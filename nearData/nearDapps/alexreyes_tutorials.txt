*GitHub Repository "alexreyes/tutorials"*

'''--- apps/transaction-seach/widget/index.html ---
<!DOCTYPE html>
<html lang="en-us">

<head>
    <script type="text/javascript" async="true" src="./lib.js"></script>
    <link href="./style.css" rel="stylesheet" type="text/css" />
</head>

<body>
    <div id="widget-content">
        <h2>Transactions</h2>
        <div id="transactions-typebox">
            <div>
                <label><input type="checkbox" name="type" value="send" >send</label>
            </div>

            <div>
                <label><input type="checkbox" name="type" value="begin_unbonding">begin_unbonding</label>
                <label><input type="checkbox" name="type" value="edit_validator">edit_validator</label>
                <label><input type="checkbox" name="type" value="create_validator">create_validator</label>
                <label><input type="checkbox" name="type" value="delegate">delegate</label>
                <label><input type="checkbox" name="type" value="begin_redelegate">begin_redelegate</label>
            </div>

            <div>
                <label><input type="checkbox" name="type" value="withdraw_delegator_reward">withdraw_delegator_reward</label>
                <label><input type="checkbox" name="type" value="withdraw_validator_commission">withdraw_validator_commission</label>
                <label><input type="checkbox" name="type" value="set_withdraw_address">set_withdraw_address</label>
                <label><input type="checkbox" name="type" value="fund_community_pool">fund_community_pool</label>
            </div>
        </div>
        <div id="transactions-container"></div>
        <div id="transactions-more">Load More</div>
    </div>

    <template id="transactionRow">
        <div class="transaction">
            <div class="transaction-head">
                <div class="height"></div>
                <div class="hash"><a></a></div>
                <div class="block"><a></a></div>
                <div class="humanTime"></div>
            </div>
            <em class="memo"></em>
            <div class="events"></div>
        </div>
    </template>

    <template id="eventRow">
        <div class="event">
            <div class="sub"></div>
        </div>
    </template>

    <template id="subRow">
        <h3 class="type"></h3>
        <div class="module-element"></div>
    </template>

    <template id="accountRow">
        <div class="account">
            <div class="id"></div>
            <div class="amount"></div>
        </div>
    </template>

    <template id="bankElem">
        <div class="senders"><h4></h4></div>
        <div class="recipients"><h4></h4></div>
    </template>

    <template id="distributionElem">
        <div class="recipients"><h4></h4></div>
        <div class="delegator"><h4></h4></div>
        <div class="withdraw"><h4></h4></div>
        <div class="validator"><h4></h4></div>
    </template>

    <template id="stakingElem">
        <div class="params">
            <div class="validator_source"><h4></h4></div>
            <div class="validator_destination"><h4></h4></div>
            <div class="delegator"><h4></h4></div>
            <div class="validator"><h4></h4></div>
        </div>
        <div class="amount"><h4></h4></div>
    </template>

    <script type="text/javascript">
        sr = new SearchRequest("cosmos", 30);

        const now = Date.now();
        sr.timeAfter(new Date(now - (1000 * 3600 * 24 * 7))); // a week ago
        sr.timeBefore(new Date(now));

        w = new Widget("transactions-container", sr);
        w.setRequest("http://localhost:8080");
        w.liveDates();
        w.initialRequest();
        w.attachEvents();
    </script>

</body>

</html>

'''
'''--- apps/transaction-seach/widget/lib.js ---
 class SearchRequest {
    constructor(network, limit) {
        this.network = network;
        if (limit === undefined) {
            this.limit = 100;
        } else {
            this.limit = limit;
        }
    }

    stringify() {
        return JSON.stringify(this)
    }

    /**
     *
     * @param {Array.<string>} accounts
     */
    addAccounts(accounts) {
        this.account = accounts;
    }

    /**
     *
     * @param {Array.<Date>} time
     */
    timeAfter(date) {
        this.after_time = date.toISOString();
    }

    /**
     *
     * @param {Array.<Date>} time
     */
    timeBefore(date) {
        this.before_time = date.toISOString();
    }

    /**
     *
     * @param {Array.<string>} accounts
     */
    addSenders(accounts) {
        this.sender = accounts;
    }

    /**
     *
     * @param {Array.<string>} accounts
     */
    addReceivers(accounts) {
        this.receiver = accounts;
    }

    /**
     *
     * @param {Array.<string>} type
     */
    addType(types) {
        this.type = types;
    }

    page(number) {
        if (number > 0 ) {
            this.offset = this.limit*number;
        }
    }
}

class Widget {
    /**
     *
     * @param {string} targetID id of target div
     * @param {SearchRequest} initialConfig initial config for onload event
     */
  constructor(targetID, initialConfig) {
    this.targetID = targetID;
    this.transactions = new Array();
    this.transactionsMap = new Map();
    this.templates = new Map();
    this.initialConfig = initialConfig;

    this.lastPage = 0;
    this.pickedTypes = new Array();
  }

  setRequest(url) {
    this.ApiURL = url;
  }

  async fetchData(data) {
    const response = await fetch(this.ApiURL +"/transactions_search", {
        method: 'POST',
        headers: {"Content-Type": "application/json"},
        body: data.stringify(data)
    });

    if (!response.ok) {
      const message = `An error has occurred: ${response.status}`;
      throw new Error(message);
    }

    const list = await response.json();
    return list
  }

  /**
   *
   * @param {SearchRequest} sr
   */
  async makeRequest(sr) {
    const response = await this.fetchData(sr)
    if (response === null || response === undefined  ) {
        return
    }
    for (let i = 0; i < response.length; i++) {
        const tx = response[i];
        if ( !this.transactionsMap.has(tx.id)) {
            tx.dirty = true;
            this.transactionsMap.set(tx.id, tx);
            this.transactions.push(tx);
        }
    }
    this.transactions.sort(compareTransactions);
    this.render();
  }

  initialRequest() {
    this.makeRequest(this.initialConfig)
  }

  loadMoreRequests() {
    const sr = this.initialConfig;
    sr.page(this.lastPage+1);
    sr.addType(this.pickedTypes);
    this.makeRequest(sr);
    this.lastPage++;
  }

  linkTemplates() {
    if (this.templates.size !== 0) {
        return
    }
    this.templates.set("transactionTemplate", document.querySelector("#transactionRow"));
    this.templates.set("eventsRowTemplate", document.querySelector("#eventRow"));
    this.templates.set("subRowTemplate", document.querySelector("#subRow"));
    this.templates.set("accountRowTemplate", document.querySelector("#accountRow"));

    this.templates.set("bankElemTemplate", document.querySelector("#bankElem"));
    this.templates.set("distributionElemTemplate", document.querySelector("#distributionElem"));
    this.templates.set("stakingElemTemplate", document.querySelector("#stakingElem"));
  }

  render() {
    this.linkTemplates();

    let transactionsList = document.querySelector("#"+ this.targetID);
    for (let i = 0; i <  this.transactions.length; i++) {
        if (this.transactions[i].dirty === undefined) {
            continue;
        }

        const elem = createTransactionElem(this.transactions[i], this.templates)
        transactionsList.appendChild(elem);
        this.transactions[i].dirty = undefined;
    }
  }

  liveDates() {
    return setInterval(this.reformatDates, 10000)
  }

  changeType() {
    this.pickedTypes = new Array();
    this.lastPage = 0;

    const checked = document.querySelectorAll('input[name=type]:checked');
    for (let i = 0; i < checked.length; i++) {
        this.pickedTypes.push(checked[i].value);
    }

    // clear current list
    let transactionsList = document.querySelector("#"+ this.targetID);
    transactionsList.innerHTML = '';

    this.transactions = new Array();
    this.transactionsMap = new Map();

    sr.page(0);
    sr.addType(this.pickedTypes);
    this.makeRequest(sr);
  }

  attachEvents() {
    const more = document.querySelector("#transactions-more");
    more.addEventListener("click", ()=> this.loadMoreRequests());

    const types = document.querySelectorAll("input[name=type]");
    for (let i = 0; i < types.length; i++) {
        types[i].addEventListener("change", (ev)=> this.changeType());
    }
  }

  reformatDates() {
    const nodes = document.querySelectorAll(".humanTime");
    let node, hour;
    const now = Date.now()
    for (let i = 0; i < nodes.length; i++) {
        node = nodes[i];
        hour = humanizeDuration(node.getAttribute("title"), now);
        if (hour !== node.innerText) {
            node.innerText = hour
        }
    }
  }
}

function compareTransactions(a,b) {
    return  b.height-a.height   // in reverse order
}

function createTransactionElem(tx, templates) {
    const clone = templates.get("transactionTemplate").content.cloneNode(true);
    const height = clone.querySelector(".height");
    height.innerText = "H: " + shotForm(tx.height, 20);
    const hashA = clone.querySelector(".hash a");
    hashA.innerText = "#: " + shotForm(tx.hash, 20);
    hashA.title = "Hash: " + tx.hash;
    hashA.href = "https://hubble.figment.io/cosmos/chains/"+ tx.chain_id + "/blocks/"+ tx.height + "/transactions/" + tx.hash;

    const time = clone.querySelector(".humanTime");
    time.title =  tx.time;
    time.innerText = humanizeDuration(tx.time, Date.now());
    const a = clone.querySelector(".block a");
    a.href = "https://hubble.figment.io/cosmos/chains/"+ tx.chain_id + "/blocks/"+ tx.height
    a.title = "Block Hash: " + tx.block_hash;
    a.innerText = shotForm(tx.block_hash, 20);

    if (tx.memo  !== undefined) {
        const memo = clone.querySelector(".memo");
        memo.classList.add("filled");
        memo.innerText = "Memo: " +  tx.memo;
    }

    const events = clone.querySelector(".events");
    for (let i = 0; i < tx.events.length; i++) {
        events.appendChild(createEventsElem(tx.events[i],templates));
    }
    return clone
}

function createEventsElem(ev, templates) {
    const clone = templates.get("eventsRowTemplate").content.cloneNode(true);
    const sub = clone.querySelector(".sub");
    for (let i = 0; i < ev.sub.length; i++) {
        sub.appendChild(createSubElem(ev.sub[i] ,templates));
    }
    return clone
}

function createSubElem(sub, templates) {
    const clone = templates.get("subRowTemplate").content.cloneNode(true);
    const kind = clone.querySelector(".type");
    kind.innerText =  sub.module + " / " + sub.type.join(" , ");

    const elm = clone.querySelector(".module-element");
    switch (sub.module) {
        case "bank":
            elm.classList.add("bank");
            elm.appendChild(createBankElem(sub, templates));
        break;
        case "distribution":
            elm.classList.add("distribution");
            elm.appendChild(createDistributionElem(sub, templates));
            break;
        case "staking":
            elm.classList.add("staking");
            elm.appendChild(createStakingElem(sub, templates));
            break;
    }
    return clone
}

function createBankElem(sub, templates) {
    const clone = templates.get("bankElemTemplate").content.cloneNode(true);
    const accountTemplate = templates.get("accountRowTemplate").content;
    if ( sub.sender != undefined ) {
        const snd = clone.querySelector(".senders");
        const head = snd.querySelector("h4");
        head.innerText = "Senders";

        let s;
        for (let i = 0; i < sub.sender.length; i++) {
            s = sub.sender[i];
            let ac = accountTemplate.cloneNode(true);
            idN = ac.querySelector(".id");
            idN.title =  s.account.id;
            idN.innerText = shotForm(s.account.id, 20);

            if (s.amounts !== undefined) {
                amountN = ac.querySelector(".amount");
                amountN.innerText = amountsToText(s.amounts);
            }
            snd.appendChild(ac);
        }
    }

    if ( sub.recipient != undefined ) {
        const rec = clone.querySelector(".recipients");
        const head = rec.querySelector("h4");
        head.innerText = "Recipients";

        let r;
        for (let i = 0; i < sub.recipient.length; i++) {
            r = sub.recipient[i];
            let ac = accountTemplate.cloneNode(true);
            idN = ac.querySelector(".id");
            idN.title =  r.account.id;
            idN.innerText = shotForm(r.account.id, 20);

            if (r.amounts !== undefined) {
                amountN = ac.querySelector(".amount");
                amountN.innerText = amountsToText(r.amounts);
            }
            rec.appendChild(ac);
        }
    }
    return clone
}

function createDistributionElem(sub, templates) {
    const clone = templates.get("distributionElemTemplate").content.cloneNode(true);
    const accountTemplate = templates.get("accountRowTemplate").content;
    if ( sub.recipient != undefined ) {
        const rec = clone.querySelector(".recipients");
        const head = rec.querySelector("h4");
        head.innerText = "Recipients";

        let r;
        for (let i = 0; i < sub.recipient.length; i++) {
            r = sub.recipient[i];
            let ac = accountTemplate.cloneNode(true);
            idN = ac.querySelector(".id");
            idN.title =  r.account.id;
            idN.innerText = shotForm(r.account.id, 20);

            if (r.amounts !== undefined) {
                amountN = ac.querySelector(".amount");
                amountN.innerText = amountsToText(r.amounts);
            }
            rec.appendChild(ac);
        }
    }

    if ( sub.node != undefined ) {
        let elems, snd, head;
        for (const key in sub.node) {
            if (sub.node.hasOwnProperty(key)) {
                elems = sub.node[key];
                snd = clone.querySelector("."+ key);
                head = snd.querySelector("h4");
                head.innerText = key;

                for (let k = 0; k < elems.length; k++) {
                    newDiv = document.createElement("div");
                    newDiv.innerText = shotForm(elems[k].id, 20);
                    snd.appendChild(newDiv);
                }
            }
        }
    }
    return clone
}

function createStakingElem(sub, templates) {
    const clone = templates.get("stakingElemTemplate").content.cloneNode(true);
    if ( sub.node != undefined ) {
        let elems, snd, head;
        for (const key in sub.node) {
            if (sub.node.hasOwnProperty(key)) {
                elems = sub.node[key];
                snd = clone.querySelector("."+ key);
                head = snd.querySelector("h4");
                head.innerText = key;

                for (let k = 0; k < elems.length; k++) {
                    newDiv = document.createElement("div");
                    newDiv.innerText = shotForm(elems[k].id, 20);
                    snd.appendChild(newDiv);
                }
                snd.classList.add("visible")
            }
        }
    }

    if ( sub.amount != undefined ) {
        const rec = clone.querySelector(".amount");
        const head = rec.querySelector("h4");
        head.innerText = "Amounts";

        for (const key in sub.amount) {
            if (sub.amount.hasOwnProperty(key)) {
                amount = sub.amount[key];
                newDiv = document.createElement("div");
                newDiv.innerText = key + ":" + amountsToText([amount]);
                rec.appendChild(newDiv);
            }
        }
    }
    return clone
}

/**
 *
 * @param {Array.<Object>} amounts
 */
function amountsToText(amounts) {
    var str = "";
    for (let i = 0; i < amounts.length; i++) {
        const am = amounts[i];
        if (am.numeric !== undefined && am.numeric !== 0 ) {
            str += " " + am.numeric + am.currency;
        } else {
            str += " " + am.text;
        }
    }
    return str;
}

/**
 *
 * @param {string} str string to shorten
 * @param {number} len length after which we need to shorten.
 */
function shotForm(str, len) {
    if (str.length > len) {
        return str.substr(0,8) + "..." + str.substr(str.length-8,8);
    }
    return str;
}

/**
 *
 * @param {string} time string with parsable date
 */
function humanizeDuration(time, now) {
    const diff = now - Date.parse(time);
    if (diff > 2592000000) { // ~ a month
        const months = Math.floor(diff / 2592000000)
        return "more than " +  months + ( (months > 1) ? " months ago" : " month ago");
    } else if (diff > 86400000) { // a day
        const days = Math.floor(diff / 86400000)
        return "more than " + days + ( (days > 1) ? " days ago" : " day ago");
    } else if (diff > 3600000) { // an hour
        const hours = Math.floor(diff / 3600000)
        return "more than " + hours + ( (hours > 1) ? " hours ago" : " hour ago");
    } else if (diff > 60000) { // a minute
        const minutes = Math.floor(diff / 60000)
        return  "more than " + minutes + ( (minutes > 1) ? " minutes ago" : " minute ago");
    } else {
        return "less than a minute ago";
    }
}

'''
'''--- apps/transaction-seach/widget/server.js ---
var http = require("http");
var https = require("https");

const PORT = process.env.PORT || 8080;
const DATAHUB_ADDRESS = process.env.DATAHUB_ADDRESS || "cosmos--search.datahub.figment.io";
const DATAHUB_KEY = process.env.DATAHUB_KEY;

//create a server object:
http.createServer(function (req, res) {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods","POST, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");

    if (req.method === "OPTIONS") {
      res.writeHead(200);
      res.end();
      return;
    }

    const options = {
      hostname: DATAHUB_ADDRESS,
      path: req.url,
      headers: {
        "authorization": DATAHUB_KEY,
        "Content-Type": "application/json",
        "accept": "*/*",
        "content-length": req.headers["content-length"],
      },
      method: "POST",
    };

    hReq = https.request(options, (innerRes) => {
      innerRes.headers['content-type'] = 'application/json';
      res.writeHead(innerRes.statusCode, innerRes.headers);

      innerRes.on("error", (error) => {
        res.write(error);
        res.end();
      });
      innerRes.on("data", (data) => {
        res.write(data);
      });

      innerRes.on("end", () => {
        res.end();
        hReq.end();
      });
    });

    req.on('data', data => {
        hReq.write(data)
    })

  })
  .listen(PORT);

'''
'''--- celo/1_connecting_to_node/connect.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Celo Network node
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  // Query chain ID
  const chainId = await web3.eth.getChainId()
    .catch((err) => { throw new Error(`Could not get chain id: ${err}`); });

  // Query chain height
  const height = await web3.eth.getBlockNumber()
    .catch((err) => { throw new Error(`Could not get block height: ${err}`); });

  console.log('ChainId:', chainId);
  console.log('Block height:', height);

  console.log('Successfully connected to Celo Network');
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/2_creating_account/create_account.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config();

const main = async () => {
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  const account =  web3.eth.accounts.create();

  console.log('address: ', account.address);
  console.log('privateKey: ', account.privateKey);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/3_query_node/query.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Celo Network node
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  // Initialize account from our private key
  const account = web3.eth.accounts.privateKeyToAccount(process.env.PRIVATE_KEY);

  // 1. Query account balances
  const accountBalances = await client.getTotalBalance(account.address)
    .catch((err) => { throw new Error(`Could not fetch account: ${err}`) });

  console.log('CELO balance: ', accountBalances.CELO.toString(10));
  console.log('cUSD balance: ', accountBalances.cUSD.toString(10));
  console.log('Locked CELO balance: ', accountBalances.lockedCELO.toString(10));
  console.log('Pending balance: ', accountBalances.pending.toString(10));

  // 2. Query node info
  const nodeInfo = await web3.eth.getNodeInfo()
    .catch((err) => { throw new Error(`Could not fetch node info: ${err}`) });
  console.log('Node Info: ', nodeInfo);

  // 3.1 Query latest block
  const blocksLatest = await web3.eth.getBlock("latest")
    .catch((err) => { throw new Error(`Could not fetch latest block: ${err}`) });
  console.log('Latest block: ', blocksLatest);

  // 3.2 Block by number, defaults to latest, lets get block 3263105
  const block = await web3.eth.getBlock(3263105)
    .catch((err) => { throw new Error(`Could not fetch block: ${err}`) });
  console.log('Block: ', block);

  // 4. Get transactions count
  const transactionCount = await web3.eth.getTransactionCount(account.address)
    .catch((err) => { throw new Error(`Could not fetch transaction count: ${err}`) });
  console.log('Transaction Count: ', transactionCount);

  // 5.Estimate gas cost
  const gasEstimate = await web3.eth.estimateGas({
    to: account.address,
    data: "0xc6888fa10000000000000000000000000000000000000000000000000000000000000003"
  }).catch((err) => { throw new Error(`Could not estimate gas: ${err}`) });
  console.log('Gas estimate: ', gasEstimate);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/4_transactions/exchange.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Celo Network node
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  // Initialize account from our private key
  const account = web3.eth.accounts.privateKeyToAccount(process.env.PRIVATE_KEY);

  // We need to add private key to ContractKit in order to sign transactions
  client.addAccount(account.privateKey);

  // Get contract wrappers
  const stableToken = await client.contracts.getStableToken();
  const exchange = await client.contracts.getExchange();

  // Get cUSD balance
  const cUsdBalance = await stableToken.balanceOf(account.address)
    .catch((err) => { throw new Error(`Could not get cUSD balance: ${err}`) });

  // Approve a user to transfer StableToken on behalf of another user.
  const approveTx = await stableToken.approve(exchange.address, cUsdBalance).send({from: account.address})
    .catch((err) => { throw new Error(`Could not send approve transaction: ${err}`) });
  const approveReceipt = await approveTx.waitReceipt();

  // Exchange cUSD for CELO
  const goldAmount = await exchange.quoteUsdSell(cUsdBalance)
    .catch((err) => { throw new Error(`Could not get a quote: ${err}`) });
  const sellTx = await exchange.sellDollar(cUsdBalance, goldAmount).send({from: account.address})
    .catch((err) => { throw new Error(`Could not send exchange transaction: ${err}`) });
  const sellReceipt = await sellTx.waitReceipt();

  // Print receipts
  console.log('Approve Transaction receipt:', approveReceipt);
  console.log('Sell Transaction receipt:', sellReceipt);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/4_transactions/transfers.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Celo Network node
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  // Initialize account from our private key
  const account = web3.eth.accounts.privateKeyToAccount(process.env.PRIVATE_KEY);

  // We need to add private key to ContractKit in order to sign transactions
  client.addAccount(account.privateKey);

  // Specify recipient Address
  const recipientAddress = '0xD86518b29BB52a5DAC5991eACf09481CE4B0710d';

  // Specify an amount to send
  const amount = 100000;

  // Get contract wrappers
  const goldtoken = await client.contracts.getGoldToken();
  const stabletoken = await client.contracts.getStableToken();

  // Transfer CELO and cUSD from your account to anAddress
  // Specify cUSD as the feeCurrency when sending cUSD
  const celotx = await goldtoken.transfer(recipientAddress, amount).send({from: account.address})
    .catch((err) => { throw new Error(`Could not transfer CELO: ${err}`) });
  const cUSDtx = await stabletoken.transfer(recipientAddress, amount).send({from: account.address, feeCurrency: stabletoken.address})
    .catch((err) => { throw new Error(`Could not transfer cUSD: ${err}`) });

  // Wait for the transactions to be processed
  const celoReceipt = await celotx.waitReceipt();
  const cUSDReceipt = await cUSDtx.waitReceipt();

  // Print receipts
  console.log('CELO Transaction receipt:', celoReceipt);
  console.log('cUSD Transaction receipt:', cUSDReceipt);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/5_contracts/interact.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');
const MetaCoin = require('./build/contracts/MetaCoin.json');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Celo Network node
  const web3 = new Web3(process.env.REST_URL);
  const client = ContractKit.newKitFromWeb3(web3);

  // Initialize account from our private key
  const account = web3.eth.accounts.privateKeyToAccount(process.env.PRIVATE_KEY);

  // We need to add private key to ContractKit in order to sign transactions
  client.addAccount(account.privateKey);

  // Check the Celo network ID
  const networkId = await web3.eth.net.getId();

  // Get the contract associated with the current network
  const deployedNetwork = MetaCoin.networks[networkId];

  if (!deployedNetwork) {
    throw new Error(`${networkId} is not valid`);
  }

  // Create a new contract instance with the MetaCoin contract info
  let instance = new web3.eth.Contract(
    MetaCoin.abi,
    deployedNetwork.address
  );

  // Get balance
  let balanceBefore = await instance.methods.getBalance(account.address).call();
  console.log('Balance before:', balanceBefore);

  // Send tokens
  const recipientAddress = '0xD86518b29BB52a5DAC5991eACf09481CE4B0710d';
  const amount = 100;

  const txObject = await instance.methods.sendCoin(recipientAddress, amount);
  let tx = await client.sendTransactionObject(txObject, { from: account.address });

  let receipt = await tx.waitReceipt();
  console.log('Sent coin smart contract call receipt: ', receipt);

  // Get balance again
  let balanceAfter = await instance.methods.getBalance(account.address).call();
  console.log('Balance after:', balanceAfter);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- celo/5_contracts/migrations/1_initial_migration.js ---
const Migrations = artifacts.require("Migrations");

module.exports = function(deployer) {
  deployer.deploy(Migrations);
};

'''
'''--- celo/5_contracts/migrations/2_deploy_contracts.js ---
const ConvertLib = artifacts.require("ConvertLib");
const MetaCoin = artifacts.require("MetaCoin");

module.exports = function(deployer) {
  deployer.deploy(ConvertLib);
  deployer.link(ConvertLib, MetaCoin);
  deployer.deploy(MetaCoin);
};

'''
'''--- celo/5_contracts/test/metacoin.js ---
const MetaCoin = artifacts.require("MetaCoin");

contract('MetaCoin', (accounts) => {
  it('should put 10000 MetaCoin in the first account', async () => {
    const metaCoinInstance = await MetaCoin.deployed();
    const balance = await metaCoinInstance.getBalance.call(accounts[0]);

    assert.equal(balance.valueOf(), 10000, "10000 wasn't in the first account");
  });
  it('should call a function that depends on a linked library', async () => {
    const metaCoinInstance = await MetaCoin.deployed();
    const metaCoinBalance = (await metaCoinInstance.getBalance.call(accounts[0])).toNumber();
    const metaCoinEthBalance = (await metaCoinInstance.getBalanceInEth.call(accounts[0])).toNumber();

    assert.equal(metaCoinEthBalance, 2 * metaCoinBalance, 'Library function returned unexpected function, linkage may be broken');
  });
  it('should send coin correctly', async () => {
    const metaCoinInstance = await MetaCoin.deployed();

    // Setup 2 accounts.
    const accountOne = accounts[0];
    const accountTwo = accounts[1];

    // Get initial balances of first and second account.
    const accountOneStartingBalance = (await metaCoinInstance.getBalance.call(accountOne)).toNumber();
    const accountTwoStartingBalance = (await metaCoinInstance.getBalance.call(accountTwo)).toNumber();

    // Make transaction from first account to second.
    const amount = 10;
    await metaCoinInstance.sendCoin(accountTwo, amount, { from: accountOne });

    // Get balances of first and second account after the transactions.
    const accountOneEndingBalance = (await metaCoinInstance.getBalance.call(accountOne)).toNumber();
    const accountTwoEndingBalance = (await metaCoinInstance.getBalance.call(accountTwo)).toNumber();

    assert.equal(accountOneEndingBalance, accountOneStartingBalance - amount, "Amount wasn't correctly taken from the sender");
    assert.equal(accountTwoEndingBalance, accountTwoStartingBalance + amount, "Amount wasn't correctly sent to the receiver");
  });
});

'''
'''--- celo/5_contracts/truffle-config.js ---
const ContractKit = require('@celo/contractkit');
const Web3 = require('web3');

require('dotenv').config({path: '../.env'});

// Create connection to DataHub Celo Network node
const web3 = new Web3(process.env.REST_URL);
const client = ContractKit.newKitFromWeb3(web3);

// Initialize account from our private key
const account = web3.eth.accounts.privateKeyToAccount(process.env.PRIVATE_KEY);

// We need to add private key to ContractKit in order to sign transactions
client.addAccount(account.privateKey);

module.exports = {
  networks: {
    test: {
      host: "127.0.0.1",
      port: 7545,
      network_id: "*"
    },
    alfajores: {
      provider: client.connection.web3.currentProvider, // CeloProvider
      network_id: 44787  // latest Alfajores network id
    }
  }
};

'''
'''--- near/1_connect_to_node/main.js ---
// Load environment variables
require("dotenv").config();

// Load Near SDK components
const near = require("near-api-js");

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  keyStore:    {} // we will configure this later
}

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const provider = client.connection.provider;
  console.log("Client config:", client.config);

  // Get current node status
  const status = await provider.status();
  console.log("Status:", status);
}

main();

'''
'''--- near/2_create_account/main.js ---
// Load environment variables
require("dotenv").config();

// Load Near SDK components
const near = require("near-api-js");
const fs = require("fs");

// Configure the irectory where Near credentials are going to be stored
const credentialsPath = "./credentials";

// Configure the keyStore to be used with the SDK
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT,
  keyStore:    keyStore
}

async function main() {
  let keyPair;

  // Configure the client with options and our local key store
  const client = await near.connect(options);

  // Configure the key pair file location
  const keyRootPath = client.connection.signer.keyStore.keyDir;
  const keyFilePath = `${keyRootPath}/${options.networkId}/${options.accountId}.json`;

  // Check if the key pair exists, and create a new one if it does not
  if (!fs.existsSync(keyFilePath)) {
    console.log("Generating a new key pair")
    keyPair = near.KeyPair.fromRandom("ed25519");
  } else {
    let content = JSON.parse(fs.readFileSync(keyFilePath).toString());
    keyPair = near.KeyPair.fromString(content.private_key);

    console.log(`Key pair for account ${options.accountId} already exists, skipping creation`);
  }

  // Create a key pair in credentials directory
  await client.connection.signer.keyStore.setKey(options.networkId, options.accountId, keyPair);

  // Determine if account already exists
  try {
    await client.account(options.accountId);
    return console.log(`Sorry, account '${options.accountId}' already exists.`);
  }
  catch (e) {
    if (!e.message.includes("does not exist while viewing")) {
      throw e;
    }
  }

  // Generate a public key for account creation step
  const publicKey = keyPair.getPublicKey()

  // Create the account
  try {
    const response = await client.createAccount(options.accountId, publicKey);
    console.log(`Account ${response.accountId} for network "${options.networkId}" was created.`);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see account in NEAR Explorer!");
    console.log(`${options.explorerUrl}/accounts/${response.accountId}`);
    console.log("----------------------------------------------------------------");
  }
  catch(error) {
    console.log("ERROR:", error);
  }
}

main();

'''
'''--- near/3_query_node/main.js ---
// Load environment variables
require("dotenv").config();

// Load Near SDK components
const near = require("near-api-js");

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT,
  keyStore:    {}
}

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const provider = client.connection.provider;

  // Get network status
  const status = await provider.status();
  console.log("network status:", status);

  // Get the latest block
  let block = await provider.block({ finality: "final" });
  console.log("current block:", block);

  // Get the block by number
  block = await provider.block({ blockId: status.sync_info.latest_block_height });
  console.log("block by height:", block);

  // Get current network validators
  const validators = await provider.validators(block.header.height);
  console.log("network validators:", validators);

  // Get account details
  const account = await client.account(options.accountId);
  console.log("account state:", await account.state());

  // Get current gas price
  gasPrice = await provider.sendJsonRpc("gas_price", [null]);
  console.log("gas price:", gasPrice);

  // Get current gas price from the block header
  const anotherBlock = await provider.sendJsonRpc("block", { finality: "final" });
  console.log("gas price from header:", anotherBlock.header.gas_price);
}

main()

'''
'''--- near/4_send_transaction/main.js ---
// Load environment variables
require("dotenv").config();

// Load NEAR components
const near = require("near-api-js");

// Formatter helper for Near amounts
function formatAmount(amount) {
  return BigInt(near.utils.format.parseNearAmount(amount.toString()));
};

// Directory where Near credentials are going to be stored
const credentialsPath = "./credentials";

// Configure the keyStore to be used with the SDK
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT,
  deps: {
    keyStore: keyStore
  }
}

// Configure transaction details
const txSender = options.accountId;
const txReceiver = "pizza.testnet";
const txAmount = formatAmount(1);

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const account = await client.account(txSender);
  const provider = client.connection.provider;

  // Create a simple money transfer using helper method
  console.log(`Sending money to ${txReceiver}`);

  try {
    const result = await account.sendMoney(txReceiver, txAmount);

    console.log("Creation result:", result.transaction);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see transaction in NEAR Explorer!");
    console.log(`${options.explorerUrl}/transactions/${result.transaction.hash}`);
    console.log("----------------------------------------------------------------");

    setTimeout(async function() {
      console.log("Checking transaction status:", result.transaction.hash);

      const status = await provider.sendJsonRpc("tx", [result.transaction.hash, options.accountId]);
      console.log("Transaction status:", status);
    }, 5000);
  }
  catch(error) {
    console.log("ERROR:", error);
  }
};

main()

'''
'''--- near/4_send_transaction/main_advanced.js ---
// Load environment variables
require("dotenv").config();

// Load NEAR components
const near = require("near-api-js");
const { sha256 } = require("js-sha256");
const fs = require("fs");

// Formatter helper for Near amounts
function formatAmount(amount) {
  return BigInt(near.utils.format.parseNearAmount(amount.toString()));
};

// Directory where Near credentials are going to be stored
const credentialsPath = "./credentials";

// Configure the keyStore to be used with the SDK
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT,
  deps: {
    keyStore: keyStore
  }
}

// Configure transaction details
const txSender = options.accountId;
const txReceiver = "pizza.testnet";
const txAmount = formatAmount(1);

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const provider = client.connection.provider;

  // Private key configuration
  const keyRootPath = client.connection.signer.keyStore.keyDir;
  const keyFilePath = `${keyRootPath}/${options.networkId}/${options.accountId}.json`;

  // Load key pair from the file
  const content = JSON.parse(fs.readFileSync(keyFilePath).toString());
  const keyPair = near.KeyPair.fromString(content.private_key);

  // Get the sender public key
  const publicKey = keyPair.getPublicKey();
  console.log("Sender public key:", publicKey.toString())

  // Get the public key information from the node
  const accessKey = await provider.query(
    `access_key/${txSender}/${publicKey.toString()}`, ""
  );
  console.log("Sender access key:", accessKey);

  // Check to make sure provided key is a full access key
  if (accessKey.permission !== "FullAccess") {
    return console.log(`Account [${txSender}] does not have permission to send tokens using key: [${publicKey}]`);
  };

  // Each transaction requires a unique number or nonce
  // This is created by taking the current nonce and incrementing it
  const nonce = ++accessKey.nonce;
  console.log("Calculated nonce:", nonce);

  // Construct actions that will be passed to the createTransaction method below
  const actions = [near.transactions.transfer(txAmount)];

  // Convert a recent block hash into an array of bytes.
  // This is required to prove the tx was recently constructed (within 24hrs)
  const recentBlockHash = near.utils.serialize.base_decode(accessKey.block_hash);

  // Create a new transaction object
  const transaction = near.transactions.createTransaction(
    txSender,
    publicKey,
    txReceiver,
    nonce,
    actions,
    recentBlockHash
  );

  // Before we can sign the transaction we must perform three steps
  // 1) Serialize the transaction in Borsh
  const serializedTx = near.utils.serialize.serialize(
    near.transactions.SCHEMA,
    transaction
  );

  // 2) Hash the serialized transaction using sha256
  const serializedTxHash = new Uint8Array(sha256.array(serializedTx));

  // 3) Create a signature using the hashed transaction
  const signature = keyPair.sign(serializedTxHash);

  // Sign the transaction
  const signedTransaction = new near.transactions.SignedTransaction({
    transaction,
    signature: new near.transactions.Signature({
      keyType: transaction.publicKey.keyType,
      data: signature.signature
    })
  });

  // Send the transaction
  try {
    const result = await provider.sendTransaction(signedTransaction);

    console.log("Creation result:", result.transaction);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see transaction in NEAR Explorer!");
    console.log(`${options.explorerUrl}/transactions/${result.transaction.hash}`);
    console.log("----------------------------------------------------------------");

    setTimeout(async function() {
      console.log("Checking transaction status:", result.transaction.hash);

      const status = await provider.sendJsonRpc("tx", [result.transaction.hash, options.accountId]);
      console.log("Transaction status:", status);
    }, 5000);
  }
  catch(error) {
    console.log("ERROR:", error);
  }
};

main()

'''
'''--- near/5_contracts/main.js ---
// Load environment variables
require("dotenv").config();

// Load Near SDK components
const near = require("near-api-js");

// Directory where Near credentials are going to be stored
const credentialsPath = "./credentials";

// Configure the keyStore to be used with the SDK
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT,
  deps: {
    keyStore: keyStore
  }
}

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const account = await client.account(options.accountId);
  const contractName = options.accountId;

  // Construct a new contract object, we'll be using it to perform calls
  const contract = new near.Contract(account, contractName, {
    viewMethods: ["getValue"],
    changeMethods: ["setValue"],
    sender: options.accountId,
  });

  // Assign a new value
  const value = (new Date()).toString();

  console.log(`Calling contract call 'setValue' with '${value}'`);
  await contract.setValue({ value: value });

  // Get the value we assigned
  console.log("Getting current value");
  result = await contract.getValue();
  console.log("Result:", result);

  // Alternative way of calling a function
  result = await account.functionCall(
    contractName,
    "getValue",
    {}
  );
  console.log(result);
};

main();

'''
'''--- secret/.eslintrc.js ---
module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  extends: [
    'airbnb-base',
  ],
  parserOptions: {
    ecmaVersion: 12,
    sourceType: 'script',
  },
  rules: {
    'no-console': 'off',
    'no-restricted-syntax': [
      'error',
      {
        selector: "CallExpression[callee.object.name='console'][callee.property.name!=/^(log|warn|error|info|trace)$/]",
        message: 'Unexpected property on console object was called',
      },
    ],
  },
};

'''
'''--- secret/1_connecting_to_node/connect.js ---
// Load SecretJS components
const { CosmWasmClient } = require('secretjs');

// Load environment variables
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Secret Network node
  const client = new CosmWasmClient(process.env.SECRET_REST_URL);

  // Query chain ID
  const chainId = await client.getChainId()
    .catch((err) => { throw new Error(`Could not get chain id: ${err}`); });

  // Query chain height
  const height = await client.getHeight()
    .catch((err) => { throw new Error(`Could not get block height: ${err}`); });

  console.log('ChainId:', chainId);
  console.log('Block height:', height);

  console.log('Successfully connected to Secret Network');
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/2_creating_account/create_account.js ---
const {
  CosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey,
} = require('secretjs');

const { Bip39, Random } = require('@iov/crypto');

require('dotenv').config();

const main = async () => {
  // Create random address and mnemonic
  const mnemonic = Bip39.encode(Random.getBytes(16)).toString();

  // This wraps a single keypair and allows for signing.
  const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    .catch((err) => { throw new Error(`Could not get signing pen: ${err}`); });

  // Get the public key
  const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);

  // Get the wallet address
  const accAddress = pubkeyToAddress(pubkey, 'secret');

  // Query the account
  const client = new CosmWasmClient(process.env.SECRET_REST_URL);
  const account = await client.getAccount(accAddress)
    .catch((err) => { throw new Error(`Could not get account: ${err}`); });

  console.log('mnemonic: ', mnemonic);
  console.log('address: ', accAddress);
  console.log('account: ', account);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/3_query_node/query.js ---
const {
  CosmWasmClient,
} = require('secretjs');

require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Secret Network node
  const client = new CosmWasmClient(process.env.SECRET_REST_URL);

  // 1. Query node info
  const nodeInfo = await client.restClient.nodeInfo()
    .catch((err) => { throw new Error(`Could not fetch node info: ${err}`); });
  console.log('Node Info: ', nodeInfo);

  // 2.1 Query latest blocks
  const blocksLatest = await client.restClient.blocksLatest()
    .catch((err) => { throw new Error(`Could not fetch latest block: ${err}`); });
  console.log('Latest block: ', blocksLatest);

  // 2.2 Block by number, defaults to latest, lets get block 42
  const blocks = await client.restClient.blocks(42)
    .catch((err) => { throw new Error(`Could not fetch block: ${err}`); });
  console.log('Blocks: ', blocks);

  // 3. Query account
  const account = await client.getAccount(process.env.ADDRESS)
    .catch((err) => { throw new Error(`Could not fetch account: ${err}`); });
  console.log('Account: ', account);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/4_transactions/send.js ---
const {
  CosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, makeSignBytes,
} = require('secretjs');

require('dotenv').config();

const main = async () => {
  // As in previous tutorial, initialise client from ENV
  const mnemonic = process.env.MNEMONIC;
  const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    .catch((err) => { throw new Error(`Could not get signing pen: ${err}`); });
  const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
  const accAddress = pubkeyToAddress(pubkey, 'secret');
  const client = new CosmWasmClient(process.env.SECRET_REST_URL);

  // Optionally, define a memo for the transaction
  const memo = 'My first secret transaction, sending uscrt to my own address';

  // 1. Define TX message
  const sendMsg = {
    type: 'cosmos-sdk/MsgSend',
    value: {
      from_address: accAddress,
      to_address: accAddress,
      amount: [
        {
          denom: 'uscrt',
          amount: '1000000',
        },
      ],
    },
  };

  // 2. Define fees
  const fee = {
    amount: [
      {
        amount: '50000',
        denom: 'uscrt',
      },
    ],
    gas: '100000',
  };

  // 3. Sign transaction
  const chainId = await client.getChainId()
    .catch((err) => { throw new Error(`Could not get chain id: ${err}`); });
  const { accountNumber, sequence } = await client.getNonce(accAddress)
    .catch((err) => { throw new Error(`Could not get nonce: ${err}`); });
  const signBytes = makeSignBytes([sendMsg], fee, chainId, memo, accountNumber, sequence);
  const signature = await signingPen.sign(signBytes)
    .catch((err) => { throw new Error(`Could not sign: ${err}`); });
  const signedTx = {
    msg: [sendMsg],
    fee,
    memo,
    signatures: [signature],
  };

  // 4. Broadcast TX
  const { transactionHash } = await client.postTx(signedTx)
    .catch((err) => { throw new Error(`Could not post tx: ${err}`); });

  // 5. Query TX by hash/ID
  const query = { id: transactionHash };
  const tx = await client.searchTx(query)
    .catch((err) => { throw new Error(`Could not search tx: ${err}`); });
  console.log('Transaction: ', tx);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/4_transactions/transfer.js ---
const {
  EnigmaUtils, SigningCosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey,
} = require('secretjs');

require('dotenv').config();

const main = async () => {
  const mnemonic = process.env.MNEMONIC;
  const httpUrl = process.env.SECRET_REST_URL;
  const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    .catch((err) => { throw new Error(`Could not get signing pen: ${err}`); });
  const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
  const accAddress = pubkeyToAddress(pubkey, 'secret');

  // 1. Initialise client
  const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
  const fees = {
    send: {
      amount: [{ amount: '80000', denom: 'uscrt' }],
      gas: '80000',
    },
  };
  const client = new SigningCosmWasmClient(
    httpUrl,
    accAddress,
    (signBytes) => signingPen.sign(signBytes),
    txEncryptionSeed, fees,
  );

  // 2. Send tokens
  const rcpt = accAddress; // Set recipient to sender for testing, or generate another account as you did previously.

  // optional memo
  const memo = 'sendTokens example';

  // Send 1 SCRT / 1000000 uscrt
  const sent = await client.sendTokens(rcpt, [{ amount: '1000000', denom: 'uscrt' }], memo)
    .catch((err) => { throw new Error(`Could not send tokens: ${err}`); });
  console.log('sent', sent);

  // 3. Query the tx result
  const query = { id: sent.transactionHash };
  const tx = await client.searchTx(query)
    .catch((err) => { throw new Error(`Could not execute the search: ${err}`); });
  console.log('Transaction: ', tx);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/5_contracts/main.js ---
const {
  EnigmaUtils, Secp256k1Pen, SigningCosmWasmClient, pubkeyToAddress, encodeSecp256k1Pubkey,
} = require('secretjs');

const fs = require('fs');

// Load environment variables
require('dotenv').config();

const customFees = {
  upload: {
    amount: [{ amount: '2000000', denom: 'uscrt' }],
    gas: '2000000',
  },
  init: {
    amount: [{ amount: '500000', denom: 'uscrt' }],
    gas: '500000',
  },
  exec: {
    amount: [{ amount: '500000', denom: 'uscrt' }],
    gas: '500000',
  },
  send: {
    amount: [{ amount: '80000', denom: 'uscrt' }],
    gas: '80000',
  },
};

const main = async () => {
  const httpUrl = process.env.SECRET_REST_URL;

  // Use key created in tutorial #2
  const mnemonic = process.env.MNEMONIC;

  // A pen is the most basic tool you can think of for signing.
  // This wraps a single keypair and allows for signing.
  const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    .catch((err) => { throw new Error(`Could not get signing pen: ${err}`); });

  // Get the public key
  const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);

  // get the wallet address
  const accAddress = pubkeyToAddress(pubkey, 'secret');

  // 1. Initialize client
  const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();

  const client = new SigningCosmWasmClient(
    httpUrl,
    accAddress,
    (signBytes) => signingPen.sign(signBytes),
    txEncryptionSeed, customFees,
  );
  console.log(`Wallet address=${accAddress}`);

  // 2. Upload the contract wasm
  const wasm = fs.readFileSync('5_contracts/contract.wasm');
  console.log('Uploading contract');
  const uploadReceipt = await client.upload(wasm, {})
    .catch((err) => { throw new Error(`Could not upload contract: ${err}`); });

  // 3. Create an instance of the Counter contract
  // Get the code ID from the receipt
  const { codeId } = uploadReceipt;

  // Create an instance of the Counter contract, providing a starting count
  const initMsg = { count: 101 };
  const contract = await client.instantiate(codeId, initMsg, `My Counter${Math.ceil(Math.random() * 10000)}`)
    .catch((err) => { throw new Error(`Could not instantiate contract: ${err}`); });
  const { contractAddress } = contract;
  console.log('contract: ', contract);

  // 4. Query the counter
  console.log('Querying contract for current count');
  let response = await client.queryContractSmart(contractAddress, { get_count: {} })
    .catch((err) => { throw new Error(`Could not query contract: ${err}`); });

  console.log(`Count=${response.count}`);

  // 5. Increment the counter
  const handleMsg = { increment: {} };
  console.log('Updating count');
  response = await client.execute(contractAddress, handleMsg)
    .catch((err) => { throw new Error(`Could not execute contract: ${err}`); });
  console.log('response: ', response);

  // Query again to confirm it worked
  console.log('Querying contract for updated count');
  response = await client.queryContractSmart(contractAddress, { get_count: {} })
    .catch((err) => { throw new Error(`Could not query contract: ${err}`); });

  console.log(`New Count=${response.count}`);
};

main().catch((err) => {
  console.error(err);
});

'''
'''--- secret/6_delegations/delegate.js ---
const {
    CosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, makeSignBytes
} = require("secretjs");

require('dotenv').config();

const main = async () => {
    const mnemonic = process.env.MNEMONIC;
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const accAddress = pubkeyToAddress(pubkey, 'secret');
    const client = new CosmWasmClient(process.env.SECRET_REST_URL);
    // Define the validator address to delegate
    const valAddress = '<VALIDATOR ADDRESS YOU WANT TO DELEGATE>';

    const memo = 'My first secret delegation';

    const sendMsg = {
        type: "cosmos-sdk/MsgDelegate",
        value: {
            delegator_address: accAddress,
            validator_address: valAddress,
            amount: {
                denom: "uscrt",
                amount: "1000000",
            },
        },
    };

    const fee = {
        amount: [
            {
                amount: "50000",
                denom: "uscrt",
            },
        ],
        gas: "200000",
    };

    const chainId = await client.getChainId();
    const { accountNumber, sequence } = await client.getNonce(accAddress);
    const signBytes = makeSignBytes([sendMsg], fee, chainId, memo, accountNumber, sequence);
    const signature = await signingPen.sign(signBytes);
    const signedTx = {
        msg: [sendMsg],
        fee: fee,
        memo: memo,
        signatures: [signature],
    };
    const { logs, transactionHash } = await client.postTx(signedTx);

    // Query the tx result
    const query = {id: transactionHash}
    const tx = await client.searchTx(query)
    console.log('Transaction: ', tx);
}

main().then(resp => {
    console.log(resp);
}).catch(err => {
    console.log(err);
})
'''
'''--- secret/6_delegations/unbond.js ---
const {
    CosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, makeSignBytes
} = require("secretjs");

require('dotenv').config();

const main = async () => {
    const mnemonic = process.env.MNEMONIC;
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic);
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const accAddress = pubkeyToAddress(pubkey, 'secret');
    const client = new CosmWasmClient(process.env.SECRET_REST_URL);
    // Define the validator address to unbond
    const valAddress = '<VALIDATOR ADDRESS YOU WANT TO UNBOND>';

    const memo = 'My first secret unbonding';

    const sendMsg = {
        type: "cosmos-sdk/MsgUndelegate",
        value: {
            delegator_address: accAddress,
            validator_address: valAddress,
            amount: {
                denom: "uscrt",
                amount: "1000000",
            },
        },
    };

    const fee = {
        amount: [
            {
                amount: "50000",
                denom: "uscrt",
            },
        ],
        gas: "200000",
    };

    const chainId = await client.getChainId();
    const { accountNumber, sequence } = await client.getNonce(accAddress);
    const signBytes = makeSignBytes([sendMsg], fee, chainId, memo, accountNumber, sequence);
    const signature = await signingPen.sign(signBytes);
    const signedTx = {
        msg: [sendMsg],
        fee: fee,
        memo: memo,
        signatures: [signature],
    };
    const { logs, transactionHash } = await client.postTx(signedTx);

    // Query the tx result
    const query = {id: transactionHash}
    const tx = await client.searchTx(query)
    console.log('Transaction: ', tx);
}

main().then(resp => {
    console.log(resp);
}).catch(err => {
    console.log(err);
})
'''
'''--- terra/1_connecting_to_node/connect.js ---
const { LCDClient } = require('@terra-money/terra.js');
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Terra node
  const terra = new LCDClient({
    URL: process.env.TERRA_NODE_URL,
    chainID: process.env.TERRA_CHAIN_ID,
  });

  console.log('Successfully connected to Terra node');
}

main().then(resp => {
  console.log(resp);
}).catch(err => {
  console.log(err);
})

'''
'''--- terra/2_creating_account/create_account.js ---
const { LCDClient, MnemonicKey } = require('@terra-money/terra.js');
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Terra node
  const terra = new LCDClient({
    URL: process.env.TERRA_NODE_URL,
    chainID: process.env.TERRA_CHAIN_ID,
  });

  // Create random address and mnemonic
  const mk = new MnemonicKey();

  console.log('mnemonic: ', mk.mnemonic);
  console.log('address: ', mk.accAddress);
}

main().then(resp => {
  console.log(resp);
}).catch(err => {
  console.log(err);
})

'''
'''--- terra/3_query_node/query.js ---
const { LCDClient, MnemonicKey } = require('@terra-money/terra.js');
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Terra node
  const terra = new LCDClient({
    URL: process.env.TERRA_NODE_URL,
    chainID: process.env.TERRA_CHAIN_ID,
  });

  // Use key created in tutorial #2
  const mk = new MnemonicKey({
    mnemonic: process.env.MNEMONIC,
  });

  // 1. Query state of chain
  const blockInfo = await terra.tendermint.blockInfo();
  console.log('blockInfo: ', blockInfo);
}

main().then(resp => {
  console.log(resp);
}).catch(err => {
  console.log(err);
})

'''
'''--- terra/4_transactions/send.js ---
const { LCDClient, MnemonicKey, MsgSend, isTxError } = require('@terra-money/terra.js');
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Terra node
  const terra = new LCDClient({
    URL: process.env.TERRA_NODE_URL,
    chainID: process.env.TERRA_CHAIN_ID,
  });

  // Use key created in tutorial #2
  const mk = new MnemonicKey({
    mnemonic: process.env.MNEMONIC,
  });

  // Create a wallet out of you mnemonic key
  const wallet = terra.wallet(mk);

  const toAddress = 'terra1uwqg9vvg82sw29xuun777547jg8tnfrdh673fl';

  // Create a message
  const msg = new MsgSend(
    wallet.key.accAddress,
    toAddress,
    { uluna: 10 }
  );

  // Create and sign transaction
  const tx = await wallet.createAndSignTx({
    msgs: [msg],
    memo: "Hello from Figment Learn"
  });

  // Broadcast transaction
  const txResult = await terra.tx.broadcast(tx);

  // Get transaction hash
  const txHash = await terra.tx.hash(tx);
  console.log('txHash: ', txHash);

  if (isTxError(txResult)) {
    throw new Error(`encountered an error while running the transaction: ${txResult.code} ${txResult.codespace}`);
  }

  // Check for events from the first message
  console.log('logs: ', txResult.logs);
}

main().then(resp => {
  console.log(resp);
}).catch(err => {
  console.log(err);
})

'''
'''--- terra/4_transactions/swap.js ---
const { LCDClient, MnemonicKey, MsgSwap, isTxError, Coin } = require('@terra-money/terra.js');
require('dotenv').config();

const main = async () => {
  // Create connection to DataHub Terra node
  const terra = new LCDClient({
    URL: process.env.TERRA_NODE_URL,
    chainID: process.env.TERRA_CHAIN_ID,
  });

  // Use key created in tutorial #2
  const mk = new MnemonicKey({
    mnemonic: process.env.MNEMONIC,
  });

  // Create a wallet out of you mnemonic key
  const wallet = terra.wallet(mk);

  // Create a message
  const swap = new MsgSwap(
    wallet.key.accAddress,
    new Coin('uluna', '1000'),
    'uusd'
  );

  // Create and sign transaction
  const tx = await wallet.createAndSignTx({
    msgs: [swap],
    memo: "Hello from Figment Learn"
  });

  // Broadcast transaction
  const txResult = await terra.tx.broadcast(tx);

  // Get transaction hash
  const txHash = await terra.tx.hash(tx);
  console.log('txHash: ', txHash);

  if (isTxError(txResult)) {
    throw new Error(`encountered an error while running the transaction: ${txResult.code} ${txResult.codespace}`);
  }

  // Check for events from the first message
  console.log('logs: ', txResult.logs);
}

main().then(resp => {
  console.log(resp);
}).catch(err => {
  console.log(err);
})

'''