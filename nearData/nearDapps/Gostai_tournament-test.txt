*GitHub Repository "Gostai/tournament-test"*

'''--- Calls.txt ---
near call $NFT_CONTRACT_ID create '{"tournament_id": "tournament-3", "name": "Tournament-3", "icon": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif" , "players_number": 8, "in_price": "100000000000000000000000" , "tournament_owner_id": "'$NFT_CONTRACT_ID'", "percents_map": {"1":50, "2":30, "3":10}}' --accountId $NFT_CONTRACT_ID

near view $NFT_CONTRACT_ID display_tournament '{"tournament_id": "tournament-1"}'

near view $NFT_CONTRACT_ID display_tournaments '{"tournament_id": "tournament-1"}'

near view $NFT_CONTRACT_ID display_freeplaces_in_tournament '{"tournament_id": "tournament-1"}'

participate_tournament

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-1"}' --accountId $NFT_CONTRACT_ID --amount 0.2

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-1"}' --accountId dgstai.testnet --amount 1

near call $NFT_CONTRACT_ID reward_prizes '{"tournament_id": "tournament-1", "winners_map": {"1":"tournament.dgstai.testnet", "2":"dgstai.testnet" }}' --accountId $NFT_CONTRACT_ID

2

near call $NFT_CONTRACT_ID tournament_create '{"tournament_id": "tournament-2", "name": "Tournament-1", "icon": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif" , "players_number": 8, "in_price": "100000000000000000000000" , "tournament_owner_id": "'$NFT_CONTRACT_ID'", "percents_map": {"1":50, "2":30, "3":10}}' --accountId $NFT_CONTRACT_ID

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-2"}' --accountId $NFT_CONTRACT_ID --amount 0.2

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-2"}' --accountId dgstai.testnet --amount 1

near call $NFT_CONTRACT_ID reward_prizes '{"tournament_id": "tournament-2", "winners_map": {"1":"tournament.dgstai.testnet", "2":"dgstai.testnet" }}' --accountId $NFT_CONTRACT_ID

3

near call $NFT_CONTRACT_ID create '{"tournament_id": "tournament-3", "name": "Tournament-3", "icon": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif" , "players_number": 8, "in_price": "100000000000000000000000" , "tournament_owner_id": "'$NFT_CONTRACT_ID'", "percents_map": {"1":50, "2":30, "3":10}}' --accountId $NFT_CONTRACT_ID

near view $NFT_CONTRACT_ID display_tournament '{"tournament_id": "tournament-3"}'

near view $NFT_CONTRACT_ID display_tournaments 

near view $NFT_CONTRACT_ID display_freeplaces_in_tournament '{"tournament_id": "tournament-3"}'

participate_tournament

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-3"}' --accountId $NFT_CONTRACT_ID --amount 0.2

near call $NFT_CONTRACT_ID participate_tournament '{"tournament_id": "tournament-3"}' --accountId dgstai.testnet --amount 1

near call $NFT_CONTRACT_ID reward_prizes '{"tournament_id": "tournament-3", "winners_map": {"1":"tournament.dgstai.testnet", "2":"dgstai.testnet" }}' --accountId $NFT_CONTRACT_ID

'''
'''--- package.json ---
{
    "name": "tournament-test",
    "version": "1.0.0",
    "description": "Tournament smart contarct for NEAR",
    "author": "D G",
    "license": "ISC",
    "scripts": {
        "build": "cd tournament-contract && bash build.sh && cd ../.."
    }
}

'''
'''--- tournament-contract/Cargo.toml ---
[package]
name = "tournament-test"
version = "0.1.0"
authors = ["D G"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.4"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- tournament-contract/README.md ---
# TOURNAMENT

'''
'''--- tournament-contract/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm
'''
'''--- tournament-contract/src/event.rs ---
use near_sdk::env;
use near_sdk::serde::{Serialize};

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
pub(crate) enum NearEvent<'a> {
    Mf1(crate::tournament::events::EventLog<'a>),    
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
} 

'''
'''--- tournament-contract/src/lib.rs ---
use std::collections::HashMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    env, near_bindgen, AccountId,  CryptoHash, PanicOnDefault,  BorshStorageKey
};
mod tournament;
use crate::tournament::*;
mod macros;
mod event;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {    
    owner_id: AccountId,
    tournament: TournamentContract,
    metadata: LazyOption<TournamentContractMetadata>, 
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    PlayersPerTournament,
    WinnersPercentPerTournament,
    PlayersPerTournamentInner { tournament_id_hash: CryptoHash },
    TournamentsById,
    TournamentMetadataById,
    TournamentContractMetadata,   
    PrizesPerTournamentInner { tournament_id_hash: CryptoHash },   
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        //calls the other function "new: with some default metadata and the owner_id passed in 
        Self::new(
            owner_id,
            TournamentContractMetadata {                
                name: "Tournament Test Contract".to_string(),                
                icon: None,                
            },
        )
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    #[init]
    pub fn new(owner_id: AccountId, metadata: TournamentContractMetadata) -> Self {
        let metadata = LazyOption::new(
            StorageKey::TournamentContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
        );
        
        let tournament = TournamentContract::new(            
            StorageKey::PlayersPerTournament,            
            StorageKey::WinnersPercentPerTournament,           
            StorageKey::TournamentsById,            
            StorageKey::TournamentMetadataById,
        );
        
        Self {
            owner_id: owner_id.clone(),
            tournament,
            metadata,
        }
    }        
}

pub trait ContractMetadata {
    //view call for returning the contract metadata
    fn contract_metadata(&self) -> TournamentContractMetadata;
}

#[near_bindgen]
impl ContractMetadata for Contract {
    fn contract_metadata(&self) -> TournamentContractMetadata {
        self.metadata.get().unwrap()
    }
}

impl_tournament_contract_core!(Contract, tournament);
impl_tournament_contract_enumeration!(Contract, tournament);

'''
'''--- tournament-contract/src/macros.rs ---
/// The core methods for a basic tournament. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_tournament_contract_core {
    ($contract: ident, $tournament: ident) => {
        use $crate::tournament::tournament_core::TournamentContractCore;
        
        #[near_bindgen]
        impl TournamentContractCore for $contract {
            fn tournament_create(
                &mut self,
                tournament_id: TournamentId,
                name: String,
                icon: Option<String>,
                players_number: u8,
                in_price: U128,        
                tournament_owner_id: AccountId,
                percents_map: HashMap<u8,u8>,
            ) {
                self.$tournament.tournament_create(tournament_id, name, icon, players_number, in_price, tournament_owner_id, percents_map)
            }
        
            fn display_tournament(
                &self,
                tournament_id: TournamentId
            ) -> Option<JsonTournament> {
                self.$tournament.display_tournament(tournament_id)
            }
            
            #[payable]
            fn participate_tournament(
                &mut self,
                tournament_id: TournamentId
            ) {
                self.$tournament.participate_tournament(tournament_id)
            }    
            
            fn display_freeplaces_in_tournament(
                &self,
                tournament_id: TournamentId
            ) -> Option<U64> {
                self.$tournament.display_freeplaces_in_tournament(tournament_id)
            } 
            
            fn reward_prizes(
                &mut self, 
                tournament_id: TournamentId, 
                winners_map: HashMap<u8,AccountId>
            ) {
                self.$tournament.reward_prizes(tournament_id, winners_map)
            }
        }
    };
}

/// Tournament enumeration adds the extension standard offering 
/// view-only methods.
#[macro_export]
macro_rules! impl_tournament_contract_enumeration {
    ($contract: ident, $tournament: ident) => {
        use $crate::tournament::enumeration::TournamentContractEnumeration;

        #[near_bindgen]
        impl TournamentContractEnumeration for $contract {
            
            fn display_tournaments(
                &self, 
                from_index: Option<U128>,
                limit: Option<u64>
            ) -> Vec<JsonTournament> {
                self.$tournament.display_tournaments(from_index, limit)
            }   
        }
    };
}

'''
'''--- tournament-contract/src/tournament/enumeration.rs ---
use crate::*;

pub trait TournamentContractEnumeration{
    //Query for  tournaments on the contract regardless of the ID using pagination
    fn display_tournaments(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonTournament>;
}

impl TournamentContractEnumeration for TournamentContract {    
    //Query for  tournaments on the contract regardless of the ID using pagination
    fn display_tournaments(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonTournament> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each tournament using an iterator
        self.tournament_metadata_by_id.keys()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|tournament_id| self.display_tournament(tournament_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }    
}

'''
'''--- tournament-contract/src/tournament/events.rs ---
use crate::event::NearEvent;
use near_sdk::{AccountId};
use near_sdk::json_types::{U128};
use near_sdk::serde::{Serialize};

/// Enum that represents the data type of the EventLog.
#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
#[serde(crate = "near_sdk::serde")]
pub enum EventLogVariant<'a> {
    TournamentCreate(&'a [TournamentCreateLog<'a>]),
    TournamentEntrance(&'a [TournamentEntranceLog<'a>]),
    TournamentPrizesReward(&'a [TournamentPrizesRewardLog<'a>]),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub(crate) struct EventLog<'a> {    
    pub version: &'static str,
    
    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant<'a>,
}

/// An event log to capture tournament creation
///
/// Arguments
/// * `tournament_id`: "tournament-1" 
/// * `players_number`: 8
/// * `in_price`: "100000"
#[must_use]
#[derive(Serialize,  Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TournamentCreateLog<'a> {    
    pub tournament_id: &'a String,
    pub players_number: &'a u8,
    pub in_price:&'a U128,
}

impl TournamentCreateLog<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }
    
    pub fn emit_many(data: &[TournamentCreateLog<'_>]) {
        new_mf1_v1(EventLogVariant::TournamentCreate(data)).emit()
    }
}

/// An event log to capture tournament entrance
///
/// Arguments
/// * `partisipator_id`: "partisipator.near"
/// * `tournament_id`: "tournament-1"
#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TournamentEntranceLog<'a> { 
    pub partisipator_id:&'a AccountId,
    pub tournament_id:&'a String,    
} 

impl TournamentEntranceLog<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }
    
    pub fn emit_many(data: &[TournamentEntranceLog<'_>]) {
        new_mf1_v1(EventLogVariant::TournamentEntrance(data)).emit()
    }
}

/// An event log to capture tournament prize rewarding
///
/// Arguments
/// * `tournament_id`: "tournament-1"
/// * `rewarded_amount`: "100000000"
#[derive(Serialize,  Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TournamentPrizesRewardLog<'a> {     
    pub tournament_id:&'a String,    
    pub rewarded_amount:&'a u128,
} 

impl TournamentPrizesRewardLog<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }
    
    pub fn emit_many(data: &[TournamentPrizesRewardLog<'_>]) {
        new_mf1_v1(EventLogVariant::TournamentPrizesReward(data)).emit()
    }
}

fn new_mf1<'a>(version: &'static str, event: EventLogVariant<'a>) -> NearEvent<'a> {
  NearEvent::Mf1(EventLog { version, event })
}

fn new_mf1_v1(event: EventLogVariant) -> NearEvent {
  new_mf1("1.0.0", event)
}

'''
'''--- tournament-contract/src/tournament/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_tournament_id(tournament_id: &TournamentId, shift: &String) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    
    //we hash the tournament ID with shift and return it
    hash.copy_from_slice(&env::sha256((tournament_id.to_owned()+shift).as_bytes()));
    
    hash
}

//calculates the percents from the amount
pub(crate) fn percent_calculation ( &percent_value: &u128, &amount: &u128)-> u128 {    
    let mut percent_amount: u128 = (percent_value * amount)/100;    
    let reminder = (percent_value * amount)%100;                
        if reminder!=0{
            if ((amount * 10 )/reminder) > 4 {
                percent_amount+=1;
            } 
        }        
    return percent_amount;        
}

impl TournamentContract {
    //add prize values in percents to the tournament
    pub(crate) fn internal_add_prizes_to_tournament(
        &mut self,
        tournament_id: &TournamentId,
        percents_map: &HashMap<u8,u8>
        
    ) {
        //get the map of prizes for the given tournament
        let mut prizes_map = self.winners_percents_per_tournament.get(tournament_id).unwrap_or_else(|| {
            //if the tournament doesn't have any players, we create a new map 
            LookupMap::new(
                StorageKey::PrizesPerTournamentInner {
                    //we get a new unique prefix for the collection
                    tournament_id_hash: hash_tournament_id(&tournament_id, &"m".to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        for (key, value) in percents_map {
            prizes_map.insert(&key, &value);
        }        

        //we insert that map for the given tournament ID. 
        self.winners_percents_per_tournament.insert(tournament_id, &prizes_map);
    }    
    
    //add a player to the set of players the tournament has
    pub(crate) fn internal_add_player_to_tournament(
        &mut self,
        tournament_id: &TournamentId,
        player: &AccountId,        
    ) -> bool {    
        //get the set of players for the given tournament
        let mut players_set = self.players_per_tournament.get(tournament_id).unwrap_or_else(|| {
            //if the tournament doesn't have any players, we create a new unordered set
            UnorderedSet::new(
                StorageKey::PlayersPerTournamentInner {
                    //we get a new unique prefix for the collection
                    tournament_id_hash: hash_tournament_id(&tournament_id, &"s".to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the player ID into the set
        let new_one = players_set.insert(player);

        //we insert that set for the given tournament ID. 
        self.players_per_tournament.insert(&tournament_id, &players_set);
        
        new_one
    }
    
    //get number of players already in the tournament
    pub(crate) fn internal_get_players_number_in_tournament(
        &self,
        tournament_id: &TournamentId,     
    ) -> u8 {    
        //get the set of tokens for the given account
        if let Some (players_set) = self.players_per_tournament.get(tournament_id) {
            players_set.len() as u8
        } else {
            0
        }   
    }
} 

'''
'''--- tournament-contract/src/tournament/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{U64, U128};
use near_sdk::{AccountId};

pub type TournamentId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TournamentContractMetadata {
    pub name: String,                
    pub icon: Option<String>,               
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TournamentMetadata {
    pub name: String,                
    pub icon: Option<String>,
    pub players_number: u8,
    pub in_price: u128,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Tournament {
    pub owner_id: AccountId,
    pub active: bool,
    pub balance: u128,
}

//The Json tournament is what will be returned from view calls. 
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonTournament {
    //tournament ID
    pub tournament_id: TournamentId,
    //owner of the tournament
    pub owner_id: AccountId,
    //tournament metadata
    pub metadata: TournamentMetadata,
    
    pub first_place_prize: U64,
    
    pub second_place_prize: U64,
    
    pub third_place_prize: U64,
    
    //is the tournament active
    pub active: bool,
    
    //total prize fond for the tournament
    pub prize_fond: U128,    
}

'''
'''--- tournament-contract/src/tournament/mod.rs ---
pub mod tournament_core;
mod metadata;
mod internal;
//mod create;
pub mod enumeration;
pub mod events;

pub use self::metadata::*;
//pub use self::create::*;
pub use self::tournament_core::TournamentContract;
pub use self::tournament_core::TournamentContractCore;
pub use self::enumeration::*;

'''
'''--- tournament-contract/src/tournament/tournament_core.rs ---
use near_sdk::{env, IntoStorageKey, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{ LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{ U64, U128};
use std::collections::HashMap;
use crate::tournament::events::{TournamentCreateLog, TournamentEntranceLog, TournamentPrizesRewardLog};

use crate::tournament::metadata::{
    TournamentId, Tournament, TournamentMetadata, JsonTournament
};

use crate::tournament::internal::{percent_calculation};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TournamentContract {  
    //keeps track of all the players IDs for a given tournament
    pub players_per_tournament: LookupMap<TournamentId, UnorderedSet<AccountId>>,
    
    //keeps winners refund distribution in percents for a given tournament
    pub winners_percents_per_tournament: LookupMap<TournamentId, LookupMap<u8,u8>>,

    //keeps track of the tournament struct for a given tournament ID
    pub tournaments_by_id: LookupMap<TournamentId, Tournament>,

    //keeps track of the tournament metadata for a given tournament ID
    pub tournament_metadata_by_id: UnorderedMap<TournamentId, TournamentMetadata>,    
}

impl TournamentContract {
    pub fn new<P,W,TI,TM>(        
        players_per_tournament_prefix: P,       
        winners_percents_per_tournament: W,
        tournaments_by_id: TI,
        tournament_metadata_by_id: TM,
    ) -> Self
        where 
            P: IntoStorageKey,
            W: IntoStorageKey,
            TI: IntoStorageKey,
            TM: IntoStorageKey,
    {
        let this = Self {
            players_per_tournament: LookupMap::new(players_per_tournament_prefix),
            winners_percents_per_tournament: LookupMap::new(winners_percents_per_tournament),
            tournaments_by_id:LookupMap::new(tournaments_by_id),
            tournament_metadata_by_id: UnorderedMap::new(tournament_metadata_by_id),
        };
        
        this
    }    
}

pub trait TournamentContractCore {   
    //tournament creation method
    fn tournament_create(
        &mut self,
        tournament_id: TournamentId,
        name: String,
        icon: Option<String>,
        players_number: u8,
        in_price: U128,        
        tournament_owner_id: AccountId,
        percents_map: HashMap<u8,u8>,
    );

    //get the information for a specific tournament ID
    fn display_tournament(&self, tournament_id: TournamentId) -> Option<JsonTournament>;
    
    //add player to the tournament with NEAR depositing
    fn participate_tournament(&mut self, tournament_id: TournamentId);
    
    //get free places in the tournament
    fn display_freeplaces_in_tournament(&self, tournament_id: TournamentId) -> Option<U64>;
    
    //refunds the prizes for the winners 
    fn reward_prizes(&mut self, tournament_id: TournamentId, winners_map: HashMap<u8,AccountId>);
}

impl TournamentContractCore for TournamentContract {

    //tournament creation method
    fn tournament_create(
        &mut self,
        tournament_id: TournamentId,
        name: String,
        icon: Option<String>,
        players_number: u8,
        in_price: U128,        
        tournament_owner_id: AccountId,
        percents_map: HashMap<u8,u8>,
    ) {            
        assert!(u128::from(in_price)>0,"Tournaments with zero in prise are not allowed");
        
        //specify the tornament struct that contains the owner ID 
        let tournament = Tournament {
            //set the owner ID equal to the tournament owner ID passed into the function
            owner_id: tournament_owner_id,
            active: true,
            balance: 0,            
        };

        //insert the tornament ID and tournament struct and make sure that the tournament doesn't exist
        assert!(
            self.tournaments_by_id.insert(&tournament_id, &tournament).is_none(),
            "Tornament already exists"
        );
        
        //specify the tournament metadata struct
        let metadata = TournamentMetadata {
            name: name,                
            icon: icon,
            players_number: players_number,
            in_price: u128::from(in_price),
        };

        //insert the tornament ID and metadata
        self.tournament_metadata_by_id.insert(&tournament_id, &metadata);
        
        //insert the prizes percents for the tournament ID
        self.internal_add_prizes_to_tournament(&tournament_id, &percents_map);
        
        TournamentCreateLog{
            tournament_id: &tournament_id,
            players_number: &players_number,
            in_price: &in_price,
        }.emit();
    }

    //get the information for a specific tournament ID
    fn display_tournament(&self, tournament_id: TournamentId) -> Option<JsonTournament> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(tournament) = self.tournaments_by_id.get(&tournament_id) {        
            //we'll get the metadata for that token
            let metadata = self.tournament_metadata_by_id.get(&tournament_id).unwrap();
            
            let prizes = self.winners_percents_per_tournament.get(&tournament_id).unwrap();
            
            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonTournament {
                tournament_id,
                owner_id: tournament.owner_id,
                metadata,
                first_place_prize: (prizes.get(&1).unwrap() as u64).into(),
                second_place_prize: (prizes.get(&2).unwrap() as u64).into(),
                third_place_prize: (prizes.get(&3).unwrap() as u64).into(),
                active: tournament.active,
                prize_fond: tournament.balance.into(),
            })
        } else { 
            //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }     
    }
    
    //add player to the tournament with NEAR depositing
    //#[payable]
    fn participate_tournament(&mut self, tournament_id: TournamentId) {    
        let account_id: &AccountId = &env::predecessor_account_id();
        
        let attached_deposit: Balance = env::attached_deposit();  
        
        if let Some(mut tournament) = self.tournaments_by_id.get(&tournament_id) {
            //check activeness of the tournament
            assert!(tournament.active, "Tournament is inactive");
            
            //we'll get the metadata for that tournament
            let metadata = self.tournament_metadata_by_id.get(&tournament_id).unwrap();
            
            //Check there are some free playses for the players in the tournament
            assert!(
                metadata.players_number-self.internal_get_players_number_in_tournament(&tournament_id)>0,
                "Tournament is already full of players",
            );
            
            //check the is enouph deposit attached to players account
            assert!(attached_deposit >= metadata.in_price, "Deposit is too small. Attached: {}, Required: {}", attached_deposit, metadata.in_price);
            
            //check for double participation
            assert!(self.internal_add_player_to_tournament(&tournament_id,&account_id), "Already in the tournament");
            
            //save the prize fond balanse of the tournament 
            tournament.balance+=metadata.in_price;
            self.tournaments_by_id.insert(&tournament_id, &tournament);
            
            TournamentEntranceLog{
                partisipator_id: &account_id,
                tournament_id: &tournament_id,                
            }.emit();
            
            //get the refund amount from the attached deposit - required cost
            let refund = attached_deposit - metadata.in_price;
            
            //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
            if refund > 1 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }        
        }        
    }
    
    //get free playses in the tournament  
    fn display_freeplaces_in_tournament(&self, tournament_id: TournamentId) -> Option<U64> {                
        //if there is some tournament ID in the tournaments_by_id collection
        if let Some(_tournament) = self.tournaments_by_id.get(&tournament_id) {
            //we'll get the metadata for that tournament
            let metadata = self.tournament_metadata_by_id.get(&tournament_id).unwrap();
            
            //calculate free places
            let free_places = metadata.players_number-self.internal_get_players_number_in_tournament(&tournament_id);
            
            //return free places
            Some((free_places as u64).into())
            
        } else { 
            //if there wasn't a tournament_id ID in the tournaments_by_id collection, we return None
            None
        }
    }
    
    //refunds the prizes for the winners 
    fn reward_prizes(&mut self, tournament_id: TournamentId, winners_map: HashMap<u8,AccountId>) {        
        //if there is some tournament ID in the tournaments_by_id collection
        if let Some(mut tournament) = self.tournaments_by_id.get(&tournament_id) {            
            //check the owner calls this method
            assert_eq!(env::predecessor_account_id(), tournament.owner_id, "Owner's method");
            
            //check the tournament is active
            assert!(tournament.active, "Tournament is inactive");            
            
            //get prizes values in persent for the places
            let prizes_map = self.winners_percents_per_tournament.get(&tournament_id).unwrap();
            
            //summarize the rewards
            let mut sum_reward = 0;
            
            //reward prizes
            for (place,account) in winners_map {
                //get percents to the place
                let percents: u128 = prizes_map.get(&place).unwrap().into();
                
                //calculate the percents of the prize fond
                let reward_amount = percent_calculation(&percents, &tournament.balance);
                
                //refund the prize
                Promise::new(account).transfer(reward_amount);
                
                //summarize the rewards
                sum_reward+=reward_amount;
            }
            
            //decrease the prize fond of tournament 
            tournament.balance-=sum_reward;
            
            //inactivate the tournament
            tournament.active=false;
            
            self.tournaments_by_id.insert(&tournament_id, &tournament);        
            
            TournamentPrizesRewardLog{                
                tournament_id: &tournament_id,    
                rewarded_amount: &sum_reward,
            }.emit();
        }                 
    }    
}

'''