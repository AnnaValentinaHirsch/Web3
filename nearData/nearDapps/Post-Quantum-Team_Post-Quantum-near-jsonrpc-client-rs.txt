*GitHub Repository "Post-Quantum-Team/Post-Quantum-near-jsonrpc-client-rs"*

'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.4.0] - 2022-10-04

- Updated nearcore dependencies, which now requires a MSRV of `1.64.0`. <https://github.com/near/near-jsonrpc-client-rs/pull/100>, <https://github.com/near/near-jsonrpc-client-rs/pull/110>
- Updated other dependencies, with some general improvements. <https://github.com/near/near-jsonrpc-client-rs/pull/111>
- Added `rustls-tls` feature flag to enable `rustls` as an alternative to `native-tls`. <https://github.com/near/near-jsonrpc-client-rs/pull/103>
- Switched to using `log::debug!` instead of `log::info!` for debug logging. <https://github.com/near/near-jsonrpc-client-rs/pull/107>
- Fixed `gas_price` RPC method serialization. <https://github.com/near/near-jsonrpc-client-rs/pull/73>
- Fixed `query` method error deserialization. <https://github.com/near/near-jsonrpc-client-rs/pull/82>
- Reworked the `JsonRpcError`::`handler_error` method. <https://github.com/near/near-jsonrpc-client-rs/pull/99>
- Moved auth specific logic behind a feature flag. <https://github.com/near/near-jsonrpc-client-rs/pull/55>
- Added the `methods::to_json()` helper method for visualizing the serialization of the RPC methods. <https://github.com/near/near-jsonrpc-client-rs/pull/49>

## [0.4.0-beta.0] - 2022-05-31

<details>
<summary>
  <em>
    Superseded by <a href="https://github.com/near/near-jsonrpc-client-rs/compare/v0.4.0-beta.0...v0.4.0">
      <code> 0.4.0 </code>
    </a>
  </em>
</summary>

> - Updated nearcore dependencies, fixing a previous breaking change. <https://github.com/near/near-jsonrpc-client-rs/pull/100>
> - Fixed `gas_price` RPC method serialization. <https://github.com/near/near-jsonrpc-client-rs/pull/73>
> - Fixed `query` method error deserialization. <https://github.com/near/near-jsonrpc-client-rs/pull/82>
> - Reworked the `JsonRpcError`::`handler_error` method. <https://github.com/near/near-jsonrpc-client-rs/pull/99>
> - Moved auth specific logic behind a feature flag. <https://github.com/near/near-jsonrpc-client-rs/pull/55>
> - Added the `methods::to_json()` helper method for visualizing the serialization of the RPC methods. <https://github.com/near/near-jsonrpc-client-rs/pull/49>

</details>

## [0.3.0] - 2022-02-09

- Dropped generic authentication and added support for custom headers. <https://github.com/near/near-jsonrpc-client-rs/pull/47>
- Added the `sandbox_fast_forward` RPC Method. <https://github.com/near/near-jsonrpc-client-rs/pull/38>
- Upgraded `nearcore` crates to `v0.12.0` <https://github.com/near/near-jsonrpc-client-rs/pull/48>
- Executing the [examples](https://github.com/near/near-jsonrpc-client-rs/tree/master/examples) now allows custom RPC addr specification with interactive server selection. <https://github.com/near/near-jsonrpc-client-rs/commit/b130118d0de806bd9950be306f563559f07c77e6> <https://github.com/near/near-jsonrpc-client-rs/commit/c5e938a90703cb216e99d6f23a43ad9d3812df3d>
- `JsonRpcClient::connect` is now generic over any url-like type. [`Url`](https://docs.rs/url/*/url/struct.Url.html), `&str`, `String` and `&String` are all supported. <https://github.com/near/near-jsonrpc-client-rs/pull/35>
- `JsonRpcClient` now defaults to the `Unauthenticated` state, easing a type specification pain point. <https://github.com/near/near-jsonrpc-client-rs/pull/36>

## [0.2.0] - 2021-12-22

- Updated nearcore version to `0.11.0` (<https://github.com/near/nearcore/pull/5943>).
- Fixed `chunk` method serialization. <https://github.com/near/near-jsonrpc-client-rs/commit/f40ad743653ad2a1a9eb5eaa96c302c9b531bf40>
- `Client::call` no longer consumes the client. <https://github.com/near/near-jsonrpc-client-rs/commit/471a53be062e0880c6bc5c2721d123da2a9e0c2e>
- Implemented workaround for partially serialized server responses. <https://github.com/near/near-jsonrpc-client-rs/pull/29>
- Dropped base64 API token support in favor of a generic key-value approach. <https://github.com/near/near-jsonrpc-client-rs/commit/dd7761b51e1775350be1782370aa22c0b0fe98d7>
- Added examples to repo. <https://github.com/near/near-jsonrpc-client-rs/pull/32>
- Ensured `None`-typed wrapped errors are actual errors (i.e. have all traits attributed with errors, especially `fmt::Display`). <https://github.com/near/near-jsonrpc-client-rs/pull/34>

## [0.1.0] - 2021-11-11

> Release Page: <https://github.com/near/near-jsonrpc-client-rs/releases/tag/v0.1.0>

[unreleased]: https://github.com/near/near-jsonrpc-client-rs/compare/v0.4.0...HEAD
[0.4.0]: https://github.com/near/near-jsonrpc-client-rs/compare/v0.3.0...v0.4.0
[0.4.0-beta.0]: https://github.com/near/near-jsonrpc-client-rs/compare/v0.3.0...v0.4.0-beta.0
[0.3.0]: https://github.com/near/near-jsonrpc-client-rs/compare/v0.2.0...v0.3.0
[0.2.0]: https://github.com/near/near-jsonrpc-client-rs/compare/v0.1.0...v0.2.0
[0.1.0]: https://github.com/near/near-jsonrpc-client-rs/releases/tag/v0.1.0

'''
'''--- Cargo.toml ---
[package]
name = "near-jsonrpc-client"
version = "0.0.0" # managed by cargo-workspaces, see below
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"
license = "MIT OR Apache-2.0"
repository = "https://github.com/near/near-jsonrpc-client-rs"
description = "Lower-level API for interfacing with the NEAR Protocol via JSONRPC"
categories = ["asynchronous", "api-bindings", "network-programming"]
keywords = ["near", "api", "jsonrpc", "rpc", "async"]
rust-version = "1.64.0"

# cargo-workspaces
[workspace.metadata.workspaces]
version = "0.4.0"

[dependencies]
log = "0.4.17"
uuid = { version = "1.1.2", features = ["v4"], optional = true }
borsh = "0.9.3"
serde = "1.0.145"
reqwest = { version = "0.11.12", features = ["json"], default-features = false }
thiserror = "1.0.37"
serde_json = "1.0.85"
lazy_static = "1.4.0"

near-crypto = { git = "https://github.com/Post-Quantum-Team/Post-Quantum-Nearcore", branch = "crates-0.15.0-Post-Quantum" }
near-primitives = { git = "https://github.com/Post-Quantum-Team/Post-Quantum-Nearcore", branch = "crates-0.15.0-Post-Quantum" }
near-chain-configs = { git = "https://github.com/Post-Quantum-Team/Post-Quantum-Nearcore", branch = "crates-0.15.0-Post-Quantum" }
near-jsonrpc-primitives = { git = "https://github.com/Post-Quantum-Team/Post-Quantum-Nearcore", branch = "crates-0.15.0-Post-Quantum" }

[dev-dependencies]
tokio = { version = "1.21.2", features = ["macros", "rt-multi-thread"] }
env_logger = "0.9.1"

[features]
default = ["auth", "native-tls"]
any = []
auth = ["uuid"]
sandbox = []
adversarial = []
native-tls = ["reqwest/native-tls"]
rustls-tls = ["reqwest/rustls-tls"]

[[example]]
name = "auth"
required-features = ["auth"]

[package.metadata.docs.rs]
features = ["any", "auth", "sandbox"]

'''
'''--- README.md ---
# near-jsonrpc-client

## WARNING

This crate is based on the tag v0.4.0 of the official near-jsonrpc-client crate.
It will be used by the Post-Quantum-Near-CLI-RS.

## Introduction

Lower-level API for interfacing with the NEAR Protocol via JSONRPC.

[![Crates.io](https://img.shields.io/crates/v/near-jsonrpc-client?label=latest)](https://crates.io/crates/near-jsonrpc-client)
[![Documentation](https://docs.rs/near-jsonrpc-client/badge.svg)](https://docs.rs/near-jsonrpc-client)
[![MIT or Apache 2.0 Licensed](https://img.shields.io/crates/l/near-jsonrpc-client.svg)](#license)
[![Dependency Status](https://deps.rs/crate/near-jsonrpc-client/0.4.0/status.svg)](https://deps.rs/crate/near-jsonrpc-client/0.4.0)

## Usage

Each one of the valid JSON RPC methods are defined in the `methods` module.
For instance, to make a `tx` request, you start with the `tx` module
and construct a request using the `methods::tx::RpcTransactionStatusRequest` struct.

```rust
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::transactions::TransactionInfo;

let mainnet_client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");

let tx_status_request = methods::tx::RpcTransactionStatusRequest {
    transaction_info: TransactionInfo::TransactionId {
        hash: "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U".parse()?,
        account_id: "miraclx.near".parse()?,
    },
};

// call a method on the server via the connected client
let tx_status = mainnet_client.call(tx_status_request).await?;

println!("{:?}", tx_status);
```

Check out [`the examples folder`](https://github.com/near/near-jsonrpc-client-rs/tree/master/examples) for a comprehensive list of helpful demos. You can run the examples with `cargo`. For example: `cargo run --example view_account`.

For all intents and purposes, the predefined structures in `methods` should suffice, if you find that they
don't or you crave extra flexibility, well, you can opt in to use the generic constructor `methods::any()` with the `any` feature flag.

In this example, we retrieve only the parts from the genesis config response that we care about.

```toml
# in Cargo.toml
near-jsonrpc-client = { ..., features = ["any"] }
```

```rust
use serde::Deserialize;
use serde_json::json;

use near_jsonrpc_client::{methods, JsonRpcClient};
use near_primitives::serialize::dec_format;
use near_primitives::types::*;

#[derive(Debug, Deserialize)]
struct PartialGenesisConfig {
    protocol_version: ProtocolVersion,
    chain_id: String,
    genesis_height: BlockHeight,
    epoch_length: BlockHeightDelta,
    #[serde(with = "dec_format")]
    min_gas_price: Balance,
    #[serde(with = "dec_format")]
    max_gas_price: Balance,
    #[serde(with = "dec_format")]
    total_supply: Balance,
    validators: Vec<AccountInfo>,
}

impl methods::RpcHandlerResponse for PartialGenesisConfig {}

let mainnet_client = JsonRpcClient::connect("https://rpc.mainnet.near.org");

let genesis_config_request = methods::any::<Result<PartialGenesisConfig, ()>>(
    "EXPERIMENTAL_genesis_config",
    json!(null),
);

let partial_genesis = mainnet_client.call(genesis_config_request).await?;

println!("{:#?}", partial_genesis);
```

By default, `near-jsonrpc-client` uses `native-tls`. On Linux, this introduces a dependency on the system `openssl` library. In some situations, for example when cross-compiling, it can be problematic to depend on non-Rust libraries.

If you wish to switch to an all-Rust TLS implementation, you may do so using the `rustls-tls` feature flag. Note that the `native-tls` feature is enabled by default. Therefore, to disable it and use `rustls-tls` instead, you must also use `default-features = false`. The default `auth` feature must then be declared explicitly.

```toml
# in Cargo.toml
near-jsonrpc-client = { ..., default-features = false, features = ["auth","rustls-tls"] }
```

## Releasing

Versioning and releasing of this crate is automated and managed by [custom fork](https://github.com/miraclx/cargo-workspaces/tree/grouping-versioning-and-exclusion) of [`cargo-workspaces`](https://github.com/pksunkara/cargo-workspaces). To publish a new version of this crate, you can do so by bumping the `version` under the `[workspace.metadata.workspaces]` section in the [package manifest](https://github.com/near/near-jsonrpc-client-rs/blob/master/Cargo.toml) and submit a PR.

We have CI Infrastructure put in place to automate the process of publishing all crates once a version change has merged into master.

However, before you release, make sure the [CHANGELOG](https://github.com/near/near-jsonrpc-client-rs/blob/master/CHANGELOG.md) is up to date and that the `[Unreleased]` section is present but empty.

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- examples/access_keys.rs ---
use near_jsonrpc_client::methods;
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::BlockReference;

mod utils;

fn indent(indentation: usize, s: String) -> String {
    let mut lines = s.split_inclusive("\n");
    let mut r = lines.next().unwrap().to_string();
    for l in lines {
        r.push_str(&" ".repeat(indentation - 3));
        r.push_str("\x1b[38;5;244m>\x1b[0m ");
        r.push_str(l);
    }
    r
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    let account_id = utils::input("Enter the Account ID whose keys we're listing: ")?.parse()?;

    let access_key_query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccessKeyList { account_id },
        })
        .await?;

    if let QueryResponseKind::AccessKeyList(response) = access_key_query_response.kind {
        for access_key in response.keys {
            println!("🗝 [{}]", access_key.public_key);
            println!("     \u{21b3}      nonce: {}", access_key.access_key.nonce);
            println!(
                "     \u{21b3} permission: {}",
                indent(20, format!("{:#?}", access_key.access_key.permission))
            );
        }
    }

    Ok(())
}

'''
'''--- examples/auth.rs ---
use near_jsonrpc_client::errors::{
    JsonRpcError::ServerError, JsonRpcServerError::ResponseStatusError,
    JsonRpcServerResponseStatusError::Unauthorized,
};
use near_jsonrpc_client::{auth, methods, JsonRpcClient};
use near_primitives::types::{BlockReference, Finality};

async fn unauthorized() -> Result<(), Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let response = client.call(request).await;

    assert!(
        matches!(
            response,
            Err(ServerError(ResponseStatusError(Unauthorized)))
        ),
        "got {:?}",
        response
    );

    Ok(())
}

async fn authorized() -> Result<(), Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect("https://rpc.testnet.near.org")
        .header(auth::ApiKey::new("399ba741-e939-4ffa-8c3c-306ec36fa8de")?);

    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let response = client.call(request).await?;

    println!("{:#?}", response);

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    unauthorized().await?;

    authorized().await?;

    Ok(())
}

'''
'''--- examples/contract_change_method.rs ---
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_jsonrpc_primitives::types::transactions::TransactionInfo;
use near_primitives::transaction::{Action, FunctionCallAction, Transaction};
use near_primitives::types::BlockReference;

use serde_json::json;
use tokio::time;

mod utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

    let signer_account_id = utils::input("Enter the signer Account ID: ")?.parse()?;
    let signer_secret_key = utils::input("Enter the signer's private key: ")?.parse()?;

    let signer = near_crypto::InMemorySigner::from_secret_key(signer_account_id, signer_secret_key);

    let access_key_query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: signer.account_id.clone(),
                public_key: signer.public_key.clone(),
            },
        })
        .await?;

    let current_nonce = match access_key_query_response.kind {
        QueryResponseKind::AccessKey(access_key) => access_key.nonce,
        _ => Err("failed to extract current nonce")?,
    };

    let other_account = utils::input("Enter the account to be rated: ")?;
    let rating = utils::input("Enter a rating: ")?.parse::<f32>()?;

    let transaction = Transaction {
        signer_id: signer.account_id.clone(),
        public_key: signer.public_key.clone(),
        nonce: current_nonce + 1,
        receiver_id: "nosedive.testnet".parse()?,
        block_hash: access_key_query_response.block_hash,
        actions: vec![Action::FunctionCall(FunctionCallAction {
            method_name: "rate".to_string(),
            args: json!({
                "account_id": other_account,
                "rating": rating,
            })
            .to_string()
            .into_bytes(),
            gas: 100_000_000_000_000, // 100 TeraGas
            deposit: 0,
        })],
    };

    let request = methods::broadcast_tx_async::RpcBroadcastTxAsyncRequest {
        signed_transaction: transaction.sign(&signer),
    };

    let sent_at = time::Instant::now();
    let tx_hash = client.call(request).await?;

    loop {
        let response = client
            .call(methods::tx::RpcTransactionStatusRequest {
                transaction_info: TransactionInfo::TransactionId {
                    hash: tx_hash,
                    account_id: signer.account_id.clone(),
                },
            })
            .await;
        let received_at = time::Instant::now();
        let delta = (received_at - sent_at).as_secs();

        if delta > 60 {
            Err("time limit exceeded for the transaction to be recognized")?;
        }

        match response {
            Err(err) => match err.handler_error() {
                Some(methods::tx::RpcTransactionError::UnknownTransaction { .. }) => {
                    time::sleep(time::Duration::from_secs(2)).await;
                    continue;
                }
                _ => Err(err)?,
            },
            Ok(response) => {
                println!("response gotten after: {}s", delta);
                println!("response: {:#?}", response);
                break;
            }
        }
    }

    Ok(())
}

'''
'''--- examples/contract_change_method_commit.rs ---
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::transaction::{Action, FunctionCallAction, Transaction};
use near_primitives::types::BlockReference;

use serde_json::json;

mod utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

    let signer_account_id = utils::input("Enter the signer Account ID: ")?.parse()?;
    let signer_secret_key = utils::input("Enter the signer's private key: ")?.parse()?;

    let signer = near_crypto::InMemorySigner::from_secret_key(signer_account_id, signer_secret_key);

    let access_key_query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: signer.account_id.clone(),
                public_key: signer.public_key.clone(),
            },
        })
        .await?;

    let current_nonce = match access_key_query_response.kind {
        QueryResponseKind::AccessKey(access_key) => access_key.nonce,
        _ => Err("failed to extract current nonce")?,
    };

    let other_account = utils::input("Enter the account to be rated: ")?;
    let rating = utils::input("Enter a rating: ")?.parse::<f32>()?;

    let transaction = Transaction {
        signer_id: signer.account_id.clone(),
        public_key: signer.public_key.clone(),
        nonce: current_nonce + 1,
        receiver_id: "nosedive.testnet".parse()?,
        block_hash: access_key_query_response.block_hash,
        actions: vec![Action::FunctionCall(FunctionCallAction {
            method_name: "rate".to_string(),
            args: json!({
                "account_id": other_account,
                "rating": rating,
            })
            .to_string()
            .into_bytes(),
            gas: 100_000_000_000_000, // 100 TeraGas
            deposit: 0,
        })],
    };

    let request = methods::broadcast_tx_commit::RpcBroadcastTxCommitRequest {
        signed_transaction: transaction.sign(&signer),
    };

    let response = client.call(request).await?;

    println!("response: {:#?}", response);

    Ok(())
}

'''
'''--- examples/contract_view_code.rs ---
use near_jsonrpc_client::methods;
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{AccountId, BlockReference, Finality};
use near_primitives::views::QueryRequest;

mod utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    let contract_id: AccountId =
        utils::input("Enter the contract whose code we're downloading: ")?.parse()?;

    let request = methods::query::RpcQueryRequest {
        block_reference: BlockReference::Finality(Finality::Final),
        request: QueryRequest::ViewCode {
            account_id: contract_id.clone(),
        },
    };

    let response = client.call(request).await?;

    if let QueryResponseKind::ViewCode(result) = response.kind {
        let path = format!("/tmp/{}.wasm", contract_id);
        println!("⚙️  [{}]", contract_id);
        println!("🏋        size: {} bytes", result.code.len());
        std::fs::write(&path, result.code)?;
        println!("💾   saved to: {}", path);
    }

    Ok(())
}

'''
'''--- examples/contract_view_method.rs ---
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{BlockReference, Finality, FunctionArgs};
use near_primitives::views::QueryRequest;

use serde::Deserialize;
use serde_json::{from_slice, json};

mod utils;

#[derive(Debug, Deserialize)]
pub struct AccountStatus {
    pub rating: f32,
    pub given: u64,
    pub received: u64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

    let account_id = utils::input("Enter the account to view: ")?;

    let request = methods::query::RpcQueryRequest {
        block_reference: BlockReference::Finality(Finality::Final),
        request: QueryRequest::CallFunction {
            account_id: "nosedive.testnet".parse()?,
            method_name: "status".to_string(),
            args: FunctionArgs::from(
                json!({
                    "account_id": account_id,
                })
                .to_string()
                .into_bytes(),
            ),
        },
    };

    let response = client.call(request).await?;

    if let QueryResponseKind::CallResult(result) = response.kind {
        println!("{:#?}", from_slice::<AccountStatus>(&result.result)?);
    }

    Ok(())
}

'''
'''--- examples/create_account.rs ---
//! Creates an account on the network.
//!
//! Creates either;
//! - a top-level mainnet / testnet account
//! - or a sub-account for any account on the network.
//!
//! top-level account example: `miraclx.near` creates `foobar.near`
//! sub-account example: `miraclx.near` creates `test.miraclx.near`
//!
//! This script is interactive.

use near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError;
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_jsonrpc_primitives::types::transactions::TransactionInfo;
use near_primitives::hash::CryptoHash;
use near_primitives::transaction::{
    Action, AddKeyAction, CreateAccountAction, FunctionCallAction, Transaction, TransferAction,
};
use near_primitives::types::{AccountId, BlockReference};

use serde_json::json;
use tokio::time;

mod utils;

async fn account_exists(
    client: &JsonRpcClient,
    account_id: &AccountId,
) -> Result<bool, Box<dyn std::error::Error>> {
    let access_key_query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccount {
                account_id: account_id.clone(),
            },
        })
        .await;

    match access_key_query_response {
        Ok(_) => Ok(true),
        Err(near_jsonrpc_client::errors::JsonRpcError::ServerError(
            near_jsonrpc_client::errors::JsonRpcServerError::HandlerError(
                near_jsonrpc_primitives::types::query::RpcQueryError::UnknownAccount { .. },
            ),
        )) => Ok(false),
        Err(res) => Err(res)?,
    }
}

async fn get_current_nonce(
    client: &JsonRpcClient,
    account_id: &AccountId,
    public_key: &near_crypto::PublicKey,
) -> Result<Option<(CryptoHash, u64)>, Box<dyn std::error::Error>> {
    let query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: account_id.clone(),
                public_key: public_key.clone(),
            },
        })
        .await;

    match query_response {
        Ok(access_key_query_response) => match access_key_query_response.kind {
            QueryResponseKind::AccessKey(access_key) => Ok(Some((
                access_key_query_response.block_hash,
                access_key.nonce,
            ))),
            _ => Err("failed to extract current nonce")?,
        },
        Err(near_jsonrpc_client::errors::JsonRpcError::ServerError(
            near_jsonrpc_client::errors::JsonRpcServerError::HandlerError(
                near_jsonrpc_primitives::types::query::RpcQueryError::UnknownAccessKey { .. },
            ),
        )) => Ok(None),
        Err(res) => Err(res)?,
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    let signer_account_id = loop {
        let signer_account_id = utils::input("Enter the creators Account ID: ")?.parse()?;
        if account_exists(&client, &signer_account_id).await? {
            break signer_account_id;
        }
        println!("(i) This account doesn't exist, please reenter!");
    };

    let (signer, latest_hash, current_nonce) = loop {
        let signer_secret_key = utils::input("Enter the creators's private key: ")?.parse()?;

        let signer = near_crypto::InMemorySigner::from_secret_key(
            signer_account_id.clone(),
            signer_secret_key,
        );

        if let Some((latest_hash, current_nonce)) =
            get_current_nonce(&client, &signer.account_id, &signer.public_key).await?
        {
            break (signer, latest_hash, current_nonce);
        }
        println!("(i) Invalid access key, please reenter!");
    };

    let new_account_id = loop {
        let new_account_id = utils::input("What's the new Account ID: ")?.parse()?;
        if !account_exists(&client, &new_account_id).await? {
            break new_account_id;
        }
        println!("(i) This account already exists, please reenter!");
    };

    let initial_deposit = loop {
        let deposit: f64 =
            utils::input("How much do you want to fund this account with (in Ⓝ units)? ")?
                .parse()?;
        if deposit >= 0.0 {
            break ((deposit * 1_000_000.0) as u128) * 1_000_000_000_000_000_000 as u128;
        }
        println!("(i) Enter a non-zero deposit value!");
    };

    let is_sub_account = new_account_id.is_sub_account_of(&signer.account_id);
    let new_key_pair = near_crypto::SecretKey::from_random(near_crypto::KeyType::FALCON512);

    let transaction = if is_sub_account {
        Transaction {
            signer_id: signer.account_id.clone(),
            public_key: signer.public_key.clone(),
            nonce: current_nonce + 1,
            receiver_id: new_account_id.clone(),
            block_hash: latest_hash,
            actions: vec![
                Action::CreateAccount(CreateAccountAction {}),
                Action::AddKey(AddKeyAction {
                    access_key: near_primitives::account::AccessKey {
                        nonce: 0,
                        permission: near_primitives::account::AccessKeyPermission::FullAccess,
                    },
                    public_key: new_key_pair.public_key(),
                }),
                Action::Transfer(TransferAction {
                    deposit: initial_deposit,
                }),
            ],
        }
    } else {
        let contract_id = if client.server_addr().ends_with("testnet.near.org") {
            "testnet".parse()?
        } else if client.server_addr().ends_with("mainnet.near.org") {
            "near".parse()?
        } else {
            Err("can only create non-sub accounts for mainnet / testnet\nconsider creating a sub-account instead")?
        };
        Transaction {
            signer_id: signer.account_id.clone(),
            public_key: signer.public_key.clone(),
            nonce: current_nonce + 1,
            receiver_id: contract_id,
            block_hash: latest_hash,
            actions: vec![Action::FunctionCall(FunctionCallAction {
                method_name: "create_account".to_string(),
                args: json!({
                    "new_account_id": new_account_id,
                    "new_public_key": new_key_pair.public_key(),
                })
                .to_string()
                .into_bytes(),
                gas: 300_000_000_000_000,
                deposit: initial_deposit,
            })],
        }
    };

    println!("=============================================================");
    println!("New Account ID: {}", new_account_id);
    println!("    Secret Key: {}", new_key_pair);
    println!("    Public Key: {}", new_key_pair.public_key());
    println!("       Deposit: {}", initial_deposit);
    println!("-------------------------------------------------------------");

    let request = methods::broadcast_tx_async::RpcBroadcastTxAsyncRequest {
        signed_transaction: transaction.sign(&signer),
    };

    let sent_at = time::Instant::now();

    let tx_hash = client.call(request).await?;

    println!("       Tx Hash: {}", tx_hash);
    println!("=============================================================");

    loop {
        let response = client
            .call(methods::tx::RpcTransactionStatusRequest {
                transaction_info: TransactionInfo::TransactionId {
                    hash: tx_hash,
                    account_id: signer.account_id.clone(),
                },
            })
            .await;
        let received_at = time::Instant::now();
        let delta = (received_at - sent_at).as_secs();

        if delta > 60 {
            Err("time limit exceeded for the transaction to be recognized")?;
        }

        match response {
            Ok(
                ref outcome @ near_primitives::views::FinalExecutionOutcomeView {
                    status: near_primitives::views::FinalExecutionStatus::SuccessValue(ref s),
                    ..
                },
            ) => {
                // outcome.status != SuccessValue(`false`)
                if s == b"false" {
                    println!("(i) Account successfully created after {}s", delta);
                } else {
                    println!("{:#?}", outcome);
                    println!("(!) Creating the account failed, check above for full logs");
                }
                break;
            }
            Ok(near_primitives::views::FinalExecutionOutcomeView {
                status: near_primitives::views::FinalExecutionStatus::Failure(err),
                ..
            }) => {
                println!("{:#?}", err);
                println!("(!) Creating the account failed, check above for full logs");
                break;
            }
            Err(err) => match err.handler_error() {
                Some(
                    RpcTransactionError::TimeoutError
                    | methods::tx::RpcTransactionError::UnknownTransaction { .. },
                ) => {
                    time::sleep(time::Duration::from_secs(2)).await;
                    continue;
                }
                _ => Err(err)?,
            },
            _ => {}
        }
    }

    Ok(())
}

'''
'''--- examples/query_block.rs ---
use near_jsonrpc_client::methods;

mod utils;

pub fn specify_block_reference() -> std::io::Result<near_primitives::types::BlockReference> {
    println!("=========[Block Reference]=========");
    let block_reference = utils::select(
        || {
            println!(" [1] final        \x1b[38;5;244m(alias: f, fin)\x1b[0m");
            println!(" [2] optimistic   \x1b[38;5;244m(alias: o, opt)\x1b[0m");
            println!(" [3] block hash   \x1b[38;5;244m(alias: s, hash)\x1b[0m");
            println!(" [4] block height \x1b[38;5;244m(alias: h, height)\x1b[0m");
        },
        "\x1b[33m(enter a selection)\x1b[0m> ",
        |selection| match (selection, selection.parse()) {
            ("f" | "fin" | "final", _) | (_, Ok(1)) => {
                Some(near_primitives::types::BlockReference::Finality(
                    near_primitives::types::Finality::Final,
                ))
            }
            ("o" | "opt" | "optimistic", _) | (_, Ok(2)) => {
                Some(near_primitives::types::BlockReference::Finality(
                    near_primitives::types::Finality::None,
                ))
            }
            ("s" | "hash" | "block hash", _) | (_, Ok(3)) => loop {
                match utils::input("What block hash should we query? ")
                    .unwrap()
                    .parse()
                {
                    Ok(block_hash) => {
                        break Some(near_primitives::types::BlockReference::BlockId(
                            near_primitives::types::BlockId::Hash(block_hash),
                        ))
                    }
                    _ => println!("(i) Invalid block hash, please reenter!"),
                }
            },
            ("h" | "height" | "block height", _) | (_, Ok(4)) => loop {
                match utils::input("What block height should we query? ")
                    .unwrap()
                    .parse()
                {
                    Ok(block_height) => {
                        break Some(near_primitives::types::BlockReference::BlockId(
                            near_primitives::types::BlockId::Height(block_height),
                        ))
                    }
                    _ => println!("(i) Invalid block height, please reenter!"),
                }
            },
            _ => None,
        },
    )?;
    println!("===================================");

    Ok(block_reference)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    // tolerate only 3 retries
    for _ in 1..=3 {
        let block_reference = specify_block_reference()?;

        match client
            .call(methods::block::RpcBlockRequest { block_reference })
            .await
        {
            Ok(block_details) => println!("{:#?}", block_details),
            Err(err) => match err.handler_error() {
                Some(methods::block::RpcBlockError::UnknownBlock { .. }) => {
                    println!("(i) Unknown block!");
                    continue;
                }
                Some(err) => {
                    println!("(i) An error occurred `{:#?}`", err);
                    continue;
                }
                _ => println!("(i) A non-handler error ocurred `{:#?}`", err),
            },
        };
        break;
    }

    Ok(())
}

'''
'''--- examples/query_tx.rs ---
use near_jsonrpc_client::methods;

mod utils;

pub fn specify_block_reference() -> std::io::Result<near_primitives::types::BlockReference> {
    println!("=========[Block Reference]=========");
    let block_reference = utils::select(
        || {
            println!(" [1] final        \x1b[38;5;244m(alias: f, fin)\x1b[0m");
            println!(" [2] optimistic   \x1b[38;5;244m(alias: o, opt)\x1b[0m");
            println!(" [3] block hash   \x1b[38;5;244m(alias: s, hash)\x1b[0m");
            println!(" [4] block height \x1b[38;5;244m(alias: h, height)\x1b[0m");
        },
        "\x1b[33m(enter a selection)\x1b[0m> ",
        |selection| match (selection, selection.parse()) {
            ("f" | "fin" | "final", _) | (_, Ok(1)) => {
                Some(near_primitives::types::BlockReference::Finality(
                    near_primitives::types::Finality::Final,
                ))
            }
            ("o" | "opt" | "optimistic", _) | (_, Ok(2)) => {
                Some(near_primitives::types::BlockReference::Finality(
                    near_primitives::types::Finality::None,
                ))
            }
            ("s" | "hash" | "block hash", _) | (_, Ok(3)) => loop {
                match utils::input("What block hash should we query? ")
                    .unwrap()
                    .parse()
                {
                    Ok(block_hash) => {
                        break Some(near_primitives::types::BlockReference::BlockId(
                            near_primitives::types::BlockId::Hash(block_hash),
                        ))
                    }
                    _ => println!("(i) Invalid block hash, please reenter!"),
                }
            },
            ("h" | "height" | "block height", _) | (_, Ok(4)) => loop {
                match utils::input("What block height should we query? ")
                    .unwrap()
                    .parse()
                {
                    Ok(block_height) => {
                        break Some(near_primitives::types::BlockReference::BlockId(
                            near_primitives::types::BlockId::Height(block_height),
                        ))
                    }
                    _ => println!("(i) Invalid block height, please reenter!"),
                }
            },
            _ => None,
        },
    )?;
    println!("===================================");

    Ok(block_reference)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    // tolerate only 3 retries for a non-failing transaction hash
    'root: for _ in 1..=3 {
        let tx_hash = 'tx_hash: loop {
            // tolerate only 3 retries for a valid transaction hash
            for _ in 1..=3 {
                if let Ok(tx_hash) =
                    utils::input("What transaction hash should we query? ")?.parse()
                {
                    break 'tx_hash tx_hash;
                }
                println!("(i) Invalid transaction hash!");
            }

            break 'root;
        };

        let account_id = 'account_id: loop {
            // tolerate only 3 retries for a valid Account ID
            for _ in 1..=3 {
                if let Ok(account_id) =
                    utils::input("What account signed this transaction? ")?.parse()
                {
                    break 'account_id account_id;
                }
                println!("(i) Invalid Account ID!");
            }

            break 'root;
        };

        match client
            .call(methods::tx::RpcTransactionStatusRequest {
                transaction_info: methods::tx::TransactionInfo::TransactionId {
                    hash: tx_hash,
                    account_id,
                },
            })
            .await
        {
            Ok(block_details) => println!("{:#?}", block_details),
            Err(err) => match err.handler_error() {
                Some(err) => {
                    println!("(i) An error occurred `{:#?}`", err);
                    continue;
                }
                _ => println!("(i) A non-handler error ocurred `{:#?}`", err),
            },
        };
        break;
    }

    Ok(())
}

'''
'''--- examples/utils.rs ---
#![allow(unused)]

use near_jsonrpc_client::JsonRpcClient;
use std::io::{self, Write};

pub fn input(query: &str) -> io::Result<String> {
    print!("{}", query);
    io::stdout().flush()?;
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_owned())
}

pub fn select<S, F>(print_msg: fn(), query: &str, chk: F) -> io::Result<S>
where
    F: Fn(&str) -> Option<S>,
{
    loop {
        print_msg();
        for _ in 1..=5 {
            let selection = input(query)?;
            if let Some(selection) = chk(selection.to_lowercase().as_str()) {
                return Ok(selection);
            }
            println!("\x1b[31m(i)\x1b[0m invalid selection, retry..");
        }
    }
}

pub fn select_network() -> io::Result<JsonRpcClient> {
    println!("========[Network Selection]========");
    let network = select(
        || {
            println!(" [1] mainnet \x1b[38;5;244m(alias: m, main)\x1b[0m");
            println!(" [2] testnet \x1b[38;5;244m(alias: t, test)\x1b[0m");
            println!(" [3] custom  \x1b[38;5;244m(alias:       c)\x1b[0m");
        },
        "\x1b[33m(enter a selection)\x1b[0m> ",
        |selection| match (selection, selection.parse()) {
            ("m" | "main" | "mainnet", _) | (_, Ok(1)) => Some("mainnet"),
            ("t" | "test" | "testnet", _) | (_, Ok(2)) => Some("testnet"),
            ("c" | "custom", _) | (_, Ok(3)) => Some("custom"),
            _ => None,
        },
    )?;
    let network_url = if network != "custom" {
        let archival = select(
            || (),
            "Should we connect to an archival node? [y/N] ",
            |selection| match selection {
                "" | "n" | "no" => Some(false),
                "y" | "yes" => Some(true),
                _ => None,
            },
        )?;
        println!(
            "\x1b[32m(i)\x1b[0m Connected to the [{}] network{}",
            network,
            if archival {
                " (via an archival node)"
            } else {
                ""
            }
        );
        format!(
            "https://{archival}rpc.{network}.near.org",
            archival = if archival { "archival-" } else { "" },
            network = network
        )
    } else {
        loop {
            let url = input("Enter the RPC Server Address: ")?;
            if let Err(err) = url.parse::<reqwest::Url>() {
                println!("\x1b[31m(i)\x1b[0m invalid url ({}), retry..", err);
                continue;
            }
            break url;
        }
    };
    println!("===================================");

    Ok(JsonRpcClient::connect(network_url))
}

fn main() {
    panic!("not a binary")
}

'''
'''--- examples/view_account.rs ---
use near_jsonrpc_client::methods;
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{AccountId, BlockReference, Finality};
use near_primitives::views::QueryRequest;

mod utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let client = utils::select_network()?;

    let account_id: AccountId = utils::input("Enter an Account ID to lookup: ")?.parse()?;

    let request = methods::query::RpcQueryRequest {
        block_reference: BlockReference::Finality(Finality::Final),
        request: QueryRequest::ViewAccount { account_id },
    };

    let response = client.call(request).await?;

    if let QueryResponseKind::ViewAccount(result) = response.kind {
        println!("{:#?}", result);
    }

    Ok(())
}

'''
'''--- src/auth.rs ---
use std::fmt;

use reqwest::header::HeaderValue;

/// NEAR JSON RPC API key.
#[derive(Eq, Hash, Clone, Debug, PartialEq)]
pub struct ApiKey(HeaderValue);

impl ApiKey {
    pub const HEADER_NAME: &'static str = "x-api-key";

    /// Creates a new API key from a string.
    pub fn new<K: IntoApiKey>(api_key: K) -> Result<Self, InvalidApiKey> {
        if let Ok(api_key) = uuid::Uuid::parse_str(api_key.as_ref()) {
            if let Ok(api_key) = api_key.to_string().try_into() {
                return Ok(ApiKey(api_key));
            }
        }
        Err(InvalidApiKey { _priv: () })
    }

    /// Returns the API key as a string slice.
    pub fn as_str(&self) -> &str {
        self.0
            .to_str()
            .expect("fatal: api key should contain only ascii characters")
    }
}

impl crate::header::HeaderEntry for ApiKey {
    type HeaderName = &'static str;
    type HeaderValue = HeaderValue;

    fn header_name(&self) -> &Self::HeaderName {
        &Self::HEADER_NAME
    }

    fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue) {
        (Self::HEADER_NAME, self.0)
    }
}

impl fmt::Display for ApiKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x-api-key: {}", self.as_str())
    }
}

/// An error returned when an API key contains invalid characters.
#[derive(Eq, Clone, PartialEq)]
pub struct InvalidApiKey {
    _priv: (),
}

impl fmt::Debug for InvalidApiKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("InvalidApiKey")
    }
}

impl std::error::Error for InvalidApiKey {}
impl fmt::Display for InvalidApiKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Invalid API key")
    }
}

mod private {
    pub trait Sealed: AsRef<str> {}
}

/// A marker trait used to identify values that can be made into API keys.
pub trait IntoApiKey: private::Sealed {}

impl private::Sealed for String {}

impl IntoApiKey for String {}

impl private::Sealed for &String {}

impl IntoApiKey for &String {}

impl private::Sealed for &str {}

impl IntoApiKey for &str {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn api_key() {
        ApiKey::new("some-value").expect_err("should not have been a valid API key");

        ApiKey::new("0ee1872b-355f-4254-8e2b-1c0b8199ee92")
            .expect("should have been a valid API key");

        ApiKey::new("0ee1872b355f42548e2b1c0b8199ee92").expect("should have been a valid API key");

        ApiKey::new("0ee--1872b355f4254-8e2b1c0b8-199ee92")
            .expect_err("should not have been a valid API key");
    }

    #[test]
    fn display() {
        let api_key = ApiKey::new("0ee1872b-355f-4254-8e2b-1c0b8199ee92")
            .expect("should have been a valid API key");

        assert_eq!(
            api_key.to_string(),
            "x-api-key: 0ee1872b-355f-4254-8e2b-1c0b8199ee92"
        );

        let api_key = ApiKey::new("0ee1872b355f42548e2b1c0b8199ee92")
            .expect("should have been a valid API key");

        assert_eq!(
            api_key.to_string(),
            "x-api-key: 0ee1872b-355f-4254-8e2b-1c0b8199ee92"
        );
    }
}

'''
'''--- src/errors.rs ---
use std::io;

use thiserror::Error;

use near_jsonrpc_primitives::errors::{RpcError, RpcErrorKind, RpcRequestValidationErrorKind};
use near_jsonrpc_primitives::message::{self, Message};

#[derive(Debug, Error)]
pub enum JsonRpcTransportSendError {
    #[error("error while serializing payload: [{0}]")]
    PayloadSerializeError(io::Error),
    #[error("error while sending payload: [{0}]")]
    PayloadSendError(reqwest::Error),
}

#[derive(Debug, Error)]
pub enum JsonRpcTransportHandlerResponseError {
    #[error("error while parsing method call result: [{0}]")]
    ResultParseError(serde_json::Error),
    #[error("error while parsing method call error message: [{0}]")]
    ErrorMessageParseError(serde_json::Error),
}

#[derive(Debug, Error)]
pub enum JsonRpcTransportRecvError {
    #[error("unexpected server response: [{0:?}]")]
    UnexpectedServerResponse(Message),
    #[error("error while reading response: [{0}]")]
    PayloadRecvError(reqwest::Error),
    #[error("error while parsing server response: [{0:?}]")]
    PayloadParseError(message::Broken),
    #[error(transparent)]
    ResponseParseError(JsonRpcTransportHandlerResponseError),
}

#[derive(Debug, Error)]
pub enum RpcTransportError {
    #[error(transparent)]
    SendError(JsonRpcTransportSendError),
    #[error(transparent)]
    RecvError(JsonRpcTransportRecvError),
}

#[derive(Debug, Error)]
pub enum JsonRpcServerResponseStatusError {
    #[error("this client is unauthorized")]
    Unauthorized,
    #[error("this client has exceeded the rate limit")]
    TooManyRequests,
    #[error("the server returned a non-OK (200) status code: [{status}]")]
    Unexpected { status: reqwest::StatusCode },
}

#[derive(Debug, Error)]
pub enum JsonRpcServerError<E> {
    #[error("request validation error: [{0:?}]")]
    RequestValidationError(RpcRequestValidationErrorKind),
    #[error("handler error: [{0}]")]
    HandlerError(E),
    #[error("internal error: [{info:?}]")]
    InternalError { info: Option<String> },
    #[error("error response lacks context: {0}")]
    NonContextualError(RpcError),
    #[error(transparent)]
    ResponseStatusError(JsonRpcServerResponseStatusError),
}

#[derive(Debug, Error)]
pub enum JsonRpcError<E> {
    #[error(transparent)]
    TransportError(RpcTransportError),
    #[error(transparent)]
    ServerError(JsonRpcServerError<E>),
}

impl<E> JsonRpcError<E> {
    pub fn handler_error(&self) -> Option<&E> {
        if let Self::ServerError(JsonRpcServerError::HandlerError(err)) = self {
            return Some(err);
        }
        None
    }
}

impl<E: super::methods::RpcHandlerError> From<RpcError> for JsonRpcError<E> {
    fn from(err: RpcError) -> Self {
        let mut handler_parse_error = None;
        match err.error_struct {
            Some(RpcErrorKind::HandlerError(ref handler_error)) => {
                match E::parse(handler_error.clone()) {
                    Ok(handler_error) => {
                        return JsonRpcError::ServerError(JsonRpcServerError::HandlerError(
                            handler_error,
                        ))
                    }
                    Err(err) => {
                        handler_parse_error.replace(err);
                    }
                }
            }
            Some(RpcErrorKind::RequestValidationError(err)) => {
                return JsonRpcError::ServerError(JsonRpcServerError::RequestValidationError(err));
            }
            Some(RpcErrorKind::InternalError(err)) => {
                return JsonRpcError::ServerError(JsonRpcServerError::InternalError {
                    info: err["info"]["error_message"]
                        .as_str()
                        .map(|info| info.to_string()),
                })
            }
            None => {}
        }
        if let Some(ref raw_err_data) = err.data {
            match E::parse_legacy_error(raw_err_data.clone()) {
                Some(Ok(handler_error)) => {
                    return JsonRpcError::ServerError(JsonRpcServerError::HandlerError(
                        handler_error,
                    ))
                }
                Some(Err(err)) => {
                    handler_parse_error.replace(err);
                }
                None => {}
            }
        }
        if let Some(err) = handler_parse_error {
            return JsonRpcError::TransportError(RpcTransportError::RecvError(
                JsonRpcTransportRecvError::ResponseParseError(
                    JsonRpcTransportHandlerResponseError::ErrorMessageParseError(err),
                ),
            ));
        }
        JsonRpcError::ServerError(JsonRpcServerError::NonContextualError(err))
    }
}

'''
'''--- src/header.rs ---
//! Client Headers.
//!
//! This module includes everything you need to build valid header entries.

use std::marker::PhantomData;

pub use reqwest::header::HeaderValue;
use reqwest::header::IntoHeaderName;

use super::JsonRpcClient;

/// [`HeaderEntry`] attribute identifying those that have been prevalidated.
///
/// The specification of a header entry identified by this discriminant doesn't return a [`Result`].
///
/// ### Example
///
/// This example adds the header name `custom-header` and value `custom:some-value`.
///
/// ```
/// use near_jsonrpc_client::{
///     header::{HeaderEntry, HeaderValue, Prevalidated},
///     methods, JsonRpcClient,
/// };
///
/// struct CustomHeader(HeaderValue);
///
/// impl HeaderEntry<Prevalidated> for CustomHeader {
///     type HeaderName = &'static str;
///     type HeaderValue = HeaderValue;
///
///     fn header_name(&self) -> &Self::HeaderName {
///         &"custom-header"
///     }
///
///     fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue) {
///         ("custom-header", self.0)
///     }
/// }
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
///
/// let header_value = HeaderValue::try_from("custom:some-value")?; // <- error handling here
///
/// let client = JsonRpcClient::connect("https://rpc.testnet.near.org").header(CustomHeader(header_value));
/// # Ok(())
/// # }
pub struct Prevalidated {
    _priv: (),
}

/// [`HeaderEntry`] attribute identifying those that need to be validated.
///
/// The specification of a header entry identified by this discriminant will return a [`Result`].
///
/// ### Example
///
/// This example adds the header name `custom-header` and value `custom:some-value`.
///
/// ```
/// # use std::{fmt, error::Error};
/// use near_jsonrpc_client::{
///     header::{HeaderEntry, HeaderValue, Postvalidated},
///     methods, JsonRpcClient,
/// };
///
/// struct CustomValue(&'static str);
///
/// struct CustomHeader(CustomValue);
///
/// # #[derive(Debug)]
/// struct CustomError;
/// # impl Error for CustomError {}
/// # impl fmt::Display for CustomError {
/// #     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
/// #         write!(f, "custom error")
/// #     }
/// # }
///
/// impl TryFrom<CustomValue> for HeaderValue {
///     type Error = CustomError;
///
///     fn try_from(v: CustomValue) -> Result<Self, Self::Error> {
///         HeaderValue::try_from(format!("custom:{}", v.0)).map_err(|_| CustomError)
///     }
/// }
///
/// impl HeaderEntry<Postvalidated<CustomError>> for CustomHeader {
///     type HeaderName = &'static str;
///     type HeaderValue = CustomValue;
///
///     fn header_name(&self) -> &Self::HeaderName {
///         &"custom-header"
///     }
///
///     fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue) {
///         ("custom-header", self.0)
///     }
/// }
/// # #[tokio::main]
/// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
///
/// let client = JsonRpcClient::connect("https://rpc.testnet.near.org")
///     .header(CustomHeader(CustomValue("some-value")))?; // <- error handling here
/// # Ok(())
/// # }
pub struct Postvalidated<E> {
    _priv: PhantomData<E>,
}

/// Trait for identifying valid header entries.
///
/// Header entries are distinguished by their discrimimants, (See [HeaderEntryDiscriminant]).
pub trait HeaderEntry<D = Prevalidated>: Sized
where
    D: HeaderEntryDiscriminant<Self>,
{
    type HeaderName;
    type HeaderValue;

    fn header_name(&self) -> &Self::HeaderName;
    fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue);
}

mod private {
    pub trait Sealed {}
}

/// Trait for defining a [`HeaderEntry`]'s application on a client.
pub trait HeaderEntryDiscriminant<H>: private::Sealed {
    type Output;

    fn apply(client: JsonRpcClient, entry: H) -> Self::Output;
}

impl private::Sealed for Prevalidated {}
impl<T> HeaderEntryDiscriminant<T> for Prevalidated
where
    T: HeaderEntry<Self, HeaderValue = HeaderValue>,
    T::HeaderName: IntoHeaderName,
{
    type Output = JsonRpcClient;

    fn apply(mut client: JsonRpcClient, entry: T) -> Self::Output {
        let (k, v) = entry.header_pair();
        client.headers.insert(k, v);
        client
    }
}

impl<E> private::Sealed for Postvalidated<E> {}
impl<T, E> HeaderEntryDiscriminant<T> for Postvalidated<E>
where
    T: HeaderEntry<Self>,
    T::HeaderName: IntoHeaderName,
    T::HeaderValue: TryInto<HeaderValue, Error = E>,
{
    type Output = Result<JsonRpcClient, E>;

    fn apply(mut client: JsonRpcClient, entry: T) -> Self::Output {
        let (k, v) = entry.header_pair();
        client.headers.insert(k, v.try_into()?);
        Ok(client)
    }
}

impl<N: IntoHeaderName> HeaderEntry<Prevalidated> for (N, HeaderValue) {
    type HeaderName = N;
    type HeaderValue = HeaderValue;

    fn header_name(&self) -> &Self::HeaderName {
        &self.0
    }

    fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue) {
        self
    }
}

impl<N, V> HeaderEntry<Postvalidated<V::Error>> for (N, V)
where
    N: IntoHeaderName,
    V: TryInto<HeaderValue>,
{
    type HeaderName = N;
    type HeaderValue = V;

    fn header_name(&self) -> &Self::HeaderName {
        &self.0
    }

    fn header_pair(self) -> (Self::HeaderName, Self::HeaderValue) {
        self
    }
}

'''
'''--- src/lib.rs ---
//! Lower-level API for interfacing with the NEAR Protocol via JSONRPC.
//!
//! ## Layout
//!
//! Each one the valid *public* JSON RPC methods are pre-defined in specialized modules within the `methods` module.
//!
//! Inside every method module (e.g [`methods::query`]) there's;
//!   - a `Request` type (e.g [`methods::query::RpcQueryRequest`])
//!   - a `Response` type (e.g [`methods::query::RpcQueryResponse`])
//!   - and an `Error` type (e.g [`methods::query::RpcQueryError`])
//!
//! Calling a constructed request on a client returns with the result and error types for that method.
//!
//! ## Examples
//!
//! 1. Request server status from testnet RPC
//!
//!    ```
//!    # #![allow(deprecated)]
//!    use near_jsonrpc_client::{methods, JsonRpcClient};
//!
//!    # #[tokio::main]
//!    # async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!    let testnet_client = JsonRpcClient::connect("https://rpc.testnet.near.org");
//!
//!    let status_request = methods::status::RpcStatusRequest; // no params
//!
//!    // call a method on the server via the connected client
//!    let server_status = testnet_client.call(status_request).await?;
//!
//!    println!("{:?}", server_status);
//!    # Ok(())
//!    # }
//!    ```
//!
//! 2. Query transaction status from mainnet RPC
//!
//!    ```
//!    use near_jsonrpc_client::{methods, JsonRpcClient};
//!    use near_jsonrpc_primitives::types::transactions::TransactionInfo;
//!
//!    # #[tokio::main]
//!    # async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//!    let mainnet_client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//!
//!    let tx_status_request = methods::tx::RpcTransactionStatusRequest {
//!        transaction_info: TransactionInfo::TransactionId {
//!            hash: "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U".parse()?,
//!            account_id: "miraclx.near".parse()?,
//!        },
//!    };
//!
//!    let tx_status = mainnet_client.call(tx_status_request).await?;
//!
//!    println!("{:?}", tx_status);
//!    # Ok(())
//!    # }
//!    ```
//!
//! 3. For all intents and purposes, the predefined structures in `methods` should suffice, if you find that they
//!    don't or you crave extra flexibility, well, you can opt in to use the generic constructor `methods::any()` with the `any` feature flag.
//!
//!    In this example, we retrieve only the parts from the genesis config response that we care about.
//!
//!    ```toml
//!    # in Cargo.toml
//!    near-jsonrpc-client = { ..., features = ["any"] }
//!    ```
//!
//!    ```
//!    use serde::Deserialize;
//!    use serde_json::json;
//!
//!    # use near_jsonrpc_client::errors::JsonRpcError;
//!    use near_jsonrpc_client::{methods, JsonRpcClient};
//!    use near_primitives::serialize::dec_format;
//!    use near_primitives::types::*;
//!
//!    #[derive(Debug, Deserialize)]
//!    struct PartialGenesisConfig {
//!        protocol_version: ProtocolVersion,
//!        chain_id: String,
//!        genesis_height: BlockHeight,
//!        epoch_length: BlockHeightDelta,
//!        #[serde(with = "dec_format")]
//!        min_gas_price: Balance,
//!        #[serde(with = "dec_format")]
//!        max_gas_price: Balance,
//!        #[serde(with = "dec_format")]
//!        total_supply: Balance,
//!        validators: Vec<AccountInfo>,
//!    }
//!
//!    impl methods::RpcHandlerResponse for PartialGenesisConfig {}
//!
//!    # #[tokio::main]
//!    # async fn main() -> Result<(), JsonRpcError<()>> {
//!    let mainnet_client = JsonRpcClient::connect("https://rpc.mainnet.near.org");
//!
//!    # #[cfg(feature = "any")] {
//!    let genesis_config_request = methods::any::<Result<PartialGenesisConfig, ()>>(
//!        "EXPERIMENTAL_genesis_config",
//!        json!(null),
//!    );
//!
//!    let partial_genesis = mainnet_client.call(genesis_config_request).await?;
//!
//!    println!("{:#?}", partial_genesis);
//!    # }
//!    # Ok(())
//!    # }
//!    ```

use std::{fmt, sync::Arc};

use lazy_static::lazy_static;

#[cfg(feature = "auth")]
pub mod auth;
pub mod errors;
pub mod header;
pub mod methods;

use errors::*;

pub const NEAR_MAINNET_RPC_URL: &str = "https://rpc.mainnet.near.org";
pub const NEAR_TESTNET_RPC_URL: &str = "https://rpc.testnet.near.org";
pub const NEAR_MAINNET_ARCHIVAL_RPC_URL: &str = "https://archival-rpc.mainnet.near.org";
pub const NEAR_TESTNET_ARCHIVAL_RPC_URL: &str = "https://archival-rpc.testnet.near.org";

lazy_static! {
    static ref DEFAULT_CONNECTOR: JsonRpcClientConnector = JsonRpcClient::new_client();
}

/// NEAR JSON RPC client connector.
#[derive(Clone)]
pub struct JsonRpcClientConnector {
    client: reqwest::Client,
}

impl JsonRpcClientConnector {
    /// Return a JsonRpcClient that connects to the specified server.
    pub fn connect<U: AsUrl>(&self, server_addr: U) -> JsonRpcClient {
        log::debug!("returned a new JSONRPC client handle");

        JsonRpcClient {
            inner: Arc::new(JsonRpcInnerClient {
                server_addr: server_addr.to_string(),
                client: self.client.clone(),
            }),
            headers: reqwest::header::HeaderMap::new(),
        }
    }
}

struct JsonRpcInnerClient {
    server_addr: String,
    client: reqwest::Client,
}

#[derive(Clone)]
/// A NEAR JSON RPC Client.
pub struct JsonRpcClient {
    inner: Arc<JsonRpcInnerClient>,
    headers: reqwest::header::HeaderMap,
}

pub type MethodCallResult<T, E> = Result<T, JsonRpcError<E>>;

impl JsonRpcClient {
    /// Connect to a JSON RPC server using the default connector.
    ///
    /// It's virtually the same as calling `new_client().connect(server_addr)`.
    /// Only, this method optimally reuses the same connector across invocations.
    ///
    /// ## Example
    ///
    /// ```
    /// use near_jsonrpc_client::{methods, JsonRpcClient};
    ///
    /// # #[tokio::main]
    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mainnet_client = JsonRpcClient::connect("https://rpc.testnet.near.org");
    ///
    /// let status_request = methods::status::RpcStatusRequest;
    /// let server_status = mainnet_client.call(status_request).await?;
    ///
    /// println!("{:?}", server_status);
    /// # Ok(())
    /// # }
    /// ```
    pub fn connect<U: AsUrl>(server_addr: U) -> JsonRpcClient {
        DEFAULT_CONNECTOR.connect(server_addr)
    }

    /// Get the server address the client connects to.
    pub fn server_addr(&self) -> &str {
        &self.inner.server_addr
    }

    /// RPC method executor for the client.
    pub async fn call<M>(&self, method: M) -> MethodCallResult<M::Response, M::Error>
    where
        M: methods::RpcMethod,
    {
        let request_payload = methods::to_json(&method).map_err(|err| {
            JsonRpcError::TransportError(RpcTransportError::SendError(
                JsonRpcTransportSendError::PayloadSerializeError(err),
            ))
        })?;

        log::debug!("request payload: {:#}", request_payload);

        let request_payload = serde_json::to_vec(&request_payload).map_err(|err| {
            JsonRpcError::TransportError(RpcTransportError::SendError(
                JsonRpcTransportSendError::PayloadSerializeError(err.into()),
            ))
        })?;

        let request = self
            .inner
            .client
            .post(&self.inner.server_addr)
            .headers(self.headers.clone())
            .body(request_payload);

        let response = request.send().await.map_err(|err| {
            JsonRpcError::TransportError(RpcTransportError::SendError(
                JsonRpcTransportSendError::PayloadSendError(err),
            ))
        })?;
        match response.status() {
            reqwest::StatusCode::OK => {}
            non_ok_status => {
                return Err(JsonRpcError::ServerError(
                    JsonRpcServerError::ResponseStatusError(match non_ok_status {
                        reqwest::StatusCode::UNAUTHORIZED => {
                            JsonRpcServerResponseStatusError::Unauthorized
                        }
                        reqwest::StatusCode::TOO_MANY_REQUESTS => {
                            JsonRpcServerResponseStatusError::TooManyRequests
                        }
                        unexpected => {
                            JsonRpcServerResponseStatusError::Unexpected { status: unexpected }
                        }
                    }),
                ));
            }
        }
        let response_payload = response.bytes().await.map_err(|err| {
            JsonRpcError::TransportError(RpcTransportError::RecvError(
                JsonRpcTransportRecvError::PayloadRecvError(err),
            ))
        })?;
        let response_payload = serde_json::from_slice::<serde_json::Value>(&response_payload);

        if let Ok(ref response_payload) = response_payload {
            log::debug!("response payload: {:#}", response_payload);
        }

        let response_message = near_jsonrpc_primitives::message::decoded_to_parsed(
            response_payload.and_then(serde_json::from_value),
        )
        .map_err(|err| {
            JsonRpcError::TransportError(RpcTransportError::RecvError(
                JsonRpcTransportRecvError::PayloadParseError(err),
            ))
        })?;

        if let near_jsonrpc_primitives::message::Message::Response(response) = response_message {
            return M::parse_handler_response(response.result?)
                .map_err(|err| {
                    JsonRpcError::TransportError(RpcTransportError::RecvError(
                        JsonRpcTransportRecvError::ResponseParseError(
                            JsonRpcTransportHandlerResponseError::ResultParseError(err),
                        ),
                    ))
                })?
                .map_err(|err| JsonRpcError::ServerError(JsonRpcServerError::HandlerError(err)));
        }
        Err(JsonRpcError::TransportError(RpcTransportError::RecvError(
            JsonRpcTransportRecvError::UnexpectedServerResponse(response_message),
        )))
    }

    /// Add a header to this request.
    ///
    /// Depending on the header specified, this method either returns back
    /// the client, or a result containing the client.
    ///
    /// ### Example
    ///
    /// ```
    /// use near_jsonrpc_client::JsonRpcClient;
    ///
    /// # #[tokio::main]
    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let client = JsonRpcClient::connect("https://rpc.testnet.near.org");
    /// let client = client.header(("user-agent", "someclient/0.1.0"))?; // <- returns a result
    ///
    /// # #[cfg(feature = "auth")]
    /// use near_jsonrpc_client::auth;
    ///
    /// # #[cfg(feature = "auth")]
    /// let client = client.header(
    ///     auth::ApiKey::new("cadc4c83-5566-4c94-aa36-773605150f44")?, // <- error handling here
    /// ); // <- returns the client
    /// # Ok(())
    /// # }
    /// ```
    pub fn header<H, D>(self, entry: H) -> D::Output
    where
        H: header::HeaderEntry<D>,
        D: header::HeaderEntryDiscriminant<H>,
    {
        D::apply(self, entry)
    }

    /// Get a shared reference to the headers.
    pub fn headers(&self) -> &reqwest::header::HeaderMap {
        &self.headers
    }

    /// Get an exclusive reference to the headers.
    pub fn headers_mut(&mut self) -> &mut reqwest::header::HeaderMap {
        &mut self.headers
    }

    /// Manually create a new client connector.
    ///
    /// It's recommended to use the [`connect`](JsonRpcClient::connect) method instead as that method optimally
    /// reuses the default connector across invocations.
    ///
    /// However, if for some reason you still need to manually create a new connector, you can do so.
    /// Just remember to properly **reuse** it as much as possible.
    ///
    /// ## Example
    ///
    /// ```
    /// # use near_jsonrpc_client::JsonRpcClient;
    /// let client_connector = JsonRpcClient::new_client();
    ///
    /// let mainnet_client = client_connector.connect("https://rpc.mainnet.near.org");
    /// let testnet_client = client_connector.connect("https://rpc.testnet.near.org");
    /// ```
    pub fn new_client() -> JsonRpcClientConnector {
        let mut headers = reqwest::header::HeaderMap::with_capacity(2);
        headers.insert(
            reqwest::header::CONTENT_TYPE,
            reqwest::header::HeaderValue::from_static("application/json"),
        );

        log::debug!("initialized a new JSONRPC client connector");
        JsonRpcClientConnector {
            client: reqwest::Client::builder()
                .default_headers(headers)
                .build()
                .unwrap(),
        }
    }

    /// Create a new client constructor using a custom web client.
    ///
    /// This is useful if you want to customize the `reqwest::Client` instance used by the JsonRpcClient.
    ///
    /// ## Example
    ///
    /// ```
    /// use near_jsonrpc_client::JsonRpcClient;
    ///
    /// # #[tokio::main]
    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let web_client = reqwest::Client::builder()
    ///     .proxy(reqwest::Proxy::all("https://192.168.1.1:4825")?)
    ///     .build()?;
    ///
    /// let testnet_client = JsonRpcClient::with(web_client).connect("https://rpc.testnet.near.org");
    /// # Ok(())
    /// # }
    /// ```
    pub fn with(client: reqwest::Client) -> JsonRpcClientConnector {
        JsonRpcClientConnector { client }
    }
}

impl fmt::Debug for JsonRpcClient {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut builder = f.debug_struct("JsonRpcClient");
        builder.field("server_addr", &self.inner.server_addr);
        builder.field("headers", &self.headers);
        builder.field("client", &self.inner.client);
        builder.finish()
    }
}

mod private {
    pub trait Sealed: ToString {}
}

pub trait AsUrl: private::Sealed {}

impl private::Sealed for String {}

impl AsUrl for String {}

impl private::Sealed for &String {}

impl AsUrl for &String {}

impl private::Sealed for &str {}

impl AsUrl for &str {}

impl private::Sealed for reqwest::Url {}

impl AsUrl for reqwest::Url {}

#[cfg(test)]
mod tests {
    use crate::{methods, JsonRpcClient};

    #[tokio::test]
    async fn chk_status_testnet() {
        let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

        let status = client.call(methods::status::RpcStatusRequest).await;

        assert!(
            matches!(status, Ok(methods::status::RpcStatusResponse { .. })),
            "expected an Ok(RpcStatusResponse), found [{:?}]",
            status
        );
    }

    #[tokio::test]
    #[cfg(feature = "any")]
    async fn any_typed_ok() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");

        let tx_status = client
            .call(methods::any::<methods::tx::RpcTransactionStatusRequest>(
                "tx",
                serde_json::json!([
                    "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U",
                    "miraclx.near",
                ]),
            ))
            .await;

        assert!(
            matches!(
                tx_status,
                Ok(methods::tx::RpcTransactionStatusResponse { ref transaction, .. })
                if transaction.signer_id.as_ref() == "miraclx.near"
                && transaction.hash == "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U".parse()?
            ),
            "expected an Ok(RpcTransactionStatusResponse) with matching signer_id + hash, found [{:?}]",
            tx_status
        );

        Ok(())
    }

    #[tokio::test]
    #[cfg(feature = "any")]
    async fn any_typed_err() -> Result<(), Box<dyn std::error::Error>> {
        let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");

        let tx_error = client
            .call(methods::any::<methods::tx::RpcTransactionStatusRequest>(
                "tx",
                serde_json::json!([
                    "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8D",
                    "youser.near",
                ]),
            ))
            .await
            .expect_err("request must not succeed");

        assert!(
            matches!(
                tx_error.handler_error(),
                Some(methods::tx::RpcTransactionError::UnknownTransaction {
                    requested_transaction_hash
                })
                if requested_transaction_hash.to_string() == "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8D"
            ),
            "expected an Ok(RpcTransactionError::UnknownTransaction) with matching hash, found [{:?}]",
            tx_error
        );

        Ok(())
    }

    #[tokio::test]
    #[cfg(feature = "any")]
    async fn any_untyped_ok() {
        let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");

        let status = client
            .call(
                methods::any::<Result<serde_json::Value, serde_json::Value>>(
                    "tx",
                    serde_json::json!([
                        "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U",
                        "miraclx.near",
                    ]),
                ),
            )
            .await
            .expect("request must not fail");

        assert_eq!(
            status["transaction"]["signer_id"], "miraclx.near",
            "expected a tx_status with matching signer_id, [{:#}]",
            status
        );
        assert_eq!(
            status["transaction"]["hash"], "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8U",
            "expected a tx_status with matching hash, [{:#}]",
            status
        );
    }

    #[tokio::test]
    #[cfg(feature = "any")]
    async fn any_untyped_err() {
        let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");

        let tx_error = client
            .call(
                methods::any::<Result<serde_json::Value, serde_json::Value>>(
                    "tx",
                    serde_json::json!([
                        "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8D",
                        "youser.near",
                    ]),
                ),
            )
            .await
            .expect_err("request must not succeed");
        let tx_error = tx_error
            .handler_error()
            .expect("expected a handler error from query request");

        assert_eq!(
            tx_error["info"]["requested_transaction_hash"],
            "9FtHUFBQsZ2MG77K3x3MJ9wjX3UT8zE1TczCrhZEcG8D",
            "expected an error with matching hash, [{:#}]",
            tx_error
        );
        assert_eq!(
            tx_error["name"], "UNKNOWN_TRANSACTION",
            "expected an UnknownTransaction, [{:#}]",
            tx_error
        );
    }
}

'''
'''--- src/methods/adversarial/check_store.rs ---
use super::*;

use serde::Deserialize;

#[derive(Debug)]
pub struct RpcAdversarialCheckStoreRequest;

#[derive(Debug, Deserialize)]
pub struct RpcAdversarialCheckStoreResponse(pub u64);

impl RpcHandlerResponse for RpcAdversarialCheckStoreResponse {}

impl RpcMethod for RpcAdversarialCheckStoreRequest {
    type Response = RpcAdversarialCheckStoreResponse;
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_check_store"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcAdversarialCheckStoreRequest {}

'''
'''--- src/methods/adversarial/disable_doomslug.rs ---
use super::*;

#[derive(Debug)]
pub struct RpcAdversarialDisableDoomslugRequest;

impl RpcMethod for RpcAdversarialDisableDoomslugRequest {
    type Response = ();
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_disable_doomslug"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcAdversarialDisableDoomslugRequest {}

'''
'''--- src/methods/adversarial/disable_header_sync.rs ---
use super::*;

#[derive(Debug)]
pub struct RpcAdversarialDisableHeaderSyncRequest;

impl RpcMethod for RpcAdversarialDisableHeaderSyncRequest {
    type Response = ();
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_disable_header_sync"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcAdversarialDisableHeaderSyncRequest {}

'''
'''--- src/methods/adversarial/get_saved_blocks.rs ---
use super::*;

use serde::Deserialize;

#[derive(Debug)]
pub struct RpcAdversarialGetSavedBlocksRequest;

#[derive(Debug, Deserialize)]
pub struct RpcAdversarialGetSavedBlocksResponse(pub u64);

impl RpcHandlerResponse for RpcAdversarialGetSavedBlocksResponse {}

impl RpcMethod for RpcAdversarialGetSavedBlocksRequest {
    type Response = RpcAdversarialGetSavedBlocksResponse;
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_get_saved_blocks"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcAdversarialGetSavedBlocksRequest {}

'''
'''--- src/methods/adversarial/mod.rs ---
use super::*;

pub mod check_store;
pub use check_store as adv_check_store;

pub mod disable_doomslug;
pub use disable_doomslug as adv_disable_doomslug;

pub mod disable_header_sync;
pub use disable_header_sync as adv_disable_header_sync;

pub mod get_saved_blocks;
pub use get_saved_blocks as adv_get_saved_blocks;

pub mod produce_blocks;
pub use produce_blocks as adv_produce_blocks;

pub mod set_weight;
pub use set_weight as adv_set_weight;

pub mod switch_to_height;
pub use switch_to_height as adv_switch_to_height;

'''
'''--- src/methods/adversarial/produce_blocks.rs ---
use super::*;

#[derive(Debug)]
pub struct RpcAdversarialProduceBlocksRequest {
    pub num_blocks: u64,
    pub only_valid: bool,
}

impl RpcMethod for RpcAdversarialProduceBlocksRequest {
    type Response = ();
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_produce_blocks"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([self.num_blocks, self.only_valid]))
    }
}

impl private::Sealed for RpcAdversarialProduceBlocksRequest {}

'''
'''--- src/methods/adversarial/set_weight.rs ---
use super::*;

#[derive(Debug)]
pub struct RpcAdversarialSetWeightRequest {
    pub height: u64,
}

impl RpcMethod for RpcAdversarialSetWeightRequest {
    type Response = ();
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_set_weight"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self.height))
    }
}

impl private::Sealed for RpcAdversarialSetWeightRequest {}

'''
'''--- src/methods/adversarial/switch_to_height.rs ---
use super::*;

#[derive(Debug)]
pub struct RpcAdversarialSwitchToHeightRequest {
    pub height: u64,
}

impl RpcMethod for RpcAdversarialSwitchToHeightRequest {
    type Response = ();
    type Error = ();

    fn method_name(&self) -> &str {
        "adv_switch_to_height"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([self.height]))
    }
}

impl private::Sealed for RpcAdversarialSwitchToHeightRequest {}

'''
'''--- src/methods/any/mod.rs ---
use super::*;

use std::marker::PhantomData;

pub fn request<T: AnyRequestResult>(
    method_name: &str,
    params: serde_json::Value,
) -> RpcAnyRequest<T::Response, T::Error>
where
    T::Response: RpcHandlerResponse,
    T::Error: RpcHandlerError,
{
    RpcAnyRequest {
        method: method_name.to_string(),
        params,
        _data: PhantomData,
    }
}

#[derive(Debug)]
pub struct RpcAnyRequest<T, E> {
    pub method: String,
    pub params: serde_json::Value,
    pub(crate) _data: PhantomData<(T, E)>,
}

impl<T, E> private::Sealed for RpcAnyRequest<T, E> {}

impl<T, E> RpcMethod for RpcAnyRequest<T, E>
where
    T: RpcHandlerResponse,
    E: RpcHandlerError,
{
    type Response = T;
    type Error = E;

    #[inline(always)]
    fn method_name(&self) -> &str {
        &self.method
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(self.params.clone())
    }
}

pub trait AnyRequestResult {
    type Response;
    type Error;
}

impl<T, E> AnyRequestResult for Result<T, E> {
    type Response = T;
    type Error = E;
}

impl<T: RpcMethod> AnyRequestResult for T {
    type Response = T::Response;
    type Error = T::Error;
}

'''
'''--- src/methods/block.rs ---
//! Queries data from a specific block on the network.
//!
//! Blocks can be referenced using either;
//! - a [block ID](https://docs.near.org/docs/api/rpc#using-block_id-param) (block height or block hash) for querying historical blocks
//! - or a [finality specifier](https://docs.near.org/docs/api/rpc#using-finality-param) (“final” or “optimistic”) for latest blocks.
//!
//! ## Examples
//!
//! - Query historical blocks by using a specific reference (block height or block hash).
//!
//!     - `BlockId::Height`
//!
//!       ```
//!       # use near_jsonrpc_client::methods;
//!       use near_primitives::types::{BlockReference, BlockId};
//!
//!       let request = methods::block::RpcBlockRequest {
//!           block_reference: BlockReference::BlockId(BlockId::Height(83975193))
//!       };
//!       ```
//!
//!     - `BlockId::Hash`
//!
//!       ```
//!       # use near_jsonrpc_client::methods;
//!       # fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//!       use near_primitives::types::{BlockReference, BlockId};
//!
//!       let request = methods::block::RpcBlockRequest {
//!           block_reference: BlockReference::BlockId(BlockId::Hash(
//!               "G1SHrwLp55oV3kz94x3ekrR6r4ihNRWdAVZpckgBx4U4".parse()?,
//!           )),
//!       };
//!       # Ok(())
//!       # }
//!       ```
//!
//! - Query latest blocks.
//!
//!     - `Finality::Final`: Get the most recent, completely finalized block.
//!
//!       References a block that has been validated on at least 66% of the nodes in the network.
//!
//!       ```
//!       # use near_jsonrpc_client::methods;
//!       use near_primitives::types::{BlockReference, Finality};
//!
//!       let request = methods::block::RpcBlockRequest {
//!           block_reference: BlockReference::Finality(Finality::Final)
//!       };
//!       ```
//!
//!     - `Finality::None`: Get the most recently submitted block.
//!
//!       Returns the latest block recorded on the node that responded to your query.
//!
//!       ```
//!       # use near_jsonrpc_client::methods;
//!       use near_primitives::types::{BlockReference, Finality};
//!
//!       let request = methods::block::RpcBlockRequest {
//!           block_reference: BlockReference::Finality(Finality::None)
//!       };
//!       ```
use super::*;

pub use near_jsonrpc_primitives::types::blocks::RpcBlockError;
pub use near_jsonrpc_primitives::types::blocks::RpcBlockRequest;

pub type RpcBlockResponse = near_primitives::views::BlockView;

impl RpcHandlerResponse for RpcBlockResponse {}

impl RpcHandlerError for RpcBlockError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcBlockRequest {
    type Response = RpcBlockResponse;
    type Error = RpcBlockError;

    fn method_name(&self) -> &str {
        "block"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcBlockRequest {}

'''
'''--- src/methods/broadcast_tx_async.rs ---
use super::*;

pub use near_primitives::transaction::SignedTransaction;

pub type RpcBroadcastTxAsyncResponse = near_primitives::hash::CryptoHash;

#[derive(Debug)]
pub struct RpcBroadcastTxAsyncRequest {
    pub signed_transaction: SignedTransaction,
}

impl From<RpcBroadcastTxAsyncRequest>
    for near_jsonrpc_primitives::types::transactions::RpcBroadcastTransactionRequest
{
    fn from(this: RpcBroadcastTxAsyncRequest) -> Self {
        Self {
            signed_transaction: this.signed_transaction,
        }
    }
}

#[derive(Debug, Deserialize, Error)]
#[error("{}", unreachable!("fatal: this error should never be constructed"))]
pub enum RpcBroadcastTxAsyncError {}

impl RpcHandlerResponse for RpcBroadcastTxAsyncResponse {}

impl RpcHandlerError for RpcBroadcastTxAsyncError {}

impl RpcMethod for RpcBroadcastTxAsyncRequest {
    type Response = RpcBroadcastTxAsyncResponse;
    type Error = RpcBroadcastTxAsyncError;

    fn method_name(&self) -> &str {
        "broadcast_tx_async"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([common::serialize_signed_transaction(
            &self.signed_transaction
        )?]))
    }
}

impl private::Sealed for RpcBroadcastTxAsyncRequest {}

'''
'''--- src/methods/broadcast_tx_commit.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::transactions::RpcTransactionError;
pub use near_primitives::transaction::SignedTransaction;

pub type RpcBroadcastTxCommitResponse = near_primitives::views::FinalExecutionOutcomeView;

#[derive(Debug)]
pub struct RpcBroadcastTxCommitRequest {
    pub signed_transaction: SignedTransaction,
}

impl From<RpcBroadcastTxCommitRequest>
    for near_jsonrpc_primitives::types::transactions::RpcBroadcastTransactionRequest
{
    fn from(this: RpcBroadcastTxCommitRequest) -> Self {
        Self {
            signed_transaction: this.signed_transaction,
        }
    }
}

impl RpcMethod for RpcBroadcastTxCommitRequest {
    type Response = RpcBroadcastTxCommitResponse;
    type Error = RpcTransactionError;

    fn method_name(&self) -> &str {
        "broadcast_tx_commit"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([common::serialize_signed_transaction(
            &self.signed_transaction
        )?]))
    }
}

impl private::Sealed for RpcBroadcastTxCommitRequest {}

'''
'''--- src/methods/chunk.rs ---
//! Returns details of a specific chunk.
//!
//! You can use the [`block`](crate::methods::block) RPC method to get a valid chunk hash.
//!
//! ## Examples
//!
//! Chunks can be queried using one of two `ChunkReference` variants: `BlockShardId` or `ChunkHash`.
//!
//! - `BlockShardId`: Query a chunk by specifying its block ID (block height or block hash) and shard ID.
//!
//!     - `BlockId::Hash`
//!
//!       ```
//!       use near_jsonrpc_client::{methods, JsonRpcClient};
//!       use near_jsonrpc_primitives::types::chunks;
//!       use near_primitives::types::BlockId;
//!
//!       # #[tokio::main]
//!       # async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//!       let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//!
//!       let request = methods::chunk::RpcChunkRequest {
//!           chunk_reference: chunks::ChunkReference::BlockShardId {
//!               block_id: BlockId::Hash("6atGq4TUTZerVHU9qWoYfzXNBg3K4C4cca15TE6KfuBr".parse()?),
//!               shard_id: 0,
//!           }
//!       };
//!
//!       let response = client.call(request).await?;
//!
//!       assert!(matches!(
//!           response,
//!           methods::chunk::RpcChunkResponse { .. }
//!       ));
//!       # Ok(())
//!       # }
//!       ```
//!
//!     - `BlockId::Height`
//!
//!       ```
//!       use near_jsonrpc_client::{methods, JsonRpcClient};
//!       use near_jsonrpc_primitives::types::chunks;
//!       use near_primitives::types::BlockId;
//!
//!       # #[tokio::main]
//!       # async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!       let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//!
//!       let request = methods::chunk::RpcChunkRequest {
//!           chunk_reference: chunks::ChunkReference::BlockShardId {
//!               block_id: BlockId::Height(61512623),
//!               shard_id: 3,
//!           }
//!       };
//!
//!       let response = client.call(request).await?;
//!
//!       assert!(matches!(
//!           response,
//!           methods::chunk::RpcChunkResponse { .. }
//!       ));
//!       # Ok(())
//!       # }
//!       ```
//!
//!
//! - `ChunkHash`: Query a chunk by a specific reference via it's associated chunk hash.
//!
//!   ```
//!   use near_jsonrpc_client::{methods, JsonRpcClient};
//!   use near_jsonrpc_primitives::types::chunks;
//!
//!   # #[tokio::main]
//!   # async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//!   let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//!
//!   let request = methods::chunk::RpcChunkRequest{
//!       chunk_reference: chunks::ChunkReference::ChunkHash {
//!           chunk_id: "6GTgCQ5genLEEiPspEvdZEJooBzgWRrUnur9eGSdeTTD".parse()?,
//!       }
//!   };
//!
//!   let response = client.call(request).await?;
//!
//!   assert!(matches!(
//!       response,
//!       methods::chunk::RpcChunkResponse { .. }
//!   ));
//!   # Ok(())
//!   # }
//!   ```
use super::*;

pub use near_jsonrpc_primitives::types::chunks::{RpcChunkError, RpcChunkRequest};

pub type RpcChunkResponse = near_primitives::views::ChunkView;

impl RpcHandlerResponse for RpcChunkResponse {}

impl RpcHandlerError for RpcChunkError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcChunkRequest {
    type Response = RpcChunkResponse;
    type Error = RpcChunkError;

    fn method_name(&self) -> &str {
        "chunk"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcChunkRequest {}

'''
'''--- src/methods/experimental/changes.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::changes::{
    RpcStateChangesError, RpcStateChangesInBlockByTypeRequest, RpcStateChangesInBlockResponse,
};

impl RpcHandlerResponse for RpcStateChangesInBlockResponse {}

impl RpcMethod for RpcStateChangesInBlockByTypeRequest {
    type Response = RpcStateChangesInBlockResponse;
    type Error = RpcStateChangesError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_changes"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcStateChangesInBlockByTypeRequest {}

'''
'''--- src/methods/experimental/changes_in_block.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::changes::{
    RpcStateChangesError, RpcStateChangesInBlockByTypeResponse, RpcStateChangesInBlockRequest,
};

impl RpcHandlerResponse for RpcStateChangesInBlockByTypeResponse {}

impl RpcMethod for RpcStateChangesInBlockRequest {
    type Response = RpcStateChangesInBlockByTypeResponse;
    type Error = RpcStateChangesError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_changes_in_block"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcStateChangesInBlockRequest {}

'''
'''--- src/methods/experimental/check_tx.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::transactions::{
    RpcBroadcastTxSyncResponse, RpcTransactionError,
};
pub use near_primitives::transaction::SignedTransaction;

#[derive(Debug)]
pub struct RpcCheckTxRequest {
    pub signed_transaction: SignedTransaction,
}

impl From<RpcCheckTxRequest>
    for near_jsonrpc_primitives::types::transactions::RpcBroadcastTransactionRequest
{
    fn from(this: RpcCheckTxRequest) -> Self {
        Self {
            signed_transaction: this.signed_transaction,
        }
    }
}

impl RpcMethod for RpcCheckTxRequest {
    type Response = RpcBroadcastTxSyncResponse;
    type Error = RpcTransactionError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_check_tx"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([common::serialize_signed_transaction(
            &self.signed_transaction
        )?]))
    }
}

impl private::Sealed for RpcCheckTxRequest {}

'''
'''--- src/methods/experimental/genesis_config.rs ---
use super::*;

pub type RpcGenesisConfigResponse = near_chain_configs::GenesisConfig;

#[derive(Debug)]
pub struct RpcGenesisConfigRequest;

#[derive(Debug, Deserialize, Error)]
#[error("{}", unreachable!("fatal: this error should never be constructed"))]
pub enum RpcGenesisConfigError {}

impl RpcHandlerResponse for RpcGenesisConfigResponse {}

impl RpcHandlerError for RpcGenesisConfigError {}

impl RpcMethod for RpcGenesisConfigRequest {
    type Response = RpcGenesisConfigResponse;
    type Error = RpcGenesisConfigError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_genesis_config"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcGenesisConfigRequest {}

'''
'''--- src/methods/experimental/mod.rs ---
use super::*;

pub mod changes;
pub use changes as EXPERIMENTAL_changes;

pub mod changes_in_block;
pub use changes_in_block as EXPERIMENTAL_changes_in_block;

pub mod check_tx;
pub use check_tx as EXPERIMENTAL_check_tx;

pub mod genesis_config;
pub use genesis_config as EXPERIMENTAL_genesis_config;

pub mod protocol_config;
pub use protocol_config as EXPERIMENTAL_protocol_config;

pub mod receipt;
pub use receipt as EXPERIMENTAL_receipt;

pub mod tx_status;
pub use tx_status as EXPERIMENTAL_tx_status;

pub mod validators_ordered;
pub use validators_ordered as EXPERIMENTAL_validators_ordered;

'''
'''--- src/methods/experimental/protocol_config.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::config::{
    RpcProtocolConfigError, RpcProtocolConfigRequest,
};

pub type RpcProtocolConfigResponse = near_chain_configs::ProtocolConfigView;

impl RpcHandlerResponse for RpcProtocolConfigResponse {}

impl RpcHandlerError for RpcProtocolConfigError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcProtocolConfigRequest {
    type Response = RpcProtocolConfigResponse;
    type Error = RpcProtocolConfigError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_protocol_config"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcProtocolConfigRequest {}

'''
'''--- src/methods/experimental/receipt.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::receipts::{RpcReceiptError, RpcReceiptRequest};

pub type RpcReceiptResponse = near_primitives::views::ReceiptView;

impl RpcHandlerResponse for RpcReceiptResponse {}

impl RpcHandlerError for RpcReceiptError {}

impl RpcMethod for RpcReceiptRequest {
    type Response = RpcReceiptResponse;
    type Error = RpcReceiptError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_receipt"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcReceiptRequest {}

'''
'''--- src/methods/experimental/tx_status.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::transactions::RpcTransactionError;
pub use near_jsonrpc_primitives::types::transactions::TransactionInfo;

pub type RpcTransactionStatusResponse =
    near_primitives::views::FinalExecutionOutcomeWithReceiptView;

#[derive(Debug)]
pub struct RpcTransactionStatusRequest {
    pub transaction_info: TransactionInfo,
}

impl From<RpcTransactionStatusRequest>
    for near_jsonrpc_primitives::types::transactions::RpcTransactionStatusCommonRequest
{
    fn from(this: RpcTransactionStatusRequest) -> Self {
        Self {
            transaction_info: this.transaction_info,
        }
    }
}

impl RpcHandlerResponse for RpcTransactionStatusResponse {}

impl RpcMethod for RpcTransactionStatusRequest {
    type Response = RpcTransactionStatusResponse;
    type Error = RpcTransactionError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_tx_status"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(match &self.transaction_info {
            TransactionInfo::Transaction(signed_transaction) => {
                json!([common::serialize_signed_transaction(signed_transaction)?])
            }
            TransactionInfo::TransactionId { hash, account_id } => {
                json!([hash, account_id])
            }
        })
    }
}

impl private::Sealed for RpcTransactionStatusRequest {}

'''
'''--- src/methods/experimental/validators_ordered.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::validator::{
    RpcValidatorError, RpcValidatorsOrderedRequest, RpcValidatorsOrderedResponse,
};

impl RpcHandlerResponse for RpcValidatorsOrderedResponse {}

impl RpcMethod for RpcValidatorsOrderedRequest {
    type Response = RpcValidatorsOrderedResponse;
    type Error = RpcValidatorError;

    fn method_name(&self) -> &str {
        "EXPERIMENTAL_validators_ordered"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcValidatorsOrderedRequest {}

'''
'''--- src/methods/gas_price.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::gas_price::{RpcGasPriceError, RpcGasPriceRequest};

pub type RpcGasPriceResponse = near_primitives::views::GasPriceView;

impl RpcHandlerResponse for RpcGasPriceResponse {}

impl RpcHandlerError for RpcGasPriceError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcGasPriceRequest {
    type Response = RpcGasPriceResponse;
    type Error = RpcGasPriceError;

    fn method_name(&self) -> &str {
        "gas_price"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!([self.block_id]))
    }
}

impl private::Sealed for RpcGasPriceRequest {}

'''
'''--- src/methods/health.rs ---
//! Requests the health status of the RPC node.
//!
//! ## Example
//!
//! Returns the current health stauts of the RPC node the client connects to.
//!
//! ```
//! use near_jsonrpc_client::{methods, JsonRpcClient};
//!
//! # #[tokio::main]
//! # async fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let client = JsonRpcClient::connect("https://rpc.testnet.near.org");
//!
//! let request = methods::health::RpcHealthRequest;
//!
//! let response = client.call(request).await?;
//!
//! assert!(matches!(
//!     response,
//!     methods::health::RpcHealthResponse
//! ));
//! # Ok(())
//! # }
//! ```
use super::*;

pub use near_jsonrpc_primitives::types::status::{RpcHealthResponse, RpcStatusError};

#[derive(Debug)]
pub struct RpcHealthRequest;

impl RpcHandlerResponse for RpcHealthResponse {}

impl RpcMethod for RpcHealthRequest {
    type Response = RpcHealthResponse;
    type Error = RpcStatusError;

    fn method_name(&self) -> &str {
        "health"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcHealthRequest {}

'''
'''--- src/methods/light_client_proof.rs ---
//! Returns the proofs for a transaction execution.
//!
//! ```
//! use near_jsonrpc_client::{methods, JsonRpcClient};
//! use near_primitives::types::TransactionOrReceiptId;
//!
//! # #[tokio::main]
//! # async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//! let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//!
//! let request = methods::light_client_proof::RpcLightClientExecutionProofRequest {
//!     id: TransactionOrReceiptId::Transaction {
//!         transaction_hash: "47sXP4jKXCMpkUS6kcxsfNU7tqysYr5fxWFdEXQkZh6z".parse()?,
//!         sender_id: "aurora.pool.near".parse()?,
//!     },
//!     light_client_head: "ANm3jm5wq1Z4rJv6tXWyiDtC3wYKpXVHY4iq6bE1te7B".parse()?,
//! };
//!
//! let response = client.call(request).await?;
//!
//! assert!(matches!(
//!     response,
//!     methods::light_client_proof::RpcLightClientExecutionProofResponse { .. }
//! ));
//! Ok(())
//! # }
//! ```
use super::*;

pub use near_jsonrpc_primitives::types::light_client::{
    RpcLightClientExecutionProofRequest, RpcLightClientExecutionProofResponse,
    RpcLightClientProofError,
};

impl RpcHandlerResponse for RpcLightClientExecutionProofResponse {}

impl RpcHandlerError for RpcLightClientProofError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcLightClientExecutionProofRequest {
    type Response = RpcLightClientExecutionProofResponse;
    type Error = RpcLightClientProofError;

    fn method_name(&self) -> &str {
        "light_client_proof"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcLightClientExecutionProofRequest {}

'''
'''--- src/methods/mod.rs ---
use std::io;

use serde::Deserialize;
use serde_json::json;
use thiserror::Error;

mod private {
    pub trait Sealed {}
}

pub trait RpcMethod: private::Sealed
where
    Self::Response: RpcHandlerResponse,
    Self::Error: RpcHandlerError,
{
    type Response;
    type Error;

    fn method_name(&self) -> &str;

    fn params(&self) -> Result<serde_json::Value, io::Error>;

    fn parse_handler_response(
        response: serde_json::Value,
    ) -> Result<Result<Self::Response, Self::Error>, serde_json::Error> {
        Self::Response::parse(response).map(Ok)
    }
}

impl<T> private::Sealed for &T where T: private::Sealed {}
impl<T> RpcMethod for &T
where
    T: RpcMethod,
{
    type Response = T::Response;
    type Error = T::Error;

    fn method_name(&self) -> &str {
        T::method_name(self)
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        T::params(self)
    }
}

pub trait RpcHandlerResponse: serde::de::DeserializeOwned {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        serde_json::from_value(value)
    }
}

pub trait RpcHandlerError: serde::de::DeserializeOwned {
    /// Parser for the `.error_struct` field in RpcError.
    fn parse(handler_error: serde_json::Value) -> Result<Self, serde_json::Error> {
        serde_json::from_value(handler_error)
    }

    /// Parser for the `.data` field in RpcError, not `.error_struct`.
    ///
    /// This would only ever be used as a fallback if [`RpcHandlerError::parse`] fails.
    ///
    /// Defaults to `None` meaning there's no alternative deserialization available.
    fn parse_legacy_error(_error: serde_json::Value) -> Option<Result<Self, serde_json::Error>> {
        None
    }
}

pub mod block;
pub mod broadcast_tx_async;
pub mod broadcast_tx_commit;
pub mod chunk;
pub mod gas_price;
pub mod health;
pub mod light_client_proof;
pub mod network_info;
pub mod next_light_client_block;
pub mod query;
pub mod status;
pub mod tx;
pub mod validators;

// ======== experimental ========
mod experimental;
pub use experimental::EXPERIMENTAL_changes;
pub use experimental::EXPERIMENTAL_changes_in_block;
pub use experimental::EXPERIMENTAL_check_tx;
pub use experimental::EXPERIMENTAL_genesis_config;
pub use experimental::EXPERIMENTAL_protocol_config;
pub use experimental::EXPERIMENTAL_receipt;
pub use experimental::EXPERIMENTAL_tx_status;
pub use experimental::EXPERIMENTAL_validators_ordered;
// ======== experimental ========

// ======== any ========
#[cfg(feature = "any")]
mod any;
#[cfg(feature = "any")]
pub use any::{request as any, RpcAnyRequest};
// ======== any ========

// ======== sandbox ========
#[cfg(feature = "sandbox")]
mod sandbox;

#[cfg(feature = "sandbox")]
pub use sandbox::sandbox_patch_state;

#[cfg(feature = "sandbox")]
pub use sandbox::sandbox_fast_forward;
// ======== sandbox ========

// ======== adversarial ========
#[cfg(feature = "adversarial")]
mod adversarial;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_set_weight;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_disable_header_sync;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_disable_doomslug;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_produce_blocks;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_switch_to_height;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_get_saved_blocks;

#[cfg(feature = "adversarial")]
pub use adversarial::adv_check_store;
// ======== adversarial ========

pub fn to_json<M: RpcMethod>(method: &M) -> Result<serde_json::Value, io::Error> {
    let request_payload = near_jsonrpc_primitives::message::Message::request(
        method.method_name().to_string(),
        Some(method.params()?),
    );

    Ok(json!(request_payload))
}

mod common {
    use super::*;

    // workaround for deserializing partially serialized
    // error types missing the `error_message` field in
    // their UnknownBlock variants.
    macro_rules! _parse_unknown_block {
        ($json:expr => $err_ty:ident) => {
            match $json {
                err => {
                    if err["name"] == "UNKNOWN_BLOCK" {
                        Ok($err_ty::UnknownBlock {
                            error_message: "".to_string(),
                        })
                    } else {
                        serde_json::from_value(err)
                    }
                }
            }
        };
    }
    pub(crate) use _parse_unknown_block as parse_unknown_block;

    pub fn serialize_signed_transaction(
        tx: &near_primitives::transaction::SignedTransaction,
    ) -> Result<String, io::Error> {
        Ok(near_primitives::serialize::to_base64(
            &borsh::BorshSerialize::try_to_vec(&tx)?,
        ))
    }

    // adv_*
    #[cfg(feature = "adversarial")]
    impl RpcHandlerError for () {}

    // adv_*
    #[cfg(feature = "adversarial")]
    impl RpcHandlerResponse for () {
        fn parse(_value: serde_json::Value) -> Result<Self, serde_json::Error> {
            Ok(())
        }
    }

    #[cfg(feature = "any")]
    impl RpcHandlerResponse for serde_json::Value {
        fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
            Ok(value)
        }
    }

    #[cfg(feature = "any")]
    impl RpcHandlerError for serde_json::Value {
        fn parse(handler_error: serde_json::Value) -> Result<Self, serde_json::Error> {
            Ok(handler_error)
        }
    }

    // broadcast_tx_commit, tx
    impl RpcHandlerResponse for near_primitives::views::FinalExecutionOutcomeView {}

    // broadcast_tx_commit, tx, EXPERIMENTAL_check_tx, EXPERIMENTAL_tx_status
    impl RpcHandlerError for near_jsonrpc_primitives::types::transactions::RpcTransactionError {
        fn parse_legacy_error(value: serde_json::Value) -> Option<Result<Self, serde_json::Error>> {
            match serde_json::from_value::<near_jsonrpc_primitives::errors::ServerError>(value) {
                Ok(near_jsonrpc_primitives::errors::ServerError::TxExecutionError(
                    near_primitives::errors::TxExecutionError::InvalidTxError(context),
                )) => Some(Ok(Self::InvalidTransaction { context })),
                Err(err) => Some(Err(err)),
                _ => None,
            }
        }
    }

    // health, status
    impl RpcHandlerError for near_jsonrpc_primitives::types::status::RpcStatusError {}

    // EXPERIMENTAL_changes, EXPERIMENTAL_changes_in_block
    impl RpcHandlerError for near_jsonrpc_primitives::types::changes::RpcStateChangesError {
        fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
            parse_unknown_block!(value => Self)
        }
    }

    // EXPERIMENTAL_broadcast_tx_sync, EXPERIMENTAL_check_tx
    impl RpcHandlerResponse
        for near_jsonrpc_primitives::types::transactions::RpcBroadcastTxSyncResponse
    {
    }

    // validators, EXPERIMENTAL_validators_ordered
    impl RpcHandlerError for near_jsonrpc_primitives::types::validator::RpcValidatorError {}
}

'''
'''--- src/methods/network_info.rs ---
//! Queries the current state of node network connections.
//!
//! This includes information about active peers, transmitted data, known producers, etc.
//!
//! ## Example
//!
//! ```
//! use near_jsonrpc_client::{methods, JsonRpcClient};
//!
//! # #[tokio::main]
//! # async fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let client = JsonRpcClient::connect("https://rpc.testnet.near.org");
//!
//! let request = methods::network_info::RpcNetworkInfoRequest;
//!
//! let response = client.call(request).await;
//!
//! assert!(matches!(
//!     response,
//!     Ok(methods::network_info::RpcNetworkInfoResponse { .. })
//! ));
//! # Ok(())
//! # }
//! ```
use super::*;

pub use near_jsonrpc_primitives::types::network_info::{
    RpcNetworkInfoError, RpcNetworkInfoResponse,
};

#[derive(Debug)]
pub struct RpcNetworkInfoRequest;

impl RpcHandlerResponse for RpcNetworkInfoResponse {}

impl RpcHandlerError for RpcNetworkInfoError {}

impl RpcMethod for RpcNetworkInfoRequest {
    type Response = RpcNetworkInfoResponse;
    type Error = RpcNetworkInfoError;

    fn method_name(&self) -> &str {
        "network_info"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcNetworkInfoRequest {}

'''
'''--- src/methods/next_light_client_block.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::light_client::{
    RpcLightClientNextBlockError, RpcLightClientNextBlockRequest,
};
pub use near_primitives::views::LightClientBlockView;

pub type RpcLightClientNextBlockResponse = Option<LightClientBlockView>;

impl RpcHandlerResponse for RpcLightClientNextBlockResponse {}

impl RpcHandlerError for RpcLightClientNextBlockError {
    fn parse(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        common::parse_unknown_block!(value => Self)
    }
}

impl RpcMethod for RpcLightClientNextBlockRequest {
    type Response = RpcLightClientNextBlockResponse;
    type Error = RpcLightClientNextBlockError;

    fn method_name(&self) -> &str {
        "next_light_client_block"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcLightClientNextBlockRequest {}

'''
'''--- src/methods/query.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::query::{RpcQueryError, RpcQueryRequest, RpcQueryResponse};

impl RpcHandlerResponse for RpcQueryResponse {}

impl RpcHandlerError for RpcQueryError {}

impl private::Sealed for RpcQueryRequest {}

impl RpcMethod for RpcQueryRequest {
    type Response = RpcQueryResponse;
    type Error = RpcQueryError;

    fn method_name(&self) -> &str {
        "query"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }

    fn parse_handler_response(
        response: serde_json::Value,
    ) -> Result<Result<Self::Response, Self::Error>, serde_json::Error> {
        match serde_json::from_value::<QueryResponse>(response)? {
            QueryResponse::HandlerResponse(r) => Ok(Ok(r)),
            QueryResponse::HandlerError(LegacyQueryError {
                error,
                block_height,
                block_hash,
            }) => {
                let mut err_parts = error.split(' ');
                let query_error = if let (
                    Some("access"),
                    Some("key"),
                    Some(pk),
                    Some("does"),
                    Some("not"),
                    Some("exist"),
                    Some("while"),
                    Some("viewing"),
                    None,
                ) = (
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                    err_parts.next(),
                ) {
                    let public_key = pk
                        .parse::<near_crypto::PublicKey>()
                        .map_err(serde::de::Error::custom)?;
                    RpcQueryError::UnknownAccessKey {
                        public_key,
                        block_height,
                        block_hash,
                    }
                } else {
                    RpcQueryError::ContractExecutionError {
                        vm_error: error,
                        block_height,
                        block_hash,
                    }
                };

                Ok(Err(query_error))
            }
        }
    }
}

#[derive(serde::Deserialize)]
#[serde(untagged)]
enum QueryResponse {
    HandlerResponse(RpcQueryResponse),
    HandlerError(LegacyQueryError),
}

#[derive(serde::Deserialize)]
struct LegacyQueryError {
    error: String,
    block_height: near_primitives::types::BlockHeight,
    block_hash: near_primitives::hash::CryptoHash,
}

#[cfg(test)]
mod tests {
    use {super::*, crate::*};

    #[tokio::test]
    async fn test_unknown_access_key() -> Result<(), Box<dyn std::error::Error>> {
        let client = JsonRpcClient::connect("https://archival-rpc.testnet.near.org");

        let request = RpcQueryRequest {
            block_reference: near_primitives::types::BlockReference::BlockId(
                near_primitives::types::BlockId::Height(63503911),
            ),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: "miraclx.testnet".parse()?,
                public_key: "ed25519:9KnjTjL6vVoM8heHvCcTgLZ67FwFkiLsNtknFAVsVvYY".parse()?,
            },
        };

        let response_err = client.call(request).await.unwrap_err();

        assert!(
            matches!(
                response_err.handler_error(),
                Some(RpcQueryError::UnknownAccessKey {
                    ref public_key,
                    block_height: 63503911,
                    ..
                }) if public_key.to_string() == "ed25519:9KnjTjL6vVoM8heHvCcTgLZ67FwFkiLsNtknFAVsVvYY"
            ),
            "{:#?}",
            response_err
        );

        Ok(())
    }

    #[tokio::test]
    async fn test_contract_execution_error() -> Result<(), Box<dyn std::error::Error>> {
        let client = JsonRpcClient::connect("https://archival-rpc.testnet.near.org");

        let request = RpcQueryRequest {
            block_reference: near_primitives::types::BlockReference::BlockId(
                near_primitives::types::BlockId::Height(63503911),
            ),
            request: near_primitives::views::QueryRequest::CallFunction {
                #[allow(deprecated)]
                account_id: "miraclx.testnet".parse()?,
                method_name: "".to_string(),
                args: vec![].into(),
            },
        };

        let response_err = client.call(request).await.unwrap_err();

        assert!(
            matches!(
                response_err.handler_error(),
                Some(RpcQueryError::ContractExecutionError {
                    ref vm_error,
                    block_height: 63503911,
                    ..
                }) if vm_error.contains("FunctionCallError(MethodResolveError(MethodEmptyName))")
            ),
            "{:#?}",
            response_err
        );

        Ok(())
    }
}

'''
'''--- src/methods/sandbox/fast_forward.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::sandbox::{
    RpcSandboxFastForwardError, RpcSandboxFastForwardRequest, RpcSandboxFastForwardResponse,
};

impl RpcHandlerResponse for RpcSandboxFastForwardResponse {}

impl RpcHandlerError for RpcSandboxFastForwardError {}

impl RpcMethod for RpcSandboxFastForwardRequest {
    type Response = RpcSandboxFastForwardResponse;
    type Error = RpcSandboxFastForwardError;

    fn method_name(&self) -> &str {
        "sandbox_fast_forward"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcSandboxFastForwardRequest {}

'''
'''--- src/methods/sandbox/mod.rs ---
use super::*;

pub mod patch_state;
pub use patch_state as sandbox_patch_state;

pub mod fast_forward;
pub use fast_forward as sandbox_fast_forward;

'''
'''--- src/methods/sandbox/patch_state.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::sandbox::{
    RpcSandboxPatchStateError, RpcSandboxPatchStateRequest, RpcSandboxPatchStateResponse,
};

impl RpcHandlerResponse for RpcSandboxPatchStateResponse {}

impl RpcHandlerError for RpcSandboxPatchStateError {}

impl RpcMethod for RpcSandboxPatchStateRequest {
    type Response = RpcSandboxPatchStateResponse;
    type Error = RpcSandboxPatchStateError;

    fn method_name(&self) -> &str {
        "sandbox_patch_state"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcSandboxPatchStateRequest {}

'''
'''--- src/methods/status.rs ---
//! Requests the status of the connected RPC node.
//!
//! This includes information about sync status, nearcore node version, protocol version, the current set of validators, etc.
//!
//! ## Example
//!
//! ```
//! use near_jsonrpc_client::{methods, JsonRpcClient};
//!
//! # #[tokio::main]
//! # async fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let client = JsonRpcClient::connect("https://rpc.testnet.near.org");
//!
//! let request = methods::status::RpcStatusRequest;
//!
//! let response = client.call(request).await?;
//!
//! assert!(matches!(
//!     response,
//!     methods::status::RpcStatusResponse { .. }
//! ));
//! # Ok(())
//! # }
//! ```
use super::*;

pub use near_jsonrpc_primitives::types::status::RpcStatusError;

pub type RpcStatusResponse = near_primitives::views::StatusResponse;

#[derive(Debug)]
pub struct RpcStatusRequest;

impl RpcHandlerResponse for RpcStatusResponse {}

impl RpcMethod for RpcStatusRequest {
    type Response = RpcStatusResponse;
    type Error = RpcStatusError;

    fn method_name(&self) -> &str {
        "status"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(null))
    }
}

impl private::Sealed for RpcStatusRequest {}

'''
'''--- src/methods/tx.rs ---
//! Queries the status of a transaction.
//!
//! ## Example
//! Returns the final transaction result for
//! <https://explorer.near.org/transactions/B9aypWiMuiWR5kqzewL9eC96uZWA3qCMhLe67eBMWacq>
//!
//! ```
//! use near_jsonrpc_client::{methods, JsonRpcClient};
//!
//! # #[tokio::main]
//! # async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
//! let client = JsonRpcClient::connect("https://archival-rpc.mainnet.near.org");
//! let tx_hash = "B9aypWiMuiWR5kqzewL9eC96uZWA3qCMhLe67eBMWacq".parse()?;
//!
//! let request = methods::tx::RpcTransactionStatusRequest {
//!     transaction_info: methods::tx::TransactionInfo::TransactionId {
//!         hash: tx_hash,
//!         account_id: "itranscend.near".parse()?,
//!    }
//! };
//!
//! let response = client.call(request).await?;
//!
//! assert_eq!(tx_hash, response.transaction.hash);
//! # Ok(())
//! # }
//! ```
use super::*;

pub use near_jsonrpc_primitives::types::transactions::RpcTransactionError;
pub use near_jsonrpc_primitives::types::transactions::TransactionInfo;

pub type RpcTransactionStatusResponse = near_primitives::views::FinalExecutionOutcomeView;

#[derive(Debug)]
pub struct RpcTransactionStatusRequest {
    pub transaction_info: TransactionInfo,
}

impl From<RpcTransactionStatusRequest>
    for near_jsonrpc_primitives::types::transactions::RpcTransactionStatusCommonRequest
{
    fn from(this: RpcTransactionStatusRequest) -> Self {
        Self {
            transaction_info: this.transaction_info,
        }
    }
}

impl RpcMethod for RpcTransactionStatusRequest {
    type Response = RpcTransactionStatusResponse;
    type Error = RpcTransactionError;

    fn method_name(&self) -> &str {
        "tx"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(match &self.transaction_info {
            TransactionInfo::Transaction(signed_transaction) => {
                json!([common::serialize_signed_transaction(signed_transaction)?])
            }
            TransactionInfo::TransactionId { hash, account_id } => {
                json!([hash, account_id])
            }
        })
    }
}

impl private::Sealed for RpcTransactionStatusRequest {}

'''
'''--- src/methods/validators.rs ---
use super::*;

pub use near_jsonrpc_primitives::types::validator::{RpcValidatorError, RpcValidatorRequest};

pub type RpcValidatorResponse = near_primitives::views::EpochValidatorInfo;

impl RpcHandlerResponse for RpcValidatorResponse {}

impl RpcMethod for RpcValidatorRequest {
    type Response = RpcValidatorResponse;
    type Error = RpcValidatorError;

    fn method_name(&self) -> &str {
        "validators"
    }

    fn params(&self) -> Result<serde_json::Value, io::Error> {
        Ok(json!(self))
    }
}

impl private::Sealed for RpcValidatorRequest {}

'''