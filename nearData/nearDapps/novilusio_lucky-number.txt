*GitHub Repository "novilusio/lucky-number"*

'''--- README.md ---
# LUCKY NUMBER

> ## Lucky Number is a project prepared at the end of the NCD training.

**Lucky Number** is a **game** of **chance** played with _two users._

- Each player must deposit **1 NEAR** to play.

- _A random number_ between **1** and **10** is generated for each user.

- The numbers assigned to the users are compared.

- _The big number_ wins the game.

- The total **2 NEAR** taken as a deposit is transferred to the winner account.

- If the numbers are _equal,_ **1 NEAR** deposit is paid back to users' accounts.

## Prerequisites

Lucky Number is a smart contract running on NEAR. We should install near-cli to play.

- Install yarn.
```
yarn
```

- Install near-cli
```
npm install --global near-cli
```

## Build - Deploy

- First, we need to **login.**
```
near login
```

- **Build** to the contract.
```
yarn build 
```

- **Deploy** to the conract.
```
yarn deploy
```

- Copy **dev-123-789** from the _neardev/dev-account_ folder.
```
export CONTRACT=<your_dev_id>
```

## How to Play

- **Create** a new game.
```
near call $CONTRACT createLucky --accountId <your_account.testnet> --amount 1
```

- For the **Second Player** to participate.
```
near call $CONTRACT findLuck '{"id":"<gameId>"}' --accountId <player_2.testnet> --amount 1
```

- Are you fortunate ?
```
near call $CONTRACT fortune '{"id": "<gameId>"}' --accountId <any_player.testnet>
```
> ## **Check your wallet. :)**

## Access Smart Contract

- To search for _any game_.
```
near call $CONTRACT viewLucky '{"id": "<game_id>"}' --accountId <your_account.testnet>
```

- To see _all games_.
```
near call $CONTRACT allLucky --accountId <your_account.testnet>
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo",
    "deploy": "near dev-deploy build/debug/simple.wasm"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/debug/simple.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=<dev-123-456>'
echo
echo 'export OWNER=<your own account>'
echo
echo

exit 0
'''
'''--- scripts/2.create-Lucky.sh ---
#!/usr/bin/env bash

set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1

echo
echo 'Defining the $PLAYER1'
export PLAYER1=$OWNER

[ -z "$PLAYER1" ] && echo "Missing \$PLAYER1 environment variable" && exit 1

echo 'About to call createLucky() on the contract'
echo near call \$CONTRACT createLucky --account_id \$PLAYER1 --amount 1
echo
echo \$CONTRACT is $CONTRACT
echo \$PLAYER1 is $PLAYER1
echo
near call $CONTRACT createLucky --account_id $PLAYER1 --amount 1

echo 'Define $GAMEID and $PLAYER2'
echo --------------------------------------------
echo run the following commands
echo
echo 'export GAMEID=<game_Id>'
echo
echo 'export PLAYER2=<player_2>'
'''
'''--- scripts/3.find-Luck.sh ---
#!/usr/bin/env bash

set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$GAMEID" ] && echo "Missing \$GAMEID environment variable" && exit 1
[ -z "$PLAYER2" ] && echo "Missing \$PLAYER2 environment variable" && exit 1

echo 'About to call findLuck(id: string) on the contract'
echo near call \$CONTRACT findLuck '{"id": '\$GAMEID'}' --account_id \$PLAYER2 --amount 1
echo
echo \$CONTRACT is $CONTRACT
echo \$GAMEID is $GAMEID
echo \$PLAYER2 is $PLAYER2
echo
near call $CONTRACT findLuck '{"id": "'"$GAMEID"'"}' --account_id $PLAYER2 --amount 1

'''
'''--- scripts/4.fortune.sh ---
#!/usr/bin/env bash

set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$GAMEID" ] && echo "Missing \$GAMEID environment variable" && exit 1
[ -z "$PLAYER2" ] && echo "Missing \$PLAYER2 environment variable" && exit 1

echo 'About to call fortune(id: string) on the contract'
echo near call \$CONTRACT fortune '{"id": '\$GAMEID'}' --account_id \$PLAYER2
echo
echo \$CONTRACT is $CONTRACT
echo \$GAMEID is $GAMEID
echo \$PLAYER2 is $PLAYER2
echo
near call $CONTRACT fortune '{"id": "'"$GAMEID"'"}' --account_id $PLAYER2
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { context, u128, ContractPromiseBatch, RNG } from "near-sdk-as";
import { ONE_NEAR } from "../../utils";
import { LuckyNumber, games} from "./model";
//
//
//-----   CREATE A GAME   ----- //
//
/*  -->   near call $CONTRACT createLucky --accountId <your_account.testnet> --amount 1   <--    */
//
//
export function createLucky(): string {
  assert(context.attachedDeposit == ONE_NEAR, 'Pay 1 NEAR for luck ;) ');
  const luck = new LuckyNumber();
  games.set(luck.id, luck);

  return luck.id;
}
//
//
//-----   FIND A GAME    ----- //
//
/*  -->   near call $CONTRACT findLuck '{"id":"<gameId>"}' --accountId <player2.testnet> --amount 1   <--      */
//
//
export function findLuck(id: string): string {
  assert(games.contains(id), 'You are not Lucky :( ');
  assert(context.attachedDeposit == ONE_NEAR, 'Pay 1 NEAR for luck ;) ');

  let luck = games.getSome(id);
  assert(luck.player2 == "", "Already has two lucky."), 
  assert(luck.player1 != context.sender, "Please find another lucky");
  

  luck.betAmount = u128.add(luck.betAmount, context.attachedDeposit);

  luck.player2 = context.sender;

  games.set(id, luck);

  return `Game is ready! Bet Amount: ${luck.betAmount} Good Luck!`;
}
//
//
//-----   GAMEPLAY    ----- //
//
/*    -->  near call $CONTRACT fortune '{"id": "<gameId>"}' --accountId <any_player.testnet>   <--       */
//
//
export function fortune(id:string): string {

  let luck = games.getSome(id);
 
  
  let randomNum = new RNG<u8>(1,10);
  luck.num1 = randomNum.next();
  luck.num2 = randomNum.next();
  
  let info = "";
  let LuckyNumbers = [luck.num1, luck.num2];
  

  if (luck.num1 > luck.num2){
    info = `${luck.player1} Won! 2NEAR sent to ${luck.player1}.` 
    const winPlayer1 = ContractPromiseBatch.create(luck.player1);
    winPlayer1.transfer(luck.betAmount);
  }
  else if (luck.num1 < luck.num2){
    info = `${luck.player2} Won! 2NEAR sent to ${luck.player2}.`
    const winPlayer2 = ContractPromiseBatch.create(luck.player2);
    winPlayer2.transfer(luck.betAmount);
  }
  else if (luck.num1 == luck.num2){
    info = `Double Chance! 1NEAR deposit has been refunded to your acount.`

    const to_player1 = ContractPromiseBatch.create(luck.player1);
    const to_player2 = ContractPromiseBatch.create(luck.player2);
    const payBack = u128.sub(luck.betAmount, ONE_NEAR);
    to_player1.transfer(payBack);
    to_player2.transfer(payBack);
  }

  games.set(luck.id, luck);
  return info + " " + `${luck.player1}'s Number --> ${luck.num1}` + " " + `${luck.player2}'s Number --> ${luck.num2}`
}
//
//
//-----   VIEW    ----- //
//
/*    --> near call $CONTRACT viewLucky '{"id": "<game_id>"}' --accountId <your_account.testnet>   <--     */
//
//
export function viewLucky(id: string): LuckyNumber {
  return games.getSome(id);
} 
//
/*    --> near call $CONTRACT allLucky --accountId <your_account.testnet>   <--     */
//
export function allLucky(): Array<LuckyNumber> {
  return games.values();
}

'''
'''--- src/simple/assembly/model.ts ---
import { PersistentUnorderedMap, context, u128, RNG } from "near-sdk-as"

@nearBindgen

export class LuckyNumber {
  id: string;
  player1: string;
  player2: string;
  betAmount: u128;
  num1: u8;
  num2: u8;

  constructor() {

    let randomId = new RNG<u32>(1, u32.MAX_VALUE);
    let idroll = randomId.next();
    
    this.id = idroll.toString();

    this.player1 = context.sender;
    this.player2 = "";
    this.betAmount = context.attachedDeposit;
    this.num1 = this.num1;
    this.num1 = this.num2;
  }
}

export const games = new PersistentUnorderedMap<string, LuckyNumber>('g');
'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { storage, Context } from "near-sdk-core"

@nearBindgen
export class Contract {
  private message: string = 'hello world'

  // return the string 'hello world'
  helloWorld(): string {
    return this.message
  }

  // read the given key from account (contract) storage
  read(key: string): string {
    if (isKeyInStorage(key)) {
      return `✅ Key [ ${key} ] has value [ ${storage.getString(key)!} ] and "this.message" is [ ${this.message} ]`
    } else {
      return `🚫 Key [ ${key} ] not found in storage. ( ${this.storageReport()} )`
    }
  }

  /**
  write the given value at the given key to account (contract) storage
  ---
  note: this is what account storage will look like AFTER the write() method is called the first time
  ╔════════════════════════════════╤══════════════════════════════════════════════════════════════════════════════════╗
  ║                            key │ value                                                                            ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                          STATE │ {                                                                                ║
  ║                                │   "message": "data was saved"                                                    ║
  ║                                │ }                                                                                ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                       some-key │ some value                                                                       ║
  ╚════════════════════════════════╧══════════════════════════════════════════════════════════════════════════════════╝
   */
  @mutateState()
  write(key: string, value: string): string {
    storage.set(key, value)
    this.message = 'data was saved' // this is why we need the deorator @mutateState() above the method name
    return `✅ Data saved. ( ${this.storageReport()} )`
  }

  // private helper method used by read() and write() above
  private storageReport(): string {
    return `storage [ ${Context.storageUsage} bytes ]`
  }
}

/**
 * This function exists only to avoid a compiler error
 *

ERROR TS2339: Property 'contains' does not exist on type 'src/singleton/assembly/index/Contract'.

     return this.contains(key);
                 ~~~~~~~~
 in ~lib/near-sdk-core/storage.ts(119,17)

/Users/sherif/Documents/code/near/_projects/edu.t3/starter--near-sdk-as/node_modules/asbuild/dist/main.js:6
        throw err;
        ^

 * @param key string key in account storage
 * @returns boolean indicating whether key exists
 */
function isKeyInStorage(key: string): bool {
  return storage.hasKey(key)
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''