*GitHub Repository "near/near-enhanced-api-server"*

'''--- Cargo.toml ---
[package]
name = "near-enhanced-api"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
publish = false
rust-version = "1.61.0"
edition = "2021"

[dependencies]
actix-web = { version = "4.0.1", features = ["macros"] }
actix-web-validator = "3.0.0"
actix-http = "3.0.4"
actix-cors = "0.6.1"
actix-web-prom = "0.6.0"
borsh = { version = "0.9.1" }
derive_more = "0.99.9"
dotenv = "0.15.0"
futures = "0.3.5"
hex = "0.4"
num-traits = "0.2.15"
# https://github.com/paperclip-rs/paperclip/pull/463
# Without this fix, the API URL won't be set properly
paperclip = { git = "https://github.com/near/paperclip", branch = "feat/respect-host-in-v2-to-v3-servers-conversion", features = ["v2", "v3", "actix4", "actix4-validator"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
strum = { version = "0.24", features = ["derive"] }
sqlx = { version = "0.6", features = ["runtime-tokio-native-tls", "postgres", "bigdecimal", "json"] }
tokio = { version = "1.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
validator = { version = "0.14", features = ["derive"] }

near-primitives = "0.14.0"
near-jsonrpc-client = "0.4.0-beta.0"
near-jsonrpc-primitives = "0.14.0"

[dev-dependencies]
insta = "1"

'''
'''--- DB_DESIGN.md ---
# DB Enhancement Proposals

We have found some issues in Indexer DB.
In order to provide all the desired features to the API, we have some required and some aspirational changes.

## New requirements for any assets__* table:
1. enumeration column that goes through all the events. Required for all endpoints with pagination.  
   Let's say we can have max 10_000 of all the events per chunk  
   max 1000 of different standards  
   max 10_000 chunks  
We take timestamp in milliseconds to have more available slots for storing the info.  
We also multiply timestamp to a big number, so that we have 10^35 in general.  
It will allow us to change the format further without breaking the compatibility.  
   The formula:
```
timestamp_millis * 100_000_000_000 * 100_000_000_000 + chunk_index * 10_000_000 + assets_type * 10_000 + index_of_event
```
It gives us the number like this:
```
16565042430000000000000000030070027 -> 10^35
```
Major thing: it fits into `i128` (10^38).

## New requirements for assets__fungible_token_events table:
1. Change old/new account_id to affected/involved account_id.

## New requirements for account_changes and balances table:
1. Change the table so that we have the same enumeration column. Required for native_history (pagination)  
   Let's say we can have max 1_000_000 of balance changing actions per chunk  
   max 10_000 chunks  
   The formula:
```
timestamp_millis * 10_000_000_000 * 1_000_000_000_000 + chunk_index * 1_000_000 + index_in_chunk
```
It gives us the number like this:
```
16565042430000000000000000003000027 -> 10^35
```
Major thing: it fits into `i128` (10^38).

## Ideas how to make the queries faster:
1. Add table with the NEAR balance daily by account_id. Will speed up native_balance
2. Add table with the FT balance daily by account_id. Will speed up coin_balances
3. Add table with the MT balance daily by account_id. Will speed up coin_balances
4. Add table with the NFT countings daily by account_id. Will speed up nft_collection_overview
5. check_account_exists already works faster in Aurora DB. This will speed up all the endpoints a bit
6. Add table with FT, MT, NFT contract metadatas by timestamp. I'd prefer to check this once in an hour. Do we want to add something like "enforce checking new metadata"? Will speed up all the places where we provide metadata (almost all endpoints)
7. Add table with MT, NFT tokens metadata.

'''
'''--- README.md ---
# NEAR Enhanced API

API for providing useful information about NEAR blockchain.  
Still under heavy development.

### Supported features

- Provide NEAR balances information, history
- Provide FT balances information, FT history (*)
- Provide NFT information and recent history for the contracts implementing Events NEP
- Provide corresponding Metadata for FT, NFT contracts, NFT items

(*) We support all the FT contracts implementing Events NEP and some popular legacy contracts such as `aurora`, `wrap.near` and few others.
If your contract is not supported, please update with our new [SDK](https://github.com/near/near-sdk-rs).  
If it's important for you to collect all the previous history as well, you need to make the contribution and implement your own legacy handler.
You can use [existing handlers](https://github.com/near/near-microindexers/tree/main/indexer-events/src/db_adapters/coin/legacy) as the example.

'''
'''--- src/config.rs ---
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    pub addr: String,
    pub cors_allowed_origins: Vec<String>,
    #[serde(default)]
    pub limits: LimitsConfig,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            addr: "0.0.0.0:3050".to_owned(),
            cors_allowed_origins: vec!["*".to_owned()],
            limits: LimitsConfig::default(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LimitsConfig {
    pub input_payload_max_size: usize,
}

impl Default for LimitsConfig {
    fn default() -> Self {
        Self {
            input_payload_max_size: 10 * 1024 * 1024,
        }
    }
}

'''
'''--- src/db_helpers.rs ---
use sqlx::{postgres::PgRow, Arguments};

use crate::{errors, types, BigDecimal};

// The DB replicas apply the WALs each X seconds (X=30 or 300 in our case, depend on replica).
// If the SELECT query started right before WAL started to apply, the query is cancelled.
// That's why we need to try the second time.
// If it hits the limit again, it makes to sense to try run it the third time,
// 99% we will hit the limit again, that's why we have 2 here
const DB_RETRY_COUNT: usize = 2;

const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);

pub struct ExplorerPool(pub sqlx::Pool<sqlx::Postgres>);
pub struct BalancesPool(pub sqlx::Pool<sqlx::Postgres>);

#[derive(sqlx::FromRow)]
struct BlockView {
    pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
}

#[derive(sqlx::FromRow)]
pub(crate) struct AccountId {
    pub account_id: String,
}

#[derive(Debug)]
pub(crate) struct Block {
    pub timestamp: u64,
    pub height: u64,
}

impl TryFrom<&BlockView> for Block {
    type Error = errors::Error;

    fn try_from(block: &BlockView) -> crate::Result<Self> {
        Ok(Self {
            timestamp: types::numeric::to_u64(&block.block_timestamp)?,
            height: types::numeric::to_u64(&block.block_height)?,
        })
    }
}

pub(crate) fn timestamp_to_event_index(timestamp: u64) -> u128 {
    timestamp as u128 * 100_000_000 * 100_000_000
}

pub(crate) fn event_index_to_timestamp(event_index: u128) -> u64 {
    (event_index / (100_000_000 * 100_000_000)) as u64
}

pub(crate) async fn get_block_from_pagination(
    pool_explorer: &ExplorerPool,
    pagination: &types::query_params::Pagination,
) -> crate::Result<Block> {
    checked_get_block(
        pool_explorer,
        &types::query_params::BlockParams {
            block_timestamp_nanos: pagination
                .after_event_index
                .map(|event_index| event_index_to_timestamp(event_index).into()),
            block_height: None,
        },
    )
    .await
}

/// Validates block_params received from the user, sets the default value if none was provided
pub(crate) async fn checked_get_block(
    pool_explorer: &ExplorerPool,
    block_params: &types::query_params::BlockParams,
) -> crate::Result<Block> {
    if block_params.block_height.is_some() && block_params.block_timestamp_nanos.is_some() {
        return Err(errors::ErrorKind::InvalidInput(
            "Both block_height and block_timestamp_nanos found. Please provide only one of values"
                .to_string(),
        )
        .into());
    }

    if let Some(block_height) = block_params.block_height {
        match select_retry_or_panic::<BlockView>(
            &pool_explorer.0,
            r"SELECT block_height, block_timestamp
              FROM blocks
              WHERE block_height = $1::numeric(20, 0)",
            &[block_height.0.to_string()],
        )
        .await?
        .first()
        {
            None => Err(errors::ErrorKind::InvalidInput(format!(
                "block_height {} is not found",
                block_height.0
            ))
            .into()),
            Some(block) => Ok(Block::try_from(block)?),
        }
    } else if let Some(block_timestamp) = block_params.block_timestamp_nanos {
        match select_retry_or_panic::<BlockView>(
            &pool_explorer.0,
            r"SELECT block_height, block_timestamp
              FROM blocks
              WHERE block_timestamp <= $1::numeric(20, 0)
              ORDER BY block_timestamp DESC
              LIMIT 1",
            &[block_timestamp.0.to_string()],
        )
        .await?
        .first()
        {
            Some(block) => Ok(Block::try_from(block)?),
            None => get_first_block(pool_explorer).await,
        }
    } else {
        get_last_block(pool_explorer).await
    }
}

async fn get_first_block(ExplorerPool(pool_explorer): &ExplorerPool) -> crate::Result<Block> {
    match select_retry_or_panic::<BlockView>(
        pool_explorer,
        r"SELECT block_height, block_timestamp
          FROM blocks
          ORDER BY block_timestamp
          LIMIT 1",
        &[],
    )
    .await?
    .first()
    {
        None => Err(errors::ErrorKind::DBError("blocks table is empty".to_string()).into()),
        Some(block) => Ok(Block::try_from(block)?),
    }
}

pub(crate) async fn get_last_block(
    ExplorerPool(pool_explorer): &ExplorerPool,
) -> crate::Result<Block> {
    match select_retry_or_panic::<BlockView>(
        pool_explorer,
        r"SELECT block_height, block_timestamp
          FROM blocks
          ORDER BY block_timestamp DESC
          LIMIT 1",
        &[],
    )
    .await?
    .first()
    {
        None => Err(errors::ErrorKind::DBError("blocks table is empty".to_string()).into()),
        Some(block) => Ok(Block::try_from(block)?),
    }
}

pub(crate) async fn get_previous_block(
    pool_explorer: &sqlx::Pool<sqlx::Postgres>,
    current_block_timestamp: u64,
) -> crate::Result<Block> {
    match select_retry_or_panic::<BlockView>(
        pool_explorer,
        r"SELECT block_height, block_timestamp
           FROM blocks
           WHERE block_timestamp < $1::numeric(20, 0)
           ORDER BY block_timestamp DESC
           LIMIT 1",
        &[current_block_timestamp.to_string()],
    )
    .await?
    .first()
    {
        None => Err(errors::ErrorKind::DBError("blocks table is empty".to_string()).into()),
        Some(block) => Ok(Block::try_from(block)?),
    }
}

pub(crate) async fn select_retry_or_panic<T: Send + Unpin + for<'r> sqlx::FromRow<'r, PgRow>>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    query: &str,
    substitution_items: &[String],
) -> Result<Vec<T>, errors::ErrorKind> {
    let mut interval = INTERVAL;
    let mut retry_attempt = 0usize;

    tracing::info!(
        target: crate::LOGGER_MSG,
        "DB request:\n{}\nParams:{}",
        query,
        substitution_items.join(", ")
    );

    loop {
        if retry_attempt == DB_RETRY_COUNT {
            return Err(errors::ErrorKind::DBError(format!(
                "Failed to perform query to database after {} attempts. Stop trying.",
                DB_RETRY_COUNT
            )));
        }
        retry_attempt += 1;

        let mut args = sqlx::postgres::PgArguments::default();
        for item in substitution_items {
            args.add(item);
        }

        match sqlx::query_as_with::<_, T, _>(query, args)
            .fetch_all(pool)
            .await
        {
            Ok(res) => return Ok(res),
            Err(async_error) => {
                tracing::warn!(
                    target: crate::LOGGER_MSG,
                    "Error occurred during {:#?}:\nFailed SELECT:\n{}Params:{}\n Retrying in {} milliseconds...",
                    async_error,
                    query,
                    substitution_items.join(", "),
                    interval.as_millis(),
                );
                tokio::time::sleep(interval).await;
                if interval < MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
}

'''
'''--- src/errors.rs ---
use paperclip::actix::{api_v2_errors, Apiv2Schema};

use near_jsonrpc_client::errors::JsonRpcError;
use near_jsonrpc_primitives::types::query::RpcQueryError;

#[derive(Debug, strum::EnumIter)]
pub enum ErrorKind {
    DBError(String),
    InvalidInput(String),
    InternalError(String),
    ContractError(String),
    RPCError(String),
}

/// Instead of utilizing HTTP status codes to describe node errors (which often
/// do not have a good analog), rich errors are returned using this object.
#[api_v2_errors(
    code = 500,
    description = "See the inner `code` value to get more details"
)]
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Error {
    /// Code is a network-specific error code. If desired, this code can be
    /// equivalent to an HTTP status code.
    pub code: u32,

    /// Message is a network-specific error message.
    pub message: String,

    /// An error is retriable if the same request may succeed if submitted
    /// again.
    pub retriable: bool,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let retriable = if self.retriable { " (retriable)" } else { "" };
        write!(f, "Error #{}{}: {}", self.code, retriable, self.message)
    }
}

impl Error {
    pub fn from_error_kind(err: ErrorKind) -> Self {
        match err {
            ErrorKind::DBError(message) => Self {
                code: 500,
                message: format!("DB Error: {}", message),
                retriable: true,
            },
            ErrorKind::InvalidInput(message) => Self {
                code: 400,
                message: format!("Invalid Input: {}", message),
                retriable: false,
            },
            ErrorKind::InternalError(message) => Self {
                code: 500,
                message: format!("Internal Error: {}", message),
                retriable: true,
            },
            ErrorKind::ContractError(message) => Self {
                code: 500,
                message: format!("Contract Error: {}", message),
                retriable: true,
            },
            ErrorKind::RPCError(message) => Self {
                code: 500,
                message: format!("RPC error: {}", message),
                retriable: true,
            },
        }
    }
}

impl<T> From<T> for Error
where
    T: Into<ErrorKind>,
{
    fn from(err: T) -> Self {
        Self::from_error_kind(err.into())
    }
}

impl actix_web::ResponseError for Error {
    fn error_response(&self) -> actix_web::HttpResponse {
        let data = paperclip::actix::web::Json(self);
        actix_web::HttpResponse::InternalServerError().json(data)
    }
}

impl From<JsonRpcError<RpcQueryError>> for ErrorKind {
    fn from(error: JsonRpcError<RpcQueryError>) -> Self {
        Self::RPCError(format!("{:#?}", error))
    }
}

impl From<serde_json::Error> for ErrorKind {
    fn from(error: serde_json::Error) -> Self {
        Self::InternalError(format!("Serialization failure: {:#?}", error))
    }
}

impl From<near_primitives::account::id::ParseAccountError> for ErrorKind {
    fn from(error: near_primitives::account::id::ParseAccountError) -> Self {
        Self::InternalError(format!("Could not parse account: {:#?}", error))
    }
}

pub(crate) fn validate_account_id(account_id: &str) -> Result<(), validator::ValidationError> {
    match near_primitives::types::AccountId::validate(account_id) {
        Ok(_) => Ok(()),
        Err(_) => Err(validator::ValidationError::new("")),
    }
}

'''
'''--- src/main.rs ---
use actix_cors::Cors;
use actix_web::{App, HttpServer, ResponseError};
use actix_web_prom::PrometheusMetricsBuilder;
use actix_web_validator::PathConfig;
use paperclip::actix::{web, OpenApiExt};
pub(crate) use sqlx::types::BigDecimal;

mod config;
mod db_helpers;
mod errors;
mod modules;
mod rpc_helpers;
mod types;

pub(crate) const LOGGER_MSG: &str = "near_enhanced_api";

pub(crate) const MIN_EVENT_INDEX: u128 = (10_u128).pow(34);

pub(crate) type Result<T> = std::result::Result<T, errors::Error>;

fn get_cors(cors_allowed_origins: &[String]) -> Cors {
    let mut cors = Cors::permissive();
    if cors_allowed_origins != ["*".to_string()] {
        for origin in cors_allowed_origins {
            cors = cors.allowed_origin(origin);
        }
    }
    cors.allowed_methods(vec!["GET"])
        .allowed_headers(vec![
            actix_web::http::header::AUTHORIZATION,
            actix_web::http::header::ACCEPT,
            actix_web::http::header::CONTENT_TYPE,
        ])
        .allowed_header("x-api-key")
        .max_age(3600)
}

fn get_api_base_path() -> String {
    std::env::var("API_BASE_PATH").unwrap_or_else(|_| "".to_string())
}

fn get_api_spec_base_path() -> String {
    std::env::var("API_SPEC_BASE_PATH").unwrap_or_else(|_| "".to_string())
}

async fn playground_ui() -> impl actix_web::Responder {
    let spec_base_path = get_api_spec_base_path();
    actix_web::HttpResponse::Ok()
        .insert_header(actix_web::http::header::ContentType::html())
        .body(
            format!(r#"<!doctype html>
                <html lang="en">
                  <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
                    <title>NEAR Enhanced API powered by Pagoda - Playground</title>
                    <!-- Embed elements Elements via Web Component -->
                    <script src="https://unpkg.com/@stoplight/elements/web-components.min.js"></script>
                    <link rel="stylesheet" href="https://unpkg.com/@stoplight/elements/styles.min.css">
                  </head>
                  <body>

                    <elements-api
                      apiDescriptionUrl="{spec_base_path}/v3.json"
                      router="hash"
                      layout="sidebar"
                    />

                  </body>
                </html>"#),
        )
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    dotenv::dotenv().ok();

    let env_filter = tracing_subscriber::EnvFilter::new(
        std::env::var("RUST_LOG")
            .as_deref()
            .unwrap_or("info,near=info,near_jsonrpc_client=warn,near_enhanced_api=debug"),
    );

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
    tracing::debug!(
        target: crate::LOGGER_MSG,
        "NEAR Enhanced API Server is initializing..."
    );

    let prometheus = PrometheusMetricsBuilder::new("api")
        .endpoint("/metrics")
        .build()
        .unwrap();

    // See https://docs.rs/sqlx/latest/sqlx/struct.Pool.html#2-connection-limits-mysql-mssql-postgres
    // for setting connection limits.
    let db_max_connections: u32 = std::env::var("DATABASE_MAX_CONNECTIONS")
        .unwrap_or_else(|_| "97".to_string())
        .parse()
        .expect("Failed to parse DATABASE_MAX_CONNECTIONS value as u32");

    let explorer_db_url = &std::env::var("EXPLORER_DATABASE_URL")
        .expect("failed to get database url from EXPLORER_DATABASE_URL env variable");
    let pool_explorer = sqlx::postgres::PgPoolOptions::new()
        .max_connections(db_max_connections)
        .connect(explorer_db_url)
        .await
        .expect("failed to connect to the database");

    let balances_db_url = &std::env::var("BALANCES_DATABASE_URL")
        .expect("failed to get database url from BALANCES_DATABASE_URL env variable");
    let pool_balances = sqlx::postgres::PgPoolOptions::new()
        .max_connections(db_max_connections)
        .connect(balances_db_url)
        .await
        .expect("failed to connect to the balances database");

    let rpc_url =
        &std::env::var("RPC_URL").expect("failed to get RPC url from RPC_URL env variable");
    let rpc_client = near_jsonrpc_client::JsonRpcClient::connect(rpc_url);

    let config::Config {
        addr,
        cors_allowed_origins,
        limits,
    } = config::Config::default();

    let server = HttpServer::new(move || {
        let json_config = web::JsonConfig::default()
            .limit(limits.input_payload_max_size)
            .error_handler(|err, _req| {
                let error_message = err.to_string();
                actix_web::error::InternalError::from_response(
                    err,
                    errors::Error::from_error_kind(errors::ErrorKind::InvalidInput(error_message))
                        .error_response(),
                )
                .into()
            });

        let path_config = PathConfig::default().error_handler(|err, _| {
            let error_message = err.to_string();
            actix_web::error::InternalError::from_response(
                err,
                errors::Error::from_error_kind(errors::ErrorKind::InvalidInput(error_message))
                    .error_response(),
            )
            .into()
        });

        let mut spec = paperclip::v2::models::DefaultApiRaw::default();
        if let Ok(api_server_public_host) = std::env::var("API_SERVER_PUBLIC_HOST") {
            spec.schemes
                .insert(paperclip::v2::models::OperationProtocol::Https);
            spec.host = Some(api_server_public_host);
        }
        let base_path = get_api_base_path();
        let spec_base_path = get_api_spec_base_path();
        spec.base_path = Some(base_path.clone());
        spec.info = paperclip::v2::models::Info {
            version: "0.1".into(),
            title: "NEAR Enhanced API powered by Pagoda".into(),
            description: Some(format!(r#"Try out our newly released Enhanced APIs - Balances (in Beta) and get what you need for all kinds of balances and token information at ease.
Call Enhanced APIs using the endpoint in the API URL box, varies by Network.

https://near-testnet.api.pagoda.co{base_path}

https://near-mainnet.api.pagoda.co{base_path}

Grab your API keys and give it a try! We will be adding more advanced Enhanced APIs in our offering, so stay tuned. Get the data you need without extra processing, NEAR Blockchain data query has never been easier!

We would love to hear from you on the data APIs you need, please leave feedback using the widget in the lower-right corner."#)),
            ..Default::default()
        };

        let mut app = App::new()
            .app_data(json_config)
            .app_data(path_config)
            .wrap(actix_web::middleware::Logger::default())
            .wrap(prometheus.clone())
            .app_data(web::Data::new(db_helpers::ExplorerPool(pool_explorer.clone())))
            .app_data(web::Data::new(db_helpers::BalancesPool(pool_balances.clone())))
            .app_data(web::Data::new(rpc_client.clone()))
            .wrap(get_cors(&cors_allowed_origins))
            .route("/", actix_web::web::get().to(playground_ui))
            .wrap_api_with_spec(spec);

        app = app.configure(modules::native::register_services);
        app = app.configure(modules::ft::register_services);
        app = app.configure(modules::nft::register_services);

        app.with_json_spec_at(format!("{spec_base_path}/v2.json").as_str())
            .with_json_spec_v3_at(format!("{spec_base_path}/v3.json").as_str())
            .build()
    })
    .bind(addr)
    .unwrap()
    .shutdown_timeout(5)
    .run();

    tracing::debug!(
        target: crate::LOGGER_MSG,
        "NEAR Enhanced API Server is starting..."
    );

    server.await
}

'''
'''--- src/modules/ft/data_provider/balance.rs ---
use crate::modules::ft;
use crate::{db_helpers, rpc_helpers, types};
use std::str::FromStr;

pub(crate) async fn get_ft_balances(
    db_helpers::BalancesPool(pool_balances): &db_helpers::BalancesPool,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    account_id: &near_primitives::types::AccountId,
    block: &db_helpers::Block,
    // TODO pagination
    limit: u32,
) -> crate::Result<Vec<ft::schemas::FtBalance>> {
    // todo it's better to query by chunks, this list can bee potentially too big (500+ contracts)
    let query = r"
        SELECT DISTINCT contract_account_id account_id
        FROM fungible_token_events
        WHERE affected_account_id = $1
        ORDER BY contract_account_id
    ";
    let contracts = db_helpers::select_retry_or_panic::<db_helpers::AccountId>(
        pool_balances,
        query,
        &[account_id.to_string()],
    )
    .await?;
    // todo drop this when querying by chunks is implemented for the query above
    tracing::info!(
        target: crate::LOGGER_MSG,
        "get_ft_balances: account {} has {} potential FT balances",
        account_id,
        contracts.len(),
    );

    let mut balances: Vec<ft::schemas::FtBalance> = vec![];
    for contract in contracts {
        if let Ok(contract_id) = near_primitives::types::AccountId::from_str(&contract.account_id) {
            if let Ok(balance) =
                get_ft_balance_by_contract(rpc_client, block, &contract_id, account_id).await
            {
                if balance.amount.0 > 0 {
                    balances.push(balance);
                }
            }
            if balances.len() == limit as usize {
                break;
            }
        }
    }
    Ok(balances)
}

pub(crate) async fn get_ft_balance_by_contract(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    block: &db_helpers::Block,
    contract_id: &near_primitives::types::AccountId,
    account_id: &near_primitives::types::AccountId,
) -> crate::Result<ft::schemas::FtBalance> {
    let (amount, metadata) = (
        get_ft_amount(
            rpc_client,
            contract_id.clone(),
            account_id.clone(),
            block.height,
        )
        .await?,
        super::metadata::get_ft_metadata(rpc_client, contract_id.clone(), block.height).await?,
    );

    Ok(ft::schemas::FtBalance {
        amount: amount.into(),
        contract_account_id: contract_id.clone().into(),
        metadata: ft::schemas::Metadata {
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            decimals: metadata.decimals,
        },
    })
}

pub(crate) async fn get_ft_amount(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    account_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<u128> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "ft_balance_of",
        serde_json::json!({ "account_id": account_id }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;
    Ok(serde_json::from_slice::<types::U128>(&response.result)?.0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_ft_balances() {
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("olga.near").unwrap();
        let balance = get_ft_balances(&pool_balances, &rpc_client, &account, &block, 10).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_balances_empty() {
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("cucumber.near").unwrap();
        let balance = get_ft_balances(&pool_balances, &rpc_client, &account, &block, 10)
            .await
            .unwrap();
        assert!(balance.is_empty());
    }

    #[tokio::test]
    async fn test_ft_balances_skip_zeros() {
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();
        let balance = get_ft_balances(&pool_balances, &rpc_client, &account, &block, 10).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_balance_by_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("token.sweat").unwrap();
        let account = near_primitives::types::AccountId::from_str(
            "10241dd91e8d8b6ff7f48ba06eb09c43ee5d5e8f5e7864a477a76161835775c1",
        )
        .unwrap();

        let balance = get_ft_balance_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_balance_by_contract_zero() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("nexp.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_ft_balance_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_balance_by_contract_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_ft_balance_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_balances_by_contract_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("patagonita.near").unwrap();

        let balance = get_ft_balance_by_contract(&rpc_client, &block, &contract, &account).await;
        insta::assert_debug_snapshot!(balance);
    }
}

'''
'''--- src/modules/ft/data_provider/history.rs ---
use crate::modules::ft;
use crate::{db_helpers, errors, types};
use num_traits::{Signed, ToPrimitive};
use sqlx::types::BigDecimal;
use std::str::FromStr;

pub(crate) async fn get_ft_history(
    db_helpers::ExplorerPool(pool_explorer): &db_helpers::ExplorerPool,
    db_helpers::BalancesPool(pool_balances): &db_helpers::BalancesPool,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: &near_primitives::types::AccountId,
    account_id: &near_primitives::types::AccountId,
    block: &db_helpers::Block,
    pagination: &types::query_params::Pagination,
) -> crate::Result<Vec<ft::schemas::HistoryItem>> {
    let metadata = ft::schemas::Metadata::from(
        super::metadata::get_ft_metadata(rpc_client, contract_id.clone(), block.height).await?,
    );

    let after_event_index = if let Some(index) = pagination.after_event_index {
        index
    } else {
        // +1 because we need to include given timestamp to result. Query has strict less operator
        db_helpers::timestamp_to_event_index(block.timestamp + 1)
    };

    // We don't have absolute_value in the DB.
    // We ask RPC for the first absolute_value, fill the in-between values with deltas, check by asking RPC for the last absolute_value and comparing the results.
    // If it matches, everything is good. If not, we return the error.

    // Problem: we can ask RPC only for the balance at the end of the block, while we may have the lines starting and ending in the middle of the block.
    // That's why we need to take slightly more lines so that we can match it with the RPC, and then filter these lines.
    // Potential issue here: the DB may contain only the part of the most fresh block (we may be in the middle of the writing process)
    // It can be easily solved by ignoring the most fresh block, but it will increase the lag between the response and the current blockchain state.
    // Since we anyway use transactional DB which guarantees that write process goes atomically, I don't want to do anything with that.
    // But, if we meet such issues in production, we may consider cutting the latest block.
    let query = r"
         WITH original_query as (
             SELECT
                 event_index,
                 involved_account_id,
                 delta_amount,
                 cause,
                 status,
                 block_timestamp,
                 block_height
             FROM fungible_token_events
             WHERE contract_account_id = $1
                 AND affected_account_id = $2
                 AND event_index < $3::numeric(38, 0)
             ORDER BY event_index desc
             LIMIT $4::numeric(20, 0)
         ), timestamps as (
             SELECT
                 min(block_timestamp) min_block_timestamp,
                 max(block_timestamp) max_block_timestamp
             FROM original_query
         )
         SELECT
             event_index,
             involved_account_id,
             delta_amount delta_balance,
             cause,
             status,
             block_timestamp block_timestamp_nanos,
             block_height
         FROM fungible_token_events, timestamps
         WHERE contract_account_id = $1
             AND affected_account_id = $2
             -- Last possible event_index from previous block for the range we request
             AND event_index > min_block_timestamp * pow(10, 16)::numeric(38, 0) - 1
             -- First possible event_index from next block for the range we request
             AND event_index < (max_block_timestamp + 1) * pow(10, 16)::numeric(38, 0)
         ORDER BY event_index desc
     ";

    let history = db_helpers::select_retry_or_panic::<ft::data_provider::models::FtHistoryInfo>(
        pool_balances,
        query,
        &[
            contract_id.to_string(),
            account_id.to_string(),
            after_event_index.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut current_balance = if let Some(first_item) = history.first() {
        let amount = super::balance::get_ft_amount(
            rpc_client,
            contract_id.clone(),
            account_id.clone(),
            first_item.block_height.to_u64().ok_or_else(|| {
                errors::ErrorKind::InternalError(
                    "Found negative block_height in fungible_token_events table".to_string(),
                )
            })?,
        )
        .await?;
        BigDecimal::from_str(&amount.to_string()).map_err(|e| {
            errors::ErrorKind::InternalError(format!("Failed to parse BigDecimal from u128: {}", e))
        })?
    } else {
        return Ok(vec![]);
    };

    let mut result: Vec<ft::schemas::HistoryItem> = vec![];
    for db_info in history {
        let balance = current_balance.clone();

        if db_info.status == "SUCCESS" {
            current_balance -= db_info.delta_balance.clone();
            if current_balance.is_negative() {
                tracing::warn!(
                    target: crate::LOGGER_MSG,
                    "get_ft_history: found inconsistent events for contract {}, account {}, block {:#?}, pagination {:#?}",
                    contract_id,
                    account_id,
                    block,
                    pagination,
                );
                return Err(errors::ErrorKind::InternalError(format!(
                    "History is not supported for account {}. Contract {} provides inconsistent events which lead to negative balance",
                    account_id, contract_id
                ))
                    .into());
            }
        }

        let involved_account_id = match db_info.involved_account_id {
            Some(id) => Some(types::AccountId::from_str(&id)?),
            None => None,
        };
        let event_index = types::numeric::to_u128(&db_info.event_index)?;

        // We collect slightly more lines that we were asked for, because we can make RPC calls only at the end of the block
        // First clause filters latest redundant lines, second clause filters earliest redundant lines
        if pagination
            .after_event_index
            .map_or_else(|| true, |index| index > event_index)
            && result.len() < pagination.limit as usize
        {
            result.push(ft::schemas::HistoryItem {
                event_index: event_index.into(),
                cause: db_info.cause.clone(),
                involved_account_id,
                delta_balance: db_info.delta_balance.to_string(),
                balance: types::numeric::to_u128(&balance)?.into(),
                block_timestamp_nanos: types::numeric::to_u64(&db_info.block_timestamp_nanos)?
                    .into(),
                block_height: types::numeric::to_u64(&db_info.block_height)?.into(),
                status: db_info.status,
                metadata: metadata.clone(),
            });
        }
    }

    let prev_block = if let Some(item) = result.last() {
        db_helpers::get_previous_block(pool_explorer, item.block_timestamp_nanos.0).await?
    } else {
        return Ok(result);
    };
    let earliest_balance = match super::balance::get_ft_amount(
        rpc_client,
        contract_id.clone(),
        account_id.clone(),
        prev_block.height,
    )
    .await
    {
        Ok(x) => x,
        Err(e) => {
            if e.message.contains("does not exist at block_height") {
                0
            } else {
                return Err(e);
            }
        }
    };
    if types::numeric::to_u128(&current_balance)? != earliest_balance {
        tracing::warn!(
            target: crate::LOGGER_MSG,
            "get_ft_history: found inconsistent events for contract {}, account {}, block {:#?}, pagination {:#?}",
            contract_id,
            account_id,
            block,
            pagination,
        );
        return Err(errors::ErrorKind::InternalError(format!(
            "History is not supported for account {}. Contract {} provides inconsistent events",
            account_id, contract_id
        ))
        .into());
    }

    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_ft_history() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str(
            "aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near",
        )
        .unwrap();
        let account = near_primitives::types::AccountId::from_str("aurora").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: None,
        };

        let balance = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_history_next_page() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let contract = near_primitives::types::AccountId::from_str(
            "aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near",
        )
        .unwrap();
        let account = near_primitives::types::AccountId::from_str("aurora").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: Some(16708552830626965310000000004000001),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();

        let history = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_ft_history_next_page_in_the_middle_of_the_block() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let contract = near_primitives::types::AccountId::from_str(
            "aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near",
        )
        .unwrap();
        let account = near_primitives::types::AccountId::from_str("aurora").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: Some(16704039164216566310000000004000001),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();

        let history1 = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await
        .unwrap();

        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: Some(history1.last().unwrap().event_index.0),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();
        let history2 = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await
        .unwrap();

        assert!(
            history1.last().unwrap().event_index > history2.first().unwrap().event_index,
            "Next page should not include event from previous page"
        );
        assert_eq!(
            history1.last().unwrap().block_height,
            history2.first().unwrap().block_height,
            "Block split in the middle expected"
        );
    }

    #[tokio::test]
    async fn test_ft_history_with_failed_receipts() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str(
            "52a047ee205701895ee06a375492490ec9c597ce.factory.bridge.near",
        )
        .unwrap();
        let account = near_primitives::types::AccountId::from_str("v2.ref-finance.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: None,
        };

        let balance = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_history_account_never_existed() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("wrap.near").unwrap();
        let account =
            near_primitives::types::AccountId::from_str("two-idiots-and-a-half.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 10,
            after_event_index: None,
        };

        let history = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await
        .unwrap();
        assert!(history.is_empty());
    }

    #[tokio::test]
    async fn test_ft_history_account_deleted() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("wrap.near").unwrap();
        let account =
            near_primitives::types::AccountId::from_str("two-idiots-and-a-half.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 10,
            after_event_index: None,
        };

        let history = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await
        .unwrap();
        assert!(history.is_empty());
    }

    #[tokio::test]
    async fn test_ft_history_contract_does_not_exist() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let contract =
            near_primitives::types::AccountId::from_str("two-idiots-and-a-half.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("olga.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 10,
            after_event_index: None,
        };

        let balance = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await;
        insta::assert_debug_snapshot!(balance);
    }

    #[tokio::test]
    async fn test_ft_history_contract_is_inconsistent() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let rpc_client = init_rpc();

        let contract = near_primitives::types::AccountId::from_str("kongztoken.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("v2.ref-finance.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 10,
            after_event_index: Some(16612455459990000000000000000000000),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();

        let balance = get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &contract,
            &account,
            &block,
            &pagination,
        )
        .await;
        insta::assert_debug_snapshot!(balance);
    }
}

'''
'''--- src/modules/ft/data_provider/metadata.rs ---
use crate::modules::ft;
use crate::rpc_helpers;

// todo switch from rpc to db
pub(crate) async fn get_ft_metadata(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<ft::schemas::FtContractMetadata> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "ft_metadata",
        serde_json::json!({}),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    Ok(serde_json::from_slice::<ft::schemas::FtContractMetadata>(
        &response.result,
    )?)
}

impl From<ft::schemas::FtContractMetadata> for ft::schemas::Metadata {
    fn from(metadata: ft::schemas::FtContractMetadata) -> Self {
        ft::schemas::Metadata {
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            decimals: metadata.decimals,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_ft_contract_metadata() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("usn").unwrap();

        let metadata = get_ft_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_ft_contract_metadata_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();

        let metadata = get_ft_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_ft_contract_metadata_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();

        let metadata = get_ft_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_ft_bridged_contract_metadata() {
        //https://github.com/near/near-enhanced-api-server/issues/43
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str(
            "0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near",
        )
        .unwrap();

        let metadata = get_ft_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }
}

'''
'''--- src/modules/ft/data_provider/mod.rs ---
mod balance;
mod history;
mod metadata;
mod models;

pub(crate) use balance::{get_ft_balance_by_contract, get_ft_balances};
pub(crate) use history::get_ft_history;
pub(crate) use metadata::get_ft_metadata;

'''
'''--- src/modules/ft/data_provider/models.rs ---
use crate::BigDecimal;

#[derive(sqlx::FromRow)]
pub(crate) struct FtHistoryInfo {
    pub event_index: BigDecimal,
    pub involved_account_id: Option<String>,
    pub delta_balance: BigDecimal,
    pub cause: String,
    pub status: String,
    pub block_timestamp_nanos: BigDecimal,
    pub block_height: BigDecimal,
}

'''
'''--- src/modules/ft/mod.rs ---
use paperclip::actix::web;

mod data_provider;
mod resources;
mod schemas;

pub(crate) fn register_services(app: &mut web::ServiceConfig) {
    app.service(
        web::resource("/accounts/{account_id}/balances/FT")
            .route(web::get().to(resources::get_ft_balances)),
    )
    .service(
        web::resource("/accounts/{account_id}/balances/FT/{contract_account_id}")
            .route(web::get().to(resources::get_ft_balance_by_contract)),
    )
    .service(
        web::resource("/accounts/{account_id}/balances/FT/{contract_account_id}/history")
            .route(web::get().to(resources::get_ft_history)),
    )
    .service(
        web::resource("/nep141/metadata/{contract_account_id}")
            .route(web::get().to(resources::get_ft_metadata)),
    );
}

'''
'''--- src/modules/ft/resources.rs ---
use paperclip::actix::{
    api_v2_operation,
    web::{self, Json},
};

use super::{data_provider, schemas};
use crate::{db_helpers, errors, modules, types};

#[api_v2_operation(tags(FT))]
/// Get user's FT balances
///
/// This endpoint returns all non-zero FT balances of the given `account_id`,
/// at the given `block_timestamp_nanos`/`block_height`.
///
/// **Limitations**
/// This endpoint scans all the FT contracts.
/// We currently provide up to 100 results, which covers almost all the potential situations.
/// Anyway, full-featured pagination will be provided soon.
pub async fn get_ft_balances(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    pool_balances: web::Data<db_helpers::BalancesPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::BalanceRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
    // TODO pagination
    limit_params: web::Query<types::query_params::LimitParams>,
) -> crate::Result<Json<schemas::FtBalancesResponse>> {
    let limit = types::query_params::checked_get_limit(limit_params.limit)?;
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;
    modules::check_account_exists(&rpc_client, &request.account_id.0, block.height).await?;

    let balances = data_provider::get_ft_balances(
        &pool_balances,
        &rpc_client,
        &request.account_id.0,
        &block,
        limit,
    )
    .await?;

    Ok(Json(schemas::FtBalancesResponse {
        balances,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(FT))]
/// Get user's FT balance by contract
///
/// This endpoint returns FT balance of the given `account_id`,
/// for the given `contract_account_id` and `block_timestamp_nanos`/`block_height`.
pub async fn get_ft_balance_by_contract(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::BalanceByContractRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::FtBalanceByContractResponse>> {
    if request.contract_account_id.to_string() == "near" {
        return Err(errors::ErrorKind::InvalidInput(
            "For native balance, please use `/accounts/{account_id}/balances/NEAR`".to_string(),
        )
        .into());
    }
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;
    modules::check_account_exists(&rpc_client, &request.account_id.0, block.height).await?;

    let balance = data_provider::get_ft_balance_by_contract(
        &rpc_client,
        &block,
        &request.contract_account_id.0,
        &request.account_id.0,
    )
    .await?;

    Ok(Json(schemas::FtBalanceByContractResponse {
        balance,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(FT))]
/// Get user's FT history by contract
///
/// This endpoint returns the history of FT operations
/// for the given `account_id`, `contract_account_id`.
/// For the next page, use `event_index` of the last item in your previous response.
pub async fn get_ft_history(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    pool_balances: web::Data<db_helpers::BalancesPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::HistoryRequest>,
    pagination_params: web::Query<types::query_params::PaginationParams>,
) -> crate::Result<Json<schemas::FtHistoryResponse>> {
    if request.contract_account_id.to_string() == "near" {
        return Err(errors::ErrorKind::InvalidInput(
            "For native history, please use `/accounts/{account_id}/balances/NEAR/history`"
                .to_string(),
        )
        .into());
    }
    let pagination = modules::checked_get_pagination_params(&pagination_params).await?;
    let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination).await?;
    // we don't need to check whether account exists. If not, we can just return the empty history

    Ok(Json(schemas::FtHistoryResponse {
        history: data_provider::get_ft_history(
            &pool_explorer,
            &pool_balances,
            &rpc_client,
            &request.contract_account_id.0,
            &request.account_id.0,
            &block,
            &pagination,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(FT))]
/// Get FT metadata
///
/// This endpoint returns the metadata for the given `contract_account_id`, `block_timestamp_nanos`/`block_height`.
pub async fn get_ft_metadata(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::ContractMetadataRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::FtContractMetadataResponse>> {
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;

    Ok(Json(schemas::FtContractMetadataResponse {
        metadata: data_provider::get_ft_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

'''
'''--- src/modules/ft/schemas.rs ---
use paperclip::actix::Apiv2Schema;
use validator::Validate;

use crate::types;

// *** Requests ***

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct BalanceRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
}

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct BalanceByContractRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct HistoryRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct ContractMetadataRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

// *** Responses ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtBalanceByContractResponse {
    pub balance: FtBalance,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtBalancesResponse {
    pub balances: Vec<FtBalance>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtBalance {
    pub amount: types::U128,
    pub contract_account_id: types::AccountId,
    pub metadata: Metadata,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtHistoryResponse {
    pub history: Vec<HistoryItem>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtContractMetadataResponse {
    pub metadata: FtContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

// ---

/// This type describes the history of the operations (NEAR, FT) for the given user.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryItem {
    pub event_index: types::U128,
    pub involved_account_id: Option<types::AccountId>,
    pub delta_balance: String,
    pub balance: types::U128,
    pub cause: String,
    pub status: String,
    pub metadata: Metadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

/// This type describes general Metadata info, collecting the most important fields from different standards in the one format.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Metadata {
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub decimals: u8,
}

/// The type for FT Contract Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/FungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct FtContractMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
    pub decimals: u8,
}

'''
'''--- src/modules/mod.rs ---
use crate::{errors, types};

pub(crate) mod ft;
pub(crate) mod native;
pub(crate) mod nft;

pub(crate) async fn check_account_exists(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    account_id: &near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<()> {
    let request = near_jsonrpc_client::methods::query::RpcQueryRequest {
        block_reference: near_primitives::types::BlockId::Height(block_height).into(),
        request: near_primitives::views::QueryRequest::ViewAccount {
            account_id: account_id.clone(),
        },
    };
    for _ in 0..5 {
        match rpc_client.call(&request).await {
            Err(near_jsonrpc_client::errors::JsonRpcError::ServerError(
                near_jsonrpc_client::errors::JsonRpcServerError::HandlerError(
                    near_jsonrpc_client::methods::query::RpcQueryError::UnknownAccount { .. },
                ),
            )) => {
                return Err(errors::ErrorKind::InvalidInput(format!(
                    "account_id {} does not exist at block_height {}",
                    account_id, block_height
                ))
                .into())
            }
            Err(err) => {
                tracing::warn!(target: crate::LOGGER_MSG, "Checking account existence via JSON RPC failed with: {:?}. Re-trying immediatelly", err);
                continue;
            }
            Ok(response) => {
                if let near_jsonrpc_primitives::types::query::QueryResponseKind::ViewAccount(_) =
                    response.kind
                {
                    return Ok(());
                } else {
                    tracing::warn!(target: crate::LOGGER_MSG, "Checking account existence returned invalid response: {:?}. Re-trying immediatelly", response);
                    continue;
                }
            }
        }
    }
    Err(errors::ErrorKind::InternalError(format!(
        "could not check if account_id {} exists after several attemps",
        account_id
    ))
    .into())
}

/// Validates pagination_params received from the user
pub(crate) async fn checked_get_pagination_params(
    pagination_params: &types::query_params::PaginationParams,
) -> crate::Result<types::query_params::Pagination> {
    Ok(types::query_params::Pagination {
        limit: types::query_params::checked_get_limit(pagination_params.limit)?,
        after_event_index: match pagination_params.after_event_index {
            None => None,
            Some(index) => {
                if index.0 < crate::MIN_EVENT_INDEX {
                    return Err(errors::ErrorKind::InvalidInput(format!(
                        "after_event_index {} is too low. Please copy event_index value from the last item in your previous response",
                        index.0
                    ))
                        .into());
                }
                Some(index.0)
            }
        },
    })
}

#[cfg(test)]
mod tests {
    use crate::db_helpers;

    pub(crate) async fn init_explorer_db() -> db_helpers::ExplorerPool {
        dotenv::dotenv().ok();
        let db_url = &std::env::var("EXPLORER_DATABASE_URL").expect("failed to get database url");

        db_helpers::ExplorerPool(
            sqlx::PgPool::connect(db_url).await.expect(
                "failed to connect to the database from EXPLORER_DATABASE_URL env variable",
            ),
        )
    }

    pub(crate) async fn init_balances_db() -> db_helpers::BalancesPool {
        dotenv::dotenv().ok();
        let db_url_balances =
            &std::env::var("BALANCES_DATABASE_URL").expect("failed to get database url");
        db_helpers::BalancesPool(sqlx::PgPool::connect(db_url_balances).await.expect(
            "failed to connect to the balances database from BALANCES_DATABASE_URL env variable",
        ))
    }

    pub(crate) fn init_rpc() -> near_jsonrpc_client::JsonRpcClient {
        dotenv::dotenv().ok();
        let rpc_url = &std::env::var("RPC_URL").expect("failed to get RPC url");
        let connector = near_jsonrpc_client::JsonRpcClient::new_client();
        connector.connect(rpc_url)
    }

    pub(crate) fn get_block() -> db_helpers::Block {
        db_helpers::Block {
            timestamp: 1670867692546051383, // December 12, 2022
            height: 80500000,
        }
    }
}

'''
'''--- src/modules/native/data_provider/balance.rs ---
use crate::modules::native;
use crate::{db_helpers, errors, types};

pub(crate) async fn get_near_balance(
    db_helpers::BalancesPool(pool_balances): &db_helpers::BalancesPool,
    block: &db_helpers::Block,
    account_id: &near_primitives::types::AccountId,
) -> crate::Result<native::schemas::NearBalanceResponse> {
    // +1 because we need to include given timestamp to result. Query has strict less operator
    let after_event_index = db_helpers::timestamp_to_event_index(block.timestamp + 1);
    let balances = db_helpers::select_retry_or_panic::<super::models::Balance>(
        pool_balances,
        r"
            WITH t AS (
                SELECT absolute_nonstaked_amount + absolute_staked_amount balance
                FROM near_balance_events
                WHERE affected_account_id = $1
                    AND event_index < $2::numeric(38, 0)
                ORDER BY event_index DESC
            )
            SELECT * FROM t LIMIT 1
        ",
        &[account_id.to_string(), after_event_index.to_string()],
    )
    .await?;

    match balances.first() {
        Some(balance) => Ok(native::schemas::NearBalanceResponse {
            balance: native::schemas::NearBalance {
                amount: types::numeric::to_u128(&balance.balance)?.into(),
                metadata: super::metadata::get_near_metadata(),
            },
            block_timestamp_nanos: block.timestamp.into(),
            block_height: block.height.into(),
        }),
        None => Err(errors::ErrorKind::DBError(format!(
            "Could not find the data in near_balance_events table for account_id {}",
            account_id
        ))
        .into()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_near_balance() {
        let pool_balances = init_balances_db().await;
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("tomato.near").unwrap();
        let balance = get_near_balance(&pool_balances, &block, &account).await;
        insta::assert_debug_snapshot!(balance);
    }
}

'''
'''--- src/modules/native/data_provider/history.rs ---
use std::str::FromStr;

use crate::modules::native;
use crate::{db_helpers, errors, types};

pub(crate) async fn get_near_history(
    db_helpers::BalancesPool(pool_balances): &db_helpers::BalancesPool,
    account_id: &near_primitives::types::AccountId,
    block: &db_helpers::Block,
    pagination: &types::query_params::Pagination,
) -> crate::Result<Vec<native::schemas::HistoryItem>> {
    let after_event_index = if let Some(index) = pagination.after_event_index {
        index
    } else {
        // +1 because we need to include given timestamp to result. Query has strict less operator
        db_helpers::timestamp_to_event_index(block.timestamp + 1)
    };

    let query = r"
        SELECT
            event_index,
            involved_account_id,
            delta_nonstaked_amount + delta_staked_amount delta_balance,
            absolute_nonstaked_amount + absolute_staked_amount balance,
            cause,
            status,
            block_timestamp block_timestamp_nanos,
            block_height
        FROM near_balance_events
        WHERE affected_account_id = $1 AND event_index < $2::numeric(38, 0)
        ORDER BY event_index DESC
        LIMIT $3::numeric(20, 0)
    ";

    let history_info = db_helpers::select_retry_or_panic::<super::models::NearHistoryInfo>(
        pool_balances,
        query,
        &[
            account_id.to_string(),
            after_event_index.to_string(),
            pagination.limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<native::schemas::HistoryItem> = vec![];
    for history in history_info {
        result.push(history.try_into()?);
    }
    Ok(result)
}

impl TryFrom<super::models::NearHistoryInfo> for native::schemas::HistoryItem {
    type Error = errors::Error;

    fn try_from(history: super::models::NearHistoryInfo) -> crate::Result<Self> {
        let involved_account_id: Option<types::AccountId> =
            if let Some(account_id) = history.involved_account_id {
                Some(near_primitives::types::AccountId::from_str(&account_id)?.into())
            } else {
                None
            };
        Ok(Self {
            event_index: types::numeric::to_u128(&history.event_index)?.into(),
            involved_account_id,
            delta_balance: history.delta_balance.to_string(),
            balance: types::numeric::to_u128(&history.balance)?.into(),
            cause: history.cause,
            status: history.status,
            metadata: super::get_near_metadata(),
            block_timestamp_nanos: types::numeric::to_u64(&history.block_timestamp_nanos)?.into(),
            block_height: types::numeric::to_u64(&history.block_height)?.into(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;

    #[tokio::test]
    async fn test_near_history() {
        let pool_balances = init_balances_db().await;
        let account = near_primitives::types::AccountId::from_str("cvirkun.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: None,
        };
        let block = get_block();

        let history = get_near_history(&pool_balances, &account, &block, &pagination).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_near_history_next_page() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let account = near_primitives::types::AccountId::from_str("cvirkun.near").unwrap();
        let index = 16708676458550339330000000000000003;
        let pagination = types::query_params::Pagination {
            limit: 3,
            after_event_index: Some(index),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();

        let history = get_near_history(&pool_balances, &account, &block, &pagination).await;
        insta::assert_debug_snapshot!(history);
        assert!(
            history.unwrap().first().unwrap().event_index.0 < index,
            "Next page should not include event from previous page"
        );
    }

    #[tokio::test]
    async fn test_near_history_with_failed_receipts() {
        let pool_explorer = init_explorer_db().await;
        let pool_balances = init_balances_db().await;
        let account = near_primitives::types::AccountId::from_str("aurora").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: Some(16708676800272181160000000010000005),
        };
        let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination)
            .await
            .unwrap();

        let history = get_near_history(&pool_balances, &account, &block, &pagination).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_near_history_account_never_existed() {
        let pool_balances = init_balances_db().await;
        let account =
            near_primitives::types::AccountId::from_str("two-idiots-and-a-half.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 10,
            after_event_index: None,
        };
        let block = get_block();

        let history = get_near_history(&pool_balances, &account, &block, &pagination)
            .await
            .unwrap();
        assert!(history.is_empty());
    }

    #[tokio::test]
    async fn test_near_history_account_deleted() {
        let pool_balances = init_balances_db().await;
        let account = near_primitives::types::AccountId::from_str("tezeract.near").unwrap();
        let pagination = types::query_params::Pagination {
            limit: 5,
            after_event_index: None,
        };
        let block = get_block();

        let history = get_near_history(&pool_balances, &account, &block, &pagination)
            .await
            .unwrap();
        // we still show the history
        insta::assert_debug_snapshot!(history);
    }
}

'''
'''--- src/modules/native/data_provider/metadata.rs ---
use crate::modules::native;

pub(crate) fn get_near_metadata() -> native::schemas::Metadata {
    native::schemas::Metadata {
        name: "NEAR blockchain native token".to_string(),
        symbol: "NEAR".to_string(),
        // TODO re-check the icon. It's the best I can find
        icon: Some("https://raw.githubusercontent.com/near/near-wallet/7ef3c824404282b76b36da2dff4f3e593e7f928d/packages/frontend/src/images/near.svg".to_string()),
        decimals: 24,
    }
}

'''
'''--- src/modules/native/data_provider/mod.rs ---
mod balance;
mod history;
mod metadata;
mod models;

pub(crate) use balance::get_near_balance;
pub(crate) use history::get_near_history;
pub(crate) use metadata::get_near_metadata;

'''
'''--- src/modules/native/data_provider/models.rs ---
use crate::BigDecimal;

#[derive(sqlx::FromRow)]
pub(crate) struct Balance {
    pub balance: BigDecimal,
}

#[derive(sqlx::FromRow)]
pub(crate) struct NearHistoryInfo {
    pub event_index: BigDecimal,
    pub involved_account_id: Option<String>,
    pub delta_balance: BigDecimal,
    pub balance: BigDecimal,
    pub cause: String,
    pub status: String,
    pub block_timestamp_nanos: BigDecimal,
    pub block_height: BigDecimal,
}

'''
'''--- src/modules/native/mod.rs ---
use paperclip::actix::web;

mod data_provider;
mod resources;
mod schemas;

pub(crate) fn register_services(app: &mut web::ServiceConfig) {
    app.service(
        web::resource("/accounts/{account_id}/balances/NEAR")
            .route(web::get().to(resources::get_near_balance)),
    )
    .service(
        web::resource("/accounts/{account_id}/balances/NEAR/history")
            .route(web::get().to(resources::get_near_history)),
    );
}

'''
'''--- src/modules/native/resources.rs ---
use paperclip::actix::{
    api_v2_operation,
    web::{self, Json},
};

use super::{data_provider, schemas};
use crate::{db_helpers, modules, types};

#[api_v2_operation(tags(NEAR))]
/// Get user's NEAR balance
///
/// This endpoint returns the NEAR balance of the given `account_id`
/// at the given `block_timestamp_nanos`/`block_height`.
pub async fn get_near_balance(
    pool_balances: web::Data<db_helpers::BalancesPool>,
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::BalanceRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::NearBalanceResponse>> {
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;
    modules::check_account_exists(&rpc_client, &request.account_id.0, block.height).await?;

    Ok(Json(
        data_provider::get_near_balance(&pool_balances, &block, &request.account_id.0).await?,
    ))
}

#[api_v2_operation(tags(NEAR))]
/// Get user's NEAR history
///
/// This endpoint returns the history of NEAR operations
/// for the given `account_id`, `block_timestamp_nanos`/`block_height`.
/// For the next page, use `event_index` of the last item in your previous response.
pub async fn get_near_history(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    pool_balances: web::Data<db_helpers::BalancesPool>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::BalanceRequest>,
    pagination_params: web::Query<types::query_params::PaginationParams>,
) -> crate::Result<Json<schemas::NearHistoryResponse>> {
    let pagination = modules::checked_get_pagination_params(&pagination_params).await?;
    let block = db_helpers::get_block_from_pagination(&pool_explorer, &pagination).await?;
    // we don't need to check whether account exists. If not, we can just return the empty history

    Ok(Json(schemas::NearHistoryResponse {
        history: data_provider::get_near_history(
            &pool_balances,
            &request.account_id,
            &block,
            &pagination,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

'''
'''--- src/modules/native/schemas.rs ---
use paperclip::actix::Apiv2Schema;
use validator::Validate;

use crate::types;

// *** Requests ***

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct BalanceRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
}

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct HistoryRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

// *** Responses ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NearBalanceResponse {
    pub balance: NearBalance,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NearBalance {
    /// Sum of staked and nonstaked balances
    pub amount: types::U128,
    pub metadata: Metadata,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NearHistoryResponse {
    pub history: Vec<HistoryItem>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

/// This type describes the history of the operations (NEAR, FT) for the given user.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryItem {
    pub event_index: types::U128,
    pub involved_account_id: Option<types::AccountId>,
    pub delta_balance: String,
    pub balance: types::U128,
    pub cause: String,
    pub status: String,
    pub metadata: Metadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

/// This type describes general Metadata info
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Metadata {
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub decimals: u8,
}

'''
'''--- src/modules/nft/data_provider/history.rs ---
use crate::modules::nft;
use crate::{db_helpers, errors, types};

// TODO PHASE 2 pagination by artificial index added to assets__non_fungible_token_events
pub(crate) async fn get_nft_history(
    db_helpers::ExplorerPool(pool_explorer): &db_helpers::ExplorerPool,
    contract_id: &near_primitives::types::AccountId,
    token_id: &str,
    block: &db_helpers::Block,
    limit: u32,
) -> crate::Result<Vec<nft::schemas::HistoryItem>> {
    let query = r"
        SELECT
            event_kind::text cause,
            CASE WHEN execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID') THEN 'SUCCESS'
                ELSE 'FAILURE'
            END status,
            token_old_owner_account_id old_account_id,
            token_new_owner_account_id new_account_id,
            emitted_at_block_timestamp block_timestamp_nanos,
            block_height
        FROM assets__non_fungible_token_events
            JOIN blocks ON assets__non_fungible_token_events.emitted_at_block_timestamp = blocks.block_timestamp
            JOIN execution_outcomes ON assets__non_fungible_token_events.emitted_for_receipt_id = execution_outcomes.receipt_id
        WHERE token_id = $1
            AND emitted_by_contract_account_id = $2
            AND emitted_at_block_timestamp < $3::numeric(20, 0)
        ORDER BY emitted_at_block_timestamp DESC
        LIMIT $4::numeric(20, 0)
    ";
    let history_items = db_helpers::select_retry_or_panic::<super::models::NftHistoryInfo>(
        pool_explorer,
        query,
        &[
            token_id.to_string(),
            contract_id.to_string(),
            block.timestamp.to_string(),
            limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<nft::schemas::HistoryItem> = vec![];
    for history in history_items {
        result.push(history.try_into()?);
    }
    Ok(result)
}

impl TryFrom<super::models::NftHistoryInfo> for nft::schemas::HistoryItem {
    type Error = errors::Error;

    fn try_from(info: super::models::NftHistoryInfo) -> crate::Result<Self> {
        Ok(Self {
            cause: info.cause,
            status: info.status,
            old_account_id: types::account_id::extract_account_id(&info.old_account_id)?
                .map(|account| account.into()),
            new_account_id: types::account_id::extract_account_id(&info.new_account_id)?
                .map(|account| account.into()),
            block_timestamp_nanos: types::numeric::to_u64(&info.block_timestamp_nanos)?.into(),
            block_height: types::numeric::to_u64(&info.block_height)?.into(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_nft_history() {
        let pool_explorer = init_explorer_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "293708:1";

        let history = get_nft_history(&pool_explorer, &contract, token, &block, 10).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_nft_history_with_failed_receipts() {
        let pool_explorer = init_explorer_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("thebullishbulls.near").unwrap();
        let token = "1349";

        let history = get_nft_history(&pool_explorer, &contract, token, &block, 10).await;
        insta::assert_debug_snapshot!(history);
    }

    #[tokio::test]
    async fn test_nft_history_nft_does_not_exist() {
        let pool_explorer = init_explorer_db().await;
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "no_such_token";

        let history = get_nft_history(&pool_explorer, &contract, token, &block, 10)
            .await
            .unwrap();
        assert!(history.is_empty());
    }
}

'''
'''--- src/modules/nft/data_provider/metadata.rs ---
use crate::modules::nft;
use crate::{errors, rpc_helpers};

pub(crate) async fn get_nft_contract_metadata(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    block_height: u64,
) -> crate::Result<nft::schemas::NftContractMetadata> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_metadata",
        serde_json::json!({}),
    );
    let response = match rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id)
        .await
    {
        Ok(response) => response,
        Err(err) => {
            println!("{}", err.message);
            if err
                .message
                .contains("called `Option::unwrap()` on a `None` value")
            {
                return Err(errors::ErrorKind::ContractError(
                    "The contract did not provide NFT Metadata which is a required part of NFT NEP 171".to_string(),
                )
                    .into());
            }
            return Err(err);
        }
    };

    Ok(serde_json::from_slice::<nft::schemas::NftContractMetadata>(
        &response.result,
    )?)
}

// Metadata is the required part of the standard.
// Unfortunately, some contracts (e.g. `nft.nearapps.near`) do not implement it.
// We should give at least anything for such contracts when we serve the overview information.
pub(crate) fn get_default_nft_contract_metadata() -> nft::schemas::NftContractMetadata {
    nft::schemas::NftContractMetadata {
        spec: "nft-1.0.0".to_string(),
        name: "The contract did not provide the metadata".to_string(),
        symbol: "The contract did not provide the symbol".to_string(),
        icon: None,
        base_uri: None,
        reference: None,
        reference_hash: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_nft_contract_metadata() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("comic.paras.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_no_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("olga.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_other_contract_deployed() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("usn").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }

    #[tokio::test]
    async fn test_nft_contract_metadata_broken_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("nft.nearapps.near").unwrap();

        let metadata = get_nft_contract_metadata(&rpc_client, contract, block.height).await;
        insta::assert_debug_snapshot!(metadata);
    }
}

'''
'''--- src/modules/nft/data_provider/mod.rs ---
mod history;
mod metadata;
mod models;
mod nft_info;

pub(crate) use history::get_nft_history;
pub(crate) use metadata::get_nft_contract_metadata;
pub(crate) use nft_info::{get_nft, get_nfts_by_contract, get_nfts_count};

'''
'''--- src/modules/nft/data_provider/models.rs ---
use crate::BigDecimal;

#[derive(sqlx::FromRow)]
pub(crate) struct NftHistoryInfo {
    // pub event_index: super::types::U128,
    pub cause: String,
    pub status: String,
    pub old_account_id: String,
    pub new_account_id: String,
    pub block_timestamp_nanos: BigDecimal,
    pub block_height: BigDecimal,
}

#[derive(sqlx::FromRow)]
pub(crate) struct NftCount {
    pub contract_id: String,
    pub count: i64,
    pub last_updated_at_timestamp: BigDecimal,
}

'''
'''--- src/modules/nft/data_provider/nft_info.rs ---
use std::str::FromStr;

use crate::modules::nft;
use crate::{db_helpers, errors, rpc_helpers, types};
use serde::{Deserialize, Serialize};

// TODO PHASE 2 pagination by artificial index added to assets__non_fungible_token_events
pub(crate) async fn get_nfts_count(
    db_helpers::ExplorerPool(pool_explorer): &db_helpers::ExplorerPool,
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    block: &db_helpers::Block,
    account_id: &near_primitives::types::AccountId,
    limit: u32,
) -> crate::Result<Vec<nft::schemas::NftCount>> {
    let query = r"
        WITH relevant_events AS (
            SELECT emitted_at_block_timestamp, token_id, emitted_by_contract_account_id, token_old_owner_account_id, token_new_owner_account_id
            FROM assets__non_fungible_token_events
                JOIN execution_outcomes ON assets__non_fungible_token_events.emitted_for_receipt_id = execution_outcomes.receipt_id
            WHERE
                -- if it works slow, we need to create table daily_nft_count_by_contract_and_user, and this query will run only over the last day
                -- emitted_at_block_timestamp > start_of_day AND
                emitted_at_block_timestamp <= $2::numeric(20, 0)
                AND execution_outcomes.status IN ('SUCCESS_VALUE', 'SUCCESS_RECEIPT_ID')
                AND (token_new_owner_account_id = $1 OR token_old_owner_account_id = $1)
        ),
        outgoing_events_count AS (
            SELECT emitted_by_contract_account_id, count(*) * -1 cnt FROM relevant_events
            WHERE token_old_owner_account_id = $1
            GROUP BY emitted_by_contract_account_id
        ),
        ingoing_events_count AS (
            SELECT emitted_by_contract_account_id, count(*) cnt FROM relevant_events
            WHERE token_new_owner_account_id = $1
            GROUP BY emitted_by_contract_account_id
        ),
        counts AS (
            SELECT ingoing_events_count.emitted_by_contract_account_id,
                -- coalesce changes null to the given parameter
                coalesce(ingoing_events_count.cnt, 0) + coalesce(outgoing_events_count.cnt, 0) cnt
            FROM ingoing_events_count FULL JOIN outgoing_events_count
                ON ingoing_events_count.emitted_by_contract_account_id = outgoing_events_count.emitted_by_contract_account_id
        ),
        counts_with_timestamp AS (
            SELECT distinct ON (counts.emitted_by_contract_account_id) counts.emitted_by_contract_account_id contract_id,
                cnt count,
                emitted_at_block_timestamp last_updated_at_timestamp
            FROM counts JOIN relevant_events ON counts.emitted_by_contract_account_id = relevant_events.emitted_by_contract_account_id
            WHERE cnt > 0
            ORDER BY counts.emitted_by_contract_account_id, emitted_at_block_timestamp DESC
        )
        SELECT * FROM counts_with_timestamp
        -- WHERE last_updated_at_timestamp < $3::numeric(20, 0) -- phase 2 pagination will be covered here
        ORDER BY last_updated_at_timestamp DESC
        LIMIT $3::numeric(20, 0)
    ";

    let info_by_contract = db_helpers::select_retry_or_panic::<super::models::NftCount>(
        pool_explorer,
        query,
        &[
            account_id.to_string(),
            block.timestamp.to_string(),
            limit.to_string(),
        ],
    )
    .await?;

    let mut result: Vec<nft::schemas::NftCount> = vec![];
    for info in info_by_contract {
        if let Ok(contract_id) = near_primitives::types::AccountId::from_str(&info.contract_id) {
            let metadata = super::metadata::get_nft_contract_metadata(
                rpc_client,
                contract_id.clone(),
                block.height,
            )
            .await
            .unwrap_or_else(|_| super::metadata::get_default_nft_contract_metadata());
            result.push(nft::schemas::NftCount {
                contract_account_id: contract_id.into(),
                nft_count: info.count as u32,
                last_updated_at_timestamp_nanos: types::numeric::to_u128(
                    &info.last_updated_at_timestamp,
                )?
                .into(),
                contract_metadata: metadata,
            });
        }
    }
    Ok(result)
}

pub(crate) async fn get_nfts_by_contract(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    account_id: near_primitives::types::AccountId,
    block_height: u64,
    limit: u32,
) -> crate::Result<Vec<nft::schemas::Nft>> {
    // TODO PHASE 2 pagination
    // RPC supports pagination, but the order is defined by the each contract and we can't control it.
    // For now, we are ready to serve only the first page
    // Later, I feel we need to load NFT (each token) metadata to the DB,
    // right after that we can stop using RPC here.
    // Or, maybe we want to delegate this task fully to the contracts?
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_tokens_for_owner",
        // https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration
        serde_json::json!({ "account_id": account_id, "from_index": "0", "limit": limit }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    let tokens = serde_json::from_slice::<Vec<Token>>(&response.result)?;
    let mut result = vec![];
    for token in tokens {
        result.push(nft::schemas::Nft::try_from(token)?);
    }
    Ok(result)
}

pub(crate) async fn get_nft(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    contract_id: near_primitives::types::AccountId,
    token_id: String,
    block_height: u64,
) -> crate::Result<nft::schemas::Nft> {
    let request = rpc_helpers::get_function_call_request(
        block_height,
        contract_id.clone(),
        "nft_token",
        serde_json::json!({ "token_id": token_id }),
    );
    let response =
        rpc_helpers::wrapped_call(rpc_client, request, block_height, &contract_id).await?;

    match serde_json::from_slice::<Option<Token>>(&response.result)? {
        None => Err(errors::ErrorKind::InvalidInput(format!(
            "Token `{}` does not exist in contract `{}`, block_height {}",
            token_id, contract_id, block_height
        ))
        .into()),
        Some(token) => nft::schemas::Nft::try_from(token),
    }
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/token.rs
/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: types::AccountId,
    pub metadata: Option<nft::schemas::NftMetadata>,
    pub approved_account_ids: Option<std::collections::HashMap<types::AccountId, u64>>,
}

impl TryFrom<Token> for nft::schemas::Nft {
    type Error = errors::Error;

    fn try_from(token: Token) -> crate::Result<Self> {
        let metadata = token.metadata.ok_or_else(|| {
            errors::ErrorKind::ContractError(
                "The contract did not provide NFT Metadata which is a required part of NFT NEP 171"
                    .to_string(),
            )
        })?;

        Ok(Self {
            token_id: token.token_id,
            owner_account_id: token.owner_id.0.to_string(),
            metadata,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::tests::*;

    #[tokio::test]
    async fn test_nfts_count() {
        let pool_explorer = init_explorer_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("blondjesus.near").unwrap();

        let nft_count = get_nfts_count(&pool_explorer, &rpc_client, &block, &account, 10).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_count_empty() {
        let pool_explorer = init_explorer_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("cucumber.near").unwrap();

        let nft_count = get_nfts_count(&pool_explorer, &rpc_client, &block, &account, 10)
            .await
            .unwrap();
        assert!(nft_count.is_empty());
    }

    #[tokio::test]
    async fn test_nfts_count_with_contracts_with_no_metadata() {
        let pool_explorer = init_explorer_db().await;
        let rpc_client = init_rpc();
        let block = db_helpers::Block {
            timestamp: 1655571176644255779,
            height: 68000000,
        };
        let account = near_primitives::types::AccountId::from_str("vlad.near").unwrap();

        let nft_count = get_nfts_count(&pool_explorer, &rpc_client, &block, &account, 10).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_count_with_no_failed_receipts_in_result() {
        let pool_explorer = init_explorer_db().await;
        let rpc_client = init_rpc();
        let block = get_block();
        let account = near_primitives::types::AccountId::from_str("kbneoburner3.near").unwrap();

        let nft_count = get_nfts_count(&pool_explorer, &rpc_client, &block, &account, 10).await;
        insta::assert_debug_snapshot!(nft_count);
    }

    #[tokio::test]
    async fn test_nfts_by_contract() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract =
            near_primitives::types::AccountId::from_str("billionairebullsclub.near").unwrap();
        let account = near_primitives::types::AccountId::from_str("olenavorobei.near").unwrap();

        let nfts = get_nfts_by_contract(&rpc_client, contract, account, block.height, 4).await;
        insta::assert_debug_snapshot!(nfts);
    }

    #[tokio::test]
    async fn test_nft() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "415815:1".to_string();

        let nft = get_nft(&rpc_client, contract, token, block.height).await;
        insta::assert_debug_snapshot!(nft);
    }

    #[tokio::test]
    async fn test_nft_does_not_exist() {
        let rpc_client = init_rpc();
        let block = get_block();
        let contract = near_primitives::types::AccountId::from_str("x.paras.near").unwrap();
        let token = "no_such_token".to_string();

        let nft = get_nft(&rpc_client, contract, token, block.height).await;
        insta::assert_debug_snapshot!(nft);
    }
}

'''
'''--- src/modules/nft/mod.rs ---
use paperclip::actix::web;

mod data_provider;
mod resources;
mod schemas;

pub(crate) fn register_services(app: &mut web::ServiceConfig) {
    app.service(
        web::resource("/accounts/{account_id}/NFT")
            .route(web::get().to(resources::get_nft_collection_overview)),
    )
    .service(
        web::resource("/accounts/{account_id}/NFT/{contract_account_id}")
            .route(web::get().to(resources::get_nft_collection_by_contract)),
    )
    .service(
        web::resource("/NFT/{contract_account_id}/{token_id}")
            .route(web::get().to(resources::get_nft)),
    )
    .service(
        web::resource("/NFT/{contract_account_id}/{token_id}/history")
            .route(web::get().to(resources::get_nft_history)),
    )
    .service(
        web::resource("/nep171/metadata/{contract_account_id}")
            .route(web::get().to(resources::get_nft_contract_metadata)),
    );
}

'''
'''--- src/modules/nft/resources.rs ---
use paperclip::actix::{
    api_v2_operation,
    web::{self, Json},
};

use crate::{db_helpers, modules, types};

use super::schemas;

#[api_v2_operation(tags(NFT))]
/// Get user's NFT collection overview
///
/// For the given `account_id`, this endpoint returns
/// the number of NFTs grouped by `contract_account_id`, together with the corresponding NFT contract metadata.
/// The NFT contract will be present in the response if the `account_id` has at least one NFT there.
///
/// **Limitations**
/// * We currently provide the most recent 100 items.
///   Full-featured pagination will be provided soon.
pub async fn get_nft_collection_overview(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::NftCountsRequest>,
    limit_params: web::Query<types::query_params::LimitParams>,
) -> crate::Result<Json<schemas::NftCountsResponse>> {
    let limit = types::query_params::checked_get_limit(limit_params.limit)?;
    let block = db_helpers::get_last_block(&pool_explorer).await?;
    modules::check_account_exists(&rpc_client, &request.account_id.0, block.height).await?;

    Ok(Json(schemas::NftCountsResponse {
        // TODO We can save metadata in the DB and update once in 10 minutes
        nft_counts: super::data_provider::get_nfts_count(
            &pool_explorer,
            &rpc_client,
            &block,
            &request.account_id.0,
            limit,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(NFT))]
/// Get user's NFT collection by contract
///
/// This endpoint returns the list of NFTs with full details for the given `account_id`, NFT `contract_account_id`.
/// You can use the `token_id` from this response and then request the NFT history for that token.
///
/// **Limitations**
/// * We currently provide the most recent 100 items.
///   Full-featured pagination will be provided soon.
pub async fn get_nft_collection_by_contract(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::NftCollectionRequest>,
    limit_params: web::Query<types::query_params::LimitParams>,
) -> crate::Result<Json<schemas::NftsResponse>> {
    let limit = types::query_params::checked_get_limit(limit_params.limit)?;
    let block = db_helpers::get_last_block(&pool_explorer).await?;
    modules::check_account_exists(&rpc_client, &request.account_id.0, block.height).await?;

    Ok(Json(schemas::NftsResponse {
        nfts: super::data_provider::get_nfts_by_contract(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.account_id.0.clone(),
            block.height,
            limit,
        )
        .await?,
        contract_metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(NFT))]
/// Get NFT
///
/// This endpoint returns detailed information on the NFT
/// for the given `token_id`, NFT `contract_account_id`, `block_timestamp_nanos`/`block_height`.
pub async fn get_nft(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::NftRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::NftResponse>> {
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;

    Ok(Json(schemas::NftResponse {
        nft: super::data_provider::get_nft(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.token_id.clone(),
            block.height,
        )
        .await?,
        contract_metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(NFT))]
/// Get NFT history
///
/// This endpoint returns the transaction history for the given NFT.
/// **Note:** The result is centered around the history of the specific NFT and will return list of its passing owners.
///
/// **Limitations**
/// * For now, we only support NFT contracts that implement the Events NEP standard.
/// * We currently provide the most recent 100 items.
///   Full-featured pagination will be provided soon.
pub async fn get_nft_history(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::NftRequest>,
    limit_params: web::Query<types::query_params::LimitParams>,
) -> crate::Result<Json<schemas::NftHistoryResponse>> {
    let limit = types::query_params::checked_get_limit(limit_params.limit)?;
    let block = db_helpers::get_last_block(&pool_explorer).await?;

    Ok(Json(schemas::NftHistoryResponse {
        history: super::data_provider::get_nft_history(
            &pool_explorer,
            &request.contract_account_id.0,
            &request.token_id,
            &block,
            limit,
        )
        .await?,
        nft: super::data_provider::get_nft(
            &rpc_client,
            request.contract_account_id.0.clone(),
            request.token_id.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

#[api_v2_operation(tags(NFT))]
/// Get NFT contract metadata
///
/// This endpoint returns the metadata for a given NFT contract and `block_timestamp_nanos`/`block_height`.
/// **Note:** This is contract-wide metadata. Each NFT also has its own metadata.
pub async fn get_nft_contract_metadata(
    pool_explorer: web::Data<db_helpers::ExplorerPool>,
    rpc_client: web::Data<near_jsonrpc_client::JsonRpcClient>,
    _: crate::types::pagoda_api_key::PagodaApiKey,
    request: actix_web_validator::Path<schemas::MetadataRequest>,
    block_params: web::Query<types::query_params::BlockParams>,
) -> crate::Result<Json<schemas::MetadataResponse>> {
    let block = db_helpers::checked_get_block(&pool_explorer, &block_params).await?;

    Ok(Json(schemas::MetadataResponse {
        metadata: super::data_provider::get_nft_contract_metadata(
            &rpc_client,
            request.contract_account_id.0.clone(),
            block.height,
        )
        .await?,
        block_timestamp_nanos: types::U64::from(block.timestamp),
        block_height: types::U64::from(block.height),
    }))
}

'''
'''--- src/modules/nft/schemas.rs ---
use paperclip::actix::Apiv2Schema;
use validator::Validate;

use crate::types;

// *** Requests ***

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct NftCountsRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
}

#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct NftCollectionRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub account_id: types::AccountId,
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

// duplicate in each folder
#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct MetadataRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
}

/// `token_id` is available at `NftCollectionByContractResponse`
#[derive(
    Validate, Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema,
)]
pub struct NftRequest {
    #[validate(custom = "crate::errors::validate_account_id")]
    pub contract_account_id: types::AccountId,
    pub token_id: String,
}

// *** Responses ***

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCountsResponse {
    pub nft_counts: Vec<NftCount>,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftsResponse {
    pub nfts: Vec<Nft>,
    pub contract_metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftResponse {
    pub nft: Nft,
    pub contract_metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftHistoryResponse {
    pub history: Vec<HistoryItem>,
    pub nft: Nft,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct MetadataResponse {
    pub metadata: NftContractMetadata,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

// ---

/// This type describes the history of NFT movements.
/// Note, it's not attached to any user, it's the whole history of NFT movements.
/// `cause` is one of ["mint", "transfer", "burn"]
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct HistoryItem {
    pub cause: String,
    pub old_account_id: Option<types::AccountId>,
    pub new_account_id: Option<types::AccountId>,
    // TODO PHASE 2 add index here
    // pub event_index: types::U128,
    pub status: String,
    pub block_timestamp_nanos: types::U64,
    pub block_height: types::U64,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftCount {
    pub contract_account_id: types::AccountId,
    pub nft_count: u32,
    // TODO PHASE 1 naming.
    pub last_updated_at_timestamp_nanos: types::U128,
    pub contract_metadata: NftContractMetadata,
}

/// The type for Non Fungible Token Contract Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized data_provider assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<String>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

/// The type for Non Fungible Token. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct Nft {
    pub token_id: String,
    pub owner_account_id: String,
    pub metadata: NftMetadata,
    // TODO PHASE 1 do we want to show them? People often put here weird things
    // pub approved_account_ids: Option<std::collections::HashMap<AccountId, u64>>,
}

/// The type for Non Fungible Token Metadata. Inspired by
/// https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct NftMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed data_provider
    pub media_hash: Option<String>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    //pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
    //pub expires_at: Option<String>, // ISO 8601 datetime when token expires
    //pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
    //pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
    pub extra: Option<String>, // anything extra the NFT wants to data_provider on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<String>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

'''
'''--- src/rpc_helpers.rs ---
use near_jsonrpc_primitives::types::query::{QueryResponseKind, RpcQueryError};

use crate::errors;

const RPC_RETRY_COUNT: usize = 10;

const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);

pub(crate) fn get_function_call_request(
    block_height: u64,
    account_id: near_primitives::types::AccountId,
    method_name: &str,
    args: serde_json::Value,
) -> near_jsonrpc_client::methods::query::RpcQueryRequest {
    near_jsonrpc_client::methods::query::RpcQueryRequest {
        block_reference: near_primitives::types::BlockReference::BlockId(
            near_primitives::types::BlockId::Height(block_height),
        ),
        request: near_primitives::views::QueryRequest::CallFunction {
            account_id,
            method_name: method_name.to_string(),
            args: near_primitives::types::FunctionArgs::from(args.to_string().into_bytes()),
        },
    }
}

fn clone_request(
    request: &near_jsonrpc_client::methods::query::RpcQueryRequest,
) -> near_jsonrpc_client::methods::query::RpcQueryRequest {
    near_jsonrpc_client::methods::query::RpcQueryRequest {
        block_reference: request.block_reference.clone(),
        request: request.request.clone(),
    }
}

pub(crate) async fn wrapped_call(
    rpc_client: &near_jsonrpc_client::JsonRpcClient,
    request: near_jsonrpc_client::methods::query::RpcQueryRequest,
    block_height: u64,
    contract_id: &near_primitives::types::AccountId,
) -> crate::Result<near_primitives::views::CallResult> {
    let mut interval = INTERVAL;
    let mut retry_attempt = 0usize;

    tracing::info!(
        target: crate::LOGGER_MSG,
        "RPC request: {:?}\nTo contract:{}, block {}",
        request,
        contract_id,
        block_height
    );

    loop {
        retry_attempt += 1;

        match rpc_client.call(clone_request(&request)).await {
            Ok(response) => {
                return match response.kind {
                    QueryResponseKind::CallResult(result) => Ok(result),
                    // I hope this is unreachable code, so if we meet such case, retry will not help
                    _ => Err(errors::ErrorKind::RPCError(
                        "Unexpected type of the response after CallFunction request".to_string(),
                    )
                    .into()),
                };
            }
            Err(near_jsonrpc_client::errors::JsonRpcError::ServerError(
                near_jsonrpc_client::errors::JsonRpcServerError::HandlerError(
                    near_jsonrpc_client::methods::query::RpcQueryError::UnknownAccount { .. },
                ),
            )) => {
                return Err(errors::ErrorKind::InvalidInput(format!(
                    "account_id {} does not exist at block_height {}",
                    contract_id, block_height
                ))
                .into())
            }
            Err(x) => {
                if let Some(RpcQueryError::ContractExecutionError { vm_error, .. }) =
                    x.handler_error()
                {
                    if vm_error.contains("CodeDoesNotExist") || vm_error.contains("MethodNotFound")
                    {
                        // no need to retry this
                        return Err(errors::ErrorKind::InvalidInput(format!(
                            "The account `{}` does not implement any suitable contract at block {}",
                            contract_id, block_height
                        ))
                        .into());
                    }
                }

                tracing::warn!(
                    target: crate::LOGGER_MSG,
                    "Error occurred during {:#?}:\nFailed RPC request: {:?}\nTo contract:{}, block {}\n Retrying in {} milliseconds...",
                    x,
                    request,
                    contract_id,
                    block_height,
                    interval.as_millis(),
                );

                if retry_attempt == RPC_RETRY_COUNT {
                    tracing::warn!(
                        target: crate::LOGGER_MSG,
                        "Failed to perform query to RPC after {} attempts. Stop trying.",
                        RPC_RETRY_COUNT
                    );
                    return Err(x.into());
                }
                tokio::time::sleep(interval).await;
                if interval < MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
}

'''
'''--- src/types/account_id.rs ---
use std::fmt;
use std::str::FromStr;

use derive_more::{AsRef, Deref, From, FromStr, Into};
use paperclip::v2::{models::DataType, schema::TypedData};
use serde::{Deserialize, Serialize};

#[derive(
    Eq,
    Ord,
    Hash,
    Clone,
    PartialEq,
    PartialOrd,
    From,
    Into,
    AsRef,
    Deref,
    FromStr,
    Serialize,
    Deserialize,
)]
#[serde(transparent)]
pub struct AccountId(pub(crate) near_primitives::types::AccountId);

impl fmt::Debug for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.0, f)
    }
}

impl TypedData for AccountId {
    fn data_type() -> DataType {
        DataType::String
    }
}

pub(crate) fn extract_account_id(
    account_id: &str,
) -> crate::Result<Option<near_primitives::types::AccountId>> {
    Ok(if account_id.is_empty() {
        None
    } else {
        Some(near_primitives::types::AccountId::from_str(account_id)?)
    })
}

'''
'''--- src/types/mod.rs ---
pub(crate) mod account_id;
pub(crate) mod numeric;
pub(crate) mod pagoda_api_key;
pub mod query_params;

pub(crate) use account_id::AccountId;
pub(crate) use numeric::{U128, U64};

'''
'''--- src/types/numeric.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use num_traits::cast::ToPrimitive;
use paperclip::v2::{models::DataType, schema::TypedData};
use serde::{Deserialize, Deserializer, Serialize, Serializer};

use crate::{errors, BigDecimal};

pub(crate) fn to_u128(x: &BigDecimal) -> crate::Result<u128> {
    x.to_string().parse().map_err(|e| {
        errors::ErrorKind::InternalError(format!("Failed to parse u128 {}: {}", x, e)).into()
    })
}

pub(crate) fn to_u64(x: &BigDecimal) -> crate::Result<u64> {
    x.to_u64().ok_or_else(|| {
        errors::ErrorKind::InternalError(format!("Failed to parse u64 {}", x)).into()
    })
}

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/json_types/integers.rs
macro_rules! impl_str_type {
    ($iden: ident, $ty: tt) => {
        #[derive(
            Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, BorshDeserialize, BorshSerialize,
        )]
        pub struct $iden(pub $ty);

        impl From<$ty> for $iden {
            fn from(v: $ty) -> Self {
                Self(v)
            }
        }

        impl From<$iden> for $ty {
            fn from(v: $iden) -> $ty {
                v.0
            }
        }

        impl Serialize for $iden {
            fn serialize<S>(
                &self,
                serializer: S,
            ) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
            where
                S: Serializer,
            {
                serializer.serialize_str(&self.0.to_string())
            }
        }

        impl<'de> Deserialize<'de> for $iden {
            fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
            where
                D: Deserializer<'de>,
            {
                let s: String = Deserialize::deserialize(deserializer)?;
                Ok(Self(str::parse::<$ty>(&s).map_err(|err| {
                    serde::de::Error::custom(err.to_string())
                })?))
            }
        }

        impl TypedData for $iden {
            fn data_type() -> DataType {
                DataType::String
            }
        }
    };
}

impl_str_type!(U128, u128);
impl_str_type!(U64, u64);

'''
'''--- src/types/pagoda_api_key.rs ---
/// This security schema is just used for OpenAPI spec declaration as validation of the api key
/// happens before the requests hit this service.
#[derive(paperclip::actix::Apiv2Security)]
#[openapi(
    apiKey,
    in = "header",
    name = "x-api-key",
    description = "Use Pagoda DevConsole API key here"
)]
pub struct PagodaApiKey;

impl actix_web::FromRequest for PagodaApiKey {
    type Error = actix_web::Error;
    type Future = futures::future::Ready<Result<Self, Self::Error>>;

    fn from_request(
        _: &actix_web::HttpRequest,
        _payload: &mut actix_web::dev::Payload,
    ) -> Self::Future {
        // This is no-op by design as the access key gets validated on the API gateway level before
        // hitting Enhanced API server, thus we don't need to validate the key here at all.
        futures::future::ready(Ok(Self {}))
    }
}

'''
'''--- src/types/query_params.rs ---
use crate::{errors, types};
use paperclip::actix::Apiv2Schema;

const DEFAULT_PAGE_LIMIT: u32 = 20;
const MAX_PAGE_LIMIT: u32 = 100;

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct BlockParams {
    pub block_timestamp_nanos: Option<types::U64>,
    pub block_height: Option<types::U64>,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct PaginationParams {
    /// Maximum available limit 100
    pub limit: Option<u32>,
    pub after_event_index: Option<types::U128>,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, Apiv2Schema)]
pub struct LimitParams {
    pub limit: Option<u32>,
}

// Helper for parsing the data from user
#[derive(Debug)]
pub(crate) struct Pagination {
    pub limit: u32,
    pub after_event_index: Option<u128>,
}

/// Validates limit_param received from the user, sets the default value if none was provided
pub(crate) fn checked_get_limit(limit_param: Option<u32>) -> crate::Result<u32> {
    Ok(if let Some(limit) = limit_param {
        if limit > MAX_PAGE_LIMIT || limit == 0 {
            return Err(errors::ErrorKind::InvalidInput(format!(
                "Limit should be in range [1, {}]",
                MAX_PAGE_LIMIT
            ))
            .into());
        }
        limit
    } else {
        DEFAULT_PAGE_LIMIT
    })
}

'''