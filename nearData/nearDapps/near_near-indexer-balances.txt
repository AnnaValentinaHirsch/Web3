*GitHub Repository "near/near-indexer-balances"*

'''--- Cargo.toml ---
[package]
name = "indexer-balances"
version = "0.1.0"
edition = "2021"
rust-version = "1.64"

[lib]
proc-macro = true

[dependencies]
actix-web = "=4.0.1"
anyhow = "1.0.51"
bigdecimal = { version = "0.2", features = ["serde"] }
cached = "0.23.0"
clap = { version = "3.2.17", features = ["color", "derive", "env"] }
dotenv = "0.15.0"
futures = "0.3.5"
lazy_static = "1.4.0"
num-traits = "0.2.11"
prometheus = "0.13.1"
quote = "1.0.17"
sqlx = { version = "0.5.13", features = ["runtime-tokio-native-tls", "postgres", "bigdecimal", "json"] }
syn = "1.0.90"
tokio = { version = "1.8", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.35"
tracing-appender = "0.1.2"
tracing-subscriber = "0.2.4"

near-jsonrpc-primitives = "0.14.0"
near-jsonrpc-client = "0.4.0-beta.0"
near-lake-framework = "0.5.0"
near-primitives = "0.14.0"

'''
'''--- README.md ---
# Indexer Balances

Async Postgres-compatible solution to load the data from NEAR blockchain.
Based on [NEAR Lake Framework](https://github.com/near/near-lake-framework-rs).

See [Indexer Base](https://github.com/near/near-indexer-base#indexer-base) docs for all the explanations, installation guide, etc.

### Why `account_changes` is not enough?

1. `account_changes` has only the absolute value for the balance, while we want to see the delta;
2. `account_changes` does not have involved account_id.

### What else do I need to know?

The code does non-trivial work with extracting the balance-changing events and trying to store them in the correct order.

The ordering is taken from the [nearcore implementation](https://github.com/near/nearcore/blob/master/runtime/runtime/src/lib.rs#L1136):
1. validators account update
2. process transactions
3. process receipts

Using [Indexer For Explorer](https://github.com/near/near-indexer-for-explorer) terminology, we merge `account_changes` and `action_receipt_actions` by `receipt_id`.

We have the natural order in these 2 arrays.
1. If `receipt_id` is stored in both arrays -> merge them to one line in the resulting table.
2. If `receipt_id` from `action_receipt_actions` has no pair in `account_changes` -> collect all the possible info from `action_receipt_actions` and put the line in the resulting table.
3. If the line in `account_changes` has no `receipt_id`, we need to check whether it changed someone's balance. If the balance was changed -> collect all the possible info from `account_changes` and put the line in the resulting table.

While merging, we can meet the situation #2 and #3 at the same point of time.
We need to find the right order of storing such cases.  
I feel these 2 situations never affect each other, so any order will work fine.
I decided to put `account_changes` data first (just to be consistent)

### Contribution Guide

Please refer to this [guide](https://github.com/near/near-indexer-for-explorer/blob/master/CONTRIBUTING.md) before submitting PRs to this repo 

'''
'''--- migrations/20220221161526_initial.sql ---
CREATE TABLE near_balance_events
(
    event_index               numeric(38, 0) PRIMARY KEY,
    block_timestamp           numeric(20, 0) NOT NULL,
    block_height              numeric(20, 0) NOT NULL,
    receipt_id                text,
    transaction_hash          text,
    affected_account_id       text           NOT NULL,
    involved_account_id       text,
    direction                 text           NOT NULL,
    cause                     text           NOT NULL,
    status                    text           NOT NULL,
    delta_nonstaked_amount    numeric(40, 0) NOT NULL,
    absolute_nonstaked_amount numeric(40, 0) NOT NULL,
    delta_staked_amount       numeric(40, 0) NOT NULL,
    absolute_staked_amount    numeric(40, 0) NOT NULL
);

CREATE INDEX CONCURRENTLY near_balance_events_block_height_idx ON near_balance_events (block_height);
CREATE INDEX CONCURRENTLY near_balance_events_affected_account_idx ON near_balance_events (affected_account_id);
CREATE INDEX CONCURRENTLY near_balance_events_receipt_id_idx ON near_balance_events (receipt_id);
CREATE INDEX CONCURRENTLY near_balance_events_tx_hash_idx ON near_balance_events (transaction_hash);

-- ALTER TABLE near_balance_events
--     ADD CONSTRAINT near_balance_events_receipt_id_fk FOREIGN KEY (receipt_id) REFERENCES action_receipts(receipt_id);
-- ALTER TABLE near_balance_events
--     ADD CONSTRAINT near_balance_events_tx_hash_fk FOREIGN KEY (transaction_hash) REFERENCES transactions(transaction_hash);

'''
'''--- src/configs.rs ---
use clap::Parser;
use tracing_subscriber::EnvFilter;

/// NEAR Indexer for Explorer
/// Watches for stream of blocks from the chain
#[derive(Parser, Debug)]
#[clap(
    version,
    author,
    about,
    disable_help_subcommand(true),
    propagate_version(true),
    next_line_help(true)
)]
pub(crate) struct Opts {
    /// Enabled Indexer for Explorer debug level of logs
    #[clap(long, env)]
    pub debug: bool,
    /// Block height to start the stream from. If None, start from interruption
    #[clap(long, short, env)]
    pub start_block_height: Option<u64>,
    #[clap(long, short, env)]
    pub near_archival_rpc_url: String,
    // Chain ID: testnet or mainnet, used for NEAR Lake initialization
    #[clap(long, env)]
    pub chain_id: String,
    /// Port to enable metrics service
    #[clap(long, short, env, default_value_t = 3000)]
    pub port: u16,
}

impl Opts {
    // returns a Lake Config object where AWS credentials are sourced from .env file first, and then from .aws/credentials if not found.
    // https://docs.aws.amazon.com/sdk-for-rust/latest/dg/credentials.html
    pub async fn to_lake_config(&self, start_block_height: u64) -> near_lake_framework::LakeConfig {
        let config_builder = near_lake_framework::LakeConfigBuilder::default();

        tracing::info!(target: crate::LOGGING_PREFIX, "CHAIN_ID: {}", self.chain_id);

        match self.chain_id.as_str() {
            "mainnet" => config_builder.mainnet(),
            "testnet" => config_builder.testnet(),
            invalid_chain => panic!(
                "Invalid CHAIN_ID: `{}`. Try `mainnet` or `testnet`",
                invalid_chain
            ),
        }
        .start_block_height(start_block_height)
        .build()
        .expect("Failed to build LakeConfig")
    }
}

pub(crate) fn init_tracing(
    debug: bool,
) -> anyhow::Result<tracing_appender::non_blocking::WorkerGuard> {
    let mut env_filter = EnvFilter::new("indexer_balances=info");

    if debug {
        env_filter = env_filter.add_directive("near_lake_framework=debug".parse()?);
    }

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    tracing::warn!(
                        target: crate::LOGGING_PREFIX,
                        "Ignoring directive `{}`: {}",
                        s,
                        err
                    );
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    let (non_blocking, guard) = tracing_appender::non_blocking(std::io::stdout());

    let subscriber = tracing_subscriber::fmt::Subscriber::builder()
        .with_writer(non_blocking)
        .with_env_filter(env_filter);

    if std::env::var("ENABLE_JSON_LOGS").is_ok() {
        subscriber.json().init();
    } else {
        subscriber.compact().init();
    }

    Ok(guard)
}

'''
'''--- src/db_adapters/balance_changes.rs ---
use cached::Cached;
use std::collections::HashMap;
use std::ops::Sub;
use std::str::FromStr;

use crate::models::balance_changes::NearBalanceEvent;
use crate::models::PrintEnum;
use bigdecimal::BigDecimal;
use futures::future::try_join_all;
use near_jsonrpc_client::errors::JsonRpcError;
use near_jsonrpc_primitives::types::query::RpcQueryError;
use near_lake_framework::near_indexer_primitives::{
    self,
    views::{ExecutionStatusView, StateChangeCauseView},
};
use num_traits::Zero;

// https://explorer.near.org/transactions/FGSPpucGQBUTPscfjQRs7Poo4XyaXGawX6QriKbhT3sE#7nu7ZAK3T11erEgG8aWTRGmz9uTHGazoNMjJdVyG3piX

// https://nomicon.io/RuntimeSpec/ApplyingChunk#processing-order
pub(crate) async fn store_balance_changes(
    pool: &sqlx::Pool<sqlx::Postgres>,
    shards: &[near_indexer_primitives::IndexerShard],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    balances_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<()> {
    let futures = shards.iter().map(|shard| {
        store_changes_for_chunk(pool, shard, block_header, balances_cache, json_rpc_client)
    });

    try_join_all(futures).await.map(|_| ())
}

#[derive(Debug, Default)]
struct AccountChangesBalances {
    pub validators: Vec<crate::AccountWithBalance>,
    pub transactions: HashMap<near_indexer_primitives::CryptoHash, crate::AccountWithBalance>,
    pub receipts: HashMap<near_indexer_primitives::CryptoHash, crate::AccountWithBalance>,
    pub rewards: HashMap<near_indexer_primitives::CryptoHash, crate::AccountWithBalance>,
}

async fn store_changes_for_chunk(
    pool: &sqlx::Pool<sqlx::Postgres>,
    shard: &near_indexer_primitives::IndexerShard,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    balances_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<()> {
    let mut changes: Vec<NearBalanceEvent> = vec![];
    let mut changes_data =
        collect_data_from_balance_changes(&shard.state_changes, block_header.height)?;
    // We should collect these 3 groups sequentially because they all share the same cache
    changes.extend(
        store_validator_accounts_update_for_chunk(
            &changes_data.validators,
            block_header,
            balances_cache,
            json_rpc_client,
        )
        .await?,
    );
    match shard.chunk.as_ref().map(|chunk| &chunk.transactions) {
        None => {}
        Some(x) => changes.extend(
            store_transaction_execution_outcomes_for_chunk(
                x,
                &mut changes_data.transactions,
                block_header,
                balances_cache,
                json_rpc_client,
            )
            .await?,
        ),
    }

    changes.extend(
        store_receipt_execution_outcomes_for_chunk(
            &shard.receipt_execution_outcomes,
            &mut changes_data.receipts,
            &mut changes_data.rewards,
            block_header,
            balances_cache,
            json_rpc_client,
        )
        .await?,
    );

    let start_from_index: u128 = (block_header.timestamp as u128) * 100_000_000 * 100_000_000
        + (shard.shard_id as u128) * 10_000_000;
    for (i, change) in changes.iter_mut().enumerate() {
        change.event_index = BigDecimal::from_str(&(start_from_index + i as u128).to_string())?;
    }
    crate::models::chunked_insert(pool, &changes, 10).await?;
    Ok(())
}

fn collect_data_from_balance_changes(
    state_changes: &near_indexer_primitives::views::StateChangesView,
    block_height: u64,
) -> anyhow::Result<AccountChangesBalances> {
    let mut result: AccountChangesBalances = Default::default();

    for state_change_with_cause in state_changes {
        let near_indexer_primitives::views::StateChangeWithCauseView { cause, value } =
            state_change_with_cause;

        let account_details = match value {
            near_indexer_primitives::views::StateChangeValueView::AccountUpdate {
                account_id,
                account,
            } => crate::AccountWithBalance {
                account_id: account_id.clone(),
                balance: crate::BalanceDetails {
                    non_staked: account.amount,
                    staked: account.locked,
                },
            },
            near_indexer_primitives::views::StateChangeValueView::AccountDeletion {
                account_id,
            } => crate::AccountWithBalance {
                account_id: account_id.clone(),
                balance: crate::BalanceDetails {
                    non_staked: 0,
                    staked: 0,
                },
            },
            // other values do not provide balance changes
            _ => continue,
        };

        match cause {
            StateChangeCauseView::NotWritableToDisk
            | StateChangeCauseView::InitialState
            | StateChangeCauseView::ActionReceiptProcessingStarted { .. }
            | StateChangeCauseView::UpdatedDelayedReceipts
            | StateChangeCauseView::PostponedReceipt { .. }
            | StateChangeCauseView::Resharding => {
                anyhow::bail!("Unexpected state change cause met: {:#?}", cause);
            }
            StateChangeCauseView::ValidatorAccountsUpdate => {
                result.validators.push(account_details);
            }
            StateChangeCauseView::TransactionProcessing { tx_hash } => {
                let prev_inserted_item = result
                    .transactions
                    .insert(*tx_hash, account_details.clone());
                if let Some(details) = prev_inserted_item {
                    anyhow::bail!(
                        "Duplicated balance changes for transaction {} at block_height {}. \
                        One of them may be missed\n{:#?}\n{:#?}",
                        tx_hash.to_string(),
                        block_height,
                        account_details,
                        details
                    );
                }
            }
            StateChangeCauseView::Migration {} => {
                // We had this reason once, in block 44337060
                // It does not affect balances, so we can skip it
            }
            StateChangeCauseView::ActionReceiptGasReward { receipt_hash } => {
                let prev_inserted_item = result
                    .rewards
                    .insert(*receipt_hash, account_details.clone());
                if let Some(details) = prev_inserted_item {
                    anyhow::bail!(
                        "Duplicated balance changes for receipt {} (reward), at block_height {}. \
                        One of them may be missed\n{:#?}\n{:#?}",
                        receipt_hash.to_string(),
                        block_height,
                        account_details,
                        details
                    );
                }
            }
            StateChangeCauseView::ReceiptProcessing { receipt_hash } => {
                let prev_inserted_item = result
                    .receipts
                    .insert(*receipt_hash, account_details.clone());
                if let Some(details) = prev_inserted_item {
                    anyhow::bail!(
                        "Duplicated balance changes for receipt {} at block_height {}. \
                        One of them may be missed\n{:#?}\n{:#?}",
                        receipt_hash.to_string(),
                        block_height,
                        account_details,
                        details
                    );
                }
            }
        }
    }
    Ok(result)
}

async fn store_validator_accounts_update_for_chunk(
    validator_changes: &[crate::AccountWithBalance],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    balances_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<Vec<NearBalanceEvent>> {
    let mut result: Vec<NearBalanceEvent> = vec![];
    for new_details in validator_changes {
        let prev_balance = get_balance_retriable(
            &new_details.account_id,
            &block_header.prev_hash,
            balances_cache,
            json_rpc_client,
        )
        .await?;
        let deltas = get_deltas(&new_details.balance, &prev_balance)?;
        save_latest_balance(
            new_details.account_id.clone(),
            &new_details.balance,
            balances_cache,
        )
        .await;

        result.push(NearBalanceEvent {
            event_index: BigDecimal::zero(), // will enumerate later
            block_timestamp: block_header.timestamp.into(),
            block_height: block_header.height.into(),
            receipt_id: None,
            transaction_hash: None,
            affected_account_id: new_details.account_id.to_string(),
            involved_account_id: None,
            direction: crate::models::Direction::Inbound.print().to_string(),
            cause: crate::models::Cause::ValidatorsReward.print().to_string(),
            status: ExecutionStatusView::SuccessValue("".to_string())
                .print()
                .to_string(),
            delta_nonstaked_amount: deltas.0,
            absolute_nonstaked_amount: BigDecimal::from_str(
                &new_details.balance.non_staked.to_string(),
            )
            .unwrap(),
            delta_staked_amount: deltas.1,
            absolute_staked_amount: BigDecimal::from_str(&new_details.balance.staked.to_string())
                .unwrap(),
        });
    }

    Ok(result)
}

async fn store_transaction_execution_outcomes_for_chunk(
    transactions: &[near_indexer_primitives::IndexerTransactionWithOutcome],
    transaction_changes: &mut HashMap<
        near_indexer_primitives::CryptoHash,
        crate::AccountWithBalance,
    >,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    balances_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<Vec<NearBalanceEvent>> {
    let mut result: Vec<NearBalanceEvent> = vec![];

    for transaction in transactions {
        let affected_account_id = &transaction.transaction.signer_id;
        let involved_account_id = match transaction.transaction.receiver_id.as_str() {
            "system" => None,
            _ => Some(&transaction.transaction.receiver_id),
        };

        let prev_balance = get_balance_retriable(
            affected_account_id,
            &block_header.prev_hash,
            balances_cache,
            json_rpc_client,
        )
        .await?;

        let details_after_transaction = transaction_changes
            .remove(&transaction.transaction.hash)
            .ok_or_else(|| {
            anyhow::anyhow!(
                "Failed to find balance change for transaction {}",
                &transaction.transaction.hash.to_string()
            )
        })?;

        if details_after_transaction.account_id != *affected_account_id {
            anyhow::bail!(
                "Unexpected balance change info found for transaction {}.\nExpected account_id {},\nActual account_id {}",
                &transaction.transaction.hash.to_string(),
                affected_account_id.to_string(),
                details_after_transaction.account_id.to_string()
            );
        }

        let deltas = get_deltas(&details_after_transaction.balance, &prev_balance)?;
        save_latest_balance(
            affected_account_id.clone(),
            &details_after_transaction.balance,
            balances_cache,
        )
        .await;

        result.push(NearBalanceEvent {
            event_index: BigDecimal::zero(), // will enumerate later
            block_timestamp: block_header.timestamp.into(),
            block_height: block_header.height.into(),
            receipt_id: None,
            transaction_hash: Some(transaction.transaction.hash.to_string()),
            affected_account_id: affected_account_id.to_string(),
            involved_account_id: involved_account_id.map(|id| id.to_string()),
            direction: crate::models::Direction::Outbound.print().to_string(),
            cause: crate::models::Cause::Transaction.print().to_string(),
            status: transaction
                .outcome
                .execution_outcome
                .outcome
                .status
                .print()
                .to_string(),
            delta_nonstaked_amount: deltas.0,
            absolute_nonstaked_amount: BigDecimal::from_str(
                &details_after_transaction.balance.non_staked.to_string(),
            )
            .unwrap(),
            delta_staked_amount: deltas.1,
            absolute_staked_amount: BigDecimal::from_str(
                &details_after_transaction.balance.staked.to_string(),
            )
            .unwrap(),
        });

        // Adding the opposite entry to the DB, just to show that the second account_id was there too
        if let Some(account_id) = involved_account_id {
            if account_id != affected_account_id {
                // balance is not changing here, we just note the line here
                let balance = get_balance_retriable(
                    account_id,
                    &block_header.prev_hash,
                    balances_cache,
                    json_rpc_client,
                )
                .await?;
                result.push(NearBalanceEvent {
                    event_index: BigDecimal::zero(), // will enumerate later
                    block_timestamp: block_header.timestamp.into(),
                    block_height: block_header.height.into(),
                    receipt_id: None,
                    transaction_hash: Some(transaction.transaction.hash.to_string()),
                    affected_account_id: account_id.to_string(),
                    involved_account_id: Some(affected_account_id.to_string()),
                    direction: crate::models::Direction::Inbound.print().to_string(),
                    cause: crate::models::Cause::Transaction.print().to_string(),
                    status: transaction
                        .outcome
                        .execution_outcome
                        .outcome
                        .status
                        .print()
                        .to_string(),
                    delta_nonstaked_amount: BigDecimal::zero(),
                    absolute_nonstaked_amount: BigDecimal::from_str(
                        &balance.non_staked.to_string(),
                    )
                    .unwrap(),
                    delta_staked_amount: BigDecimal::zero(),
                    absolute_staked_amount: BigDecimal::from_str(&balance.staked.to_string())
                        .unwrap(),
                });
            }
        }
    }

    if !transaction_changes.is_empty() {
        anyhow::bail!(
            "{} changes for transactions were not applied, block_height {}\n{:#?}",
            transaction_changes.len(),
            block_header.height,
            transaction_changes
        );
    }

    Ok(result)
}

async fn store_receipt_execution_outcomes_for_chunk(
    outcomes_with_receipts: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    receipt_changes: &mut HashMap<near_indexer_primitives::CryptoHash, crate::AccountWithBalance>,
    reward_changes: &mut HashMap<near_indexer_primitives::CryptoHash, crate::AccountWithBalance>,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    balances_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<Vec<NearBalanceEvent>> {
    let mut result: Vec<NearBalanceEvent> = vec![];

    for outcome_with_receipt in outcomes_with_receipts {
        let receipt_id = &outcome_with_receipt.receipt.receipt_id;
        // predecessor has made the action, as the result, receiver's balance may change
        let affected_account_id = &outcome_with_receipt.receipt.receiver_id;
        let involved_account_id = match outcome_with_receipt.receipt.predecessor_id.as_str() {
            "system" => None,
            _ => Some(&outcome_with_receipt.receipt.predecessor_id),
        };

        if let Some(details_after_receipt) = receipt_changes.remove(receipt_id) {
            if details_after_receipt.account_id != *affected_account_id {
                anyhow::bail!(
                "Unexpected balance change info found for receipt {}.\nExpected account_id {},\nActual account_id {}",
                receipt_id.to_string(),
                affected_account_id.to_string(),
                details_after_receipt.account_id.to_string()
            );
            }

            let prev_balance = get_balance_retriable(
                affected_account_id,
                &block_header.prev_hash,
                balances_cache,
                json_rpc_client,
            )
            .await?;

            let deltas = get_deltas(&details_after_receipt.balance, &prev_balance)?;
            save_latest_balance(
                affected_account_id.clone(),
                &details_after_receipt.balance,
                balances_cache,
            )
            .await;

            result.push(NearBalanceEvent {
                event_index: BigDecimal::zero(), // will enumerate later
                block_timestamp: block_header.timestamp.into(),
                block_height: block_header.height.into(),
                receipt_id: Some(receipt_id.to_string()),
                transaction_hash: None,
                affected_account_id: affected_account_id.to_string(),
                involved_account_id: involved_account_id.map(|id| id.to_string()),
                direction: crate::models::Direction::Inbound.print().to_string(),
                cause: crate::models::Cause::Receipt.print().to_string(),
                status: outcome_with_receipt
                    .execution_outcome
                    .outcome
                    .status
                    .print()
                    .to_string(),
                delta_nonstaked_amount: deltas.0,
                absolute_nonstaked_amount: BigDecimal::from_str(
                    &details_after_receipt.balance.non_staked.to_string(),
                )
                .unwrap(),
                delta_staked_amount: deltas.1,
                absolute_staked_amount: BigDecimal::from_str(
                    &details_after_receipt.balance.staked.to_string(),
                )
                .unwrap(),
            });

            // Adding the opposite entry to the DB, just to show that the second account_id was there too
            if let Some(account_id) = involved_account_id {
                if account_id != affected_account_id {
                    // balance is not changing here, we just note the line here
                    let balance = get_balance_retriable(
                        account_id,
                        &block_header.prev_hash,
                        balances_cache,
                        json_rpc_client,
                    )
                    .await?;
                    result.push(NearBalanceEvent {
                        event_index: BigDecimal::zero(), // will enumerate later
                        block_timestamp: block_header.timestamp.into(),
                        block_height: block_header.height.into(),
                        receipt_id: Some(receipt_id.to_string()),
                        transaction_hash: None,
                        affected_account_id: account_id.to_string(),
                        involved_account_id: Some(affected_account_id.to_string()),
                        direction: crate::models::Direction::Outbound.print().to_string(),
                        cause: crate::models::Cause::Receipt.print().to_string(),
                        status: outcome_with_receipt
                            .execution_outcome
                            .outcome
                            .status
                            .print()
                            .to_string(),
                        delta_nonstaked_amount: BigDecimal::zero(),
                        absolute_nonstaked_amount: BigDecimal::from_str(
                            &balance.non_staked.to_string(),
                        )
                        .unwrap(),
                        delta_staked_amount: BigDecimal::zero(),
                        absolute_staked_amount: BigDecimal::from_str(&balance.staked.to_string())
                            .unwrap(),
                    });
                }
            }
        }

        // REWARDS
        if let Some(details_after_reward) = reward_changes.remove(receipt_id) {
            if details_after_reward.account_id != *affected_account_id {
                anyhow::bail!(
                "Unexpected balance change info found for receipt_id {} (reward).\nExpected account_id {},\nActual account_id {}",
                receipt_id.to_string(),
                affected_account_id.to_string(),
                details_after_reward.account_id.to_string()
            );
            }

            let prev_balance = get_balance_retriable(
                affected_account_id,
                &block_header.prev_hash,
                balances_cache,
                json_rpc_client,
            )
            .await?;
            let deltas = get_deltas(&details_after_reward.balance, &prev_balance)?;
            save_latest_balance(
                affected_account_id.clone(),
                &details_after_reward.balance,
                balances_cache,
            )
            .await;

            result.push(NearBalanceEvent {
                event_index: BigDecimal::zero(), // will enumerate later
                block_timestamp: block_header.timestamp.into(),
                block_height: block_header.height.into(),
                receipt_id: Some(receipt_id.to_string()),
                transaction_hash: None,
                affected_account_id: affected_account_id.to_string(),
                involved_account_id: involved_account_id.map(|id| id.to_string()),
                direction: crate::models::Direction::Inbound.print().to_string(),
                cause: crate::models::Cause::ContractReward.print().to_string(),
                status: outcome_with_receipt
                    .execution_outcome
                    .outcome
                    .status
                    .print()
                    .to_string(),
                delta_nonstaked_amount: deltas.0,
                absolute_nonstaked_amount: BigDecimal::from_str(
                    &details_after_reward.balance.non_staked.to_string(),
                )
                .unwrap(),
                delta_staked_amount: deltas.1,
                absolute_staked_amount: BigDecimal::from_str(
                    &details_after_reward.balance.staked.to_string(),
                )
                .unwrap(),
            });
        }
    }

    if !receipt_changes.is_empty() {
        anyhow::bail!(
            "{} changes for receipts were not applied, block_height {}\n{:#?}",
            receipt_changes.len(),
            block_header.height,
            receipt_changes
        );
    }
    if !reward_changes.is_empty() {
        anyhow::bail!(
            "{} reward changes for receipts were not applied, block_height {}\n{:#?}",
            reward_changes.len(),
            block_header.height,
            reward_changes
        );
    }

    Ok(result)
}

fn get_deltas(
    new_balance: &crate::BalanceDetails,
    old_balance: &crate::BalanceDetails,
) -> anyhow::Result<(BigDecimal, BigDecimal)> {
    Ok((
        BigDecimal::from_str(&new_balance.non_staked.to_string())?
            .sub(BigDecimal::from_str(&old_balance.non_staked.to_string())?),
        BigDecimal::from_str(&new_balance.staked.to_string())?
            .sub(BigDecimal::from_str(&old_balance.staked.to_string())?),
    ))
}

async fn get_balance_retriable(
    account_id: &near_indexer_primitives::types::AccountId,
    block_hash: &near_indexer_primitives::CryptoHash,
    balance_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<crate::BalanceDetails> {
    let mut interval = crate::INTERVAL;
    let mut retry_attempt = 0usize;

    loop {
        if retry_attempt == crate::RETRY_COUNT {
            anyhow::bail!(
                "Failed to perform query to RPC after {} attempts. Stop trying.\nAccount {}, block_hash {}",
                crate::RETRY_COUNT,
                account_id.to_string(),
                block_hash.to_string()
            );
        }
        retry_attempt += 1;

        match get_balance(account_id, block_hash, balance_cache, json_rpc_client).await {
            Ok(res) => return Ok(res),
            Err(err) => {
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "Failed to request account view details from RPC for account {}, block_hash {}.{}\n Retrying in {} milliseconds...",
                    account_id.to_string(),
                    block_hash.to_string(),
                    err,
                    interval.as_millis(),
                );
                tokio::time::sleep(interval).await;
                if interval < crate::MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
}

async fn get_balance(
    account_id: &near_indexer_primitives::types::AccountId,
    block_hash: &near_indexer_primitives::CryptoHash,
    balance_cache: &crate::BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<crate::BalanceDetails> {
    let mut balances_cache_lock = balance_cache.lock().await;
    let result = match balances_cache_lock.cache_get(account_id) {
        None => {
            let account_balance =
                match get_account_view(json_rpc_client, account_id, block_hash).await {
                    Ok(account_view) => Ok(crate::BalanceDetails {
                        non_staked: account_view.amount,
                        staked: account_view.locked,
                    }),
                    Err(err) => match err.handler_error() {
                        Some(RpcQueryError::UnknownAccount { .. }) => Ok(crate::BalanceDetails {
                            non_staked: 0,
                            staked: 0,
                        }),
                        _ => Err(err.into()),
                    },
                };
            if let Ok(balance) = account_balance {
                balances_cache_lock.cache_set(account_id.clone(), balance);
            }
            account_balance
        }
        Some(balance) => Ok(*balance),
    };
    drop(balances_cache_lock);
    result
}

async fn save_latest_balance(
    account_id: near_indexer_primitives::types::AccountId,
    balance: &crate::BalanceDetails,
    balance_cache: &crate::BalanceCache,
) {
    let mut balances_cache_lock = balance_cache.lock().await;
    balances_cache_lock.cache_set(
        account_id,
        crate::BalanceDetails {
            non_staked: balance.non_staked,
            staked: balance.staked,
        },
    );
    drop(balances_cache_lock);
}

async fn get_account_view(
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
    account_id: &near_indexer_primitives::types::AccountId,
    block_hash: &near_indexer_primitives::CryptoHash,
) -> Result<near_indexer_primitives::views::AccountView, JsonRpcError<RpcQueryError>> {
    let query = near_jsonrpc_client::methods::query::RpcQueryRequest {
        block_reference: near_primitives::types::BlockReference::BlockId(
            near_primitives::types::BlockId::Hash(*block_hash),
        ),
        request: near_primitives::views::QueryRequest::ViewAccount {
            account_id: account_id.clone(),
        },
    };

    let account_response = json_rpc_client.call(query).await?;
    match account_response.kind {
        near_jsonrpc_primitives::types::query::QueryResponseKind::ViewAccount(account) => {
            Ok(account)
        }
        _ => unreachable!(
            "Unreachable code! Asked for ViewAccount (block_hash {}, account_id {})\nReceived\n\
                {:#?}\nReport this to https://github.com/near/near-jsonrpc-client-rs",
            block_hash.to_string(),
            account_id.to_string(),
            account_response.kind
        ),
    }
}

'''
'''--- src/db_adapters/mod.rs ---
pub(crate) mod balance_changes;

pub(crate) const CHUNK_SIZE_FOR_BATCH_INSERT: usize = 100;

'''
'''--- src/lib.rs ---
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct};

#[proc_macro_derive(FieldCount)]
pub fn derive_field_count(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemStruct);

    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
    let field_count = input.fields.iter().count();

    let output = quote! {
        impl #impl_generics FieldCount for #name #ty_generics #where_clause {
            fn field_count() -> usize {
                #field_count
            }
        }
    };

    TokenStream::from(output)
}

'''
'''--- src/main.rs ---
// // TODO cleanup imports in all the files in the end
use cached::SizedCache;
use clap::Parser;
use configs::{init_tracing, Opts};
use futures::StreamExt;
use near_lake_framework::near_indexer_primitives;
use tokio::sync::Mutex;

mod configs;
mod db_adapters;
mod metrics;
mod models;

#[macro_use]
extern crate lazy_static;

pub(crate) const LOGGING_PREFIX: &str = "indexer_balances";

const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);
const RETRY_COUNT: usize = 10;

#[derive(Debug, Default, Clone, Copy)]
pub struct BalanceDetails {
    pub non_staked: near_indexer_primitives::types::Balance,
    pub staked: near_indexer_primitives::types::Balance,
}

#[derive(Debug, Clone)]
pub struct AccountWithBalance {
    pub account_id: near_indexer_primitives::types::AccountId,
    pub balance: BalanceDetails,
}

pub type BalanceCache =
    std::sync::Arc<Mutex<SizedCache<near_indexer_primitives::types::AccountId, BalanceDetails>>>;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenv::dotenv().ok();

    let opts = Opts::parse();
    let _worker_guard = init_tracing(opts.debug)?;

    let pool = sqlx::PgPool::connect(&std::env::var("DATABASE_URL")?).await?;
    // TODO Error: while executing migrations: error returned from database: 1128 (HY000): Function 'near_indexer.GET_LOCK' is not defined
    // sqlx::migrate!().run(&pool).await?;

    let start_block_height = match opts.start_block_height {
        Some(x) => x,
        None => models::start_after_interruption(&pool).await?,
    };
    tracing::info!(
        target: LOGGING_PREFIX,
        "Indexer will start from block {}",
        start_block_height
    );

    // create a lake configuration with S3 information passed in as ENV vars
    let config = opts.to_lake_config(start_block_height).await;
    let (_lake_handle, stream) = near_lake_framework::streamer(config);

    // We want to prevent unnecessary RPC queries to find previous balance
    let balances_cache: BalanceCache =
        std::sync::Arc::new(Mutex::new(SizedCache::with_size(100_000)));

    let json_rpc_client = near_jsonrpc_client::JsonRpcClient::connect(&opts.near_archival_rpc_url);
    tokio::spawn(async move {
        let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
            .map(|streamer_message| {
                handle_streamer_message(streamer_message, &pool, &balances_cache, &json_rpc_client)
            })
            .buffer_unordered(1usize);

        let mut time_now = std::time::Instant::now();
        while let Some(handle_message) = handlers.next().await {
            match handle_message {
                Ok(block_height) => {
                    let elapsed = time_now.elapsed();
                    tracing::info!(
                        target: LOGGING_PREFIX,
                        "Elapsed time spent on block {}: {:.3?}",
                        block_height,
                        elapsed
                    );
                    time_now = std::time::Instant::now();
                }
                Err(e) => {
                    tracing::error!(target: LOGGING_PREFIX, "Stop indexing due to {}", e);
                    // we do not catch this error anywhere, this thread is just stopped with error,
                    // main thread continues serving metrics
                    anyhow::bail!(e)
                }
            }
        }
        Ok(()) // unreachable statement, loop above is endless
    });

    metrics::init_metrics_server(opts.port).await
}

async fn handle_streamer_message(
    streamer_message: near_indexer_primitives::StreamerMessage,
    pool: &sqlx::Pool<sqlx::Postgres>,
    balances_cache: &BalanceCache,
    json_rpc_client: &near_jsonrpc_client::JsonRpcClient,
) -> anyhow::Result<u64> {
    metrics::BLOCK_PROCESSED_TOTAL.inc();
    // Prometheus Gauge Metric type do not support u64
    // https://github.com/tikv/rust-prometheus/issues/470
    metrics::LATEST_BLOCK_HEIGHT.set(i64::try_from(streamer_message.block.header.height)?);

    db_adapters::balance_changes::store_balance_changes(
        pool,
        &streamer_message.shards,
        &streamer_message.block.header,
        balances_cache,
        json_rpc_client,
    )
    .await?;

    Ok(streamer_message.block.header.height)
}

'''
'''--- src/metrics.rs ---
use actix_web::{get, App, HttpServer, Responder};
use prometheus::{Encoder, IntCounter, IntGauge, Opts};

use crate::LOGGING_PREFIX;

type Result<T, E> = std::result::Result<T, E>;

fn try_create_int_counter(name: &str, help: &str) -> Result<IntCounter, prometheus::Error> {
    let opts = Opts::new(name, help);
    let counter = IntCounter::with_opts(opts)?;
    prometheus::register(Box::new(counter.clone()))?;
    Ok(counter)
}

fn try_create_int_gauge(name: &str, help: &str) -> Result<IntGauge, prometheus::Error> {
    let opts = Opts::new(name, help);
    let gauge = IntGauge::with_opts(opts)?;
    prometheus::register(Box::new(gauge.clone()))?;
    Ok(gauge)
}

lazy_static! {
    pub(crate) static ref BLOCK_PROCESSED_TOTAL: IntCounter = try_create_int_counter(
        "indexer_balances_total_blocks_processed",
        "Total number of blocks processed by indexer regardless of restarts. Used to calculate Block Processing Rate(BPS)"
    )
    .unwrap();
    pub(crate) static ref LATEST_BLOCK_HEIGHT: IntGauge = try_create_int_gauge(
        "indexer_balances_latest_block_height",
        "Last seen block height by indexer"
    )
    .unwrap();
}

#[get("/metrics")]
async fn get_metrics() -> impl Responder {
    let encoder = prometheus::TextEncoder::new();

    let mut buffer = Vec::new();
    if let Err(e) = encoder.encode(&prometheus::gather(), &mut buffer) {
        tracing::error!(target: LOGGING_PREFIX, "could not encode metrics: {}", e);
    };

    match String::from_utf8(buffer.clone()) {
        Ok(v) => v,
        Err(e) => {
            tracing::error!(
                target: LOGGING_PREFIX,
                "custom metrics could not be from_utf8'd: {}",
                e
            );
            String::default()
        }
    }
}

pub(crate) async fn init_metrics_server(port: u16) -> anyhow::Result<()> {
    tracing::info!(
        target: LOGGING_PREFIX,
        "Starting metrics server on http://0.0.0.0:{port}/metrics"
    );

    HttpServer::new(|| App::new().service(get_metrics))
        .bind(("0.0.0.0", port))?
        .run()
        .await
        .map_err(|e| anyhow::anyhow!("Error while executing HTTP Server: {}", e))
}

'''
'''--- src/models/balance_changes.rs ---
use bigdecimal::BigDecimal;
use sqlx::Arguments;

use crate::models::FieldCount;

#[derive(Debug, sqlx::FromRow, FieldCount)]
pub struct NearBalanceEvent {
    pub event_index: BigDecimal,
    pub block_timestamp: BigDecimal,
    pub block_height: BigDecimal,
    pub receipt_id: Option<String>,
    pub transaction_hash: Option<String>,
    pub affected_account_id: String,
    pub involved_account_id: Option<String>,
    pub direction: String,
    pub cause: String,
    pub status: String,
    pub delta_nonstaked_amount: BigDecimal,
    pub absolute_nonstaked_amount: BigDecimal,
    pub delta_staked_amount: BigDecimal,
    pub absolute_staked_amount: BigDecimal,
}

impl crate::models::SqlxMethods for NearBalanceEvent {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments) {
        args.add(&self.event_index);
        args.add(&self.block_timestamp);
        args.add(&self.block_height);
        args.add(&self.receipt_id);
        args.add(&self.transaction_hash);
        args.add(&self.affected_account_id);
        args.add(&self.involved_account_id);
        args.add(&self.direction);
        args.add(&self.cause);
        args.add(&self.status);
        args.add(&self.delta_nonstaked_amount);
        args.add(&self.absolute_nonstaked_amount);
        args.add(&self.delta_staked_amount);
        args.add(&self.absolute_staked_amount);
    }

    fn insert_query(count: usize) -> anyhow::Result<String> {
        Ok("INSERT INTO near_balance_events VALUES ".to_owned()
            + &crate::models::create_placeholders(count, NearBalanceEvent::field_count())?
            + " ON CONFLICT DO NOTHING")
    }

    fn name() -> String {
        "near_balance_events".to_string()
    }
}

'''
'''--- src/models/mod.rs ---
use std::fmt::Write;

use bigdecimal::BigDecimal;
use futures::future::try_join_all;
use near_lake_framework::near_indexer_primitives::views::ExecutionStatusView;

use num_traits::ToPrimitive;
use sqlx::{Arguments, Row};

pub(crate) use indexer_balances::FieldCount;
pub(crate) mod balance_changes;

pub trait FieldCount {
    /// Get the number of fields on a struct.
    fn field_count() -> usize;
}

pub trait SqlxMethods {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments);

    fn insert_query(count: usize) -> anyhow::Result<String>;

    fn name() -> String;
}

pub async fn chunked_insert<T: SqlxMethods + std::fmt::Debug>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    items: &[T],
    retry_count: usize,
) -> anyhow::Result<()> {
    let futures = items
        .chunks(crate::db_adapters::CHUNK_SIZE_FOR_BATCH_INSERT)
        .map(|items_part| insert_retry_or_panic(pool, items_part, retry_count));
    try_join_all(futures).await.map(|_| ())
}

async fn insert_retry_or_panic<T: SqlxMethods + std::fmt::Debug>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    items: &[T],
    retry_count: usize,
) -> anyhow::Result<()> {
    let mut interval = crate::INTERVAL;
    let mut retry_attempt = 0usize;
    let query = T::insert_query(items.len())?;

    loop {
        if retry_attempt == retry_count {
            return Err(anyhow::anyhow!(
                "Failed to perform query to database after {} attempts. Stop trying.",
                retry_count
            ));
        }
        retry_attempt += 1;

        let mut args = sqlx::postgres::PgArguments::default();
        for item in items {
            item.add_to_args(&mut args);
        }

        match sqlx::query_with(&query, args).execute(pool).await {
            Ok(_) => break,
            Err(async_error) => {
                tracing::error!(
                         target: crate::LOGGING_PREFIX,
                         "Error occurred during {}:\n{} were not stored. \n{:#?} \n Retrying in {} milliseconds...",
                         async_error,
                         &T::name(),
                         &items,
                         interval.as_millis(),
                     );
                tokio::time::sleep(interval).await;
                if interval < crate::MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
    Ok(())
}

pub async fn select_retry_or_panic(
    pool: &sqlx::Pool<sqlx::Postgres>,
    query: &str,
    substitution_items: &[String],
    retry_count: usize,
) -> anyhow::Result<Vec<sqlx::postgres::PgRow>> {
    let mut interval = crate::INTERVAL;
    let mut retry_attempt = 0usize;

    loop {
        if retry_attempt == retry_count {
            return Err(anyhow::anyhow!(
                "Failed to perform query to database after {} attempts. Stop trying.",
                retry_count
            ));
        }
        retry_attempt += 1;

        let mut args = sqlx::postgres::PgArguments::default();
        for item in substitution_items {
            args.add(item);
        }

        match sqlx::query_with(query, args).fetch_all(pool).await {
            Ok(res) => return Ok(res),
            Err(async_error) => {
                // todo we print here select with non-filled placeholders. It would be better to get the final select statement here
                tracing::error!(
                         target: crate::LOGGING_PREFIX,
                         "Error occurred during {}:\nFailed SELECT:\n{}\n Retrying in {} milliseconds...",
                         async_error,
                    query,
                         interval.as_millis(),
                     );
                tokio::time::sleep(interval).await;
                if interval < crate::MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
}

pub(crate) async fn start_after_interruption(
    pool: &sqlx::Pool<sqlx::Postgres>,
) -> anyhow::Result<u64> {
    let query = "SELECT max(block_height) FROM near_balance_events";

    let res = select_retry_or_panic(pool, query, &[], 10).await?;
    Ok(res
        .first()
        .map(|value| value.get::<BigDecimal, _>(0))
        .expect("`START_BLOCK_HEIGHT` should be provided when the DB is empty")
        .to_u64()
        .expect("height should be positive")
        // We start 1000 blocks before the latest block in the DB to be sure we haven't missed anything
        .saturating_sub(1000))
}

// Generates `($1, $2), ($3, $4)`
pub(crate) fn create_placeholders(
    mut items_count: usize,
    fields_count: usize,
) -> anyhow::Result<String> {
    if items_count < 1 {
        return Err(anyhow::anyhow!("At least 1 item expected"));
    }

    let mut start_num: usize = 1;
    let mut res = create_placeholder(&mut start_num, fields_count)?;
    items_count -= 1;
    while items_count > 0 {
        write!(
            res,
            ", {}",
            create_placeholder(&mut start_num, fields_count)?
        )?;
        items_count -= 1;
    }

    Ok(res)
}

// Generates `($1, $2, $3)`
pub(crate) fn create_placeholder(
    start_num: &mut usize,
    mut fields_count: usize,
) -> anyhow::Result<String> {
    if fields_count < 1 {
        return Err(anyhow::anyhow!("At least 1 field expected"));
    }
    let mut item = format!("(${}", start_num);
    *start_num += 1;
    fields_count -= 1;
    while fields_count > 0 {
        write!(item, ", ${}", start_num)?;
        *start_num += 1;
        fields_count -= 1;
    }
    item += ")";
    Ok(item)
}

pub(crate) trait PrintEnum {
    fn print(&self) -> &str;
}

impl PrintEnum for ExecutionStatusView {
    fn print(&self) -> &str {
        match self {
            ExecutionStatusView::Unknown => "UNKNOWN",
            ExecutionStatusView::Failure(_) => "FAILURE",
            ExecutionStatusView::SuccessValue(_) => "SUCCESS",
            ExecutionStatusView::SuccessReceiptId(_) => "SUCCESS",
        }
    }
}

pub(crate) enum Direction {
    Inbound,
    Outbound,
}

impl PrintEnum for Direction {
    fn print(&self) -> &str {
        match self {
            Direction::Inbound => "INBOUND",
            Direction::Outbound => "OUTBOUND",
        }
    }
}

pub(crate) enum Cause {
    ValidatorsReward,
    Transaction,
    Receipt,
    ContractReward,
}

impl PrintEnum for Cause {
    fn print(&self) -> &str {
        match self {
            Cause::ValidatorsReward => "VALIDATORS_REWARD",
            Cause::Transaction => "TRANSACTION",
            Cause::Receipt => "RECEIPT",
            Cause::ContractReward => "CONTRACT_REWARD",
        }
    }
}

'''