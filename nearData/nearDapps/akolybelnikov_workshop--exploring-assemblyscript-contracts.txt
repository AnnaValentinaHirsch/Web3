*GitHub Repository "akolybelnikov/workshop--exploring-assemblyscript-contracts"*

'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.spec.ts");

// // include tests for all folders under "/assembly" recursively since each one is a separate contract
// const fs = require('fs')
// const path = require('path')

// function readDirR(dir) {
//   return fs.statSync(dir).isDirectory()
//     ? [Array.prototype].concat(...fs.readdirSync(dir).map(f => readDirR(path.join(dir, f))))
//     : dir;
// }

// readDirR(path.resolve(__dirname, "assembly"))
//   .filter(dir => !dir.includes("/."))
//   .filter(dir => dir.includes("__tests__"))
//   .map(dir => module.exports.include.push(dir))

'''
'''--- asconfig.js ---
const fs = require("fs");
const path = require("path");
const util = require("util");

const compile = require("near-sdk-as/compiler").compile;
const asc = require("near-sdk-as/compiler").asc;

// main folder that includes all projects used in this workshop
const PROJECTS_DIR = "sample-projects";

/**
 * This file chooses one of two ways to compile AssemblyScript contracts
 *
 * - compileReadable() produces an unoptimized Wasm and WAT file for exploration
 * - compileOptimized() produces a highly optimized Wasm file to minimize on-chain execution costs
 */

const mode = process.argv.pop();

switch (mode) {
  case __filename:
    // we're using main package.json so build all contracts matching filters below

    scanProjects().map(compileOptimized);

    break;

  case process.cwd():
    // we're using a specific contract package.json
    // we know this because we've appended $(pwd) to yarn build for each contract in its local package.json

    compileReadable(`${process.cwd()}/main.ts`, { relPath: "../../../" });

    break;

  default:
    const projects = projectsNames();
    if (Object.keys(projects).includes(mode)) {
      compileOptimized(projects[mode], {});
    } else {
      throw new Error(
        `Unexpected condition in build process.\nLast argument was [${mode}]`
      );
    }
}

process.exit(0);

// ----------------------------------------------------------------------------
// Helper functions for the code above
// ----------------------------------------------------------------------------

/**
 * Compiles the most cost-effective Wasm file for deployment to NEAR Protocol
 * @param {string} fqPath
 * @param {object} options currently `relPath` to help direct files to the right output folder
 */
function compileOptimized(fqPath, { relPath = "" }) {
  const folder = path.dirname(fqPath).split("/").pop(); // 01.greeting
  const output = folder.split(".")[1]; // greeting

  reportProgress(folder, output, false);

  asc.main(
    [
      fqPath,
      "--binaryFile",
      `${relPath}out/${output}.wasm`,
      "-O3z", // optimize for size and speed
      "--validate", // validate the generated wasm module
      "--runPasses",
      "inlining-optimizing,dce", // inlines to optimize and removes deadcode
      "--measure", // shows compiler run time
    ],
    { verbose: false } // output the cli args passed to asc
  );

  reportFilesize(`${relPath}out/${output}.wasm`);
}

/**
 * Compiles the most readable Wasm file and WAT file for learning and readability
 * @param {string} fqPath
 * @param {object} options currently `relPath` to help direct files to the right output folder
 */
function compileReadable(fqPath, { relPath = "" }) {
  const folder = path.dirname(fqPath).split("/").pop(); // 01.greeting
  const output = folder.split(".")[1]; // greeting

  reportProgress(folder, output, true);

  compile(
    fqPath, // input file
    `out/${output}.wasm`, // output file
    [
      "--validate", // validate the generated wasm module
      "--measure", // shows compiler run time
      "--runPasses", "inlining-optimizing,dce", // inlines to optimize and removes deadcode
    ],
    { verbose: false } // output the cli args passed to asc
  );
}

/**
 * List all files in a directory recursively in a synchronous fashion
 * adapted from https://gist.github.com/kethinov/6658166#gistcomment-2109513
 * @param {string} dir top level to begin recursive descent through gstall subfolders
 */
function readDirR(dir) {
  return fs.statSync(dir).isDirectory()
    ? [].concat(...fs.readdirSync(dir).map((f) => readDirR(path.join(dir, f))))
    : dir;
}

/**
 * Formats compiler output nicely
 */
function reportProgress(folder, output, includeWAT) {
  const padding = includeWAT ? 0 : 20 - folder.length;
  console.log(
    `compiling contract [ ${folder}/main.ts${" ".padStart(
      padding
    )}] to [ out/${output}.${includeWAT ? "{wasm,wat}" : "wasm"} ] `
  );
}

function reportFilesize(fqPath) {
  const stats = fs.statSync(fqPath);
  console.log(`Filesize  : ${stats.size / 1000.0}kb`);
}

function scanProjects() {
  return readDirR(path.resolve(__dirname, "assembly")) // only AssemblyScript files
    .filter((fqPath) => fqPath.includes(PROJECTS_DIR)) // in the A.scavenger-hunt folder
    .filter((fqPath) => !fqPath.includes("cross-contract-calls")) // ignore cross contract calls
    .filter((fqPath) => fqPath.includes("main.ts")); // just the contract entry points
}

function projectsNames() {
  const projects = scanProjects();
  const re = new RegExp(`${PROJECTS_DIR}\/\\d{2}.([A-Za-z]*)`);
  return projects.reduce((result, path) => {
    let match = path.match(re);
    result[match[1]] = match.input;
    return result;
  }, {});
}

'''
'''--- assembly/A.sample-projects/01.greeting/__tests__/greeting.simulate.spec.js ---
const { Runtime } = require("near-sdk-as/runtime");

const WASM_FILE = __dirname + "/../out/greeting.wasm";

describe("Greeting ", () => {
  const users = ["alice", "bob", "carol"];
  const messages = ["awesomesauce!", "yashilsin!", "beleza!"];

  let runtime;
  let greeting;

  beforeAll(() => {
    runtime = new Runtime();
    greeting = runtime.newAccount("greeting", WASM_FILE);

    accounts = users
      .map((name) => runtime.newAccount(name))
      .reduce((acc, user) => {
        acc[user.account_id] = user;
        return acc;
      }, {});
  });

  afterEach(() => {
    greeting.state = {};
  });

  describe("View methods", () => {
    it("responds to showYouKnow()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "showYouKnow",
        },
      };

      const { result } = simulate(transaction);

      expectToFind("showYouKnow() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to sayHello()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "sayHello",
        },
      };

      const { result, data } = simulate(transaction);

      expect(data).toEqual("Hello!");
      expectToFind("sayHello() was called", {
        inArray: result.outcome.logs,
      });
    });

    describe("responds to getAllMessages()", () => {
      it("works with 0 messages", () => {
        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        const { result, data } = simulate(transaction);

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with 1 message", () => {
        sendMessage(accounts.alice, { message: messages[0] });

        const transaction = {
          signer: accounts.alice,
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const { result, data } = simulate(transaction);

        expectToFind("alice says awesomesauce!", {
          inArray: data,
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with many messages", () => {
        let expectedMessages = [];

        Object.keys(accounts).map((user, idx) => {
          let signer = accounts[user];
          let message = messages[idx];

          sendMessage(signer, { message });
          expectedMessages.push(`${signer.account_id} says ${message}`);
        });

        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const { result, data } = simulate(transaction);

        expectedMessages.map((message) => {
          expectToFind(message, {
            inArray: data,
          });
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });
    });
  });

  describe("Call methods", () => {
    it("responds to sayMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "sayMyName",
        },
      };

      const { data, result } = simulate(transaction);

      expect(data).toEqual(`Hello, ${accounts.alice.account_id}!`);
      expectToFind("sayMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyName",
        },
      };

      const { result } = simulate(transaction);

      // "c2VuZGVy" is " in base64
      // "YWxpY2U=" is "alice" in base64
      expect(result.state).toHaveProperty("sender", "alice");

      expectToFind("saveMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyMessage()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyMessage",
          params: { message: "awesomesauce" },
        },
      };

      const { data, result } = simulate(transaction);

      expect(data).toBeTruthy();

      // "bWVzc2FnZXM6Oi0x" is  in base64
      // "YWxpY2Ugc2F5cyBhd2Vzb21lc2F1Y2Uh" is "alice says awesomesauce" in base64
      expect(result.state).toHaveProperty(
        "messages::-1",
        "alice says awesomesauce"
      );

      expectToFind("saveMyMessage() was called", {
        inArray: result.outcome.logs,
      });
    });
  });

  describe("Cross-contract calls()", () => {
    test.todo("add cross contract call examples");
  });

  // ---------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------

  function sendMessage(signer, params) {
    const transaction = {
      signer,
      contract: greeting,
      method: {
        type: "view",
        name: "saveMyMessage",
        params,
      },
    };

    const { data } = simulate(transaction);

    expect(data).toBeTruthy();
  }

  function expectToFind(target, { inArray }) {
    if (inArray) {
      expect(inArray).toEqual(expect.arrayContaining([target]));
    }
  }

  function simulate({ signer, contract, method }, printResponse = false) {
    let response;

    if (signer) {
      response = signer.call_other(
        contract.account_id,
        method.name,
        method.params
      );
    } else {
      response = contract[method.type](method.name, method.params);
    }

    if (printResponse) {
      console.log("\n\n------ Near VM Response ------");
      console.log(JSON.stringify(response, null, 2));
    }

    return {
      data: response.return_data,
      error: response.err,
      result: response.result,
      results: response.results,
      calls: response.calls,
    };
  }

  function getContext() {
    return {
      input: "{}",
      output_data_receivers: [],
      prepaid_gas: 10 ** 15,
      attached_deposit: "0",
      is_view: false,
      block_index: 1,
      block_timestamp: 1585778575325000000,
      epoch_height: 1,
      storage_usage: 100,
      random_seed: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      current_account_id: "alice",
      signer_account_id: "alice",
      predecessor_account_id: "bob",
      account_balance: "1000",
      signer_account_pk: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      account_locked_balance: "10",
    };
  }
});

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/__tests__/cross-contract-calls.simulate.spec.js ---
const { Runtime, encodeBs64 } = require("near-sdk-as/runtime");
const path = require("path");

const sentencesWasm = path.join(__dirname, "/../out/sentences.wasm");
const wordsWasm = path.join(__dirname, "/../out/words.wasm");

let runtime, alice, sentences, words;

describe("cross contract calls", () => {
  beforeEach(() => {
    runtime = new Runtime();
    alice = runtime.newAccount("alice");
    sentences = runtime.newAccount("sentences", sentencesWasm);
    words = runtime.newAccount("words.examples", wordsWasm);
  });

  function addWord(hello) {
    return alice.call_other("sentences", "SetWord", {
      word: { text: "hello" },
    });
  }

  test("single promise", () => {
    let res = alice.call_other("sentences", "reverseWordOne");
    expect(res.return_data.text).toBe("elpmas");
  });

  test("promise + then with no arguments", () => {
    let res = alice.call_other("sentences", "reverseWordTwo");
    expect(res.return_data).toBe(true);
  });
  test("promise + then with arguments", () => {
    let res = alice.call_other("sentences", "reverseWordThree");
    expect(res.return_data).toBe(true);
  });

  test("add to storage", () => {
    addWord("hello");
    expect(sentences.storage_usage).toBeGreaterThan(0);
  });

  test("read from storage with default", () => {
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("DEFAULT");
    expect(sentences.state["word"]).toBe(undefined);
  });
  test("read from storage", () => {
    addWord("hello");
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("hello");
    expect(sentences.state["word"]).toStrictEqual(word);
  });

  test("setting state", () => {
    let state = { word: { lang: "en-us", text: "hello" } };
    sentences.state = state;
    sentences.reset();
    let { result } = addWord("hello");
    expect(result.state).toStrictEqual(state);
  });
});

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/asconfig.js ---
const compile = require("near-sdk-as/compiler").compile;

function compileContract(name) {
  console.log(`\ncompiling contract [ ${name}.ts ] to [ out/${name}.wasm ]`);

  compile(
    `assembly/${name}/main.ts`, // input file
    `out/${name}.wasm`, // output file
    [
      // add optional args here
      // "-O3z",
      "--debug", // Shows debug output
      "--measure", // Shows compiler run time
      "--validate", // Validate the generated wasm module
    ],
    {
      verbose: false, // Output the cli args passed to asc
    }
  );
}

compileContract("sentences");
compileContract("words");

'''