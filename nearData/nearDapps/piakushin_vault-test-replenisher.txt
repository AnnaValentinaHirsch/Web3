*GitHub Repository "piakushin/vault-test-replenisher"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
    - name: Build Docs
      run: |
        cargo doc --no-deps -p near-sdk
        cargo doc --no-deps
        echo "<meta http-equiv=\"refresh\" content=\"0; url=vault_test_replenisher\">" > target/doc/index.html
    - name: Deploy
      uses: JamesIves/github-pages-deploy-action@v4
      with:
        folder: target/doc

'''
'''--- Cargo.toml ---
[package]
name = "vault-test-replenisher"
version = "0.0.0"
authors = ["Pavel Iakushin <piakushin@roke.to>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "4.0"
near-contract-standards = "4.0"
serde = "1.0"

'''
'''--- README.md ---
# vault-test-replenisher
'''
'''--- src/interface/ft.rs ---
use near_sdk::{ext_contract, json_types::U128, AccountId};

#[ext_contract(ft)]
trait FungibleToken {
    fn ft_transfer_call(receiver_id: AccountId, amount: U128, msg: String);
}

'''
'''--- src/interface/ft_receiver.rs ---
use near_contract_standards::{
    fungible_token::receiver::FungibleTokenReceiver, non_fungible_token::TokenId,
};
use near_sdk::{
    ext_contract,
    json_types::U128,
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    serde_json::from_str,
    AccountId, Gas, Promise, PromiseOrValue,
};

use crate::{Contract, ContractExt};

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        log!(
            "ft_on_transfer: sender_id: {sender_id} amount: {} msg: {msg}",
            amount.0,
        );
        let req: Request = from_str(&msg).unwrap();

        Promise::new(req.vault).function_call(
            "add_replenishment_callback".to_owned(),
            req.args.into_bytes(),
            1,
            Gas::ONE_TERA * 100,
        );

        PromiseOrValue::Value(U128(0))
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct Request {
    vault: AccountId,
    args: String,
}

#[ext_contract(vault)]
trait Vault {
    fn add_replenishment_callback(
        &mut self,
        nft_contract_id: AccountId,
        nft_id: TokenId,
        callback: String,
        args: String,
    );
}

'''
'''--- src/interface/mod.rs ---
pub mod ft;
mod ft_receiver;

'''
'''--- src/lib.rs ---
mod interface;

use interface::ft::ft;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::U128,
    log, near_bindgen, Gas,
};

pub const NEAR: u128 = 10u128.pow(24);

#[near_bindgen]
#[derive(Debug, BorshSerialize, BorshDeserialize)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[init]
    #[private]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {}
    }

    pub fn withdraw_call(msg: String) {
        log!("prepaid gas: {}", env::prepaid_gas().0);
        log!("replenisher withdraw call: msg: {}", msg);
        let receiver_id = env::predecessor_account_id();
        let amount = U128(NEAR);
        ft::ext("wrap.testnet".parse().unwrap())
            .with_attached_deposit(1)
            .with_static_gas(Gas::ONE_TERA * 260)
            .ft_transfer_call(receiver_id, amount, msg);
    }
}

impl Default for Contract {
    fn default() -> Self {
        Self::new()
    }
}

'''