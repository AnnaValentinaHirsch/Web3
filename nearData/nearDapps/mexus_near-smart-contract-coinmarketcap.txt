*GitHub Repository "mexus/near-smart-contract-coinmarketcap"*

'''--- Cargo.toml ---
[package]
name = "near-smart-contract-coinmarketcap"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

static_assertions = "1"

[dev-dependencies]
quickcheck = "1.0.3"
quickcheck_macros = "1.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
# What's that

That are my first steps in creating blockchain smart-contracts using the
[NEAR](https://near.org/) protocol.

# Where is it?

The contract is currently deployed at `coinmarketcap.mexus.testnet`, calculating
average BTC price. To get the current average (amongst the latest 5 values),
replace ACCOUNT_NAME with you account on the testnet and run the following:
```shell
$ near view coinmarketcap.mexus.testnet get_average --accountId ACCOUNT_NAME
```

As of the 20th of February, 2022, the contract is populated with a BTC price
obtained from the [CoinMarketCap](https://coinmarketcap.com/) on a hourly basis.

# How to deploy and test

Please replace the `ACCOUNT_NAME` placeholder with your (testnet) account.

0. Make sure you've got `wasm32-unknown-unknown` target installed:
```shell
$ rustup target add wasm32-unknown-unknown
```
1. Build
```shell
$ cargo build --target wasm32-unknown-unknown --release
```
2. Deploy
```shell
$ near dev-deploy -f --wasmFile target/wasm32-unknown-unknown/release/near_smart_contract_coinmarketcap.wasm
```
3. Add prices
```shell
$ . neardev/dev-account.env # This loads a CONTRACT_NAME variable
$ near call "$CONTRACT_NAME" record_price --accountId "$CONTRACT_NAME" --args '{"price": 1}'
$ near call "$CONTRACT_NAME" record_price --accountId "$CONTRACT_NAME" --args '{"price": 2}'
$ near call "$CONTRACT_NAME" record_price --accountId "$CONTRACT_NAME" --args '{"price": 3}'
$ near call "$CONTRACT_NAME" record_price --accountId "$CONTRACT_NAME" --args '{"price": 4}'
$ near call "$CONTRACT_NAME" record_price --accountId "$CONTRACT_NAME" --args '{"price": 5}'
```
4. Verify that the average is something about `3.0`:
```shell
$ near view "$CONTRACT_NAME" get_average --accountId "$CONTRACT_NAME"
```
5. You can also view the average from any account:
```shell
$ near view "$CONTRACT_NAME" get_average --accountId ACCOUNT_NAME
```

'''
'''--- src/fifo.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

/// A fixed-length FIFO queue.
#[derive(Debug, BorshDeserialize, BorshSerialize)]
pub struct Fifo<T, const LENGTH: usize> {
    array: [T; LENGTH],
    position: usize,
}

impl<T, const LENGTH: usize> Default for Fifo<T, LENGTH>
where
    T: Default + Copy,
{
    fn default() -> Self {
        if LENGTH == 0 {
            near_sdk::env::panic(b"Zero-length FIFO queue are not supported");
        } else if LENGTH > usize::MAX / 2 {
            near_sdk::env::panic(b"Length of the queue is way too big");
        }
        Self {
            array: [T::default(); LENGTH],
            position: 0,
        }
    }
}

impl<T, const LENGTH: usize> Fifo<T, LENGTH> {
    /// Creates a queue of size `LENGTH`, filled with `T::default()`.
    pub fn new() -> Self
    where
        T: Default + Copy,
    {
        Self::default()
    }

    /// Adds an item to the queue.
    pub fn push(&mut self, item: T) {
        // Since `position` is lesser than `LENGTH`, and `LENGTH <=
        // usize::MAX/2`, `position + LENGTH` never overflows.
        let insert_position = (self.position + LENGTH) % LENGTH;
        // `position + 1`, hence, doesn't overflow either.
        self.position = (self.position + 1) % LENGTH;
        self.array[insert_position] = item;
    }

    /// Returns an iterator over the queued items.
    pub fn iter(&self) -> FifoIterator<'_, T, LENGTH> {
        FifoIterator {
            array: &self.array,
            start_position: self.position,
            count: LENGTH,
        }
    }
}

impl<'a, T: 'a, const LENGTH: usize> IntoIterator for &'a Fifo<T, LENGTH> {
    type Item = &'a T;

    type IntoIter = FifoIterator<'a, T, LENGTH>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

/// An iterator over the queued values.
// TODO: the iterator could have been implemented alternatively as a chained
// iterator over two consecutive slices.
pub struct FifoIterator<'a, T, const LENGTH: usize> {
    array: &'a [T; LENGTH],
    start_position: usize,
    count: usize,
}

impl<'a, T: 'a, const LENGTH: usize> Iterator for FifoIterator<'a, T, LENGTH> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.count = self.count.checked_sub(1)?;
        let item = &self.array[self.start_position % LENGTH];
        self.start_position += 1;
        Some(item)
    }
}

#[cfg(test)]
mod test {
    use std::collections::VecDeque;

    use super::*;
    use quickcheck::TestResult;
    use quickcheck_macros::quickcheck;

    #[test]
    fn simple_test() {
        let mut queue = Fifo::<_, 5>::new();
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 0, 0]
        );

        queue.push(100);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 0, 100]
        );

        queue.push(200);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 100, 200]
        );

        queue.push(300);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 100, 200, 300]
        );

        queue.push(400);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 100, 200, 300, 400]
        );

        queue.push(500);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![100, 200, 300, 400, 500]
        );
    }

    #[quickcheck]
    fn extensive_test(input: Vec<u8>) -> TestResult {
        if input.len() < 5 {
            return TestResult::discard();
        }

        let mut reference_queue = VecDeque::with_capacity(5);
        let mut testing_queue = Fifo::<u8, 5>::new();
        for item in input {
            if reference_queue.len() >= 5 {
                reference_queue.pop_front();
            }
            reference_queue.push_back(item);
            testing_queue.push(item);
        }

        let reference: Vec<_> = reference_queue.into_iter().collect();
        let testing: Vec<_> = testing_queue.iter().copied().collect();

        assert_eq!(reference, testing);

        TestResult::passed()
    }
}

'''
'''--- src/lib.rs ---
//! Storing historical price data.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod fifo;

const HISTORY_DEPTH: usize = 5;

/// A contract that's able to store a historical data and making an average out
/// of it.
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct PriceHistory {
    price_history: fifo::Fifo<f64, HISTORY_DEPTH>,
    recorded: u16,
}

#[near_bindgen]
impl PriceHistory {
    /// Returns the average price.
    ///
    /// # Panics
    ///
    /// Will panic when not enough historical data has been collected.
    pub fn get_average(&self) -> f64 {
        static_assertions::const_assert_ne!(HISTORY_DEPTH, 0);
        if usize::from(self.recorded) != HISTORY_DEPTH {
            env::panic(b"Not enough historical data has been collected yet")
        }
        let sum: f64 = self.price_history.iter().sum();
        sum / HISTORY_DEPTH as f64
    }

    /// Adds the provided `price` to the storage.
    ///
    /// # Panics
    ///
    /// Will panic when called not from the account which was used to deployed
    /// the contract.
    pub fn record_price(&mut self, price: f64) {
        if env::signer_account_id() != env::current_account_id() {
            // Prevent others from adding possibly malicious records.
            env::panic(b"Sorry, you are not allowed to record a price")
        }
        if usize::from(self.recorded) < HISTORY_DEPTH {
            // Hint: no overflow check required until the const assert holds
            // true.
            static_assertions::const_assert_ne!(HISTORY_DEPTH, usize::MAX);
            self.recorded += 1;
        }
        self.price_history.push(price)
    }

    /// Returns the depth of the recorded history.
    pub fn depth_so_far(&self) -> usize {
        usize::from(self.recorded)
    }

    /// Returns the amount of required historical data to calculate the average.
    pub fn required_depth(&self) -> usize {
        HISTORY_DEPTH
    }

    /// Forgets the history.
    pub fn reset(&mut self) {
        self.recorded = 0;
        env::log(b"History has been reset");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // Hint: copied from one of NEAR SDK examples.
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn record() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut counter = PriceHistory::default();

        for price in [1., 2., 3., 4., 5.] {
            counter.record_price(price);
        }

        let expected = 3.;
        assert!((counter.get_average() - expected).abs() < 1e-5);
    }

    #[test]
    #[should_panic]
    fn empty() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let counter = PriceHistory::default();
        counter.get_average();
    }
}

'''