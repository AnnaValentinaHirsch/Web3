*GitHub Repository "luciotato/create-contract-cli"*

'''--- .eslintrc.json ---
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 12,
    "sourceType": "module"
  },
  "ignorePatterns": [ "out/**", "dist/**","*.js","z-old/**" ] ,
  "plugins": [
    "@typescript-eslint"
  ],
  "rules": {
    "quotes": ["off"],
    "indent": ["error", 4],
    "no-comma-dangle": ["off"],
    "@typescript-eslint/no-inferrable-types": ["off"],
    "@typescript-eslint/ban-ts-comment": ["off"],
    "no-constant-condition": ["error", { "checkLoops": false }],
    "space-before-function-paren": ["error", "never"],
    "@typescript-eslint/no-shadow": ["error"]
  }
}

'''
'''--- .vscode/launch.json ---
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Debug Test",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "program": "${workspaceFolder}/dist/test/test"
        }
    ]
}
'''
'''--- .vscode/tasks.json ---
{
	"version": "2.0.0",
	"tasks": [
		{
			"type": "typescript",
			"tsconfig": "tsconfig.json",
			"problemMatcher": {
				"owner": "typescript",
				"fileLocation": "relative",
				"pattern": {
					"regexp": "^(.*):(\\d+):(\\d+).*(warning|error)\\s+(.*)$",
					"file": 1,
					"location": 2,
					"severity": 3,
					"code": 4,
					"message": 5
				},
			},
			"group": {
				"kind": "build",
				"isDefault": true,
			},
			"label": "tsc: build - tsconfig.json"
		}
	]
}
'''
'''--- README.md ---

## CREATE-CONTRACT-CLI tool for NEAR Contracts

### What's this tool for?

This tool can create a cli for any NEAR smart contract by parsing the contract code

It works for any rust-coded contract

[![asciicast](https://asciinema.org/a/364018.svg)](https://asciinema.org/a/364018)

For example, let's create a cli for the staking-pool. 
I have a staking-pool deployed @luckystaker.stakehouse.betanet

Let's create a cli to manage that contract from my account

`> create-contract-cli --help`

`> create-contract-cli lucky core-contracts/staking-pool --contractName luckystaker.stakehouse.betanet --accountId luciotato.betanet`

```
Creating dir lucky-cli......................................: OK
Parsing core-contracts/staking-pool/src/lib.rs..............: OK
Producing lucky-cli/ContractAPI.js..........................: OK
Completing from create-contract-cli/model...................: OK
```

and.... **done!**

We just parsed `core-contracts/staking-pool/scr/lib.rs` and created a new cli called "lucky" with commands to control a staking-pool contract

The new cli is at ./lucky-cli and its nickname is "lucky"

To see what the new cli can do type `lucky --help | more`

### Will it work for my contract?

Yes! Just point it to your contract code!

`> create-contract-cli myprecious myrepo/mycontract --contractName mycontract.accountId.near --accountId my.accountId.near`

### Shut up and take my money! How do I install it?

```
> git clone https://github.com/luciotato/create-contract-cli
> cd create-contract-cli
> npm link
> cd ..
> create-contract-cli --help
```

### Prerequisites:

* near-cli
* nodejs v10+

To install prerequisites:

You can use npm to install near-cli

`> npm install -g near-cli`

and you can check your node version

```
> node -v
v12.x.y
```

If your version is <v10, you must install nodejs from [nodejs.org](nodejs.org) (windows/linux), 
or use [nvm](https://github.com/nvm-sh/nvm) (linux) to install node stable

`> nvm install stable`

### Generated cli-tool Usage:

#### JSON parameteres 

The cli parses command line arguments to create JSON parameters for the contract. You must:

* Put spaces around  { and }

        lucky withdraw { amount:10 }

* Numbers are by default in NEAR, so they'll be converted to U128 yoctos before passing them to the contract. This means `lucky withdraw { amount: 10 }` will be converted to `near call lucky.near withdraw {amount:"100000000000000000000"}`

* You can also use "**N**" to expressely indicate the amount is in NEAR

        lucky withdraw { amount:10N }

* In some uncommon cases, you can use "**y**" to indicate you're stating yoctos, and the number will just be enclosed in quotes (It's uncommon to use yoctos to express parameters)

        lucky witdraw { amount:6500000000000000000000y } 
        => call lucky.near withdraw {\"amount\":\"6500000000000000000000\"}

* Because the default denomination is NEAR, you can state numbers with a decimal point and they will be converted to U128 Yoctos, that means multiplied by 1e24 and enclosed in quotes, so `amount:0.065` becomes `"amount":"6500000000000000000000"`. This is the default parameter convention

        lucky witdraw { amount: 0.065 } 
        => call lucky.near withdraw {\"amount\":\"6500000000000000000000\"}

* And finally, you can use "**i**" to indicate the number is an integer and should be sent as it is, not converted or enclosed in quotes

        lucky get_accounts { from_index: 1i, limit: 10i } 
        => view lucky.near get_accounts {\"from_index\":1,\"limit\":10}

* Note: Commas are optional

        lucky get_accounts { from_index:1i limit:10i }
        => view lucky.near get_accounts {\"from_index\":1,\"limit\":10}

### More Conversion Examples:

--- 

`lucky stake { amount:10 }` or `lucky stake { amount:10N }`

both execute:
```
near call lucky.near stake "{\"amount\":\"1000000000000000000000000\"}"`
```
---

`lucky stake { amount:0.0005 }`<br>
or `lucky stake { amount:0.0005N }`<br>
or `lucky stake { amount:500000000000000000000y }`<br>

all of them execute:
```
near call luckystaker.near stake "{\"amount\":\"500000000000000000000\"}"`
```

---

`lucky get_accounts { from_index:1i limit: 10i }`

executes:
```
near view luckystaker.near get_accounts "{\"from_index\":1,\"limit\":10}"
```

## Caveats

* Should work for any contract

... but Rust is specially hard to parse, if the tool can't parse your `lib.rs`, please report the issue [here](https://github.com/luciotato/create-contract-cli/issues) including some failing `lib.rs` sample code

* Should work on Windows

## Road Map

* Parse AssemblyScript contracts

'''
'''--- bin/cli.js ---
#!/usr/bin/env node
require("../dist/main/create-contract-cli.js")

'''
'''--- build.js ---
const fs = require("fs")
const path= require("path")
const child_process= require("child_process")

const execSync=child_process.execSync

function fromDir (startPath, filter, callback) {
    // console.log('Starting from dir '+startPath+'/');

    if (!fs.existsSync(startPath)) {
        console.log("no dir ", startPath)
        return
    }

    var files = fs.readdirSync(startPath)
    for (var i = 0; i < files.length; i++) {
        var filename = path.join(startPath, files[i])
        var stat = fs.lstatSync(filename)
        if (stat.isDirectory()) {
            fromDir(filename, filter, callback) // recurse
        } else if (filter.test(filename)) callback(filename)
    };
};

function addDotJsToLocalImports (filename) {
    var buf = fs.readFileSync(filename)
    const replaced = buf.toString().replace(/(import .* from\s+['"])(?!.*\.js['"])(\..*?)(?=['"])/g, '$1$2.js')
    if (replaced !== buf.toString()) {
        fs.writeFileSync(filename, replaced)
        console.log("fixed imports at " + filename)
    }
}

// ---------------------
// ---START BUILD TASKS
// ---------------------

execSync("npx tsc --build -verbose", { stdio: 'inherit' })

// add .js to ts-generated import-commands so the generated ES6 code works with node ES2020 type:module
// see: https://github.com/microsoft/TypeScript/issues/16577
fromDir("./dist", /\.js$/, addDotJsToLocalImports)

'''
'''--- dist/lib/Lexer/Lexer.js ---
"use strict";
// The main class in this module is the Tokenizer
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = exports.Token = exports.TokenCode = void 0;
// The Lexer translates code (a string or a file) into a list of anottated tokens ready to be parsed
// --eslint no-constant-condition: ["error", { "checkLoops": false }]*/
require("../util/String.extensions.js");
const logger = require("../util/logger.js");
const UTF8FileReader_js_1 = require("../util/UTF8FileReader.js");
var TokenCode;
(function (TokenCode) {
    TokenCode[TokenCode["BOF"] = 0] = "BOF";
    TokenCode[TokenCode["EOF"] = 1] = "EOF";
    TokenCode[TokenCode["NEWLINE"] = 2] = "NEWLINE";
    TokenCode[TokenCode["WHITESPACE"] = 3] = "WHITESPACE";
    TokenCode[TokenCode["COMMENT"] = 4] = "COMMENT";
    TokenCode[TokenCode["ATTRIBUTE"] = 5] = "ATTRIBUTE";
    TokenCode[TokenCode["PUNCTUATION"] = 6] = "PUNCTUATION";
    TokenCode[TokenCode["WORD"] = 7] = "WORD";
    TokenCode[TokenCode["OPERATOR"] = 8] = "OPERATOR";
    TokenCode[TokenCode["NUMBER"] = 9] = "NUMBER";
    TokenCode[TokenCode["HEXANUMBER"] = 10] = "HEXANUMBER";
    TokenCode[TokenCode["BINARYNUMBER"] = 11] = "BINARYNUMBER";
    TokenCode[TokenCode["LITERAL_STRING"] = 12] = "LITERAL_STRING";
    TokenCode[TokenCode["LITERAL_OBJECT"] = 13] = "LITERAL_OBJECT";
})(TokenCode = exports.TokenCode || (exports.TokenCode = {}));
// ----------------------
// The Token Class
//= ==============
// Each token instance has:
// -a "type" e.g.: NEWLINE,EOF, when the token is a special char
// -a "value": the parsed text
// -the column in the source line in which the token appears
// class Token
// constructor
class Token {
    constructor(owner, tokenCode, tokenText, line, column) {
        this.owner = owner;
        this.tokenCode = tokenCode;
        this.value = tokenText;
        this.line = line;
        this.col = column;
    }
    // ---------------------------
    isSpace() { return this.tokenCode == TokenCode.NEWLINE || this.tokenCode == TokenCode.WHITESPACE; }
    isEOF() { return this.tokenCode == TokenCode.EOF; }
    // ---------------------------
    toString() {
        const code = TokenCode[this.tokenCode];
        if (this.tokenCode == TokenCode.BOF ||
            this.tokenCode == TokenCode.EOF ||
            this.tokenCode == TokenCode.WHITESPACE ||
            this.tokenCode == TokenCode.NEWLINE) {
            return '(' + code + ')';
        }
        let v = this.value;
        if (v && v.length > 20)
            v = v.slice(0, 17) + '...';
        return '(' + code + ' ' + v + ')';
    }
    posToString() {
        return `${this.owner.filename}:${this.line}:${(this.col)}`;
    }
    toStringDebug() {
        return `${this.line}:${(this.col)} ${this.toString()}`;
    }
}
exports.Token = Token;
//= ==============
// The Lexer Class
//= ==============
class Lexer {
    /**
     * Init all the options for the tokenizer
     * @param options
     */
    constructor() {
        // this.project = project
        this.readString = ''; // data already read from the file 
        this.startedFromString = false;
        this.curReadLine = 1;
        this.curReadCol = 1;
        this.autoSkipWhitespaceAndNewLine = true;
        this.semiNotRequired = false;
        // use same options as compiler
        this.BOFToken = new Token(this, TokenCode.BOF, '', 0, 0);
        this.EOFToken = new Token(this, TokenCode.EOF, '', 0, 0);
        // stringInterpolationChar starts for every file the same: "#"
        // can be changed in-file with `tokenizer options` directive
        // .hardError = null # stores most significative (deepest) error, when parsing fails
        this.hardError = null;
    }
    /**
         * MAIN LEXER FUNCTION: recognizeToken
         * In this function you define the rules to tokenize the input stream
         * the data to analize is at: this.readString
         * this.readString have the next 4Kb from the input stream
         *
         * if the token is invalid, throw an error, else return [TokenCode, endPos]
         * where endPos is the position after the last character recognized
         *
         * */
    recognizeToken() {
        // fastest recognition based on 1st char
        const char = this.readString.charAt(0);
        const twoChars = this.readString.slice(0, 2);
        // based on 2-chars
        switch (twoChars) {
            case "//": {
                const endOfComment = this.untilNewLine();
                return [TokenCode.COMMENT, endOfComment];
            }
            case "#[": {
                const endPos = this.findRead("]");
                return [TokenCode.ATTRIBUTE, endPos + 1];
            }
            case '\r\n': {
                return [TokenCode.NEWLINE, 2];
            }
            // rust namespace separator
            case '::': {
                return [TokenCode.PUNCTUATION, 2];
            }
            // rust range separator
            case '..': {
                return [TokenCode.OPERATOR, 2];
            }
            // rust lifetime open
            case "<'": {
                return [TokenCode.PUNCTUATION, 2];
            }
            // rust match pair: X => Y
            case '=>': {
                return [TokenCode.PUNCTUATION, 2];
            }
            // /* multiline comment
            case '/*': {
                const endPos = this.findRead("*/");
                return [TokenCode.COMMENT, endPos + 2]; // includes opening /* and closing */
            }
            // rust 2-char special LITERAL_STRINGs
            // b"..." , r"..."
            case 'b"': { // byte literal string
                const quoteChar = '"';
                const endQuotePos = this.untilUnescaped(quoteChar, 2);
                // return new Token 'LITERAL_STRING'
                return [TokenCode.LITERAL_STRING, endQuotePos + 1]; // includes opening (b") and closing quotes (")
            }
            // '0x' => Hexadecimal number, can inlude u64, u128
            case '0x': {
                const endPos = this.whileRanges('a-fA-F0-9u', 2);
                return [TokenCode.HEXANUMBER, endPos];
            }
            // '0b' => Binary number, , can inlude u64, u128
            case '0b': {
                const endPos = this.whileRanges('a-fA-F0-9u', 2);
                return [TokenCode.BINARYNUMBER, endPos];
            }
        }
        // based on single-char
        if (char == '\n') {
            return [TokenCode.NEWLINE, 1];
        }
        // check for NUMBER,, can inlude u64, u128
        if (char >= '0' && char <= '9') {
            let endPos = this.whileRanges('0-9._u');
            while (this.readString.charAt(endPos - 1) == '.')
                endPos--; // can't end in '\.*'
            return [TokenCode.NUMBER, endPos];
        }
        if (Lexer.WHITESPACE_CHARS.includes(char)) {
            const endPos = this.whileRanges(Lexer.WHITESPACE_CHARS);
            return [TokenCode.WHITESPACE, endPos];
        }
        const threeChars = this.readString.slice(0, 3);
        if (threeChars == 'r#"') { // raw literal string
            const endQuotePos = this.untilUnescaped('"#', 3);
            // return new Token 'LITERAL_STRING'
            return [TokenCode.LITERAL_STRING, endQuotePos + 2]; // includes opening (r#") and closing quotes ("#) and \n if multiline
        }
        // rust 3-char assignment operators
        if (['<<=', '>>='].includes(threeChars)) {
            return [TokenCode.OPERATOR, 3];
        }
        // rust 3-char operators
        if (['...', '..='].includes(threeChars)) {
            return [TokenCode.OPERATOR, 3];
        }
        // rust 2-char assignment operators
        if (['*=', '+=', '-=', '/=', '^=', '|=', '%=', '&='].includes(twoChars)) {
            return [TokenCode.OPERATOR, 2];
        }
        // rust 2-char operators -- note: >> could be an operator or it could be <Hashmap<String>>
        if (['!=', '&&', '||', '->', '..', '<=', '==', '>='].includes(twoChars)) {
            return [TokenCode.OPERATOR, 2];
        }
        // assignment operator
        if (char == '=') {
            return [TokenCode.OPERATOR, 1];
        }
        // rust 1-char operators
        if ('!%&*+-/<>@^|?'.includes(char)) {
            return [TokenCode.OPERATOR, 1];
        }
        // Punctuation: () [] {} ; , . :
        if ('()[]{};,.:'.includes(char)) {
            return [TokenCode.PUNCTUATION, 1];
        }
        // String Literals can be either single or double quoted.
        // ['STRING', /^'(?:[^'\\]|\\.)*'/],
        if (char == "'" || char == '"') {
            const quoteChar = char;
            const endQuotePos = this.untilUnescaped(quoteChar, 1);
            // return new Token 'LITERAL_STRING'
            return [TokenCode.LITERAL_STRING, endQuotePos + 1]; // includes opening and closing quotes
        }
        // Regex tokens are regular expressions. The javascript producer, just passes the raw regex to JavaScript.
        // ['REGEX', /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/],
        // if chunk.startsWith('/') and chunk.indexOf('/',1) isnt -1
        // if (chunk.startsWith('/') && chunk.indexOf('/', 1) !== -1) {
        //    //var regexpContents = PMREX.quotedContent(chunk)
        //    var regexpContents = PMREX.quotedContent(chunk)
        //    //var regexpExpr:string = chunk.slice(0,regexpContents.length+2) //include quote-chars: / & /
        //    var regexpExpr = chunk.slice(0, regexpContents.length + 2)
        //    //var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length),"gimy")
        //    var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length), 'gimy')
        //    //return new Token('REGEX', regexpExpr & regexpFlags)
        //    return new Token('REGEX', regexpExpr + regexpFlags)
        // }
        //* *Numbers** can be either in hex format (like `0xa5b`) or decimal/scientific format (`10`, `3.14159`, or `10.02e23`).
        // As in js, all numbers are floating point.
        // ['NUMBER',/^0x[a-f0-9]+/i ],
        // ['NUMBER',/^[0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?/i],
        // Identifiers (generally variable names), must start with a letter, `$`, or underscore.
        // Subsequent characters can also be numbers. Unicode characters are supported in variable names.
        // ['IDENTIFIER',/^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/] ]
        // a IDENTIFIER starts with A-Z a-z (a unicode codepoint), $ or _
        // note we checked for numbers above
        const endIdentifier = this.whileRanges('A-Za-z0-9\x7F-\xFF$_');
        if (endIdentifier) {
            return [TokenCode.WORD, endIdentifier];
        }
        throw new Error("unrecognized token");
    }
    /**
     * helper function to get comments attached after the semicolon in the same line of a statement
     * @param separator
     */
    getAttachedCommentAfter(separator) {
        this.savePosition();
        this.skipWhiteSpace();
        if (this.token.value == separator) {
            this.skipWhiteSpace();
            if (this.token.tokenCode == TokenCode.COMMENT) {
                // comment after the separator, on the same line (no NEWLINE)
                this.discardSavedPosition();
                return this.token.value;
            }
        }
        // if ;//comment not found - rewind
        this.restoreSavedPosition();
    }
    /**
     * helper function consume comments, return string
     */
    consumeCommentsAndAttr(storeInList) {
        while (this.token.tokenCode == TokenCode.COMMENT || this.token.tokenCode == TokenCode.ATTRIBUTE) {
            storeInList.push(this.token.value);
            this.advance();
        }
    }
    // --------
    initTokenList() {
        this.savedPositions = [];
        this.cachedTokens = [];
        this.token = this.BOFToken;
        if (this.autoSkipWhitespaceAndNewLine) {
            this.advance();
            this.skipWhiteSpaceAndNewLine();
        }
    }
    // ---------------------------
    startFromString(code) {
        this.readString = code;
        this.startedFromString = true;
        this.initTokenList();
    }
    get moreToRead() {
        return !this.startedFromString && this.file && this.file.isOpen;
    }
    // ---------------------------
    /**
     * attach a file as input for the tokenizer
     * @param filename
     */
    openFile(filename) {
        this.filename = filename;
        this.file = new UTF8FileReader_js_1.UTF8FileReader();
        this.file.open(filename, 8 * 1024);
        this.startedFromString = false;
        // read the first chunk
        this.readString = this.file.readChunk();
        // start with Token:BOF
        this.initTokenList();
    }
    // ---------------------------
    savePosition() {
        this.savedPositions.push(this.token);
    }
    // ---------------------------
    discardSavedPosition() {
        this.savedPositions.pop(); // discard saved pos
    }
    // ---------------------------
    /**
     * rewind the token stream to the last saved position
     * */
    restoreSavedPosition() {
        if (this.savedPositions.length == 0)
            throw new Error("restoreSavedPosition(): this.savedPositions.length==0");
        this.token = this.savedPositions.pop(); // go back to saved position
    }
    // ------------------------------
    prevToken(n = 1) {
        // veo si el actual está en el cache
        const inxInCached = this.indexInCached();
        if (inxInCached <= n - 1) { // si n=1 y esta en el index 0 (o no está), no se puede
            throw new Error("Cant read previous [current - " + n + "] token");
        }
        // return tok at [current-n]
        return this.cachedTokens[inxInCached - n];
    }
    // ---------------------------
    rewind(n = 1) {
        const prev = this.prevToken(n);
        // do rewind
        this.token = prev;
        logger.debug('<<REW -' + n, this.token.toStringDebug());
    }
    // ---------------------------
    cacheOneMoreToken() {
        const newToken = this.readNewToken();
        this.cachedTokens.push(newToken);
        return newToken;
    }
    // ---------------------------
    indexInCached() {
        // search if current token is in cached (from the last one to the first)
        for (let inx = this.cachedTokens.length - 1; inx >= 0; inx--) {
            const t = this.cachedTokens[inx];
            if (t.line == this.token.line && t.col == this.token.col)
                return inx;
        }
        return -1;
    }
    // ---------------------------
    /**
     * peek next token
     * */
    nextToken() {
        // veo si está en el cache
        const inxInCached = this.indexInCached();
        if (inxInCached > 0 && inxInCached + 1 < this.cachedTokens.length) {
            return this.cachedTokens[inxInCached + 1];
        }
        // si no está agrego uno al cache y retorno ese
        return this.cacheOneMoreToken();
    }
    // ---------------------------
    skipWhiteSpaceAndNewLine() {
        // skip newlines & whitespace
        while (this.token.tokenCode == TokenCode.NEWLINE || this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken();
        }
    }
    // ---------------------------
    skipNewLines() {
        // skip newlines
        while (this.token.tokenCode == TokenCode.NEWLINE) {
            this.token = this.nextToken();
        }
    }
    // ---------------------------
    skipWhiteSpace() {
        // skip whitespace
        while (this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken();
        }
    }
    // ---------------------------
    advance() {
        if (this.token.tokenCode == TokenCode.EOF)
            throw ("asked for a token after EOF");
        // set next as current
        this.token = this.nextToken();
        if (this.autoSkipWhitespaceAndNewLine)
            this.skipWhiteSpaceAndNewLine();
        return this.token.value;
    }
    // --------------------------
    curPosString() {
        return this.curReadLine + ':' + this.curReadCol;
    }
    // --------------------------
    consumeStringFromRead(endPos) {
        const result = this.readString.slice(0, endPos);
        this.readString = this.readString.slice(endPos);
        if (this.moreToRead && this.readString.length < 8 * 1024) {
            this.readString += this.file.readChunk();
        }
        return result;
    }
    // --------------------------
    /**
     * returns position in this.readString or this.readString.length if not found
     * @param what what to search
     */
    findRead(what) {
        let start = 0;
        let foundPos = -1;
        while (foundPos < 0) {
            foundPos = this.readString.indexOf(what, start);
            if (foundPos < 0) {
                if (!this.moreToRead)
                    throw Error(`can not find: ${what} starting at ${this.curReadLine}`);
                start = this.readString.length;
                this.readString += this.file.readChunk();
            }
        }
        return foundPos;
    }
    // --------------------------
    /**
     * creates a new token from @endPos chars from readLine
     * and also advances curLine and curCol
     * @param type
     * @param endPos
     */
    createTokenUpToPos(type, endPos) {
        const result = new Token(this, type, this.consumeStringFromRead(endPos), this.curReadLine, this.curReadCol);
        if (type == TokenCode.NEWLINE) {
            this.curReadLine++;
            this.curReadCol = 0;
        }
        else if (type == TokenCode.COMMENT || type == TokenCode.LITERAL_STRING) {
            const internalNewLinesCount = result.value.split(/\r\n|\r|\n/).length;
            if (internalNewLinesCount) {
                this.curReadLine += internalNewLinesCount - 1;
                this.curReadCol = 0;
            }
        }
        else {
            this.curReadCol += endPos;
        }
        // #debug
        if (logger.debugLevel)
            logger.debug('>>>READ', `${result.line}:${result.col}`, result.toString());
        return result;
    }
    // --------------------------
    untilNewLine() {
        let endPos = this.findRead("\n");
        if (this.readString.charAt(endPos - 1) == '\r')
            endPos--;
        if (endPos < 0)
            endPos = this.findRead.length;
        return endPos;
    }
    // --------------------------
    readNewToken() {
        if (this.readString.length == 0)
            return this.EOFToken;
        try {
            const [tokenCode, endPos] = this.recognizeToken();
            return this.createTokenUpToPos(tokenCode, endPos);
        }
        catch (ex) {
            // add current position to error message
            throw new Error(ex.message + ` ${this.filename}:${this.curReadLine}:${(this.curReadCol)}`);
        }
    }
    // ---------------------------
    //   function whileUnescaped(chunk:string,endChar:string) returns number
    // ---------------------------
    /**
     *  returns position of unescaped endChar, starting from start
     * @param endChar
     * @param fromPos
     */
    untilUnescaped(endChar, fromPos) {
        // advance until unescaped endChar
        // return pos of endChar
        // throws id endChar not found
        // var pos = 0
        let pos = fromPos;
        while (true) {
            // find the next quote
            const inx = this.readString.indexOf(endChar, pos);
            // if inx is -1, fail with 'missing closing quote-char: #{endChar} ' // closer not found
            if (inx === -1) {
                throw new Error(`missing closing quote-char: ${endChar}`);
            }
            // quote found
            pos = inx;
            // check if escaped with '\'
            if (inx > 0 && this.readString.charAt(inx - 1) === '\\') {
                // seems escaped, let's see if the escape is escaped
                let countEscape = 1;
                while (inx > countEscape && this.readString.charAt(inx - 1 - countEscape) === '\\') {
                    countEscape++;
                }
                // how many escapes?
                if (countEscape % 2 === 0) { // even, means escaped-escapeChar, means: not escaped
                    break; // we found the closing quote
                }
                else {
                    // odd number means escaped quote, so it's not the closing quote yet
                    pos = inx + 1;
                }
            }
            else {
                // not escaped
                break; // we found the closing quote
            }
        } // loop looking for the closing quote
        return pos;
    }
    /**
     * Helper functions. simplified regex over this.readString
     * @param rangesStr
     */
    static parseRanges(rangesStr) {
        // Range examples:
        //* "1-9" means all chars between 1 and 9 (inclusive)
        //* "1-9J-Z" means all chars between 1 and 9 or between "J" and "Z"
        //* "1-9JNW" means all chars between 1 and 9, a "J" a "N" or a "W"
        // This function returns a normalized range string without "-"
        // and composed always from ranges:
        //
        //    "1-9" => "19"
        //    "1-9J-Z" => "19JZ"
        //    "1-9JNW" => "19JJNNWW"
        // var result = ""
        let result = '';
        let ch;
        let inx = 0;
        while (inx < rangesStr.length) {
            ch = rangesStr.charAt(inx);
            result += ch;
            if (rangesStr.charAt(inx + 1) === '-') {
                inx++;
                result += rangesStr.charAt(inx + 1);
            }
            else {
                result += ch; // same char twice
            }
            inx++;
        }
        return result;
    }
    whileRanges(rangesStr, startPos = 0) {
        // whileRanges, advance while the char is in the ranges specified.
        // will return pos of first char not in range, or entire string if all chars are in ranges
        // e.g.: whileRanges("123ABC","0-9") will return 3:"A"
        // e.g.: whileRanges("123ABC","0-9A-Z") will return 6:{EOS} because all chars are in range
        const len = this.readString.length;
        // normalize ranges
        const ranges = Lexer.parseRanges(rangesStr);
        // advance while in any of the ranges
        let inx = startPos;
        // do while inx<len
        while (inx < len) {
            const ch = this.readString.charAt(inx);
            let isIn = false;
            // check all ranges
            const upTo = ranges.length - 1;
            for (let r = 0; r <= upTo; r += 2) {
                if (ch >= ranges.charAt(r) && ch <= ranges.charAt(r + 1)) {
                    isIn = true;
                    break;
                }
            }
            if (!isIn) {
                break;
            }
            inx++;
        }
        return inx;
    }
}
exports.Lexer = Lexer;
Lexer.WHITESPACE_CHARS = ' \t\u00A0\u2028\u2029';
//# sourceMappingURL=Lexer.js.map
'''
'''--- dist/lib/Parser/ASTBase.js ---
"use strict";
// This module defines the base abstract syntax tree node used by the grammar.
// It's main purpose is to provide utility methods used in the grammar
// for **req**uired tokens, **opt**ional tokens
// and comma or semicolon **Separated Lists** of symbols.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTBase = void 0;
const Lexer_1 = require("../Lexer/Lexer");
const ControlledError_1 = require("../util/ControlledError");
const logger = require("../util/logger.js");
const os_1 = require("os");
class ASTBase {
    constructor(parent, name) {
        this.children = [];
        this.isPublic = false;
        this.isMut = false;
        this.parent = parent;
        this.name = name;
        // Get owner from parent
        if (parent) {
            this.owner = parent.owner;
            // Remember this node source position.
            // Also remember line index in tokenized lines, and indent
            if (this.owner) {
                // this.sourceLineNum = this.lexer.sourceLineNum
                // this.column = this.lexer.token.column
                // this.indent = this.lexer.indent
                // this.lineInx = this.lexer.lineInx
            }
        }
    }
    // ---------------------------
    lock() {
        //* *lock** marks this node as "locked", meaning we are certain this is the right class
        // for the given syntax. For example, if the `FunctionDeclaration` class see the token `function`,
        // we are certain this is the right class to use, so we 'lock()'.
        // Once locked, any **req**uired token not present causes compilation to fail.
        // .locked = true
        this.locked = true;
    }
    // ---------------------------
    // @ts-ignore
    // getParent(searchedClass):ASTBase { 
    //     //* *getParent** method searchs up the AST tree until a specfied node class is found
    //     // var node = this.parent
    //     let node = this.parent
    //     // while node and node isnt instance of searchedClass
    //     while (node && !(node instanceof searchedClass)) {
    //         // node = node.parent # move to parent
    //         node = node.parent
    //     }// end loop
    //     // return node
    //     return node
    // }
    // ---------------------------
    positionText() {
        if (!this.owner) {
            return '(compiler-defined)';
        }
        return `${this.owner.lexer.filename}:${this.sourceLineNum}:${this.sourceColumn || 0}`;
    }
    // ---------------------------
    toString() {
        return `[${this.constructor.name}]` + (this.keyword ? this.keyword + ' ' : '') + this.name;
    }
    // ---------------------------
    sayErr(msg) {
        logger.error(this.positionText(), msg);
    }
    // ---------------------------
    warn(msg) {
        logger.warning(this.positionText(), msg);
    }
    // ---------------------------
    throwError(msg) {
        //* *throwError** add node position info and throws a 'controlled' error.
        // A 'controlled' error, shows only err.message
        // A 'un-controlled' error is an unhandled exception in the compiler code itself,
        // and it shows error message *and stack trace*.
        logger.throwControlled(`${this.positionText()}. ${msg}`);
    }
    // ---------------------------
    throwParseFailed(msg) {
        // throws a parseFailed-error
        // During a node.parse(), if there is a token mismatch, a "parse failed" is raised.
        // "parse failed" signals a failure to parse the tokens from the stream,
        // however the syntax might still be valid for another AST node.
        // If the AST node was locked-on-target, it is a hard-error.
        // If the AST node was NOT locked, it's a soft-error, and will not abort compilation
        // as the parent node will try other AST classes against the token stream before failing.
        // var cErr = new ControlledError("#{.lexer.posToString()}. #{msg}")
        const cErr = new ControlledError_1.ControlledError(`${this.owner.lexer.token.posToString()}. ${msg}`);
        cErr.soft = !(this.locked);
        throw cErr;
    }
    // ---------------------------
    parse() {
        // abstract method representing the TRY-Parse of the node.
        // Child classes _must_ override this method
        this.throwError('ASTBase parse is abstract');
    }
    // ---------------------------
    /** produce():string is the method to produce target code for this node.
     * derived classes _should_ override this, if the default production isnt: this.name
     * Default behavior is to
     * recursively produce the entire sub-tree to a UTF file
     *
     */
    produce() {
        this.owner.codeWriter.write(this.name);
        this.produceChildren();
    }
    produceChildren(separator) {
        const o = this.owner.codeWriter;
        let inx = 0;
        for (const child of this.children) {
            if (inx > 0 && separator)
                o.write(separator);
            if (separator && separator.includes(os_1.EOL))
                o.write(' '.repeat(o.indent));
            child.writeComments();
            child.produce();
            inx++;
        }
        // if (separator == EOL) o.write(separator)
    }
    /**
     * output all node children as the body of a function
     * indented, one on each line
     * */
    produceBody(indent = 4) {
        const o = this.owner.codeWriter;
        o.newLine();
        o.indent += indent;
        for (const child of this.children) {
            child.writeComments();
            child.produce();
            o.newLine();
        }
        o.indent -= indent;
    }
    writeComments(watchForThis) {
        let result = false;
        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (const s of this.commentsAndAttr) {
                if (!s.startsWith("/"))
                    this.owner.codeWriter.write('//');
                if (watchForThis && watchForThis == s)
                    result = true;
                this.owner.codeWriter.writeLine(s);
            }
        }
        return result;
    }
    // --- helper
    tokVal() {
        return this.owner.lexer.token.value;
    }
    // ---------------------------
    // parseDirect(key, directMap) {
    //    //We use a DIRECT associative array to pick the exact AST node to parse
    //    //based on the actual token value or type.
    //    //This speeds up parsing, avoiding parsing by trial & error
    //    //Check keyword
    //    //if directMap.get(key) into var param
    //    let param = directMap[key]
    //    if (param) {
    //        //try parse by calling .opt
    //        let statement = undefined
    //        if (param instanceof Array) {
    //            //#accept Arrays also
    //            statement = this.optList(param)
    //        }
    //        else {
    //            //#normal call
    //            statement = this.optList([param])
    //        }
    //        //return parsed statement or nothing
    //        return statement
    //    }
    // }
    // ---------------------------
    optList(list) {
        //* *opt** (optional) parses optional parts of a grammar. It attempts to parse
        // the token stream using one of the classes or token types specified.
        // This method takes a variable number of arguments.
        // For example:
        // calling `.opt IfStatement, Expression, 'IDENTIFIER'`
        // would attempt to parse the token stream first as an `IfStatement`. If that fails, it would attempt
        // to use the `Expression` class. If that fails, it will accept a token of type `IDENTIFIER`.
        // If all of those fail, it will return `undefined`.
        var _a;
        // Method start:
        const t = this.owner.lexer.token;
        // For each argument, -a class or a string-, we will attempt to parse the token stream
        // with the class, or match the token type to the string.
        // Remember the actual position, to rewind if parse soft-fails
        this.owner.lexer.savePosition();
        // for each searched in arguments.toArray()
        for (const searched of list) {
            // skip empty, null & undefined
            if (!searched) {
                continue;
            }
            let found = false;
            // For strings, we check the token **value**
            if (typeof searched === 'string') {
                const searchedString = searched;
                found = (t.value == searchedString);
                if (found && logger.debugLevel) {
                    logger.debug(this.constructor.name, 'matched OK:', searched, t.value);
                }
            }
            // For numbers, we assume it's a TokenCode
            else if (typeof searched === 'number') { // it's a TokenCode
                const searchedToken = searched;
                found = (t.tokenCode == searchedToken);
                if (found && logger.debugLevel) {
                    logger.debug(this.constructor.name, 'matched OK:', Lexer_1.TokenCode[searchedToken], t.value);
                }
            }
            if (found) { // simple string/Token match
                // Ok, type/value found! now we return: token.value
                // Note: we shouldn't return the 'token' object, because returning objects (here and in js)
                // is "pass-by-reference" for the object members. You return a "pointer" to the object.
                // If we return the 'token' object, the calling function will recive a "pointer"
                // and it can inadvertedly alter the token object members in the token stream. (it should not, leads to subtle bugs)
                // Consume this token
                this.owner.lexer.advance();
                // discard saved position
                this.owner.lexer.discardSavedPosition();
                // return token value
                return t.value;
            }
            else if (typeof searched === 'function') { // it's a Grammar class
                const searchedClass = searched;
                logger.debug(this.constructor.name, 'TRY', searchedClass.name, 'on', t.toString());
                // if the argument is an AST node class, we instantiate the class and try the `parse()` method.
                // `parse()` can throw `ParseFailed` if the syntax do not matches the parse
                try {
                    // create required ASTNode, to try method parse()
                    const astNode = new searchedClass(this, t.value);
                    astNode.sourceLineNum = t.line;
                    astNode.sourceColumn = t.col;
                    // if it can't parse, will raise an exception
                    astNode.parse();
                    // logger.debug spaces, 'Parsed OK!->',searched.name
                    logger.debug('Parsed OK!->', searchedClass.name);
                    // discard saved position
                    this.owner.lexer.discardSavedPosition();
                    // parsed ok!, return instance
                    return astNode;
                }
                catch (err) {
                    if (!(err instanceof ControlledError_1.ControlledError)) { // non-controlled error
                        // discard saved position
                        this.owner.lexer.discardSavedPosition();
                        throw err;
                    }
                    // If parsing fail, but the AST node was not 'locked' on target, (that is, if it was a "soft" exception),
                    // we try other AST nodes.
                    // if err.soft => no match, try next
                    if (err.soft) {
                        this.owner.lexer.softError = err;
                        logger.debug(searchedClass.name, 'parse failed.', err.message);
                        // rewind the token stream, to try other AST nodes
                        this.owner.lexer.restoreSavedPosition();
                        logger.debug('<<REW to', (_a = this.owner.lexer.token) === null || _a === void 0 ? void 0 : _a.toStringDebug());
                    }
                    else {
                        // else: it's a hard-error. The AST node were locked-on-target.
                        // We abort parsing and throw.
                        // discard saved position
                        this.owner.lexer.discardSavedPosition();
                        // # the first hard-error is the most informative, the others are cascading ones
                        // if .lexer.hardError is null, .lexer.hardError = err
                        if (this.owner.hardError === null) {
                            this.owner.hardError = err;
                        }
                        // raise up, abort parsing
                        throw err;
                    } // end if - type of error
                } // end catch
            } // end if - string/TokenCode/ASTclass
        } // end loop - try the next argument
        // No more arguments.
        // discard saved position
        this.owner.lexer.discardSavedPosition();
        // `opt` returns `undefined` if none of the arguments can be use to parse the token stream.
        return undefined;
    }
    // ---------------------------
    opt(singleItem) {
        return this.optList([singleItem]);
    }
    // ---------------------------
    /**
     * Require one of a list
     *
     * @param list to try parsing, in order, one of the list must parse
     */
    reqList(list) {
        //* *req** (required) try to parse *required* symbols of the grammar.
        // It works the same way as `opt` except that it throws an error if none of the arguments
        // can be used to parse the stream.
        // We first call `opt` to try the arguments in order.
        // If a value is returned, the parsing was successful,
        // so we just return the node that `opt` found.
        const result = this.optList(list);
        // If `opt` returned "undefined" (no match), we give the user a useful error message.
        if (!result) {
            this.throwParseFailed(`${this.constructor.name}:${this.extraInfo || ''} found ${this.owner.lexer.token.toString()} but ${ASTBase.listToString(list)} required`);
        }
        return result;
    }
    // ---------------------------
    req(item) {
        return this.reqList([item]);
    }
    // ---------------------------
    reqClass(ASTClass) {
        return this.reqList([ASTClass]);
    }
    // ---------------------------
    reqChild(ASTClass) {
        this.children.push(this.reqList([ASTClass]));
    }
    optChild(ASTClass) {
        const result = this.opt(ASTClass);
        if (result) {
            this.children.push(result);
        }
    }
    // ---------------------------
    reqToken(tokenCode) {
        return this.reqList([tokenCode]);
    }
    // ---------------------------
    reqOneOf(list) {
        // (performance) check before try to parse, that the next token is in the list
        // if .lexer.token.value in arr
        if (list.includes(this.owner.lexer.token.value)) {
            return this.reqList(list);
        }
        else {
            this.throwParseFailed('not in list');
        }
    }
    /**
     * a [separator] separated list of [astClass] ended by [closer]
     *
     * the last closer is consumed
     *
     * @param astClass
     * @param separator
     * @param closer
     */
    // ---------------------------
    optSeparatedList(astClass, separator, closer) {
        // Start optSeparatedList
        // normal separated list,
        // loop until closer found
        const result = [];
        logger.debug(`optSeparatedList [${this.constructor.name}] get SeparatedList of [${astClass.name}] by '${separator}' closer:`, closer || '-no closer-');
        const startLine = this.owner.lexer.token.line;
        while (true) {
            if (this.owner.lexer.token.tokenCode == Lexer_1.TokenCode.EOF)
                break; // break on EOF
            if (closer && this.opt(closer))
                break; // if closer set, and closer found, break
            // pre comments and attrs
            const preComments = [];
            this.owner.lexer.consumeCommentsAndAttr(preComments);
            // get an item
            const item = this.reqClass(astClass);
            this.lock();
            // add item to result
            result.push(item);
            item.commentsAndAttr = preComments;
            // post comments and attr - NO, se come pre comments del siguiente
            // this.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr )
            // if .opt(closer) then break #closer found
            if (this.opt(closer)) {
                break;
            }
            // here, a 'separator' (comma/semicolon) means: 'there is another item'.
            // Any token other than 'separator' means 'end of list'
            // if no .opt(separator)
            if (!this.opt(separator)) {
                // # any token other than comma/semicolon means 'end of comma separated list'
                // # but if a closer was required, then "other" token is an error
                // if closer, .throwError "Expected '#{closer}' to end list started at line #{startLine}, got '#{.lexer.token.value}'"
                if (closer) {
                    if (this.owner.lexer.semiNotRequired) {
                        // after blocks separators are not required
                        this.owner.lexer.semiNotRequired = false;
                        continue;
                    }
                    this.throwError(`Expected '${closer}' to end list started at line ${startLine}, got '${this.owner.lexer.token.value}'`);
                }
                break;
            }
        } // try another item after the separator
        if (closer == '}')
            this.owner.lexer.semiNotRequired = true; // semicolon not required if list closed by '}'
        return result;
    }
    // ---------------------------
    reqSeparatedList(astClass, separator, closer) {
        //* *reqSeparatedList** is the same as `optSeparatedList` except that it throws an error
        // if the list is empty
        // First, call optSeparatedList
        const result = this.optSeparatedList(astClass, separator, closer);
        if (result.length === 0) {
            this.throwParseFailed(`${this.constructor.name}: Get list: At least one [${astClass.name}] was expected`);
        }
        return result;
    }
    // ------------------------
    optPub() {
        // manage special prefixes like 'pub'
        if (this.owner.lexer.token.value == 'pub') {
            this.isPublic = true;
            this.owner.lexer.advance();
        }
    }
    optRef() {
        // manage special prefixes like '&'
        if (this.owner.lexer.token.value == '&') {
            this.isRef = true;
            this.owner.lexer.advance();
        }
    }
    optDeRef() {
        // manage special prefixes like '*'
        if (this.owner.lexer.token.value == '*') {
            this.deRef = true;
            this.owner.lexer.advance();
        }
    }
    optMut() {
        // manage special prefixes like 'mut'
        if (this.owner.lexer.token.value == 'mut') {
            this.isMut = true;
            this.owner.lexer.advance();
        }
    }
    optDecorators() {
        // manage decorators like #[callback]
        if (this.owner.lexer.token.value == '#' && this.owner.lexer.nextToken().value == "[") {
            this.owner.lexer.advance();
            this.owner.lexer.advance();
            if (!this.decorators)
                this.decorators = [];
            this.decorators.push(this.owner.lexer.token.value);
            this.req("]");
        }
    }
    // ---------------------------
    /**
     * Helper function toString of an argument list to opt() or req()
     * @param args
     */
    static listToString(args) {
        // listArgs list arguments (from opt or req). used for debugging
        // and syntax error reporting
        // var msg = []
        const msg = [];
        // for each i in args
        for (const i of args) {
            // if typeof i is 'string'
            if (typeof i === 'string') {
                msg.push(`'${i}'`);
            }
            else if (i) {
                if (typeof i === 'function') {
                    msg.push(`[${i.name}]`);
                }
                else if (typeof i === 'number') {
                    msg.push(`[${Lexer_1.TokenCode[i]}]`);
                }
                else {
                    msg.push(`<${i}>`);
                }
            }
            else {
                msg.push('[null]');
            }
        }
        return msg.join('|');
    }
}
exports.ASTBase = ASTBase;
//# sourceMappingURL=ASTBase.js.map
'''
'''--- dist/lib/Parser/CodeWriter.js ---
"use strict";
// public helper class CodeWriter
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeWriter = void 0;
const fs = require("fs");
const mkPath = require("../util/mkPath");
const console_1 = require("console");
const os_1 = require("os");
class CodeWriter {
    // ---------------------------
    constructor(fn1, data, fn2 = '', fn3 = '') {
        this.fileMode = true;
        this.filenames = ['', '', ''];
        this.fileIsOpen = [false, false, false];
        this.fHandles = [null, null, null];
        this.selectedStream = 0;
        this.indent = 0;
        this.filenames = [fn1, fn2, fn3];
        this.data = data;
        // Initialize output array
        this.lineNum = 1;
        this.column = 1;
        this.currLine = [];
        this.lines = [[], [], []];
    }
    // ---------------------------
    selectOutStream(index) {
        this.newLine();
        this.selectedStream = index;
    }
    // ---------------------------
    write(text) {
        // put a string into produced code
        if (text) {
            this.currLine.push(text);
            this.column += text.length;
        }
    }
    // ---------------------------
    writeLine(text) {
        this.write(text);
        this.newLine();
    }
    // ---------------------------
    getIndent() {
        // if no .currLine.length, return 0
        if (!this.currLine.length) {
            return 0;
        }
        return this.currLine[0].countSpaces();
    }
    // ---------------------------
    newLine() {
        // Start New Line into produced code
        // send the current line
        if (this.currLine.length) {
            if (this.fileMode) {
                if (!this.fileIsOpen[this.selectedStream]) {
                    // make sure output dir exists
                    const filename = this.filenames[this.selectedStream];
                    console_1.assert(filename);
                    mkPath.toFile(filename);
                    // open output file
                    this.fHandles[this.selectedStream] = fs.openSync(filename, 'w');
                    this.fileIsOpen[this.selectedStream] = true;
                }
                const fd = this.fHandles[this.selectedStream];
                // save all the parts to file
                if (this.indent > 0)
                    fs.writeSync(fd, ' '.repeat(this.indent));
                // for each part in .currLine
                for (const part of this.currLine) {
                    fs.writeSync(fd, part);
                }
                // close the line: "\n"
                fs.writeSync(fd, os_1.EOL);
            }
            else {
                // not fileMode
                // store in array
                this.lines[this.selectedStream].push(this.currLine.join(''));
            }
            if (this.selectedStream === 0) {
                this.lineNum++;
            }
        }
        this.clearCurrentLine();
    }
    // ----------------------------
    // clear current working line
    clearCurrentLine() {
        // clear current line
        this.currLine = [];
        this.column = 1;
    }
    // ----------------------------
    // return current working line
    getCurrentLine() {
        return this.currLine.join("");
    }
    // ---------------------------
    ensureNewLine() {
        // if there's something on the line, start a new one
        if (this.currLine.length) {
            this.newLine();
        }
    }
    // ---------------------------
    blankLine() {
        this.newLine();
        this.currLine.push('');
        this.newLine();
    }
    // ---------------------------
    getResult(inx = 0) {
        // get result and clear memory
        if (inx === undefined)
            inx = 0;
        this.selectedStream = inx;
        // #close last line
        this.newLine();
        return this.lines[inx];
    }
    // ---------------------------
    close() {
        // save last pending line
        this.newLine();
        if (this.fileMode) {
            for (let inx = 0; inx <= 2; inx++) {
                if (this.fileIsOpen[inx]) {
                    fs.closeSync(this.fHandles[inx]);
                    this.fileIsOpen[inx] = false;
                }
            }
        }
    }
}
exports.CodeWriter = CodeWriter;
//# sourceMappingURL=CodeWriter.js.map
'''
'''--- dist/lib/Parser/Grammar.js ---
"use strict";
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/*
 * This Grammar is based on [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
 * *with extensions*.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTModule = exports.Body = exports.Statement = exports.VarRef = exports.IndexAccess = exports.PropertyAccess = exports.FunctionAccess = exports.Accessor = exports.ForStatement = exports.RangeExpression = exports.WhileStatement = exports.IfStatement = exports.ReturnStatement = exports.TraitDeclaration = exports.FunctionParameters = exports.LetStatement = exports.VariableDecl = exports.FunctionDeclaration = exports.MatchExpression = exports.MatchPair = exports.RustClosure = exports.IdentifierMaybeTuple = exports.LineAttribute = exports.ImplDeclaration = exports.EnumDeclaration = exports.EnumItem = exports.StructDeclaration = exports.MacroInvocation = exports.DelimitedWordList = exports.TypeDeclaration = exports.ModDeclaration = exports.UseDeclaration = exports.TypeAnnotation = exports.ParenExpression = exports.ConstDeclaration = exports.ArrayLiteral = exports.StaticDeclaration = exports.ObjectLiteral = exports.NameValuePair = exports.RustNativeSuffixes = exports.Expression = exports.FunctionArgument = exports.Operand = exports.RegExpLiteral = exports.StringLiteral = exports.NumberLiteral = exports.UnaryOper = exports.Oper = exports.Identifier = void 0;
// Grammar Meta-Syntax
// -------------------
// Each Grammar class, contains a 'grammar definition' as reference.
// The meta-syntax for the grammar definitions is an extended form of
// [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
// The differences with classic PEG are:
//* instead of `Symbol <- definition`, we use `Symbol: definition` (colon instead of arrow)
//* we use `[Symbol]` for optional symbols instead of `Symbol?` (brackets also groups symbols, the entire group is optional)
//* symbols upper/lower case has meaning
//* we add `(Symbol,)` for `comma separated List of` as a powerful syntax option
// Meta-Syntax Examples:
// `function`     : all-lowercase means the literal word: "function"<br>
// `":"`              : literal symbols are quoted<br>
// `ReturnStatement`  : CamelCase is reserved for composed, non-terminal symbol<br>
// `IDENTIFIER`,`OPER` : all-uppercase denotes a entire class of symbols<br>
// `NEWLINE`,`EOF`     : or special unprintable characters<br>
// `[to]`               : Optional symbols are enclosed in brackets<br>
// `(var|let)`          : The vertical bar represents ordered alternatives<br>
// `(Oper Operand)`     : Parentheses groups symbols<br>
// `(Oper Operand)*`    : Asterisk after a group `()*` means the group can repeat (meaning one or more)<br>
// `[Oper Operand]*`    : Asterisk after a optional group `[]*` means *zero* or more of the group.<br>
// `[Expression,]` : means: "optional comma separated list of Expressions".<br>
// `Body: (Statement;)` : means "Body is a semicolon-separated list of statements".<br>
// Full Meta-Syntax Example:
// `PrintStatement: print [Expression,]`
// It reads: composed symbol `PrintStatement` is conformed by the word `print` followed by
// an _optional_ comma-separated list of `Expression`
// ###More on comma-separated lists
// Let's analyze the example: `PrintStatement: print [Expression,]`
// `[Expression,]` means *optional* **comma "Separated List"** of Expressions.
// Since the comma is inside a **[ ]** group, it means the entire list is optional.
// Another example:
// `VariableDecl: IDENTIFIER ["=" Expression]`
// `VarStatement: var (VariableDecl,)`
// It reads: composed symbol `VarStatement` is conformed by the word `var` followed by
// a comma-separated list of `VariableDecl` (at least one)
// The construction `(VariableDecl,)` means: **comma "Separated List"** of `VariableDecl`
// Since the comma is inside a **( )** group, it means _at least one VariableDecl_ is required.
const ASTBase_1 = require("./ASTBase");
const logger = require("../util/logger.js");
const Lexer_1 = require("../Lexer/Lexer");
const os_1 = require("os");
// Reserved Words
// ---------------
// Words that are reserved and cannot be used as variable or function names
const RESERVED_WORDS = ['fn', 'async', 'class', 'if', 'then', 'else', 'null', 'true', 'false',
    'new', 'loop', 'while', 'crate', 'for', 'to', 'break', 'continue',
    'return', 'try', 'catch', 'throw', 'raise', 'fail', 'exception', 'finally',
    'mut', 'var', 'let',
    'yield', 'await', 'self', 'super', 'export',
    'async', 'short', 'long', 'int',
    'unsigned', 'void', 'null', 'bool', 'assert'];
// Operators precedence
// --------------------
// The order of symbols here determines operators precedence
// var operatorsPrecedence = [
// '++','--', 'unary -', 'unary +', 'bitnot' ,'bitand', 'bitor', 'bitxor'
//, '>>','<<'
//, 'new','type of','instance of','has property'
//, '*','/','%','+','-','&'
//, 'into','in'
//, '>','<','>=','<=','is','<>','!==','like'
//, 'no','not','and','but','or'
//, '?',':'
// ]
const OPERATORS_PRECEDENCE = ['&', '&mut', '*',
    '!', '?',
    'unary -', 'unary +',
    'as',
    '*', '/', '%', '&', '|', '^', '>>', '<<',
    '+', '-',
    '==', '!=', '>', '<', '>=', '<=',
    '||', '&&',
    '..', '..=',
    '=', '+=', '-=', '*=', '/='
];
// --------------------------
// Grammar - AST Classes
//= ===============================
// You'll find a class for each syntax construction the parser accepts
/**
 * can include namespace::namespace::name
 * */
class Identifier extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.optMut();
        this.optRef();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        while (this.opt('::')) {
            this.name += '::';
            if (this.opt("<")) {
                this.typeParams = DelimitedWordList.parseOpened(this, '<', '>');
            }
            else {
                this.name += this.reqToken(Lexer_1.TokenCode.WORD);
            }
        }
    }
}
exports.Identifier = Identifier;
// ## Oper
// ```
// Oper: ('~'|'&'|'^'|'|'|'>>'|'<<'
// |'*'|'/'|'+'|'-'|mod
// |'>'|'<'|'>='|'<='
// etc.
// ```
// An Oper sits between two Operands ("Oper" is a "Binary Operator",
// different from *UnaryOperators* which optionally precede a Operand)
// If an Oper is found after an Operand, a second Operand is expected.
class Oper extends ASTBase_1.ASTBase {
    constructor() {
        super(...arguments);
        // ---------------------------
        this.getPrecedence = function () {
            this.precedence = OPERATORS_PRECEDENCE.indexOf(this.name);
            if (this.precedence === -1) {
                this.sayErr(`OPER '${this.name}' not found in the operator precedence list`);
            }
        };
    }
    // ---------------------------
    parse() {
        if (this.owner.lexer.token.value == "as") { // typecast operation
            this.lock();
            this.name = this.req("as");
        }
        else {
            this.name = this.reqToken(Lexer_1.TokenCode.OPERATOR);
            this.lock();
            // check range operator
            if (this.name == ".." && this.opt("=")) {
                this.name = "..=";
            }
        }
        // Get operator precedence index
        this.getPrecedence();
    }
    // ----------------
    produce() {
        var _a, _b;
        (_a = this.left) === null || _a === void 0 ? void 0 : _a.produce();
        this.owner.codeWriter.write(' ' + this.name + ' ');
        (_b = this.right) === null || _b === void 0 ? void 0 : _b.produce();
    }
}
exports.Oper = Oper;
// end class Oper
class UnaryOper extends Oper {
    // ---------------------------
    parse() {
        this.name = this.reqOneOf(['+', '-', '!']);
        // Lock, we have a unary oper
        this.lock();
        // Rename - and + to 'unary -' and 'unary +',
        // if .name is '-'
        if (this.name == '-' || this.name == '+') {
            this.precedence = 0;
        }
        else {
            // calculate precedence - Oper.getPrecedence()
            this.getPrecedence();
        }
    }
}
exports.UnaryOper = UnaryOper;
// end class UnaryOper
// ## NumberLiteral
// `NumberLiteral: [0-9_.u] | '0x[0-9a-fA-F] | 0b[0-1][u0-9] `
class NumberLiteral extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.tokenCode = this.owner.lexer.token.tokenCode;
        this.name = this.reqList([Lexer_1.TokenCode.NUMBER, Lexer_1.TokenCode.HEXANUMBER, Lexer_1.TokenCode.BINARYNUMBER]);
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
exports.NumberLiteral = NumberLiteral;
// end class NumberLiteral
// ## StringLiteral
// `StringLiteral: '"' [ any* | '\"' ] '"' | ''' [ any* | '\'' ] '''
// A string constant token. Can be anything the lexer supports, including single or double-quoted strings.
// The token includes the enclosing quotes
class StringLiteral extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(Lexer_1.TokenCode.LITERAL_STRING);
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
    // ---------------------------
    unquoted() {
        return this.name.slice(1, -1);
    }
}
exports.StringLiteral = StringLiteral;
// end class StringLiteral
// ## RegExpLiteral
// `RegExpLiteral: REGEX`
// A regular expression token constant. Can be anything the lexer supports.
class RegExpLiteral extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(Lexer_1.TokenCode.LITERAL_STRING);
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
exports.RegExpLiteral = RegExpLiteral;
// end class RegExpLiteral
// ## Operand
// ```
// Operand: (
// (NumberLiteral|StringLiteral|RegExpLiteral|ArrayLiteral|ObjectLiteral
// |ParenExpression|FunctionDeclaration)[Accessors])
// |VariableRef)
// ```
// Examples:
// <br> 4 + 3 -> `Operand Oper Operand`
// <br> -4    -> `UnaryOper Operand`
// A `Operand` is the data on which the operator operates.
// It's the left and right part of a binary operator.
// It's the data affected (righ) by a UnaryOper.
class Operand extends ASTBase_1.ASTBase {
    // -------------------------
    // value is at children[0]
    // -------------------------
    parse() {
        // Let's look for operands in a expression, i.e: "a" and "b" in  "a+b*5"
        const t = this.owner.lexer.token;
        if ([Lexer_1.TokenCode.NUMBER, Lexer_1.TokenCode.HEXANUMBER, Lexer_1.TokenCode.BINARYNUMBER].includes(t.tokenCode)) {
            this.children.push(this.reqClass(NumberLiteral));
            return; //* *** early exit
        }
        if (t.tokenCode == Lexer_1.TokenCode.LITERAL_STRING) {
            this.children.push(this.reqClass(StringLiteral));
            return; //* *** early exit
        }
        if (t.value == "match") { // Rust match expression
            this.name = 'match';
            this.children.push(this.reqClass(MatchExpression));
            return; //* *** early exit
        }
        if (t.value == "[") { // array expression
            this.name = 'array expression';
            this.children.push(this.reqClass(ArrayLiteral));
            return; //* *** early exit
        }
        if (t.value == "(") { // parenthized expression
            this.name = 'parentized';
            this.children.push(this.reqClass(ParenExpression));
            return; //* *** early exit
        }
        if (t.value == "|") { // closure expression
            this.name = 'closure';
            this.children.push(this.reqClass(RustClosure));
            return; //* *** early exit
        }
        if (t.value == "let") { // if let => destructuring, check if the Rvalue is of the Lvalue struct
            this.name = 'if-let';
            this.req("let");
            this.reqChild(Operand); // expression like Some(a / Foo::Bar / Foo::Bar { field })
            this.req("=");
            this.reqChild(Identifier); // rvalue is the variable to check against lvalue
            return; //* *** early exit
        }
        if (t.value == "if") { // let x = if... if expression
            this.name = 'if-expr';
            this.reqChild(IfStatement); // expression like Some(a / Foo::Bar / Foo::Bar { field })
            return; //* *** early exit
        }
        // here, the OPERAND is a var reference, fn-call or macro!
        this.owner.lexer.savePosition();
        const vr = this.reqClass(VarRef);
        // let's see if this is a macro! invocation
        if (this.owner.lexer.token.value == '!') { // it's a macro!
            this.owner.lexer.restoreSavedPosition();
            this.keyword = "macro!";
            this.name = vr.name;
            this.children.push(this.reqClass(MacroInvocation));
            return; //* *** early exit
        }
        // it's not a macro, last options are var reference or fn-call
        // the vr is good for both
        this.owner.lexer.discardSavedPosition();
        // let's see if this is a struct instantiation expression
        // rust's struct instantiation can only be detected by 'Self {...' or 'Declared-Struct-Type-Name {...' used as a statement
        // ojo ambiguos if we're in [match expr '{' ... '}' ] - commented
        if (this.owner.lexer.token.value == "{" &&
            this.parent.parent.name != 'match' && // for all this statements { => start body
            this.parent.parent.name != 'if' &&
            this.parent.parent.name != 'for') { // it's a struct Instantiation
            const objectLiteral = this.reqClass(ObjectLiteral);
            objectLiteral.name = vr.name;
            objectLiteral.keyword = "struct-instantiation";
            this.children.push(objectLiteral);
            return; //* *** early exit
        }
        // last option, this is just a varRef acting as a expression
        this.name = vr.name;
        this.children.push(vr);
    }
    // --------
    produce() {
        this.produceChildren();
    }
}
exports.Operand = Operand;
// end class Operand
class FunctionArgument extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.lock();
        if (this.owner.lexer.token.value == "_") { //  _ => wildcard, ignore param
            this.name = "_";
            this.owner.lexer.advance();
            return; // early exit
        }
        this.optRef();
        this.optMut();
        this.expression = this.reqClass(Expression);
    }
} // end class FunctionArgument
exports.FunctionArgument = FunctionArgument;
// -----------
// ## Expression
// `Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`
// The expression class parses intially a *flat* array of nodes.
// After the expression is parsed, a *Expression Tree* is created based on operator precedence.
class Expression extends ASTBase_1.ASTBase {
    constructor() {
        super(...arguments);
        // ---------------------------
        this.growExpressionTree = function (arr) {
            // do while arr.length > 1
            while (arr.length > 1) {
                // find the one with highest precedence (lower number) to push down
                // (on equal precedende, we use the leftmost)
                let pos = -1;
                let minPrecedenceInx = 100;
                for (let inx = 0, item; inx < arr.length; inx++) {
                    item = arr[inx];
                    // debug "item at #{inx} #{item.name}, Oper? #{item instanceof Oper}. precedence:",item.precedence
                    if (item instanceof Oper) {
                        // if not item.pushed and item.precedence < minPrecedenceInx
                        if (!(item.pushed) && item.precedence < minPrecedenceInx) {
                            pos = inx;
                            minPrecedenceInx = item.precedence;
                        }
                    }
                }
                // end for
                // #control
                if (pos < 0) {
                    this.throwError("can't find highest precedence operator");
                }
                // Un-flatten: Push down the operands a level down
                const oper = arr[pos];
                oper.pushed = true;
                if (oper instanceof UnaryOper) {
                    // #control
                    if (pos === arr.length) {
                        this.throwError(`can't get RIGHT operand for unary operator '${oper}'`);
                    }
                    // # if it's a unary operator, take the only (right) operand, and push-it down the tree
                    oper.right = arr.splice(pos + 1, 1)[0];
                }
                else {
                    // #control
                    if (pos === arr.length) {
                        this.throwError(`can't get RIGHT operand for binary operator '${oper}'`);
                    }
                    if (pos === 0) {
                        this.throwError(`can't get LEFT operand for binary operator '${oper}'`);
                    }
                    // # if it's a binary operator, take the left and right operand, and push them down the tree
                    oper.right = arr.splice(pos + 1, 1)[0];
                    oper.left = arr.splice(pos - 1, 1)[0];
                }
                // loop #until there's only one operator
            }
            // Store the root operator
            this.root = arr[0];
        };
    }
    // ---------------------------
    parse() {
        const arr = [];
        this.operandCount = 0;
        this.ternaryCount = 0;
        // (performance) Fast exit for no-expression `);{` => end of expression.
        if (');}'.includes(this.owner.lexer.token.value)) {
            return; // early exit
        }
        while (true) {
            // Get optional unary operator
            // (performance) check token first
            if (['+', '-', '!'].includes(this.owner.lexer.token.value)) {
                const unaryOper = this.opt(UnaryOper);
                if (unaryOper) {
                    arr.push(unaryOper);
                    this.lock();
                }
            }
            // Get operand
            arr.push(this.reqClass(Operand));
            this.operandCount++;
            this.lock();
            // (performance) Fast exit for common tokens: `=> , ] ) ; { ` => end of expression.
            if (this.owner.lexer.token.value == "=>" || ',]);{'.includes(this.owner.lexer.token.value)) {
                break; // early exit
            }
            // Try to parse next token as an operator
            const oper = this.opt(Oper);
            // if no oper then break # no more operators, end of expression
            if (!oper) {
                break;
            }
            // If it was an operator, store, and continue because we expect another operand.
            // (operators sits between two operands)
            arr.push(oper);
        }
        // Now we create a tree from .arr[], based on operator precedence
        this.growExpressionTree(arr);
    }
    static checkNativeRustConversionMapCollect(node) {
        if (node.tokVal() == ".") {
            node.nativeSuffixes = node.reqClass(RustNativeSuffixes);
        }
    }
}
exports.Expression = Expression;
// end class Expression
class RustNativeSuffixes extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        // check for .into() o .as_u128() .to_vec() .map() . collect() etc,
        while (this.owner.lexer.token.value == '.') {
            this.owner.lexer.advance();
            if (this.owner.lexer.token.tokenCode == Lexer_1.TokenCode.NUMBER) {
                // tuple item acess
                this.reqChild(NumberLiteral);
            }
            else {
                const suffix = this.reqClass(Identifier);
                if (this.opt("(")) {
                    if (suffix.name == "map" || suffix.name == "filter") { // .map() && filter param are rust's closures
                        suffix.reqChild(RustClosure);
                    }
                    else if (this.tokVal() != ')') { // has parameters
                        suffix.reqChild(Expression);
                    }
                    this.req(")");
                }
            }
        }
    }
}
exports.RustNativeSuffixes = RustNativeSuffixes;
// ## NameValuePair
// `NameValuePair: (IDENTIFIER|StringLiteral|NumberLiteral) ':' Expression`
// A single item inside a `ObjectLiteral / StructInstantiation.value`
// a `property-name: value` pair.
class NameValuePair extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.owner.lexer.savePosition();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        if (this.opt(':')) { // por alguna razon en rust decidieron q se podia instanciar un obj por posicion, los : son opcionales
            this.owner.lexer.discardSavedPosition();
            this.lock();
            this.value = this.reqClass(Expression);
        }
        else {
            // asumpo posicional
            this.owner.lexer.restoreSavedPosition();
            this.name = "[positional]";
            this.value = this.reqClass(Expression);
        }
    }
    // ---------------------------
    produce() {
        this.owner.codeWriter.write(this.name);
        this.owner.codeWriter.write(" : ");
        this.value.produce();
    }
}
exports.NameValuePair = NameValuePair;
class ObjectLiteral extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('{');
        this.lock();
        this.children = this.optSeparatedList(NameValuePair, ',', '}');
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
    // ---------------------------
    forEach(callback) {
        // for each nameValue in .items
        for (const nameValue of this.children) {
            callback(nameValue);
        }
    }
    // ---------------------------
    produce() {
        this.owner.codeWriter.write("{");
        this.produceChildren("," + os_1.EOL);
        this.owner.codeWriter.write("}");
    }
}
exports.ObjectLiteral = ObjectLiteral;
class StaticDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('static');
        // At this point we lock because it is definitely a `static` declaration. Failure to parse the expression
        // from this point is a syntax error.
        this.lock();
        // After the word 'static' we require an identifier:type=value
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.req(":");
        this.reqChild(TypeAnnotation);
        this.req("=");
        this.reqChild(Expression);
    }
}
exports.StaticDeclaration = StaticDeclaration;
// end static place declaration
// ## ArrayLiteral
// `ArrayLiteral: '[' (Expression,)* ']'`
// An array definition, such as `a = [1,2,3]`
class ArrayLiteral extends ASTBase_1.ASTBase {
    constructor() {
        super(...arguments);
        this.items = [];
    }
    // ---------------------------
    parse() {
        this.req('[');
        this.lock();
        // closer "]" required
        this.items = this.optSeparatedList(Expression, ',', ']');
    }
} // end class ArrayLiteral
exports.ArrayLiteral = ArrayLiteral;
class ConstDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('const');
        // At this point we lock because it is definitely a `const` declaration. Failure to parse the expression
        // from this point is a syntax error.
        this.lock();
        // After the word 'const' we require an identifier
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.req(":");
        this.reqChild(TypeAnnotation);
        this.req("=");
        this.reqChild(Expression);
    }
}
exports.ConstDeclaration = ConstDeclaration;
// end ConstValueDeclaration
// ## ParenExpression
// `ParenExpression: '(' Expression ')'`
// An expression enclosed by parentheses, like `(a + b)`.
class ParenExpression extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('(');
        this.lock();
        while (true) {
            this.reqChild(Expression);
            if (this.opt(",")) {
                // tuple paren expression
                this.keyword = "tuple";
                continue;
            }
            else {
                break;
            }
        }
        this.req(')');
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversion
    }
}
exports.ParenExpression = ParenExpression;
// end class ParenExpression
/**
 * a type annotation with optional <type-paramenters,...>
 *      IDENT [ '<' (type-paramenter,) '>' ]
 * */
class TypeAnnotation extends ASTBase_1.ASTBase {
    parse() {
        this.optRef();
        this.optMut();
        if (this.opt("(")) { // tuple type annotation
            this.lock();
            this.keyword = "tuple type";
            this.name = "(tuple)";
            this.children = this.reqSeparatedList(TypeAnnotation, ',', ')');
        }
        else if (this.opt("[")) { // arr type annotation
            this.lock();
            this.keyword = "arr type";
            this.name = "(arr)";
            this.reqChild(Identifier);
            if (this.opt(";")) {
                this.reqChild(NumberLiteral);
            }
            this.req("]");
        }
        else {
            const ident = this.reqClass(Identifier);
            this.name = ident.name; // composed::namespace::name
            // check for (nested) type parameters
            const initial = (this.opt('<') || this.opt("<'"));
            if (initial) {
                this.typeParams = DelimitedWordList.parseAfter(initial, this, '<', '>');
            }
        }
    }
}
exports.TypeAnnotation = TypeAnnotation;
/**
 * class UseDeclaration
 *      'use' WORD ([::WORD...]  | '{' (Identifier,) '}' | * )
 * */
class UseDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('use');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        while (this.owner.lexer.token.value == '::') {
            this.name += '::';
            const nextValue = this.owner.lexer.advance();
            if (nextValue == '{') { // special rust case, several use declarations sharing the same root
                this.owner.lexer.advance();
                this.children = this.reqSeparatedList(Identifier, ",", "}");
                break; // no more ::'s possible
            }
            else if (nextValue == '*') { // special: all items
                this.name += '*';
                this.owner.lexer.advance();
                break; // no more ::'s possible
            }
            else { // more indentifiers
                this.name += this.reqToken(Lexer_1.TokenCode.WORD);
            }
        }
    }
}
exports.UseDeclaration = UseDeclaration;
class ModDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('mod');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        Body.optIntoChildren(this);
    }
}
exports.ModDeclaration = ModDeclaration;
class TypeDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('type');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.req('=');
        this.reqChild(Expression);
    }
}
exports.TypeDeclaration = TypeDeclaration;
class DelimitedWordList {
    static parse(node, opener, closer) {
        const initial = node.req(opener);
        return DelimitedWordList.parseAfter(initial, node, opener, closer);
    }
    static parseOpened(node, opener, closer) {
        return DelimitedWordList.parseAfter(opener, node, opener, closer);
    }
    static parseAfter(initial, node, opener, closer) {
        // read balanced openers/closers { } / () or up to ;
        // because it's a "macro" anything goes (can't use AST Body parser)
        const macroWords = [];
        macroWords.push(initial);
        let openBalance = 1;
        while (openBalance > 0) {
            const word = node.owner.lexer.advance();
            if (opener && word == opener) {
                openBalance++;
            }
            else if (word == closer) {
                openBalance--;
            }
            macroWords.push(word);
        }
        node.owner.lexer.advance(); // consume the closer
        return macroWords;
    }
}
exports.DelimitedWordList = DelimitedWordList;
class MacroInvocation extends ASTBase_1.ASTBase {
    constructor() {
        super(...arguments);
        this.macroWords = [];
    }
    // ---------------------------
    parse() {
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.name += this.req('!');
        this.lock();
        // handle standard rust macro parameter delimiters
        const initial = this.owner.lexer.token.value;
        let opener = initial;
        let closer;
        if (initial == '{') {
            closer = '}';
        }
        else if (initial == '(') {
            closer = ')';
        }
        else if (initial == '[') {
            closer = ']';
        }
        else {
            opener = undefined;
            closer = ';';
        }
        // special recognized macros: assert_eq!(a,b) => expect(a).toBe(b)
        if (this.name == "assert_eq!" && opener == "(") {
            // parse the 2 expression and store at children[]
            this.req("(");
            this.reqChild(Expression);
            this.req(",");
            this.reqChild(Expression);
            if (this.opt(",")) { // third parameter, message if asssert failed
                this.reqChild(Expression);
            }
            this.req(")");
        }
        else {
            // read balanced openers/closers { } / () or up to ;
            // because it's a "macro" anything goes (can't use AST Body parser)
            this.macroWords = DelimitedWordList.parseAfter(initial, this, opener, closer);
        }
        // check if the macro!() ends with .into() .as_bytes() .as_U128() etc
        Expression.checkNativeRustConversionMapCollect(this);
        this.owner.lexer.semiNotRequired = true; // no need for a semicolon after this
    }
    toString() {
        return Function.apply(ASTBase_1.ASTBase.toString, this) + ' ' + this.macroWords.join(' ');
    }
}
exports.MacroInvocation = MacroInvocation;
class StructDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('struct');
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.req('{');
        this.children = this.reqSeparatedList(VariableDecl, ",", "}");
    }
}
exports.StructDeclaration = StructDeclaration;
class EnumItem extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        if (this.opt('{')) {
            this.children = this.reqSeparatedList(VariableDecl, ",", "}");
        }
    }
}
exports.EnumItem = EnumItem;
class EnumDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('enum');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.req('{');
        this.children = this.reqSeparatedList(EnumItem, ",", "}");
    }
}
exports.EnumDeclaration = EnumDeclaration;
class ImplDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('impl');
        this.lock();
        const ident = this.reqClass(Identifier);
        this.name = ident.name;
        if (this.opt('for')) {
            this.for = this.reqClass(Identifier);
        }
        this.req("{");
        Body.parseIntoChildren(this); // parse as a Body (no separator, several fn { } blocks) => children
    }
}
exports.ImplDeclaration = ImplDeclaration;
/**
 * A single-line attribute
 * comments attached to statements are stored in Statement.comment
 * */
class LineAttribute extends ASTBase_1.ASTBase {
    parse() {
        this.name = this.reqToken(Lexer_1.TokenCode.ATTRIBUTE);
    }
}
exports.LineAttribute = LineAttribute;
class IdentifierMaybeTuple extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        if (this.opt("(")) {
            this.lock();
            this.children = this.reqSeparatedList(Identifier, ",", ")"); // closure params as tuples?
        }
        else {
            this.reqChild(Identifier);
        }
    }
}
exports.IdentifierMaybeTuple = IdentifierMaybeTuple;
// ## RustClosure
//
// `RustClosure: ` '|' (WORD,...) '|' ( Body | Expression | fn-call ) `
//
class RustClosure extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('|');
        this.lock();
        if (this.opt("(")) {
            this.params = this.reqSeparatedList(Identifier, ",", ")"); // closure params as tuples?
            this.req('|');
        }
        else {
            this.params = this.reqSeparatedList(Identifier, ",", "|"); // closure params
        }
        // it's a body?
        if (this.opt('{')) {
            Body.parseIntoChildren(this);
        }
        else {
            // let's assume it is an Expression
            this.children.push(this.reqClass(Expression));
        }
    }
}
exports.RustClosure = RustClosure;
// end class RustClosure
// ## MatchPair
//
// `MatchPair: ` (Expression | '_' ) '=>' Expression
//
class MatchPair extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        if (this.opt('_')) {
            this.left = null;
        }
        else {
            this.left = this.reqClass(Expression);
        }
        this.req("=>");
        if (this.owner.lexer.token.value == "{") { // match pair right item is a block
            this.right = this.reqClass(Body);
        }
        else {
            this.right = this.reqClass(Expression);
        }
    }
    toString() {
        return Function.apply(ASTBase_1.ASTBase.toString, this) + (this.left ? this.left.name : '_') + " => " + this.right.name;
    }
}
exports.MatchPair = MatchPair;
// ## MatchExpression
//
// `MatchExpression: ` match Expression '{' ( (Expression | '_' ) => Expression ,... ) '}'`
//
class MatchExpression extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('match');
        this.lock();
        this.exprToMatch = this.reqClass(Expression);
        this.req('{');
        this.children = this.optSeparatedList(MatchPair, ",", "}");
        Expression.checkNativeRustConversionMapCollect(this); // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
exports.MatchExpression = MatchExpression;
// end class MatchExpression
// ## FunctionDeclaration
//
// `FunctionDeclaration: 'function [IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`
//
// Functions: parametrized pieces of callable code.
//
class FunctionDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        // manage special keywords like 'pub'
        this.optPub();
        this.req('fn');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        // get parameters declarations
        this.paramsDeclarations = this.opt(FunctionParameters);
        // get the return-type (optional)
        if (this.opt('->')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation);
        }
        // now parse the body
        if (this.owner.lexer.token.value == ";") {
            // just a fn signature declaration (no body)
        }
        else {
            if (this.owner.options.skipFunctionBody) { //do not parse function body
                DelimitedWordList.parse(this, "{", "}");
            }
            else {
                Body.parseIntoChildren(this);
            }
        }
    }
}
exports.FunctionDeclaration = FunctionDeclaration;
// end class FunctionDeclaration
/**
 * [pub mut &] Name,Type and optional assignment
 *
 * Identifier: TypeAnnotation [ = Expression ]
 *
 * */
class VariableDecl extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        // manage special keywords like 'pub' & mut
        this.optPub();
        this.optRef();
        this.optMut();
        this.optDecorators();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        this.lock();
        // if .parent instance of VarStatement
        if (this.parent instanceof LetStatement && RESERVED_WORDS.indexOf(this.name) >= 0) {
            this.sayErr(`"${this.name}" is a reserved word`);
        }
        // optional type annotation
        if (this.opt(':')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation);
        }
        // optional assigned value
        if (this.opt('=')) {
            this.assignedExpression = this.reqClass(Expression);
        }
    }
    toString() {
        return (this.isRef ? "&" : "") + (this.isMut ? "mut " : "") + this.name + (this.typeAnnotation ? this.typeAnnotation.name + ":" : "");
    }
}
exports.VariableDecl = VariableDecl;
// end class VariableDecl
class LetStatement extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('let');
        this.optMut();
        this.lock();
        if (this.opt("(")) { // tuple assignment
            this.keyword = "tuple";
            this.children = this.reqSeparatedList(Identifier, ',', ')');
            // optional assigned value
            if (this.opt('=')) {
                this.children.push(this.reqClass(Expression));
            }
        }
        else {
            this.children = this.reqSeparatedList(VariableDecl, ',', ';');
        }
    }
}
exports.LetStatement = LetStatement;
// ------------------
class FunctionParameters extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        // if we define a list of specific parameters, fuction is no longer variadic
        this.lock();
        this.req('(');
        this.children = this.optSeparatedList(VariableDecl, ',', ')');
    }
    toString() {
        return "(" + this.children.map((c) => c.toString()).join(",") + ")";
    }
} // end class FunctionParameters
exports.FunctionParameters = FunctionParameters;
// ------------------------------------------
class TraitDeclaration extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('trait');
        this.lock();
        this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        // See if there is an inheritance declaration
        if (this.opt(':')) {
            // now a list of references (to other traits, separated by "+", ended by the "{" )
            this.traitAncestors = this.reqSeparatedList(Identifier, '+', '{');
        }
        // Now get the trait body
        this.req("{");
        Body.parseIntoChildren(this);
    }
}
exports.TraitDeclaration = TraitDeclaration;
// end class TraitDeclaration
/**
 * 'return' [Expression]
 * */
class ReturnStatement extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('return');
        this.lock();
        this.optChild(Expression);
    }
}
exports.ReturnStatement = ReturnStatement;
// end class ReturnStatement
// ---------------------------
class IfStatement extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('if');
        this.lock();
        this.conditional = this.reqClass(Expression);
        Body.reqAsChild(this, "then-block"); // first child, then block
        if (this.opt('else')) {
            Body.reqAsChild(this, "else-block"); // second child, optional else block
        }
    }
}
exports.IfStatement = IfStatement;
// end class IfStatement
// ---------------------------
class WhileStatement extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.req('while');
        this.lock();
        this.conditional = this.reqClass(Expression);
        this.req("{");
        Body.parseIntoChildren(this);
    }
    toString() {
        return Function.apply(ASTBase_1.ASTBase.toString, this) + ' ' + this.conditional.name;
    }
}
exports.WhileStatement = WhileStatement;
// end class WhileStatement
// ## Range Expression
class RangeExpression extends ASTBase_1.ASTBase {
    constructor() {
        super(...arguments);
        this.inclusive = false;
    }
    // ---------------------------
    parse() {
        this.reqChild(Expression);
        this.req('..');
        if (this.opt("="))
            this.inclusive = true;
        this.reqChild(Expression);
    }
} // end class RangeExpression
exports.RangeExpression = RangeExpression;
// ## For Statement
class ForStatement extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        // We start with commonn `for` keyword
        this.req('for');
        this.lock();
        this.ident = this.reqClass(IdentifierMaybeTuple);
        this.req('in');
        this.range = this.reqClass(Expression);
        this.req('{');
        Body.parseIntoChildren(this); // first child, then block
    }
} // end class ForStatement
exports.ForStatement = ForStatement;
// -----------------------
// ## Accessors
// `Accessors: (PropertyAccess | FunctionAccess | IndexAccess)`
// Accessors:
// `PropertyAccess: '.' IDENTIFIER`
// `IndexAccess: '[' Expression ']'`
// `FunctionAccess: '('[Expression,] * ')'`
// Accessors can appear after a VariableRef (most common case)
// but also after a String constant, a Regex Constant,
// a ObjectLiteral and a ArrayLiteral
// Examples:
// - `myObj.item.fn(call)`  <-- 3 accesors, two PropertyAccess and a FunctionAccess
// - `myObj[5](param).part`  <-- 3 accesors, IndexAccess, FunctionAccess and PropertyAccess
// - `[1, 2, 3, 4].indexOf(3)` <-- 2 accesors, PropertyAccess and FunctionAccess
// #####Actions:
// `.` -> PropertyAccess: Search the property in the object and in his pototype chain.
// It resolves to the property value
// `[...]` -> IndexAccess: Same as PropertyAccess
// `(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed.
// It resolves to the function return value.
// ## Implementation
// We provide a class Accessor to be super class for the three accessors types.
class Accessor extends ASTBase_1.ASTBase {
    static parseAccessors(node) {
        let accessorFound = true;
        // Loop parsing accessors
        while (accessorFound) {
            if (node.owner.lexer.token.tokenCode == Lexer_1.TokenCode.COMMENT) { // skip comments
                node.owner.lexer.advance();
                continue;
            }
            switch (node.owner.lexer.token.value) {
                case '.': // . => property acceess
                    node.reqChild(PropertyAccess);
                    node.isFunctionCall = false;
                    break;
                case '(': // ( => function access
                    node.reqChild(FunctionAccess);
                    node.isFunctionCall = true; // if the very last accesor is "(", it means the entire expression is a function call
                    node.hasSideEffects = true; // if any accessor is a function call, this statement is assumed to have side-effects
                    break;
                case '[': // [ => array access
                    node.reqChild(IndexAccess);
                    node.isFunctionCall = false;
                    break;
                default:
                    accessorFound = false;
            }
        }
    }
}
exports.Accessor = Accessor;
// end class Accessor
class FunctionAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('(');
        this.lock();
        this.children = this.optSeparatedList(FunctionArgument, ',', ')');
    }
    // ---------------------------
    toString() {
        return '(...)';
    }
    produce() {
        const o = this.owner.codeWriter;
        // function accessor => function call
        o.write("(");
        this.produceChildren(", ");
        o.write(")");
    }
}
exports.FunctionAccess = FunctionAccess;
// end class FunctionAccess
class PropertyAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('.');
        this.lock();
        // check for NumberLiteral  x.0 rust tuple dot-index access. https://stackoverflow.com/questions/32030756/reasons-for-dot-notation-for-tuple
        if (this.owner.lexer.token.tokenCode == Lexer_1.TokenCode.NUMBER) {
            this.keyword = "tuple-index";
            this.extraInfo = this.owner.lexer.token.value;
            this.owner.lexer.advance();
        }
        else {
            // let's assume .field access
            this.name = this.reqToken(Lexer_1.TokenCode.WORD);
        }
    }
    // ---------------------------
    toString() {
        return `.${this.name} `;
    }
    produce() {
        const o = this.owner.codeWriter;
        // function accessor => function call
        o.write(".");
        o.write(this.name);
    }
}
exports.PropertyAccess = PropertyAccess;
// end class PropertyAccess
class IndexAccess extends Accessor {
    // ---------------------------
    parse() {
        this.name = this.req('[');
        this.lock();
        this.reqChild(Expression);
        this.req(']');
    } // ---------------------------
    toString() {
        return '[...]';
    }
    produce() {
        const o = this.owner.codeWriter;
        // function accessor => function call
        o.write("[");
        this.produceChildren();
        o.write("]");
    }
}
exports.IndexAccess = IndexAccess;
// end class IndexAccess
// -----------------------
/**
 * a VarRef can be:
 * 1. A "place" or L-Value, an Identifier with optional Accessors referencig a specific memory location with a type
 * 2. A Function call, returning a value (an R-value)
 *
 * When used in Expressions, both interpretations are used as an R-Value, either by reading the value from the referenced place or executing the function call
 *
 * The property `VarRref.isFunctionCall = true` marks it as a Function Call
 *
 * A VarRef be an "Operand" of "InfixExpression"
 *
 * Examples:
 *      myVar
 *      std::Rand(5)
 *      myData[7]
 *      myData[utils::getIndex(s)]
 *      myStruct.name
 *      myStruct.values[7].price
 *
 * */
class VarRef extends ASTBase_1.ASTBase {
    // ---------------------------
    parse() {
        this.preIncDec = this.optList(['--', '++']);
        this.isFunctionCall = false;
        this.optMut();
        this.optRef();
        this.optDeRef();
        this.name = this.reqClass(Identifier).name;
        this.lock();
        // Now we check for accessors:
        // <br>`.`->**PropertyAccess**
        // <br>`[...]`->**IndexAccess**
        // <br>`(...)`->**FunctionAccess**
        // Note: **.paserAccessors()** will:
        // - set .hasSideEffects=true if a function accessor is parsed
        // - set .isFunctionCall=true if the last accessor is a function accessor
        // .parseAccessors
        Accessor.parseAccessors(this);
        // .postIncDec = .opt('--','++')
        this.postIncDec = this.optList(['--', '++']);
        // If this variable ref has ++ or --, IT IS CONSIDERED a "call to execution" in itself,
        // a "imperative statement", because it has side effects.
        // (`i++` has a "imperative" part, It means: "give me the value of i, and then increment it!")
        if (this.preIncDec || this.postIncDec) {
            this.isFunctionCall = true;
            this.hasSideEffects = true;
        }
    }
    // ---------------------------
    toString() {
        // This method is only valid to be used in error reporting.
        // function accessors will be output as "(...)", and index accessors as [...]
        let result = `${this.preIncDec || ''}${this.name}`;
        if (this.children) {
            for (const ac of this.children) {
                result = `${result}${ac.toString()} `;
            }
        }
        return `${result}${this.postIncDec || ''}`;
    }
}
exports.VarRef = VarRef;
// end class VariableRef
// ##Statement
// A `Statement` is an imperative statment (command) or a control construct.
// The `Statement` node is a generic container for all previously defined statements.
// The generic `Statement` is used to define `Body: (Statement;)`, that is,
//* *Body** is a list of semicolon (or NEWLINE) separated **Statements**.
// Grammar:
// ```
// Statement: [Adjective]* (TraitDeclaration|FunctionDeclaration
// |IfStatement|ForStatement|WhileUntilLoop|DoLoop
// |AssignmentStatement
// |LoopControlStatement|ThrowStatement
// |TryCatch|ExceptionBlock
// |ReturnStatement|PrintStatement|DoNothingStatement)
// Statement: ( AssignmentStatement | fnCall-VariableRef [ ["("] (Expression,) [")"] ] )
// ```
// public class Statement extends ASTBase
// constructor
class Statement {
    // ---------------------------
    /** static Statement.tryParse
     *  try to parse a statement and return the specific node found | throws
     * @param node
     */
    static tryParse(node) {
        node.lock(); // no other option than a statement
        // manage rust attributes (lines starting with #)
        if (node.owner.lexer.token.tokenCode == Lexer_1.TokenCode.ATTRIBUTE) {
            return node.reqClass(LineAttribute);
        }
        // manage special keywords like 'pub'
        const isPublic = (node.opt('pub') == 'pub');
        const key = node.owner.lexer.token.value;
        const resultASTNode = Statement.tryParseByKeyword(node, key);
        resultASTNode.keyword = key;
        resultASTNode.isPublic = isPublic;
        Expression.checkNativeRustConversionMapCollect(resultASTNode); // veo si tiene una llamada a .to_vec() u otra conversi�n
        return resultASTNode;
    }
    static tryParseByKeyword(node, key) {
        // manage rust macros
        if (node.owner.lexer.nextToken().value == '!') { // it's a macro!
            return node.reqClass(MacroInvocation);
        }
        // rust expression as as statement, discarded or returned if it is the last expression in the function
        if (key == '(') { // it's a (Expression-maybeReturn-Statement)
            return node.reqClass(Expression);
        }
        // Now we can look up the keyword in the **StatementsDirect** table, and parse the specific AST node
        const ClassByKeyword = Statement.DirectKeywordMap[key];
        if (ClassByKeyword) {
            // keyword found, use the AST class to parse
            return node.reqClass(ClassByKeyword);
        }
        // if keyword not found in table
        // It's an expression
        return node.reqClass(Expression);
        // let's asume it's a fn call or an assignment statement
        // lets try then to parse a varRef, that could result in a fn-call or in an L-Value for an assignment
        const vr = node.reqClass(VarRef);
        if (vr.isFunctionCall) { // it was a fn call
            return vr;
        }
        // let's see if node is a struct instantiation expression
        // rust's struct instantiation have the form: IDENT ObjectLiteral
        // ObjectLiteral  = '{' [ NameValuePair, ] '}'
        if (node.owner.lexer.token.value == "{") { // let's assume is a Struct Instantiation
            // it's a Struct Instantiation
            const objectLiteral = node.reqClass(ObjectLiteral);
            objectLiteral.name = vr.name;
            objectLiteral.keyword = "struct-instantiation";
            return objectLiteral;
        }
        // it wasn't a function call,
        // if there's an assignmen token => AssignmentStatement
        // else is just an expression-maybe-return-value
        if (node.owner.lexer.token.tokenCode == Lexer_1.TokenCode.OPERATOR) {
            // it's is an AssignmentStatement
            // const assignmentStatement = node.reqClass(AssignmentStatement) as AssignmentStatement
            // assignmentStatement.lvalue = vr //complete the AssignmentStatement L-value with the prevously parsed VarRef
            // return assignmentStatement
        }
        // finally, just a expression
        // the preParsedVarRef is just a R-Value, an expression-maybe-return-value
        return vr;
    }
}
exports.Statement = Statement;
// ----------------------------------------
// Table-based (fast) Statement parsing
// ------------------------------------
// This a extension to PEGs.
// To make the compiler faster and easier to debug, we define an
// object with name-value pairs: `"keyword" : AST node class`
// We look here for fast-statement parsing, selecting the right AST node to call `parse()` on
// based on `token.value`. (instead of parsing by ordered trial & error)
// This table makes a direct parsing of almost all statements, thanks to a core definition of LiteScript:
// Anything standing alone in it's own line, its an imperative statement (it does something, it produces effects).
Statement.DirectKeywordMap = {
    use: UseDeclaration,
    mod: ModDeclaration,
    const: ConstDeclaration,
    static: StaticDeclaration,
    trait: TraitDeclaration,
    type: TypeDeclaration,
    '#': LineAttribute,
    struct: StructDeclaration,
    enum: EnumDeclaration,
    impl: ImplDeclaration,
    fn: FunctionDeclaration,
    let: LetStatement,
    if: IfStatement,
    while: WhileStatement,
    for: ForStatement,
    match: MatchExpression,
    return: ReturnStatement,
};
// end class Statement
// ## Body
// a Body is a (optional)semicolon-separated list of statements (At least one) ending with a "closer", either '}' or EOF
// Body is used for "fn" body, for body, if& else bodies, etc.
// Anywhere a list of semicolon separated statements apply.
/**
 * '{' [Statements;] '}'
 * */
class Body extends ASTBase_1.ASTBase {
    parse() {
        this.req("{");
        this.lock();
        Body.parseIntoChildren(this);
    }
    // ---------------------------
    produce() {
        this.produceBody(4);
    }
    // ---------------------------
    static reqAsChild(parent, name = "Body") {
        const newBlock = parent.reqClass(Body);
        newBlock.name = name;
        parent.children.push(newBlock);
    }
    // ---------------------------
    static optIntoChildren(node, closer = "}") {
        if (node.opt("{")) {
            Body.parseIntoChildren(node, closer);
        }
    }
    // ---------------------------
    static parseIntoChildren(node, closer = "}") {
        node.lock();
        // We accept statements and comments as items in the body
        // A Body is a list of Statements|LineComments separated by *semicolon* and, closed by "}"
        const separator = ';';
        logger.debug(`Body for ${node.constructor.name}: get LineComments & Statements separated by '${separator}' closer:`, closer || ' to EOF');
        while (true) {
            node.owner.lexer.skipWhiteSpaceAndNewLine();
            // pre comments and attrs
            const preComments = [];
            node.owner.lexer.consumeCommentsAndAttr(preComments);
            if (node.owner.lexer.token.tokenCode == Lexer_1.TokenCode.EOF)
                break; // break on EOF
            if (closer && node.opt(closer))
                break; // on closer:'}', break - end of body, (a single extra separator before closer is allowed)
            if (logger.debugFrom && node.owner.lexer.token.line > logger.debugFrom)
                logger.setDebugLevel(1);
            if (logger.debugTo && node.owner.lexer.token.line > logger.debugTo)
                logger.setDebugLevel(0);
            // -----------------------
            // here we assume it's a Statement
            // Statement.tryParse will return the right AST class parsed
            const statement = Statement.tryParse(node);
            // attach pre-comments to the statement
            statement.commentsAndAttr = preComments;
            // keep a dict of declaredStructs in order to be able to recognize struct instantiation
            // (there's no keyword in a struct instantiation, just the struct's name | Self)
            if (statement instanceof StructDeclaration) {
                node.owner.declaredStructs[statement.name] = statement;
            }
            // add post comments and attr - NO, se come precomments del sieguiente after a struct { }
            // node.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr)
            node.children.push(statement);
            if (node.opt(closer))
                break; // if closer '}' found here, break - end of body
            // special case: check if now comes a separator (;) followed of a comment on the same line...
            statement.attachedComment = node.owner.lexer.getAttachedCommentAfter(separator);
            if (statement.attachedComment) {
                // keep the comments atttached to the statement
                continue; // Next sentence, separator found and consumed
            }
            // if the statement had a body defined by { }, or the statemente consumend the separator ";" -- it's OK
            if (node.owner.lexer.token.value != separator) {
                // allow exceptions, separator is not required
                continue;
            }
            // if there is a 'separator' (semicolon), let's consume it
            node.owner.lexer.semiNotRequired = false;
            node.req(separator);
        } // try another item after the separator
        logger.debug(`End Body on '${closer}'`);
        if (closer == '}')
            node.owner.lexer.semiNotRequired = true; // no need for a semicolon if closed by '}'
    }
}
exports.Body = Body;
// end class Body
// ## Module
// The `Module` represents a complete source file.
class ASTModule extends ASTBase_1.ASTBase {
    // ------------
    constructor(owner, filename) {
        super(null, filename);
        this.dependencyTreeLevel = 0;
        this.dependencyTreeLevelOrder = 0;
        this.importOrder = 0;
        this.owner = owner;
    }
    parse() {
        const closer = undefined; // parse until EOF
        Body.parseIntoChildren(this, closer);
    }
}
exports.ASTModule = ASTModule;
//# sourceMappingURL=Grammar.js.map
'''
'''--- dist/lib/Parser/Parser.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const Lexer_1 = require("../Lexer/Lexer");
const Grammar_1 = require("./Grammar");
class Parser {
    constructor(options) {
        // declaredStructs = new Map<string, StructDeclaration>()
        this.declaredStructs = {};
        this.options = options;
    }
    /**
     * creates the AST
     * returns Root Node: type Module
     * */
    parse(lexer) {
        this.lexer = lexer;
        const ASTRoot = new Grammar_1.ASTModule(this, lexer.filename);
        ASTRoot.parse();
        return ASTRoot;
    }
    parseFile(filename) {
        const lexer = new Lexer_1.Lexer();
        lexer.openFile(filename);
        return this.parse(lexer);
    }
}
exports.Parser = Parser;
//# sourceMappingURL=Parser.js.map
'''
'''--- dist/lib/util/CommandLineArgs.js ---
"use strict";
/**
 #Simple and minimum command line args parser
 *
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args.
 *    --Note:  spaces *must* be used around { and }
 *

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandLineArgs = exports.ShowHelpPage = exports.ShowHelpOptions = void 0;
const path_1 = require("path"); // host OS path separator
const util_1 = require("util");
const color = require("./color.js");
// ----------------------------------------------------
// construct and show help page based on valid options
// ----------------------------------------------------
function ShowHelpOptions(optionsDeclaration) {
    // show help about declared options
    console.log();
    console.log("-".repeat(60));
    console.log("Options:");
    for (const key in optionsDeclaration) {
        let line = "";
        const opt = optionsDeclaration[key];
        let text = "--" + key;
        if (opt.valueType)
            text = text + " " + opt.valueType;
        if (opt.shortName) {
            text = text + ", -" + opt.shortName;
            if (opt.valueType)
                text = text + " " + opt.valueType;
        }
        line = `  ${text}`.padEnd(50) + (opt.helpText ? opt.helpText : "");
        console.log(line);
    }
    console.log("-".repeat(60));
}
exports.ShowHelpOptions = ShowHelpOptions;
// ----------------------------------------------------
// construct and show a help page based on the API for the commands
// ----------------------------------------------------
function ShowHelpPage(command, contractAPI, optionsDeclaration) {
    const commandsHelp = {};
    // check all functions in the ContractAPI class, except the class constructor
    const methodNames = Object.getOwnPropertyNames(contractAPI.__proto__)
        .filter(name => name !== "constructor" && (command === "" || name === command)); // filter requested command
    // populate commandsHelp
    methodNames.forEach((value) => commandsHelp[value] = "");
    // see which functions have proper help text
    // check all *_help string items in the ContractAPI class
    const properHelpStrings = Object.getOwnPropertyNames(contractAPI);
    for (const item of properHelpStrings) {
        if (item.endsWith("_help") && typeof contractAPI[item] === "string") {
            const method = item.replace("_help", "");
            if (command === "" || command == method) { // filter the requested help
                commandsHelp[method] = contractAPI[item]; // add proper help
            }
        }
    }
    // print all commands and their help if it's there
    for (const key in commandsHelp) {
        console.log("-".repeat(60));
        console.log('command: ' + key); // name the command
        console.log(commandsHelp[key]); // print the help
    }
    ShowHelpOptions(optionsDeclaration);
}
exports.ShowHelpPage = ShowHelpPage;
// --------------------------
// --  main exported class --
// --------------------------
class CommandLineArgs {
    constructor(options) {
        this.clArgs = process.argv;
        this.optDeclarations = options;
        this.positional = [];
        // remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node' ||
            this.clArgs[0].endsWith(path_1.sep + 'node')) ||
            this.clArgs[0].endsWith(path_1.sep + 'node.exe')) {
            this.clArgs = this.clArgs.slice(1);
        }
        // remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1);
        // process each item separating options from posiitonal args
        // First: process --options
        for (const key in options) {
            const optionDecl = options[key];
            // search for option name & variations
            const pos = this.searchOption(optionDecl);
            if (pos >= 0) { // found in command line args
                const literal = this.clArgs[pos]; // as written
                this.clArgs.splice(pos, 1); // remove from cl args
                if (optionDecl.valueType) { // has a value
                    if (pos >= this.clArgs.length) {
                        color.logErr("expecting value after " + literal);
                        process.exit(1);
                    }
                    const value = this.clArgs[pos]; // take value
                    options[key].value = value; // set value
                    this.clArgs.splice(pos, 1); // also remove value from list
                }
                else // valueless option
                 {
                    options[key].value = true; // set as present
                }
            }
        }
        // if at this point there are still --options in the command line args array, those are unknown options
        let hasErrors = false;
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                color.logErr("UNKNOWN option: " + item);
                hasErrors = true;
            }
        }
        if (hasErrors) {
            ShowHelpOptions(options);
            process.exit(1);
        }
        // create consumible positional arguments, parsing also JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index];
            if (item == "{") { // a JSON object in the command line
                const extracted = this.extractJSONObject(index);
                this.positional.push(extracted.value);
                index = extracted.end;
            }
            else {
                this.positional.push(item);
            }
        }
    }
    /**
     * When the first argument is the command to execute
     * returns "" if there's no arguments
     */
    getCommand() {
        if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            color.logErr("expected a command as first argument'");
            process.exit(1);
        }
        else {
            if (this.positional.length === 0)
                return "";
            // take the first argument as this.command
            return this.positional.shift();
        }
    }
    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which) {
        if (this.positional.length == 0)
            return false;
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected a string argument, got {... }`);
            process.exit(1);
        }
        if (this.positional[0] == which) {
            this.positional.shift(); // consume
            return true;
        }
        return false; // not the expected string
    }
    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected '${name}' argument`);
            process.exit(1);
        }
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected ${name} string argument, got {... }`);
            process.exit(1);
        }
        return this.positional.shift();
    }
    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name, units) {
        const value = this.consumeString(name);
        return this.convertAmount(value, units, name);
    }
    /**
     * requires a JSON as the next positional arg
     * @param name
     */
    consumeJSON(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected ${name} as { }`);
            process.exit(1);
        }
        if (typeof this.positional[0] === "string") {
            color.logErr(`expected ${name} as {... } got a string: '${this.positional[0]}'`);
            process.exit(1);
        }
        return this.positional.shift();
    }
    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs() {
        if (this.positional.length) {
            color.logErr(`unrecognized extra arguments`);
            console.log(util_1.inspect(this.positional));
            process.exit(1);
        }
    }
    findDeclarationKey(opt) {
        for (const key in this.optDeclarations) {
            if (opt.shortName && this.optDeclarations[key].shortName == opt.shortName)
                return key;
            if (opt.helpText && this.optDeclarations[key].helpText == opt.helpText)
                return key;
        }
        throw new Error("shortName|helpText not found in declarations: " + util_1.inspect(opt));
    }
    /**
     * requires the presence of an option with a string value
     * @param optionName option name
     */
    requireOptionString(opt) {
        if (opt.value == undefined || opt.value == "" || opt.value == {}) {
            const key = this.findDeclarationKey(opt);
            color.logErr(`required --${key}`);
            process.exit(1);
        }
    }
    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(opt, units) {
        const value = opt.value.toString().trim();
        const key = this.findDeclarationKey(opt);
        if (!value) {
            color.logErr(`required --${key} [number]`);
            process.exit(1);
        }
        const converted = this.convertAmount(value, units, key);
        opt.value = converted; // store in the required units
    }
    /**
     * search for the presence of an option
     * removes it from the options if found
     *
     * @param optionName option name
     */
    consumeOption(opt, defaultValue) {
        const value = opt.value;
        if (value) { // found
            opt.value = undefined; // remove from options (consume)
        }
        return value;
    }
    /**
     * add options found in command line to nearCliArgs for near-cli
     * @param spawnProcessArgs prepared array for spawning anothe cli tool
     */
    addOptionsTo(spawnProcessArgs) {
        // for each option
        for (const key in this.optDeclarations) {
            const opt = this.optDeclarations[key];
            const value = opt.value;
            if (value) { // if it was set
                spawnProcessArgs.push("--" + key); // add option presence
                if (opt.valueType) { // if the option included a value
                    spawnProcessArgs.push(opt.value); // add option value
                }
            }
        }
    }
    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     *
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value, requiredUnits, name) {
        let result;
        name = color.yellow + name + color.normal;
        if (value.length > 1 && value.endsWith("N")) { // NEARS
            result = value.slice(0, -1); // remove N
            result = result.replace("_", ""); // allow 100_000_000, ignore _
            if (requiredUnits == "N")
                return result; // already in Nears
            // Yoctos required -- convert to yoctos
            const parts = result.split(".");
            if (parts.length > 2) {
                color.logErr(name + ": invalid amount format, too many decimal points: " + value);
                process.exit(1);
            }
            if (parts.length == 1)
                parts.push(""); // .0
            const decimalString = parts[1].padEnd(24, '0');
            result = parts[0] + "" + decimalString; // +""+ is for making sure + means concat here
            return result;
        }
        else if (value.length > 1 && value.endsWith("Y")) { // YOCTOS
            if (value.includes(".")) {
                color.logErr(name + ": invalid amount format, YOCTOS can't have decimals: " + value);
                process.exit(1);
            }
            result = value.slice(0, -1); // remove Y
            result = result.replace("_", ""); // allow 100_000_000, ignore _
            if (requiredUnits == "Y")
                return result; // already in Yoctos
            // NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24);
            }
            else {
                // insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24);
            }
            return result;
        }
        else {
            color.logErr(name + ": invalid amount format, expecting [0-9.](Y|N). Received: " + value);
            console.log("valid examples are: 0.5N | 100N | 100_000_000Y");
            process.exit(1);
        }
    }
    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    extractJSONObject(start) {
        var _a, _b;
        // find the closing "}"
        let opened = 1;
        let end = -1;
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n];
            if (item == "{") {
                opened++;
            }
            else if (item == "}") {
                opened--;
                if (opened == 0) {
                    end = n;
                    break;
                }
            }
        }
        if (end == -1) { // unmatched opener error
            color.logErr("Unmatched '{' . remember to put spaces around { and }");
            this.clArgs[start] = color.yellow + "{" + color.normal;
            console.log(this.clArgs.join(" "));
            process.exit(1);
        }
        // Here we have start & end for matching { }
        const resultObj = {};
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index];
            let propValue;
            if (propName == ",")
                continue;
            if ("{}".includes(propName)) {
                color.logErr("expected name:value");
                this.clArgs[index] = color.yellow + propName + color.normal;
                console.log(this.clArgs.slice(start, end + 1).join(" "));
                process.exit(1);
            }
            const parts = propName.split(":");
            if (parts.length > 2) {
                color.logErr(` too many ':' (found ${parts.length - 1}) at ${propName}`);
                process.exit(1);
            }
            propName = (_a = parts[0]) === null || _a === void 0 ? void 0 : _a.trim();
            propValue = (_b = parts[1]) === null || _b === void 0 ? void 0 : _b.trim();
            if (propValue == undefined || propValue == "") {
                // let's assume the user typed "name: value" instead of "name:value"
                index++; // take the next arg
                propValue = this.clArgs[index];
                if (propValue.endsWith(":")) {
                    color.logErr(` missing value after ':' for ${propName}`);
                }
                if (index >= end || propValue == "}") {
                    console.log(`ERROR: expected value after ${propName}`);
                    process.exit(1);
                }
            }
            if (propValue == "{") { // subornidated object
                const subObj = this.extractJSONObject(index); // recursive***
                // store as object
                resultObj[propName] = subObj.value;
                index = subObj.end; // skip internal object
                continue;
            }
            // it's a string
            // remove ending "," if it's there
            if (propValue.endsWith(","))
                propValue = propValue.slice(0, propValue.length - 1);
            // check if it's a number
            if (propValue.slice(0, 1).match(/[0-9]/)) { // starts with a digit
                if (propValue.endsWith("N")) { // amount in nears
                    propValue = this.convertAmount(propValue, "Y", propName); // convert to yocto
                }
                else if (propValue.endsWith("Y")) { // amount in yocto
                    propValue = propValue.slice(0, -1);
                    propValue = propValue.replace("_", ""); // just remove _'s
                }
            }
            // store
            resultObj[propName] = propValue;
        } // end for
        // return positions and composed object
        return { start: start, end: end, value: resultObj };
    }
    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */
    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */
    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    searchOption(option) {
        const name = this.findDeclarationKey(option);
        const shortName = option.shortName;
        // search several possible forms of the option, e.g. -o --o -outdir --outdir
        const variants = ['-' + name, '--' + name];
        if (shortName) {
            variants.push('--' + shortName, '-' + shortName);
        }
        // for each item in list
        for (const variant of variants) {
            const inx = this.clArgs.indexOf(variant);
            if (inx >= 0) {
                return inx; // found
            }
        }
        return -1; // not found
    }
}
exports.CommandLineArgs = CommandLineArgs;
// end class CommandLineArgs
//# sourceMappingURL=CommandLineArgs.js.map
'''
'''--- dist/lib/util/ControlledError.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlledError = void 0;
class ControlledError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.ControlledError = ControlledError;
//# sourceMappingURL=ControlledError.js.map
'''
'''--- dist/lib/util/String.extensions.js ---
// utils.ts
// ## utility methods
String.prototype.replaceAll = function (searched, newStr) {
    return searched.replace(new RegExp(searched, 'g'), newStr);
};
String.prototype.quoted = function (quoteChar) {
    return `${quoteChar}${this}${quoteChar}`;
};
String.prototype.countSpaces = function () {
    // var inx=0
    let inx = 0;
    // while inx<this.length
    while (inx < this.length) {
        // if this.charAt(inx) isnt ' ', break
        if (this.charAt(inx) !== ' ') {
            break;
        }
        // inx++
        inx++;
    } // end loop
    // return inx
    return inx;
};
/*
//Helper methods to class String.
//Also add 'remove' & 'clear' to class Array

    //    append to class String

        //shim method startsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'startsWith'))
        startsWith = function(text){
            //return this.slice(0, text.length) is text
            return this.slice(0, text.length) === text;
        };

        //shim method endsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'endsWith'))
        endsWith = function(text){
            //return this.slice(-text.length) is text
            return this.slice(-text.length) === text;
        };

        //shim method trimRight()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimRight'))
        trimRight = function(){
            //if no this.length into var inx, return this //empty str
            var inx:=undefined
            if (!((inx=this.length))) {return this};
            //do
            do{

                //inx--
                inx--;
            } while (inx >= 0 && this.charAt(inx) === ' ');// end loop
            //return this.slice(0,inx+1)
            return this.slice(0, inx + 1);
        };

        //shim method trimLeft()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimLeft'))
        trimLeft = function(){
            //if no this.length into var len, return this
            var len:=undefined
            if (!((len=this.length))) {return this};
            //var inx=0
            var inx = 0;
            //while inx<len and this.charAt(inx) is ' '
            while(inx < len && this.charAt(inx) === ' '){
                //inx++
                inx++;
            };// end loop
            //return this.slice(inx)
            return this.slice(inx);
        };

//.capitalized

        //method capitalized returns string
        // ---------------------------
        capitalized = function(){
           //if this, return "#{this.charAt(0).toUpperCase()}#{this.slice(1)}"
           if (this) {return `${this.charAt(0).toUpperCase()}#{this.slice(1)}`};
        };

//.replaceAll, equiv. to .replace(/./g, newStr)

        //shim method replaceAll(searched,newStr)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'replaceAll'))
        replaceAll = function(searched, newStr){
           //return this.replace(new RegExp(searched,"g"), newStr)
           return this.replace(new RegExp(searched, 'g'), newStr);
        };

//.countSpaces()

        //shim method countSpaces()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'countSpaces'))
        countSpaces = function(){
            //var inx=0
            var inx = 0;
            //while inx<this.length
            while(inx < this.length){
                //if this.charAt(inx) isnt ' ', break
                if (this.charAt(inx) !== ' ') {break};
                //inx++
                inx++;
            };// end loop

            //return inx
            return inx;
        };

//.quoted(quotechar)

        //method quoted(quoteChar)
        // ---------------------------
        quoted = function(quoteChar){
            //return '#{quoteChar}#{this}#{quoteChar}'
            return `${quoteChar}#{this}#{quoteChar}`;
        };

        //shim method rpad(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'rpad'))
        rpad = function(howMany){
            //return .concat(String.spaces(howMany-.length))
            return this.concat(String.spaces(howMany - this.length));
        };

//repeat(howMany)

        //shim method repeat(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'repeat'))
        repeat = function(howMany){
            //if howMany<=0, return ''
            if (howMany <= 0) {return ''};

            //var a=''
            var a = '';
            //while howMany--
            while(howMany--){
                //a &= this
                a += this;
            };// end loop

            //return a
            return a;
        };

    //    append to namespace String

//Checks if a name is Capitalized, unicode aware.
//capitalized is like: /^[A-Z]+[$_a-z0-9]+$/ ,but unicode aware.

        //method isCapitalized(text:string) returns boolean
        // ---------------------------
        isCapitalized = function(text){
            //if text and text.charAt(0) is text.charAt(0).toUpperCase()
            if (text && text.charAt(0) === text.charAt(0).toUpperCase()) {

                //if text.length is 1, return true;
                if (text.length === 1) {return true};

                //for n=1 while n<text.length
                for( var n=1; n < text.length; n++) {
                    //if text.charAt(n) is text.charAt(n).toLowerCase(), return true
                    if (text.charAt(n) === text.charAt(n).toLowerCase()) {return true};
                };// end for n

            };

            //return false
            return false;
        };

//String.findMatchingPair(text,start,closer).
//Note: text[start] MUST be the opener char

        //method findMatchingPair(text:string, start, closer)
        // ---------------------------
        findMatchingPair = function(text, start, closer){
            //var opener=text.charAt(start);
            var opener = text.charAt(start);
            //var opencount=1;
            var opencount = 1;
            //for n=start+1 while n<text.length
            for( var n=start + 1; n < text.length; n++) {
                //if text.charAt(n) is closer and --opencount is 0
                if (text.charAt(n) === closer && --opencount === 0) {

                    //return n
                    return n;
                }
                //if text.charAt(n) is closer and --opencount is 0

                else if (text.charAt(n) === opener) {

                    //opencount++
                    opencount++;
                };
            };// end for n

            //return -1
            return -1;
        };

    //    append to class Array

//method .remove(element)

        //shim method remove(element)  [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'remove'))
        Object.defineProperty(
        ,'remove',{value:function(element){

            //if this.indexOf(element) into var inx >= 0
            var inx:=undefined
            if ((inx=this.indexOf(element)) >= 0) {

                 //return this.splice(inx,1)
                 return this.splice(inx, 1);
            };
        }
        ,enumerable:false
        });

        //shim method clear       [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'clear'))
        Object.defineProperty(
        ,'clear',{value:function(){
            //empty the array
            //for n=1 to .length
            var _end7=this.length;
            for( var n=1; n<=_end7; n++) {
                //.pop
                this.pop();
            };// end for n

        }
        ,enumerable:false
        });

//##Console group

    //    append to namespace console

//Note: Today, Node.js "console" object do not have `group` & `groupEnd` methods
//neither do older browsers

        //properties indentLevel

        //properties indentLevel

        //shim method group()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'group'))
        group = function(){
            //console.log.apply undefined,arguments
            console.log.apply(undefined, Array.prototype.slice.call(arguments));
            //console.indentLevel = console.indentLevel or 0 + 1
            console.indentLevel = console.indentLevel || 0 + 1;
        };

        //shim method groupEnd()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'groupEnd'))
        groupEnd = function(){
            //if console.indentLevel
            if (console.indentLevel) {

                //console.indentLevel--
                console.indentLevel--;
            };
        };
// -----------
// Module code
// -----------
// end of module
*/
//# sourceMappingURL=String.extensions.js.map
'''
'''--- dist/lib/util/UTF8FileReader.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UTF8FileReader = void 0;
// --------------------
// UTF8FileReader
// --------------------
const fs = require("fs");
const string_decoder_1 = require("string_decoder");
class UTF8FileReader {
    constructor() {
        this.isOpen = false;
    }
    /**
     * open the file | throw
     * @param filename
     */
    open(filename, chunkSize = 16 * 1024) {
        this.chunkSize = chunkSize;
        try {
            this.fd = fs.openSync(filename, 'r');
        }
        catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString());
        }
        this.filename = filename;
        this.isOpen = true;
        this.readBuffer = Buffer.alloc(this.chunkSize);
        this.readFilePos = 0;
        // a StringDecoder is a buffered object that ensures complete UTF-8 multibyte decoding from a byte buffer
        this.utf8decoder = new string_decoder_1.StringDecoder('utf8');
    }
    /**
     * read another chunk from the file
     * return the decoded UTF8 into a string
     * (or throw)
     * */
    readChunk() {
        let decodedString = ''; // return '' by default
        if (!this.isOpen) {
            return decodedString;
        }
        let readByteCount;
        try {
            readByteCount = fs.readSync(this.fd, this.readBuffer, 0, this.chunkSize, this.readFilePos);
        }
        catch (e) {
            throw new Error("reading " + this.filename + ", error:" + e.toString());
        }
        if (readByteCount) {
            // some data read, advance readFilePos
            this.readFilePos += readByteCount;
            // get only the read bytes (if we reached the end of the file)
            const onlyReadBytesBuf = this.readBuffer.slice(0, readByteCount);
            // correctly decode as utf8, and store in decodedString
            // yes, the api is called "write", but it decodes a string - it's a write-decode-and-return the string kind-of-thing :)
            decodedString = this.utf8decoder.write(onlyReadBytesBuf);
        }
        else {
            // read returns 0 => all bytes read
            this.close();
        }
        return decodedString;
    }
    close() {
        if (!this.isOpen) {
            return;
        }
        fs.closeSync(this.fd);
        this.isOpen = false;
        this.utf8decoder.end();
    }
}
exports.UTF8FileReader = UTF8FileReader;
//# sourceMappingURL=UTF8FileReader.js.map
'''
'''--- dist/lib/util/UTF8FileWriter.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UTF8FileWriter = void 0;
// --------------------
// UTF8FileReader
// --------------------
const fs = require("fs");
class UTF8FileWriter {
    constructor() {
        this.isOpen = false;
        this.indent = 0;
    }
    /**
     * open the file | throw
     * @param filename
     */
    open(filename) {
        try {
            this.fd = fs.openSync(filename, 'w');
        }
        catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString());
        }
        this.filename = filename;
        this.isOpen = true;
    }
    /**
     * write text to the file
     * (or throw)
     * */
    write(s) {
        if (!this.isOpen) {
            throw new Error(this.filename + " is closed.");
        }
        try {
            fs.writeSync(this.fd, s);
        }
        catch (e) {
            throw new Error("writing to " + this.filename + ", error:" + e.toString());
        }
    }
    writeLine(s) {
        this.write(' '.repeat(this.indent) + s + '\n');
    }
    close() {
        if (!this.isOpen) {
            return;
        }
        fs.closeSync(this.fd);
        this.isOpen = false;
    }
}
exports.UTF8FileWriter = UTF8FileWriter;
//# sourceMappingURL=UTF8FileWriter.js.map
'''
'''--- dist/lib/util/color.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.greenOK = exports.logErr = exports.action = exports.green = exports.yellow = exports.red = exports.normal = void 0;
exports.normal = '\x1b[39;49m';
exports.red = '\x1b[91m';
exports.yellow = '\x1b[93m';
exports.green = '\x1b[32m';
function action(msg) {
    process.stdout.write(msg.padEnd(60, "."));
}
exports.action = action;
function logErr(text) {
    console.error(exports.red + "ERR: " + text + exports.normal);
}
exports.logErr = logErr;
function greenOK() {
    console.log(exports.green + ": OK" + exports.normal);
}
exports.greenOK = greenOK;
//# sourceMappingURL=color.js.map
'''
'''--- dist/lib/util/logger.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwControlled = exports.getMessages = exports.extra = exports.info = exports.msg = exports.warning = exports.error = exports.debugGroupEnd = exports.debugGroup = exports.debug = exports.setDebugRange = exports.setDebugLevel = exports.debugTo = exports.debugFrom = exports.debugLevel = exports.messages = exports.warningCount = exports.warningLevel = exports.errorCount = exports.verboseLevel = exports.storeMessages = void 0;
const color = require("./color.js");
const ControlledError_js_1 = require("./ControlledError.js");
exports.verboseLevel = 1;
exports.errorCount = 0;
exports.warningLevel = 0;
exports.warningCount = 0;
exports.messages = [];
exports.debugLevel = 0;
exports.debugFrom = 0;
exports.debugTo = 0;
function setDebugLevel(level) {
    exports.debugLevel = level;
}
exports.setDebugLevel = setDebugLevel;
function setDebugRange(fromLine, toLine) {
    exports.debugFrom = fromLine;
    exports.debugTo = toLine || 0;
}
exports.setDebugRange = setDebugRange;
//     method debug
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function debug(...args) {
    if (exports.debugLevel) {
        console.error(...args);
    }
}
exports.debug = debug;
//     method debugGroup
// ---------------------------
function debugGroup(...args) {
    if (exports.debugLevel) {
        console.error(...args);
        console.group(...args);
    }
}
exports.debugGroup = debugGroup;
//     method debugGroupEnd
// ---------------------------
function debugGroupEnd() {
    if (exports.debugLevel) {
        console.groupEnd();
    }
}
exports.debugGroupEnd = debugGroupEnd;
//     method error
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function error(...args) {
    exports.errorCount++;
    // add "ERROR:", send to debug logger
    args.unshift('ERROR:');
    debug(...args);
    // if messages should be stored...
    if (exports.storeMessages) {
        exports.messages.push(args.join(' '));
    }
    else {
        args.unshift(color.red);
        args.push(color.normal);
        console.error.apply(args.join(' '));
    }
}
exports.error = error;
//     method warning
// ---------------------------
function warning(...args) {
    exports.warningCount++;
    args.unshift('WARNING:');
    debug(...args);
    if (exports.warningLevel > 0) {
        // if messages should be stored...
        if (exports.storeMessages) {
            exports.messages.push(args.join(' '));
        }
        else {
            args.unshift(color.yellow);
            args.push(color.normal);
            console.error(args.join(' '));
        }
    }
}
exports.warning = warning;
//     method msg
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function msg(...args) {
    debug(...args);
    if (exports.verboseLevel >= 1) {
        // if messages should be stored...
        if (exports.storeMessages) {
            exports.messages.push(args.join(' '));
        }
        else {
            console.log(...args);
        }
    }
}
exports.msg = msg;
//     method info
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function info(...args) {
    if (exports.verboseLevel >= 2) {
        // msg.apply(undefined,args)
        msg(...args);
    }
}
exports.info = info;
//     method extra
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function extra(...args) {
    if (exports.verboseLevel >= 3) {
        msg(...args);
    }
}
exports.extra = extra;
//     method getMessages
// ---------------------------
function getMessages() {
    // get & clear
    const result = exports.messages;
    exports.messages = [];
    return result;
}
exports.getMessages = getMessages;
//     method throwControlled(msg)
// ---------------------------
function throwControlled(errorMsg) {
    // Throws Error, but with a "controlled" flag set,
    // to differentiate from unexpected compiler errors
    debug('Controlled ERROR:', errorMsg);
    throw new ControlledError_js_1.ControlledError(errorMsg);
}
exports.throwControlled = throwControlled;
//# sourceMappingURL=logger.js.map
'''
'''--- dist/lib/util/mkPath.js ---
"use strict";
// Generated by LiteScript compiler v0.8.9, source: lib/mkPath.lite.md
// -----------
// Module Init
// -----------
//= ============
Object.defineProperty(exports, "__esModule", { value: true });
exports.dirExists = exports.create = exports.toFile = void 0;
// import fs, path
const fs = require("fs");
const path = require("path");
// ---------------------------
// mkPath.toFile
// ---------------------------
function toFile(filename) {
    // Create a path to a file
    create(path.dirname(filename));
}
exports.toFile = toFile;
// ---------------------------
// mkPath.create(dirPath)
// ---------------------------
function create(dirPath) {
    // Make sure a path exists - Recursive
    if (dirExists(dirPath)) {
        return;
    } // ok! dir exists
    // else... recursive:
    // try a folder up, until a dir is found (or an error thrown)
    create(path.dirname(dirPath)); // recurse
    // ok, found parent dir! - make the children dir
    fs.mkdirSync(dirPath);
    // return into recursion, creating children subdirs in reverse order (of recursion)
}
exports.create = create;
//    helper function dirExists(dirPath)
// ---------------------------
function dirExists(dirPath) {
    try {
        if (fs.statSync(dirPath).isDirectory()) {
            return true; // ok! exists and is a directory
        }
        else {
            throw new Error(`${dirPath} exists but IT IS NOT a directory`);
        }
    }
    catch (err) {
        // if dir does not exists, return false
        if (err.code === 'ENOENT') {
            return false;
        }
        throw err; // another error
    }
}
exports.dirExists = dirExists;
//# sourceMappingURL=mkPath.js.map
'''
'''--- dist/main/CLIOptions.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.options = void 0;
exports.options = {
    contractName: {
        shortName: "c",
        helpText: `AccountId where the contract is deployed`,
        valueType: "string",
        value: ""
    },
    accountId: {
        shortName: "acc",
        valueType: "string",
        value: "",
        helpText: `default user accountId, sets signer`
    },
    help: {
        shortName: "h",
        value: false
    },
    verbose: {
        shortName: "v",
        helpText: 'Prints out verbose output',
        value: false
    },
    networkId: {
        shortName: "net",
        helpText: 'default NEAR network ID for the cli-tool being created (defaults to NODE_ENV)',
        valueType: "string",
        value: ""
    },
    output: {
        shortName: "o",
        valueType: "string",
        helpText: `output path (Default .)`,
        value: "."
    },
    nolink: {
        shortName: "nl",
        helpText: `do not run npm link after creation`,
        value: false
    }
};
//# sourceMappingURL=CLIOptions.js.map
'''
'''--- dist/main/ContractAPI-producer.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractAPIProducer = exports.IfStatementWriter = exports.RustClosureWriter = exports.FunctionArgumentWriter = exports.ObjectLiteralWriter = exports.VarRefWriter = exports.LetStatementWriter = exports.ParenExpressionWriter = exports.ExpressionWriter = exports.VarDeclWriter = exports.TypeAnnotationWriter = void 0;
const Grammar = require("../lib/Parser/Grammar");
const CodeWriter_1 = require("../lib/Parser/CodeWriter");
const logger = require("../lib/util/logger");
// let globalTestFlag = false; //if the rust fn is decorated with "#[test]
// let debugProduceLineNumbers = false
class ASTModuleWriter extends Grammar.ASTModule {
    produce() {
        const o = this.owner.codeWriter;
        o.writeLine(`
    // ----------------------------------------------
    // generated by create-contract-cli from ${this.owner.lexer.filename}
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    `);
        o.indent += 2;
        o.newLine();
        let mainImpl;
        // look for main Impl (the one with #[init])
        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                for (const fns of implDecl.children) {
                    if (fns.commentsAndAttr.includes("#[init]")) {
                        mainImpl = implDecl;
                    }
                }
            }
        }
        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                if (mainImpl !== undefined && implDecl !== mainImpl) {
                    continue;
                }
                else {
                    // produce children of main impl
                    for (const child of implDecl.children) {
                        child.produce();
                        o.newLine();
                    }
                }
            }
        }
        o.indent -= 2;
        o.newLine();
        o.writeLine(`}`);
        o.writeLine(`module.exports = ContractAPI;`);
    }
}
Grammar.ASTModule.prototype.produce = ASTModuleWriter.prototype.produce;
class EmptyProducer extends Grammar.Statement {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    produce() {
    }
}
Grammar.ImplDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.StructDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.StaticDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.UseDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.ModDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.ConstDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.TypeDeclaration.prototype.produce = EmptyProducer.prototype.produce;
Grammar.MacroInvocation.prototype.produce = EmptyProducer.prototype.produce;
Grammar.MatchExpression.prototype.produce = EmptyProducer.prototype.produce;
class FunctionDeclarationWriter extends Grammar.FunctionDeclaration {
    produceContractAPI() {
        const o = this.owner.codeWriter;
        if (!this.isPublic) {
            // o.writeLine(`NON-PUB fn ${this.name}`) //debug
            return; // only pub fns are part of the ContractAPI
        }
        const fnName = this.name;
        let isView = true;
        if (fnName == 'new') {
            // always !isVew, doesn't have &[mut] self
            isView = false;
        }
        else {
            const selfParam = this.paramsDeclarations.children[0];
            // pub fn(&mut self) are "calls" -- alter state
            // pub fn(&self) are views -- do not alter state
            isView = !(selfParam.isMut);
        }
        if (isView && this.commentsAndAttr.includes("#[init]")) {
            // it's the init/new pub fn
            isView = false;
        }
        logger.debug(">>> " + (isView ? "[view]" : "[call]") + " pub fn " + fnName + this.paramsDeclarations.toString());
        // output pub fn comments
        // this.writeComments() -- no, they're include in the help string
        o.writeLine(`${fnName}_HELP(){ return \``); // start help declaration
        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (let s of this.commentsAndAttr) {
                while (s.startsWith("/"))
                    s = s.slice(1); // remove starting //
                if (s.endsWith("/"))
                    s = s.slice(0, s.length - 1); // remove ending /
                o.writeLine(s.replace(/`/g, "'"));
            }
        }
        o.blankLine();
        // construct usage example from pub fn params
        let argsDecl = "";
        const hasJSONArguments = this.paramsDeclarations.children.length > 1; // 1st = 'self'
        if (hasJSONArguments) {
            o.write("{");
            let inx = 0;
            for (const paramDecl of this.paramsDeclarations.children) {
                if (paramDecl.name !== 'self') { // rust 'self' is implicit 'this' in ts
                    if (inx > 0)
                        o.write(", ");
                    paramDecl.produce();
                    inx++;
                }
            }
            o.write("}");
        }
        argsDecl = o.getCurrentLine(); // save line
        o.clearCurrentLine(); // clear
        if (hasJSONArguments) {
            // ensure all { and } have spaces around
            argsDecl = argsDecl.replace(/\{/g, " { ");
            argsDecl = argsDecl.replace(/\}/g, " } ").trim();
        }
        o.writeLine("usage:");
        o.writeLine("> " + o.data.nickname + " " + fnName + " " + argsDecl);
        // Type Annotation -- remove
        /* let hasReturnValue = false;
        if (this.typeAnnotation) {
            if (this.typeAnnotation.name !== "Self") {
                this.typeAnnotation?.produce()
                hasReturnValue = true
            }
        }
        */
        const isPayable = (this.commentsAndAttr.includes("#[payable]"));
        // EXAMPLE -- for the user to add
        // o.blankLine()
        // o.writeLine("example:")
        // o.writeLine(PromptNickName + " " + argsDecl)
        // o.writeLine("this command will " + fnName)
        // o.blankLine()
        o.writeLine("`};"); // close help string & help function
        o.blankLine();
        // function as method of ContractAPI
        o.write(fnName);
        o.writeLine(`(a /*:CommandLineArgs*/) /*:${isView ? "string" : "void"}*/{`); // API receives CommandLineArgs parser utlity
        o.indent += 2; // start body
        o.blankLine();
        if (isPayable) {
            o.writeLine("//function is #payable, --amount option is required");
            o.writeLine("a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required");
        }
        // commented options for the user to expand
        o.writeLine('//--these are some examples on how to consume arguments');
        o.writeLine('//const toAccount = a.consumeString("to Account")');
        o.writeLine('//const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")');
        o.blankLine();
        // get JSON args for the fn
        if (hasJSONArguments) {
            o.writeLine('//get fn arguments as JSON');
            o.writeLine(`const fnJSONParams = a.consumeJSON("${argsDecl}")`);
        }
        else {
            o.writeLine(`//--${fnName} has no arguments, if you add some, uncomment the following line and send the params in this.call/view`);
            o.writeLine('//const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")');
        }
        o.blankLine();
        // standard end of args mark
        o.writeLine("a.noMoreArgs() // no more positional args should remain");
        o.blankLine();
        // make the view/call
        let invoke;
        if (isView) {
            invoke = "return this._view";
        }
        else {
            invoke = "this._call";
        }
        let invokeArgs = `"${fnName}"`;
        if (hasJSONArguments)
            invokeArgs += ",fnJSONParams";
        o.writeLine(`${invoke}(${invokeArgs})`);
        o.blankLine();
        //end method
        o.indent -= 2; // end APi method body
        o.writeLine("}");
        o.blankLine();
        // rust contract pub fn Body
        // if (this.children.length) {
        //    o.write(' {')
        //    RustFnBodyWriter.prototype.produceBody.call(this, 4, hasReturnValue)
        //    o.writeLine('}')
        // }
    }
}
Grammar.FunctionDeclaration.prototype.produce = FunctionDeclarationWriter.prototype.produceContractAPI;
class TypeAnnotationWriter extends Grammar.TypeAnnotation {
    produceTS() {
        const o = this.owner.codeWriter;
        o.write(": ");
        // this.optAddrOf()
        // this.optMut()
        let replaced = this.name.replace("::", ".");
        switch (replaced) {
            case 'str':
                replaced = "string";
                break;
            default:
        }
        o.write(replaced);
        // if (this.opt('<')) {
        //    this.children = this.reqSeparatedList(Identifier, ',', '>')
        // }
    }
}
exports.TypeAnnotationWriter = TypeAnnotationWriter;
Grammar.TypeAnnotation.prototype.produce = TypeAnnotationWriter.prototype.produceTS;
class VarDeclWriter extends Grammar.VariableDecl {
    produceTS() {
        var _a;
        const o = this.owner.codeWriter;
        o.write(this.name);
        (_a = this.typeAnnotation) === null || _a === void 0 ? void 0 : _a.produce();
        if (this.assignedExpression) {
            o.write(" = ");
            if (this.assignedExpression.name === 'env') { // rust 'env' => AS 'Context'
                o.write('Context.');
                switch (this.assignedExpression.root.name) {
                    case 'env::signer_account_id':
                        o.write('sender');
                        break;
                    default:
                        this.assignedExpression.root.produce();
                }
            }
            else {
                this.assignedExpression.produce();
            }
        }
    }
}
exports.VarDeclWriter = VarDeclWriter;
Grammar.VariableDecl.prototype.produce = VarDeclWriter.prototype.produceTS;
class ExpressionWriter extends Grammar.Expression {
    produceTS() {
        var _a;
        // const o = this.owner.codeWriter
        (_a = this.root) === null || _a === void 0 ? void 0 : _a.produce();
    }
}
exports.ExpressionWriter = ExpressionWriter;
Grammar.Expression.prototype.produce = ExpressionWriter.prototype.produceTS;
class ParenExpressionWriter extends Grammar.ParenExpression {
    produceTS() {
        const o = this.owner.codeWriter;
        o.write("(");
        this.produceChildren();
        o.write(")");
    }
}
exports.ParenExpressionWriter = ParenExpressionWriter;
Grammar.ParenExpression.prototype.produce = ParenExpressionWriter.prototype.produceTS;
class LetStatementWriter extends Grammar.LetStatement {
    produceTS() {
        const o = this.owner.codeWriter;
        o.write("let ");
        this.produceChildren(", ");
    }
}
exports.LetStatementWriter = LetStatementWriter;
Grammar.LetStatement.prototype.produce = LetStatementWriter.prototype.produceTS;
class VarRefWriter extends Grammar.VarRef {
    produceTS() {
        const o = this.owner.codeWriter;
        if (this.name == 'self') {
            o.write('this');
        }
        else if (this.name == 'env::log') { // rust 'env::log' => AS logging.log
            o.write('logging.log');
        }
        else {
            o.write(this.name.replace("::", "."));
        }
        // accessors
        this.produceChildren();
    }
}
exports.VarRefWriter = VarRefWriter;
Grammar.VarRef.prototype.produce = VarRefWriter.prototype.produceTS;
const superObjectLiteralProduce = Grammar.ObjectLiteral.prototype.produce;
class ObjectLiteralWriter extends Grammar.ObjectLiteral {
    produceTS() {
        const o = this.owner.codeWriter;
        o.indent += 4;
        superObjectLiteralProduce.call(this);
        if (this.name) { // "struct-instantiation") {
            o.write(` as ${this.name}`);
        }
        o.indent -= 4;
    }
}
exports.ObjectLiteralWriter = ObjectLiteralWriter;
Grammar.ObjectLiteral.prototype.produce = ObjectLiteralWriter.prototype.produceTS;
class FunctionArgumentWriter extends Grammar.FunctionArgument {
    produceTS() {
        const o = this.owner.codeWriter;
        if (this.expression) {
            this.expression.produce();
        }
        else {
            o.write("undefined"); // rust _ wildcard argument
        }
    }
}
exports.FunctionArgumentWriter = FunctionArgumentWriter;
Grammar.FunctionArgument.prototype.produce = FunctionArgumentWriter.prototype.produceTS;
// ---------------------------
// function outNativeRustConversionMapCollect(item: ASTBase) {
//    //veo si al final de la expresion hay uno o mas .into() o .as_u128() .to_vec() .map() . collect() etc,
//    // que son sufijos de conversiones de rust y de map()
//    const o = item.owner.codeWriter
//    if (item.nativeSuffixes) {
//        for (const suffixIdent of item.nativeSuffixes.children) {
//            o.write(".")
//            suffixIdent.produce()
//            o.write("(")
//            suffixIdent.produceChildren()
//            o.write(")")
//        }
//    }
// }
class RustClosureWriter extends Grammar.RustClosure {
    produceTS() {
        const o = this.owner.codeWriter;
        o.write("function(");
        for (const param of this.params) {
            param.produce();
        }
        o.writeLine(") {");
        if (this.children.length == 1 && this.children[0] instanceof Grammar.Expression) {
            o.write("return ");
        }
        this.produceChildren();
        o.writeLine("}");
    }
}
exports.RustClosureWriter = RustClosureWriter;
Grammar.RustClosure.prototype.produce = RustClosureWriter.prototype.produceTS;
// ---------------------------
class IfStatementWriter extends Grammar.IfStatement {
    // conditional: Expression
    // ---------------------------
    produceTS() {
        const o = this.owner.codeWriter;
        o.write("if (");
        this.conditional.produce();
        o.write("){");
        this.children[0].produce();
        o.write("}");
        if (this.children.length > 1) {
            o.write("else {");
            this.children[0].produce();
            o.write("}");
        }
    }
}
exports.IfStatementWriter = IfStatementWriter;
Grammar.IfStatement.prototype.produce = IfStatementWriter.prototype.produceTS;
// end class IfStatement
class ContractAPIProducer {
    static produce(root, data, outFilename) {
        const parser = root.owner;
        parser.codeWriter = new CodeWriter_1.CodeWriter(outFilename, data);
        root.produce();
        parser.codeWriter.close();
    }
}
exports.ContractAPIProducer = ContractAPIProducer;
//# sourceMappingURL=ContractAPI-producer.js.map
'''
'''--- dist/main/create-contract-cli.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAndProduceAPIfor = void 0;
const path = require("path");
const fs = require("fs");
const mkPath = require("../lib/util/mkPath");
const color = require("../lib/util/color.js");
const child_process = require("child_process");
const logger = require("../lib/util/logger");
const Parser_1 = require("../lib/Parser/Parser");
const ContractAPI_producer_1 = require("./ContractAPI-producer");
const CommandLineArgs_1 = require("../lib/util/CommandLineArgs");
const CLIOptions_1 = require("./CLIOptions");
// produce ContractAPI by parsing cotract/src/lib.rs
function parseAndProduceAPIfor(rustFile, data, outFile) {
    logger.setDebugLevel(0);
    // parse
    color.action(`Parsing ${rustFile}`);
    let parsedModule;
    try {
        const parser = new Parser_1.Parser({ skipFunctionBody: true });
        // parse rust lib file
        parsedModule = parser.parseFile(rustFile);
    }
    catch (ex) {
        console.log(color.red + "ERR");
        console.log(ex.message + color.normal);
        color.logErr("parsing " + rustFile);
        console.log(color.green + "Workarounds:" + color.normal);
        console.log("* [fast] Simplify yout lib.rs (move non pub fns to internal.rs or util.rs)");
        console.log("* [slow] Report this issue at github.com/luciotato/create-contract-cli/issues - include your lib.rs" + color.normal);
        if (logger.debugLevel) {
            console.log(ex);
            throw (ex);
        }
        process.exit(1);
    }
    color.greenOK();
    // make output path
    try {
        mkPath.create(path.dirname(outFile));
    }
    catch (ex) {
        color.logErr("creating dir " + path.dirname(outFile));
        throw (ex);
    }
    // produce
    color.action(`Producing ${outFile}`);
    try {
        ContractAPI_producer_1.ContractAPIProducer.produce(parsedModule, data, outFile);
    }
    catch (ex) {
        console.log(color.red + "ERR");
        console.log(ex.message + color.normal);
        color.logErr("producing for " + (parsedModule === null || parsedModule === void 0 ? void 0 : parsedModule.name));
        // console.log(color.green + "Workarounds:" + color.normal)
        // console.log("* Simplify yout lib.rs (move to util.rs or internal.rs) [fast]")
        // console.log("* You can report an issue on github.com/luciotato/create-contract-cli/issues [slow]" + color.normal)
        if (logger.debugLevel) {
            console.log(ex);
            throw (ex);
        }
        process.exit(2);
    }
    color.greenOK();
}
exports.parseAndProduceAPIfor = parseAndProduceAPIfor;
// ---------------------------
// ------ MAIN ---------------
// ---------------------------
function main() {
    var _a;
    const args = new CommandLineArgs_1.CommandLineArgs(CLIOptions_1.options);
    // Show help
    if (CLIOptions_1.options.help.value) {
        console.log("create-command-cli");
        console.log("Parses your rust NEAR contract code interface from src/lib.rs and generates a cli-tool tailored to that contract");
        console.log();
        console.log("usage:");
        console.log(" > create-contact-cli [nickname] path/to/rust-project -c contract_account_id --accountId user_account_id ");
        console.log("where [nickname] is the name of your new cli-tool");
        console.log();
        console.log("Example:");
        console.log(" > create-contact-cli staky core-contracts/staker-pool -c mystaker.stakehouse.betanet --accountId lucio.testnet");
        console.log("This wil create a new cli tool named 'staky', to control the contract at mystaker.stakehouse.betanet");
        console.log("Type 'staky --help' after creation");
        CommandLineArgs_1.ShowHelpOptions(CLIOptions_1.options);
        process.exit(0);
    }
    const nickname = args.consumeString("nickname");
    const pathToRustProject = args.consumeString("path/to/rust-project");
    //TODO - parse other files besides lib.rs (see core-contracts/lockup)
    // check if we can find the rust source
    const rustSourceFile = path.join(pathToRustProject, "src", "lib.rs");
    try {
        fs.statSync(rustSourceFile);
    }
    catch (ex) {
        color.logErr("can't find " + rustSourceFile);
        color.logErr(ex.message);
        process.exit(1);
    }
    // both -c & -acc are required
    args.requireOptionString(CLIOptions_1.options.contractName);
    args.requireOptionString(CLIOptions_1.options.accountId);
    // create project dir
    let projectDir = `${nickname}-cli`;
    if (CLIOptions_1.options.output.value)
        projectDir = path.join(CLIOptions_1.options.output.value, projectDir);
    color.action(`Creating dir ${projectDir}`);
    if (mkPath.dirExists(projectDir)) {
        color.logErr("dir already exists: " + projectDir);
        process.exit(1);
    }
    try {
        mkPath.create(projectDir);
    }
    catch (ex) {
        color.logErr("can't mkdir " + projectDir);
        throw (ex);
    }
    color.greenOK();
    // create ContractAPI
    const generatedContractAPI = path.join(projectDir, "ContractAPI.js");
    // by parsing cotract/src/lib.rs
    const data = {
        nickname: nickname,
        defaultContractName: CLIOptions_1.options.contractName.value,
        defaultUserAccountId: CLIOptions_1.options.accountId.value
    };
    //TODO - parse other files besides lib.rs (see core-contracts/lockup)
    parseAndProduceAPIfor(rustSourceFile, data, generatedContractAPI);
    // add auxiliary files
    //console.log("Current dir: " +process.cwd())
    //console.log("this script: " +process.argv[1]) // \usr\local\bin\npm\node_modules\create-contract-cli\bin\cli
    let basedir = path.join(__dirname, "..", "..");
    //console.log(__dirname);
    // Prints: /Users/mjr
    //console.log(path.dirname(__filename));
    // Prints: /Users/mjr    
    //let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..")
    if (basedir.startsWith("\\"))
        basedir = basedir.slice(1); // windows compat remove extra "\"
    basedir = path.relative(process.cwd(), basedir);
    color.action(`Completing from ${basedir}/model`);
    try {
        mkPath.create(path.join(projectDir, "util"));
        //create package.json
        let pkg = fs.readFileSync(path.join(basedir, "res", "packageES2018.json")).toString();
        pkg = pkg.replace(/{nickname}/g, nickname);
        pkg = pkg.replace(/{contract}/g, pathToRustProject.replace(/\\/g, "/")); // windows compat: c.\./
        pkg = pkg.replace(/{contractAddress}/g, CLIOptions_1.options.contractName.value);
        fs.writeFileSync(path.join(projectDir, "package.json"), pkg);
        //create cli.js
        let cli = fs.readFileSync(path.join(basedir, "res", "cli.js")).toString();
        cli = cli.replace(/{nickname}/g, nickname);
        fs.writeFileSync(path.join(projectDir, "cli.js"), cli);
        //create CLIConfig.js
        const cliConfigPath = path.join(projectDir, "CLIConfig.js");
        const text = `
        module.exports = {
            nickname: "${nickname}",
            userAccount: "${CLIOptions_1.options.accountId.value}",
            contractAccount: "${CLIOptions_1.options.contractName.value}"
        }
        `;
        fs.writeFileSync(cliConfigPath, text);
        //create ${nickname}.js from model
        //type:module const modelPath = path.join(basedir, "dist", "model", "hand-coded-tom")
        const modelPath = path.join(basedir, "res", "model-ES2018");
        fs.copyFileSync(path.join(modelPath, "tomES2018.js"), path.join(projectDir, nickname + ".js"));
        //copy common files - main dir
        for (const file of ["CLIOptions", "ExtensionAPI"]) {
            fs.copyFileSync(path.join(modelPath, file + ".js"), path.join(projectDir, file + ".js"));
        }
        //copy common files - util dir
        for (const file of ["SpawnNearCli", "CommandLineArgs", "saveConfig", "color"]) {
            fs.copyFileSync(path.join(modelPath, "util", file + ".js"), path.join(projectDir, "util", file + ".js"));
        }
    }
    catch (ex) {
        color.logErr("copying auxiliary files");
        throw (ex);
    }
    color.greenOK();
    if (CLIOptions_1.options.nolink.value) {
        color.action(`${path.join(projectDir, nickname)} created`);
        color.greenOK();
    }
    else {
        console.log(`cd ${projectDir}`);
        console.log(`Executing npm link`);
        const spawnOptions = {
            shell: true,
            cwd: projectDir,
            stdio: "inherit"
        };
        const execResult = child_process.spawnSync("npm", ["link"], spawnOptions);
        if (execResult.error) {
            color.logErr(execResult.error.message);
            process.exit(5);
        }
        console.log();
        if ((_a = execResult.stderr) === null || _a === void 0 ? void 0 : _a.toString().includes("EEXISTS")) {
            console.log(color.yellow + "WARN: nmp link may report ERR:code EEXISTS. You can ignore that." + color.normal);
            console.log();
        }
        console.log("now type:");
        console.log(` > ${nickname} --help`);
    }
}
main();
//# sourceMappingURL=create-contract-cli.js.map
'''
'''--- dist/model-TS/CLIConfig.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cliConfig = void 0;
exports.cliConfig = {
    userAccount: "luciotato.betanet",
    contractAccount: "testcontract.betanet"
};
//# sourceMappingURL=CLIConfig.js.map
'''
'''--- dist/model-TS/CLIOptions.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.options = void 0;
exports.options = {
    accountId: {
        shortName: "acc",
        valueType: "string",
        value: "",
        helpText: `signer accountId`
    },
    masterAccount: {
        shortName: "ma",
        valueType: "string",
        value: "",
        helpText: `master account`
    },
    help: {
        shortName: "h",
        value: false
    },
    info: {
        shortName: "i",
        value: false,
        helpText: 'show configured contract account, default user accountId'
    },
    verbose: {
        shortName: "v",
        helpText: 'Prints out verbose output',
        name: "verbose"
    },
    amount: {
        shortName: "am",
        valueType: "NEAR",
        value: "",
        helpText: `attach NEAR tokens to this call. Example: --amount 100N`
    },
    networkId: {
        shortName: "net",
        valueType: "string",
        value: "",
        helpText: 'NEAR network ID (default is NODE_ENV)'
    },
    contractName: {
        shortName: "c",
        valueType: "string",
        value: "",
        helpText: `Sets default contract account when used with --cliconfig. Otherwise, sets --contractName argument for the near call`
    },
    cliConfig: {
        shortName: "cliconfig",
        value: false,
        helpText: `config this cli, add --contractName xx and --accountId yy to set default contract accountId and user`
    },
};
// # sourceMappingURL=CLIOptions.js.map
//# sourceMappingURL=CLIOptions.js.map
'''
'''--- dist/model-TS/ContractAPI.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractAPI = exports.nickname = void 0;
const nearCli = require("./util/SpawnNearCli.js");
const CLIOptions_js_1 = require("./CLIOptions.js");
const CLIConfig_js_1 = require("./CLIConfig.js");
// name of this script
exports.nickname = "tom";
// one function for each pub fn in the contract
// get parameters by consuming from CommandLineParser
class ContractAPI {
    constructor() {
        this.deploy_help = `
    deploy a WASM file into the account ${CLIConfig_js_1.cliConfig.contractAccount} and call init function
    
    usage:
    > ${exports.nickname} deploy [--account xx] code.WASM new { owner_id:string, stake_public_key:string, reward_fee_fraction: { numerator:x, denominator:y } }
    
    example:
    > ${exports.nickname} deploy code.WASM new { owner_id:lucio.near, stake_public_key:"7fa387483934", reward_fee_fraction: { numerator:8, denominator:100 } }
    willl deploy code.WASM at ${CLIConfig_js_1.cliConfig.contractAccount} and then initialize it
    `;
        this.ping_help = `
    Distributes rewards and restakes if needed.
    
    usage:
    > ${exports.nickname} ping `;
        this.get_accounts_help = `
    get registered accounts from the contract
    
    usage:
    > ${exports.nickname} get_accounts { from_index:number, limit:number }
    
    example:
    > ${exports.nickname} get_accounts { from_index:0, limit:10 }
    will get 10 accounts starting from 0
    `;
        this.deposit_help = `
    deposit into the contract for staking later
    
    usage:
    > ${exports.nickname} deposit --attach Near-amount
    
    example:
    > ${exports.nickname} deposit --attach 40N
    will deposit 40N on behalf of your account into the pool
    
    `;
        this.stake_help = `
stake deposited unstaked amount

usage:
> ${exports.nickname} stake { amount: 10N }

example:
> ${exports.nickname} stake { amount: 10N }
will stake 10N from the unstaked balance of myaccount.betanet 

`;
    }
    // this.view helper function
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    _view(command, fnJSONparams) {
        return nearCli.view(CLIConfig_js_1.cliConfig.contractAccount, command, fnJSONparams, CLIOptions_js_1.options);
    }
    // this.call helper function
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    _call(command, fnJSONparams) {
        return nearCli.call(CLIConfig_js_1.cliConfig.contractAccount, command, fnJSONparams, CLIOptions_js_1.options);
    }
    deploy(a) {
        const wasmFile = a.consumeString("wasmFile");
        a.optionalString("new"); // can be omitted
        const initArgs = a.consumeJSON("init fn params");
        a.noMoreArgs();
        nearCli.spawnNearCli([
            'deploy', CLIConfig_js_1.cliConfig.contractAccount, wasmFile,
            "new", initArgs
        ], CLIOptions_js_1.options);
    }
    ping(a) {
        a.noMoreArgs(); // end of arguments
        this._call("ping");
    }
    get_accounts(a) {
        const params = a.consumeJSON("{ from_index:number, limit:number }");
        a.noMoreArgs();
        return this._view("get_accounts", params);
    }
    deposit(a) {
        a.requireOptionWithAmount(CLIOptions_js_1.options.amount, "N"); // require --amount, in Nears
        a.noMoreArgs();
        this._call("deposit");
    }
    stake(a) {
        const stakeJSONargs = a.consumeJSON("{ amount: x }");
        a.noMoreArgs();
        this._call("stake", stakeJSONargs);
    }
    get_total_staked_balance(a) {
        a.noMoreArgs();
        return this._view("get_total_staked_balance");
    }
    get_owner_id(a) {
        a.noMoreArgs();
        return this._view("get_owner_id");
    }
    get_staking_key(a) {
        a.noMoreArgs();
        return this._view("get_staking_key");
    }
}
exports.ContractAPI = ContractAPI;
//# sourceMappingURL=ContractAPI.js.map
'''
'''--- dist/model-TS/ExtensionAPI.js ---
#!/bin/node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionAPI = void 0;
const CLIConfig_js_1 = require("./CLIConfig.js");
const ContractAPI_js_1 = require("./ContractAPI.js");
const CLIOptions_js_1 = require("./CLIOptions.js");
const color = require("./util/color.js");
const nearCli = require("./util/SpawnNearCli.js");
// -------------------------
// Contract API extensions
// -------------------------
class ExtensionAPI extends ContractAPI_js_1.ContractAPI {
    constructor() {
        super(...arguments);
        // hm handy extension example
        this.hm_help = `How much? 
	converts an amount in Yoctos into a more readable format. 
    Example: 
    >${ContractAPI_js_1.nickname} hm 30037100000000000000000000
    `;
        // where extension example
        this.where_help = `Where is the contract? 
    show contract accountId
    Example extension, gives the same information as: ${ContractAPI_js_1.nickname} --info
    
    Usage:
    >${ContractAPI_js_1.nickname} where [are] [you]
    `;
        // balance extension example
        this.state_help = `
    Get contract's account state, with more readable numbers
    
    Usage:
    >${ContractAPI_js_1.nickname} state
    `;
        // deploy extension example
        this.deploy_help = `call near deploy on ${CLIConfig_js_1.cliConfig.contractAccount} 
    Example: 
    >${ContractAPI_js_1.nickname} deploy path/to/wasm
    `;
        // -----------------------------------------------
        // -----------------------------------------------
        // You can add more extension commands here
        // -----------------------------------------------
        // -----------------------------------------------
        // -----------------------------------------------
        // info Example extension
        // -----------------------------------------------
        /*
        myfn_help = `This is a command extension example wiht variable args.
        Handy commands you can create composing fn calls to this contract or others
    
        Usage:
        >${nickname} myfn [account]+
        `
        myfn(a: CommandLineArgs) {
            if (a.positional.length == 0) {
                this.view("myfn", {}) // call myfn on this contract
            } else {
                while (a.positional.length) {
                    const account = a.consumeString("another account")
                    nearCli.view(account, "myfn", {}, options) // call myfn on one or mode accounts
                }
            }
            process.exit(0)
        }
        */
        // -----------------------------------------------
        // NEP21 Example extension
        // -----------------------------------------------
        /*
        nep21_help = `Call functions on NEP21 contracts.
        Examples:
        >>${nickname} nep21 balance gold.nep21.near         -> get how much gold this contract has
        >>${nickname} nep21 balance my gold.nep21.near      -> get how much gold you have
        >>${nickname} nep21 mint mytoken.near               -> (dev) calls mytoken.near.mint(), minting tokens for you
    
        >${nickname} nep21 transfer 50 gold.near to lucio.testnet  -> transfer 50e24 gold.near tokens to account lucio.testnet
    
    `
        nep21(a: CommandLineArgs) {
            const subcommand = a.consumeString("sub-command")
    
            if (subcommand == "balance") {
                let tokenOwner = cliConfig.contractAccount
                if (a.optionalString("my")) tokenOwner = cliConfig.userAccount
    
                while (a.positional.length) {
                    const token = a.consumeString("nep21-contract")
                    nearCli.view(token, "get_balance", { owner_id: tokenOwner }, options)
                }
            } else if (subcommand == "mint") {
                const token = a.consumeString("nep21-contract")
                nearCli.call(token, "mint_1e3", {}, options)
            }
    
            // nearswap nep21 transfer 50000 gold to lucio.testnet
            else if (subcommand == "transfer") {
                const tokAmount = a.consumeAmount("token amount", "Y")
    
                const token = a.consumeString("nep21-contract")
    
                a.optionalString("to")
    
                let toAcc = a.consumeString("to account")
                if (toAcc == "contract") toAcc = cliConfig.contractAccount // this contract
    
                nearCli.call(token, "transfer", { new_owner_id: toAcc, amount: tokAmount }, options)
            } else {
                console.log("nep21 UNK subcommand " + color.red + subcommand + color.normal)
                process.exit(1)
            }
    
            process.exit(0)
        }
        */
        /*
        // function depo: example manually coded composed/aternative command
        depo_help: string = `
        shotcut for deposit
    
        usage:
        > ${nickname} depo amountN [and] [stake]
    
        example:
        > ${nickname} depo 40N
        will deposit 40N on into ${nickname}'s pool
        > ${nickname} depo 40N and stake
        will deposit 40N into ${nickname}'s pool and stake it in the same transaction
    
        `;
    
        depo(a: CommandLineArgs) {
            options.amount.value = a.consumeAmount("amount to deposit", "N")
    
            // check if [and] [stake] is next in the command line
            a.optionalString("and")
            const stake = a.optionalString("stake")
    
            const fnToCall = stake ? "deposit_and_stake" : "deposit"
    
            a.noMoreArgs()
    
            return this.call(fnToCall)
        }
        */
        // function info: example manually coded composed command
        /*
        info_help = "get_owner_id, get_staking_key & get_total_staked_balance"
    
        info(a: CommandLineArgs) {
            this.get_owner_id(a)
            this.get_staking_key(a)
            this.get_total_staked_balance(a)
        }
        */
    }
    hm(a) {
        const str = a.consumeString("amount");
        console.log(color.green, a.convertAmount(str + "Y", "N", "amount"), color.normal);
    }
    where(a) {
        a.optionalString("are");
        a.optionalString("you");
        a.noMoreArgs();
        console.log("Contract is at ", color.green, CLIConfig_js_1.cliConfig.contractAccount, color.normal);
        console.log("Default user is ", color.green, CLIConfig_js_1.cliConfig.userAccount, color.normal);
    }
    state(a) {
        a.noMoreArgs();
        nearCli.spawnNearCli(["state", CLIConfig_js_1.cliConfig.contractAccount], CLIOptions_js_1.options);
    }
    deploy(a) {
        //get path from command line
        const wasmFile = a.consumeString("path/to/contract.wasm");
        //spawn near-cli, command=deploy
        nearCli.spawnNearCli(["deploy", CLIConfig_js_1.cliConfig.contractAccount, wasmFile], CLIOptions_js_1.options);
    }
}
exports.ExtensionAPI = ExtensionAPI;
module.exports = ExtensionAPI;
//# sourceMappingURL=ExtensionAPI.js.map
'''
'''--- dist/model-TS/tom.js ---
#!/bin/node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CLIConfig_js_1 = require("./CLIConfig.js");
const ContractAPI_js_1 = require("./ContractAPI.js");
const CLIOptions_js_1 = require("./CLIOptions.js");
const CommandLineArgs_js_1 = require("./util/CommandLineArgs.js");
const color = require("./util/color.js");
const ExtensionAPI_js_1 = require("./ExtensionAPI.js");
const saveConfig_js_1 = require("./util/saveConfig.js");
// default accountId
CLIOptions_js_1.options.accountId.value = CLIConfig_js_1.cliConfig.userAccount;
// process command line args
const args = new CommandLineArgs_js_1.CommandLineArgs(CLIOptions_js_1.options);
// command is the 1st positional argument
const command = args.getCommand();
// Show config info if requested
// Set config if requested
if (CLIOptions_js_1.options.cliConfig.value) {
    saveConfig_js_1.saveConfig(CLIOptions_js_1.options.accountId.value, CLIOptions_js_1.options.contractName.value);
    process.exit(0);
}
if (CLIOptions_js_1.options.info.value) {
    console.log(`config.js:`);
    console.log(`  Your account    : ${color.yellow}${CLIConfig_js_1.cliConfig.userAccount}${color.normal}`);
    console.log(`  Contract account: ${color.yellow}${CLIConfig_js_1.cliConfig.contractAccount}${color.normal}`);
    process.exit(0);
}
// TODO configure
// if (command=="configure") {
//     args.requireOptionString(options.accountId,"default account Id")
//     process.exit(0);
// }
// -------------------
// PROCESS COMMAND //
// -------------------
// get contract API + Extensions
const API = new ExtensionAPI_js_1.ExtensionAPI();
// check the command is in the API
// eslint-disable-next-line @typescript-eslint/no-explicit-any
if (command && typeof API[command] !== "function") {
    color.logErr("unknown command " + color.yellow + command + color.normal);
    console.log(`${ContractAPI_js_1.nickname} --help to see a list of commands`);
    process.exit(1);
}
// Show help if requested or if no command
if (CLIOptions_js_1.options.help.value || !command) {
    CommandLineArgs_js_1.ShowHelpPage(command, API, CLIOptions_js_1.options);
    process.exit(0);
}
// call the contract API function
// eslint-disable-next-line @typescript-eslint/no-explicit-any
API[command](args);
//# sourceMappingURL=tom.js.map
'''
'''--- dist/model-TS/util/CommandLineArgs.js ---
"use strict";
/**
 #Simple and minimum command line args parser
 *
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args.
 *    --Note:  spaces *must* be used around { and }
 *

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandLineArgs = exports.ShowHelpPage = exports.ShowHelpOptions = void 0;
const path_1 = require("path"); // host OS path separator
const util_1 = require("util");
const color = require("./color.js");
// ----------------------------------------------------
// construct and show help page based on valid options
// ----------------------------------------------------
function ShowHelpOptions(optionsDeclaration) {
    // show help about declared options
    console.log();
    console.log("-".repeat(60));
    console.log("Options:");
    for (const key in optionsDeclaration) {
        let line = "";
        const opt = optionsDeclaration[key];
        let text = "--" + key;
        if (opt.valueType)
            text = text + " " + opt.valueType;
        if (opt.shortName) {
            text = text + ", -" + opt.shortName;
            if (opt.valueType)
                text = text + " " + opt.valueType;
        }
        line = `  ${text}`.padEnd(50) + (opt.helpText ? opt.helpText : "");
        console.log(line);
    }
    console.log("-".repeat(60));
}
exports.ShowHelpOptions = ShowHelpOptions;
// ----------------------------------------------------
// construct and show a help page based on the API for the commands
// ----------------------------------------------------
function ShowHelpPage(command, contractAPI, optionsDeclaration) {
    const commandsHelp = {};
    // check all functions in the ContractAPI class, except the class constructor
    const methodNames = Object.getOwnPropertyNames(contractAPI.__proto__)
        .filter(name => name !== "constructor" && (command === "" || name === command)); // filter requested command
    // populate commandsHelp
    methodNames.forEach((value) => commandsHelp[value] = "");
    // see which functions have proper help text
    // check all *_help string items in the ContractAPI class
    const properHelpStrings = Object.getOwnPropertyNames(contractAPI);
    for (const item of properHelpStrings) {
        if (item.endsWith("_help") && typeof contractAPI[item] === "string") {
            const method = item.replace("_help", "");
            if (command === "" || command == method) { // filter the requested help
                commandsHelp[method] = contractAPI[item]; // add proper help
            }
        }
    }
    // print all commands and their help if it's there
    for (const key in commandsHelp) {
        console.log("-".repeat(60));
        console.log('command: ' + key); // name the command
        console.log(commandsHelp[key]); // print the help
    }
    ShowHelpOptions(optionsDeclaration);
}
exports.ShowHelpPage = ShowHelpPage;
// --------------------------
// --  main exported class --
// --------------------------
class CommandLineArgs {
    constructor(options) {
        this.clArgs = process.argv;
        this.optDeclarations = options;
        this.positional = [];
        // remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node' ||
            this.clArgs[0].endsWith(path_1.sep + 'node')) ||
            this.clArgs[0].endsWith(path_1.sep + 'node.exe')) {
            this.clArgs = this.clArgs.slice(1);
        }
        // remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1);
        // process each item separating options from posiitonal args
        // First: process --options
        for (const key in options) {
            const optionDecl = options[key];
            // search for option name & variations
            const pos = this.searchOption(optionDecl);
            if (pos >= 0) { // found in command line args
                const literal = this.clArgs[pos]; // as written
                this.clArgs.splice(pos, 1); // remove from cl args
                if (optionDecl.valueType) { // has a value
                    if (pos >= this.clArgs.length) {
                        color.logErr("expecting value after " + literal);
                        process.exit(1);
                    }
                    const value = this.clArgs[pos]; // take value
                    options[key].value = value; // set value
                    this.clArgs.splice(pos, 1); // also remove value from list
                }
                else // valueless option
                 {
                    options[key].value = true; // set as present
                }
            }
        }
        // if at this point there are still --options in the command line args array, those are unknown options
        let hasErrors = false;
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                color.logErr("UNKNOWN option: " + item);
                hasErrors = true;
            }
        }
        if (hasErrors) {
            ShowHelpOptions(options);
            process.exit(1);
        }
        // create consumible positional arguments, parsing also JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index];
            if (item == "{") { // a JSON object in the command line
                const extracted = this.extractJSONObject(index);
                this.positional.push(extracted.value);
                index = extracted.end;
            }
            else {
                this.positional.push(item);
            }
        }
    }
    /**
     * When the first argument is the command to execute
     * returns "" if there's no arguments
     */
    getCommand() {
        if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            color.logErr("expected a command as first argument'");
            process.exit(1);
        }
        else {
            if (this.positional.length === 0)
                return "";
            // take the first argument as this.command
            return this.positional.shift();
        }
    }
    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which) {
        if (this.positional.length == 0)
            return false;
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected a string argument, got {... }`);
            process.exit(1);
        }
        if (this.positional[0] == which) {
            this.positional.shift(); // consume
            return true;
        }
        return false; // not the expected string
    }
    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected '${name}' argument`);
            process.exit(1);
        }
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected ${name} string argument, got {... }`);
            process.exit(1);
        }
        return this.positional.shift();
    }
    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name, units) {
        const value = this.consumeString(name);
        return this.convertAmount(value, units, name);
    }
    /**
     * requires a JSON as the next positional arg
     * @param name
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consumeJSON(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected ${name} as { }`);
            process.exit(1);
        }
        if (typeof this.positional[0] === "string") {
            color.logErr(`expected ${name} as {... } got a string: '${this.positional[0]}'`);
            process.exit(1);
        }
        return this.positional.shift();
    }
    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs() {
        if (this.positional.length) {
            color.logErr(`unrecognized extra arguments`);
            console.log(util_1.inspect(this.positional));
            process.exit(1);
        }
    }
    findDeclarationKey(opt) {
        for (const key in this.optDeclarations) {
            if (opt.shortName && this.optDeclarations[key].shortName == opt.shortName)
                return key;
            if (opt.helpText && this.optDeclarations[key].helpText == opt.helpText)
                return key;
        }
        throw new Error("shortName|helpText not found in declarations: " + util_1.inspect(opt));
    }
    /**
     * requires the presence of an option with a string value
     * @param optionName option name
     */
    requireOptionString(opt) {
        if (opt.value == undefined || opt.value == "") {
            const key = this.findDeclarationKey(opt);
            color.logErr(`required --${key}`);
            process.exit(1);
        }
    }
    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(opt, units) {
        var _a;
        const value = ((_a = opt.value) === null || _a === void 0 ? void 0 : _a.toString().trim()) || "";
        const key = this.findDeclarationKey(opt);
        if (!value) {
            color.logErr(`required --${key} [number]`);
            process.exit(1);
        }
        const converted = this.convertAmount(value, units, key);
        opt.value = converted; // store in the required units
    }
    /**
     * search for the presence of an option
     * removes it from the options if found
     *
     * @param optionName option name
     */
    consumeOption(opt) {
        const value = opt.value;
        if (value) { // found
            opt.value = undefined; // remove from options (consume)
        }
        return value;
    }
    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     *
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value, requiredUnits, name) {
        let result = value.toUpperCase();
        name = color.yellow + name + color.normal;
        result = result.replace("_", ""); // allow 100_000_000, ignore _
        if (result.endsWith("Y")) { // value ends in "Y"OCTOS
            if (result.includes(".")) {
                color.logErr(name + ": invalid amount format, YOCTOS can't have decimals: " + value);
                process.exit(1);
            }
            result = result.slice(0, -1); // remove Y
            if (requiredUnits == "Y") {
                return result;
            } // already in Yoctos
            if (requiredUnits == "I" || requiredUnits == "F") {
                return Number(result);
            } // a js Number
            // NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24);
            }
            else {
                // insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24);
            }
            return result;
        }
        else { // other, assume amount in NEARS (default)
            if (!result.slice(-1).match(/\d|N|I|F/)) { //should end with N|I|F or a digit
                color.logErr(name + ": invalid denominator, expected Y|N|I|F => yoctos|near|int|float. Received:" + result);
                process.exit(1);
            }
            if (result.endsWith("I") || result.endsWith("F")) {
                result = result.slice(0, -1); // remove denom, store as number
                return Number(result);
            }
            if (result.endsWith("N"))
                result = result.slice(0, -1); // remove N
            if (requiredUnits == "N") {
                return result;
            } // already in Nears
            // Yoctos required -- convert to yoctos
            const parts = result.split(".");
            if (parts.length > 2) {
                color.logErr(name + ": invalid amount format, too many decimal points: " + value);
                process.exit(1);
            }
            if (parts.length == 1) {
                parts.push("");
            } // .0
            const decimalString = parts[1].padEnd(24, '0');
            result = parts[0] + "" + decimalString; // +""+ is for making sure + means concat here
            return result;
        }
    }
    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    extractJSONObject(start) {
        var _a, _b;
        // find the closing "}"
        let opened = 1;
        let end = -1;
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n];
            if (item == "{") {
                opened++;
            }
            else if (item == "}") {
                opened--;
                if (opened == 0) {
                    end = n;
                    break;
                }
            }
        }
        if (end == -1) { // unmatched opener error
            color.logErr("Unmatched '{' . remember to put spaces around { and }");
            this.clArgs[start] = color.yellow + "{" + color.normal;
            console.log(this.clArgs.join(" "));
            process.exit(1);
        }
        // Here we have start & end for matching { }
        const resultObj = {};
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index];
            let propValue;
            if (propName == ",")
                continue;
            if ("{}".includes(propName)) {
                color.logErr("expected name:value");
                this.clArgs[index] = color.yellow + propName + color.normal;
                console.log(this.clArgs.slice(start, end + 1).join(" "));
                process.exit(1);
            }
            const parts = propName.split(":");
            if (parts.length > 2) {
                color.logErr(` too many ':' (found ${parts.length - 1}) at ${propName}`);
                process.exit(1);
            }
            propName = (_a = parts[0]) === null || _a === void 0 ? void 0 : _a.trim();
            propValue = (_b = parts[1]) === null || _b === void 0 ? void 0 : _b.trim();
            if (propValue == undefined || propValue == "") {
                // let's assume the user typed "name: value" instead of "name:value"
                index++; // take the next arg
                propValue = this.clArgs[index];
                if (propValue.endsWith(":")) {
                    color.logErr(` missing value after ':' for ${propName}`);
                }
                if (index >= end || propValue == "}") {
                    console.log(`ERROR: expected value after ${propName}`);
                    process.exit(1);
                }
            }
            if (propValue == "{") { // subornidated object
                const subObj = this.extractJSONObject(index); // recursive***
                // store as object
                resultObj[propName] = subObj.value;
                index = subObj.end; // skip internal object
                continue;
            }
            // it's a string
            // remove ending "," if it's there
            if (propValue.endsWith(","))
                propValue = propValue.slice(0, propValue.length - 1);
            // check if it's a number
            if (propValue.toUpperCase().match(/^[0-9.]+[Y|N|I|F]{0,1}$/)) { // amount (optionally [Y|N|I|F] expressed in nears. yoctos, integer or float
                propValue = this.convertAmount(propValue, "Y", propName); // process and convert to Yoctos if expressed in nears
            }
            // store
            resultObj[propName] = propValue;
        } // end for
        // return positions and composed object
        return { start: start, end: end, value: resultObj };
    }
    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */
    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */
    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    searchOption(option) {
        const name = this.findDeclarationKey(option);
        const shortName = option.shortName;
        // search several possible forms of the option, e.g. -o --o -outdir --outdir
        const variants = ['-' + name, '--' + name];
        if (shortName) {
            variants.push('--' + shortName, '-' + shortName);
        }
        // for each item in list
        for (const variant of variants) {
            const inx = this.clArgs.indexOf(variant);
            if (inx >= 0) {
                return inx; // found
            }
        }
        return -1; // not found
    }
}
exports.CommandLineArgs = CommandLineArgs;
// end class CommandLineArgs
//# sourceMappingURL=CommandLineArgs.js.map
'''
'''--- dist/model-TS/util/SpawnNearCli.js ---
"use strict";
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
exports.thsep = exports.lastNumber = exports.view = exports.call = exports.spawnNearCli = exports.yton = exports.decodeHTMLEntities = exports.setDebug = void 0;
const child_process = require("child_process");
let debug = 0;
function setDebug(value) { debug = value; }
exports.setDebug = setDebug;
function decodeHTMLEntities(str) {
    str = str.replace(/&#(\d+);/g, function (match, dec) {
        return String.fromCharCode(dec);
    });
    str = str.replace(/&#(x[A-F0-9]+);/g, function (match, dec) {
        return String.fromCharCode(parseInt("0" + dec));
    });
    return str.replace(/&quot;/g, "'");
}
exports.decodeHTMLEntities = decodeHTMLEntities;
function yton(yoctos) {
    let units = yoctos;
    if (units.length < 25)
        units = units.padStart(25, '0');
    units = units.slice(0, -24) + "." + units.slice(-24);
    return units;
}
exports.yton = yton;
function spawnNearCli(args, options) {
    var _a;
    //remove empty args
    let inx = 0;
    while (inx < args.length)
        if (args[inx] == undefined)
            args.splice(inx, 1);
        else
            inx++;
    // add options to args for near-cli
    // for each option
    for (const key in options) {
        const opt = options[key];
        const value = opt.value;
        if (value) { // if it was set
            args.push("--" + key); // add option presence
            if (opt.valueType) { // if the option included a value
                args.push(opt.value); // add option value
            }
        }
    }
    // -----------------------------
    // near-cli uses NODE_ENV to define --networkId
    // -----------------------------
    // get process.env, clone the actual env vars
    const env = Object.create(process.env);
    const pos = args.indexOf("--networkId");
    if (pos >= 0) {
        const network = args[pos + 1];
        env.NODE_ENV = network;
        console.log(`NODE_ENV=${network}`);
    }
    // -----------------------------
    for (let i = 0; i < args.length; i++) {
        if (typeof args[i] !== "string") { // JSON
            args[i] = JSON.stringify(args[i]);
            args[i] = args[i].replace(/"/g, '\\"'); // add escape before each quote
        }
    }
    if (debug || ((_a = options.verbose) === null || _a === void 0 ? void 0 : _a.value))
        console.log(`near ${args.join(" ")}`);
    const execResult = child_process.spawnSync("near", args, { shell: true, env: env }); // shell:true => to be able to invoke near-cli on windows
    // console.log(execResult.stdout.toString())
    // console.log(execResult.stderr.toString())
    if (execResult.error) {
        console.log(execResult.error);
        process.exit(1);
    }
    let stdo = "";
    if (execResult.stdout) {
        // console.log("stdout:")
        // console.log("-*-")
        // fixes for  near-cli output
        stdo = decodeHTMLEntities(execResult.stdout.toString());
        process.stdout.write(stdo);
        // console.log("-*-")
    }
    if (execResult.stderr) {
        // console.log("stderr:")
        // console.log("-*-")
        process.stdout.write(decodeHTMLEntities(execResult.stderr.toString()));
        // console.log("-*-")
    }
    // show numbers in yoctos converted to more readable units
    // get all numbers where number.lenght>=20
    const numbersFound = stdo.replace(/'/g, " ").replace(/"/g, " ").match(/.*?['" ]\d{14,50}/g);
    if (numbersFound) {
        // deduplicate
        const numbers = [...new Set(numbersFound)];
        // show conversion to NEARs
        console.log("amounts denomination:");
        for (const text of numbers) {
            const parts = text.split(" ");
            const num = parts.pop() || "";
            if (num.length >= 20) {
                // show reference line
                console.log(text.padStart(60, ' ').slice(-60) + " Yoctos => " + yton(num).padStart(38, ' '));
            }
        }
    }
    if (execResult.status != 0) {
        process.exit(execResult.status);
    }
    return stdo;
}
exports.spawnNearCli = spawnNearCli;
// -------------------------------------
// extension helper fns at ContractAPI
// -------------------------------------
function nearCli(cv, contract, command, fnJSONparams, options) {
    const nearCliArgs = [
        cv,
        contract,
        command,
        fnJSONparams
    ];
    return spawnNearCli(nearCliArgs, options);
}
// --------------------- call  contract
function call(contract, command, fnJSONparams, options) {
    return nearCli("call", contract, command, fnJSONparams, options);
}
exports.call = call;
// --------------------- view on contract
function view(contract, command, fnJSONparams, options) {
    return nearCli("view", contract, command, fnJSONparams, options);
}
exports.view = view;
// format output helper functions
// get single number output on a near view call
function lastNumber(stdo) {
    if (!stdo)
        return "";
    const items = stdo.split("\n");
    if (items.length < 2)
        return "";
    return items[items.length - 2].replace(/'/g, "");
}
exports.lastNumber = lastNumber;
// formats a large amount adding _ as thousands separator
function thsep(stdonum) {
    if (stdonum && stdonum.length > 3) {
        for (let n = stdonum.length - 3; n >= 1; n -= 3) {
            stdonum = stdonum.slice(0, n) + "_" + stdonum.slice(n);
        }
    }
    return stdonum;
}
exports.thsep = thsep;
//# sourceMappingURL=SpawnNearCli.js.map
'''
'''--- dist/model-TS/util/color.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.greenOK = exports.logErr = exports.green = exports.yellow = exports.red = exports.normal = void 0;
exports.normal = '\x1b[39;49m';
exports.red = '\x1b[91m';
exports.yellow = '\x1b[93m';
exports.green = '\x1b[32m';
function logErr(text) {
    console.error(exports.red + "ERR: " + exports.normal + text);
}
exports.logErr = logErr;
function greenOK() {
    console.log(exports.green + "OK" + exports.normal);
}
exports.greenOK = greenOK;
//# sourceMappingURL=color.js.map
'''
'''--- dist/model-TS/util/saveConfig.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveConfig = void 0;
const fs_1 = require("fs");
const path = require("path");
const CLIConfig_1 = require("../CLIConfig");
const color_1 = require("./color");
function saveConfig(userAccount, contractAccount) {
    // @ts-ignore -- import.meta.url
    let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..");
    if (basedir.startsWith("\\"))
        basedir = basedir.slice(1); // windows compat remove extra "\"
    const cliConfigPath = path.join(basedir, "CLIConfig.js");
    process.stdout.write(`saving cli-config to ${cliConfigPath}...`);
    try {
        if (!userAccount)
            userAccount = CLIConfig_1.cliConfig.userAccount;
        if (!contractAccount)
            contractAccount = CLIConfig_1.cliConfig.contractAccount;
        const text = `
        export const cliConfig =
            {
                userAccount: "${userAccount}",
                contractAccount: "${contractAccount}"
            }
        `;
        fs_1.writeFileSync(cliConfigPath, text);
        console.log(`${color_1.green}OK${color_1.normal}`);
    }
    catch (err) {
        console.log(`${color_1.red}ERR:${err.message}${color_1.normal}`);
        throw (err);
    }
}
exports.saveConfig = saveConfig;
//# sourceMappingURL=saveConfig.js.map
'''
'''--- dist/test/expect.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
// ------------------------------
// -- function expect().toBe() --
// ------------------------------
// ---------------------------
function deepEqual(object1, object2) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (const key of keys1) {
        const val1 = object1[key];
        const val2 = object2[key];
        const areObjects = isObject(val1) && isObject(val2);
        if (areObjects && !deepEqual(val1, val2) ||
            !areObjects && val1 !== val2) {
            console.log(red + val1 + " !== " + val2 + normal);
            return false;
        }
    }
    return true;
}
function isObject(object) {
    return object != null && typeof object === 'object';
}
let savedTitle;
let saveReceived;
const red = '\x1b[91m';
const yellow = '\x1b[93m';
const green = '\x1b[32m';
const normal = '\x1b[39;49m';
function expect(title, received) {
    savedTitle = title || "";
    saveReceived = received;
    return expect.prototype;
}
expect.prototype.toBe = function (expected) {
    let eq = false;
    if (isObject(expected) && isObject(saveReceived)) {
        eq = deepEqual(expected, saveReceived);
    }
    else {
        eq = (expected == saveReceived);
    }
    if (!eq) {
        console.log(red + "ERR: expect failed: " + savedTitle + normal);
        console.log("      received: " + yellow + util_1.inspect(saveReceived, { depth: 10 }) + normal);
        console.log("      expected: " + green + util_1.inspect(expected, { depth: 10 }) + normal);
        process.exit(1);
    }
    else {
        console.log(green + "OK: " + normal + savedTitle);
    }
    return expect.prototype;
};
exports.default = expect;
//# sourceMappingURL=expect.js.map
'''
'''--- dist/test/test-deploy.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const mkPath = require("../lib/util/mkPath");
const color = require("../lib/util/color.js");
const child_process = require("child_process");
let nickname = "";
let contractCli = "";
//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd, args, options) {
    const spawnOptions = {
        shell: true,
        //cwd: basedir,
        stdio: "inherit"
    };
    if (!options || !options["hideCommand"])
        console.log(color.yellow, ">", cmd, ...args, color.normal);
    const execResult = child_process.spawnSync(cmd, args, spawnOptions);
    if (execResult.error) {
        color.logErr(execResult.error.message);
        process.exit(5);
    }
    if (execResult.status !== 0 && (!options || options["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`);
        process.exit(execResult.status);
    }
    return execResult.status;
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
function near(command, args, options) {
    args.unshift(command);
    return spawn("near", args, options);
}
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command, args, options) {
    const argsArray = args.split(" ");
    argsArray.unshift(command);
    return spawn("node", argsArray, options);
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args, options) {
    console.log(color.yellow, ">", nickname, args, color.normal);
    const argsArray = args.split(" ");
    argsArray.unshift(contractCli);
    if (!options)
        options = {};
    options["hideCommand"] = true;
    return spawn("node", argsArray, options);
}
//-----------------------------------
//-----------------------------------
console.log("---------- START TESTNET DEPLOY TESTS ---------");
const validNetworks = ["test", "testnet", "ci", "development", "local"];
if (!validNetworks.includes(process.env.NODE_ENV)) {
    color.logErr("NODE_ENV must be one of: " + validNetworks.join("|"));
    process.exit(1);
}
// @ts-ignore -- import.meta.url
//let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..")
let basedir = path.join(__dirname, "..", "..");
if (basedir.startsWith("\\"))
    basedir = basedir.slice(1); // windows compat remove extra "\"
basedir = path.relative(process.cwd(), basedir);
console.log(`basedir: ${basedir}`);
// create project dir
const outDir = path.join(basedir, "out");
process.stdout.write(`Creating dir ${outDir}/...`);
try {
    mkPath.create(outDir);
}
catch (ex) {
    color.logErr("can't mkdir " + outDir);
    throw (ex);
}
color.greenOK();
const contractAccountFile = path.join(basedir, "neardev", "dev-account");
let contractAccount;
//get test account where `near dev-deploy` deployed the contract (if already run)
try {
    contractAccount = fs.readFileSync(contractAccountFile).toString();
}
catch (_a) {
    contractAccount = undefined;
}
if (contractAccount) {
    // delete account
    const result = near("delete", [contractAccount, "lucio.testnet"], { ignoreExitStatus: true });
    if (result == 0)
        fs.unlinkSync(contractAccountFile); //rm file
}
const rustDir = path.join(basedir, "res", "test", "rust");
const wasmFile = path.join(rustDir, "staking-pool", "staking_pool.wasm");
//deploy the contract with near dev-deploy
near("dev-deploy", [wasmFile]);
//get contract account
contractAccount = fs.readFileSync(contractAccountFile).toString();
near("state", [contractAccount]);
//create a user account different from the contract account
const userAccount = `user.${contractAccount}`;
near("create-account", [userAccount, "--masterAccount", contractAccount], { ignoreExitStatus: true });
//create contract-cli named 'staky' for the deployed staking-pool
nickname = "staky";
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`);
//test new staky command
contractCli = path.join(outDir, `${nickname}-cli`, `${nickname}`);
//test call fn "new" - init the contract
cli(`new { owner_id:${userAccount}, stake_public_key:BnLACoaywKGfAEoeKn5HuiAzpn1NTcjTuUkjs44dMiPp, reward_fee_fraction: { numerator:8i, denominator:100i } }`, { ignoreExitStatus: true }); //ignore if alerady initialized
cli("get_owner_id");
cli("get_reward_fee_fraction");
cli("deposit -am 1");
cli("deposit -am 0.5");
cli("withdraw_all");
//-------------
// cleanup
//-------------
{
    // delete user account
    near("delete", [userAccount, contractAccount], { ignoreExitStatus: true });
    // delete contract account
    const result = near("delete", [contractAccount, "lucio.testnet"], { ignoreExitStatus: true });
    if (result == 0)
        fs.unlinkSync(contractAccountFile); //rm file
}
console.log("---------- END TESTNET DEPLOY TESTS ---------");
//# sourceMappingURL=test-deploy.js.map
'''
'''--- dist/test/test-staking-pool.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const mkPath = require("../lib/util/mkPath");
const color = require("../lib/util/color.js");
const child_process = require("child_process");
let nickname = "";
let contractCli = "";
//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd, args, options) {
    const spawnOptions = {
        shell: true,
        //cwd: basedir,
        stdio: "inherit"
    };
    if (!options || !options["hideCommand"])
        console.log(color.yellow, ">", cmd, ...args, color.normal);
    const execResult = child_process.spawnSync(cmd, args, spawnOptions);
    if (execResult.error) {
        color.logErr(execResult.error.message);
        process.exit(5);
    }
    if (execResult.status !== 0 && (!options || options["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`);
        process.exit(execResult.status);
    }
    return execResult.status;
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
function near(command, args, options) {
    args.unshift(command);
    return spawn("near", args, options);
}
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command, args, options) {
    const argsArray = args.split(" ");
    argsArray.unshift(command);
    return spawn("node", argsArray, options);
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args, options) {
    console.log(color.yellow, ">", nickname, args, color.normal);
    const argsArray = args.split(" ");
    argsArray.unshift(contractCli);
    if (!options)
        options = {};
    options["hideCommand"] = true;
    return spawn("node", argsArray, options);
}
//-----------------------------------
//-----------------------------------
console.log("---------- START TESTNET DEPLOY TESTS ---------");
const validNetworks = ["test", "testnet", "ci", "development", "local"];
if (!validNetworks.includes(process.env.NODE_ENV)) {
    color.logErr("NODE_ENV must be one of: " + validNetworks.join("|"));
    process.exit(1);
}
// @ts-ignore -- import.meta.url
let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..");
if (basedir.startsWith("\\"))
    basedir = basedir.slice(1); // windows compat remove extra "\"
basedir = path.relative(process.cwd(), basedir);
console.log(`basedir: ${basedir}`);
// create project dir
const outDir = path.join(basedir, "out");
process.stdout.write(`Creating dir ${outDir}/...`);
try {
    mkPath.create(outDir);
}
catch (ex) {
    color.logErr("can't mkdir " + outDir);
    throw (ex);
}
color.greenOK();
const contractAccountFile = path.join(basedir, "neardev", "dev-account");
const rustDir = path.join(basedir, "res", "test", "rust");
const wasmFile = path.join(rustDir, "staking-pool", "staking_pool.wasm");
//deploy the contract with near dev-deploy
near("dev-deploy", [wasmFile]);
//get contract account
const contractAccount = fs.readFileSync(contractAccountFile).toString();
near("state", [contractAccount]);
//create a user account different from the contract account
const userAccount = `user.${contractAccount}`;
near("create-account", [userAccount, "--masterAccount", contractAccount], { ignoreExitStatus: true });
//create contract-cli named 'staky' for the deployed staking-pool
nickname = "staky";
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`);
//test new staky command
contractCli = path.join(outDir, `${nickname}-cli`, `${nickname}`);
//test call fn "new" - init the contract
cli(`new { owner_id:${userAccount}, stake_public_key:BnLACoaywKGfAEoeKn5HuiAzpn1NTcjTuUkjs44dMiPp, reward_fee_fraction: { numerator:8i, denominator:100i } }`, { ignoreExitStatus: true }); //ignore if alerady initialized
cli("get_owner_id");
cli("get_reward_fee_fraction");
//cli("deposit -am 1")
cli("deposit_and_stake -am 0.1");
cli("deposit_and_stake -am 0.2");
cli("deposit_and_stake -am 0.3");
cli("deposit_and_stake -am 0.5");
//cli("withdraw_all")
cli("ping");
console.log("---------- END TESTNET DEPLOY TESTS ---------");
//# sourceMappingURL=test-staking-pool.js.map
'''
'''--- dist/test/test.ContractAPI.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testContractAPIProducer = exports.testFor = void 0;
const path = require("path");
const mkPath = require("../lib/util/mkPath.js");
const logger = require("../lib/util/logger.js");
const color = require("../lib/util/color.js");
const fs_1 = require("fs");
const Parser_js_1 = require("../lib/Parser/Parser.js");
const ContractAPI_producer_1 = require("../main/ContractAPI-producer");
const child_process_1 = require("child_process");
const TESTNAME = "ContractAPI Producer";
function testFor(rustFile, expectedFile, data) {
    console.log("Testing " + TESTNAME);
    // parse
    let parsedModule;
    try {
        const parser = new Parser_js_1.Parser({ skipFunctionBody: true });
        // parse rust lib file
        parsedModule = parser.parseFile(rustFile);
    }
    catch (ex) {
        console.log(color.red + ex.message + color.normal);
        console.log(ex);
        console.log(process.cwd());
        console.log("Error parsing " + (parsedModule === null || parsedModule === void 0 ? void 0 : parsedModule.name));
        throw (ex);
    }
    console.log("parsed ok: " + (parsedModule === null || parsedModule === void 0 ? void 0 : parsedModule.name));
    const outPath = "out";
    mkPath.create(outPath);
    console.log("writing temp files in " + path.join(process.cwd(), outPath));
    const generatedFile = path.join(outPath, data.nickname + "-API.js");
    // produce
    try {
        ContractAPI_producer_1.ContractAPIProducer.produce(parsedModule, data, generatedFile);
    }
    catch (ex) {
        console.log(ex);
        console.log("Error producing " + (parsedModule === null || parsedModule === void 0 ? void 0 : parsedModule.name));
        throw (ex);
    }
    const generated = fs_1.readFileSync(generatedFile);
    const expected = fs_1.readFileSync(expectedFile);
    if (generated.toString() !== expected.toString()) {
        console.log(color.red + "FAILED " + color.normal);
        console.log("generated: " + generatedFile);
        console.log("expected: " + expectedFile);
        const compareCommand = "meld " + generatedFile + " " + expectedFile;
        console.log(" > " + compareCommand);
        child_process_1.spawn("meld", [generatedFile, expectedFile]);
    }
    else {
        console.log(TESTNAME + " Test " + color.green + "OK" + color.normal);
    }
}
exports.testFor = testFor;
function testContractAPIProducer() {
    logger.setDebugLevel(0);
    //logger.setDebugRange(1490,1800)
    testFor('./res/test/rust/div-pool/src/lib.rs', "./res/test/expected/div-pool-API.js", { nickname: "div", defaultContractName: "diversifying.pools.guildnet" });
    logger.setDebugLevel(0);
    //logger.setDebugRange(1450,1500)
    //testFor('./res/test/rust/NEARSwap/src/lib.rs', "./res/test/expected/swap-API.js",
    //    { nickname: "swap", defaultContractName: "near-clp.betanet" }
    //)
    // logger.setDebugLevel(0)
    //logger.setDebugRange(1450,1500)
    testFor('./res/test/rust/staking-pool/src/lib.rs', "./res/test/expected/staking-pool-API.js", { nickname: "staky", defaultContractName: "tomstaker.stakehouse.betanet" });
    // logger.setDebugLevel(0)
    //logger.setDebugRange(1450,1500)
    testFor('./res/test/rust/lockup/src/lib.rs', "./res/test/expected/lockup-API.js", { nickname: "lockup", defaultContractName: "testcontract.testnet" });
    testFor('./res/test/rust/multisig/src/lib.rs', "./res/test/expected/multisig-API.js", { nickname: "multisig", defaultContractName: "testcontract.testnet" });
    testFor('./res/test/rust/staking-pool-factory/src/lib.rs', "./res/test/expected/factory-API.js", { nickname: "factory", defaultContractName: "testcontract.testnet" });
    testFor('./res/test/rust/voting/src/lib.rs', "./res/test/expected/vote-API.js", { nickname: "vote", defaultContractName: "testcontract.testnet" });
}
exports.testContractAPIProducer = testContractAPIProducer;
//# sourceMappingURL=test.ContractAPI.js.map
'''
'''--- dist/test/test.Tokenizer.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testTokenizer = void 0;
const Lexer_js_1 = require("../lib/Lexer/Lexer.js");
const expect_js_1 = require("./expect.js");
function testThis(rustCode, expected) {
    process.stdout.write("Testing tokenizer ");
    const lexer = new Lexer_js_1.Lexer();
    lexer.startFromString(rustCode);
    const tokens = [];
    while (true) {
        const t = lexer.token;
        if (!t.isSpace())
            tokens.push(`(${Lexer_js_1.TokenCode[t.tokenCode]} ${t.value})`);
        if (t.tokenCode == Lexer_js_1.TokenCode.EOF)
            break;
        lexer.advance();
    }
    expect_js_1.default("tokenizer", tokens).toBe(expected);
}
function testTokenizer() {
    let rustCode = "\n\
    /// The amount of gas given to complete `vote` call.\n\
    const VOTE_GAS: u64 = 100_000_000_000_000;\n\
    \n\
    /// The amount of gas given to complete internal `on_stake_action` call.\n\
    const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;\n\
    ";
    testThis(rustCode, ["(COMMENT /// The amount of gas given to complete `vote` call.)",
        "(WORD const)", "(WORD VOTE_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(OPERATOR =)", "(NUMBER 100_000_000_000_000)", "(PUNCTUATION ;)",
        "(COMMENT /// The amount of gas given to complete internal `on_stake_action` call.)",
        "(WORD const)", "(WORD ON_STAKE_ACTION_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(OPERATOR =)", "(NUMBER 20_000_000_000_000)", "(PUNCTUATION ;)",
        "(EOF )"]);
    // ---------------------
    rustCode = `
        impl fmt::Display for PoolInfo {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                return write!(
                    f,
                    "({}, {}, {})",
                    self.ynear, self.reserve, self.total_shares
                );
            }
        }`;
    testThis(rustCode, ['(WORD impl)', '(WORD fmt)', '(PUNCTUATION ::)', '(WORD Display)', '(WORD for)', '(WORD PoolInfo)', '(PUNCTUATION {)',
        '(WORD fn)', '(WORD fmt)', '(PUNCTUATION ()', '(OPERATOR &)', '(WORD self)', '(PUNCTUATION ,)', '(WORD f)',
        '(PUNCTUATION :)', '(OPERATOR &)', '(WORD mut)', '(WORD fmt)', '(PUNCTUATION ::)',
        '(WORD Formatter)', "(PUNCTUATION <')", '(WORD _)', '(OPERATOR >)', '(PUNCTUATION ))',
        '(OPERATOR ->)', '(WORD fmt)', '(PUNCTUATION ::)', '(WORD Result)', '(PUNCTUATION {)',
        '(WORD return)', '(WORD write)', '(OPERATOR !)', '(PUNCTUATION ()',
        '(WORD f)', '(PUNCTUATION ,)',
        '(LITERAL_STRING "({}, {}, {})")',
        '(PUNCTUATION ,)',
        '(WORD self)', '(PUNCTUATION .)', '(WORD ynear)', '(PUNCTUATION ,)', '(WORD self)', '(PUNCTUATION .)', '(WORD reserve)',
        '(PUNCTUATION ,)', '(WORD self)', '(PUNCTUATION .)', '(WORD total_shares)', '(PUNCTUATION ))', '(PUNCTUATION ;)',
        '(PUNCTUATION })',
        '(PUNCTUATION })',
        '(EOF )']);
}
exports.testTokenizer = testTokenizer;
//# sourceMappingURL=test.Tokenizer.js.map
'''
'''--- dist/test/test.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_Tokenizer_js_1 = require("./test.Tokenizer.js");
const test_ContractAPI_js_1 = require("./test.ContractAPI.js");
const expect_js_1 = require("./expect.js");
const child_process = require("child_process");
const color = require("../lib/util/color.js");
const CommandLineArgs = require("../../res/model-ES2018/util/CommandLineArgs.js");
const options = require("../../res/model-ES2018/CLIOptions.js");
const nickname = "testy";
const testyContractCliPath = "out/" + nickname + "-cli";
//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd, args, spawnOpt) {
    const spawnOptions = {
        shell: true,
        //cwd: basedir,
        stdio: "inherit"
    };
    if (!spawnOpt || !spawnOpt["hideCommand"])
        console.log(color.yellow, ">", cmd, ...args, color.normal);
    const execResult = child_process.spawnSync(cmd, args, spawnOptions);
    if (execResult.error) {
        color.logErr(execResult.error.message);
        process.exit(5);
    }
    if (execResult.status !== 0 && (!spawnOpt || spawnOpt["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`);
        process.exit(execResult.status);
    }
    return execResult.status;
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
// function near(command: string, args: string[], spawnOpt?: Record<string, unknown>): number {
//     args.unshift(command)
//     return spawn("near", args, spawnOpt)
// }
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command, args, spawnOpt) {
    const argsArray = args.split(" ");
    argsArray.unshift(command);
    return spawn("node", argsArray, spawnOpt);
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args, spawnOpt) {
    console.log(color.yellow, ">", nickname, args, color.normal);
    const argsArray = args.split(" ");
    argsArray.unshift(testyContractCliPath);
    if (!spawnOpt)
        spawnOpt = {};
    spawnOpt["hideCommand"] = true;
    return spawn("node", argsArray, spawnOpt);
}
//-----------------------------
function testCLIparser() {
    let cmdline = `node nearswap add_liquidity { token: "gold.nearswap.testnet", max_tokens: 10, min_shares: 5 } --amount 10`;
    process.argv = cmdline.split(' ');
    let a = new CommandLineArgs(options);
    expect_js_1.default("command", a.consumeString("cmd")).toBe("add_liquidity");
    expect_js_1.default("JSON", a.consumeJSON("json args")).toBe({ token: '"gold.nearswap.testnet"', max_tokens: "10" + "".padEnd(24, "0"), min_shares: "5" + "".padEnd(24, "0") });
    expect_js_1.default("options.amount", options.amount.value).toBe(10);
    //no spaces around { }
    cmdline = `node nearswap add_liquidity {token:gold.nearswap.testnet max_tokens:10 min_shares:5} --amount 10`;
    process.argv = cmdline.split(' ');
    a = new CommandLineArgs(options);
    expect_js_1.default("command", a.consumeString("cmd")).toBe("add_liquidity");
    expect_js_1.default("JSON", a.consumeJSON("json args")).toBe({ token: "gold.nearswap.testnet", max_tokens: "10" + "".padEnd(24, "0"), min_shares: "5" + "".padEnd(24, "0") });
    expect_js_1.default("options.amount", options.amount.value).toBe(10);
    //no spaces around { } v2
    cmdline = `node staky new {account:lucio.testnet, reward_fee_fraction: {numerator:10i, denominator:8i}} --amount 10N`;
    process.argv = cmdline.split(' ');
    a = new CommandLineArgs(options);
    expect_js_1.default("command", a.consumeString("cmd")).toBe("new");
    expect_js_1.default("JSON", a.consumeJSON("json args")).toBe({ account: "lucio.testnet", reward_fee_fraction: { numerator: 10, denominator: 8 } });
    expect_js_1.default("options.amount", options.amount.value).toBe("10N");
}
//------------------------------------------------------
console.log("---------- START PARSE TESTS ---------");
spawn("rm", ["-rf", "out"]);
testCLIparser();
test_Tokenizer_js_1.testTokenizer();
test_ContractAPI_js_1.testContractAPIProducer();
console.log("---------- END PARSE TESTS ---------");
//------------------------------------------------------
console.log("---------- START dist/main/create-contract-cli TEST ---------");
const contractAccount = "AcontractAccount";
const userAccount = "AuserAccount";
const outDir = "out"; // will add out/testy-cli
//create contract-cli named 'staky' for the deployed staking-pool
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`);
//test json parsing
//test configure contractName & accountId
cli("--cliConfig --contractName contract.account.testnet --accountId yourAccount.near");
cli("--info");
cli(`--cliConfig --contractName ${contractAccount} --accountId test.near`);
cli("--info");
//cleanup (leave /out for meld comparisions)
//spawn("cd",["out", "&&", "rm","-rf", "testy-cli"])
console.log("---------- dist/main/create-contract-cli ---------");
//# sourceMappingURL=test.js.map
'''
'''--- package-lock.json ---
{
  "name": "create-contract-cli",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@babel/code-frame": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.10.4.tgz",
      "integrity": "sha512-vG6SvB6oYEhvgisZNFRmRCUkLz11c7rp+tbNTynGqc6mS1d5ATd/sGyV6W0KZZnXRKMTzZDRgQT3Ou9jhpAfUg==",
      "dev": true,
      "requires": {
        "@babel/highlight": "^7.10.4"
      }
    },
    "@babel/helper-validator-identifier": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.10.4.tgz",
      "integrity": "sha512-3U9y+43hz7ZM+rzG24Qe2mufW5KhvFg/NhnNph+i9mgCtdTCtMJuI1TMkrIUiK7Ix4PYlRF9I5dhqaLYA/ADXw==",
      "dev": true
    },
    "@babel/highlight": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.10.4.tgz",
      "integrity": "sha512-i6rgnR/YgPEQzZZnbTHHuZdlE8qyoBNalD6F+q4vAFlcMEcqmkoG+mPqJYJCo63qPf74+Y1UZsl3l6f7/RIkmA==",
      "dev": true,
      "requires": {
        "@babel/helper-validator-identifier": "^7.10.4",
        "chalk": "^2.0.0",
        "js-tokens": "^4.0.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        }
      }
    },
    "@eslint/eslintrc": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.1.3.tgz",
      "integrity": "sha512-4YVwPkANLeNtRjMekzux1ci8hIaH5eGKktGqR0d3LWsKNn5B2X/1Z6Trxy7jQXl9EBGE6Yj02O+t09FMeRllaA==",
      "dev": true,
      "requires": {
        "ajv": "^6.12.4",
        "debug": "^4.1.1",
        "espree": "^7.3.0",
        "globals": "^12.1.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.2.1",
        "js-yaml": "^3.13.1",
        "lodash": "^4.17.19",
        "minimatch": "^3.0.4",
        "strip-json-comments": "^3.1.1"
      },
      "dependencies": {
        "ignore": {
          "version": "4.0.6",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
          "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
          "dev": true
        }
      }
    },
    "@nodelib/fs.scandir": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.3.tgz",
      "integrity": "sha512-eGmwYQn3gxo4r7jdQnkrrN6bY478C3P+a/y72IJukF8LjB6ZHeB3c+Ehacj3sYeSmUXGlnA67/PmbM9CVwL7Dw==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "2.0.3",
        "run-parallel": "^1.1.9"
      }
    },
    "@nodelib/fs.stat": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.3.tgz",
      "integrity": "sha512-bQBFruR2TAwoevBEd/NWMoAAtNGzTRgdrqnYCc7dhzfoNvqPzLyqlEQnzZ3kVnNrSp25iyxE00/3h2fqGAGArA==",
      "dev": true
    },
    "@nodelib/fs.walk": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.4.tgz",
      "integrity": "sha512-1V9XOY4rDW0rehzbrcqAmHnz8e7SKvX27gh8Gt2WgB0+pdzdiLV83p72kZPU+jvMbS1qU5mauP2iOvO8rhmurQ==",
      "dev": true,
      "requires": {
        "@nodelib/fs.scandir": "2.1.3",
        "fastq": "^1.6.0"
      }
    },
    "@types/json-schema": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.6.tgz",
      "integrity": "sha512-3c+yGKvVP5Y9TYBEibGNR+kLtijnj7mYrXRg+WpFb2X9xm04g/DXYkfg4hmzJQosc9snFNUPkbYIhu+KAm6jJw==",
      "dev": true
    },
    "@types/json5": {
      "version": "0.0.29",
      "resolved": "https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz",
      "integrity": "sha1-7ihweulOEdK4J7y+UnC86n8+ce4=",
      "dev": true
    },
    "@types/node": {
      "version": "14.11.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.11.2.tgz",
      "integrity": "sha512-jiE3QIxJ8JLNcb1Ps6rDbysDhN4xa8DJJvuC9prr6w+1tIh+QAbYyNF3tyiZNLDBIuBCf4KEcV2UvQm/V60xfA==",
      "dev": true
    },
    "@typescript-eslint/eslint-plugin": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-4.4.0.tgz",
      "integrity": "sha512-RVt5wU9H/2H+N/ZrCasTXdGbUTkbf7Hfi9eLiA8vPQkzUJ/bLDCC3CsoZioPrNcnoyN8r0gT153dC++A4hKBQQ==",
      "dev": true,
      "requires": {
        "@typescript-eslint/experimental-utils": "4.4.0",
        "@typescript-eslint/scope-manager": "4.4.0",
        "debug": "^4.1.1",
        "functional-red-black-tree": "^1.0.1",
        "regexpp": "^3.0.0",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      }
    },
    "@typescript-eslint/experimental-utils": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-4.4.0.tgz",
      "integrity": "sha512-01+OtK/oWeSJTjQcyzDztfLF1YjvKpLFo+JZmurK/qjSRcyObpIecJ4rckDoRCSh5Etw+jKfdSzVEHevh9gJ1w==",
      "dev": true,
      "requires": {
        "@types/json-schema": "^7.0.3",
        "@typescript-eslint/scope-manager": "4.4.0",
        "@typescript-eslint/types": "4.4.0",
        "@typescript-eslint/typescript-estree": "4.4.0",
        "eslint-scope": "^5.0.0",
        "eslint-utils": "^2.0.0"
      }
    },
    "@typescript-eslint/parser": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-4.4.0.tgz",
      "integrity": "sha512-yc14iEItCxoGb7W4Nx30FlTyGpU9r+j+n1LUK/exlq2eJeFxczrz/xFRZUk2f6yzWfK+pr1DOTyQnmDkcC4TnA==",
      "dev": true,
      "requires": {
        "@typescript-eslint/scope-manager": "4.4.0",
        "@typescript-eslint/types": "4.4.0",
        "@typescript-eslint/typescript-estree": "4.4.0",
        "debug": "^4.1.1"
      }
    },
    "@typescript-eslint/scope-manager": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-4.4.0.tgz",
      "integrity": "sha512-r2FIeeU1lmW4K3CxgOAt8djI5c6Q/5ULAgdVo9AF3hPMpu0B14WznBAtxrmB/qFVbVIB6fSx2a+EVXuhSVMEyA==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.4.0",
        "@typescript-eslint/visitor-keys": "4.4.0"
      }
    },
    "@typescript-eslint/types": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-4.4.0.tgz",
      "integrity": "sha512-nU0VUpzanFw3jjX+50OTQy6MehVvf8pkqFcURPAE06xFNFenMj1GPEI6IESvp7UOHAnq+n/brMirZdR+7rCrlA==",
      "dev": true
    },
    "@typescript-eslint/typescript-estree": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-4.4.0.tgz",
      "integrity": "sha512-Fh85feshKXwki4nZ1uhCJHmqKJqCMba+8ZicQIhNi5d5jSQFteWiGeF96DTjO8br7fn+prTP+t3Cz/a/3yOKqw==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.4.0",
        "@typescript-eslint/visitor-keys": "4.4.0",
        "debug": "^4.1.1",
        "globby": "^11.0.1",
        "is-glob": "^4.0.1",
        "lodash": "^4.17.15",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      }
    },
    "@typescript-eslint/visitor-keys": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-4.4.0.tgz",
      "integrity": "sha512-oBWeroUZCVsHLiWRdcTXJB7s1nB3taFY8WGvS23tiAlT6jXVvsdAV4rs581bgdEjOhn43q6ro7NkOiLKu6kFqA==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.4.0",
        "eslint-visitor-keys": "^2.0.0"
      }
    },
    "acorn": {
      "version": "7.4.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
      "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
      "dev": true
    },
    "acorn-jsx": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.1.tgz",
      "integrity": "sha512-K0Ptm/47OKfQRpNQ2J/oIN/3QYiK6FwW+eJbILhsdxh2WTLdl+30o8aGdTbm5JbffpFFAg/g+zi1E+jvJha5ng==",
      "dev": true
    },
    "ajv": {
      "version": "6.12.5",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.5.tgz",
      "integrity": "sha512-lRF8RORchjpKG50/WFf8xmg7sgCLFiYNNnqdKflk63whMQcWR5ngGjiSXkL9bjxy6B2npOK2HSMN49jEBMSkag==",
      "dev": true,
      "requires": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      }
    },
    "ansi-colors": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
      "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
      "dev": true
    },
    "ansi-regex": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
      "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
      "dev": true
    },
    "ansi-styles": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
      "dev": true,
      "requires": {
        "color-convert": "^1.9.0"
      }
    },
    "argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "requires": {
        "sprintf-js": "~1.0.2"
      }
    },
    "array-includes": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/array-includes/-/array-includes-3.1.1.tgz",
      "integrity": "sha512-c2VXaCHl7zPsvpkFsw4nxvFie4fh1ur9bpcgsVkIjqn0H/Xwdg+7fv3n2r/isyS8EBj5b06M9kHyZuIr4El6WQ==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0",
        "is-string": "^1.0.5"
      }
    },
    "array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true
    },
    "array.prototype.flat": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/array.prototype.flat/-/array.prototype.flat-1.2.3.tgz",
      "integrity": "sha512-gBlRZV0VSmfPIeWfuuy56XZMvbVfbEUnOXUvt3F/eUUUSyzlgLxhEX4YAEpxNAogRGehPSnfXyPtYyKAhkzQhQ==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1"
      }
    },
    "astral-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-1.0.0.tgz",
      "integrity": "sha512-+Ryf6g3BKoRc7jfp7ad8tM4TtMiaWvbF/1/sQcZPkkS7ag3D5nMBCe2UfOTONtAkaG0tO0ij3C5Lwmf1EiyjHg==",
      "dev": true
    },
    "balanced-match": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c=",
      "dev": true
    },
    "brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "requires": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "braces": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
      "dev": true,
      "requires": {
        "fill-range": "^7.0.1"
      }
    },
    "callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true
    },
    "chalk": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.0.tgz",
      "integrity": "sha512-qwx12AxXe2Q5xQ43Ac//I6v5aXTipYrSESdOgzrN+9XjgEpyjpKuvSGaN4qE93f7TQTlerQQ8S+EQ0EyDoVL1A==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "4.3.0",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
          "dev": true,
          "requires": {
            "color-convert": "^2.0.1"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        },
        "color-name": {
          "version": "1.1.4",
          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
          "dev": true
        },
        "has-flag": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
          "dev": true
        },
        "supports-color": {
          "version": "7.2.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
          "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
          "dev": true,
          "requires": {
            "has-flag": "^4.0.0"
          }
        }
      }
    },
    "color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "dev": true,
      "requires": {
        "color-name": "1.1.3"
      }
    },
    "color-name": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
      "dev": true
    },
    "concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
      "dev": true
    },
    "contains-path": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/contains-path/-/contains-path-0.1.0.tgz",
      "integrity": "sha1-/ozxhP9mcLa67wGp1IYaXL7EEgo=",
      "dev": true
    },
    "cross-spawn": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
      "dev": true,
      "requires": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      }
    },
    "debug": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.2.0.tgz",
      "integrity": "sha512-IX2ncY78vDTjZMFUdmsvIRFY2Cf4FnD0wRs+nQwJU8Lu99/tPFdb0VybiiMTPe3I6rQmwsqQqRBvxU+bZ/I8sg==",
      "dev": true,
      "requires": {
        "ms": "2.1.2"
      }
    },
    "deep-is": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
      "dev": true
    },
    "define-properties": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
      "dev": true,
      "requires": {
        "object-keys": "^1.0.12"
      }
    },
    "dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "requires": {
        "path-type": "^4.0.0"
      }
    },
    "doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "requires": {
        "esutils": "^2.0.2"
      }
    },
    "emoji-regex": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
      "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
      "dev": true
    },
    "enquirer": {
      "version": "2.3.6",
      "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz",
      "integrity": "sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==",
      "dev": true,
      "requires": {
        "ansi-colors": "^4.1.1"
      }
    },
    "error-ex": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
      "integrity": "sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==",
      "dev": true,
      "requires": {
        "is-arrayish": "^0.2.1"
      }
    },
    "es-abstract": {
      "version": "1.17.7",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.17.7.tgz",
      "integrity": "sha512-VBl/gnfcJ7OercKA9MVaegWsBHFjV492syMudcnQZvt/Dw8ezpcOHYZXa/J96O8vx+g4x65YKhxOwDUh63aS5g==",
      "dev": true,
      "requires": {
        "es-to-primitive": "^1.2.1",
        "function-bind": "^1.1.1",
        "has": "^1.0.3",
        "has-symbols": "^1.0.1",
        "is-callable": "^1.2.2",
        "is-regex": "^1.1.1",
        "object-inspect": "^1.8.0",
        "object-keys": "^1.1.1",
        "object.assign": "^4.1.1",
        "string.prototype.trimend": "^1.0.1",
        "string.prototype.trimstart": "^1.0.1"
      }
    },
    "es-to-primitive": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz",
      "integrity": "sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==",
      "dev": true,
      "requires": {
        "is-callable": "^1.1.4",
        "is-date-object": "^1.0.1",
        "is-symbol": "^1.0.2"
      }
    },
    "escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
      "dev": true
    },
    "eslint": {
      "version": "7.10.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-7.10.0.tgz",
      "integrity": "sha512-BDVffmqWl7JJXqCjAK6lWtcQThZB/aP1HXSH1JKwGwv0LQEdvpR7qzNrUT487RM39B5goWuboFad5ovMBmD8yA==",
      "dev": true,
      "requires": {
        "@babel/code-frame": "^7.0.0",
        "@eslint/eslintrc": "^0.1.3",
        "ajv": "^6.10.0",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.0.1",
        "doctrine": "^3.0.0",
        "enquirer": "^2.3.5",
        "eslint-scope": "^5.1.1",
        "eslint-utils": "^2.1.0",
        "eslint-visitor-keys": "^1.3.0",
        "espree": "^7.3.0",
        "esquery": "^1.2.0",
        "esutils": "^2.0.2",
        "file-entry-cache": "^5.0.1",
        "functional-red-black-tree": "^1.0.1",
        "glob-parent": "^5.0.0",
        "globals": "^12.1.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.0.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "js-yaml": "^3.13.1",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash": "^4.17.19",
        "minimatch": "^3.0.4",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.1",
        "progress": "^2.0.0",
        "regexpp": "^3.1.0",
        "semver": "^7.2.1",
        "strip-ansi": "^6.0.0",
        "strip-json-comments": "^3.1.0",
        "table": "^5.2.3",
        "text-table": "^0.2.0",
        "v8-compile-cache": "^2.0.3"
      },
      "dependencies": {
        "eslint-visitor-keys": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
          "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
          "dev": true
        },
        "ignore": {
          "version": "4.0.6",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
          "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
          "dev": true
        }
      }
    },
    "eslint-config-standard": {
      "version": "14.1.1",
      "resolved": "https://registry.npmjs.org/eslint-config-standard/-/eslint-config-standard-14.1.1.tgz",
      "integrity": "sha512-Z9B+VR+JIXRxz21udPTL9HpFMyoMUEeX1G251EQ6e05WD9aPVtVBn09XUmZ259wCMlCDmYDSZG62Hhm+ZTJcUg==",
      "dev": true
    },
    "eslint-import-resolver-node": {
      "version": "0.3.4",
      "resolved": "https://registry.npmjs.org/eslint-import-resolver-node/-/eslint-import-resolver-node-0.3.4.tgz",
      "integrity": "sha512-ogtf+5AB/O+nM6DIeBUNr2fuT7ot9Qg/1harBfBtaP13ekEWFQEEMP94BCB7zaNW3gyY+8SHYF00rnqYwXKWOA==",
      "dev": true,
      "requires": {
        "debug": "^2.6.9",
        "resolve": "^1.13.1"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        }
      }
    },
    "eslint-module-utils": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/eslint-module-utils/-/eslint-module-utils-2.6.0.tgz",
      "integrity": "sha512-6j9xxegbqe8/kZY8cYpcp0xhbK0EgJlg3g9mib3/miLaExuuwc3n5UEfSnU6hWMbT0FAYVvDbL9RrRgpUeQIvA==",
      "dev": true,
      "requires": {
        "debug": "^2.6.9",
        "pkg-dir": "^2.0.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        }
      }
    },
    "eslint-plugin-es": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-es/-/eslint-plugin-es-3.0.1.tgz",
      "integrity": "sha512-GUmAsJaN4Fc7Gbtl8uOBlayo2DqhwWvEzykMHSCZHU3XdJ+NSzzZcVhXh3VxX5icqQ+oQdIEawXX8xkR3mIFmQ==",
      "dev": true,
      "requires": {
        "eslint-utils": "^2.0.0",
        "regexpp": "^3.0.0"
      }
    },
    "eslint-plugin-import": {
      "version": "2.22.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-import/-/eslint-plugin-import-2.22.1.tgz",
      "integrity": "sha512-8K7JjINHOpH64ozkAhpT3sd+FswIZTfMZTjdx052pnWrgRCVfp8op9tbjpAk3DdUeI/Ba4C8OjdC0r90erHEOw==",
      "dev": true,
      "requires": {
        "array-includes": "^3.1.1",
        "array.prototype.flat": "^1.2.3",
        "contains-path": "^0.1.0",
        "debug": "^2.6.9",
        "doctrine": "1.5.0",
        "eslint-import-resolver-node": "^0.3.4",
        "eslint-module-utils": "^2.6.0",
        "has": "^1.0.3",
        "minimatch": "^3.0.4",
        "object.values": "^1.1.1",
        "read-pkg-up": "^2.0.0",
        "resolve": "^1.17.0",
        "tsconfig-paths": "^3.9.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "doctrine": {
          "version": "1.5.0",
          "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-1.5.0.tgz",
          "integrity": "sha1-N53Ocw9hZvds76TmcHoVmwLFpvo=",
          "dev": true,
          "requires": {
            "esutils": "^2.0.2",
            "isarray": "^1.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        }
      }
    },
    "eslint-plugin-node": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-node/-/eslint-plugin-node-11.1.0.tgz",
      "integrity": "sha512-oUwtPJ1W0SKD0Tr+wqu92c5xuCeQqB3hSCHasn/ZgjFdA9iDGNkNf2Zi9ztY7X+hNuMib23LNGRm6+uN+KLE3g==",
      "dev": true,
      "requires": {
        "eslint-plugin-es": "^3.0.0",
        "eslint-utils": "^2.0.0",
        "ignore": "^5.1.1",
        "minimatch": "^3.0.4",
        "resolve": "^1.10.1",
        "semver": "^6.1.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "eslint-plugin-promise": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-promise/-/eslint-plugin-promise-4.2.1.tgz",
      "integrity": "sha512-VoM09vT7bfA7D+upt+FjeBO5eHIJQBUWki1aPvB+vbNiHS3+oGIJGIeyBtKQTME6UPXXy3vV07OL1tHd3ANuDw==",
      "dev": true
    },
    "eslint-plugin-standard": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-standard/-/eslint-plugin-standard-4.0.1.tgz",
      "integrity": "sha512-v/KBnfyaOMPmZc/dmc6ozOdWqekGp7bBGq4jLAecEfPGmfKiWS4sA8sC0LqiV9w5qmXAtXVn4M3p1jSyhY85SQ==",
      "dev": true
    },
    "eslint-scope": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
      "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
      "dev": true,
      "requires": {
        "esrecurse": "^4.3.0",
        "estraverse": "^4.1.1"
      }
    },
    "eslint-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
      "integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
      "dev": true,
      "requires": {
        "eslint-visitor-keys": "^1.1.0"
      },
      "dependencies": {
        "eslint-visitor-keys": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
          "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
          "dev": true
        }
      }
    },
    "eslint-visitor-keys": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.0.0.tgz",
      "integrity": "sha512-QudtT6av5WXels9WjIM7qz1XD1cWGvX4gGXvp/zBn9nXG02D0utdU3Em2m/QjTnrsk6bBjmCygl3rmj118msQQ==",
      "dev": true
    },
    "espree": {
      "version": "7.3.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-7.3.0.tgz",
      "integrity": "sha512-dksIWsvKCixn1yrEXO8UosNSxaDoSYpq9reEjZSbHLpT5hpaCAKTLBwq0RHtLrIr+c0ByiYzWT8KTMRzoRCNlw==",
      "dev": true,
      "requires": {
        "acorn": "^7.4.0",
        "acorn-jsx": "^5.2.0",
        "eslint-visitor-keys": "^1.3.0"
      },
      "dependencies": {
        "eslint-visitor-keys": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
          "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
          "dev": true
        }
      }
    },
    "esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true
    },
    "esquery": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.3.1.tgz",
      "integrity": "sha512-olpvt9QG0vniUBZspVRN6lwB7hOZoTRtT+jzR+tS4ffYx2mzbw+z0XCOk44aaLYKApNX5nMm+E+P6o25ip/DHQ==",
      "dev": true,
      "requires": {
        "estraverse": "^5.1.0"
      },
      "dependencies": {
        "estraverse": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
          "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
          "dev": true
        }
      }
    },
    "esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "requires": {
        "estraverse": "^5.2.0"
      },
      "dependencies": {
        "estraverse": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
          "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
          "dev": true
        }
      }
    },
    "estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
      "dev": true
    },
    "esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true
    },
    "fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true
    },
    "fast-glob": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.4.tgz",
      "integrity": "sha512-kr/Oo6PX51265qeuCYsyGypiO5uJFgBS0jksyG7FUeCyQzNwYnzrNIMR1NXfkZXsMYXYLRAHgISHBz8gQcxKHQ==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.0",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.2",
        "picomatch": "^2.2.1"
      }
    },
    "fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true
    },
    "fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
      "dev": true
    },
    "fastq": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.8.0.tgz",
      "integrity": "sha512-SMIZoZdLh/fgofivvIkmknUXyPnvxRE3DhtZ5Me3Mrsk5gyPL42F0xr51TdRXskBxHfMp+07bcYzfsYEsSQA9Q==",
      "dev": true,
      "requires": {
        "reusify": "^1.0.4"
      }
    },
    "file-entry-cache": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-5.0.1.tgz",
      "integrity": "sha512-bCg29ictuBaKUwwArK4ouCaqDgLZcysCFLmM/Yn/FDoqndh/9vNuQfXRDvTuXKLxfD/JtZQGKFT8MGcJBK644g==",
      "dev": true,
      "requires": {
        "flat-cache": "^2.0.1"
      }
    },
    "fill-range": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
      "dev": true,
      "requires": {
        "to-regex-range": "^5.0.1"
      }
    },
    "find-up": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz",
      "integrity": "sha1-RdG35QbHF93UgndaK3eSCjwMV6c=",
      "dev": true,
      "requires": {
        "locate-path": "^2.0.0"
      }
    },
    "flat-cache": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-2.0.1.tgz",
      "integrity": "sha512-LoQe6yDuUMDzQAEH8sgmh4Md6oZnc/7PjtwjNFSzveXqSHt6ka9fPBuso7IGf9Rz4uqnSnWiFH2B/zj24a5ReA==",
      "dev": true,
      "requires": {
        "flatted": "^2.0.0",
        "rimraf": "2.6.3",
        "write": "1.0.3"
      }
    },
    "flatted": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-2.0.2.tgz",
      "integrity": "sha512-r5wGx7YeOwNWNlCA0wQ86zKyDLMQr+/RB8xy74M4hTphfmjlijTSSXGuH8rnvKZnfT9i+75zmd8jcKdMR4O6jA==",
      "dev": true
    },
    "fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
      "dev": true
    },
    "function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
      "dev": true
    },
    "functional-red-black-tree": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
      "integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
      "dev": true
    },
    "glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "dev": true,
      "requires": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      }
    },
    "glob-parent": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.1.tgz",
      "integrity": "sha512-FnI+VGOpnlGHWZxthPGR+QhR78fuiK0sNLkHQv+bL9fQi57lNNdquIbna/WrfROrolq8GK5Ek6BiMwqL/voRYQ==",
      "dev": true,
      "requires": {
        "is-glob": "^4.0.1"
      }
    },
    "globals": {
      "version": "12.4.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-12.4.0.tgz",
      "integrity": "sha512-BWICuzzDvDoH54NHKCseDanAhE3CeDorgDL5MT6LMXXj2WCnd9UC2szdk4AWLfjdgNBCXLUanXYcpBBKOSWGwg==",
      "dev": true,
      "requires": {
        "type-fest": "^0.8.1"
      }
    },
    "globby": {
      "version": "11.0.1",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.0.1.tgz",
      "integrity": "sha512-iH9RmgwCmUJHi2z5o2l3eTtGBtXek1OYlHrbcxOYugyHLmAsZrPj43OtHThd62Buh/Vv6VyCBD2bdyWcGNQqoQ==",
      "dev": true,
      "requires": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.1.1",
        "ignore": "^5.1.4",
        "merge2": "^1.3.0",
        "slash": "^3.0.0"
      }
    },
    "graceful-fs": {
      "version": "4.2.4",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.4.tgz",
      "integrity": "sha512-WjKPNJF79dtJAVniUlGGWHYGz2jWxT6VhN/4m1NdkbZ2nOsEF+cI1Edgql5zCRhs/VsQYRvrXctxktVXZUkixw==",
      "dev": true
    },
    "has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dev": true,
      "requires": {
        "function-bind": "^1.1.1"
      }
    },
    "has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
      "dev": true
    },
    "has-symbols": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.1.tgz",
      "integrity": "sha512-PLcsoqu++dmEIZB+6totNFKq/7Do+Z0u4oT0zKOJNl3lYK6vGwwu2hjHs+68OEZbTjiUE9bgOABXbP/GvrS0Kg==",
      "dev": true
    },
    "hosted-git-info": {
      "version": "2.8.8",
      "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.8.8.tgz",
      "integrity": "sha512-f/wzC2QaWBs7t9IYqB4T3sR1xviIViXJRJTWBlx2Gf3g0Xi5vI7Yy4koXQ1c9OYDGHN9sBy1DQ2AB8fqZBWhUg==",
      "dev": true
    },
    "ignore": {
      "version": "5.1.8",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.1.8.tgz",
      "integrity": "sha512-BMpfD7PpiETpBl/A6S498BaIJ6Y/ABT93ETbby2fP00v4EbvPBXWEoaR1UBPKs3iR53pJY7EtZk5KACI57i1Uw==",
      "dev": true
    },
    "import-fresh": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.2.1.tgz",
      "integrity": "sha512-6e1q1cnWP2RXD9/keSkxHScg508CdXqXWgWBaETNhyuBFz+kUZlKboh+ISK+bU++DmbHimVBrOz/zzPe0sZ3sQ==",
      "dev": true,
      "requires": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      }
    },
    "imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
      "dev": true
    },
    "inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
      "dev": true,
      "requires": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha1-d8mYQFJ6qOyxqLppe4BkWnqSap0=",
      "dev": true
    },
    "is-callable": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.2.tgz",
      "integrity": "sha512-dnMqspv5nU3LoewK2N/y7KLtxtakvTuaCsU9FU50/QDmdbHNy/4/JuRtMHqRU22o3q+W89YQndQEeCVwK+3qrA==",
      "dev": true
    },
    "is-date-object": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.2.tgz",
      "integrity": "sha512-USlDT524woQ08aoZFzh3/Z6ch9Y/EWXEHQ/AaRN0SkKq4t2Jw2R2339tSXmwuVoY7LLlBCbOIlx2myP/L5zk0g==",
      "dev": true
    },
    "is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
      "dev": true
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
      "dev": true
    },
    "is-glob": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
      "integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
      "dev": true,
      "requires": {
        "is-extglob": "^2.1.1"
      }
    },
    "is-negative-zero": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.0.tgz",
      "integrity": "sha1-lVOxIbD6wohp2p7UWeIMdUN4hGE=",
      "dev": true
    },
    "is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true
    },
    "is-regex": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.1.1.tgz",
      "integrity": "sha512-1+QkEcxiLlB7VEyFtyBg94e08OAsvq7FUBgApTq/w2ymCLyKJgDPsybBENVtA7XCQEgEXxKPonG+mvYRxh/LIg==",
      "dev": true,
      "requires": {
        "has-symbols": "^1.0.1"
      }
    },
    "is-string": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/is-string/-/is-string-1.0.5.tgz",
      "integrity": "sha512-buY6VNRjhQMiF1qWDouloZlQbRhDPCebwxSjxMjxgemYT46YMd2NR0/H+fBhEfWX4A/w9TBJ+ol+okqJKFE6vQ==",
      "dev": true
    },
    "is-symbol": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.3.tgz",
      "integrity": "sha512-OwijhaRSgqvhm/0ZdAcXNZt9lYdKFpcRDT5ULUuYXPoT794UNOdU+gpT6Rzo7b4V2HUl/op6GqY894AZwv9faQ==",
      "dev": true,
      "requires": {
        "has-symbols": "^1.0.1"
      }
    },
    "isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE=",
      "dev": true
    },
    "isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
      "dev": true
    },
    "js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true
    },
    "js-yaml": {
      "version": "3.14.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.0.tgz",
      "integrity": "sha512-/4IbIeHcD9VMHFqDR/gQ7EdZdLimOvW2DdcxFjdyyZ9NsbS+ccrXqVWDtab/lRl5AlUqmpBx8EhPaWR+OtY17A==",
      "dev": true,
      "requires": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      }
    },
    "json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true
    },
    "json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
      "dev": true
    },
    "json5": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
      "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
      "dev": true,
      "requires": {
        "minimist": "^1.2.0"
      }
    },
    "levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "requires": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      }
    },
    "load-json-file": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/load-json-file/-/load-json-file-2.0.0.tgz",
      "integrity": "sha1-eUfkIUmvgNaWy/eXvKq8/h/inKg=",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.2",
        "parse-json": "^2.2.0",
        "pify": "^2.0.0",
        "strip-bom": "^3.0.0"
      }
    },
    "locate-path": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-2.0.0.tgz",
      "integrity": "sha1-K1aLJl7slExtnA3pw9u7ygNUzY4=",
      "dev": true,
      "requires": {
        "p-locate": "^2.0.0",
        "path-exists": "^3.0.0"
      }
    },
    "lodash": {
      "version": "4.17.20",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.20.tgz",
      "integrity": "sha512-PlhdFcillOINfeV7Ni6oF1TAEayyZBoZ8bcshTHqOYJYlrqzRK5hagpagky5o4HfCzzd1TRkXPMFq6cKk9rGmA==",
      "dev": true
    },
    "merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true
    },
    "micromatch": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
      "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
      "dev": true,
      "requires": {
        "braces": "^3.0.1",
        "picomatch": "^2.0.5"
      }
    },
    "minimatch": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
      "dev": true,
      "requires": {
        "brace-expansion": "^1.1.7"
      }
    },
    "minimist": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz",
      "integrity": "sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw==",
      "dev": true
    },
    "mkdirp": {
      "version": "0.5.5",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz",
      "integrity": "sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==",
      "dev": true,
      "requires": {
        "minimist": "^1.2.5"
      }
    },
    "ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
      "dev": true
    },
    "natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
      "dev": true
    },
    "normalize-package-data": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/normalize-package-data/-/normalize-package-data-2.5.0.tgz",
      "integrity": "sha512-/5CMN3T0R4XTj4DcGaexo+roZSdSFW/0AOOTROrjxzCG1wrWXEsGbRKevjlIL+ZDE4sZlJr5ED4YW0yqmkK+eA==",
      "dev": true,
      "requires": {
        "hosted-git-info": "^2.1.4",
        "resolve": "^1.10.0",
        "semver": "2 || 3 || 4 || 5",
        "validate-npm-package-license": "^3.0.1"
      },
      "dependencies": {
        "semver": {
          "version": "5.7.1",
          "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
          "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
          "dev": true
        }
      }
    },
    "object-inspect": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.8.0.tgz",
      "integrity": "sha512-jLdtEOB112fORuypAyl/50VRVIBIdVQOSUUGQHzJ4xBSbit81zRarz7GThkEFZy1RceYrWYcPcBFPQwHyAc1gA==",
      "dev": true
    },
    "object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
      "dev": true
    },
    "object.assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.1.tgz",
      "integrity": "sha512-VT/cxmx5yaoHSOTSyrCygIDFco+RsibY2NM0a4RdEeY/4KgqezwFtK1yr3U67xYhqJSlASm2pKhLVzPj2lr4bA==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.18.0-next.0",
        "has-symbols": "^1.0.1",
        "object-keys": "^1.1.1"
      },
      "dependencies": {
        "es-abstract": {
          "version": "1.18.0-next.1",
          "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.18.0-next.1.tgz",
          "integrity": "sha512-I4UGspA0wpZXWENrdA0uHbnhte683t3qT/1VFH9aX2dA5PPSf6QW5HHXf5HImaqPmjXaVeVk4RGWnaylmV7uAA==",
          "dev": true,
          "requires": {
            "es-to-primitive": "^1.2.1",
            "function-bind": "^1.1.1",
            "has": "^1.0.3",
            "has-symbols": "^1.0.1",
            "is-callable": "^1.2.2",
            "is-negative-zero": "^2.0.0",
            "is-regex": "^1.1.1",
            "object-inspect": "^1.8.0",
            "object-keys": "^1.1.1",
            "object.assign": "^4.1.1",
            "string.prototype.trimend": "^1.0.1",
            "string.prototype.trimstart": "^1.0.1"
          }
        }
      }
    },
    "object.values": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object.values/-/object.values-1.1.1.tgz",
      "integrity": "sha512-WTa54g2K8iu0kmS/us18jEmdv1a4Wi//BZ/DTVYEcH0XhLM5NYdpDHja3gt57VrZLcNAO2WGA+KpWsDBaHt6eA==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1",
        "function-bind": "^1.1.1",
        "has": "^1.0.3"
      }
    },
    "once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
      "dev": true,
      "requires": {
        "wrappy": "1"
      }
    },
    "optionator": {
      "version": "0.9.1",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
      "dev": true,
      "requires": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.3"
      }
    },
    "p-limit": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-1.3.0.tgz",
      "integrity": "sha512-vvcXsLAJ9Dr5rQOPk7toZQZJApBl2K4J6dANSsEuh6QI41JYcsS/qhTGa9ErIUUgK3WNQoJYvylxvjqmiqEA9Q==",
      "dev": true,
      "requires": {
        "p-try": "^1.0.0"
      }
    },
    "p-locate": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-2.0.0.tgz",
      "integrity": "sha1-IKAQOyIqcMj9OcwuWAaA893l7EM=",
      "dev": true,
      "requires": {
        "p-limit": "^1.1.0"
      }
    },
    "p-try": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-1.0.0.tgz",
      "integrity": "sha1-y8ec26+P1CKOE/Yh8rGiN8GyB7M=",
      "dev": true
    },
    "parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "requires": {
        "callsites": "^3.0.0"
      }
    },
    "parse-json": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-2.2.0.tgz",
      "integrity": "sha1-9ID0BDTvgHQfhGkJn43qGPVaTck=",
      "dev": true,
      "requires": {
        "error-ex": "^1.2.0"
      }
    },
    "path-exists": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-3.0.0.tgz",
      "integrity": "sha1-zg6+ql94yxiSXqfYENe1mwEP1RU=",
      "dev": true
    },
    "path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
      "dev": true
    },
    "path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true
    },
    "path-parse": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.6.tgz",
      "integrity": "sha512-GSmOT2EbHrINBf9SR7CDELwlJ8AENk3Qn7OikK4nFYAu3Ote2+JYNVvkpAEQm3/TLNEJFD/xZJjzyxg3KBWOzw==",
      "dev": true
    },
    "path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true
    },
    "picomatch": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.2.2.tgz",
      "integrity": "sha512-q0M/9eZHzmr0AulXyPwNfZjtwZ/RBZlbN3K3CErVrk50T2ASYI7Bye0EvekFY3IP1Nt2DHu0re+V2ZHIpMkuWg==",
      "dev": true
    },
    "pify": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
      "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
      "dev": true
    },
    "pkg-dir": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-2.0.0.tgz",
      "integrity": "sha1-9tXREJ4Z1j7fQo4L1X4Sd3YVM0s=",
      "dev": true,
      "requires": {
        "find-up": "^2.1.0"
      }
    },
    "prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true
    },
    "progress": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
      "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
      "dev": true
    },
    "punycode": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
      "dev": true
    },
    "read-pkg": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/read-pkg/-/read-pkg-2.0.0.tgz",
      "integrity": "sha1-jvHAYjxqbbDcZxPEv6xGMysjaPg=",
      "dev": true,
      "requires": {
        "load-json-file": "^2.0.0",
        "normalize-package-data": "^2.3.2",
        "path-type": "^2.0.0"
      },
      "dependencies": {
        "path-type": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/path-type/-/path-type-2.0.0.tgz",
          "integrity": "sha1-8BLMuEFbcJb8LaoQVMPXI4lZTHM=",
          "dev": true,
          "requires": {
            "pify": "^2.0.0"
          }
        }
      }
    },
    "read-pkg-up": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/read-pkg-up/-/read-pkg-up-2.0.0.tgz",
      "integrity": "sha1-a3KoBImE4MQeeVEP1en6mbO1Sb4=",
      "dev": true,
      "requires": {
        "find-up": "^2.0.0",
        "read-pkg": "^2.0.0"
      }
    },
    "regexpp": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz",
      "integrity": "sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==",
      "dev": true
    },
    "resolve": {
      "version": "1.17.0",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.17.0.tgz",
      "integrity": "sha512-ic+7JYiV8Vi2yzQGFWOkiZD5Z9z7O2Zhm9XMaTxdJExKasieFCr+yXZ/WmXsckHiKl12ar0y6XiXDx3m4RHn1w==",
      "dev": true,
      "requires": {
        "path-parse": "^1.0.6"
      }
    },
    "resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true
    },
    "reusify": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
      "dev": true
    },
    "rimraf": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.6.3.tgz",
      "integrity": "sha512-mwqeW5XsA2qAejG46gYdENaxXjx9onRNCfn7L0duuP4hCuTIi/QO7PDK07KJfp1d+izWPrzEJDcSqBa0OZQriA==",
      "dev": true,
      "requires": {
        "glob": "^7.1.3"
      }
    },
    "run-parallel": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.1.9.tgz",
      "integrity": "sha512-DEqnSRTDw/Tc3FXf49zedI638Z9onwUotBMiUFKmrO2sdFKIbXamXGQ3Axd4qgphxKB4kw/qP1w5kTxnfU1B9Q==",
      "dev": true
    },
    "semver": {
      "version": "7.3.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
      "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
      "dev": true
    },
    "shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "requires": {
        "shebang-regex": "^3.0.0"
      }
    },
    "shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true
    },
    "slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true
    },
    "slice-ansi": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-2.1.0.tgz",
      "integrity": "sha512-Qu+VC3EwYLldKa1fCxuuvULvSJOKEgk9pi8dZeCVK7TqBfUNTH4sFkk4joj8afVSfAYgJoSOetjx9QWOJ5mYoQ==",
      "dev": true,
      "requires": {
        "ansi-styles": "^3.2.0",
        "astral-regex": "^1.0.0",
        "is-fullwidth-code-point": "^2.0.0"
      }
    },
    "spdx-correct": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/spdx-correct/-/spdx-correct-3.1.1.tgz",
      "integrity": "sha512-cOYcUWwhCuHCXi49RhFRCyJEK3iPj1Ziz9DpViV3tbZOwXD49QzIN3MpOLJNxh2qwq2lJJZaKMVw9qNi4jTC0w==",
      "dev": true,
      "requires": {
        "spdx-expression-parse": "^3.0.0",
        "spdx-license-ids": "^3.0.0"
      }
    },
    "spdx-exceptions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/spdx-exceptions/-/spdx-exceptions-2.3.0.tgz",
      "integrity": "sha512-/tTrYOC7PPI1nUAgx34hUpqXuyJG+DTHJTnIULG4rDygi4xu/tfgmq1e1cIRwRzwZgo4NLySi+ricLkZkw4i5A==",
      "dev": true
    },
    "spdx-expression-parse": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/spdx-expression-parse/-/spdx-expression-parse-3.0.1.tgz",
      "integrity": "sha512-cbqHunsQWnJNE6KhVSMsMeH5H/L9EpymbzqTQ3uLwNCLZ1Q481oWaofqH7nO6V07xlXwY6PhQdQ2IedWx/ZK4Q==",
      "dev": true,
      "requires": {
        "spdx-exceptions": "^2.1.0",
        "spdx-license-ids": "^3.0.0"
      }
    },
    "spdx-license-ids": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/spdx-license-ids/-/spdx-license-ids-3.0.6.tgz",
      "integrity": "sha512-+orQK83kyMva3WyPf59k1+Y525csj5JejicWut55zeTWANuN17qSiSLUXWtzHeNWORSvT7GLDJ/E/XiIWoXBTw==",
      "dev": true
    },
    "sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
      "dev": true
    },
    "string-width": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
      "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
      "dev": true,
      "requires": {
        "emoji-regex": "^7.0.1",
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^5.1.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        }
      }
    },
    "string.prototype.trimend": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.1.tgz",
      "integrity": "sha512-LRPxFUaTtpqYsTeNKaFOw3R4bxIzWOnbQ837QfBylo8jIxtcbK/A/sMV7Q+OAV/vWo+7s25pOE10KYSjaSO06g==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "string.prototype.trimstart": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.1.tgz",
      "integrity": "sha512-XxZn+QpvrBI1FOcg6dIpxUPgWCPuNXvMD72aaRaUQv1eD4e/Qy8i/hFTe0BUmD60p/QA6bh1avmuPTfNjqVWRw==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "strip-ansi": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
      "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
      "dev": true,
      "requires": {
        "ansi-regex": "^5.0.0"
      }
    },
    "strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha1-IzTBjpx1n3vdVv3vfprj1YjmjtM=",
      "dev": true
    },
    "strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true
    },
    "supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "requires": {
        "has-flag": "^3.0.0"
      }
    },
    "table": {
      "version": "5.4.6",
      "resolved": "https://registry.npmjs.org/table/-/table-5.4.6.tgz",
      "integrity": "sha512-wmEc8m4fjnob4gt5riFRtTu/6+4rSe12TpAELNSqHMfF3IqnA+CH37USM6/YR3qRZv7e56kAEAtd6nKZaxe0Ug==",
      "dev": true,
      "requires": {
        "ajv": "^6.10.2",
        "lodash": "^4.17.14",
        "slice-ansi": "^2.1.0",
        "string-width": "^3.0.0"
      }
    },
    "text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
      "dev": true
    },
    "to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "requires": {
        "is-number": "^7.0.0"
      }
    },
    "tsconfig-paths": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.9.0.tgz",
      "integrity": "sha512-dRcuzokWhajtZWkQsDVKbWyY+jgcLC5sqJhg2PSgf4ZkH2aHPvaOY8YWGhmjb68b5qqTfasSsDO9k7RUiEmZAw==",
      "dev": true,
      "requires": {
        "@types/json5": "^0.0.29",
        "json5": "^1.0.1",
        "minimist": "^1.2.0",
        "strip-bom": "^3.0.0"
      }
    },
    "tslib": {
      "version": "1.13.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.13.0.tgz",
      "integrity": "sha512-i/6DQjL8Xf3be4K/E6Wgpekn5Qasl1usyw++dAA35Ue5orEn65VIxOA+YvNNl9HV3qv70T7CNwjODHZrLwvd1Q==",
      "dev": true
    },
    "tsutils": {
      "version": "3.17.1",
      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.17.1.tgz",
      "integrity": "sha512-kzeQ5B8H3w60nFY2g8cJIuH7JDpsALXySGtwGJ0p2LSjLgay3NdIpqq5SoOBe46bKDW2iq25irHCr8wjomUS2g==",
      "dev": true,
      "requires": {
        "tslib": "^1.8.1"
      }
    },
    "type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "requires": {
        "prelude-ls": "^1.2.1"
      }
    },
    "type-fest": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.8.1.tgz",
      "integrity": "sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==",
      "dev": true
    },
    "typescript": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.3.tgz",
      "integrity": "sha512-tEu6DGxGgRJPb/mVPIZ48e69xCn2yRmCgYmDugAVwmJ6o+0u1RI18eO7E7WBTLYLaEVVOhwQmcdhQHweux/WPg==",
      "dev": true
    },
    "uri-js": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.0.tgz",
      "integrity": "sha512-B0yRTzYdUCCn9n+F4+Gh4yIDtMQcaJsmYBDsTSG8g/OejKBodLQ2IHfN3bM7jUsRXndopT7OIXWdYqc1fjmV6g==",
      "dev": true,
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "v8-compile-cache": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.1.1.tgz",
      "integrity": "sha512-8OQ9CL+VWyt3JStj7HX7/ciTL2V3Rl1Wf5OL+SNTm0yK1KvtReVulksyeRnCANHHuUxHlQig+JJDlUhBt1NQDQ==",
      "dev": true
    },
    "validate-npm-package-license": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/validate-npm-package-license/-/validate-npm-package-license-3.0.4.tgz",
      "integrity": "sha512-DpKm2Ui/xN7/HQKCtpZxoRWBhZ9Z0kqtygG8XCgNQ8ZlDnxuQmWhj566j8fN4Cu3/JmbhsDo7fcAJq4s9h27Ew==",
      "dev": true,
      "requires": {
        "spdx-correct": "^3.0.0",
        "spdx-expression-parse": "^3.0.0"
      }
    },
    "which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "requires": {
        "isexe": "^2.0.0"
      }
    },
    "word-wrap": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
      "dev": true
    },
    "wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
      "dev": true
    },
    "write": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/write/-/write-1.0.3.tgz",
      "integrity": "sha512-/lg70HAjtkUgWPVZhZcm+T4hkL8Zbtp1nFNOn3lRrxnlv50SRBv7cR7RqR+GMsd3hUXy9hWBo4CHTbFTcOYwig==",
      "dev": true,
      "requires": {
        "mkdirp": "^0.5.1"
      }
    }
  }
}

'''
'''--- package.json ---
{
  "name": "create-contract-cli",
  "version": "1.0.0",
  "description": "creates a cli tool based on a NEAR smart contract",
  "main": "dist/main/create-contract-cli",
  "bin": "bin/cli.js",
  "directories": {
    "test": "dist/test"
  },
  "scripts": {
    "build": "node ./build.js",
    "test:deploy": "npm run build && node dist/test/test-deploy.js",
    "test": "npm run build && node dist/test/test.js",
    "lint": "eslint . --ext .ts --fix"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/luciotato/create-contract-cli.git"
  },
  "keywords": [
    "near",
    "contract",
    "cli",
    "tool"
  ],
  "author": "luciotato@gmail.com",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/create-contract-cli/issues"
  },
  "homepage": "https://github.com/luciotato/create-contract-cli#readme",
  "devDependencies": {
    "@types/node": "^14.11.2",
    "@typescript-eslint/eslint-plugin": "^4.4.0",
    "@typescript-eslint/parser": "^4.4.0",
    "eslint": "^7.10.0",
    "eslint-config-standard": "^14.1.1",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-promise": "^4.2.1",
    "eslint-plugin-standard": "^4.0.1",
    "typescript": "^4.0.3"
  }
}

'''
'''--- res/cli.js ---
#!/usr/bin/env node
require("./{nickname}.js")

'''
'''--- res/model-ES2018/.vscode/tasks.json ---
{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    "version": "2.0.0",
    "tasks": [
      {
        "type": "typescript",
        "tsconfig": "tsconfig.json",
        "problemMatcher": ["$tsc"],
        "group": {
          "kind": "build",
          "isDefault": true
        }
      }
    ]
  }
'''
'''--- res/model-ES2018/CLIConfig.js ---
module.exports =
{
    nickname: "tomES2018",
    userAccount: "luciotato.betanet",
    contractAccount: "testcontract.betanet"
}

'''
'''--- res/model-ES2018/CLIOptions.js ---
module.exports = {

    accountId: {
        shortName: "acc",
        valueType: "string",
        value: "",
        helpText: `signer accountId`
    },

    masterAccount: {
        shortName: "ma",
        valueType: "string",
        value: "",
        helpText: `master account`
    },

    help: {
        shortName: "h",
        value: false
    },

    info: {
        shortName: "i",
        value: false,
        helpText: 'show configured contract account, default user accountId'
    },

    verbose: {
        shortName: "v",
        helpText: 'Prints out verbose output',
        name: "verbose"
    },

    amount: {
        shortName: "am",
        valueType: "NEAR",
        value: "",
        helpText: `attach NEAR tokens to this call. Example: --amount 100N`

    },
    networkId: {
        shortName: "net",
        valueType: "string",
        value: "",
        helpText: 'NEAR network ID (default is NODE_ENV)'
    },

    contractName: {
        shortName: "c",
        valueType: "string",
        value: "",
        helpText: `sets the contract accountId for near deploy and --cliConfig`
    },

    cliConfig: {
        shortName: "cliconf",
        value: false,
        helpText: `config this cli, you must include --contractName xx and --accountId yy to set default contract accountId and user`
    },
}

'''
'''--- res/model-ES2018/ContractAPI.js ---
const color = require("./util/color.js")
const nearCli = require("./util/SpawnNearCli.js");
const options = require("./CLIOptions.js");
const cliConfig = require("./CLIConfig.js")

const nickname = cliConfig.nickname

// one function for each pub fn in the contract
// get parameters by consuming from CommandLineParser
class ContractAPI {

    // this.view helper function
    _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
        return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
    }
    // this.call helper function
    _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
        return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
    }

    ping_HELP() { return  `
    Distributes rewards and restakes if needed.
    
    usage:
    > ${nickname} ping `};

    ping(a /*:CommandLineArgs*/ ) /*:void*/{
        a.noMoreArgs() // end of arguments
        this._call("ping")
    }

    get_accounts_HELP() { return  `
    get registered accounts from the contract
    
    usage:
    > ${nickname} get_accounts { from_index:number, limit:number }
    
    example:
    > ${nickname} get_accounts { from_index:0, limit:10 }
    will get 10 accounts starting from 0
    `;}

    get_accounts(a /*:CommandLineArgs*/ ) {
        const params = a.consumeJSON("{ from_index:number, limit:number }")
        a.noMoreArgs()
        return this._view("get_accounts", params)
    }

    deposit_HELP() { return  `
    deposit into the contract for staking later
    
    usage:
    > ${nickname} deposit --attach Near-amount
    
    example:
    > ${nickname} deposit --attach 40N
    will deposit 40N on behalf of your account into the pool
    
    `}

    deposit(a /*:CommandLineArgs*/ ) /*:void*/{
        a.requireOptionWithAmount(options.amount, "N") // require --amount, in Nears
        a.noMoreArgs()
        this._call("deposit")
    }

    stake_HELP() { return  `
    stake deposited unstaked amount

    usage:
    > ${nickname} stake { amount: 10N }

    example:
    > ${nickname} stake { amount: 10N }
    will stake 10N from the unstaked balance of myaccount.betanet 

    `}

    stake(a /*:CommandLineArgs*/ ) /*:void*/{
        const stakeJSONargs = a.consumeJSON("{ amount: x }")
        a.noMoreArgs()
        this._call("stake", stakeJSONargs)
    }

    get_total_staked_balance(a /*:CommandLineArgs*/ ) /*:string*/ {
        a.noMoreArgs()

        return this._view("get_total_staked_balance")
    }

    get_owner_id(a /*:CommandLineArgs*/ ) /*:string*/ {
        a.noMoreArgs()

        return this._view("get_owner_id")
    }

    get_staking_key(a /*:CommandLineArgs*/ ) /*:string*/ {
        a.noMoreArgs()

        return this._view("get_staking_key")
    }
}

module.exports = ContractAPI;

'''
'''--- res/model-ES2018/ExtensionAPI.js ---
const color = require("./util/color.js")
const nearCli = require("./util/SpawnNearCli.js");
const options = require("./CLIOptions.js");
const cliConfig = require("./CLIConfig.js")
const ContractAPI = require("./ContractAPI.js")
const CommandLineArgs = require("./util/CommandLineArgs.js")

const nickname = cliConfig.nickname

// -------------------------
// Contract API extensions
// -------------------------
class ExtensionAPI extends ContractAPI {

    // hm handy extension example
    hm_HELP(){ return `
    How much? 
	converts an amount in Yoctos into a more readable format. 
    
    Example: 
    >${nickname} hm 30037100000000000000000000
    `}

    hm(a /*:CommandLineArgs*/)  {
        const str = a.consumeString("amount")
        console.log(color.green,a.convertAmount(str + "Y", "N", "amount"),color.normal)
    }

    // where extension example
    where_HELP(){ return `
    Where is the contract? 
    shows contract accountId, this is an Example extension, gives the same information as: ${nickname} --info
    
    Usage:
    >${nickname} where [are] [you]
    `}
    where(a /*:CommandLineArgs*/) /*:void*/ {
        a.optionalString("are")
        a.optionalString("you")
        a.noMoreArgs()
        console.log("Contract is at ",color.green,cliConfig.contractAccount,color.normal)
        console.log("Default user is ",color.green,cliConfig.userAccount,color.normal)
    }

    // balance extension example
    state_HELP(){ return `
    Get contract's account state, with more readable numbers
    
    Usage:
    >${nickname} state
    `}

    state(a /*:CommandLineArgs*/) /*:void*/ {
        a.noMoreArgs()
        nearCli.spawnNearCli(["state", cliConfig.contractAccount], options)
    }

    // deploy extension example
    deploy_HELP(){ return `
    deploy a WASM file into the account ${cliConfig.contractAccount} 
    
    usage:
    > ${nickname} deploy /path/to/code.WASM
    
    example:
    > ${nickname} deploy myCode.WASM
    willl deploy code.WASM at ${cliConfig.contractAccount} 
    `;}

    deploy(a /*:CommandLineArgs*/) /*:void*/ {
        //get path from command line
        const wasmFile = a.consumeString("path/to/contract.wasm")
        //spawn near-cli, command=deploy
        nearCli.spawnNearCli(["deploy", cliConfig.contractAccount, wasmFile], options);
    }

    // -----------------------------------------------
    // -----------------------------------------------
    // You can add more extension commands here
    // -----------------------------------------------
    // -----------------------------------------------

    // -----------------------------------------------
    // info Example extension
    // -----------------------------------------------
    /*
    myfn_HELP(){ return `
    This is a command extension example wiht variable args. 
	Handy commands you can create composing fn calls to this contract or others

	Usage:
	>${nickname} myfn [account]+
    `}

    myfn(a) {
        if (a.positional.length == 0) {
            this.view("myfn", {}) // call myfn on this contract
        } else {
            while (a.positional.length) {
                const account = a.consumeString("another account")
                nearCli.view(account, "myfn", {}, options) // call myfn on one or mode accounts
            }
        }
        process.exit(0)
    }
    */

    // -----------------------------------------------
    // NEP21 Example extension
    // -----------------------------------------------
    /*
    nep21_HELP(){ return `
    Call functions on NEP21 contracts.
    Examples:
    >>${nickname} nep21 balance gold.nep21.near         -> get how much gold this contract has
    >>${nickname} nep21 balance my gold.nep21.near      -> get how much gold you have
    >>${nickname} nep21 mint mytoken.near               -> (dev) calls mytoken.near.mint(), minting tokens for you

    >${nickname} nep21 transfer 50 gold.near to lucio.testnet  -> transfer 50e24 gold.near tokens to account lucio.testnet

    `}
    nep21(a) {
        const subcommand = a.consumeString("sub-command")

        if (subcommand == "balance") {
            let tokenOwner = cliConfig.contractAccount
            if (a.optionalString("my")) tokenOwner = cliConfig.userAccount

            while (a.positional.length) {
                const token = a.consumeString("nep21-contract")
                nearCli.view(token, "get_balance", { owner_id: tokenOwner }, options)
            }
        } else if (subcommand == "mint") {
            const token = a.consumeString("nep21-contract")
            nearCli.call(token, "mint_1e3", {}, options)
        }

        // nearswap nep21 transfer 50000 gold to lucio.testnet
        else if (subcommand == "transfer") {
            const tokAmount = a.consumeAmount("token amount", "Y")

            const token = a.consumeString("nep21-contract")

            a.optionalString("to")

            let toAcc = a.consumeString("to account")
            if (toAcc == "contract") toAcc = cliConfig.contractAccount // this contract

            nearCli.call(token, "transfer", { new_owner_id: toAcc, amount: tokAmount }, options)
        } else {
            console.log("nep21 UNK subcommand " + color.red + subcommand + color.normal)
            process.exit(1)
        }

        process.exit(0)
    }
    */

    /*
    // function depo: example manually coded composed/aternative command
    depo_HELP(){return `
    shotcut for deposit

    usage:
    > ${nickname} depo amountN [and] [stake]

    example:
    > ${nickname} depo 40N 
    will deposit 40N on into ${nickname}'s pool
    > ${nickname} depo 40N and stake
    will deposit 40N into ${nickname}'s pool and stake it in the same transaction
    `}

    depo(a) { //a:CommandLineArgs
        options.amount.value = a.consumeAmount("amount to deposit", "N")

        // check if [and] [stake] is next in the command line
        a.optionalString("and")
        const stake = a.optionalString("stake")

        const fnToCall = stake ? "deposit_and_stake" : "deposit"

        a.noMoreArgs()

        return this.call(fnToCall)
    }
    */

    // function info: example manually coded composed command
    /*
    info_HELP(){ return `
    get_owner_id, get_staking_key & get_total_staked_balance
    `}

    info(a) { //a:CommandLineArgs
        this.get_owner_id(a)
        this.get_staking_key(a)
        this.get_total_staked_balance(a)
    }
    */

}

module.exports = ExtensionAPI

'''
'''--- res/model-ES2018/package-lock.json ---
{
  "name": "hand-coded-tom",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@types/node": {
      "version": "14.11.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.11.2.tgz",
      "integrity": "sha512-jiE3QIxJ8JLNcb1Ps6rDbysDhN4xa8DJJvuC9prr6w+1tIh+QAbYyNF3tyiZNLDBIuBCf4KEcV2UvQm/V60xfA==",
      "dev": true
    },
    "typescript": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.3.tgz",
      "integrity": "sha512-tEu6DGxGgRJPb/mVPIZ48e69xCn2yRmCgYmDugAVwmJ6o+0u1RI18eO7E7WBTLYLaEVVOhwQmcdhQHweux/WPg==",
      "dev": true
    }
  }
}

'''
'''--- res/model-ES2018/package.json ---
{
  "name": "hand-coded-tom-es2018",
  "version": "1.0.0",
  "description": "model for create-command-cli",
  "main": "tomES2018.js",
  "scripts": {
    "test": "tomES2018 --help|more"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/luciotato/create-contract-cli.git"
  },
  "keywords": [
    "create-command-cli"
  ],
  "author": "Lucio Tato",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/create-contract-cli/issues"
  },
  "homepage": "https://github.com/luciotato/create-contract-cli/#readme"
}

'''
'''--- res/model-ES2018/tomES2018.js ---
const color = require("./util/color.js")
const nearCli = require("./util/SpawnNearCli.js")
const saveConfig = require("./util/saveConfig.js")
const CommandLineArgs= require("./util/CommandLineArgs.js")

const options = require("./CLIOptions.js")
const cliConfig = require("./CLIConfig.js")
const ExtensionAPI= require("./ExtensionAPI.js")

// name of this script
const nickname = cliConfig.nickname;

// default accountId
options.accountId.value = cliConfig.userAccount

// process command line args
const args = new CommandLineArgs(options)

// command is the 1st positional argument
const command = args.getCommand()

// Show config info if requested
// Set config if requested by --cliConfig
if (options.cliConfig.value) {
    saveConfig(options.accountId.value, options.contractName.value)
    process.exit(0)
}
if (options.info.value) {
    console.log(`config.js:`)
    console.log(`  Your account    : ${color.yellow}${cliConfig.userAccount}${color.normal}`)
    console.log(`  Contract account: ${color.yellow}${cliConfig.contractAccount}${color.normal}`)
    process.exit(0)
}

// TODO configure
// if (command=="configure") {
//     args.requireOptionString(options.accountId,"default account Id")
//     process.exit(0);
// }

// -------------------
// PROCESS COMMAND //
// -------------------

// get contract API + Extensions
const API = new ExtensionAPI()

// check the command is in the API
// eslint-disable-next-line @typescript-eslint/no-explicit-any
if (command && typeof API[command] !== "function") {
    color.logErr("unknown command " + color.yellow + command + color.normal)
    console.log(`${nickname} --help to see a list of commands`)
    process.exit(1)
}

// Show help if requested or if no command
if (options.help.value || !command) {
    args.ShowHelpPage(command, API)
    process.exit(0)
}

// call the contract API function
// eslint-disable-next-line @typescript-eslint/no-explicit-any
API[command](args)

'''
'''--- res/model-ES2018/util/CommandLineArgs.js ---
/**
 #Simple and minimum command line args parser
 *
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args.
 *    --Note:  spaces *must* be used around { and }
 *

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/

const sep = require("path").sep // host OS path separator
const inspect = require("util").inspect
const ContractAPI = require("../ContractAPI.js")
const color = require('./color.js')

/*
export type OptionDeclaration =
    {
        shortName: string
        valueType?: string
        helpText?: string
        value?: string|number|boolean
    }
*/

// --------------------------
// --  main exported class --
// --------------------------
class CommandLineArgs {

    //clArgs //: string[] // initial list process.argv

    //positional //: (string | Record<string,unknown>)[] // string or JSON objects -- positional arguments

    //optDeclarations //: Record<string,OptionDeclaration>; // pointer to passed option declarations

    constructor(options /*:Record<string,OptionDeclaration>*/) {
        this.clArgs = process.argv
        this.optDeclarations = options
        this.positional = []

        // remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node' ||
            this.clArgs[0].endsWith(sep + 'node')) ||
            this.clArgs[0].endsWith(sep + 'node.exe')
        ) {
            this.clArgs = this.clArgs.slice(1)
        }

        // remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1)

        // process each item separating options from posiitonal args

        // First: process --options
        for (const key in options) {
            const optionDecl = options[key]
            // search for option name & variations
            const pos = this.searchOption(optionDecl)
            if (pos >= 0) { // found in command line args
                const literal = this.clArgs[pos] // as written
                this.clArgs.splice(pos, 1) // remove from cl args

                if (optionDecl.valueType) { // has a value
                    if (pos >= this.clArgs.length) {
                        color.logErr("expecting value after " + literal)
                        process.exit(1)
                    }
                    const value = this.clArgs[pos] // take value
                    options[key].value = value // set value
                    this.clArgs.splice(pos, 1) // also remove value from list
                } else // valueless option
                {
                    options[key].value = true // set as present
                }
            }
        }

        // if at this point there are still --options in the command line args array, those are unknown options
        let hasErrors = false
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                color.logErr("UNKNOWN option: " + item)
                hasErrors = true
            }
        }
        if (hasErrors) {
            ShowHelpOptions(options)
            process.exit(1)
        }

        //JSON pre-process:
        //ideally the user adds spaces around { }, but let's be forgiving
        //if an item starts with "{..." => splice into its own item "{"
        //if an item ends with "..}" => splice into its own item "}"
        for(let i=0;i<this.clArgs.length;i++){
            let item=this.clArgs[i]
            if (item!="{" && item.startsWith("{")){
                //remove the starting {
                item=item.slice(1)
                this.clArgs[i]=item
                //insert as its own item
                this.clArgs.splice(i,0,"{")
            }
            if (item!="}" && item.endsWith("}")){
                //remove the endint }
                item=item.slice(0,-1)
                this.clArgs[i]=item
                //insert as its own item
                this.clArgs.splice(i+1,0,"}")
                i-- //re-check for }}
            }
        }

        // create consumible positional arguments, parsing also JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index]
            if (item == "{") { // a JSON object in the command line
                const extracted = this.extractJSONObject(index)
                this.positional.push(extracted.value)
                index = extracted.end
            } else {
                this.positional.push(item)
            }
        }
    }

    /**
     * When the first argument is the command to execute
     * returns "" if there's no arguments
     */
    getCommand() {
        if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            color.logErr("expected a command as first argument'")
            process.exit(1)
        } else {
            if (this.positional.length === 0) return ""
            // take the first argument as this.command
            return this.positional.shift()
        }
    }

    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which) /*:boolean*/ {
        if (this.positional.length == 0) return false

        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected a string argument, got {... }`)
            process.exit(1)
        }
        if (this.positional[0] == which) {
            this.positional.shift() // consume
            return true
        }
        return false // not the expected string
    }

    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected '${name}' argument`)
            process.exit(1)
        }
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected ${name} string argument, got {... }`)
            process.exit(1)
        }
        return this.positional.shift()
    }

    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name, units /*:"N"|"Y"|"I"|"F"*/) /*:string|number*/ {
        const value = this.consumeString(name)
        return this.convertAmount(value, units, name)
    }

    /**
     * requires a JSON as the next positional arg
     * @param name
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consumeJSON(name) {
        if (this.positional.length == 0) {
            color.logErr(`expected ${name} as { }`)
            process.exit(1)
        }
        if (typeof this.positional[0] === "string") {
            color.logErr(`expected ${name} as {... } got a string: '${this.positional[0]}'`)
            process.exit(1)
        }
        return this.positional.shift()
    }

    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs() {
        if (this.positional.length) {
            color.logErr(`unrecognized extra arguments`)
            console.log(inspect(this.positional))
            process.exit(1)
        }
    }

    findDeclarationKey(opt /*:OptionDeclaration*/) {
        for (const key in this.optDeclarations) {
            if (opt.shortName && this.optDeclarations[key].shortName == opt.shortName) return key
            if (opt.helpText && this.optDeclarations[key].helpText == opt.helpText) return key
        }
        throw new Error("shortName|helpText not found in declarations: " + inspect(opt))
    }

    /**
     * requires the presence of an option with a string value
     * @param optionName option name
     */
    requireOptionString(opt /*:OptionDeclaration*/) {
        if (opt.value == undefined || opt.value == "") {
            const key = this.findDeclarationKey(opt)
            color.logErr(`required --${key}`)
            process.exit(1)
        }
    }

    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(opt /*:OptionDeclaration*/, units /*:"N"|"Y"*/) {
        const value = opt.value ? opt.value.toString().trim() : ""

        const key = this.findDeclarationKey(opt)
        if (!value) {
            color.logErr(`required --${key} [number]`)
            process.exit(1)
        }

        const converted = this.convertAmount(value, units, key)
        opt.value = converted // store in the required units
    }

    /**
     * search for the presence of an option
     * removes it from the options if found
     *
     * @param optionName option name
     */
    consumeOption(opt /*:OptionDeclaration*/) /*:string*/ {
        const value = opt.value + ""

        if (value) { // found
            opt.value = undefined // remove from options (consume)
        }

        return value
    }

    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     *
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value /*:string*/, requiredUnits /*:"N"|"Y"|"I"|"F"*/, name) /*:string|number*/ {
        let result = value.toUpperCase()
        name = color.yellow + name + color.normal
        result = result.replace("_", "") // allow 100_000_000, ignore _

        if (result.endsWith("Y")) { // value ends in "Y"OCTOS
            if (result.includes(".")) {
                color.logErr(name + ": invalid amount format, YOCTOS can't have decimals: " + value)
                process.exit(1)
            }
            result = result.slice(0, -1) // remove Y
            if (requiredUnits == "Y") { return result } // already in Yoctos
            if (requiredUnits == "I" || requiredUnits == "F") { return Number(result) } // a js Number
            // NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24)
            } else {
                // insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24)
            }
            return result
        } else { // other, assume amount in NEARS (default)
            if (!result.slice(-1).match(/\d|N|I|F/)) { //should end with N|I|F or a digit
                color.logErr(name + ": invalid denominator, expected Y|N|I|F => yoctos|near|int|float. Received:" + result)
                process.exit(1)
            }
            if (result.endsWith("I") || result.endsWith("F")) {
                result = result.slice(0, -1) // remove denom, store as number
                return Number(result)
            }
            if (result.endsWith("N")) result = result.slice(0, -1) // remove N
            if (requiredUnits == "N") { return result } // already in Nears
            // Yoctos required -- convert to yoctos
            const parts = result.split(".")
            if (parts.length > 2) {
                color.logErr(name + ": invalid amount format, too many decimal points: " + value)
                process.exit(1)
            }
            if (parts.length == 1) { parts.push("") } // .0
            const decimalString = parts[1].padEnd(24, '0')
            result = parts[0] + "" + decimalString // +""+ is for making sure + means concat here
            return result
        }
    }

    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    extractJSONObject(start/*:number*/) {
        // find the closing "}"
        let opened = 1
        let end = -1
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n]
            if (item == "{") {
                opened++
            } else if (item == "}") {
                opened--
                if (opened == 0) {
                    end = n
                    break
                }
            }
        }

        if (end == -1) { // unmatched opener error
            color.logErr("Unmatched '{' . remember to put spaces around { and }")
            this.clArgs[start] = color.yellow + "{" + color.normal
            console.log(this.clArgs.join(" "))
            process.exit(1)
        }

        // Here we have start & end for matching { }
        const resultObj = {}
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index]
            let propValue

            if (propName == ",") continue

            if ("{}".includes(propName)) {
                color.logErr("expected name:value")
                this.clArgs[index] = color.yellow + propName + color.normal
                console.log(this.clArgs.slice(start, end + 1).join(" "))
                process.exit(1)
            }

            const parts = propName.split(":")
            if (parts.length > 2) {
                color.logErr(` too many ':' (found ${parts.length - 1}) at ${propName}`)
                process.exit(1)
            }
            propName = parts[0] ? parts[0].trim() : ""
            propValue = parts[1] ? parts[1].trim() : ""

            if (propValue == undefined || propValue == "") {
                // let's assume the user typed "name: value" instead of "name:value"
                index++ // take the next arg
                propValue = this.clArgs[index]
                if (propValue.endsWith(":")) {
                    color.logErr(` missing value after ':' for ${propName}`)
                }
                if (index >= end || propValue == "}") {
                    console.log(`ERROR: expected value after ${propName}`)
                    process.exit(1)
                }
            }

            if (propValue == "{") { // subornidated object
                const subObj = this.extractJSONObject(index) // recursive***
                // store as object
                resultObj[propName] = subObj.value
                index = subObj.end // skip internal object
                continue
            }
            // it's a string
            // remove ending "," if it's there
            if (propValue.endsWith(",")) propValue = propValue.slice(0, propValue.length - 1)
            // check if it's a number
            if (propValue.toUpperCase().match(/^[0-9.]+[Y|N|I|F]{0,1}$/)) { // amount (optionally [Y|N|I|F] expressed in nears. yoctos, integer or float
                propValue = this.convertAmount(propValue, "Y", propName) // process and convert to Yoctos if expressed in nears
            }
            // store
            resultObj[propName] = propValue
        } // end for

        // return positions and composed object
        return { start: start, end: end, value: resultObj }
    }

    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */

    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */

    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    searchOption(option /*:OptionDeclaration*/) /*:number*/ {
        const name = this.findDeclarationKey(option)
        const shortName = option.shortName

        // search several possible forms of the option, e.g. -o --o -outdir --outdir
        const variants = ['-' + name, '--' + name]
        if (shortName) { variants.push('--' + shortName, '-' + shortName) }

        // for each item in list
        for (const variant of variants) {
            const inx = this.clArgs.indexOf(variant)
            if (inx >= 0) {
                return inx // found
            }
        }
        return -1// not found
    }

    // ----------------------------------------------------
    // construct and show help page based on valid options
    // ----------------------------------------------------
    ShowHelpOptions() {
        // show help about declared options
        console.log()
        console.log("-".repeat(60))
        console.log("Options:")
        for (const key in this.optDeclarations) {
            let line = ""
            const opt = this.optDeclarations[key]
            let text = "--" + key
            if (opt.valueType) text = text + " " + opt.valueType
            if (opt.shortName) {
                text = text + ", -" + opt.shortName
                if (opt.valueType) text = text + " " + opt.valueType
            }
            line = `  ${text}`.padEnd(50) + (opt.helpText ? opt.helpText : "")
            console.log(line)
        }
        console.log("-".repeat(60))
    }

    static getMethods(API) {
        const list=[]
        const proto = Object.getPrototypeOf(API)
        for (const key of Object.getOwnPropertyNames(proto)) {
            if (key != "constructor" && key != "call" && key != "view" && !key.endsWith("_HELP")) {
                list.push(key) 
            }
        }
        return list
    }

    // ----------------------------------------------------
    // construct and show a help page based on the API for the commands
    // ----------------------------------------------------
    ShowHelpPage(forCommand, API) {

        // list functions in the Extended and ContractAPI class, except the class constructor and view/call/HELP helpers
        const list = CommandLineArgs.getMethods(API)
            .concat(CommandLineArgs.getMethods(Object.getPrototypeOf(API)))
       
        list.sort()

        // print all commands and their help if it's there
        for (const name of list) {
            if (forCommand && name!=forCommand) continue;
            console.log("-".repeat(60))
            console.log('command: ' + name) // name the command
            if (API[name + "_HELP"]) { //if there's help...
                console.log(API[name + "_HELP"]()); // print the help
            }
        }

        this.ShowHelpOptions()
    }

}
// end class CommandLineArgs

module.exports = CommandLineArgs

'''
'''--- res/model-ES2018/util/SpawnNearCli.js ---
const child_process= require("child_process");

let debug = 0
module.exports.setDebug=function(value /*:0|1|2*/) /*:void*/ { debug = value }

function decodeHTMLEntities (str) {
    str = str.replace(/&#(\d+);/g, function(match, dec) {
        return String.fromCharCode(dec)
    })
    str = str.replace(/&#(x[A-F0-9]+);/g, function(match, dec) {
        return String.fromCharCode(parseInt("0" + dec))
    })
    return str.replace(/&quot;/g, "'")
}
module.exports.decodeHTMLEntities=decodeHTMLEntities;

function yton(yoctos/*:string*/)/*:string*/ {
    let units = yoctos
    if (units.length < 25) units = units.padStart(25, '0')
    units = units.slice(0, -24) + "." + units.slice(-24)
    return units
}
module.exports.yton=yton

function spawnNearCli(args /*:(string|any)[]*/, options /*:any*/) /*:string*/ {
    
    //remove empty args
    let inx=0
    while(inx<args.length) if (args[inx]==undefined) args.splice(inx,1); else inx++;
    
    // add options to args for near-cli
    // for each option
    for (const key in options) {
        const opt = options[key]
        const value = opt.value
        if (value) { // if it was set
            args.push("--" + key) // add option presence
            if (opt.valueType) { // if the option included a value
                args.push(opt.value) // add option value
            }
        }
    }

    // -----------------------------
    // near-cli uses NODE_ENV to define --networkId
    // -----------------------------
    // get process.env, clone the actual env vars
    const env = Object.create(process.env)
    const pos = args.indexOf("--networkId")
    if (pos >= 0) {
        const network = args[pos + 1]
        env.NODE_ENV = network
        console.log(`NODE_ENV=${network}`)
    }
    // -----------------------------

    for (let i = 0; i < args.length; i++) {
        if (typeof args[i] !== "string") { // JSON
            args[i] = JSON.stringify(args[i])
            args[i] = args[i].replace(/"/g, '\\"') // add escape before each quote
            args[i] = "\"" + args[i] + "\""
            
        }
    }

    if (debug || options.verbose || options.verbose.value) console.log(`near ${args.join(" ")}`)
    const execResult = child_process.spawnSync("near", args, { shell: true, env: env }) // shell:true => to be able to invoke near-cli on windows

    // console.log(execResult.stdout.toString())
    // console.log(execResult.stderr.toString())

    if (execResult.error) {
        console.log(execResult.error)
        process.exit(1)
    }
    let stdo = ""
    if (execResult.stdout) {
        // console.log("stdout:")
        // console.log("-*-")
        // fixes for  near-cli output
        stdo = decodeHTMLEntities(execResult.stdout.toString())
        process.stdout.write(stdo)
        // console.log("-*-")
    }
    if (execResult.stderr) {
        // console.log("stderr:")
        // console.log("-*-")
        process.stdout.write(decodeHTMLEntities(execResult.stderr.toString()))
        // console.log("-*-")
    }

    // show numbers in yoctos converted to more readable units
    // get all numbers where number.lenght>=20
    const numbersFound = stdo.replace(/'/g," ").replace(/"/g," ").match(/.*?['" ]\d{14,50}/g)
    if (numbersFound) {
        // deduplicate
        const numbers = [...new Set(numbersFound)]
        // show conversion to NEARs
        console.log("amounts denomination:")
        for (const text of numbers) {
            const parts=text.split(" ")
            const num=parts.pop()||""
            if (num.length >= 20) {
                // show reference line
                console.log(text.padStart(60, ' ').slice(-60) + " Yoctos => " + yton(num).padStart(38, ' '))
            }
        }
    }

    if (execResult.status != 0) {
        process.exit(execResult.status)
    }

    return stdo
}
module.exports.spawnNearCli = spawnNearCli

// -------------------------------------
// extension helper fns at ContractAPI
// -------------------------------------
function nearCli(cv /*:"call"|"view"*/, contract, command, fnJSONparams, options) {
    const nearCliArgs = [
        cv,
        contract,
        command,
        fnJSONparams
    ]
    return spawnNearCli(nearCliArgs, options)
}
// --------------------- call  contract
module.exports.call=function(contract, command, fnJSONparams, options) {
    return nearCli("call", contract, command, fnJSONparams, options)
}
// --------------------- view on contract
module.exports.view=function(contract, command, fnJSONparams, options) {
    return nearCli("view", contract, command, fnJSONparams, options)
}

// format output helper functions
// get single number output on a near view call
module.exports.lastNumber=function(stdo) {
    if (!stdo) return ""
    const items = stdo.split("\n")
    if (items.length < 2) return ""
    return items[items.length - 2].replace(/'/g, "")
}

// formats a large amount adding _ as thousands separator
module.exports.thsep=function(stdonum) {
    if (stdonum && stdonum.length > 3) {
        for (let n = stdonum.length - 3; n >= 1; n -= 3) {
            stdonum = stdonum.slice(0, n) + "_" + stdonum.slice(n)
        }
    }
    return stdonum
}

'''
'''--- res/model-ES2018/util/color.js ---
const color= {
    normal: '\x1b[39;49m',
    red: '\x1b[91m',
    yellow: '\x1b[93m',
    green: '\x1b[32m',

    logErr: function (text) {
        console.error(color.red + "ERR: " + color.normal + text)
    },

    greenOK: function() {
        console.log(color.green + "OK" + color.normal)
    }
}

module.exports = color
'''
'''--- res/model-ES2018/util/saveConfig.js ---
const fs=require("fs")
const path=require("path")
const cliConfig = require("../CLIConfig.js")
const color=require("./color.js")

//saveConfig
module.exports=function(userAccount, contractAccount) {
    // @ts-ignore -- import.meta.url
    let basedir = path.join(__dirname, "..")
    if (basedir.startsWith("\\")) basedir = basedir.slice(1) // windows compat remove extra "\"
    let cliConfigPath = path.join(basedir, "CLIConfig.js")
    cliConfigPath = path.relative(process.cwd(),cliConfigPath)
    process.stdout.write(`saving cli-config to ${cliConfigPath}...`)
    try {

        if (!userAccount) userAccount = cliConfig.userAccount;
        if (!contractAccount) contractAccount = cliConfig.contractAccount;

        const text = `
        module.exports = {
            nickname: "${cliConfig.nickname}",
            userAccount: "${userAccount}",
            contractAccount: "${contractAccount}"
        }`

        fs.writeFileSync(cliConfigPath, text)
        console.log(`${color.green}OK${color.normal}`)
    }
    catch (err) {
        console.log(`${color.red}ERR:${err.message}${color.normal}`)
        throw (err)
    }

}
'''
'''--- res/packageES2018.json ---
{
  "name": "{nickname}",
  "version": "1.0.0",
  "description": "command cli for {contract} smart contract at {contractAddress}}",
  "main": "{nickname}",
  "bin": {
    "{nickname}": "cli.js"
  },
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/{contractAddress}"
  },
  "keywords": [
    "near",
    "contract",
    "cli",
    "tool",
    "{contract}",
    "{contractAddress}"
  ],
  "author": "luciotato@gmail.com",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/create-contract-cli/issues"
  },
  "homepage": "https://github.com/luciotato/create-contract-cli#readme"
}

'''
'''--- res/packageTYPEMOD.json ---
{
  "name": "{nickname}",
  "version": "1.0.0",
  "description": "command cli for {contract} smart contract at {contractAddress}}",
  "main": "{nickname}",
  "type": "module",
  "bin": {
    "{nickname}": "cli.js"
  },
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/{contractAddress}"
  },
  "keywords": [
    "near",
    "contract",
    "cli",
    "tool",
    "{contract}",
    "{contractAddress}"
  ],
  "author": "luciotato@gmail.com",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/create-contract-cli/issues"
  },
  "homepage": "https://github.com/luciotato/create-contract-cli#readme"
}

'''
'''--- res/test/expected/div-pool-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/div-pool/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
  * NOTE
    This contract implements several traits

    1. deposit-trait [NEP-xxx]: this contract implements: deposit, get_account_total_balance, get_account_available_balance, withdraw, withdraw_all
       A [NEP-xxx] contract creates an account on deposit and allows you to withdraw later under certain conditions. Deletes the account on withdraw_all

    2. staking-pool [NEP-xxx]: this contract must be perceived as a staking-pool for the lockup-contract, wallets, and users.
        This means implmenting: ping, deposit, deposit_and_stake, withdraw_all, withdraw, stake_all, stake, unstake_all, unstake
        and view methods: get_account_unstaked_balance, get_account_staked_balance, get_account_total_balance, is_account_unstaked_balance_available,
            get_total_staked_balance, get_owner_id, get_reward_fee_fraction, is_staking_paused, get_staking_key, get_account,
            get_number_of_accounts, get_accounts.

    3. diversified-staking: these are the extensions to the standard staking pool (buy/sell skash)

    4. multitoken (TODO) [NEP-xxx]: this contract implements: deposit(tok), get_token_balance(tok), withdraw_token(tok), tranfer_token(tok), transfer_token_to_contract(tok)
       A [NEP-xxx] manages multiple tokens

    *
   Requires 25 TGas (1 * BASE_GAS)
   Initializes DiversifiedPool contract.
   - 'owner_account_id' - the account ID of the owner.  Only this account can call owner's methods on this contract.
  #[init]
  
  usage:
  > div new { owner_account_id: AccountId, treasury_account_id: AccountId, operator_account_id: AccountId }
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ owner_account_id: AccountId, treasury_account_id: AccountId, operator_account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new",fnJSONParams)
    
  }
  
  ping_HELP(){ return `
  pub fn set_min_balance(&mut self)
  ------------------------------------
   deposit trait & staking-pool trait
  ------------------------------------
   staking-pool's ping redirects to diversified-pool's distribute, Does a bit of work
  
  usage:
  > div ping 
  `};
  
  ping(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--ping has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("ping")
    
  }
  
  deposit_HELP(){ return `
   Deposits the attached amount into the inner account of the predecessor.
  #[payable]
  
  usage:
  > div deposit 
  `};
  
  deposit(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--deposit has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("deposit")
    
  }
  
  withdraw_HELP(){ return `
   Withdraws from the available balance
  
  usage:
  > div withdraw { amount: U128String }
  `};
  
  withdraw(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw",fnJSONParams)
    
  }
  
  withdraw_all_HELP(){ return `
   Withdraws ALL from the "available" balance
  
  usage:
  > div withdraw_all 
  `};
  
  withdraw_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--withdraw_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw_all")
    
  }
  
  deposit_and_stake_HELP(){ return `
   Deposits the attached amount into the inner account of the predecessor and stakes it.
  #[payable]
  
  usage:
  > div deposit_and_stake 
  `};
  
  deposit_and_stake(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--deposit_and_stake has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("deposit_and_stake")
    
  }
  
  stake_all_HELP(){ return `
   Stakes all available unstaked balance from the inner account of the predecessor.
   staking-pool "unstaked" is equivalent to diversified-pool "available", but here
   we keep the staking-pool logic because we're implementing the staking-pool trait
  
  usage:
  > div stake_all 
  `};
  
  stake_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--stake_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("stake_all")
    
  }
  
  stake_HELP(){ return `
   Stakes the given amount from the inner account of the predecessor.
   The inner account should have enough unstaked balance.
  
  usage:
  > div stake { amount: U128String }
  `};
  
  stake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("stake",fnJSONParams)
    
  }
  
  unstake_all_HELP(){ return `
   Unstakes all staked balance from the inner account of the predecessor.
   The new total unstaked balance will be available for withdrawal in four epochs.
  
  usage:
  > div unstake_all 
  `};
  
  unstake_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--unstake_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("unstake_all")
    
  }
  
  unstake_HELP(){ return `
   Unstakes the given amount from the inner account of the predecessor.
   The inner account should have enough staked balance.
   The new total unstaked balance will be available for withdrawal in four epochs.
  
  usage:
  > div unstake { amount: U128String }
  `};
  
  unstake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("unstake",fnJSONParams)
    
  }
  
  get_account_unstaked_balance_HELP(){ return `
  *****************************
  * staking-pool View methods *
  *****************************
   Returns the unstaked balance of the given account.
  
  usage:
  > div get_account_unstaked_balance { account_id: AccountId }
  `};
  
  get_account_unstaked_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_unstaked_balance",fnJSONParams)
    
  }
  
  get_account_staked_balance_HELP(){ return `
   Returns the staked balance of the given account.
   NOTE: This is computed from the amount of "stake" shares the given account has and the
   current amount of total staked balance and total stake shares on the account.
  
  usage:
  > div get_account_staked_balance { account_id: AccountId }
  `};
  
  get_account_staked_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_staked_balance",fnJSONParams)
    
  }
  
  get_account_total_balance_HELP(){ return `
   Returns the total balance of the given account (including staked and unstaked balances).
  
  usage:
  > div get_account_total_balance { account_id: AccountId }
  `};
  
  get_account_total_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_total_balance",fnJSONParams)
    
  }
  
  get_account_available_balance_HELP(){ return `
   additional to staking-pool to satisfy generic deposit-NEP-standard
   returns the amount that can be withdrawn immediately
  
  usage:
  > div get_account_available_balance { account_id: AccountId }
  `};
  
  get_account_available_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_available_balance",fnJSONParams)
    
  }
  
  is_account_unstaked_balance_available_HELP(){ return `
   Returns 'true' if the given account can withdraw tokens in the current epoch.
  
  usage:
  > div is_account_unstaked_balance_available { account_id: AccountId }
  `};
  
  is_account_unstaked_balance_available(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("is_account_unstaked_balance_available",fnJSONParams)
    
  }
  
  get_owner_id_HELP(){ return `
   Returns account ID of the staking pool owner.
  
  usage:
  > div get_owner_id 
  `};
  
  get_owner_id(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_owner_id has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_owner_id")
    
  }
  
  get_reward_fee_fraction_HELP(){ return `
   Returns the current reward fee as a fraction.
  
  usage:
  > div get_reward_fee_fraction 
  `};
  
  get_reward_fee_fraction(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_reward_fee_fraction has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_reward_fee_fraction")
    
  }
  
  get_staking_key_HELP(){ return `
   Returns the staking public key
  
  usage:
  > div get_staking_key 
  `};
  
  get_staking_key(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_staking_key has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_staking_key")
    
  }
  
  is_staking_paused_HELP(){ return `
   Returns true if the staking is paused
  
  usage:
  > div is_staking_paused 
  `};
  
  is_staking_paused(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--is_staking_paused has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("is_staking_paused")
    
  }
  
  get_account_HELP(){ return `
   to implement the Staking-pool inteface, get_account returns the same as the staking-pool returns
   full account info can be obtained by calling: pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult
   Returns human readable representation of the account for the given account ID.
  warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
  
  usage:
  > div get_account { account_id: AccountId }
  `};
  
  get_account(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account",fnJSONParams)
    
  }
  
  get_number_of_accounts_HELP(){ return `
   Returns the number of accounts that have positive balance on this staking pool.
  
  usage:
  > div get_number_of_accounts 
  `};
  
  get_number_of_accounts(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_number_of_accounts has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_number_of_accounts")
    
  }
  
  get_accounts_HELP(){ return `
   Returns the list of accounts
  warning: self.get_accounts is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
  
  usage:
  > div get_accounts { from_index: u64, limit: u64 }
  `};
  
  get_accounts(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from_index: u64, limit: u64 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_accounts",fnJSONParams)
    
  }
  
  complete_unstaking_HELP(){ return `
  ----------------------------------
  ----------------------------------
   DIVERISIFYING-STAKING-POOL trait
  ----------------------------------
  ----------------------------------
   user method
   completes unstake action by moving from retreieved_from_the_pools to available
  
  usage:
  > div complete_unstaking 
  `};
  
  complete_unstaking(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--complete_unstaking has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("complete_unstaking")
    
  }
  
  buy_skash_stake_HELP(){ return `
   buy_skash_stake. Identical to stake, migth change in the future
  
  usage:
  > div buy_skash_stake { amount: U128String }
  `};
  
  buy_skash_stake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("buy_skash_stake",fnJSONParams)
    
  }
  
  get_near_amount_sell_skash_HELP(){ return `
  ---------------------------
   NSLP Methods
  ---------------------------
   user method - NEAR/SKASH SWAP functions
   return how much NEAR you can get by selling x SKASH
  
  usage:
  > div get_near_amount_sell_skash { skash_to_sell: U128String }
  `};
  
  get_near_amount_sell_skash(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ skash_to_sell: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_near_amount_sell_skash",fnJSONParams)
    
  }
  
  nslp_get_discount_basis_points_HELP(){ return `
   NEAR/SKASH Liquidity Pool
   computes the discount_basis_points for NEAR/SKASH Swap based on NSLP Balance
   If you want to sell x SKASH
  
  usage:
  > div nslp_get_discount_basis_points { skash_to_sell: U128String }
  `};
  
  nslp_get_discount_basis_points(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ skash_to_sell: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("nslp_get_discount_basis_points",fnJSONParams)
    
  }
  
  sell_skash_HELP(){ return `
   user method
   Sells-skash at discount in the NLSP
   returns near received
  
  usage:
  > div sell_skash { skash_to_sell: U128String, min_expected_near: U128String }
  `};
  
  sell_skash(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ skash_to_sell: U128String, min_expected_near: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("sell_skash",fnJSONParams)
    
  }
  
  nslp_add_liquidity_HELP(){ return `
   add liquidity from deposited funds
  
  usage:
  > div nslp_add_liquidity { amount: U128String }
  `};
  
  nslp_add_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("nslp_add_liquidity",fnJSONParams)
    
  }
  
  nslp_remove_liquidity_HELP(){ return `
   remove liquidity from deposited funds
  
  usage:
  > div nslp_remove_liquidity { amount: U128String }
  `};
  
  nslp_remove_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128String }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("nslp_remove_liquidity",fnJSONParams)
    
  }
  
  harvest_g_skash_from_staking_HELP(){ return `
  ------------------
   HARVEST G-SKASH
  ------------------
  g-skash for stakers are realized during stake(), unstake() or by calling harvest_g_skash_from_staking()
  realize pending g-skash rewards from staking
  
  usage:
  > div harvest_g_skash_from_staking 
  `};
  
  harvest_g_skash_from_staking(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--harvest_g_skash_from_staking has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("harvest_g_skash_from_staking")
    
  }
  
  harvest_g_skash_from_lp_HELP(){ return `
  g-skash for LP providers are realized during add_liquidit(), remove_liquidity() or by calling harvest_g_skash_from_lp()
  realize pending g-skash rewards from LP
  
  usage:
  > div harvest_g_skash_from_lp 
  `};
  
  harvest_g_skash_from_lp(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--harvest_g_skash_from_lp has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("harvest_g_skash_from_lp")
    
  }
  
  get_staking_pool_list_HELP(){ return `
  ---------------------------------
   staking-pools-list (SPL) management
  ---------------------------------
   get the current list of pools
  
  usage:
  > div get_staking_pool_list 
  `};
  
  get_staking_pool_list(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_staking_pool_list has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_staking_pool_list")
    
  }
  
  remove_staking_pool_HELP(){ return `
  remove staking pool from list *if it's empty*
  
  usage:
  > div remove_staking_pool { inx: u16 }
  `};
  
  remove_staking_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ inx: u16 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("remove_staking_pool",fnJSONParams)
    
  }
  
  set_staking_pool_weight_HELP(){ return `
  update existing weight_basis_points
  
  usage:
  > div set_staking_pool_weight { inx: u16, weight_basis_points: u16 }
  `};
  
  set_staking_pool_weight(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ inx: u16, weight_basis_points: u16 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("set_staking_pool_weight",fnJSONParams)
    
  }
  
  set_staking_pool_HELP(){ return `
  add a new staking pool or update existing weight_basis_points
  
  usage:
  > div set_staking_pool { account_id: AccountId, weight_basis_points: u16 }
  `};
  
  set_staking_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId, weight_basis_points: u16 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("set_staking_pool",fnJSONParams)
    
  }
  
  distribute_HELP(){ return `
  -----------------------------
   DISTRIBUTE
  -----------------------------
   operator method
   distribute. Do staking & unstaking in batches of at most 100Kn
   called externaly every 30 mins or less if: a) there's a large stake/unstake oper to perform or b) the epoch is about to finish and there are stakes to be made
   returns "true" if there's still more job to do
  
  usage:
  > div distribute 
  `};
  
  distribute(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--distribute has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("distribute")
    
  }
  
  on_staking_pool_stake_maybe_deposit_HELP(){ return `
  prev fn continues here
   Called after amount is staked from the sp's unstaked balance (all into  the staking pool contract).
   This method needs to update staking pool status.
  
  usage:
  > div on_staking_pool_stake_maybe_deposit { sp_inx: usize, amount: u128, included_deposit: bool }
  `};
  
  on_staking_pool_stake_maybe_deposit(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ sp_inx: usize, amount: u128, included_deposit: bool }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("on_staking_pool_stake_maybe_deposit",fnJSONParams)
    
  }
  
  on_staking_pool_unstake_HELP(){ return `
   Called after the given amount was unstaked at the staking pool contract.
   This method needs to update staking pool status.
  
  usage:
  > div on_staking_pool_unstake { sp_inx: usize, amount: u128 }
  `};
  
  on_staking_pool_unstake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ sp_inx: usize, amount: u128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("on_staking_pool_unstake",fnJSONParams)
    
  }
  
  get_operator_account_id_HELP(){ return `
  ------------------------------------------
   GETTERS (moved from getters.rs)
  ------------------------------------------
   Returns the account ID of the owner.
  
  usage:
  > div get_operator_account_id 
  `};
  
  get_operator_account_id(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_operator_account_id has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_operator_account_id")
    
  }
  
  get_known_deposited_balance_HELP(){ return `
   The amount of tokens that were deposited to the staking pool.
   NOTE: The actual balance can be larger than this known deposit balance due to staking
   rewards acquired on the staking pool.
   To refresh the amount the owner can call 'refresh_staking_pool_balance'.
  
  usage:
  > div get_known_deposited_balance 
  `};
  
  get_known_deposited_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_known_deposited_balance has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_known_deposited_balance")
    
  }
  
  get_account_info_HELP(){ return `
   full account info
   Returns JSON representation of the account for the given account ID.
  
  usage:
  > div get_account_info { account_id: AccountId }
  `};
  
  get_account_info(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_info",fnJSONParams)
    
  }
  
  get_contract_info_HELP(){ return `
   NEP-129 get information about this contract
   returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
  
  usage:
  > div get_contract_info 
  `};
  
  get_contract_info(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_contract_info has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_contract_info")
    
  }
  
  get_contract_state_HELP(){ return `
   get contract totals 
   Returns JSON representation of the contract state
  
  usage:
  > div get_contract_state 
  `};
  
  get_contract_state(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_contract_state has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_contract_state")
    
  }
  
  get_contract_params_HELP(){ return `
   Returns JSON representation of contract parameters
  
  usage:
  > div get_contract_params 
  `};
  
  get_contract_params(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_contract_params has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_contract_params")
    
  }
  
  set_contract_params_HELP(){ return `
   Returns JSON representation of contract parameters
  
  usage:
  > div set_contract_params { params: ContractParamsJSON }
  `};
  
  set_contract_params(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ params: ContractParamsJSON }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("set_contract_params",fnJSONParams)
    
  }
  
  get_sp_info_HELP(){ return `
   get sp (staking-pool) info
   Returns JSON representation of sp recorded state
  
  usage:
  > div get_sp_info { sp_inx_i32: i32 }
  `};
  
  get_sp_info(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ sp_inx_i32: i32 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_sp_info",fnJSONParams)
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/factory-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/staking-pool-factory/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
   Initializes the staking pool factory with the given account ID of the staking pool whitelist
   contract.
  #[init]
  
  usage:
  > factory new 
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--new has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new")
    
  }
  
  get_min_attached_balance_HELP(){ return `
   Returns the minimum amount of tokens required to attach to the function call to
   create a new staking pool.
  
  usage:
  > factory get_min_attached_balance 
  `};
  
  get_min_attached_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_min_attached_balance has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_min_attached_balance")
    
  }
  
  get_number_of_staking_pools_created_HELP(){ return `
   Returns the total number of the staking pools created from this factory.
  
  usage:
  > factory get_number_of_staking_pools_created 
  `};
  
  get_number_of_staking_pools_created(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_number_of_staking_pools_created has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_number_of_staking_pools_created")
    
  }
  
  create_staking_pool_HELP(){ return `
   Creates a new staking pool.
   - 'staking_pool_id' - the prefix of the account ID that will be used to create a new staking
      pool account. It'll be prepended to the staking pool factory account ID separated by dot.
   - 'owner_id' - the account ID of the staking pool owner. This account will be able to
      control the staking pool, set reward fee, update staking key and vote on behalf of the
       pool.
   - 'stake_public_key' - the initial staking key for the staking pool.
   - 'reward_fee_fraction' - the initial reward fee fraction for the staking pool.
  #[payable]
  
  usage:
  > factory create_staking_pool { staking_pool_id: String, owner_id: AccountId, stake_public_key: Base58PublicKey, reward_fee_fraction: RewardFeeFraction }
  `};
  
  create_staking_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ staking_pool_id: String, owner_id: AccountId, stake_public_key: Base58PublicKey, reward_fee_fraction: RewardFeeFraction }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("create_staking_pool",fnJSONParams)
    
  }
  
  on_staking_pool_create_HELP(){ return `
   Callback after a staking pool was created.
   Returns the promise to whitelist the staking pool contract if the pool creation succeeded.
   Otherwise refunds the attached deposit and returns 'false'.
  
  usage:
  > factory on_staking_pool_create { staking_pool_account_id: AccountId, attached_deposit: U128, predecessor_account_id: AccountId }
  `};
  
  on_staking_pool_create(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ staking_pool_account_id: AccountId, attached_deposit: U128, predecessor_account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("on_staking_pool_create",fnJSONParams)
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/lockup-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/lockup/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
   Requires 25 TGas (1 * BASE_GAS)
   Initializes lockup contract.
   - 'owner_account_id' - the account ID of the owner.  Only this account can call owner's
      methods on this contract.
   - 'lockup_duration' - the duration in nanoseconds of the lockup period from the moment
      the transfers are enabled.
   - 'lockup_timestamp' - the optional absolute lockup timestamp in nanoseconds which locks
      the tokens until this timestamp passes.
   - 'transfers_information' - the information about the transfers. Either transfers are
      already enabled, then it contains the timestamp when they were enabled. Or the transfers
      are currently disabled and it contains the account ID of the transfer poll contract.
   - 'vesting_schedule' - If provided, then it's either a base64 encoded hash of vesting
      schedule with salt or an explicit vesting schedule.
      Vesting schedule affects the amount of tokens the NEAR Foundation will get in case of
      employment termination as well as the amount of tokens available for transfer by
      the employee. If Hash provided, it's expected that vesting started before lockup and
      it only needs to be revealed in case of termination.
   - 'release_duration' - is the duration when the full lockup amount will be available.
      The tokens are linearly released from the moment transfers are enabled. If it's used
      in addition to the vesting schedule, then the amount of tokens available to transfer
      is subject to the minimum between vested tokens and released tokens.
   - 'staking_pool_whitelist_account_id' - the Account ID of the staking pool whitelist contract.
   - 'foundation_account_id' - the account ID of the NEAR Foundation, that has the ability to
      terminate vesting schedule.
  #[init]
  
  usage:
  > lockup new { owner_account_id: AccountId, lockup_duration: WrappedDuration, lockup_timestamp: Option, transfers_information: TransfersInformation, vesting_schedule: Option, release_duration: Option, staking_pool_whitelist_account_id: AccountId, foundation_account_id: Option }
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ owner_account_id: AccountId, lockup_duration: WrappedDuration, lockup_timestamp: Option, transfers_information: TransfersInformation, vesting_schedule: Option, release_duration: Option, staking_pool_whitelist_account_id: AccountId, foundation_account_id: Option }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new",fnJSONParams)
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/multisig-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/multisig/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
   Initialize multisig contract.
   @params num_confirmations: k of n signatures required to perform operations.
  #[init]
  
  usage:
  > multisig new 
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--new has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new")
    
  }
  
  add_request_HELP(){ return `
   Add request for multisig.
  
  usage:
  > multisig add_request { request: MultiSigRequest }
  `};
  
  add_request(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request: MultiSigRequest }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_request",fnJSONParams)
    
  }
  
  add_request_and_confirm_HELP(){ return `
   Add request for multisig and confirm with the pk that added.
  
  usage:
  > multisig add_request_and_confirm { request: MultiSigRequest }
  `};
  
  add_request_and_confirm(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request: MultiSigRequest }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_request_and_confirm",fnJSONParams)
    
  }
  
  delete_request_HELP(){ return `
   Remove given request and associated confirmations.
  
  usage:
  > multisig delete_request { request_id: RequestId }
  `};
  
  delete_request(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request_id: RequestId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("delete_request",fnJSONParams)
    
  }
  
  confirm_HELP(){ return `
   Confirm given request with given signing key.
   If with this, there has been enough confirmation, a promise with request will be scheduled.
  
  usage:
  > multisig confirm { request_id: RequestId }
  `};
  
  confirm(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request_id: RequestId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("confirm",fnJSONParams)
    
  }
  
  get_request_HELP(){ return `
  ********************************
    View methods
    ********************************
  
  usage:
  > multisig get_request { request_id: RequestId }
  `};
  
  get_request(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request_id: RequestId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_request",fnJSONParams)
    
  }
  
  get_num_requests_pk_HELP(){ return `
  
  usage:
  > multisig get_num_requests_pk { public_key: Base58PublicKey }
  `};
  
  get_num_requests_pk(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ public_key: Base58PublicKey }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_num_requests_pk",fnJSONParams)
    
  }
  
  list_request_ids_HELP(){ return `
  
  usage:
  > multisig list_request_ids 
  `};
  
  list_request_ids(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--list_request_ids has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("list_request_ids")
    
  }
  
  get_confirmations_HELP(){ return `
  
  usage:
  > multisig get_confirmations { request_id: RequestId }
  `};
  
  get_confirmations(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ request_id: RequestId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_confirmations",fnJSONParams)
    
  }
  
  get_num_confirmations_HELP(){ return `
  
  usage:
  > multisig get_num_confirmations 
  `};
  
  get_num_confirmations(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_num_confirmations has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_num_confirmations")
    
  }
  
  get_request_nonce_HELP(){ return `
  
  usage:
  > multisig get_request_nonce 
  `};
  
  get_request_nonce(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_request_nonce has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_request_nonce")
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/staking-pool-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/staking-pool/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
   Initializes the contract with the given owner_id, initial staking public key (with ED25519
   curve) and initial reward fee fraction that owner charges for the validation work.
   The entire current balance of this contract will be used to stake. This allows contract to
   always maintain staking shares that can't be unstaked or withdrawn.
   It prevents inflating the price of the share too much.
  #[init]
  
  usage:
  > staky new { owner_id: AccountId, stake_public_key: Base58PublicKey, reward_fee_fraction: RewardFeeFraction }
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ owner_id: AccountId, stake_public_key: Base58PublicKey, reward_fee_fraction: RewardFeeFraction }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new",fnJSONParams)
    
  }
  
  ping_HELP(){ return `
   Distributes rewards and restakes if needed.
  
  usage:
  > staky ping 
  `};
  
  ping(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--ping has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("ping")
    
  }
  
  deposit_HELP(){ return `
   Deposits the attached amount into the inner account of the predecessor.
  #[payable]
  
  usage:
  > staky deposit 
  `};
  
  deposit(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--deposit has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("deposit")
    
  }
  
  deposit_and_stake_HELP(){ return `
   Deposits the attached amount into the inner account of the predecessor and stakes it.
  #[payable]
  
  usage:
  > staky deposit_and_stake 
  `};
  
  deposit_and_stake(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--deposit_and_stake has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("deposit_and_stake")
    
  }
  
  withdraw_all_HELP(){ return `
   Withdraws the entire unstaked balance from the predecessor account.
   It's only allowed if the 'unstake' action was not performed in the four most recent epochs.
  
  usage:
  > staky withdraw_all 
  `};
  
  withdraw_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--withdraw_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw_all")
    
  }
  
  withdraw_HELP(){ return `
   Withdraws the non staked balance for given account.
   It's only allowed if the 'unstake' action was not performed in the four most recent epochs.
  
  usage:
  > staky withdraw { amount: U128 }
  `};
  
  withdraw(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw",fnJSONParams)
    
  }
  
  stake_all_HELP(){ return `
   Stakes all available unstaked balance from the inner account of the predecessor.
  
  usage:
  > staky stake_all 
  `};
  
  stake_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--stake_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("stake_all")
    
  }
  
  stake_HELP(){ return `
   Stakes the given amount from the inner account of the predecessor.
   The inner account should have enough unstaked balance.
  
  usage:
  > staky stake { amount: U128 }
  `};
  
  stake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("stake",fnJSONParams)
    
  }
  
  unstake_all_HELP(){ return `
   Unstakes all staked balance from the inner account of the predecessor.
   The new total unstaked balance will be available for withdrawal in four epochs.
  
  usage:
  > staky unstake_all 
  `};
  
  unstake_all(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--unstake_all has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("unstake_all")
    
  }
  
  unstake_HELP(){ return `
   Unstakes the given amount from the inner account of the predecessor.
   The inner account should have enough staked balance.
   The new total unstaked balance will be available for withdrawal in four epochs.
  
  usage:
  > staky unstake { amount: U128 }
  `};
  
  unstake(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ amount: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("unstake",fnJSONParams)
    
  }
  
  get_account_unstaked_balance_HELP(){ return `
  ****************
  * View methods *
  ****************
   Returns the unstaked balance of the given account.
  
  usage:
  > staky get_account_unstaked_balance { account_id: AccountId }
  `};
  
  get_account_unstaked_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_unstaked_balance",fnJSONParams)
    
  }
  
  get_account_staked_balance_HELP(){ return `
   Returns the staked balance of the given account.
   NOTE: This is computed from the amount of "stake" shares the given account has and the
   current amount of total staked balance and total stake shares on the account.
  
  usage:
  > staky get_account_staked_balance { account_id: AccountId }
  `};
  
  get_account_staked_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_staked_balance",fnJSONParams)
    
  }
  
  get_account_total_balance_HELP(){ return `
   Returns the total balance of the given account (including staked and unstaked balances).
  
  usage:
  > staky get_account_total_balance { account_id: AccountId }
  `};
  
  get_account_total_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account_total_balance",fnJSONParams)
    
  }
  
  is_account_unstaked_balance_available_HELP(){ return `
   Returns 'true' if the given account can withdraw tokens in the current epoch.
  
  usage:
  > staky is_account_unstaked_balance_available { account_id: AccountId }
  `};
  
  is_account_unstaked_balance_available(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("is_account_unstaked_balance_available",fnJSONParams)
    
  }
  
  get_total_staked_balance_HELP(){ return `
   Returns the total staking balance.
  
  usage:
  > staky get_total_staked_balance 
  `};
  
  get_total_staked_balance(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_total_staked_balance has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_total_staked_balance")
    
  }
  
  get_owner_id_HELP(){ return `
   Returns account ID of the staking pool owner.
  
  usage:
  > staky get_owner_id 
  `};
  
  get_owner_id(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_owner_id has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_owner_id")
    
  }
  
  get_reward_fee_fraction_HELP(){ return `
   Returns the current reward fee as a fraction.
  
  usage:
  > staky get_reward_fee_fraction 
  `};
  
  get_reward_fee_fraction(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_reward_fee_fraction has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_reward_fee_fraction")
    
  }
  
  get_staking_key_HELP(){ return `
   Returns the staking public key
  
  usage:
  > staky get_staking_key 
  `};
  
  get_staking_key(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_staking_key has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_staking_key")
    
  }
  
  is_staking_paused_HELP(){ return `
   Returns true if the staking is paused
  
  usage:
  > staky is_staking_paused 
  `};
  
  is_staking_paused(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--is_staking_paused has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("is_staking_paused")
    
  }
  
  get_account_HELP(){ return `
   Returns human readable representation of the account for the given account ID.
  
  usage:
  > staky get_account { account_id: AccountId }
  `};
  
  get_account(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ account_id: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_account",fnJSONParams)
    
  }
  
  get_number_of_accounts_HELP(){ return `
   Returns the number of accounts that have positive balance on this staking pool.
  
  usage:
  > staky get_number_of_accounts 
  `};
  
  get_number_of_accounts(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_number_of_accounts has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_number_of_accounts")
    
  }
  
  get_accounts_HELP(){ return `
   Returns the list of accounts
  
  usage:
  > staky get_accounts { from_index: u64, limit: u64 }
  `};
  
  get_accounts(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from_index: u64, limit: u64 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_accounts",fnJSONParams)
    
  }
  
  on_stake_action_HELP(){ return `
  *************
  * Callbacks *
  *************
  
  usage:
  > staky on_stake_action 
  `};
  
  on_stake_action(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--on_stake_action has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("on_stake_action")
    
  }
  
  update_staking_key_HELP(){ return `
  *******************
  * Owner's methods *
  *******************
   Owner's method.
   Updates current public key to the new given public key.
  
  usage:
  > staky update_staking_key { stake_public_key: Base58PublicKey }
  `};
  
  update_staking_key(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ stake_public_key: Base58PublicKey }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("update_staking_key",fnJSONParams)
    
  }
  
  update_reward_fee_fraction_HELP(){ return `
   Owner's method.
   Updates current reward fee fraction to the new given fraction.
  
  usage:
  > staky update_reward_fee_fraction { reward_fee_fraction: RewardFeeFraction }
  `};
  
  update_reward_fee_fraction(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ reward_fee_fraction: RewardFeeFraction }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("update_reward_fee_fraction",fnJSONParams)
    
  }
  
  vote_HELP(){ return `
   Owner's method.
   Calls 'vote(is_vote)' on the given voting contract account ID on behalf of the pool.
  
  usage:
  > staky vote { voting_account_id: AccountId, is_vote: bool }
  `};
  
  vote(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ voting_account_id: AccountId, is_vote: bool }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("vote",fnJSONParams)
    
  }
  
  pause_staking_HELP(){ return `
   Owner's method.
   Pauses pool staking.
  
  usage:
  > staky pause_staking 
  `};
  
  pause_staking(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--pause_staking has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("pause_staking")
    
  }
  
  resume_staking_HELP(){ return `
   Owner's method.
   Resumes pool staking.
  
  usage:
  > staky resume_staking 
  `};
  
  resume_staking(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--resume_staking has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("resume_staking")
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/swap-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/NEARSwap/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
  #[init]
  
  usage:
  > swap new 
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--new has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new")
    
  }
  
  set_fee_dst_HELP(){ return `
   Updates the fee destination destination account
  
  usage:
  > swap set_fee_dst { fee_dst: AccountId }
  `};
  
  set_fee_dst(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ fee_dst: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("set_fee_dst",fnJSONParams)
    
  }
  
  change_owner_HELP(){ return `
   Owner is an account (can be acc multisig) who has management rights to update
   fee size.
  
  usage:
  > swap change_owner { new_owner: AccountId }
  `};
  
  change_owner(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ new_owner: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("change_owner",fnJSONParams)
    
  }
  
  create_pool_HELP(){ return `
  **********************
     POOL MANAGEMENT
    *********************
   Allows any user to creat acc new near-token pool. Each pool is identified by the 'token'
   account - which we call the Pool Reserve Token.
   If acc pool for give token exists then "E1" assert exception is thrown.
   TODO: charge user for acc storage created!
  #[payable]
  
  usage:
  > swap create_pool { token: AccountId }
  `};
  
  create_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("create_pool",fnJSONParams)
    
  }
  
  pool_info_HELP(){ return `
   Extracts public information of the 'token' pool.
  
  usage:
  > swap pool_info { token: AccountId }
  `};
  
  pool_info(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("pool_info",fnJSONParams)
    
  }
  
  list_pools_HELP(){ return `
   Returns list of pools identified as their reserve token AccountId.
  
  usage:
  > swap list_pools 
  `};
  
  list_pools(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--list_pools has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("list_pools")
    
  }
  
  add_liquidity_HELP(){ return `
   Increases Near and the Reserve token liquidity.
   The supplied funds must preserve current ratio of the liquidity pool.
   Returns amount of LP Shares is minted for the user.
  #[payable]
  
  usage:
  > swap add_liquidity { token: AccountId, max_tokens: U128, min_shares: U128 }
  `};
  
  add_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, max_tokens: U128, min_shares: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_liquidity",fnJSONParams)
    
  }
  
  withdraw_liquidity_HELP(){ return `
   Redeems 'shares' for liquidity stored in this pool with condition of getting at least
   'min_ynear' of Near and 'min_tokens' of reserve tokens ('token'). Shares are note
   exchengable between different pools.
  
  usage:
  > swap withdraw_liquidity { token: AccountId, shares: U128, min_ynear: U128, min_tokens: U128 }
  `};
  
  withdraw_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, shares: U128, min_ynear: U128, min_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw_liquidity",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_in_HELP(){ return `
  **********************
     CLP market functions
    **********************
   Swaps NEAR to 'token' and transfers the reserve tokens to the caller.
   Caller attaches near tokens he wants to swap to the transacion under acc condition of
   receving at least 'min_tokens' of 'token'.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_in { token: AccountId, min_tokens: U128 }
  `};
  
  swap_near_to_token_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, min_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_in",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_in_xfr_HELP(){ return `
   Same as 'swap_near_to_token_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_in_xfr { token: AccountId, min_tokens: U128, recipient: AccountId }
  `};
  
  swap_near_to_token_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, min_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_out_HELP(){ return `
   Swaps NEAR to 'token' and transfers the reserve tokens to the caller.
   Caller attaches maximum amount of NEAR he is willing to swap to receive 'tokens_out'
   of 'token' wants to swap to the transacion. Surplus of NEAR tokens will be returned.
   Transaction will panic if the caller doesn't attach enough NEAR tokens.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_out { token: AccountId, tokens_out: U128 }
  `};
  
  swap_near_to_token_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_out",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_out_xfr_HELP(){ return `
   Same as 'swap_near_to_token_exact_out', but user additionly specifies the 'recipient'
   who will receive the reserve tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_out_xfr { token: AccountId, tokens_out: U128, recipient: AccountId }
  `};
  
  swap_near_to_token_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_out_xfr",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_in_HELP(){ return `
   Swaps 'tokens_paid' of 'token' to NEAR and transfers NEAR to the caller under acc
   condition of receving at least 'min_ynear' yocto NEARs.
   Preceeding to this transaction, caller has to create sufficient allowance of 'token'
   for this contract (at least 'tokens_paid').
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_in { token: AccountId, tokens_paid: U128, min_ynear: U128 }
  `};
  
  swap_token_to_near_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_paid: U128, min_ynear: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_in",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_in_xfr_HELP(){ return `
   Same as 'swap_token_to_near_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_in_xfr { token: AccountId, tokens_paid: U128, min_ynear: U128, recipient: AccountId }
  `};
  
  swap_token_to_near_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_paid: U128, min_ynear: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_out_HELP(){ return `
   Swaps 'token' to NEAR and transfers NEAR to the caller.
   Caller defines the amount of NEAR he wants to receive under acc condition of not spending
   more than 'max_tokens' of 'token'.
   Preceeding to this transaction, caller has to create sufficient allowance of 'token'
   for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_out { token: AccountId, ynear_out: U128, max_tokens: U128 }
  `};
  
  swap_token_to_near_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128, max_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_out",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_out_xfr_HELP(){ return `
   Same as 'swap_token_to_near_exact_out', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_out_xfr { token: AccountId, ynear_out: U128, max_tokens: U128, recipient: AccountId }
  `};
  
  swap_token_to_near_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128, max_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_out_xfr",fnJSONParams)
    
  }
  
  swap_tokens_exact_in_HELP(){ return `
   Swaps two different tokens.
   Caller defines the amount of tokens he wants to swap under acc condition of
   receving at least 'min_to_tokens'.
   Preceeding to this transaction, caller has to create sufficient allowance of
   'from' token for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_in { from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128 }
  `};
  
  swap_tokens_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_in",fnJSONParams)
    
  }
  
  swap_tokens_exact_in_xfr_HELP(){ return `
   Same as 'swap_tokens_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_in_xfr { from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128, recipient: AccountId }
  `};
  
  swap_tokens_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_tokens_exact_out_HELP(){ return `
   Swaps two different tokens.
   Caller defines the amount of tokens he wants to receive under acc of not spending
   more than 'max_from_tokens'.
   Preceeding to this transaction, caller has to create sufficient allowance of
   'from' token for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_out { from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128 }
  `};
  
  swap_tokens_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_out",fnJSONParams)
    
  }
  
  swap_tokens_exact_out_xfr_HELP(){ return `
   Same as 'swap_tokens_exact_out', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_out_xfr { from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128, recipient: AccountId }
  `};
  
  swap_tokens_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_out_xfr",fnJSONParams)
    
  }
  
  price_near_to_token_in_HELP(){ return `
   Calculates amount of tokens user will recieve when swapping 'ynear_in' for 'token'
   assets
  
  usage:
  > swap price_near_to_token_in { token: AccountId, ynear_in: U128 }
  `};
  
  price_near_to_token_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_near_to_token_in",fnJSONParams)
    
  }
  
  price_near_to_token_out_HELP(){ return `
   Calculates amount of NEAR user will need to swap if he wants to receive
   'tokens_out' of 'token'
  
  usage:
  > swap price_near_to_token_out { token: AccountId, tokens_out: U128 }
  `};
  
  price_near_to_token_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_near_to_token_out",fnJSONParams)
    
  }
  
  price_token_to_near_in_HELP(){ return `
   Calculates amount of NEAR user will recieve when swapping 'tokens_in' for NEAR.
  
  usage:
  > swap price_token_to_near_in { token: AccountId, tokens_in: U128 }
  `};
  
  price_token_to_near_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_near_in",fnJSONParams)
    
  }
  
  price_token_to_near_out_HELP(){ return `
   Calculates amount of tokens user will need to swap if he wants to receive
   'tokens_out' of 'tokens'
  
  usage:
  > swap price_token_to_near_out { token: AccountId, ynear_out: U128 }
  `};
  
  price_token_to_near_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_near_out",fnJSONParams)
    
  }
  
  price_token_to_token_in_HELP(){ return `
   Calculates amount of tokens 'to' user will receive when swapping 'tokens_in' of 'from'
  
  usage:
  > swap price_token_to_token_in { from: AccountId, to: AccountId, tokens_in: U128 }
  `};
  
  price_token_to_token_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, tokens_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_token_in",fnJSONParams)
    
  }
  
  price_token_to_token_out_HELP(){ return `
   Calculates amount of tokens 'from' user will need to swap if he wants to receive
   'tokens_out' of tokens 'to'
  
  usage:
  > swap price_token_to_token_out { from: AccountId, to: AccountId, tokens_out: U128 }
  `};
  
  price_token_to_token_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_token_out",fnJSONParams)
    
  }
  
  add_liquidity_transfer_callback_HELP(){ return `
  
  usage:
  > swap add_liquidity_transfer_callback { token: AccountId }
  `};
  
  add_liquidity_transfer_callback(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_liquidity_transfer_callback",fnJSONParams)
    
  }
  
  token_url_HELP(){ return `
  **********************
     Multi Token standard: NEP-MFT
    **********************
   returns resource to more information about the token.
  #[allow(unused)]
  
  usage:
  > swap token_url { token: AccountId }
  `};
  
  token_url(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("token_url",fnJSONParams)
    
  }
  
  granularity_HELP(){ return `
   granularity is the smallest amount of tokens (in the internal denomination) which
   may be minted, sent or burned at any time.
  #[allow(unused)]
  
  usage:
  > swap granularity { token: AccountId }
  `};
  
  granularity(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("granularity",fnJSONParams)
    
  }
  
  decimals_HELP(){ return `
   granularity is the smallest amount of tokens (in the internal denomination) which
   may be minted, sent or burned at any time.
  #[allow(unused)]
  
  usage:
  > swap decimals { token: AccountId }
  `};
  
  decimals(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("decimals",fnJSONParams)
    
  }
  
  total_supply_HELP(){ return `
   Returns total balance of acc given subtoken. Implements the NEP-MFT standard.
  
  usage:
  > swap total_supply { token: AccountId }
  `};
  
  total_supply(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("total_supply",fnJSONParams)
    
  }
  
  balance_of_HELP(){ return `
   Returns the owner balance of shares of acc pool identified by token.
  
  usage:
  > swap balance_of { token: AccountId, owner: AccountId }
  `};
  
  balance_of(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, owner: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("balance_of",fnJSONParams)
    
  }
  
  transfer_to_sc_HELP(){ return `
   Transfer 'amount' of LP Shares of acc pool identified by the 'token' (must be acc valid
   AccountID related to acc registered pool) from to acc 'recipeint' contract.
   Implements the NEP-MFT interface.
   'recipient' MUST be acc contract address.
   The recipient contract MUST implement 'MFTRecipient' interface.
   'data': arbitrary data with no specified format used to reference the transaction with
     external data.
   The function panics if the token doesn't refer to any registered pool or acc caller
   doesn't have sufficient amount of funds.
  #[payable]
  
  usage:
  > swap transfer_to_sc { token: String, recipient: AccountId, amount: U128, data: Data }
  `};
  
  transfer_to_sc(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: String, recipient: AccountId, amount: U128, data: Data }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("transfer_to_sc",fnJSONParams)
    
  }
  
  transfer_HELP(){ return `
   Transfer 'amount' of LP Shares of acc pool identified by the 'token' (must be acc valid
   AccountID related to acc registered pool) from to acc 'recipeint' account.
   Implements the NEP-MFT interface.
   'recipient' MUST NOT be acc contract address.
   'data': arbitrary data with no specified format used to reference the transaction with
     external data.
   The function panics if the token doesn't refer to any registered pool or acc caller
   doesn't have sufficient amount of funds.
  #[payable]
  
  usage:
  > swap transfer { token: String, recipient: AccountId, amount: U128, data: Data }
  `};
  
  transfer(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: String, recipient: AccountId, amount: U128, data: Data }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("transfer",fnJSONParams)
    
  }
  
  remove_pool_HELP(){ return `
  **********************
     Debug
    **********************
   TODO: remove
  
  usage:
  > swap remove_pool { token: AccountId }
  `};
  
  remove_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("remove_pool",fnJSONParams)
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/expected/vote-API.js ---

    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/voting/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
  #[init]
  
  usage:
  > vote new 
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--new has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new")
    
  }
  
  ping_HELP(){ return `
   Ping to update the votes according to current stake of validators.
  
  usage:
  > vote ping 
  `};
  
  ping(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--ping has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("ping")
    
  }
  
  vote_HELP(){ return `
   Method for validators to vote or withdraw the vote.
   Votes for if 'is_vote' is true, or withdraws the vote if 'is_vote' is false.
  
  usage:
  > vote vote { is_vote: bool }
  `};
  
  vote(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ is_vote: bool }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("vote",fnJSONParams)
    
  }
  
  get_result_HELP(){ return `
   Get the timestamp of when the voting finishes. 'None' means the voting hasn't ended yet.
  
  usage:
  > vote get_result 
  `};
  
  get_result(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_result has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_result")
    
  }
  
  get_total_voted_stake_HELP(){ return `
   Returns current a pair of 'total_voted_stake' and the total stake.
   Note: as a view method, it doesn't recompute the active stake. May need to call 'ping' to
   update the active stake.
  
  usage:
  > vote get_total_voted_stake 
  `};
  
  get_total_voted_stake(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_total_voted_stake has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_total_voted_stake")
    
  }
  
  get_votes_HELP(){ return `
   Returns all active votes.
   Note: as a view method, it doesn't recompute the active stake. May need to call 'ping' to
   update the active stake.
  
  usage:
  > vote get_votes 
  `};
  
  get_votes(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--get_votes has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("get_votes")
    
  }
  
}
module.exports = ContractAPI;

'''
'''--- res/test/rust/NEARSwap/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise};

pub mod types;
pub mod util;

use crate::types::*;
use crate::util::*;

// acc way to optimize memory management
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

mod internal;

// Errors
// E1: pool already exists
// E2: all token arguments must be positive.
// E3: required amount of tokens to transfer is bigger then specified max.
// E4: computed amount of shares to receive is smaller then the minimum required by the user.
// E5: can't withdraw more shares then currently owned
// E6: computed amount of near or reserve tokens is smaller than user required minimums for shares redeemption.
// E7: computed amount of buying tokens is smaller than user required minimum.
// E8: computed amount of selling tokens is bigger than user required maximum.
// E9: assets (tokens) must be different in token to token swap.
// E10: Pool is empty and can't make acc swap.
// E11: Insufficient amount of shares balance.
// E12: Insufficient amount of NEAR attached

/// PoolInfo is acc helper structure to extract public data from acc Pool
#[derive(Debug, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
pub struct PoolInfo {
    /// balance in yoctoNEAR
    pub ynear: U128,
    pub reserve: U128,
    /// total amount of participation shares. Shares are represented using the same amount of
    /// tailing decimals as the NEAR token, which is 24
    pub total_shares: U128,
}

use std::fmt;

impl fmt::Display for PoolInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        return write!(
            f,
            "({}, {}, {})",
            self.ynear.0, self.reserve.0, self.total_shares.0
        );
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Pool {
    ynear: Balance,
    reserve: Balance,
    shares: UnorderedMap<AccountId, Balance>,
    /// check `PoolInfo.total_shares`
    total_shares: Balance,
}

impl Pool {
    pub fn new(pool_id: Vec<u8>) -> Self {
        Self {
            ynear: 0,
            reserve: 0,
            shares: UnorderedMap::new(pool_id),
            total_shares: 0,
        }
    }

    pub fn pool_info(&self) -> PoolInfo {
        PoolInfo {
            ynear: self.ynear.into(),
            reserve: self.reserve.into(),
            total_shares: self.total_shares.into(),
        }
    }
}

/// NearCLP is the main contract for managing the swap pools and liquidity.
/// It implements the NEARswap functionality.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NearCLP {
    pub fee_dst: AccountId,
    pub owner: AccountId,
    // we are using unordered map because it allows to iterate over the pools
    pools: UnorderedMap<AccountId, Pool>,
}

impl Default for NearCLP {
    fn default() -> Self {
        panic!("Fun token should be initialized before usage")
    }
}

//-------------------------
// CONTRACT PUBLIC API
//-------------------------
#[near_bindgen]
impl NearCLP {
    #[init]
    pub fn new(owner: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        util::assert_account_is_valid(&owner);
        Self {
            fee_dst: owner.clone(),
            owner,
            pools: UnorderedMap::new(env::current_account_id().as_bytes().to_vec()),
        }
    }

    /// Updates the fee destination destination account
    pub fn set_fee_dst(&mut self, fee_dst: AccountId) {
        self.assert_owner();
        util::assert_account_is_valid(&fee_dst);
        self.fee_dst = fee_dst;
    }

    /// Owner is an account (can be acc multisig) who has management rights to update
    /// fee size.
    pub fn change_owner(&mut self, new_owner: AccountId) {
        self.assert_owner();
        util::assert_account_is_valid(&new_owner);
        env_log!("Changing owner from {} to {}", self.owner, new_owner);
        self.owner = new_owner;
    }

    /**********************
     POOL MANAGEMENT
    *********************/

    /// Allows any user to creat acc new near-token pool. Each pool is identified by the `token`
    /// account - which we call the Pool Reserve Token.
    /// If acc pool for give token exists then "E1" assert exception is thrown.
    /// TODO: charge user for acc storage created!
    #[payable]
    pub fn create_pool(&mut self, token: AccountId) {
        assert!(
            self.pools
                .insert(&token, &Pool::new(token.as_bytes().to_vec()))
                .is_none(),
            "E1: pool already exists"
        );
    }

    /// Extracts public information of the `token` pool.
    pub fn pool_info(&self, token: &AccountId) -> Option<PoolInfo> {
        match self.pools.get(&token) {
            None => None,
            Some(p) => Some(p.pool_info()),
        }
    }

    /// Returns list of pools identified as their reserve token AccountId.
    pub fn list_pools(&self) -> Vec<AccountId> {
        return self.pools.keys().collect();
    }

    /// Increases Near and the Reserve token liquidity.
    /// The supplied funds must preserve current ratio of the liquidity pool.
    /// Returns amount of LP Shares is minted for the user.
    #[payable]
    pub fn add_liquidity(&mut self, token: AccountId, max_tokens: U128, min_shares: U128) -> U128 {
        let mut p = self.must_get_pool(&token);
        let caller = env::predecessor_account_id();
        let shares_minted;
        let ynear_amount = env::attached_deposit();
        let added_reserve;
        let max_tokens: Balance = max_tokens.into();
        assert!(
            ynear_amount > 0 && max_tokens > 0,
            "E2: balance arguments must be >0"
        );

        env_log!("adding liquidity for {} ynear", &ynear_amount);

        // the very first deposit -- we define the constant ratio
        if p.total_shares == 0 {
            p.ynear = ynear_amount;
            shares_minted = p.ynear;
            p.total_shares = shares_minted;
            added_reserve = max_tokens;
            p.reserve = added_reserve;
            p.shares.insert(&caller, &p.ynear);
        } else {
            added_reserve = ynear_amount * p.reserve / p.ynear + 1;
            shares_minted = ynear_amount * p.total_shares / ynear_amount;
            assert!(
                max_tokens >= added_reserve,
                format!(
                    "E3: needs to transfer {} of tokens and it's bigger then specified  maximum",
                    added_reserve
                )
            );
            assert!(
                u128::from(min_shares) <= shares_minted,
                format!(
                    "E4: amount minted shares ({}) is smaller then the required minimum",
                    shares_minted
                )
            );

            p.shares.insert(
                &caller,
                &(p.shares.get(&caller).unwrap_or(0) + shares_minted),
            );
            p.reserve += added_reserve;
            p.ynear += ynear_amount;
            p.total_shares += shares_minted;
        }

        env_log!(
            "Minting {} of shares for {} yNEAR and {} reserve tokens",
            shares_minted,
            ynear_amount,
            added_reserve
        );
        println!(
            ">> in contract, attached deposit: {}, PoolInfo: {}",
            ynear_amount,
            p.pool_info()
        );
        self.set_pool(&token, &p);

        // TODO: do proper rollback
        // Prepare acc callback for liquidity transfer rollback which we will attach later on.
        let callback_args = format!(r#"{{ "token":"{}" }}"#, token).into();
        let callback = Promise::new(env::current_account_id()).function_call(
            "add_liquidity_transfer_callback".into(),
            callback_args,
            0,
            5 * TGAS,
        );
        self.schedule_nep21_tx(&token, caller, env::current_account_id(), added_reserve)
            .then(callback); //after that, the callback will check success/failure

        // TODO:
        // Handling exception is work-in-progress in NEAR runtime
        // 1. rollback `p` on changes or move the pool update to acc promise
        // 2. consider adding acc lock to prevent other contracts calling and manipulate the prise before the token transfer will get finalized.

        return shares_minted.into();
    }

    /// Redeems `shares` for liquidity stored in this pool with condition of getting at least
    /// `min_ynear` of Near and `min_tokens` of reserve tokens (`token`). Shares are note
    /// exchengable between different pools.
    pub fn withdraw_liquidity(
        &mut self,
        token: AccountId,
        shares: U128,
        min_ynear: U128,
        min_tokens: U128,
    ) {
        let shares_: u128 = shares.into();
        let min_ynear: u128 = min_ynear.into();
        let min_tokens: u128 = min_tokens.into();
        assert!(
            shares_ > 0 && min_ynear > 0 && min_tokens > 0,
            "E2: balance arguments must be >0"
        );

        let caller = env::predecessor_account_id();
        let mut p = self.must_get_pool(&token);
        let current_shares = p.shares.get(&caller).unwrap_or(0);
        assert!(
            current_shares >= shares_,
            format!(
                "E5: can't withdraw more shares then currently owned ({})",
                current_shares
            )
        );

        let total_shares2 = u256::from(p.total_shares);
        let shares2 = u256::from(shares_);
        let ynear_amount = (shares2 * u256::from(p.ynear) / total_shares2).as_u128();
        let token_amount = (shares2 * u256::from(p.reserve) / total_shares2).as_u128();
        assert!(
            ynear_amount >= min_ynear && token_amount >= min_tokens,
            format!(
                "E6: redeeming (ynear={}, tokens={}), which is smaller than the required minimum",
                ynear_amount, token_amount
            )
        );

        env_log!(
            "Reedeming {:?} shares for {} NEAR and {} reserve tokens",
            shares,
            ynear_amount,
            token_amount,
        );
        p.shares.insert(&caller, &(current_shares - shares_));
        p.total_shares -= shares_;
        p.reserve -= token_amount;
        p.ynear -= ynear_amount;

        // let prepaid_gas = env::prepaid_gas();
        self.schedule_nep21_tx(
            &token,
            env::current_account_id(),
            caller.clone(),
            token_amount,
        )
        .then(Promise::new(caller).transfer(ynear_amount));

        //TODO COMPLEX-CALLBACKS
        self.set_pool(&token, &p);
    }

    /**********************
     CLP market functions
    **********************/

    /// Swaps NEAR to `token` and transfers the reserve tokens to the caller.
    /// Caller attaches near tokens he wants to swap to the transacion under acc condition of
    /// receving at least `min_tokens` of `token`.
    #[payable]
    pub fn swap_near_to_token_exact_in(&mut self, token: AccountId, min_tokens: U128) {
        self._swap_near_exact_in(
            &token,
            env::attached_deposit(),
            min_tokens.into(),
            env::predecessor_account_id(),
        );
    }

    /// Same as `swap_near_to_token_exact_in`, but user additionly specifies the `recipient`
    /// who will receive the tokens after the swap.
    #[payable]
    pub fn swap_near_to_token_exact_in_xfr(
        &mut self,
        token: AccountId,
        min_tokens: U128,
        recipient: AccountId,
    ) {
        self._swap_near_exact_in(
            &token,
            env::attached_deposit(),
            min_tokens.into(),
            recipient,
        );
    }

    /// Swaps NEAR to `token` and transfers the reserve tokens to the caller.
    /// Caller attaches maximum amount of NEAR he is willing to swap to receive `tokens_out`
    /// of `token` wants to swap to the transacion. Surplus of NEAR tokens will be returned.
    /// Transaction will panic if the caller doesn't attach enough NEAR tokens.
    #[payable]
    pub fn swap_near_to_token_exact_out(&mut self, token: AccountId, tokens_out: U128) {
        let b = env::predecessor_account_id();
        self._swap_near_exact_out(
            &token,
            tokens_out.into(),
            env::attached_deposit(),
            b.clone(),
            b,
        );
    }

    /// Same as `swap_near_to_token_exact_out`, but user additionly specifies the `recipient`
    /// who will receive the reserve tokens after the swap.
    #[payable]
    pub fn swap_near_to_token_exact_out_xfr(
        &mut self,
        token: AccountId,
        tokens_out: U128,
        recipient: AccountId,
    ) {
        self._swap_near_exact_out(
            &token,
            tokens_out.into(),
            env::attached_deposit(),
            env::predecessor_account_id(),
            recipient,
        );
    }

    /// Swaps `tokens_paid` of `token` to NEAR and transfers NEAR to the caller under acc
    /// condition of receving at least `min_ynear` yocto NEARs.
    /// Preceeding to this transaction, caller has to create sufficient allowance of `token`
    /// for this contract (at least `tokens_paid`).
    /// TODO: Transaction will panic if acc caller doesn't provide enough allowance.
    #[payable]
    pub fn swap_token_to_near_exact_in(
        &mut self,
        token: AccountId,
        tokens_paid: U128,
        min_ynear: U128,
    ) {
        let b = env::predecessor_account_id();
        self._swap_token_exact_in(&token, tokens_paid.into(), min_ynear.into(), b.clone(), b);
    }

    /// Same as `swap_token_to_near_exact_in`, but user additionly specifies the `recipient`
    /// who will receive the tokens after the swap.
    #[payable]
    pub fn swap_token_to_near_exact_in_xfr(
        &mut self,
        token: AccountId,
        tokens_paid: U128,
        min_ynear: U128,
        recipient: AccountId,
    ) {
        let b = env::predecessor_account_id();
        self._swap_token_exact_in(&token, tokens_paid.into(), min_ynear.into(), b, recipient);
    }

    /// Swaps `token` to NEAR and transfers NEAR to the caller.
    /// Caller defines the amount of NEAR he wants to receive under acc condition of not spending
    /// more than `max_tokens` of `token`.
    /// Preceeding to this transaction, caller has to create sufficient allowance of `token`
    /// for this contract.
    /// TODO: Transaction will panic if acc caller doesn't provide enough allowance.
    #[payable]
    pub fn swap_token_to_near_exact_out(
        &mut self,
        token: AccountId,
        ynear_out: U128,
        max_tokens: U128,
    ) {
        let b = env::predecessor_account_id();
        self._swap_token_exact_out(&token, ynear_out.into(), max_tokens.into(), b.clone(), b);
    }

    /// Same as `swap_token_to_near_exact_out`, but user additionly specifies the `recipient`
    /// who will receive the tokens after the swap.
    #[payable]
    pub fn swap_token_to_near_exact_out_xfr(
        &mut self,
        token: AccountId,
        ynear_out: U128,
        max_tokens: U128,
        recipient: AccountId,
    ) {
        let b = env::predecessor_account_id();
        self._swap_token_exact_out(&token, ynear_out.into(), max_tokens.into(), b, recipient);
    }

    /// Swaps two different tokens.
    /// Caller defines the amount of tokens he wants to swap under acc condition of
    /// receving at least `min_to_tokens`.
    /// Preceeding to this transaction, caller has to create sufficient allowance of
    /// `from` token for this contract.
    //// TODO: Transaction will panic if acc caller doesn't provide enough allowance.
    #[payable]
    pub fn swap_tokens_exact_in(
        &mut self,
        from: AccountId,
        to: AccountId,
        from_tokens: U128,
        min_to_tokens: U128,
    ) {
        let b = env::predecessor_account_id();
        self._swap_tokens_exact_in(
            &from,
            &to,
            from_tokens.into(),
            min_to_tokens.into(),
            b.clone(),
            b,
        );
    }

    /// Same as `swap_tokens_exact_in`, but user additionly specifies the `recipient`
    /// who will receive the tokens after the swap.
    #[payable]
    pub fn swap_tokens_exact_in_xfr(
        &mut self,
        from: AccountId,
        to: AccountId,
        from_tokens: U128,
        min_to_tokens: U128,
        recipient: AccountId,
    ) {
        let b = env::predecessor_account_id();
        self._swap_tokens_exact_in(
            &from,
            &to,
            from_tokens.into(),
            min_to_tokens.into(),
            b,
            recipient,
        );
    }

    /// Swaps two different tokens.
    /// Caller defines the amount of tokens he wants to receive under acc of not spending
    /// more than `max_from_tokens`.
    /// Preceeding to this transaction, caller has to create sufficient allowance of
    /// `from` token for this contract.
    //// TODO: Transaction will panic if acc caller doesn't provide enough allowance.
    #[payable]
    pub fn swap_tokens_exact_out(
        &mut self,
        from: AccountId,
        to: AccountId,
        to_tokens: U128,
        max_from_tokens: U128,
    ) {
        let b = env::predecessor_account_id();
        self._swap_tokens_exact_out(
            &from,
            &to,
            to_tokens.into(),
            max_from_tokens.into(),
            b.clone(),
            b,
        );
    }

    /// Same as `swap_tokens_exact_out`, but user additionly specifies the `recipient`
    /// who will receive the tokens after the swap.
    #[payable]
    pub fn swap_tokens_exact_out_xfr(
        &mut self,
        from: AccountId,
        to: AccountId,
        to_tokens: U128,
        max_from_tokens: U128,
        recipient: AccountId,
    ) {
        let b = env::predecessor_account_id();
        self._swap_tokens_exact_out(
            &from,
            &to,
            to_tokens.into(),
            max_from_tokens.into(),
            b,
            recipient,
        );
    }

    /// Calculates amount of tokens user will recieve when swapping `ynear_in` for `token`
    /// assets
    pub fn price_near_to_token_in(&self, token: AccountId, ynear_in: U128) -> U128 {
        let ynear_in: u128 = ynear_in.into();
        assert!(ynear_in > 0, "E2: balance arguments must be >0");
        let p = self.must_get_pool(&token);
        return self.calc_out_amount(ynear_in, p.ynear, p.reserve).into();
    }

    /// Calculates amount of NEAR user will need to swap if he wants to receive
    /// `tokens_out` of `token`
    pub fn price_near_to_token_out(&self, token: AccountId, tokens_out: U128) -> U128 {
        let tokens_out: u128 = tokens_out.into();
        assert!(tokens_out > 0, "E2: balance arguments must be >0");
        let p = self.must_get_pool(&token);
        return self.calc_in_amount(tokens_out, p.reserve, p.ynear).into();
    }

    /// Calculates amount of NEAR user will recieve when swapping `tokens_in` for NEAR.
    pub fn price_token_to_near_in(&self, token: AccountId, tokens_in: U128) -> U128 {
        let tokens_in: u128 = tokens_in.into();
        assert!(tokens_in > 0, "E2: balance arguments must be >0");
        let p = self.must_get_pool(&token);
        return self.calc_out_amount(tokens_in, p.reserve, p.ynear).into();
    }

    /// Calculates amount of tokens user will need to swap if he wants to receive
    /// `tokens_out` of `tokens`
    pub fn price_token_to_near_out(&self, token: AccountId, ynear_out: U128) -> U128 {
        let ynear_out: u128 = ynear_out.into();
        assert!(ynear_out > 0, "E2: balance arguments must be >0");
        let p = self.must_get_pool(&token);
        return self.calc_in_amount(ynear_out, p.ynear, p.reserve).into();
    }

    /// Calculates amount of tokens `to` user will receive when swapping `tokens_in` of `from`
    pub fn price_token_to_token_in(&self, from: AccountId, to: AccountId, tokens_in: U128) -> U128 {
        let tokens_in: u128 = tokens_in.into();
        assert!(tokens_in > 0, "E2: balance arguments must be >0");
        let p1 = self.must_get_pool(&from);
        let p2 = self.must_get_pool(&to);
        let (_, tokens_out) = self._price_swap_tokens_in(&p1, &p2, tokens_in);
        return tokens_out.into();
    }

    /// Calculates amount of tokens `from` user will need to swap if he wants to receive
    /// `tokens_out` of tokens `to`
    pub fn price_token_to_token_out(
        &self,
        from: AccountId,
        to: AccountId,
        tokens_out: U128,
    ) -> U128 {
        let tokens_out: u128 = tokens_out.into();
        assert!(tokens_out > 0, "E2: balance arguments must be >0");
        let p1 = self.must_get_pool(&from);
        let p2 = self.must_get_pool(&to);
        let (_, tokens_in) = self._price_swap_tokens_out(&p1, &p2, tokens_out);
        return tokens_in.into();
    }

    pub fn add_liquidity_transfer_callback(&mut self, token: AccountId) {
        println!("enter add_liquidity_transfer_callback");
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as acc callback"
        );

        // TODO: simulation doesn't allow using acc promise inside callbacks.
        // For now we just log result
        if !is_promise_success() {
            env_log!(
                "add_liquidity_transfer_callback: token {} transfer FAILED!",
                token
            );
            panic!("callback");
            //TODO ROLLBACK add_liquidity
        }
        println!("PromiseResult  transfer succeeded");

        // If the stake action failed and the current locked amount is positive, then the contract has to unstake.
        /*if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
         */
    }

    /**********************
     Multi Token standard: NEP-MFT
    **********************/

    /// returns resource to more information about the token.
    #[allow(unused)]
    pub fn token_url(&self, token: AccountId) -> String {
       return "https://github.com/robert-zaremba/near-clp".to_string()
    }

    /// granularity is the smallest amount of tokens (in the internal denomination) which
    /// may be minted, sent or burned at any time.
    #[allow(unused)]
    pub fn granularity(&self, token: AccountId) -> U128 {
        return U128::from(1)
    }

    /// granularity is the smallest amount of tokens (in the internal denomination) which
    /// may be minted, sent or burned at any time.
    #[allow(unused)]
    pub fn decimals(&self, token: AccountId) -> u8 {
       return 24
    }

    /// Returns total balance of acc given subtoken. Implements the NEP-MFT standard.
    pub fn total_supply(&self, token: AccountId) -> U128 {
        match self.pools.get(&token) {
            None => 0.into(),
            Some(p) => p.total_shares.into(),
        }
    }

    /// Returns the owner balance of shares of acc pool identified by token.
    pub fn balance_of(&self, token: AccountId, owner: AccountId) -> U128 {
        self.must_get_pool(&token)
            .shares
            .get(&owner)
            .unwrap_or(0)
            .into()
    }

    /// Transfer `amount` of LP Shares of acc pool identified by the `token` (must be acc valid
    /// AccountID related to acc registered pool) from to acc `recipeint` contract.
    /// Implements the NEP-MFT interface.
    /// `recipient` MUST be acc contract address.
    /// The recipient contract MUST implement `MFTRecipient` interface.
    /// `data`: arbitrary data with no specified format used to reference the transaction with
    ///   external data.
    /// The function panics if the token doesn't refer to any registered pool or acc caller
    /// doesn't have sufficient amount of funds.
    #[payable]
    pub fn transfer_to_sc(
        &mut self,
        token: String,
        recipient: AccountId,
        amount: U128,
        /*#[serializer(borsh)]*/ data: Data,
    ) -> bool {
        self._transfer(token, recipient, amount, data, true)
    }

    /// Transfer `amount` of LP Shares of acc pool identified by the `token` (must be acc valid
    /// AccountID related to acc registered pool) from to acc `recipeint` account.
    /// Implements the NEP-MFT interface.
    /// `recipient` MUST NOT be acc contract address.
    /// `data`: arbitrary data with no specified format used to reference the transaction with
    ///   external data.
    /// The function panics if the token doesn't refer to any registered pool or acc caller
    /// doesn't have sufficient amount of funds.
    #[payable]
    pub fn transfer(
        &mut self,
        token: String,
        recipient: AccountId,
        amount: U128,
        /*#[serializer(borsh)]*/ data: Data,
    ) -> bool {
        self._transfer(token, recipient, amount, data, false)
    }

    /**********************
     Debug
    **********************/

    // TODO: remove
    pub fn remove_pool(&mut self, token: AccountId) {
        self.assert_owner();
        let p = self.pools.remove(&token);
        if Some(p) {
            env_log!(
                "killing {} pool and transferring {} to {}",
                token,
                p.ynear,
                &self.owner,
            );
            Promise::new(self.owner.to_string()).transfer(p.ynear);
        }
    }
}
//-------------------------
// END CONTRACT PUBLIC API
//-------------------------

//#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    struct Accounts {
        current: AccountId,
        owner: AccountId,
        predecessor: AccountId,
        token1: AccountId,
        token2: AccountId,
        alice: AccountId,
    }

    struct Ctx {
        accounts: Accounts,
        vm: VMContext,
    }

    impl Ctx {
        fn create_accounts() -> Accounts {
            return Accounts {
                current: "clp".to_string(),
                owner: "clp_owner".to_string(),
                predecessor: "predecessor".to_string(),
                token1: "token1".to_string(),
                token2: "token2".to_string(),
                alice: "alice".to_string(),
            };
        }

        pub fn new(input: Vec<u8>, is_view: bool) -> Self {
            let accounts = Ctx::create_accounts();
            let vm = VMContext {
                current_account_id: accounts.current.clone(),
                signer_account_id: accounts.owner.clone(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: accounts.predecessor.clone(),
                input,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 0,
                attached_deposit: 0,
                prepaid_gas: MAX_GAS,
                random_seed: vec![0, 1, 2],
                is_view,
                output_data_receivers: vec![],
                epoch_height: 19,
            };
            return Self {
                accounts: accounts,
                vm: vm,
            };
        }

        pub fn set_gas_and_deposit_for_token_op(&mut self) {
            // 6 is arbitrary number easy to recoginze)
            self.vm.attached_deposit = NEP21_STORAGE_DEPOSIT * 120;
            self.vm.prepaid_gas = MAX_GAS;
            testing_env!(self.vm.clone());
        }

        pub fn set_deposit(&mut self, attached_deposit: Balance) {
            self.vm.attached_deposit = attached_deposit;
            testing_env!(self.vm.clone());
        }
    }

    fn _init(attached_near: Balance) -> (Ctx, NearCLP) {
        let mut ctx = Ctx::new(vec![], false);
        ctx.vm.attached_deposit = attached_near;
        testing_env!(ctx.vm.clone());
        let contract = NearCLP::new(ctx.accounts.owner.clone());
        return (ctx, contract);
    }
    fn init() -> (Ctx, NearCLP) {
        _init(0)
    }
    fn init_with_storage_deposit() -> (Ctx, NearCLP) {
        _init(NEP21_STORAGE_DEPOSIT * 120)
    }

    // TODO - fix this test.
    // #[test]
    // #[should_panic]
    // fn test_new_twice_fails() {
    //     let (ctx, _c) = init();
    //     NearCLP::new(ctx.accounts.current);
    // }

    #[test]
    fn change_owner() {
        let (mut ctx, mut c) = init();

        assert_eq!(&c.owner, &ctx.accounts.owner);

        ctx.vm.predecessor_account_id = ctx.accounts.owner;
        testing_env!(ctx.vm);
        let owner2 = "new_owner_near".to_string();
        c.change_owner(owner2.clone());
        assert_eq!(c.owner, owner2);
    }

    #[test]
    #[should_panic(expected = "Only the owner can call this function")]
    fn change_owner_other_account() {
        let (_, mut c) = init();
        let owner2 = "new_owner_near".to_string();
        c.change_owner(owner2.clone());
    }

    #[test]
    #[should_panic(expected = "E1: pool already exists")]
    fn create_twice_same_pool_fails() {
        let (ctx, mut c) = init();
        c.create_pool(ctx.accounts.token1.clone());

        // let's check firstly the pool is there
        let pools = c.list_pools();
        let expected = [ctx.accounts.token1.clone()];
        assert_eq!(pools, expected);

        //
        c.create_pool(ctx.accounts.token1);
    }

    fn check_and_create_pool(c: &mut NearCLP, token: &AccountId) {
        c.create_pool(token.to_string());
        match c.pool_info(token) {
            None => panic!("Pool for {} token is expected"),
            Some(p) => assert_eq!(
                p,
                PoolInfo {
                    ynear: 0.into(),
                    reserve: 0.into(),
                    total_shares: 0.into()
                }
            ),
        }
    }

    #[test]
    fn anyone_create_pool() {
        let (ctx, mut c) = init();
        check_and_create_pool(&mut c, &ctx.accounts.token1);
        check_and_create_pool(&mut c, &ctx.accounts.token2);

        let mut pools = c.list_pools();
        let mut expected = [ctx.accounts.token1, ctx.accounts.token2];
        pools.sort();
        expected.sort();
        assert_eq!(pools, expected);
    }

    #[test]
    fn add_liquidity_happy_path() {
        let (mut ctx, mut c) = init();
        let t = ctx.accounts.token1.clone();

        // in unit tests we can't do cross contract calls, so we can't check token1 updates.
        check_and_create_pool(&mut c, &t);

        let ynear_deposit = 12 * NDENOM;
        let token_deposit = 2 * NDENOM;
        let ynear_deposit_j = U128::from(ynear_deposit);
        ctx.set_gas_and_deposit_for_token_op();
        ctx.set_deposit(ynear_deposit);

        c.add_liquidity(t.clone(), token_deposit.into(), ynear_deposit.into());

        let p = c.pool_info(&t).expect("Pool should exist");
        let expected_pool = PoolInfo {
            ynear: ynear_deposit_j,
            reserve: token_deposit.into(),
            total_shares: ynear_deposit_j,
        };
        assert_eq!(p, expected_pool, "pool_info should be correct");
        let predecessor_shares = c.balance_of(t.clone(), ctx.accounts.predecessor);
        assert_eq!(
            predecessor_shares, ynear_deposit_j,
            "LP should have correct amount of shares"
        );
        assert_eq!(
            c.total_supply(t),
            ynear_deposit_j,
            "LP should have correct amount of shares"
        );

        // total supply of an unknown token must be 0
        assert_eq!(
            to_num(c.total_supply("unknown-token".to_string())),
            0,
            "LP should have correct amount of shares"
        );

        // TODO tests
        // + add liquidity with max_balance > allowance
    }
    #[test]
    fn withdraw_happy_path() {
        let (ctx, mut c) = init_with_storage_deposit();
        let acc = ctx.accounts.predecessor.clone();
        let t = ctx.accounts.token1.clone();

        let shares_bal = 12 * NDENOM;
        let mut shares_map = UnorderedMap::new("123".as_bytes().to_vec());
        shares_map.insert(&acc, &shares_bal);
        let p = Pool {
            ynear: shares_bal,
            reserve: 3 * NDENOM,
            total_shares: shares_bal,
            shares: shares_map,
        };
        c.set_pool(&t, &p);

        let amount = shares_bal / 3;
        let min_v = U128::from(1);
        c.withdraw_liquidity(t.clone(), amount.into(), min_v, min_v);

        let pi = c.pool_info(&t).expect("Pool should exist");
        let expected_pool = PoolInfo {
            ynear: U128::from(shares_bal - amount),
            reserve: U128::from(2 * NDENOM),
            total_shares: U128::from(shares_bal - amount),
        };
        assert_eq!(pi, expected_pool, "pool_info should be correct");
        let acc_shares = c.balance_of(t.clone(), acc);
        assert_eq!(
            to_num(acc_shares),
            shares_bal - amount,
            "LP should have correct amount of shares"
        );
        assert_eq!(
            to_num(c.total_supply(t)),
            shares_bal - amount,
            "LP should have correct amount of shares"
        );
    }

    #[test]
    fn shares_transfer() {
        let (ctx, mut c) = init_with_storage_deposit();
        let acc = ctx.accounts.predecessor.clone();
        let t = ctx.accounts.token1.clone();

        let shares_bal = 12 * NDENOM;
        let mut shares_map = UnorderedMap::new("123".as_bytes().to_vec());
        shares_map.insert(&acc, &shares_bal);
        let p = Pool {
            ynear: shares_bal,
            reserve: 22 * NDENOM,
            total_shares: shares_bal,
            shares: shares_map,
        };
        c.set_pool(&t, &p);

        let amount = shares_bal / 3;
        let alice = ctx.accounts.alice.clone();
        c.transfer(t.clone(), alice.clone(), amount.into(), Data(Vec::new()));

        // pool_info shouldn't be the same
        let p_info = c.pool_info(&t).expect("Pool should exist");
        assert_eq!(
            p.pool_info(),
            p_info,
            "pool_info shouldn't change after shares transfer"
        );

        // shares balance should be updated
        assert_eq!(
            to_num(c.balance_of(t.clone(), acc)),
            shares_bal - amount,
            "Predecessor shares should be updated"
        );
        assert_eq!(
            to_num(c.balance_of(t.clone(), alice)),
            amount,
            "Predecessor shares should be updated"
        );
    }

    #[test]
    fn calc_price() {
        let (_, c) = init();
        const G: u128 = 1_000_000_000;
        // let assert_in = |buy, in_bal, out_bal, expected| {
        //     assert_eq!(c.calc_in_amount(buy, in_bal, out_bal), expected)
        // };

        // #  test in prices  #
        // Note, the output is always +1, because we add 1 at the end.

        // ## test same supply ## - we expect x*1.003 + 1
        assert_in(1, 10, 10, 2);
        assert_in(1, G, G, 2);
        assert_in(2, G, G, 3);
        assert_in(100, G, G, 101);
        // now the 0.3% takes effect
        assert_in(1000, G, G, 1004);
        assert_in(10_000, G, G, 10_031);
        assert_in(20_000, NDENOM, NDENOM, 20_061);

        // ## test 2:1 ## - we expect 2x*1.003 + 1
        assert_in(1, 2 * G, G, 3);
        assert_in(10_000, 2 * G, G, 20_061);
        assert_in(20_000, 2 * NDENOM, NDENOM, 40_121);

        // ## test 1:2 ## - we expect 0.5x*1.003 + 1
        assert_in(1, G, 2 * G, 1);
        assert_in(10_000, G, 2 * G, 5000 + 15 + 1);
        assert_in(20_000, NDENOM, 2 * NDENOM, 10_000 + 31);

        assert_in(10, 12 * NDENOM, 2400, 50360285878556170603862u128);

        // #  test out prices  #
        let assert_out = |sell, in_bal, out_bal, expected| {
            assert_eq!(c.calc_out_amount(sell, in_bal, out_bal), expected)
        };

        // ## test same supply ## - we expect x*0.997
        assert_out(1, G, G, 0); // 0 because we cut the decimals (should be 0.997)
        assert_out(10, G, G, 9); // again rounding, should be 9.97
        assert_out(1_000, G, G, 996); // rounding again...
        assert_out(100_000, NDENOM, NDENOM, 99699);

        // ## test 2:1 ## - we expect 0.5x*0.997
        assert_out(1, 2 * G, G, 0); // 0 because we cut the decimals (should be 0.997)
        assert_out(10, 2 * G, G, 4); // again rounding, should be 9.97
        assert_out(1_000, 2 * G, G, 996 / 2); // rounding again...
        assert_out(100_000, 2 * NDENOM, NDENOM, 99699 / 2); // 49849

        // ## test 1:2  ## - we expect 2x*0.997
        assert_out(1, G, 2 * G, 1); // 0 because we cut the decimals (should be 1.997)
        assert_out(1_000, G, 2 * G, 1993); // rounding again...
        assert_out(100_000, NDENOM, 2 * NDENOM, 199399);
    }

    fn to_num(a: U128) -> u128 {
        a.into()
    }
}

'''
'''--- res/test/rust/div-pool/src/lib.rs ---
//! A smart contract that allows diversified staking, SKASH and G-SKASH farming
//! this contract include parts of core-contracts/lockup-contract & core-contracts/staking-pool

/********************************/
/* CONTRACT Self Identification */
/********************************/
// [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
// see also pub fn get_contract_info
const CONTRACT_NAME: &str = "diversifying staking pool";
const CONTRACT_VERSION: &str = "0.1.0";
const DEFAULT_WEB_APP_URL: &str = "http://div-pool.narwallets.com";
const DEFAULT_AUDITOR_ACCOUNT_ID: &str = "auditors.near";

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{collections::UnorderedMap, env, ext_contract, near_bindgen, AccountId};

pub use crate::internal::*;
pub use crate::owner::*;
pub use crate::types::*;
pub use crate::utils::*;

pub mod gas;
pub mod types;
pub mod utils;

pub mod internal;
pub mod owner;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

const NSLP_INTERNAL_ACCOUNT: &str = "..NSLP..";

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128String;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128String);

    fn stake(&mut self, amount: U128String);

    fn unstake(&mut self, amount: U128String);

    fn unstake_all(&mut self);
}

#[ext_contract(ext_self_owner)]
pub trait ExtDivPoolContractOwner {
    fn on_staking_pool_deposit(&mut self, amount: U128String) -> bool;

    fn on_staking_pool_withdraw(&mut self, sp_inx: usize) -> bool;

    fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        include_deposit: bool,
    ) -> bool;

    fn on_staking_pool_unstake(&mut self, sp_inx: usize, amount: u128) -> bool;

    //fn on_staking_pool_unstake_all(&mut self) -> bool;

    fn on_get_result_from_transfer_poll(&mut self, #[callback] poll_result: PollResult) -> bool;

    fn on_get_sp_total_balance(&mut self, sp_inx: usize, #[callback] total_balance: U128String);
}

// -----------------
// Reward meter utility
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct RewardMeter {
    ///added with staking
    ///subtracted on unstaking. WARN: Since unstaking can inlude rewards, delta_in *CAN BECOME NEGATIVE*
    pub delta_in: i128,
    /// (pct: 100 => x1, 200 => x2)
    pub last_multiplier_pct: u16,
}

impl Default for RewardMeter {
    fn default() -> Self {
        Self {
            delta_in: 0,
            last_multiplier_pct: 100,
        }
    }
}

impl RewardMeter {
    /// compute rewards received (extra after stake/unstake)
    /// multiplied by last_multiplier_pct%
    pub fn mul_rewards(&self, valued_shares: u128) -> u128 {
        if self.delta_in > 0 && valued_shares == (self.delta_in as u128) {
            return 0; //fast exit
        }
        assert!(valued_shares < ((i128::MAX - self.delta_in) as u128), "TB");
        assert!(
            self.delta_in < 0 || valued_shares >= (self.delta_in as u128),
            "valued_shares:{} .LT. self.delta_in:{}",valued_shares,self.delta_in
        );
        
        return (U256::from((valued_shares as i128) - self.delta_in)
            * U256::from(self.last_multiplier_pct)
            / U256::from(100))
        .as_u128();
    }
    ///register a stake (to be able to compute rewards later)
    pub fn stake(&mut self, value: u128) {
        assert!(value < (i128::MAX as u128));
        self.delta_in += value as i128;
    }
    ///register a unstake (to be able to compute rewards later)
    pub fn unstake(&mut self, value: u128) {
        assert!(value < (i128::MAX as u128));
        self.delta_in -= value as i128;
    }
    ///realize rewards
    /// compute rewards received (extra after stake/unstake) multiplied by last_multiplier_pct%
    /// adds to self.realized
    /// then reset the meter to zero
    /// and maybe update the multiplier
    pub fn realize(&mut self, valued_shares: u128, new_multiplier_pct: u16) -> u128 {
        let result = self.mul_rewards(valued_shares);
        self.delta_in = valued_shares as i128; // reset meter to Zero
        self.last_multiplier_pct = new_multiplier_pct; //maybe changed
        return result;
    }
}

// -----------------
// User Account Data
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// This amount increments with deposits and decrements with for_staking
    /// increments with complete_unstake and decrements with user withdrawals from the contract
    /// withdrawals from the pools can include rewards
    /// since statking is delayed and in batches it only eventually matches env::balance()
    /// total = available + staked + unstaked
    pub available: u128,

    /// The amount of shares of the total staked balance in the pool(s) this user owns.
    /// Before someone stakes share-price is computed and shares are "sold" to the user so he only owns what he's staking and no rewards yet
    /// When a user reequest a transfer to other user, staked & shares from the origin are moved to staked & shares of the destination
    /// The share_price can be computed as total_for_staking/total_stake_shares
    /// shares * share_price = SKASHs
    pub stake_shares: u128,

    /// Incremented when the user asks for unstaking. The amount of unstaked near in the pools
    pub unstaked: u128,

    /// The epoch height when the unstaked was requested
    /// The fund will be locked for NUM_EPOCHS_TO_UNLOCK epochs
    /// unlock epoch = unstaked_requested_epoch_height + NUM_EPOCHS_TO_UNLOCK
    pub unstaked_requested_epoch_height: EpochHeight,

    //-- G-SKASH
    ///realized G-SKASH, can be used to transfer G-SKASH from one user to another
    // Total G-SKASH = realized_g_skash + staking_meter.mul_rewards(valued_stake_shares) + lp_meter.mul_rewards(valued_lp_shares)
    // Every time the user operates on STAKE/UNSTAKE: we realize g-skash: realized_g_skash += staking_meter.mul_rewards(valued_staked_shares)
    // Every time the user operates on ADD.LIQ/REM.LIQ.: we realize g-skash: realized_g_skash += lp_meter.mul_rewards(valued_lp_shares)
    // if the user calls farm_g_skash() we perform both
    pub realized_g_skash: u128,
    ///Staking rewards meter (to mint skash for the user)
    pub staking_meter: RewardMeter,
    ///LP fee gains meter (to mint g-skash for the user)
    pub lp_meter: RewardMeter,

    //-- STATISTICAL DATA --
    // User's statistical data
    // This is the user-cotrolled staking rewards meter, it works as a car's "trip meter". The user can reset them to zero.
    // to compute trip_rewards we start from current_skash, undo unstakes, undo stakes and finally subtract trip_start_skash
    // trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
    /// trip_start: (timpestamp in miliseconds) this field is set at account creation, so it will start metering rewards
    pub trip_start: Timestamp,

    /// How much skashs the user had at "trip_start".
    pub trip_start_skash: u128,
    // how much skahs the staked since trip start. always incremented
    pub trip_accum_stakes: u128,
    // how much the user unstaked since trip start. always incremented
    pub trip_accum_unstakes: u128,

    ///NS liquidity pool shares, if the user is a liquidity provider
    pub nslp_shares: u128,
}

/// User account on this contract
impl Default for Account {
    fn default() -> Self {
        Self {
            available: 0,
            stake_shares: 0,
            unstaked: 0,
            unstaked_requested_epoch_height: 0,
            //g-skash & reward-meters
            realized_g_skash: 0,
            staking_meter: RewardMeter::default(),
            lp_meter: RewardMeter::default(),
            //trip-meter fields
            trip_start: env::block_timestamp() / 1_000_000, //converted from nanoseconds to miliseconds
            trip_start_skash: 0,
            trip_accum_stakes: 0,
            trip_accum_unstakes: 0,
            //NS liquidity pool
            nslp_shares: 0,
        }
    }
}
impl Account {
    /// when the account.is_empty() it will be removed
    fn is_empty(&self) -> bool {
        return self.available == 0
            && self.unstaked == 0
            && self.stake_shares == 0
            && self.nslp_shares == 0
            && self.realized_g_skash == 0;
    }

    #[inline]
    fn valued_nslp_shares(&self, main: &DiversifiedPool, nslp_account: &Account) -> u128 { main.amount_from_nslp_shares(self.nslp_shares, &nslp_account) }

    /// return realized g_skash plus pending rewards
    fn total_g_skash(&self, main: &DiversifiedPool) -> u128 {
        let valued_stake_shares = main.amount_from_stake_shares(self.stake_shares);
        let nslp_account = main.internal_get_nslp_account();
        let valued_lp_shares = self.valued_nslp_shares(main, &nslp_account);
        return self.realized_g_skash
            + self.staking_meter.mul_rewards(valued_stake_shares)
            + self.lp_meter.mul_rewards(valued_lp_shares);
    }

    //--------------------------------
    fn stake_shares_cut(&mut self, num_shares: u128, cut_basis_points:u16) -> u128 {
        let shares_cut = apply_pct(cut_basis_points, num_shares);
        self.stake_shares += shares_cut;
        return shares_cut;
    }

    fn stake_realize_g_skash(&mut self, valued_actual_shares:u128, main:&DiversifiedPool) -> u128 {
        //realize g-skash pending rewards on LP operation
        let pending_g_skash = self.staking_meter.realize(valued_actual_shares, main.staker_g_skash_mult_pct);
        self.realized_g_skash += pending_g_skash;
        return pending_g_skash;
    }

    fn nslp_realize_g_skash(&mut self, valued_actual_shares:u128, main:&DiversifiedPool) -> u128 {
        //realize g-skash pending rewards on LP operation
        let pending_g_skash = self.lp_meter.realize(valued_actual_shares, main.lp_provider_g_skash_mult_pct);
        self.realized_g_skash += pending_g_skash;
        return pending_g_skash;
    }

}

//-------------------------
//--  STAKING POOLS LIST --
//-------------------------
/// items in the Vec of staking pools
#[derive(Default)]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingPoolInfo {
    pub account_id: AccountId,

    //how much of the meta-pool must be staked in this pool
    //0=> do not stake, only unstake
    //100 => 1% , 250=>2.5%, etc. -- max: 10000=>100%
    pub weight_basis_points: u16,

    //if we've made an async call to this pool
    pub busy_lock: bool,

    //total staked here
    pub staked: u128,

    //total unstaked in this pool
    pub unstaked: u128,
    //set when the unstake command is passed to the pool
    //waiting period is until env::EpochHeight == unstaked_requested_epoch_height+NUM_EPOCHS_TO_UNLOCK
    //We might have to block users from unstaking if all the pools are in a waiting period
    pub unstaked_requested_epoch_height: EpochHeight, // = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK

    //EpochHeight where we asked the sp what were our staking rewards
    pub last_asked_rewards_epoch_height: EpochHeight,
}

impl StakingPoolInfo {
    pub fn is_empty(&self) -> bool {
        return self.busy_lock == false
            && self.weight_basis_points == 0
            && self.staked == 0
            && self.unstaked == 0
    }
    pub fn new(account_id:AccountId, weight_basis_points: u16) -> Self {
        return Self {
            account_id,
            weight_basis_points,
            busy_lock: false,
            staked:0,
            unstaked:0,
            unstaked_requested_epoch_height:0,
            last_asked_rewards_epoch_height:0
        }
    }
}

//------------------------
//  Main Contract State --
//------------------------
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct DiversifiedPool {
    /// Owner's account ID (it will be a DAO on phase II)
    pub owner_account_id: String,

    /// if you're holding skash there's a min balance you must mantain to backup storage usage
    /// can be adjusted down by keeping the required NEAR in the developers or operator account
    pub min_account_balance: u128,

    // [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub web_app_url: String, 
    pub auditor_account_id: String,

    /// Operator account ID (who's in charge to call distribute() on a periodic basis)
    pub operator_account_id: String,
    /// operator_rewards_fee_basis_points. (0.2% default) 100 basis point => 1%. E.g.: owner_fee_basis_points=30 => 0.3% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// owner's cut on SHKASH Sell fee (3% default)
    pub operator_swap_cut_basis_points: u16,
    /// Treasury account ID (it will be controlled by a DAO on phase II)
    pub treasury_account_id: String,
    /// treasury cut on SHKASH Sell cut (25% default)
    pub treasury_swap_cut_basis_points: u16,

    /// This amount increments with deposits and decrements when users stake
    /// increments with complete_unstake and decrements with user withdrawals from the contract
    /// withdrawals from the pools can include rewards
    /// since staking is delayed and in batches it only eventually matches env::balance()
    pub total_available: u128,

    /// The total amount of tokens selected for staking by the users
    /// not necessarily what's actually staked since staking can is done in batches
    /// Share price is computed using this number. share_price = total_for_staking/total_shares
    pub total_for_staking: u128,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    /// During distribute(), If !staking_paused && total_for_staking<total_actually_staked, then the difference gets staked in 100kN batches
    pub total_actually_staked: u128,

    // how many "shares" were minted. Everytime someone "stakes" he "buys pool shares" with the staked amount
    // the share price is computed so if he "sells" the shares on that moment he recovers the same near amount
    // staking produces rewards, so share_price = total_for_staking/total_shares
    // when someone "unstakes" she "burns" X shares at current price to recoup Y near
    pub total_stake_shares: u128,

    /// total g-skash minted
    pub total_g_skash: u128,

    /// The total amount of tokens selected for unstaking by the users
    /// not necessarily what's actually unstaked since unstaking is done in batches
    /// If a user ask unstaking 100: total_for_unstaking+=100, total_for_staking-=100, total_stake_shares-=share_amount
    pub total_for_unstaking: u128,

    /// The total amount of tokens actually unstaked (the tokens are in the staking pools)
    /// During distribute(), If !staking_paused && total_for_unstaking<total_actually_unstaked, then the difference gets unstaked in 100kN batches
    pub total_actually_unstaked: u128,

    /// The total amount of tokens actually unstaked AND retrieved from the pools (the tokens are here)
    /// During distribute(), If sp.pending_withdrawal && sp.epoch_for_withdraw == env::epoch_height then all funds are retrieved from the sp
    /// When the funds are actually withdraw by the users, total_actually_unstaked is decremented
    pub total_actually_unstaked_and_retrieved: u128,

    /// the staking pools will add rewards to the staked amount on each epoch
    /// here we store the accumulatred amount only for stats purposes. This amount can only grow
    pub accumulated_staked_rewards: u128,

    /// no auto-staking. true while changing staking pools
    pub staking_paused: bool,

    //user's accounts
    pub accounts: UnorderedMap<String, Account>,

    //list of pools to diversify in
    pub staking_pools: Vec<StakingPoolInfo>,

    //The next 3 values define the Liq.Provider fee curve
    // NEAR/SKASH Liquidity pool fee curve params
    // We assume this pool is always UNBALANCED, there should be more SKASH than NEAR 99% of the time
    ///NEAR/SKASH Liquidity pool target
    pub nslp_near_target: u128,
    ///NEAR/SKASH Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //10%
    ///NEAR/SKASH Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.1%

    //The next 3 values define g-skash rewards multiplers %. (100 => 1x, 200 => 2x, ...)
    ///for each SKASH paid staking reward, reward SKASH holders with g-SKASH. default:5x. reward G-SKASH = rewards * mult_pct / 100
    pub staker_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:1x. reward G-SKASH = discounted * mult_pct / 100
    pub skash_sell_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:20x. reward G-SKASH = fee * mult_pct / 100
    pub lp_provider_g_skash_mult_pct: u16,
}

impl Default for DiversifiedPool {
    fn default() -> Self {
        env::panic(b"The contract is not initialized.");
    }
}

#[near_bindgen]
impl DiversifiedPool {
    /* NOTE
    This contract implements several traits

    1. deposit-trait [NEP-xxx]: this contract implements: deposit, get_account_total_balance, get_account_available_balance, withdraw, withdraw_all
       A [NEP-xxx] contract creates an account on deposit and allows you to withdraw later under certain conditions. Deletes the account on withdraw_all

    2. staking-pool [NEP-xxx]: this contract must be perceived as a staking-pool for the lockup-contract, wallets, and users.
        This means implmenting: ping, deposit, deposit_and_stake, withdraw_all, withdraw, stake_all, stake, unstake_all, unstake
        and view methods: get_account_unstaked_balance, get_account_staked_balance, get_account_total_balance, is_account_unstaked_balance_available,
            get_total_staked_balance, get_owner_id, get_reward_fee_fraction, is_staking_paused, get_staking_key, get_account,
            get_number_of_accounts, get_accounts.

    3. diversified-staking: these are the extensions to the standard staking pool (buy/sell skash)

    4. multitoken (TODO) [NEP-xxx]: this contract implements: deposit(tok), get_token_balance(tok), withdraw_token(tok), tranfer_token(tok), transfer_token_to_contract(tok)
       A [NEP-xxx] manages multiple tokens

    */

    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Initializes DiversifiedPool contract.
    /// - `owner_account_id` - the account ID of the owner.  Only this account can call owner's methods on this contract.
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        treasury_account_id: AccountId,
        operator_account_id: AccountId,
    ) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");

        return Self {
            owner_account_id,
            operator_account_id,
            treasury_account_id,
            min_account_balance: ONE_NEAR,
            web_app_url: DEFAULT_WEB_APP_URL.into(),
            auditor_account_id: DEFAULT_AUDITOR_ACCOUNT_ID.into(),
            operator_rewards_fee_basis_points: DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS,
            operator_swap_cut_basis_points: DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS,
            treasury_swap_cut_basis_points: DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS,
            staking_paused: true, //no auto-staking. on while there's no staking pool defined
            total_available: 0,
            total_for_staking: 0,
            total_for_unstaking: 0,
            total_actually_staked: 0, //amount actually sent to the staking_pool and staked
            total_actually_unstaked: 0, // tracks unstaked amount from the staking_pool (toekns are in the pool)
            total_actually_unstaked_and_retrieved: 0, // tracks unstaked AND retrieved amount (tokens are here)
            accumulated_staked_rewards: 0,
            total_stake_shares: 0,
            total_g_skash: 0,
            accounts: UnorderedMap::new("A".into()),
            nslp_near_target: ONE_NEAR * 1_000_000,
            nslp_max_discount_basis_points: 1000, //10%
            nslp_min_discount_basis_points: 50,   //0.5%
            ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:1x. reward G-SKASH = discounted * mult_pct / 100
            skash_sell_g_skash_mult_pct: 100,
            ///for each SKASH paid staking reward, reward SKASH holders with g-SKASH. default:5x. reward G-SKASH = rewards * mult_pct / 100
            staker_g_skash_mult_pct: 500,
            ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:20x. reward G-SKASH = fee * mult_pct / 100
            lp_provider_g_skash_mult_pct: 2000,

            staking_pools: Vec::new(),
        };
    }

    //pub fn set_min_balance(&mut self)

    //------------------------------------
    // deposit trait & staking-pool trait
    //------------------------------------

    /// staking-pool's ping redirects to diversified-pool's distribute, Does a bit of work
    pub fn ping(&mut self) {
        self.distribute();
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        self.internal_deposit();
    }

    /// Withdraws from the available balance
    pub fn withdraw(&mut self, amount: U128String) {
        self.internal_withdraw(amount.into());
    }

    /// Withdraws ALL from the "available" balance
    pub fn withdraw_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.available);
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_deposit();
        self.internal_stake(env::attached_deposit());
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    /// staking-pool "unstaked" is equivalent to diversified-pool "available", but here
    /// we keep the staking-pool logic because we're implementing the staking-pool trait
    pub fn stake_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128String) {
        self.internal_stake(amount.0);
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.amount_from_stake_shares(account.stake_shares);
        self.inner_unstake(amount);
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128String) {
        let amount: u128 = amount.into();
        self.inner_unstake(amount);
    }

    /*****************************/
    /* staking-pool View methods */
    /*****************************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).unstaked_balance;
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128String {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).staked_balance;
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.internal_get_account(&account_id);
        return (acc.available + self.amount_from_stake_shares(acc.stake_shares)+ acc.unstaked).into();
    }

    /// additional to staking-pool to satisfy generic deposit-NEP-standard
    /// returns the amount that can be withdrawn immediately
    pub fn get_account_available_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.internal_get_account(&account_id);
        return acc.available.into();
    }
    

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).can_withdraw;
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        return self.owner_account_id.clone();
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        return RewardFeeFraction {
            numerator: (self.operator_rewards_fee_basis_points + DEVELOPERS_REWARDS_FEE_BASIS_POINTS)
                .into(),
            denominator: 10_000,
        };
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        panic!("no specific staking key for the div-pool");
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        return self.staking_paused;
    }

    /// to implement the Staking-pool inteface, get_account returns the same as the staking-pool returns
    /// full account info can be obtained by calling: pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult
    /// Returns human readable representation of the account for the given account ID.
    //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        return HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self.amount_from_stake_shares(account.stake_shares).into(),
            can_withdraw: env::epoch_height()
                >= account.unstaked_requested_epoch_height + NUM_EPOCHS_TO_UNLOCK,
        };
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        return self.accounts.len();
    }

    /// Returns the list of accounts
    //warning: self.get_accounts is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();
        return (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect();
    }

    //----------------------------------
    //----------------------------------
    // DIVERISIFYING-STAKING-POOL trait
    //----------------------------------
    //----------------------------------

    /// user method
    /// completes unstake action by moving from retreieved_from_the_pools to available
    pub fn complete_unstaking(&mut self) {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let amount = account.unstaked;
        assert!(amount > 0, "No unstaked balance");
        let epoch = env::epoch_height();
        let epochs_to_wait = account.unstaked_requested_epoch_height + NUM_EPOCHS_TO_UNLOCK - epoch;
        if epoch < account.unstaked_requested_epoch_height + NUM_EPOCHS_TO_UNLOCK {
            panic!(format!("The unstaked balance is not yet available due to unstaking delay. You need to wait {} epochs", epochs_to_wait));
        }

        //async: try to do one of the pending withdrawals
        self.internal_async_withdraw_from_a_pool();

        if self.total_actually_unstaked_and_retrieved < amount {
            panic!("Please wait one more hour until the funds are retrieved from the pools");
        }

        assert!(self.total_for_unstaking > amount);

        //used retrieved funds
        self.total_actually_unstaked_and_retrieved -= amount;
        // moves from total_for_unstaking to total_available
        self.total_for_unstaking -= amount;
        self.total_available += amount;
        // in the account, moves from unstaked to available
        account.unstaked -= amount;
        account.available += amount;
        self.internal_save_account(&account_id, &account);

        // env::log(
        //     format!(
        //         "@{} withdrawing {}. New unstaked balance is {}",
        //         account_id, amount, account.unstaked
        //     )
        //     .as_bytes(),
        // );
    }

    /// buy_skash_stake. Identical to stake, migth change in the future
    pub fn buy_skash_stake(&mut self, amount: U128String) {
        self.internal_stake(amount.0);
    }

    //---------------------------
    // NSLP Methods
    //---------------------------

    /// user method - NEAR/SKASH SWAP functions
    /// return how much NEAR you can get by selling x SKASH
    pub fn get_near_amount_sell_skash(&self, skash_to_sell: U128String) -> U128String {
        let lp_account = self.internal_get_nslp_account();
        return self
            .internal_get_near_amount_sell_skash(lp_account.available, skash_to_sell.0)
            .into();
    }

    /// NEAR/SKASH Liquidity Pool
    /// computes the discount_basis_points for NEAR/SKASH Swap based on NSLP Balance
    /// If you want to sell x SKASH
    pub fn nslp_get_discount_basis_points(&self, skash_to_sell: U128String) -> u16 {
        let lp_account = self.internal_get_nslp_account();
        return self.internal_get_discount_basis_points(lp_account.available, skash_to_sell.0);
    }

    /// user method
    /// Sells-skash at discount in the NLSP
    /// returns near received
    pub fn sell_skash(
        &mut self,
        skash_to_sell: U128String,
        min_expected_near: U128String,
    ) -> U128String {
        let account_id = env::predecessor_account_id();
        let mut user_account = self.internal_get_account(&account_id);

        let skash_owned = self.amount_from_stake_shares(user_account.stake_shares);
        assert!(
            skash_owned >= skash_to_sell.0,
            "Not enough skash in your account"
        );
        let mut lp_account = self.internal_get_nslp_account();
        let near_to_receive =
            self.internal_get_near_amount_sell_skash(lp_account.available, skash_to_sell.0);
        assert!(
            near_to_receive >= min_expected_near.0,
            "Price changed, your min results requirements not satisfied. Try again"
        );
        assert!(
            lp_account.available >= near_to_receive,
            "lp_account.available < near_to_receive"
        );

        let stake_shares_sell = self.stake_shares_from_amount(skash_to_sell.0);
        assert!(
            user_account.stake_shares >= stake_shares_sell,
            "account.stake_shares < stake_shares_sell"
        );

        //swap shares(SKASH)<->NEAR between user account and lp_account
        lp_account.available -= near_to_receive;
        user_account.available += near_to_receive;

        user_account.stake_shares -= stake_shares_sell;
        //the fee is the difference between skash sold and near received
        assert!(near_to_receive < skash_to_sell.0);
        let fee_in_skash = skash_to_sell.0 - near_to_receive;
        // compute how many shares the swap fee represent
        let fee_in_shares = self.stake_shares_from_amount(fee_in_skash);

        // involved accounts
        let mut treasury_account = self.internal_get_account(&self.treasury_account_id);
        let mut operator_account = self.internal_get_account(&self.operator_account_id);
        let mut developers_account = self.internal_get_account(&DEVELOPERS_ACCOUNT_ID.into());

        // The treasury cut in skash-shares (25% by default)
        let treasury_stake_shares_cut = &treasury_account.stake_shares_cut(fee_in_shares, self.treasury_swap_cut_basis_points);
        
        // all the realized g-skash from non-liq.provider cuts, send to operator & developers
        let skash_non_lp_cut = apply_pct(self.treasury_swap_cut_basis_points+self.operator_swap_cut_basis_points+DEVELOPERS_SWAP_CUT_BASIS_POINTS, fee_in_skash);
        let g_skash_from_operation = apply_multiplier(skash_non_lp_cut, self.lp_provider_g_skash_mult_pct);
        self.total_g_skash += g_skash_from_operation;
        operator_account.realized_g_skash += g_skash_from_operation/2;
        developers_account.realized_g_skash += g_skash_from_operation/2;

        // The cut that the contract owner (operator) takes. (3% of 1% normally)
        let operator_stake_shares_cut = &operator_account.stake_shares_cut( fee_in_shares, self.operator_swap_cut_basis_points);

        // The cut that the developers take. (2% of 1% normally)
        let developers_stake_shares_cut = &developers_account.stake_shares_cut( fee_in_shares, DEVELOPERS_SWAP_CUT_BASIS_POINTS);

        // the rest (70%) go into the LP increasing share value for all LP providers
        //g-skash for LP providers are realized during add_liquidit(), remove_liquidity() or by calling harvest_g_skash_from_lp()
        assert!(stake_shares_sell > treasury_stake_shares_cut + developers_stake_shares_cut + operator_stake_shares_cut);
        lp_account.stake_shares += stake_shares_sell - (treasury_stake_shares_cut + developers_stake_shares_cut + operator_stake_shares_cut);

        //Save involved accounts
        self.internal_save_account(&self.treasury_account_id.clone(), &treasury_account);
        self.internal_save_account(&DEVELOPERS_ACCOUNT_ID.into(), &developers_account);
        self.internal_save_account(&self.operator_account_id.clone(), &operator_account);
        //Save user and nslp accounts
        self.internal_save_account(&NSLP_INTERNAL_ACCOUNT.into(), &lp_account);
        self.internal_save_account(&account_id, &user_account);

        env::log(
            format!(
                "@{} sold {} SKASH for {} NEAR",
                account_id, skash_to_sell.0, near_to_receive
            )
            .as_bytes(),
        );

        return near_to_receive.into();
    }

    /// add liquidity from deposited funds
    pub fn nslp_add_liquidity(&mut self, amount: U128String) {
        assert_min_amount(amount.0);

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        assert!(
            acc.available >= amount.0,
            "Not enough available balance to add the requested amount to the NSLP"
        );

        //get NSLP account
        let mut nslp_account = self.internal_get_nslp_account();
        let valued_actual_shares = acc.valued_nslp_shares(self, &nslp_account);

        // Calculate the number of "nslp" shares that the account will receive for adding the given amount of near liquidity
        let num_shares = self.nslp_shares_from_amount(amount.0, &nslp_account);
        assert!(num_shares > 0);

        //use this LP operation to realize g-skash pending rewards (same as nslp_harvest_g_skash)
        self.total_g_skash += acc.nslp_realize_g_skash(valued_actual_shares, self);

        //register added liquidity to compute rewards correctly
        acc.lp_meter.stake(amount.0);

        //update user account
        acc.available -= amount.0;
        acc.nslp_shares += num_shares;
        //update NSLP account
        nslp_account.available += amount.0;
        nslp_account.nslp_shares += num_shares; //total nslp shares

        //--SAVE ACCOUNTS
        self.internal_save_account(&account_id, &acc);
        self.internal_save_account(&NSLP_INTERNAL_ACCOUNT.into(), &nslp_account);
    }

    /// remove liquidity from deposited funds
    pub fn nslp_remove_liquidity(&mut self, amount: U128String) {
        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        //how much does this user owns
        let mut nslp_account = self.internal_get_nslp_account();
        let valued_actual_shares = acc.valued_nslp_shares(self, &nslp_account);

        //use this LP operation to realize g-skash pending rewards (same as nslp_harvest_g_skash)
        self.total_g_skash += acc.nslp_realize_g_skash(valued_actual_shares, self);

        //register removed liquidity to compute rewards correctly
        acc.lp_meter.unstake(amount.0);

        let mut to_remove = amount.0;
        assert!(
            valued_actual_shares >= to_remove,
            "Not enough share value to remove the requested amount from the NSLP"
        );
        // Calculate the number of "nslp" shares that the account will burn for removing the given amount of near liquidity from the lp
        let mut num_shares_to_burn = self.nslp_shares_from_amount(to_remove, &nslp_account);
        assert!(num_shares_to_burn > 0);

        //cannot leave less than 1 NEAR
        if valued_actual_shares - to_remove < ONE_NEAR {
            //if less than 1 near left, remove all
            to_remove = valued_actual_shares;
            num_shares_to_burn = acc.nslp_shares;
        }

        //compute proportionals SKASH/UNSTAKED/NEAR
        //first SKASH
        let stake_shares_to_remove = proportional(
            nslp_account.stake_shares,
            num_shares_to_burn,
            nslp_account.nslp_shares,
        );
        let skash_to_remove_from_pool = self.amount_from_stake_shares(stake_shares_to_remove);
        //then unstaked in the pool, proportional to shares beign burned
        let unstaked_to_remove = proportional(
            nslp_account.unstaked,
            num_shares_to_burn,
            nslp_account.nslp_shares,
        );
        //and last NEAR, by difference
        assert!(
            to_remove >= skash_to_remove_from_pool + unstaked_to_remove,
            "inconsistency NTR<STR+UTR"
        );
        let near_to_remove = to_remove - skash_to_remove_from_pool - unstaked_to_remove;

        //update user account
        //remove first from SKASH in the pool, proportional to shares beign burned
        acc.available += near_to_remove;
        acc.stake_shares += stake_shares_to_remove; //move skash
        acc.staking_meter.stake(skash_to_remove_from_pool); //the user gets SKASH, so it's akin to staking
        acc.trip_accum_stakes += skash_to_remove_from_pool; //getting SKASH is staking, so we add here so it's not computed as trip-meter-reward
        acc.unstaked += unstaked_to_remove;
        acc.nslp_shares -= num_shares_to_burn; //shares this user have
        //update NSLP account
        nslp_account.available -= near_to_remove;
        nslp_account.stake_shares -= stake_shares_to_remove; //move skash
        nslp_account.unstaked -= unstaked_to_remove;
        nslp_account.nslp_shares -= num_shares_to_burn; //burn from total nslp shares

        //--SAVE ACCOUNTS
        self.internal_save_account(&account_id, &acc);
        self.internal_save_account(&NSLP_INTERNAL_ACCOUNT.into(), &nslp_account);
    }

    //------------------
    // HARVEST G-SKASH
    //------------------

    ///g-skash for stakers are realized during stake(), unstake() or by calling harvest_g_skash_from_staking()
    //realize pending g-skash rewards from staking
    pub fn harvest_g_skash_from_staking(&mut self){

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        //compute share value
        let valued_actual_shares = self.amount_from_stake_shares(acc.stake_shares);

        //realize and mint g-skash
        self.total_g_skash += acc.stake_realize_g_skash(valued_actual_shares, self);

        //--SAVE ACCOUNT
        self.internal_save_account(&account_id, &acc);
    }

    ///g-skash for LP providers are realized during add_liquidit(), remove_liquidity() or by calling harvest_g_skash_from_lp()
    ///realize pending g-skash rewards from LP
    pub fn harvest_g_skash_from_lp(&mut self){

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        //get NSLP account
        let lp_account = self.internal_get_nslp_account();
        
        //compute share value
        let valued_actual_shares = self.amount_from_nslp_shares(acc.nslp_shares, &lp_account);
        
        //realize and mint g-skash
        self.total_g_skash += acc.nslp_realize_g_skash(valued_actual_shares, self);
        
        //--SAVE ACCOUNT
        self.internal_save_account(&account_id, &acc);
    }

    //---------------------------------
    // staking-pools-list (SPL) management
    //---------------------------------

    /// get the current list of pools
    pub fn get_staking_pool_list(&self) -> Vec<StakingPoolJSONInfo> {
        let mut result = Vec::with_capacity(self.staking_pools.len());
        for elem in self.staking_pools.iter(){
            result.push(StakingPoolJSONInfo{
                account_id: elem.account_id.clone(),
                weight_basis_points: elem.weight_basis_points,
                staked: elem.staked.into(),
                unstaked: elem.unstaked.into(),
                last_asked_rewards_epoch_height: elem.last_asked_rewards_epoch_height.into(),
                unstaked_requested_epoch_height: elem.unstaked_requested_epoch_height.into(),
            })
        }
        return result;
    }

    ///remove staking pool from list *if it's empty*
    pub fn remove_staking_pool(&mut self, inx:u16 ){

        self.assert_owner_calling();

        let sp = &self.staking_pools[inx as usize];
        if !sp.is_empty() {
            panic!(b"sp is not empty")
        }
        self.staking_pools.remove(inx as usize);
    }

    ///update existing weight_basis_points
    pub fn set_staking_pool_weight(&mut self, inx:u16, weight_basis_points:u16 ){

        self.assert_owner_calling();

        let sp = &mut self.staking_pools[inx as usize];
        if sp.busy_lock {
            panic!(b"sp is busy")
        }
        sp.weight_basis_points = weight_basis_points;
    }
    
    ///add a new staking pool or update existing weight_basis_points
    pub fn set_staking_pool(&mut self, account_id:AccountId, weight_basis_points:u16 ){

        self.assert_owner_calling();

        //search the pools
        for sp in self.staking_pools.iter_mut() {
            if sp.account_id==account_id {
                //found
                if sp.busy_lock {
                    panic!(b"sp is busy")
                }
                (*sp).weight_basis_points = weight_basis_points;
                return;
            }
        }
        //not found, it's a new pool
        self.staking_pools.push(  StakingPoolInfo::new(account_id, weight_basis_points) );
    }

    //-----------------------------
    // DISTRIBUTE
    //-----------------------------

    /// operator method
    /// distribute. Do staking & unstaking in batches of at most 100Kn
    /// called externaly every 30 mins or less if: a) there's a large stake/unstake oper to perform or b) the epoch is about to finish and there are stakes to be made
    /// returns "true" if there's still more job to do

    pub fn distribute(&mut self) {

        self.assert_owner_calling();

        //let epoch_height = env::epoch_height();
        // if self.last_epoch_height == epoch_height {
        //     return false;
        // }
        // self.last_epoch_height = epoch_height;

        //-------------------------------------
        //check if we need to actually stake
        //-------------------------------------
        let mut amount_to_stake = 0;
        if self.total_for_staking > 0 && self.total_for_staking > self.total_actually_staked {
            //more ordered for staking than actually staked
            amount_to_stake = self.total_for_staking - self.total_actually_staked;
        }

        //-------------------------------------
        //check if we need to actually un-stake
        //-------------------------------------
        let mut amount_to_unstake = 0;
        if self.total_for_unstaking > 0 && self.total_for_unstaking > self.total_actually_unstaked {
            //more ordered for unstaking than actually unstaked
            amount_to_unstake = self.total_for_unstaking - self.total_actually_unstaked;
        }

        //-----------------------------------------------
        //internal clearing, no need to talk to the pools
        //-----------------------------------------------
        if amount_to_stake > 0 && amount_to_unstake > 0 {
            if amount_to_stake > amount_to_unstake {
                amount_to_stake -= amount_to_unstake;
                amount_to_unstake = 0;
            } else {
                amount_to_unstake -= amount_to_stake;
                amount_to_stake = 0;
            }
        }

        //-----------------------------------
        //check if we need to actually stake
        //-----------------------------------
        if amount_to_stake > 0 {
            //more ordered for staking than actually staked
            // do it in batches of 100/150k
            if amount_to_stake > MAX_NEARS_SINGLE_MOVEMENT {
                //split movements
                amount_to_stake = NEARS_PER_BATCH;
            }
            let sp_inx = self.get_staking_pool_requiring_stake();
            if sp_inx != usize::MAX {
                //most unbalanced pool found & available
                //launch async stake or deposit_and_stake on that pool

                let sp = &mut self.staking_pools[sp_inx];
                sp.busy_lock = true;

                if sp.unstaked > 0 {
                    //pool has unstaked amount
                    if sp.unstaked < amount_to_stake {
                        amount_to_stake = sp.unstaked;
                    }
                    //launch async stake to re-stake on the pool
                    assert!(sp.unstaked >= amount_to_stake);
                    self.total_actually_staked += amount_to_stake; //preventively consider the amount staked (undoes if failed)
                    ext_staking_pool::stake(
                        amount_to_stake.into(),
                        &sp.account_id,
                        NO_DEPOSIT,
                        gas::staking_pool::STAKE,
                    )
                    .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                        sp_inx,
                        amount_to_stake,
                        false,
                        &env::current_account_id(),
                        NO_DEPOSIT,
                        gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
                    ));

                    return; //just one bit of work
                }

                //here the sp has no unstaked balance, we must deposit_and_stake on the sp
                //launch async deposit_and_stake on the pool
                assert!(
                    env::account_balance() - MIN_BALANCE_FOR_STORAGE >= amount_to_stake,
                    "env::account_balance()-MIN_BALANCE_FOR_STORAGE < amount_to_deposit_and_stake"
                );
                assert!(
                    self.total_available >= amount_to_stake,
                    "self.available < amount_to_deposit_and_stake"
                );
                self.total_available -= amount_to_stake; //preventively consider the amount sent (undoes if async fails)
                self.total_actually_staked += amount_to_stake; //preventively consider the amount staked (undoes if async fails)

                ext_staking_pool::deposit_and_stake(
                    &sp.account_id,
                    amount_to_stake.into(), //attached amount
                    gas::staking_pool::DEPOSIT_AND_STAKE,
                )
                .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                    sp_inx,
                    amount_to_stake,
                    true,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
                ));

                return; //just one bit of work
            }
        }

        //-------------------------------------
        //check if we need to actually UN-stake
        //-------------------------------------
        if amount_to_unstake > 0 {
            //more ordered for unstaking than actually unstaked
            //do it in batches of 100/150k
            if amount_to_unstake > MAX_NEARS_SINGLE_MOVEMENT {
                //split movements
                amount_to_unstake = NEARS_PER_BATCH;
            }
            let sp_inx = self.get_staking_pool_requiring_unstake();
            if sp_inx != usize::MAX {
                //most unbalanced pool found & available
                //launch async to unstake

                let sp = &mut self.staking_pools[sp_inx];
                sp.busy_lock = true;

                //max to unstake is amount staked
                if sp.staked < amount_to_unstake {
                    amount_to_unstake = sp.staked;
                }
                //launch async to un-stake from the pool
                assert!(sp.staked >= amount_to_unstake);
                self.total_actually_staked -= amount_to_unstake; //preventively consider the amount un-staked (undoes if promise fails)
                self.total_actually_unstaked += amount_to_unstake; //preventively consider the amount un-staked (undoes if promise fails)
                ext_staking_pool::unstake(
                    amount_to_unstake.into(),
                    &sp.account_id,
                    NO_DEPOSIT,
                    gas::staking_pool::UNSTAKE,
                )
                .then(ext_self_owner::on_staking_pool_unstake(
                    sp_inx,
                    amount_to_unstake,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::owner_callbacks::ON_STAKING_POOL_UNSTAKE,
                ));

                return; //just one bit of work
            }
        }
    }

    //prev fn continues here
    /// Called after amount is staked from the sp's unstaked balance (all into  the staking pool contract).
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        included_deposit: bool,
    ) -> bool {

        assert_callback_calling();

        let sp = &mut self.staking_pools[sp_inx];
        sp.busy_lock = false;
        let stake_succeeded = is_promise_success();

        let result: &str;
        if stake_succeeded {
            result = "succeeded";
            if !included_deposit {
                //not deposited first, so staked funds came from unstaked funds already in the sp
                sp.unstaked -= amount;
            }
            //move into staked
            sp.staked += amount;
        } else {
            result = "has failed";
            if included_deposit {
                self.total_available += amount; //undo preventive action considering the amount sent
            }
            self.total_actually_staked -= amount; //undo preventive action considering the amount staked
        }
        env::log(format!("Staking of {} at @{} {}", amount, sp.account_id, result).as_bytes());
        return stake_succeeded;
    }

    /// Called after the given amount was unstaked at the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_unstake(&mut self, sp_inx: usize, amount: u128) -> bool {

        assert_callback_calling();

        let sp = &mut self.staking_pools[sp_inx];
        sp.busy_lock = false;

        let unstake_succeeded = is_promise_success();

        let result: &str;
        if unstake_succeeded {
            result = "succeeded";
            sp.unstaked += amount;
            sp.staked -= amount;
        } else {
            result = "has failed";
            self.total_actually_staked += amount; //undo preventive action considering the amount unstaked
            self.total_actually_unstaked -= amount; //undo preventive action considering the amount unstaked
        }

        env::log(format!("Unstaking of {} at @{} {}", amount, sp.account_id, result).as_bytes());
        return unstake_succeeded;
    }

    //------------------------------------------
    // GETTERS (moved from getters.rs)
    //------------------------------------------
    /// Returns the account ID of the owner.
    pub fn get_operator_account_id(&self) -> AccountId {
        return self.operator_account_id.clone();
    }

    /// The amount of tokens that were deposited to the staking pool.
    /// NOTE: The actual balance can be larger than this known deposit balance due to staking
    /// rewards acquired on the staking pool.
    /// To refresh the amount the owner can call `refresh_staking_pool_balance`.
    pub fn get_known_deposited_balance(&self) -> U128String {
        return self.total_actually_staked.into();
    }

    /// full account info
    /// Returns JSON representation of the account for the given account ID.
    pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult {
        let acc = self.internal_get_account(&account_id);
        let skash = self.amount_from_stake_shares(acc.stake_shares);
        // trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
        let trip_rewards = (skash + acc.trip_accum_unstakes).saturating_sub(acc.trip_accum_stakes + acc.trip_start_skash);
        //NLSP share value
        let mut nslp_share_value: u128 = 0;
        if acc.nslp_shares != 0 {
            let nslp_account = self.internal_get_nslp_account();
            nslp_share_value = acc.valued_nslp_shares(self, &nslp_account);
        }
        return GetAccountInfoResult {
            account_id,
            available: acc.available.into(),
            skash: skash.into(),
            unstaked: acc.unstaked.into(),
            unstaked_requested_epoch_height: acc.unstaked_requested_epoch_height.into(),
            can_withdraw: (env::epoch_height()
                >= acc.unstaked_requested_epoch_height + NUM_EPOCHS_TO_UNLOCK),
            total: (acc.available + skash + acc.unstaked).into(),
            //trip-meter
            trip_start: acc.trip_start.into(),
            trip_start_skash: acc.trip_start_skash.into(),
            trip_accum_stakes: acc.trip_accum_stakes.into(),
            trip_accum_unstakes: acc.trip_accum_unstakes.into(),
            trip_rewards: trip_rewards.into(),

            nslp_shares: acc.nslp_shares.into(),
            nslp_share_value: nslp_share_value.into(),

            g_skash: acc.total_g_skash(self).into(),
        };
    }

    /// NEP-129 get information about this contract
    /// returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub fn get_contract_info(&self) -> String {
        return format!(r#"{{\
            "dataVersion":1,\
            "name":"{}"\
            "version":"{}",\
            "developersAccountId":"{}",\
            "source":"https://github.com/Narwallets/diversifying-staking-pool", \
            "standards":["NEP-129"], \ 
            "webAppUrl":"{}", \
            "auditorAccountId":"{}" \
            }}"#, CONTRACT_NAME, CONTRACT_VERSION, DEVELOPERS_ACCOUNT_ID,
                self.web_app_url, self.auditor_account_id )
    }

    /// get contract totals 
    /// Returns JSON representation of the contract state
    pub fn get_contract_state(&self) -> GetContractStateResult {

        let lp_account = self.internal_get_nslp_account();

        return GetContractStateResult {
            total_available: self.total_available.into(),
            total_for_staking: self.total_for_staking.into(),
            total_for_unstaking: self.total_for_unstaking.into(),
            total_actually_staked: self.total_actually_staked.into(),
            accumulated_staked_rewards: self.accumulated_staked_rewards.into(),
            total_actually_unstaked: self.total_actually_unstaked.into(),
            total_actually_unstaked_and_retrieved: self.total_actually_unstaked_and_retrieved.into(),
            total_stake_shares: self.total_stake_shares.into(),
            total_g_skash: self.total_g_skash.into(),
            accounts_count: self.accounts.len().into(),
            staking_pools_count: self.staking_pools.len() as u16,
            nslp_liquidity: lp_account.available.into(),
            nslp_current_discount_basis_points: self.internal_get_discount_basis_points(lp_account.available, TEN_NEAR)
        };
    }

    /// Returns JSON representation of contract parameters
    pub fn get_contract_params(&self) -> ContractParamsJSON {
        return ContractParamsJSON {
            staking_paused: self.staking_paused,
            min_account_balance: self.min_account_balance.into(),

            nslp_near_target: self.nslp_near_target.into(),
            nslp_max_discount_basis_points: self.nslp_max_discount_basis_points,
            nslp_min_discount_basis_points: self.nslp_min_discount_basis_points,

            staker_g_skash_mult_pct: self.staker_g_skash_mult_pct,
            skash_sell_g_skash_mult_pct: self.skash_sell_g_skash_mult_pct,
            lp_provider_g_skash_mult_pct: self.lp_provider_g_skash_mult_pct,
                    
            operator_rewards_fee_basis_points: self.operator_rewards_fee_basis_points,
            operator_swap_cut_basis_points: self.operator_swap_cut_basis_points,
            treasury_swap_cut_basis_points: self.treasury_swap_cut_basis_points,
            };
    }

    /// Returns JSON representation of contract parameters
    pub fn set_contract_params(&mut self, params:ContractParamsJSON) {

        self.assert_owner_calling();

        self.min_account_balance = params.min_account_balance.0;

        self.nslp_near_target = params.nslp_near_target.0;
        self.nslp_max_discount_basis_points = params.nslp_max_discount_basis_points;
        self.nslp_min_discount_basis_points = params.nslp_min_discount_basis_points;

        self.staker_g_skash_mult_pct = params.staker_g_skash_mult_pct;
        self.skash_sell_g_skash_mult_pct = params.skash_sell_g_skash_mult_pct;
        self.lp_provider_g_skash_mult_pct = params.lp_provider_g_skash_mult_pct;
                    
        self.operator_rewards_fee_basis_points = params.operator_rewards_fee_basis_points;
        self.operator_swap_cut_basis_points = params.operator_swap_cut_basis_points;
        self.treasury_swap_cut_basis_points = params.treasury_swap_cut_basis_points;

    }
    
    /// get sp (staking-pool) info
    /// Returns JSON representation of sp recorded state
    pub fn get_sp_info(&self, sp_inx_i32: i32) -> StakingPoolJSONInfo {

        assert!(sp_inx_i32 > 0);

        let sp_inx = sp_inx_i32 as usize;
        assert!(sp_inx < self.staking_pools.len());

        let sp = &self.staking_pools[sp_inx];

        return StakingPoolJSONInfo {
            account_id: sp.account_id.clone(),
            weight_basis_points: sp.weight_basis_points,
            staked: sp.staked.into(),
            unstaked: sp.unstaked.into(),
            unstaked_requested_epoch_height: sp.unstaked_requested_epoch_height.into(),
            last_asked_rewards_epoch_height: sp.last_asked_rewards_epoch_height.into(),
        };
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use near_sdk::{testing_env, MockedBlockchain, PromiseResult, VMContext};

    use test_utils::*;

    use super::*;

    mod test_utils;

    pub type AccountId = String;

    const SALT: [u8; 3] = [1, 2, 3];

    fn basic_context() -> VMContext {
        get_context(
            system_account(),
            to_yocto(TEST_INITIAL_BALANCE),
            0,
            to_ts(GENESIS_TIME_IN_DAYS),
            false,
        )
    }

    fn new_contract() -> DiversifiedPool {
        DiversifiedPool::new(account_owner())
    }

    fn contract_only_setup() -> (VMContext, DiversifiedPool) {
        let context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract();
        return (context, contract);
    }

    // #[test]
    // fn test_gfme_only_basic() {
    //     let (mut context, contract) = contract_only_setup();
    //     // Checking initial values at genesis time
    //     context.is_view = true;
    //     testing_env!(context.clone());

    //     assert_eq!(contract.get_owners_balance().0, 0);

    //     // Checking values in 1 day after genesis time
    //     context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);

    //     assert_eq!(contract.get_owners_balance().0, 0);

    //     // Checking values next day after gfme timestamp
    //     context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
    //     testing_env!(context.clone());

    //     assert_almost_eq(contract.get_owners_balance().0, to_yocto(TEST_INITIAL_BALANCE));
    // }
    #[test]
    fn test_internal_get_near_amount_sell_skash() {
        let (mut context, mut contract) = contract_only_setup();
        let lp_balance_y: u128 = to_yocto(500_000);
        let sell_skash_y: u128 = to_yocto(120);
        let discount_bp: u16 = contract.get_discount_basis_points(lp_balance_y, sell_skash_y);
        let near_amount_y =
            contract.internal_get_near_amount_sell_skash(lp_balance_y, sell_skash_y);
        assert!(near_amount_y <= sell_skash_y);
        let discountedy = sell_skash_y - near_amount_y;
        let discounted_displayN = ytof(discountedy);
        let sell_skash_displayN = ytof(sell_skash_y);
        assert!(discountedy == apply_pct(discount_bp, sell_skash_y));
        assert!(near_amount_y == sell_skash_y - discountedy);
    }

    /*
    #[test]
    fn test_add_full_access_key() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Can only be called by the owner")]
    fn test_call_by_non_owner() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.select_staking_pool(AccountId::from("staking_pool"));
    }

    #[test]
    fn test_gfme_only_transfer_call_by_owner() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(TEST_INITIAL_BALANCE));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(TEST_INITIAL_BALANCE));
        contract.transfer(to_yocto(100).into(), non_owner());
        assert_almost_eq(env::account_balance(), to_yocto(TEST_INITIAL_BALANCE - 100));
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_is_not_selected() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
    }

    #[test]
    fn test_staking_pool_success() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_staking_pool_account_id(), Some(staking_pool));
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Deposit to the staking_pool
        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(TEST_INITIAL_BALANCE) - amount);

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        // Assuming there are 20 NEAR tokens in rewards. Unstaking.
        let unstake_amount = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unstake(unstake_amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake(unstake_amount.into());

        // Withdrawing
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.withdraw_from_staking_pool(unstake_amount.into());
        context.account_balance += unstake_amount;

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_withdraw(unstake_amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
        assert_eq!(contract.get_staking_pool_account_id(), None);
    }

    #[test]
    fn test_staking_pool_refresh_balance() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(TEST_INITIAL_BALANCE) - amount);

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Assuming there are 20 NEAR tokens in rewards. Refreshing balance.
        let total_balance = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.refresh_staking_pool_balance();

        // In unit tests, the following call ignores the promise value, because it's passed directly.
        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_get_sp_total_balance(sp_account, total_balance.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(20));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(20));
        context.is_view = false;

        // Withdrawing these tokens
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        let transfer_amount = to_yocto(15);
        contract.transfer(transfer_amount.into(), non_owner());
        context.account_balance = env::account_balance();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(5));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(5));
        context.is_view = false;
    }

    #[test]
    #[should_panic(expected = "Staking pool is already selected")]
    fn test_staking_pool_selected_again() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Selecting another staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.select_staking_pool("staking_pool_2".to_string());
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_unselecting_non_selected() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Unselecting staking pool
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    fn test_staking_pool_owner_balance() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);

        let gfme_amount = to_yocto(TEST_INITIAL_BALANCE);
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, gfme_amount);
        context.is_view = false;

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Deposit to the staking_pool
        let mut total_amount = 0;
        let amount = to_yocto(100);
        for _ in 1..=5 {
            total_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.deposit_to_staking_pool(amount.into());
            context.account_balance = env::account_balance();
            assert_eq!(context.account_balance, gfme_amount - total_amount);

            context.predecessor_account_id = gfme_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_deposit(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(contract.get_known_deposited_balance().0, total_amount);
            assert_eq!(contract.get_owners_balance().0, gfme_amount);
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                gfme_amount - total_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }

        // Withdrawing from the staking_pool. Plus one extra time as a reward
        let mut total_withdrawn_amount = 0;
        for _ in 1..=6 {
            total_withdrawn_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.withdraw_from_staking_pool(amount.into());
            context.account_balance += amount;
            assert_eq!(
                context.account_balance,
                gfme_amount - total_amount + total_withdrawn_amount
            );

            context.predecessor_account_id = gfme_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_withdraw(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(
                contract.get_known_deposited_balance().0,
                total_amount.saturating_sub(total_withdrawn_amount)
            );
            assert_eq!(
                contract.get_owners_balance().0,
                gfme_amount + total_withdrawn_amount.saturating_sub(total_amount)
            );
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                gfme_amount - total_amount + total_withdrawn_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }
    }
    */
}

'''
'''--- res/test/rust/lockup/src/lib.rs ---
//! A smart contract that allows tokens to be locked up.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{env, ext_contract, near_bindgen, AccountId};

pub use crate::foundation::*;
pub use crate::foundation_callbacks::*;
pub use crate::getters::*;
pub use crate::internal::*;
pub use crate::owner::*;
pub use crate::owner_callbacks::*;
pub use crate::types::*;
pub use crate::utils::*;

pub mod foundation;
pub mod foundation_callbacks;
pub mod gas;
pub mod owner_callbacks;
pub mod types;
pub mod utils;

pub mod getters;
pub mod internal;
pub mod owner;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Indicates there are no deposit for a cross contract call for better readability.
const NO_DEPOSIT: u128 = 0;

/// The contract keeps at least 35 NEAR in the account to avoid being transferred out to cover
/// contract code storage and some internal state.
const MIN_BALANCE_FOR_STORAGE: u128 = 35_000_000_000_000_000_000_000_000;

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn get_account_total_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: WrappedBalance);

    fn stake(&mut self, amount: WrappedBalance);

    fn unstake(&mut self, amount: WrappedBalance);

    fn unstake_all(&mut self);
}

#[ext_contract(ext_whitelist)]
pub trait ExtStakingPoolWhitelist {
    fn is_whitelisted(&self, staking_pool_account_id: AccountId) -> bool;
}

#[ext_contract(ext_transfer_poll)]
pub trait ExtTransferPoll {
    fn get_result(&self) -> Option<PollResult>;
}

#[ext_contract(ext_self_owner)]
pub trait ExtLockupContractOwner {
    fn on_whitelist_is_whitelisted(
        &mut self,
        #[callback] is_whitelisted: bool,
        staking_pool_account_id: AccountId,
    ) -> bool;

    fn on_staking_pool_deposit(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_deposit_and_stake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_withdraw(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_stake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_unstake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_unstake_all(&mut self) -> bool;

    fn on_get_result_from_transfer_poll(&mut self, #[callback] poll_result: PollResult) -> bool;

    fn on_get_account_total_balance(&mut self, #[callback] total_balance: WrappedBalance);

    fn on_get_account_unstaked_balance_to_withdraw_by_owner(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    );
}

#[ext_contract(ext_self_foundation)]
pub trait ExtLockupContractFoundation {
    fn on_withdraw_unvested_amount(
        &mut self,
        amount: WrappedBalance,
        receiver_id: AccountId,
    ) -> bool;

    fn on_get_account_staked_balance_to_unstake(
        &mut self,
        #[callback] staked_balance: WrappedBalance,
    );

    fn on_staking_pool_unstake_for_termination(&mut self, amount: WrappedBalance) -> bool;

    fn on_get_account_unstaked_balance_to_withdraw(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    );

    fn on_staking_pool_withdraw_for_termination(&mut self, amount: WrappedBalance) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupContract {
    /// The account ID of the owner.
    pub owner_account_id: AccountId,

    /// Information about lockup schedule and the amount.
    pub lockup_information: LockupInformation,

    /// Information about vesting including schedule or termination status.
    pub vesting_information: VestingInformation,

    /// Account ID of the staking pool whitelist contract.
    pub staking_pool_whitelist_account_id: AccountId,

    /// Information about staking and delegation.
    /// `Some` means the staking information is available and the staking pool contract is selected.
    /// `None` means there is no staking pool selected.
    pub staking_information: Option<StakingInformation>,

    /// The account ID that the NEAR Foundation, that has the ability to terminate vesting.
    pub foundation_account_id: Option<AccountId>,
}

impl Default for LockupContract {
    fn default() -> Self {
        env::panic(b"The contract is not initialized.");
    }
}

#[near_bindgen]
impl LockupContract {
    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Initializes lockup contract.
    /// - `owner_account_id` - the account ID of the owner.  Only this account can call owner's
    ///    methods on this contract.
    /// - `lockup_duration` - the duration in nanoseconds of the lockup period from the moment
    ///    the transfers are enabled.
    /// - `lockup_timestamp` - the optional absolute lockup timestamp in nanoseconds which locks
    ///    the tokens until this timestamp passes.
    /// - `transfers_information` - the information about the transfers. Either transfers are
    ///    already enabled, then it contains the timestamp when they were enabled. Or the transfers
    ///    are currently disabled and it contains the account ID of the transfer poll contract.
    /// - `vesting_schedule` - If provided, then it's either a base64 encoded hash of vesting
    ///    schedule with salt or an explicit vesting schedule.
    ///    Vesting schedule affects the amount of tokens the NEAR Foundation will get in case of
    ///    employment termination as well as the amount of tokens available for transfer by
    ///    the employee. If Hash provided, it's expected that vesting started before lockup and
    ///    it only needs to be revealed in case of termination.
    /// - `release_duration` - is the duration when the full lockup amount will be available.
    ///    The tokens are linearly released from the moment transfers are enabled. If it's used
    ///    in addition to the vesting schedule, then the amount of tokens available to transfer
    ///    is subject to the minimum between vested tokens and released tokens.
    /// - `staking_pool_whitelist_account_id` - the Account ID of the staking pool whitelist contract.
    /// - `foundation_account_id` - the account ID of the NEAR Foundation, that has the ability to
    ///    terminate vesting schedule.
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        lockup_duration: WrappedDuration,
        lockup_timestamp: Option<WrappedTimestamp>,
        transfers_information: TransfersInformation,
        vesting_schedule: Option<VestingScheduleOrHash>,
        release_duration: Option<WrappedDuration>,
        staking_pool_whitelist_account_id: AccountId,
        foundation_account_id: Option<AccountId>,
    ) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::is_valid_account_id(owner_account_id.as_bytes()),
            "The account ID of the owner is invalid"
        );
        assert!(
            env::is_valid_account_id(staking_pool_whitelist_account_id.as_bytes()),
            "The staking pool whitelist account ID is invalid"
        );
        if let TransfersInformation::TransfersDisabled {
            transfer_poll_account_id,
        } = &transfers_information
        {
            assert!(
                env::is_valid_account_id(transfer_poll_account_id.as_bytes()),
                "The transfer poll account ID is invalid"
            );
        }
        let lockup_information = LockupInformation {
            lockup_amount: env::account_balance(),
            termination_withdrawn_tokens: 0,
            lockup_duration: lockup_duration.0,
            release_duration: release_duration.map(|d| d.0),
            lockup_timestamp: lockup_timestamp.map(|d| d.0),
            transfers_information,
        };
        let vesting_information = match vesting_schedule {
            None => {
                assert!(
                    foundation_account_id.is_none(),
                    "Foundation account can't be added without vesting schedule"
                );
                VestingInformation::None
            }
            Some(VestingScheduleOrHash::VestingHash(hash)) => VestingInformation::VestingHash(hash),
            Some(VestingScheduleOrHash::VestingSchedule(vs)) => {
                VestingInformation::VestingSchedule(vs)
            }
        };
        assert!(
            vesting_information == VestingInformation::None || foundation_account_id.is_some(),
            "Foundation account should be added for vesting schedule"
        );

        Self {
            owner_account_id,
            lockup_information,
            vesting_information,
            staking_information: None,
            staking_pool_whitelist_account_id,
            foundation_account_id,
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use near_sdk::{testing_env, MockedBlockchain, PromiseResult, VMContext};

    use test_utils::*;

    use super::*;

    mod test_utils;

    pub type AccountId = String;

    const SALT: [u8; 3] = [1, 2, 3];

    fn basic_context() -> VMContext {
        get_context(
            system_account(),
            to_yocto(LOCKUP_NEAR),
            0,
            to_ts(GENESIS_TIME_IN_DAYS),
            false,
        )
    }

    fn new_vesting_schedule(offset_in_days: u64) -> VestingSchedule {
        VestingSchedule {
            start_timestamp: to_ts(GENESIS_TIME_IN_DAYS - YEAR + offset_in_days).into(),
            cliff_timestamp: to_ts(GENESIS_TIME_IN_DAYS + offset_in_days).into(),
            end_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR * 3 + offset_in_days).into(),
        }
    }

    fn no_vesting_schedule() -> VestingSchedule {
        VestingSchedule {
            start_timestamp: to_ts(0).into(),
            cliff_timestamp: to_ts(0).into(),
            end_timestamp: to_ts(0).into(),
        }
    }

    fn new_contract(
        transfers_enabled: bool,
        vesting_schedule: Option<VestingSchedule>,
        release_duration: Option<WrappedDuration>,
        foundation_account: bool,
    ) -> LockupContract {
        let lockup_start_information = if transfers_enabled {
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            }
        } else {
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: AccountId::from("transfers"),
            }
        };
        let foundation_account_id = if foundation_account {
            Some(account_foundation())
        } else {
            None
        };
        let vesting_schedule = vesting_schedule.map(|vesting_schedule| {
            VestingScheduleOrHash::VestingHash(
                VestingScheduleWithSalt {
                    vesting_schedule,
                    salt: SALT.to_vec().into(),
                }
                .hash()
                .into(),
            )
        });
        LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            lockup_start_information,
            vesting_schedule,
            release_duration,
            AccountId::from("whitelist"),
            foundation_account_id,
        )
    }

    fn lockup_only_setup() -> (VMContext, LockupContract) {
        let context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract(true, None, None, false);
        (context, contract)
    }

    #[test]
    fn test_lockup_only_basic() {
        let (mut context, contract) = lockup_only_setup();
        // Checking initial values at genesis time
        context.is_view = true;
        testing_env!(context.clone());

        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(LOCKUP_NEAR)
        );

        // Checking values in 1 day after genesis time
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);

        assert_eq!(contract.get_owners_balance().0, 0);

        // Checking values next day after lockup timestamp
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        testing_env!(context.clone());

        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));
    }

    #[test]
    fn test_add_full_access_key() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Can only be called by the owner")]
    fn test_call_by_non_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.select_staking_pool(AccountId::from("staking_pool"));
    }

    #[test]
    #[should_panic(expected = "Presented vesting schedule and salt don't match the hash")]
    fn test_vesting_doesnt_match() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = new_contract(true, Some(vesting_schedule), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        let not_real_vesting = new_vesting_schedule(100);
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: not_real_vesting,
            salt: SALT.to_vec().into(),
        }));
    }

    #[test]
    #[should_panic(expected = "Expected vesting schedule and salt, but it was not provided")]
    fn test_vesting_schedule_and_salt_not_provided() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = new_contract(true, Some(vesting_schedule), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(None);
    }

    #[test]
    #[should_panic(expected = "Explicit vesting schedule exists")]
    fn test_explicit_vesting() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            None,
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule,
            salt: SALT.to_vec().into(),
        }));
    }

    #[test]
    #[should_panic(expected = "Foundation account can't be added without vesting schedule")]
    fn test_init_foundation_key_no_vesting() {
        let context = basic_context();
        testing_env!(context.clone());
        new_contract(true, None, None, true);
    }

    #[test]
    #[should_panic(expected = "Foundation account can't be added without vesting schedule")]
    fn test_init_foundation_key_no_vesting_with_release() {
        let context = basic_context();
        testing_env!(context.clone());
        new_contract(true, None, Some(to_nanos(YEAR).into()), true);
    }

    #[test]
    #[should_panic(expected = "Can only be called by NEAR Foundation")]
    fn test_call_by_non_foundation() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(None);
    }

    #[test]
    #[should_panic(expected = "Transfers are disabled")]
    fn test_transfers_not_enabled() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.transfer(to_yocto(100).into(), non_owner());
    }

    #[test]
    fn test_enable_transfers() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.check_transfers_vote();

        let poll_result = Some(to_ts(GENESIS_TIME_IN_DAYS + 10).into());
        context.predecessor_account_id = lockup_account();
        // NOTE: Unit tests don't need to read the content of the promise result. So here we don't
        // have to pass serialized result from the transfer poll.
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        assert!(contract.on_get_result_from_transfer_poll(poll_result));

        context.is_view = true;
        testing_env!(context.clone());
        // Not unlocked yet
        assert_eq!(contract.get_owners_balance().0, 0);
        assert!(contract.are_transfers_enabled());
        assert_eq!(contract.get_vesting_information(), VestingInformation::None);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 10);
        testing_env!(context.clone());
        // Unlocked yet
        assert_eq!(
            contract.get_owners_balance().0,
            to_yocto(LOCKUP_NEAR).into()
        );

        context.is_view = false;
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.transfer(to_yocto(100).into(), non_owner());
    }

    #[test]
    fn test_check_transfers_vote_false() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.check_transfers_vote();

        let poll_result = None;
        // NOTE: Unit tests don't need to read the content of the promise result. So here we don't
        // have to pass serialized result from the transfer poll.
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        assert!(!contract.on_get_result_from_transfer_poll(poll_result));

        context.is_view = true;
        testing_env!(context.clone());
        // Not enabled
        assert!(!contract.are_transfers_enabled());
    }

    #[test]
    fn test_lockup_only_transfer_call_by_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(LOCKUP_NEAR));
        contract.transfer(to_yocto(100).into(), non_owner());
        assert_almost_eq(env::account_balance(), to_yocto(LOCKUP_NEAR - 100));
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_is_not_selected() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        let amount = to_yocto(LOCKUP_NEAR - 100);
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
    }

    #[test]
    fn test_staking_pool_success() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_staking_pool_account_id(), Some(staking_pool));
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(LOCKUP_NEAR) - amount);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        // Assuming there are 20 NEAR tokens in rewards. Unstaking.
        let unstake_amount = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unstake(unstake_amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake(unstake_amount.into());

        // Withdrawing
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.withdraw_from_staking_pool(unstake_amount.into());
        context.account_balance += unstake_amount;

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_withdraw(unstake_amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
        assert_eq!(contract.get_staking_pool_account_id(), None);
    }

    #[test]
    fn test_staking_pool_refresh_balance() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(LOCKUP_NEAR) - amount);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Assuming there are 20 NEAR tokens in rewards. Refreshing balance.
        let total_balance = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.refresh_staking_pool_balance();

        // In unit tests, the following call ignores the promise value, because it's passed directly.
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_get_account_total_balance(total_balance.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(20));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(20));
        context.is_view = false;

        // Withdrawing these tokens
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        let transfer_amount = to_yocto(15);
        contract.transfer(transfer_amount.into(), non_owner());
        context.account_balance = env::account_balance();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(5));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(5));
        context.is_view = false;
    }

    #[test]
    #[should_panic(expected = "Staking pool is already selected")]
    fn test_staking_pool_selected_again() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Selecting another staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.select_staking_pool("staking_pool_2".to_string());
    }

    #[test]
    #[should_panic(expected = "The given staking pool account ID is not whitelisted")]
    fn test_staking_pool_not_whitelisted() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"false".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(false, staking_pool.clone());
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_unselecting_non_selected() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Unselecting staking pool
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    #[should_panic(expected = "There is still a deposit on the staking pool")]
    fn test_staking_pool_unselecting_with_deposit() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    fn test_staking_pool_owner_balance() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);

        let lockup_amount = to_yocto(LOCKUP_NEAR);
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, lockup_amount);
        context.is_view = false;

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let mut total_amount = 0;
        let amount = to_yocto(100);
        for _ in 1..=5 {
            total_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.deposit_to_staking_pool(amount.into());
            context.account_balance = env::account_balance();
            assert_eq!(context.account_balance, lockup_amount - total_amount);

            context.predecessor_account_id = lockup_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_deposit(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(contract.get_known_deposited_balance().0, total_amount);
            assert_eq!(contract.get_owners_balance().0, lockup_amount);
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                lockup_amount - total_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }

        // Withdrawing from the staking_pool. Plus one extra time as a reward
        let mut total_withdrawn_amount = 0;
        for _ in 1..=6 {
            total_withdrawn_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.withdraw_from_staking_pool(amount.into());
            context.account_balance += amount;
            assert_eq!(
                context.account_balance,
                lockup_amount - total_amount + total_withdrawn_amount
            );

            context.predecessor_account_id = lockup_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_withdraw(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(
                contract.get_known_deposited_balance().0,
                total_amount.saturating_sub(total_withdrawn_amount)
            );
            assert_eq!(
                contract.get_owners_balance().0,
                lockup_amount + total_withdrawn_amount.saturating_sub(total_amount)
            );
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                lockup_amount - total_amount + total_withdrawn_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }
    }

    #[test]
    fn test_lock_timestmap() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = LockupContract::new(
            account_owner(),
            0.into(),
            Some(to_ts(GENESIS_TIME_IN_DAYS + YEAR).into()),
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: AccountId::from("transfers"),
            },
            None,
            None,
            AccountId::from("whitelist"),
            None,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_lock_timestmap_transfer_enabled() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = LockupContract::new(
            account_owner(),
            0.into(),
            Some(to_ts(GENESIS_TIME_IN_DAYS + YEAR).into()),
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR / 2).into(),
            },
            None,
            None,
            AccountId::from("whitelist"),
            None,
        );

        context.is_view = true;
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_no_staking() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            None,
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::VestingSchedule(vesting_schedule.clone())
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(None);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::Terminating(TerminationInformation {
                unvested_amount: to_yocto(250).into(),
                status: TerminationStatus::ReadyToWithdraw
            })
        );
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(0)
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = "near".to_string();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(250).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(750) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(0));
        assert_eq!(contract.get_termination_status(), None);
        assert_eq!(contract.get_vesting_information(), VestingInformation::None);
    }

    #[test]
    fn test_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract(true, None, Some(to_nanos(4 * YEAR).into()), false);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(750)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(500)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
    }

    #[test]
    fn test_vesting_and_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let contract = new_contract(
            true,
            Some(vesting_schedule.clone()),
            Some(to_nanos(4 * YEAR).into()),
            true,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 4 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
    }

    // Vesting post transfers is not supported by Hash vesting.
    #[test]
    fn test_vesting_post_transfers_and_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(YEAR * 2);
        let contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            Some(to_nanos(4 * YEAR).into()),
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(1000)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(1000)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 4 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 5 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_no_staking_with_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract(
            true,
            Some(vesting_schedule.clone()),
            Some(to_nanos(4 * YEAR).into()),
            true,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(0)
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = "near".to_string();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(250).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(0));
        assert_eq!(contract.get_termination_status(), None);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(750) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_before_cliff() {
        let lockup_amount = to_yocto(1000);
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(YEAR);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::VestingHash(
                VestingScheduleWithSalt {
                    vesting_schedule: vesting_schedule.clone(),
                    salt: SALT.to_vec().into()
                }
                .hash()
                .into()
            )
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            lockup_amount
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::Terminating(TerminationInformation {
                unvested_amount: lockup_amount.into(),
                status: TerminationStatus::ReadyToWithdraw
            })
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            lockup_amount
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, lockup_amount);
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = account_foundation();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, MIN_BALANCE_FOR_STORAGE);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(
            (lockup_amount - MIN_BALANCE_FOR_STORAGE).into(),
            receiver_id,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(
            contract.get_terminated_unvested_balance().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );
    }

    #[test]
    fn test_termination_with_staking() {
        let lockup_amount = to_yocto(1000);
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        context.is_view = false;

        context.predecessor_account_id = account_owner();
        context.signer_account_pk = public_key(2).into();
        testing_env!(context.clone());

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let stake_amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(stake_amount.into());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(stake_amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(stake_amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(stake_amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_known_deposited_balance().0, stake_amount);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        context.is_view = false;

        // Foundation terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(650) + MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::VestingTerminatedWithDeficit)
        );

        // Proceeding with unstaking from the pool due to termination.
        context.is_view = false;
        testing_env!(context.clone());
        contract.termination_prepare_to_withdraw();
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::UnstakingInProgress)
        );

        let stake_amount_with_rewards = stake_amount + to_yocto(50);
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(format!("{}", stake_amount_with_rewards).into_bytes()),
        );
        contract.on_get_account_staked_balance_to_unstake(stake_amount_with_rewards.into());

        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake_for_termination(stake_amount_with_rewards.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::EverythingUnstaked)
        );

        // Proceeding with withdrawing from the pool due to termination.
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        testing_env!(context.clone());
        contract.termination_prepare_to_withdraw();
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::WithdrawingFromStakingPoolInProgress)
        );

        let withdraw_amount_with_extra_rewards = stake_amount_with_rewards + to_yocto(1);
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(
                format!("{}", withdraw_amount_with_extra_rewards).into_bytes(),
            ),
        );
        contract
            .on_get_account_unstaked_balance_to_withdraw(withdraw_amount_with_extra_rewards.into());
        context.account_balance += withdraw_amount_with_extra_rewards;

        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract
            .on_staking_pool_withdraw_for_termination(withdraw_amount_with_extra_rewards.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance_deficit().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        testing_env!(context.clone());
        let receiver_id = account_foundation();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(250 + 51));

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(750).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_unvested_amount(vesting_schedule.clone()).0, 0);
        assert_eq!(contract.get_terminated_unvested_balance().0, 0);
        assert_eq!(contract.get_terminated_unvested_balance_deficit().0, 0);
        assert_eq!(contract.get_termination_status(), None);

        // Checking the balance becomes unlocked later
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(301));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(301) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(contract.get_locked_amount().0, 0);
    }
}

'''
'''--- res/test/rust/multisig/src/lib.rs ---
use std::collections::HashSet;
use std::convert::TryFrom;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, Base64VecU8, U128, U64};
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue, PublicKey};
use near_sdk::serde::{Deserialize, Serialize};

/// Unlimited allowance for multisig keys.
const DEFAULT_ALLOWANCE: u128 = 0;

// Request cooldown period (time before a request can be deleted)
const REQUEST_COOLDOWN: u64 = 900_000_000_000;

pub type RequestId = u32;

/// Permissions for function call access key.
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallPermission {
    allowance: Option<U128>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

/// Lowest level action that can be performed by the multisig contract.
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(tag = "type", crate = "near_sdk::serde")]
pub enum MultiSigRequestAction {
    /// Transfers given amount to receiver.
    Transfer { amount: U128 },
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Adds key, either new key for multisig or full access key to another account.
    AddKey {
        public_key: Base58PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Deletes key, either one of the keys from multisig or key from another account.
    DeleteKey { public_key: Base58PublicKey },
    /// Call function on behalf of this contract.
    FunctionCall {
        method_name: String,
        args: Base64VecU8,
        deposit: U128,
        gas: U64,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations { num_confirmations: u32 },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit { active_requests_limit: u32 },
}

// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequest {
    receiver_id: AccountId,
    actions: Vec<MultiSigRequestAction>,
}

// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    signer_pk: PublicKey,
    added_timestamp: u64,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultiSigContract {
    num_confirmations: u32,
    request_nonce: RequestId,
    requests: UnorderedMap<RequestId, MultiSigRequestWithSigner>,
    confirmations: UnorderedMap<RequestId, HashSet<PublicKey>>,
    num_requests_pk: UnorderedMap<PublicKey, u32>,
    // per key
    active_requests_limit: u32,
}

// If you haven't initialized the contract with new(num_confirmations: u32)
impl Default for MultiSigContract {
    fn default() -> Self {
        env::panic(b"Multisig contract should be initialized before usage")
    }
}

#[near_bindgen]
impl MultiSigContract {
    /// Initialize multisig contract.
    /// @params num_confirmations: k of n signatures required to perform operations.
    #[init]
    pub fn new(num_confirmations: u32) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            num_confirmations,
            request_nonce: 0,
            requests: UnorderedMap::new(b"r".to_vec()),
            confirmations: UnorderedMap::new(b"c".to_vec()),
            num_requests_pk: UnorderedMap::new(b"k".to_vec()),
            active_requests_limit: 12,
        }
    }

    /// Add request for multisig.
    pub fn add_request(&mut self, request: MultiSigRequest) -> RequestId {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Predecessor account must much current account"
        );
        // track how many requests this key has made
        let num_requests = self
            .num_requests_pk
            .get(&env::signer_account_pk())
            .unwrap_or(0)
            + 1;
        assert!(
            num_requests <= self.active_requests_limit,
            "Account has too many active requests. Confirm or delete some."
        );
        self.num_requests_pk
            .insert(&env::signer_account_pk(), &num_requests);
        // add the request
        let request_added = MultiSigRequestWithSigner {
            signer_pk: env::signer_account_pk(),
            added_timestamp: env::block_timestamp(),
            request: request,
        };
        self.requests.insert(&self.request_nonce, &request_added);
        let confirmations = HashSet::new();
        self.confirmations
            .insert(&self.request_nonce, &confirmations);
        self.request_nonce += 1;
        return self.request_nonce - 1
    }

    /// Add request for multisig and confirm with the pk that added.
    pub fn add_request_and_confirm(&mut self, request: MultiSigRequest) -> RequestId {
        let request_id = self.add_request(request);
        self.confirm(request_id);
        request_id
    }

    /// Remove given request and associated confirmations.
    pub fn delete_request(&mut self, request_id: RequestId) {
        self.assert_valid_request(request_id);
        let request_with_signer = self.requests.get(&request_id).expect("No such request");
        // can't delete requests before 15min
        assert!(
            env::block_timestamp() > request_with_signer.added_timestamp + REQUEST_COOLDOWN,
            "Request cannot be deleted immediately after creation."
        );
        self.remove_request(request_id);
    }

    fn execute_request(&mut self, request: MultiSigRequest) -> PromiseOrValue<bool> {
        let mut promise = Promise::new(request.receiver_id.clone());
        let receiver_id = request.receiver_id.clone();
        let num_actions = request.actions.len();
        for action in request.actions {
            promise = match action {
                MultiSigRequestAction::Transfer { amount } => promise.transfer(amount.into()),
                MultiSigRequestAction::CreateAccount => promise.create_account(),
                MultiSigRequestAction::DeployContract { code } => {
                    promise.deploy_contract(code.into())
                }
                MultiSigRequestAction::AddKey {
                    public_key,
                    permission,
                } => {
                    self.assert_self_request(receiver_id.clone());
                    if let Some(permission) = permission {
                        promise.add_access_key(
                            public_key.into(),
                            permission
                                .allowance
                                .map(|x| x.into())
                                .unwrap_or(DEFAULT_ALLOWANCE),
                            permission.receiver_id,
                            permission.method_names.join(",").into_bytes(),
                        )
                    } else {
                        // wallet UI should warn user if receiver_id == env::current_account_id(), adding FAK will render multisig useless
                        promise.add_full_access_key(public_key.into())
                    }
                }
                MultiSigRequestAction::DeleteKey { public_key } => {
                    self.assert_self_request(receiver_id.clone());
                    let pk: PublicKey = public_key.into();
                    // delete outstanding requests by public_key
                    let request_ids: Vec<u32> = self
                        .requests
                        .iter()
                        .filter(|(_k, r)| r.signer_pk == pk)
                        .map(|(k, _r)| k)
                        .collect();
                    for request_id in request_ids {
                        // remove confirmations for this request
                        self.confirmations.remove(&request_id);
                        self.requests.remove(&request_id);
                    }
                    // remove num_requests_pk entry for public_key
                    self.num_requests_pk.remove(&pk);
                    promise.delete_key(pk)
                }
                MultiSigRequestAction::FunctionCall {
                    method_name,
                    args,
                    deposit,
                    gas,
                } => promise.function_call(
                    method_name.into_bytes(),
                    args.into(),
                    deposit.into(),
                    gas.into(),
                ),
                // the following methods must be a single action
                MultiSigRequestAction::SetNumConfirmations { num_confirmations } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.num_confirmations = num_confirmations;
                    return PromiseOrValue::Value(true);
                }
                MultiSigRequestAction::SetActiveRequestsLimit {
                    active_requests_limit,
                } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.active_requests_limit = active_requests_limit;
                    return PromiseOrValue::Value(true);
                }
            };
        }
        promise.into()
    }

    /// Confirm given request with given signing key.
    /// If with this, there has been enough confirmation, a promise with request will be scheduled.
    pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<bool> {
        self.assert_valid_request(request_id);
        let mut confirmations = self.confirmations.get(&request_id).unwrap();
        assert!(
            !confirmations.contains(&env::signer_account_pk()),
            "Already confirmed this request with this key"
        );
        if confirmations.len() as u32 + 1 >= self.num_confirmations {
            let request = self.remove_request(request_id);
            /********************************
            NOTE: If the tx execution fails for any reason, the request and confirmations are removed already, so the client has to start all over
            ********************************/
            self.execute_request(request)
        } else {
            confirmations.insert(env::signer_account_pk());
            self.confirmations.insert(&request_id, &confirmations);
            PromiseOrValue::Value(true)
        }
    }

    /********************************
    Helper methods
    ********************************/
    // removes request, removes confirmations and reduces num_requests_pk - used in delete, delete_key, and confirm
    fn remove_request(&mut self, request_id: RequestId) -> MultiSigRequest {
        // remove confirmations for this request
        self.confirmations.remove(&request_id);
        // remove the original request
        let request_with_signer = self
            .requests
            .remove(&request_id)
            .expect("Failed to remove existing element");
        // decrement num_requests for original request signer
        let original_signer_pk = request_with_signer.signer_pk;
        let mut num_requests = self.num_requests_pk.get(&original_signer_pk).unwrap_or(0);
        // safety check for underrun (unlikely since original_signer_pk must have num_requests_pk > 0)
        if num_requests > 0 {
            num_requests = num_requests - 1;
        }
        self.num_requests_pk
            .insert(&original_signer_pk, &num_requests);
        // return request
        request_with_signer.request
    }
    // Prevents access to calling requests and make sure request_id is valid - used in delete and confirm
    fn assert_valid_request(&mut self, request_id: RequestId) {
        // request must come from key added to contract account
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Predecessor account must much current account"
        );
        // request must exist
        assert!(
            self.requests.get(&request_id).is_some(),
            "No such request: either wrong number or already confirmed"
        );
        // request must have
        assert!(
            self.confirmations.get(&request_id).is_some(),
            "Internal error: confirmations mismatch requests"
        );
    }
    // Prevents request from approving tx on another account
    fn assert_self_request(&mut self, receiver_id: AccountId) {
        assert_eq!(
            receiver_id,
            env::current_account_id(),
            "This method only works when receiver_id is equal to current_account_id"
        );
    }
    // Prevents a request from being bundled with other actions
    fn assert_one_action_only(&mut self, receiver_id: AccountId, num_actions: usize) {
        self.assert_self_request(receiver_id);
        assert_eq!(num_actions, 1, "This method should be a separate request");
    }
    /********************************
    View methods
    ********************************/
    pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest {
        (self.requests.get(&request_id).expect("No such request")).request
    }

    pub fn get_num_requests_pk(&self, public_key: Base58PublicKey) -> u32 {
        self.num_requests_pk.get(&public_key.into()).unwrap_or(0)
    }

    pub fn list_request_ids(&self) -> Vec<RequestId> {
        self.requests.keys().collect()
    }

    pub fn get_confirmations(&self, request_id: RequestId) -> Vec<Base58PublicKey> {
        self.confirmations
            .get(&request_id)
            .expect("No such request")
            .into_iter()
            .map(|key| Base58PublicKey::try_from(key).expect("Failed to covert key to base58"))
            .collect()
    }

    pub fn get_num_confirmations(&self) -> u32 {
        self.num_confirmations
    }

    pub fn get_request_nonce(&self) -> u32 {
        self.request_nonce
    }
}

#[cfg(test)]
mod tests {
    use std::fmt::{Debug, Error, Formatter};

    use near_sdk::{testing_env, MockedBlockchain};
    use near_sdk::{AccountId, VMContext};
    use near_sdk::{Balance, BlockHeight, EpochHeight};

    use super::*;

    /// Used for asserts_eq.
    /// TODO: replace with derive when https://github.com/near/near-sdk-rs/issues/165
    impl Debug for MultiSigRequest {
        fn fmt(&self, _f: &mut Formatter<'_>) -> Result<(), Error> {
            panic!("Should not trigger");
        }
    }

    pub fn alice() -> AccountId {
        "alice".to_string()
    }
    pub fn bob() -> AccountId {
        "bob".to_string()
    }

    pub struct VMContextBuilder {
        context: VMContext,
    }

    impl VMContextBuilder {
        pub fn new() -> Self {
            Self {
                context: VMContext {
                    current_account_id: "".to_string(),
                    signer_account_id: "".to_string(),
                    signer_account_pk: vec![0, 1, 2],
                    predecessor_account_id: "".to_string(),
                    input: vec![],
                    epoch_height: 0,
                    block_index: 0,
                    block_timestamp: 0,
                    account_balance: 0,
                    account_locked_balance: 0,
                    storage_usage: 10u64.pow(6),
                    attached_deposit: 0,
                    prepaid_gas: 10u64.pow(18),
                    random_seed: vec![0, 1, 2],
                    is_view: false,
                    output_data_receivers: vec![],
                },
            }
        }

        pub fn current_account_id(mut self, account_id: AccountId) -> Self {
            self.context.current_account_id = account_id;
            self
        }

        pub fn block_timestamp(mut self, time: u64) -> Self {
            self.context.block_timestamp = time;
            self
        }

        #[allow(dead_code)]
        pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
            self.context.signer_account_id = account_id;
            self
        }

        pub fn signer_account_pk(mut self, signer_account_pk: PublicKey) -> Self {
            self.context.signer_account_pk = signer_account_pk;
            self
        }

        pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
            self.context.predecessor_account_id = account_id;
            self
        }

        #[allow(dead_code)]
        pub fn block_index(mut self, block_index: BlockHeight) -> Self {
            self.context.block_index = block_index;
            self
        }

        #[allow(dead_code)]
        pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
            self.context.epoch_height = epoch_height;
            self
        }

        #[allow(dead_code)]
        pub fn attached_deposit(mut self, amount: Balance) -> Self {
            self.context.attached_deposit = amount;
            self
        }

        pub fn account_balance(mut self, amount: Balance) -> Self {
            self.context.account_balance = amount;
            self
        }

        #[allow(dead_code)]
        pub fn account_locked_balance(mut self, amount: Balance) -> Self {
            self.context.account_locked_balance = amount;
            self
        }

        pub fn finish(self) -> VMContext {
            self.context
        }
    }

    fn context_with_key(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .finish()
    }

    fn context_with_key_future(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .block_timestamp(REQUEST_COOLDOWN + 1)
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .finish()
    }

    #[test]
    fn test_multi_3_of_n() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn test_multi_add_request_and_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request_and_confirm(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        // c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn add_key_delete_key_storage_cleared() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(1);
        let new_key: Base58PublicKey =
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        // switch accounts
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        let request2 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        // make request but don't confirm
        c.add_request(request2.clone());
        // should have 1 request now
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.get_num_requests_pk(new_key.clone()), 1);
        // self delete key
        let request3 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::DeleteKey {
                public_key: new_key.clone(),
            }],
        };
        // make request and confirm
        c.add_request_and_confirm(request3.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.get_num_requests_pk(new_key.clone()), 0);
    }

    #[test]
    #[should_panic]
    fn test_panics_add_key_different_account() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(1);
        let new_key: Base58PublicKey =
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request);
    }

    #[test]
    fn test_change_num_confirmations() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![1, 2, 3], amount));
        let mut c = MultiSigContract::new(1);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::SetNumConfirmations {
                num_confirmations: 2,
            }],
        });
        c.confirm(request_id);
        assert_eq!(c.num_confirmations, 2);
    }

    #[test]
    #[should_panic]
    fn test_panics_on_second_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 0);
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        c.confirm(request_id);
    }

    #[test]
    #[should_panic]
    fn test_panics_delete_request() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.confirmations.len(), 0);
    }

    #[test]
    fn test_delete_request_future() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        testing_env!(context_with_key_future(vec![5, 7, 9], amount));
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.confirmations.len(), 0);
    }

    #[test]
    #[should_panic]
    fn test_delete_request_panic_wrong_key() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        testing_env!(context_with_key(vec![1, 2, 3], amount));
        c.delete_request(request_id);
    }

    #[test]
    #[should_panic]
    fn test_too_many_requests() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        for _i in 0..16 {
            c.add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            });
        }
    }
}

'''
'''--- res/test/rust/staking-pool-factory/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, ext_contract, near_bindgen, AccountId, Balance, Promise, PromiseOrValue};

mod utils;
use crate::utils::*;

/// The 30 NEAR tokens required for the storage of the staking pool.
const MIN_ATTACHED_BALANCE: Balance = 30_000_000_000_000_000_000_000_000;

pub mod gas {
    use near_sdk::Gas;

    /// The base amount of gas for a regular execution.
    const BASE: Gas = 25_000_000_000_000;

    /// The amount of Gas the contract will attach to the promise to create the staking pool.
    /// The base for the execution and the base for staking action to verify the staking key.
    pub const STAKING_POOL_NEW: Gas = BASE * 2;

    /// The amount of Gas the contract will attach to the callback to itself.
    /// The base for the execution and the base for whitelist call or cash rollback.
    pub const CALLBACK: Gas = BASE * 2;

    /// The amount of Gas the contract will attach to the promise to the whitelist contract.
    /// The base for the execution.
    pub const WHITELIST_STAKING_POOL: Gas = BASE;
}

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingPoolFactory {
    /// Account ID of the staking pool whitelist contract.
    staking_pool_whitelist_account_id: AccountId,

    /// The account ID of the staking pools created.
    staking_pool_account_ids: UnorderedSet<AccountId>,
}

impl Default for StakingPoolFactory {
    fn default() -> Self {
        env::panic(b"The contract should be initialized before usage")
    }
}

/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolArgs {
    /// Owner account ID of the staking pool.
    owner_id: AccountId,
    /// The initial staking key.
    stake_public_key: Base58PublicKey,
    /// The initial reward fee fraction.
    reward_fee_fraction: RewardFeeFraction,
}

/// External interface for the callbacks to self.
#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_staking_pool_create(
        &mut self,
        staking_pool_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> Promise;
}

/// External interface for the whitelist contract.
#[ext_contract(ext_whitelist)]
pub trait ExtWhitelist {
    fn add_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool;
}

#[near_bindgen]
impl StakingPoolFactory {
    /// Initializes the staking pool factory with the given account ID of the staking pool whitelist
    /// contract.
    #[init]
    pub fn new(staking_pool_whitelist_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::is_valid_account_id(staking_pool_whitelist_account_id.as_bytes()),
            "The staking pool whitelist account ID is invalid"
        );
        Self {
            staking_pool_whitelist_account_id,
            staking_pool_account_ids: UnorderedSet::new(b"s".to_vec()),
        }
    }

    /// Returns the minimum amount of tokens required to attach to the function call to
    /// create a new staking pool.
    pub fn get_min_attached_balance(&self) -> U128 {
        MIN_ATTACHED_BALANCE.into()
    }

    /// Returns the total number of the staking pools created from this factory.
    pub fn get_number_of_staking_pools_created(&self) -> u64 {
        self.staking_pool_account_ids.len()
    }

    /// Creates a new staking pool.
    /// - `staking_pool_id` - the prefix of the account ID that will be used to create a new staking
    ///    pool account. It'll be prepended to the staking pool factory account ID separated by dot.
    /// - `owner_id` - the account ID of the staking pool owner. This account will be able to
    ///    control the staking pool, set reward fee, update staking key and vote on behalf of the
    ///     pool.
    /// - `stake_public_key` - the initial staking key for the staking pool.
    /// - `reward_fee_fraction` - the initial reward fee fraction for the staking pool.
    #[payable]
    pub fn create_staking_pool(
        &mut self,
        staking_pool_id: String,
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Promise {
        assert!(
            env::attached_deposit() >= MIN_ATTACHED_BALANCE,
            "Not enough attached deposit to complete staking pool creation"
        );

        assert!(
            staking_pool_id.find('.').is_none(),
            "The staking pool ID can't contain `.`"
        );

        let staking_pool_account_id = format!("{}.{}", staking_pool_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The staking pool account ID is invalid"
        );

        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        reward_fee_fraction.assert_valid();

        assert!(
            self.staking_pool_account_ids
                .insert(&staking_pool_account_id),
            "The staking pool account ID already exists"
        );

        Promise::new(staking_pool_account_id.clone())
            .create_account()
            .transfer(env::attached_deposit())
            .deploy_contract(include_bytes!("../../staking-pool/res/staking_pool.wasm").to_vec())
            .function_call(
                b"new".to_vec(),
                near_sdk::serde_json::to_vec(&StakingPoolArgs {
                    owner_id,
                    stake_public_key,
                    reward_fee_fraction,
                })
                .unwrap(),
                NO_DEPOSIT,
                gas::STAKING_POOL_NEW,
            )
            .then(ext_self::on_staking_pool_create(
                staking_pool_account_id,
                env::attached_deposit().into(),
                env::predecessor_account_id(),
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::CALLBACK,
            ))
    }

    /// Callback after a staking pool was created.
    /// Returns the promise to whitelist the staking pool contract if the pool creation succeeded.
    /// Otherwise refunds the attached deposit and returns `false`.
    pub fn on_staking_pool_create(
        &mut self,
        staking_pool_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> PromiseOrValue<bool> {
        assert_self();

        let staking_pool_created = is_promise_success();

        if staking_pool_created {
            env::log(
                format!(
                    "The staking pool @{} was successfully created. Whitelisting...",
                    staking_pool_account_id
                )
                .as_bytes(),
            );
            ext_whitelist::add_staking_pool(
                staking_pool_account_id,
                &self.staking_pool_whitelist_account_id,
                NO_DEPOSIT,
                gas::WHITELIST_STAKING_POOL,
            )
            .into()
        } else {
            self.staking_pool_account_ids
                .remove(&staking_pool_account_id);
            env::log(
                format!(
                    "The staking pool @{} creation has failed. Returning attached deposit of {} to @{}",
                    staking_pool_account_id,
                    attached_deposit.0,
                    predecessor_account_id
                ).as_bytes()
            );
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            PromiseOrValue::Value(false)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{testing_env, MockedBlockchain, PromiseResult};

    mod test_utils;
    use std::convert::TryInto;
    use test_utils::*;

    #[test]
    fn test_create_staking_pool_success() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(31);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_create(account_pool(), ntoy(31).into(), account_tokens_owner());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_number_of_staking_pools_created(), 1);
    }

    #[test]
    #[should_panic(expected = "Not enough attached deposit to complete staking pool creation")]
    fn test_create_staking_pool_not_enough_deposit() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        // Checking the pool is still whitelisted
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(20);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
    }

    #[test]
    fn test_create_staking_pool_rollback() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(31);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        context.account_balance += ntoy(31);
        testing_env_with_promise_results(context.clone(), PromiseResult::Failed);
        let res = contract.on_staking_pool_create(
            account_pool(),
            ntoy(31).into(),
            account_tokens_owner(),
        );
        match res {
            PromiseOrValue::Promise(_) => panic!("Unexpected result, should return Value(false)"),
            PromiseOrValue::Value(value) => assert!(!value),
        };

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);
    }
}

'''
'''--- res/test/rust/staking-pool/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}
'''
'''--- res/test/rust/voting/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::{env, near_bindgen, AccountId, Balance, EpochHeight};
use std::collections::HashMap;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

type WrappedTimestamp = U64;

/// Voting contract for unlocking transfers. Once the majority of the stake holders agree to
/// unlock transfer, the time will be recorded and the voting ends.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct VotingContract {
    /// How much each validator votes
    votes: HashMap<AccountId, Balance>,
    /// Total voted balance so far.
    total_voted_stake: Balance,
    /// When the voting ended. `None` means the poll is still open.
    result: Option<WrappedTimestamp>,
    /// Epoch height when the contract is touched last time.
    last_epoch_height: EpochHeight,
}

impl Default for VotingContract {
    fn default() -> Self {
        env::panic(b"Voting contract should be initialized before usage")
    }
}

#[near_bindgen]
impl VotingContract {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        VotingContract {
            votes: HashMap::new(),
            total_voted_stake: 0,
            result: None,
            last_epoch_height: 0,
        }
    }

    /// Ping to update the votes according to current stake of validators.
    pub fn ping(&mut self) {
        assert!(self.result.is_none(), "Voting has already ended");
        let cur_epoch_height = env::epoch_height();
        if cur_epoch_height != self.last_epoch_height {
            let votes = std::mem::take(&mut self.votes);
            self.total_voted_stake = 0;
            for (account_id, _) in votes {
                let account_current_stake = env::validator_stake(&account_id);
                self.total_voted_stake += account_current_stake;
                if account_current_stake > 0 {
                    self.votes.insert(account_id, account_current_stake);
                }
            }
            self.check_result();
            self.last_epoch_height = cur_epoch_height;
        }
    }

    /// Check whether the voting has ended.
    fn check_result(&mut self) {
        assert!(
            self.result.is_none(),
            "check result is called after result is already set"
        );
        let total_stake = env::validator_total_stake();
        if self.total_voted_stake > 2 * total_stake / 3 {
            self.result = Some(U64::from(env::block_timestamp()));
        }
    }

    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    pub fn vote(&mut self, is_vote: bool) {
        self.ping();
        if self.result.is_some() {
            return;
        }
        let account_id = env::predecessor_account_id();
        let account_stake = if is_vote {
            let stake = env::validator_stake(&account_id);
            assert!(stake > 0, "{} is not a validator", account_id);
            stake
        } else {
            0
        };
        let voted_stake = self.votes.remove(&account_id).unwrap_or_default();
        assert!(
            voted_stake <= self.total_voted_stake,
            "invariant: voted stake {} is more than total voted stake {}",
            voted_stake,
            self.total_voted_stake
        );
        self.total_voted_stake = self.total_voted_stake + account_stake - voted_stake;
        if account_stake > 0 {
            self.votes.insert(account_id, account_stake);
            self.check_result();
        }
    }

    /// Get the timestamp of when the voting finishes. `None` means the voting hasn't ended yet.
    pub fn get_result(&self) -> Option<WrappedTimestamp> {
        self.result.clone()
    }

    /// Returns current a pair of `total_voted_stake` and the total stake.
    /// Note: as a view method, it doesn't recompute the active stake. May need to call `ping` to
    /// update the active stake.
    pub fn get_total_voted_stake(&self) -> (U128, U128) {
        (
            self.total_voted_stake.into(),
            env::validator_total_stake().into(),
        )
    }

    /// Returns all active votes.
    /// Note: as a view method, it doesn't recompute the active stake. May need to call `ping` to
    /// update the active stake.
    pub fn get_votes(&self) -> HashMap<AccountId, U128> {
        self.votes
            .iter()
            .map(|(account_id, stake)| (account_id.clone(), (*stake).into()))
            .collect()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use std::collections::HashMap;
    use std::iter::FromIterator;

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        get_context_with_epoch_height(predecessor_account_id, 0)
    }

    fn get_context_with_epoch_height(
        predecessor_account_id: AccountId,
        epoch_height: EpochHeight,
    ) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 1000,
            attached_deposit: 0,
            prepaid_gas: 2 * 10u64.pow(14),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height,
        }
    }

    #[test]
    #[should_panic(expected = "is not a validator")]
    fn test_nonvalidator_cannot_vote() {
        let context = get_context("bob.near".to_string());
        let validators = HashMap::from_iter(
            vec![
                ("alice_near".to_string(), 100),
                ("bob_near".to_string(), 100),
            ]
            .into_iter(),
        );
        testing_env!(context, Default::default(), Default::default(), validators);
        let mut contract = VotingContract::new();
        contract.vote(true);
    }

    #[test]
    #[should_panic(expected = "Voting has already ended")]
    fn test_vote_again_after_voting_ends() {
        let context = get_context("alice.near".to_string());
        let validators = HashMap::from_iter(vec![("alice.near".to_string(), 100)].into_iter());
        testing_env!(context, Default::default(), Default::default(), validators);
        let mut contract = VotingContract::new();
        contract.vote(true);
        assert!(contract.result.is_some());
        contract.vote(true);
    }

    #[test]
    fn test_voting_simple() {
        let context = get_context("test0".to_string());
        let validators = (0..10)
            .map(|i| (format!("test{}", i), 10))
            .collect::<HashMap<_, _>>();
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();

        for i in 0..7 {
            let mut context = get_context(format!("test{}", i));
            testing_env!(
                context.clone(),
                Default::default(),
                Default::default(),
                validators.clone()
            );
            contract.vote(true);
            context.is_view = true;
            testing_env!(
                context,
                Default::default(),
                Default::default(),
                validators.clone()
            );
            assert_eq!(
                contract.get_total_voted_stake(),
                (U128::from(10 * (i + 1)), U128::from(100))
            );
            assert_eq!(
                contract.get_votes(),
                (0..=i)
                    .map(|i| (format!("test{}", i), U128::from(10)))
                    .collect::<HashMap<_, _>>()
            );
            assert_eq!(contract.votes.len() as u128, i + 1);
            if i < 6 {
                assert!(contract.result.is_none());
            } else {
                assert!(contract.result.is_some());
            }
        }
    }

    #[test]
    fn test_voting_with_epoch_change() {
        let validators = (0..10)
            .map(|i| (format!("test{}", i), 10))
            .collect::<HashMap<_, _>>();
        let context = get_context("test0".to_string());
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();

        for i in 0..7 {
            let context = get_context_with_epoch_height(format!("test{}", i), i);
            testing_env!(
                context,
                Default::default(),
                Default::default(),
                validators.clone()
            );
            contract.vote(true);
            assert_eq!(contract.votes.len() as u64, i + 1);
            if i < 6 {
                assert!(contract.result.is_none());
            } else {
                assert!(contract.result.is_some());
            }
        }
    }

    #[test]
    fn test_validator_stake_change() {
        let mut validators = HashMap::from_iter(vec![
            ("test1".to_string(), 40),
            ("test2".to_string(), 10),
            ("test3".to_string(), 10),
        ]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );

        let mut contract = VotingContract::new();
        contract.vote(true);
        validators.insert("test1".to_string(), 50);
        let context = get_context_with_epoch_height("test2".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.ping();
        assert!(contract.result.is_some());
    }

    #[test]
    fn test_withdraw_votes() {
        let validators =
            HashMap::from_iter(vec![("test1".to_string(), 10), ("test2".to_string(), 10)]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();
        contract.vote(true);
        assert_eq!(contract.votes.len(), 1);
        let context = get_context_with_epoch_height("test1".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.vote(false);
        assert!(contract.votes.is_empty());
    }

    #[test]
    fn test_validator_kick_out() {
        let mut validators = HashMap::from_iter(vec![
            ("test1".to_string(), 40),
            ("test2".to_string(), 10),
            ("test3".to_string(), 10),
        ]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );

        let mut contract = VotingContract::new();
        contract.vote(true);
        assert_eq!((contract.get_total_voted_stake().0).0, 40);
        validators.remove(&"test1".to_string());
        let context = get_context_with_epoch_height("test2".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.ping();
        assert_eq!((contract.get_total_voted_stake().0).0, 0);
    }
}

'''
'''--- src/lib/Lexer/Lexer.ts ---
// The main class in this module is the Tokenizer

// The Lexer translates code (a string or a file) into a list of anottated tokens ready to be parsed

// --eslint no-constant-condition: ["error", { "checkLoops": false }]*/

import "../util/String.extensions.js"

import * as logger from '../util/logger.js'

import { UTF8FileReader } from "../util/UTF8FileReader.js"

export enum TokenCode {
    BOF = 0,
    EOF,
    NEWLINE,
    WHITESPACE,
    COMMENT,
    ATTRIBUTE,
    PUNCTUATION,
    WORD,
    OPERATOR, // includes assignment, assignents are expressions in rust
    NUMBER,
    HEXANUMBER,
    BINARYNUMBER,
    LITERAL_STRING,
    LITERAL_OBJECT,
}

// ----------------------
// The Token Class
//= ==============

// Each token instance has:
// -a "type" e.g.: NEWLINE,EOF, when the token is a special char
// -a "value": the parsed text
// -the column in the source line in which the token appears

// class Token
// constructor
export class Token {
    owner: Lexer
    tokenCode: TokenCode
    value: string
    line: number
    col: number
    constructor(owner: Lexer, tokenCode: TokenCode, tokenText: string, line: number, column: number) {
        this.owner = owner
        this.tokenCode = tokenCode
        this.value = tokenText
        this.line = line
        this.col = column
    }

    // ---------------------------
    isSpace(): boolean { return this.tokenCode == TokenCode.NEWLINE || this.tokenCode == TokenCode.WHITESPACE }
    isEOF(): boolean { return this.tokenCode == TokenCode.EOF }

    // ---------------------------
    toString(): string {
        const code = TokenCode[this.tokenCode]
        if (this.tokenCode == TokenCode.BOF ||
            this.tokenCode == TokenCode.EOF ||
            this.tokenCode == TokenCode.WHITESPACE ||
            this.tokenCode == TokenCode.NEWLINE
        ) {
            return '(' + code + ')'
        }
        let v = this.value
        if (v && v.length > 20) v = v.slice(0, 17) + '...'
        return '(' + code + ' ' + v + ')'
    }

    posToString(): string {
        return `${this.owner.filename}:${this.line}:${(this.col)}`
    }

    toStringDebug(): string {
        return `${this.line}:${(this.col)} ${this.toString()}`
    }
}

//= ==============
// The Lexer Class
//= ==============
export class Lexer {
    token: Token // current token

    filename: string
    private file: UTF8FileReader
    private readString = '' // data already read from the file 
    private startedFromString = false;

    private curReadLine = 1
    private curReadCol = 1
    private cachedTokens: Token[]

    private savedPositions: Token[]

    hardError: Error
    softError: Error
    // outCode: OutCode
    private BOFToken: Token
    private EOFToken: Token

    autoSkipWhitespaceAndNewLine = true
    semiNotRequired = false

    static WHITESPACE_CHARS = ' \t\u00A0\u2028\u2029'

    /**
         * MAIN LEXER FUNCTION: recognizeToken
         * In this function you define the rules to tokenize the input stream
         * the data to analize is at: this.readString
         * this.readString have the next 4Kb from the input stream
         *
         * if the token is invalid, throw an error, else return [TokenCode, endPos]
         * where endPos is the position after the last character recognized
         *
         * */
    private recognizeToken(): [TokenCode, number] {
        // fastest recognition based on 1st char
        const char = this.readString.charAt(0)
        const twoChars: string = this.readString.slice(0, 2)

        // based on 2-chars
        switch (twoChars) {
        case "//": {
            const endOfComment = this.untilNewLine()
            return [TokenCode.COMMENT, endOfComment]
        }
        case "#[": {
            const endPos = this.findRead("]")
            return [TokenCode.ATTRIBUTE, endPos + 1]
        }
        case '\r\n': {
            return [TokenCode.NEWLINE, 2]
        }
        // rust namespace separator
        case '::': {
            return [TokenCode.PUNCTUATION, 2]
        }
        // rust range separator
        case '..': {
            return [TokenCode.OPERATOR, 2]
        }
        // rust lifetime open
        case "<'": {
            return [TokenCode.PUNCTUATION, 2]
        }
        // rust match pair: X => Y
        case '=>': {
            return [TokenCode.PUNCTUATION, 2]
        }
        // /* multiline comment
        case '/*': {
            const endPos = this.findRead("*/")
            return [TokenCode.COMMENT, endPos + 2] // includes opening /* and closing */
        }
        // rust 2-char special LITERAL_STRINGs
        // b"..." , r"..."
        case 'b"': { // byte literal string
            const quoteChar = '"'
            const endQuotePos = this.untilUnescaped(quoteChar, 2)
            // return new Token 'LITERAL_STRING'
            return [TokenCode.LITERAL_STRING, endQuotePos + 1] // includes opening (b") and closing quotes (")
        }

        // '0x' => Hexadecimal number, can inlude u64, u128
        case '0x': {
            const endPos = this.whileRanges('a-fA-F0-9u', 2)
            return [TokenCode.HEXANUMBER, endPos]
        }

        // '0b' => Binary number, , can inlude u64, u128
        case '0b': {
            const endPos = this.whileRanges('a-fA-F0-9u', 2)
            return [TokenCode.BINARYNUMBER, endPos]
        }
        }

        // based on single-char
        if (char == '\n') {
            return [TokenCode.NEWLINE, 1]
        }

        // check for NUMBER,, can inlude u64, u128
        if (char >= '0' && char <= '9') {
            let endPos = this.whileRanges('0-9._u')
            while (this.readString.charAt(endPos - 1) == '.') endPos-- // can't end in '\.*'
            return [TokenCode.NUMBER, endPos]
        }

        if (Lexer.WHITESPACE_CHARS.includes(char)) {
            const endPos = this.whileRanges(Lexer.WHITESPACE_CHARS)
            return [TokenCode.WHITESPACE, endPos]
        }

        const threeChars: string = this.readString.slice(0, 3)

        if (threeChars == 'r#"') { // raw literal string
            const endQuotePos = this.untilUnescaped('"#', 3)
            // return new Token 'LITERAL_STRING'
            return [TokenCode.LITERAL_STRING, endQuotePos + 2] // includes opening (r#") and closing quotes ("#) and \n if multiline
        }

        // rust 3-char assignment operators
        if (['<<=', '>>='].includes(threeChars)) {
            return [TokenCode.OPERATOR, 3]
        }
        // rust 3-char operators
        if (['...', '..='].includes(threeChars)) {
            return [TokenCode.OPERATOR, 3]
        }

        // rust 2-char assignment operators
        if (['*=', '+=', '-=', '/=', '^=', '|=', '%=', '&='].includes(twoChars)) {
            return [TokenCode.OPERATOR, 2]
        }
        // rust 2-char operators -- note: >> could be an operator or it could be <Hashmap<String>>
        if (['!=', '&&', '||', '->', '..', '<=', '==', '>='].includes(twoChars)) {
            return [TokenCode.OPERATOR, 2]
        }

        // assignment operator
        if (char == '=') {
            return [TokenCode.OPERATOR, 1]
        }
        // rust 1-char operators
        if ('!%&*+-/<>@^|?'.includes(char)) {
            return [TokenCode.OPERATOR, 1]
        }

        // Punctuation: () [] {} ; , . :
        if ('()[]{};,.:'.includes(char)) {
            return [TokenCode.PUNCTUATION, 1]
        }

        // String Literals can be either single or double quoted.
        // ['STRING', /^'(?:[^'\\]|\\.)*'/],
        if (char == "'" || char == '"') {
            const quoteChar = char
            const endQuotePos = this.untilUnescaped(quoteChar, 1)
            // return new Token 'LITERAL_STRING'
            return [TokenCode.LITERAL_STRING, endQuotePos + 1] // includes opening and closing quotes
        }

        // Regex tokens are regular expressions. The javascript producer, just passes the raw regex to JavaScript.
        // ['REGEX', /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/],
        // if chunk.startsWith('/') and chunk.indexOf('/',1) isnt -1
        // if (chunk.startsWith('/') && chunk.indexOf('/', 1) !== -1) {
        //    //var regexpContents = PMREX.quotedContent(chunk)
        //    var regexpContents = PMREX.quotedContent(chunk)
        //    //var regexpExpr:string = chunk.slice(0,regexpContents.length+2) //include quote-chars: / & /
        //    var regexpExpr = chunk.slice(0, regexpContents.length + 2)
        //    //var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length),"gimy")
        //    var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length), 'gimy')
        //    //return new Token('REGEX', regexpExpr & regexpFlags)
        //    return new Token('REGEX', regexpExpr + regexpFlags)
        // }

        //* *Numbers** can be either in hex format (like `0xa5b`) or decimal/scientific format (`10`, `3.14159`, or `10.02e23`).
        // As in js, all numbers are floating point.

        // ['NUMBER',/^0x[a-f0-9]+/i ],
        // ['NUMBER',/^[0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?/i],

        // Identifiers (generally variable names), must start with a letter, `$`, or underscore.
        // Subsequent characters can also be numbers. Unicode characters are supported in variable names.
        // ['IDENTIFIER',/^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/] ]
        // a IDENTIFIER starts with A-Z a-z (a unicode codepoint), $ or _

        // note we checked for numbers above
        const endIdentifier = this.whileRanges('A-Za-z0-9\x7F-\xFF$_')
        if (endIdentifier) {
            return [TokenCode.WORD, endIdentifier]
        }

        throw new Error("unrecognized token")
    }

    /**
     * helper function to get comments attached after the semicolon in the same line of a statement
     * @param separator
     */
    getAttachedCommentAfter(separator: string): string {
        this.savePosition()
        this.skipWhiteSpace()
        if (this.token.value == separator) {
            this.skipWhiteSpace()
            if (this.token.tokenCode == TokenCode.COMMENT) {
                // comment after the separator, on the same line (no NEWLINE)
                this.discardSavedPosition()
                return this.token.value
            }
        }
        // if ;//comment not found - rewind
        this.restoreSavedPosition()
    }

    /**
     * helper function consume comments, return string
     */
    consumeCommentsAndAttr(storeInList: string[]): void {
        while (this.token.tokenCode == TokenCode.COMMENT || this.token.tokenCode == TokenCode.ATTRIBUTE) {
            storeInList.push(this.token.value)
            this.advance()
        }
    }

    /**
     * Init all the options for the tokenizer
     * @param options
     */
    constructor() {
        // this.project = project

        // use same options as compiler

        this.BOFToken = new Token(this, TokenCode.BOF, '', 0, 0)
        this.EOFToken = new Token(this, TokenCode.EOF, '', 0, 0)

        // stringInterpolationChar starts for every file the same: "#"
        // can be changed in-file with `tokenizer options` directive

        // .hardError = null # stores most significative (deepest) error, when parsing fails
        this.hardError = null
    }

    // --------
    private initTokenList() {
        this.savedPositions = []
        this.cachedTokens = []
        this.token = this.BOFToken
        if (this.autoSkipWhitespaceAndNewLine) {
            this.advance()
            this.skipWhiteSpaceAndNewLine()
        }
    }

    // ---------------------------
    startFromString(code: string): void {
        this.readString = code
        this.startedFromString = true
        this.initTokenList()
    }

    get moreToRead():boolean {
        return !this.startedFromString && this.file && this.file.isOpen
    }
    // ---------------------------
    /**
     * attach a file as input for the tokenizer
     * @param filename
     */
    openFile(filename: string): void {
        this.filename = filename

        this.file = new UTF8FileReader()
        this.file.open(filename, 8 * 1024)

        this.startedFromString = false
        // read the first chunk
        this.readString = this.file.readChunk()
        // start with Token:BOF
        this.initTokenList()
    }

    // ---------------------------
    savePosition():void {
        this.savedPositions.push(this.token)
    }

    // ---------------------------
    discardSavedPosition(): void {
        this.savedPositions.pop() // discard saved pos
    }

    // ---------------------------
    /**
     * rewind the token stream to the last saved position
     * */
    restoreSavedPosition(): void {
        if (this.savedPositions.length == 0) throw new Error("restoreSavedPosition(): this.savedPositions.length==0")
        this.token = this.savedPositions.pop() // go back to saved position
    }

    // ------------------------------
    prevToken(n:number = 1): Token {
        // veo si el actual está en el cache
        const inxInCached = this.indexInCached()
        if (inxInCached <= n - 1) { // si n=1 y esta en el index 0 (o no está), no se puede
            throw new Error("Cant read previous [current - " + n + "] token")
        }
        // return tok at [current-n]
        return this.cachedTokens[inxInCached - n]
    }

    // ---------------------------
    rewind(n:number = 1):void {
        const prev = this.prevToken(n)
        // do rewind
        this.token = prev
        logger.debug('<<REW -' + n, this.token.toStringDebug())
    }

    // ---------------------------
    private cacheOneMoreToken(): Token {
        const newToken = this.readNewToken()
        this.cachedTokens.push(newToken)
        return newToken
    }

    // ---------------------------
    private indexInCached() {
        // search if current token is in cached (from the last one to the first)
        for (let inx = this.cachedTokens.length - 1; inx >= 0; inx--) {
            const t = this.cachedTokens[inx]
            if (t.line == this.token.line && t.col == this.token.col) return inx
        }
        return -1
    }

    // ---------------------------
    /**
     * peek next token
     * */
    nextToken(): Token {
        // veo si está en el cache
        const inxInCached = this.indexInCached()
        if (inxInCached > 0 && inxInCached + 1 < this.cachedTokens.length) {
            return this.cachedTokens[inxInCached + 1]
        }
        // si no está agrego uno al cache y retorno ese
        return this.cacheOneMoreToken()
    }

    // ---------------------------
    skipWhiteSpaceAndNewLine():void {
        // skip newlines & whitespace
        while (this.token.tokenCode == TokenCode.NEWLINE || this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken()
        }
    }

    // ---------------------------
    skipNewLines():void {
        // skip newlines
        while (this.token.tokenCode == TokenCode.NEWLINE) {
            this.token = this.nextToken()
        }
    }

    // ---------------------------
    skipWhiteSpace():void {
        // skip whitespace
        while (this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken()
        }
    }

    // ---------------------------
    advance(): string {
        if (this.token.tokenCode == TokenCode.EOF) throw ("asked for a token after EOF")
        // set next as current
        this.token = this.nextToken()
        if (this.autoSkipWhitespaceAndNewLine) this.skipWhiteSpaceAndNewLine()
        return this.token.value
    }

    // --------------------------
    curPosString(): string {
        return this.curReadLine + ':' + this.curReadCol
    }

    // --------------------------
    private consumeStringFromRead(endPos: number): string {
        const result = this.readString.slice(0, endPos)
        this.readString = this.readString.slice(endPos)
        if (this.moreToRead && this.readString.length < 8 * 1024 ) {
            this.readString += this.file.readChunk()
        }
        return result
    }

    // --------------------------
    /**
     * returns position in this.readString or this.readString.length if not found
     * @param what what to search
     */
    private findRead(what: string): number {
        let start=0
        let foundPos=-1
        while (foundPos<0) {
            foundPos = this.readString.indexOf(what, start)
            if (foundPos < 0) {
                if (!this.moreToRead) throw Error(`can not find: ${what} starting at ${this.curReadLine}`)
                start = this.readString.length
                this.readString += this.file.readChunk()
            }
        }
        return foundPos
    }

    // --------------------------
    /**
     * creates a new token from @endPos chars from readLine
     * and also advances curLine and curCol
     * @param type
     * @param endPos
     */
    private createTokenUpToPos(type: TokenCode, endPos: number): Token {
        const result = new Token(this, type, this.consumeStringFromRead(endPos), this.curReadLine, this.curReadCol)
        if (type == TokenCode.NEWLINE) {
            this.curReadLine++
            this.curReadCol = 0
        } else if (type == TokenCode.COMMENT || type == TokenCode.LITERAL_STRING ) {
            const internalNewLinesCount = result.value.split(/\r\n|\r|\n/).length
            if (internalNewLinesCount) {
                this.curReadLine += internalNewLinesCount - 1
                this.curReadCol = 0
            }
        } else {
            this.curReadCol += endPos
        }

        // #debug
        if (logger.debugLevel) logger.debug('>>>READ', `${result.line}:${result.col}`, result.toString())

        return result
    }

    // --------------------------
    private untilNewLine(): number {
        let endPos = this.findRead("\n")
        if (this.readString.charAt(endPos - 1) == '\r') endPos--
        if (endPos<0) endPos = this.findRead.length 
        return endPos
    }

    // --------------------------
    private readNewToken(): Token {
        if (this.readString.length == 0) return this.EOFToken

        try {
            const [tokenCode, endPos] = this.recognizeToken()
            return this.createTokenUpToPos(tokenCode, endPos)
        } catch (ex) {
            // add current position to error message
            throw new Error(ex.message + ` ${this.filename}:${this.curReadLine}:${(this.curReadCol)}`)
        }
    }

    // ---------------------------
    //   function whileUnescaped(chunk:string,endChar:string) returns number
    // ---------------------------
    /**
     *  returns position of unescaped endChar, starting from start
     * @param endChar
     * @param fromPos
     */
    untilUnescaped(endChar: string, fromPos: number) :number {
        // advance until unescaped endChar
        // return pos of endChar
        // throws id endChar not found

        // var pos = 0
        let pos = fromPos
        while (true) {
            // find the next quote
            const inx = this.readString.indexOf(endChar, pos)
            // if inx is -1, fail with 'missing closing quote-char: #{endChar} ' // closer not found
            if (inx === -1) { throw new Error(`missing closing quote-char: ${endChar}`) }

            // quote found
            pos = inx

            // check if escaped with '\'
            if (inx > 0 && this.readString.charAt(inx - 1) === '\\') {
                // seems escaped, let's see if the escape is escaped
                let countEscape = 1
                while (inx > countEscape && this.readString.charAt(inx - 1 - countEscape) === '\\') {
                    countEscape++
                }
                // how many escapes?
                if (countEscape % 2 === 0) { // even, means escaped-escapeChar, means: not escaped
                    break // we found the closing quote
                } else {
                    // odd number means escaped quote, so it's not the closing quote yet
                    pos = inx + 1
                }
            } else {
                // not escaped
                break // we found the closing quote
            }
        }// loop looking for the closing quote

        return pos
    }

    /**
     * Helper functions. simplified regex over this.readString
     * @param rangesStr
     */
    static parseRanges(rangesStr:string): string {
        // Range examples:

        //* "1-9" means all chars between 1 and 9 (inclusive)
        //* "1-9J-Z" means all chars between 1 and 9 or between "J" and "Z"
        //* "1-9JNW" means all chars between 1 and 9, a "J" a "N" or a "W"

        // This function returns a normalized range string without "-"
        // and composed always from ranges:
        //
        //    "1-9" => "19"
        //    "1-9J-Z" => "19JZ"
        //    "1-9JNW" => "19JJNNWW"

        // var result = ""
        let result = ''

        let ch
        let inx = 0
        while (inx < rangesStr.length) {
            ch = rangesStr.charAt(inx)
            result += ch
            if (rangesStr.charAt(inx + 1) === '-') {
                inx++
                result += rangesStr.charAt(inx + 1)
            } else {
                result += ch // same char twice
            }
            inx++
        }

        return result
    }

    whileRanges(rangesStr: string, startPos = 0): number {
        // whileRanges, advance while the char is in the ranges specified.
        // will return pos of first char not in range, or entire string if all chars are in ranges
        // e.g.: whileRanges("123ABC","0-9") will return 3:"A"
        // e.g.: whileRanges("123ABC","0-9A-Z") will return 6:{EOS} because all chars are in range

        const len = this.readString.length

        // normalize ranges
        const ranges = Lexer.parseRanges(rangesStr)

        // advance while in any of the ranges
        let inx = startPos
        // do while inx<len
        while (inx < len) {
            const ch = this.readString.charAt(inx)
            let isIn = false
            // check all ranges
            const upTo = ranges.length - 1
            for (let r = 0; r <= upTo; r += 2) {
                if (ch >= ranges.charAt(r) && ch <= ranges.charAt(r + 1)) {
                    isIn = true
                    break
                }
            }

            if (!isIn) { break }
            inx++
        }

        return inx
    }
}

'''
'''--- src/lib/Parser/ASTBase.ts ---

// This module defines the base abstract syntax tree node used by the grammar.
// It's main purpose is to provide utility methods used in the grammar
// for **req**uired tokens, **opt**ional tokens
// and comma or semicolon **Separated Lists** of symbols.

import { TokenCode } from '../Lexer/Lexer'
import { ControlledError } from '../util/ControlledError'

import * as logger from '../util/logger.js'
import { Parser } from './Parser'
import { TypeAnnotation } from './Grammar'
import { EOL } from 'os'

export class ASTBase {
    owner: Parser
    parent: ASTBase
    children: ASTBase[] = []
    keyword: string
    name: string
    typeAnnotation: TypeAnnotation
    // AST node position in source
    sourceLineNum
    sourceColumn
    // wile-parsing info
    locked: boolean
    commentsAndAttr: string[] // comments and #attributes
    attachedComment: string
    // extraInfo // if parse failed, extra information
    extraInfo
    isPublic: boolean = false
    isMut: boolean = false
    isRef: boolean
    decorators: string[]
    nativeSuffixes: ASTBase // to_vec, as_u128, .map, .collect etc.
    deRef: boolean

    constructor(parent:ASTBase, name:string) { 
        this.parent = parent
        this.name = name

        // Get owner from parent
        if (parent) {
            this.owner = parent.owner

            // Remember this node source position.
            // Also remember line index in tokenized lines, and indent
            if (this.owner) {
                // this.sourceLineNum = this.lexer.sourceLineNum
                // this.column = this.lexer.token.column
                // this.indent = this.lexer.indent
                // this.lineInx = this.lexer.lineInx
            }
        }
    }

    // ---------------------------
    lock():void {
        //* *lock** marks this node as "locked", meaning we are certain this is the right class
        // for the given syntax. For example, if the `FunctionDeclaration` class see the token `function`,
        // we are certain this is the right class to use, so we 'lock()'.
        // Once locked, any **req**uired token not present causes compilation to fail.

        // .locked = true
        this.locked = true
    }

    // ---------------------------
    // @ts-ignore
    // getParent(searchedClass):ASTBase { 
    //     //* *getParent** method searchs up the AST tree until a specfied node class is found

    //     // var node = this.parent
    //     let node = this.parent
    //     // while node and node isnt instance of searchedClass
    //     while (node && !(node instanceof searchedClass)) {
    //         // node = node.parent # move to parent
    //         node = node.parent
    //     }// end loop
    //     // return node
    //     return node
    // }

    // ---------------------------
    positionText() :string{
        if (!this.owner) { return '(compiler-defined)' }
        return `${this.owner.lexer.filename}:${this.sourceLineNum}:${this.sourceColumn || 0}`
    }

    // ---------------------------
    toString():string {
        return `[${this.constructor.name}]` + (this.keyword ? this.keyword + ' ' : '') + this.name
    }

    // ---------------------------
    sayErr(msg:string) :void{
        logger.error(this.positionText(), msg)
    }

    // ---------------------------
    warn(msg:string) :void{
        logger.warning(this.positionText(), msg)
    }

    // ---------------------------
    throwError(msg:string) :void{
        //* *throwError** add node position info and throws a 'controlled' error.

        // A 'controlled' error, shows only err.message

        // A 'un-controlled' error is an unhandled exception in the compiler code itself,
        // and it shows error message *and stack trace*.

        logger.throwControlled(`${this.positionText()}. ${msg}`)
    }

    // ---------------------------
    throwParseFailed(msg:string):void {
        // throws a parseFailed-error

        // During a node.parse(), if there is a token mismatch, a "parse failed" is raised.
        // "parse failed" signals a failure to parse the tokens from the stream,
        // however the syntax might still be valid for another AST node.
        // If the AST node was locked-on-target, it is a hard-error.
        // If the AST node was NOT locked, it's a soft-error, and will not abort compilation
        // as the parent node will try other AST classes against the token stream before failing.

        // var cErr = new ControlledError("#{.lexer.posToString()}. #{msg}")
        const cErr = new ControlledError(`${this.owner.lexer.token.posToString()}. ${msg}`)
        cErr.soft = !(this.locked)
        throw cErr
    }

    // ---------------------------
    parse():void {
        // abstract method representing the TRY-Parse of the node.
        // Child classes _must_ override this method
        this.throwError('ASTBase parse is abstract')
    }

    // ---------------------------
    /** produce():string is the method to produce target code for this node.
     * derived classes _should_ override this, if the default production isnt: this.name
     * Default behavior is to
     * recursively produce the entire sub-tree to a UTF file
     *
     */
    produce(): void {
        this.owner.codeWriter.write(this.name)
        this.produceChildren()
    }

    produceChildren(separator?:string): void {
        const o = this.owner.codeWriter
        let inx = 0
        for (const child of this.children) {
            if (inx > 0 && separator) o.write(separator)
            if (separator && separator.includes(EOL)) o.write(' '.repeat(o.indent))
            child.writeComments()
            child.produce()
            inx++
        }
        // if (separator == EOL) o.write(separator)
    }

    /**
     * output all node children as the body of a function
     * indented, one on each line
     * */
    produceBody(indent: number = 4): void {
        const o = this.owner.codeWriter
        o.newLine()
        o.indent += indent
        for (const child of this.children) {
            child.writeComments()
            child.produce()
            o.newLine()
        }
        o.indent -= indent
    }

    writeComments(watchForThis?: string): boolean {
        let result = false
        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (const s of this.commentsAndAttr) {
                if (!s.startsWith("/")) this.owner.codeWriter.write('//')
                if (watchForThis && watchForThis == s) result = true
                this.owner.codeWriter.writeLine(s)
            }
        }
        return result
    }

    // --- helper
    tokVal(): string {
        return this.owner.lexer.token.value
    }

    // ---------------------------
    // parseDirect(key, directMap) {

    //    //We use a DIRECT associative array to pick the exact AST node to parse
    //    //based on the actual token value or type.
    //    //This speeds up parsing, avoiding parsing by trial & error

    //    //Check keyword

    //    //if directMap.get(key) into var param
    //    let param = directMap[key]
    //    if (param) {
    //        //try parse by calling .opt
    //        let statement = undefined
    //        if (param instanceof Array) {
    //            //#accept Arrays also
    //            statement = this.optList(param)
    //        }
    //        else {
    //            //#normal call
    //            statement = this.optList([param])
    //        }
    //        //return parsed statement or nothing
    //        return statement
    //    }
    // }

    // ---------------------------
    optList(list: (string | number | typeof ASTBase)[]): string | ASTBase {
        //* *opt** (optional) parses optional parts of a grammar. It attempts to parse
        // the token stream using one of the classes or token types specified.
        // This method takes a variable number of arguments.
        // For example:
        // calling `.opt IfStatement, Expression, 'IDENTIFIER'`
        // would attempt to parse the token stream first as an `IfStatement`. If that fails, it would attempt
        // to use the `Expression` class. If that fails, it will accept a token of type `IDENTIFIER`.
        // If all of those fail, it will return `undefined`.

        // Method start:

        const t = this.owner.lexer.token
        // For each argument, -a class or a string-, we will attempt to parse the token stream
        // with the class, or match the token type to the string.

        // Remember the actual position, to rewind if parse soft-fails
        this.owner.lexer.savePosition()

        // for each searched in arguments.toArray()
        for (const searched of list) {
            // skip empty, null & undefined
            if (!searched) { continue }

            let found: boolean = false

            // For strings, we check the token **value**
            if (typeof searched === 'string') {
                const searchedString: string = searched
                found = (t.value == searchedString)
                if (found && logger.debugLevel) {
                    logger.debug(this.constructor.name, 'matched OK:', searched, t.value)
                }
            }

            // For numbers, we assume it's a TokenCode
            else if (typeof searched === 'number') { // it's a TokenCode
                const searchedToken: TokenCode = searched as TokenCode
                found = (t.tokenCode == searchedToken)
                if (found && logger.debugLevel) {
                    logger.debug(this.constructor.name, 'matched OK:', TokenCode[searchedToken], t.value)
                }
            }

            if (found) { // simple string/Token match
                // Ok, type/value found! now we return: token.value
                // Note: we shouldn't return the 'token' object, because returning objects (here and in js)
                // is "pass-by-reference" for the object members. You return a "pointer" to the object.
                // If we return the 'token' object, the calling function will recive a "pointer"
                // and it can inadvertedly alter the token object members in the token stream. (it should not, leads to subtle bugs)

                // Consume this token
                this.owner.lexer.advance()
                // discard saved position
                this.owner.lexer.discardSavedPosition()
                // return token value
                return t.value
            } else if (typeof searched === 'function') { // it's a Grammar class
                const searchedClass = searched as (typeof ASTBase)

                logger.debug(this.constructor.name, 'TRY', searchedClass.name, 'on', t.toString())

                // if the argument is an AST node class, we instantiate the class and try the `parse()` method.
                // `parse()` can throw `ParseFailed` if the syntax do not matches the parse

                try {
                    // create required ASTNode, to try method parse()
                    const astNode = new searchedClass(this, t.value)
                    astNode.sourceLineNum = t.line
                    astNode.sourceColumn = t.col

                    // if it can't parse, will raise an exception
                    astNode.parse()

                    // logger.debug spaces, 'Parsed OK!->',searched.name
                    logger.debug('Parsed OK!->', searchedClass.name)

                    // discard saved position
                    this.owner.lexer.discardSavedPosition()
                    // parsed ok!, return instance
                    return astNode
                } catch (err) {
                    if (!(err instanceof ControlledError)) { // non-controlled error
                        // discard saved position
                        this.owner.lexer.discardSavedPosition()
                        throw err
                    }

                    // If parsing fail, but the AST node was not 'locked' on target, (that is, if it was a "soft" exception),
                    // we try other AST nodes.

                    // if err.soft => no match, try next
                    if (err.soft) {
                        this.owner.lexer.softError = err
                        logger.debug(searchedClass.name, 'parse failed.', err.message)
                        // rewind the token stream, to try other AST nodes
                        this.owner.lexer.restoreSavedPosition()
                        logger.debug('<<REW to', this.owner.lexer.token?.toStringDebug())
                    } else {
                        // else: it's a hard-error. The AST node were locked-on-target.
                        // We abort parsing and throw.

                        // discard saved position
                        this.owner.lexer.discardSavedPosition()

                        // # the first hard-error is the most informative, the others are cascading ones
                        // if .lexer.hardError is null, .lexer.hardError = err
                        if (this.owner.hardError === null) { this.owner.hardError = err }

                        // raise up, abort parsing
                        throw err
                    } // end if - type of error
                }// end catch
            }// end if - string/TokenCode/ASTclass
        }// end loop - try the next argument

        // No more arguments.

        // discard saved position
        this.owner.lexer.discardSavedPosition()

        // `opt` returns `undefined` if none of the arguments can be use to parse the token stream.
        return undefined
    }

    // ---------------------------
    opt(singleItem: string | typeof ASTBase): string | ASTBase {
        return this.optList([singleItem])
    }

    // ---------------------------
    /**
     * Require one of a list
     *
     * @param list to try parsing, in order, one of the list must parse
     */
    reqList(list: (string | number | typeof ASTBase)[]): string | ASTBase {
        //* *req** (required) try to parse *required* symbols of the grammar.
        // It works the same way as `opt` except that it throws an error if none of the arguments
        // can be used to parse the stream.

        // We first call `opt` to try the arguments in order.
        // If a value is returned, the parsing was successful,
        // so we just return the node that `opt` found.
        const result = this.optList(list)

        // If `opt` returned "undefined" (no match), we give the user a useful error message.
        if (!result) {
            this.throwParseFailed(`${this.constructor.name}:${this.extraInfo || ''} found ${this.owner.lexer.token.toString()} but ${ASTBase.listToString(list)} required`)
        }
        return result
    }

    // ---------------------------
    req(item: string): string {
        return this.reqList([item]) as string
    }

    // ---------------------------
    reqClass(ASTClass: typeof ASTBase): ASTBase {
        return this.reqList([ASTClass]) as ASTBase
    }

    // ---------------------------
    reqChild(ASTClass: typeof ASTBase): void {
        this.children.push(this.reqList([ASTClass]) as ASTBase)
    }

    optChild(ASTClass: typeof ASTBase): void {
        const result = this.opt(ASTClass) as ASTBase
        if (result) {
            this.children.push(result)
        }
    }

    // ---------------------------
    reqToken(tokenCode: TokenCode): string {
        return this.reqList([tokenCode]) as string
    }

    // ---------------------------
    reqOneOf(list: string[]): string {
        // (performance) check before try to parse, that the next token is in the list
        // if .lexer.token.value in arr
        if (list.includes(this.owner.lexer.token.value)) {
            return this.reqList(list) as string
        } else {
            this.throwParseFailed('not in list')
        }
    }

    /**
     * a [separator] separated list of [astClass] ended by [closer]
     *
     * the last closer is consumed
     *
     * @param astClass
     * @param separator
     * @param closer
     */
    // ---------------------------
    optSeparatedList(astClass: typeof ASTBase, separator: string, closer: string): ASTBase[] {
        // Start optSeparatedList
        // normal separated list,
        // loop until closer found

        const result: ASTBase[] = []

        logger.debug(`optSeparatedList [${this.constructor.name}] get SeparatedList of [${astClass.name}] by '${separator}' closer:`, closer || '-no closer-')

        const startLine = this.owner.lexer.token.line

        while (true) {
            if (this.owner.lexer.token.tokenCode == TokenCode.EOF) break // break on EOF
            if (closer && this.opt(closer)) break // if closer set, and closer found, break

            // pre comments and attrs
            const preComments: string[] = []
            this.owner.lexer.consumeCommentsAndAttr(preComments)

            // get an item
            const item = this.reqClass(astClass) as ASTBase
            this.lock()

            // add item to result
            result.push(item)

            item.commentsAndAttr = preComments
            // post comments and attr - NO, se come pre comments del siguiente
            // this.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr )

            // if .opt(closer) then break #closer found
            if (this.opt(closer)) { break }

            // here, a 'separator' (comma/semicolon) means: 'there is another item'.
            // Any token other than 'separator' means 'end of list'

            // if no .opt(separator)
            if (!this.opt(separator)) {
                // # any token other than comma/semicolon means 'end of comma separated list'
                // # but if a closer was required, then "other" token is an error
                // if closer, .throwError "Expected '#{closer}' to end list started at line #{startLine}, got '#{.lexer.token.value}'"
                if (closer) {
                    if (this.owner.lexer.semiNotRequired) {
                        // after blocks separators are not required
                        this.owner.lexer.semiNotRequired = false
                        continue
                    }
                    this.throwError(`Expected '${closer}' to end list started at line ${startLine}, got '${this.owner.lexer.token.value}'`)
                }
                break
            }
        }// try another item after the separator

        if (closer == '}') this.owner.lexer.semiNotRequired = true // semicolon not required if list closed by '}'

        return result
    }

    // ---------------------------
    reqSeparatedList(astClass: typeof ASTBase, separator: string, closer: string): ASTBase[] {
        //* *reqSeparatedList** is the same as `optSeparatedList` except that it throws an error
        // if the list is empty

        // First, call optSeparatedList
        const result = this.optSeparatedList(astClass, separator, closer)
        if (result.length === 0) { this.throwParseFailed(`${this.constructor.name}: Get list: At least one [${astClass.name}] was expected`) }

        return result
    }

    // ------------------------
    optPub():void {
        // manage special prefixes like 'pub'
        if (this.owner.lexer.token.value == 'pub') {
            this.isPublic = true
            this.owner.lexer.advance()
        }
    }

    optRef():void {
        // manage special prefixes like '&'
        if (this.owner.lexer.token.value == '&') {
            this.isRef = true
            this.owner.lexer.advance()
        }
    }

    optDeRef():void {
        // manage special prefixes like '*'
        if (this.owner.lexer.token.value == '*') {
            this.deRef = true
            this.owner.lexer.advance()
        }
    }

    optMut():void {
        // manage special prefixes like 'mut'
        if (this.owner.lexer.token.value == 'mut') {
            this.isMut = true
            this.owner.lexer.advance()
        }
    }

    optDecorators():void {
        // manage decorators like #[callback]
        if (this.owner.lexer.token.value == '#' && this.owner.lexer.nextToken().value == "[") {
            this.owner.lexer.advance()
            this.owner.lexer.advance()
            if (!this.decorators) this.decorators = []
            this.decorators.push(this.owner.lexer.token.value)
            this.req("]")
        }
    }

    // ---------------------------
    /**
     * Helper function toString of an argument list to opt() or req()
     * @param args
     */
    static listToString(args: (string | number | typeof ASTBase)[]) :string {
        // listArgs list arguments (from opt or req). used for debugging
        // and syntax error reporting

        // var msg = []
        const msg = []
        // for each i in args
        for (const i of args) {
            // if typeof i is 'string'
            if (typeof i === 'string') {
                msg.push(`'${i}'`)
            } else if (i) {
                if (typeof i === 'function') {
                    msg.push(`[${i.name}]`)
                } else if (typeof i === 'number') {
                    msg.push(`[${TokenCode[i]}]`)
                } else {
                    msg.push(`<${i}>`)
                }
            } else {
                msg.push('[null]')
            }
        }
        return msg.join('|')
    }

    // ---------------------------
    /*
    out(list: (string | object | ASTBase)[]) {

        //*out* is a helper function for code generation
        //It evaluates and output its arguments. uses .lexer.out

        var rawOut = .lexer.outCode
        const rawOut = this.owner.outCode

        //for each item in arguments.toArray()
        for (const item of list) {

            //skip empty items
            //if no item, continue
            if (!item) { continue }

            //if it is the first thing in the line, out indentation

            //if rawOut.currLine.length is 0  and .indent > 0
            //if (rawOut.currLine.length === 0 && this.indent > 0) {
            //    //rawOut.put String.spaces(.indent)
            //    rawOut.put(' '.repeat(this.indent))
            //}

            //if it is an AST node, call .produce()

            //if item instance of ASTBase
            if (item instanceof ASTBase) {
                item.produce()
            }

            else if (item === '\n') {
                rawOut.startNewLine()
            }

            else if (typeof item === 'string') {
                rawOut.put(item)
            }
            else if (item instanceof Array) {

                //# Recursive #
                this.out(item)
            }

            else if (item instanceof Object) {

                // expected keys:
                //  COMMENT:string, NLI, CSL:Object array, freeForm, h

                //{CSL:arr} -> output the array as Comma Separated List (note: CSL can be present and undefined)

                //if item.hasProperty('CSL')
                let comment = undefined
                //var header = undefined
                if ("CSL" in item) {
                    const CSL = item["CSL"]
                    // additional keys: pre,post,separator
                    const separator = item['separator'] || ', '
                    //var freeFormMode = item.tryGetProperty('freeForm')
                    const newLineIncluded = false
                    //var actualIndent = rawOut.getIndent()

                    //for each inx,listItem in CSL
                    let inx = 0;
                    for (const listItem in CSL as object) {
                        if (inx > 0) {
                            rawOut.put(separator)
                        }
                        inx++
                        //#recurse
                        this.out([item['pre'], listItem, item['post']])
                    }

                    //if newLineIncluded # prettier generated code
                    if (newLineIncluded) {
                        //rawOut.startNewLine
                        rawOut.startNewLine()
                    }
                }

                else if ((comment = item['COMMENT']) != undefined) {
                    //# prepend // if necessary
                    if (typeof item !== 'string' || !(comment.startsWith('//'))) { rawOut.put('// ') }
                    this.out(comment)
                }

                else {
                    this.sayErr(`ASTBase method out Map|Object: unrecognized keys: ${item}`)
                }
            }

            else {
                rawOut.put(item as string)
            }

        }//end loop, next item

    }

    /*
    // ---------------------------
    outPreviousComments = function () {

        //out previous lines with comments

        //if no .sourceLineNum, return // if undefined or 0
        if (!this.sourceLineNum) { return }

        //search CODE line, immediatly previous to this
        //var prevCODElineInx = .lexer.getPrevCODEInfoLineIndex(.sourceLineNum)
        var prevCODElineInx = this.lexer.getPrevCODEInfoLineIndex(this.sourceLineNum)

        //search line previous to this (any type)
        //var endAtInx = .lexer.getInfoLineIndex(.sourceLineNum-1)
        var endAtInx = this.lexer.getInfoLineIndex(this.sourceLineNum - 1)

        // print in-between lines (comments & blank lines)
        //for lineInx=prevCODElineInx+1 to endAtInx
        var _end1 = endAtInx
        for (var lineInx = prevCODElineInx + 1; lineInx <= _end1; lineInx++) {
            //.outInfoLineAsComment lineInx
            this.outInfoLineAsComment(lineInx)
        }// end for lineInx

    }
    // ---------------------------
    outSourceLinesAsComment = function (upTo, fromLineNum) {

        //if no .lexer.options.comments, return
        if (!this.lexer.options.comments) { return }

        //default fromLineNum = .sourceLineNum // this statement
        if (fromLineNum === undefined) fromLineNum = this.sourceLineNum
        //default upTo = .sourceLineNum // this statement
        if (upTo === undefined) upTo = this.sourceLineNum

        //var startAtInx = .lexer.getInfoLineIndex(fromLineNum)
        var startAtInx = this.lexer.getInfoLineIndex(fromLineNum)
        //var endAtInx = .lexer.getInfoLineIndex(upTo)
        var endAtInx = this.lexer.getInfoLineIndex(upTo)

        //for lineInx=startAtInx to endAtInx
        var _end2 = endAtInx
        for (var lineInx = startAtInx; lineInx <= _end2; lineInx++) {
            //.outInfoLineAsComment lineInx
            this.outInfoLineAsComment(lineInx)
        }// end for lineInx

    }
    // ---------------------------

    levelIndent() {
        //show indented messaged for debugging

        //var indent = 0
        var indent = 0
        //var node = this
        var node = this.parent
        //while node.parent into node
        while (node) {
            //indent += 2 //add 2 spaces
            indent += 2
            node = node.parent
        }// end loop

        //return String.spaces(indent)
        return ' '.repeat(indent)
    }
    */
}

'''
'''--- src/lib/Parser/CodeWriter.ts ---
// public helper class CodeWriter

import * as fs from 'fs'
import * as mkPath from '../util/mkPath'
import { assert } from 'console'
import { EOL } from 'os'

export type CodeWriterData = {
    nickname?:string
}

export class CodeWriter {
    lineNum: number
    column: number
    currLine: string[]

    fileMode = true
    filenames = ['', '', '']
    fileIsOpen = [false, false, false]
    fHandles = [null, null, null]
    selectedStream: number = 0

    indent: number =0

    lines
    browser: boolean
    exportNamespace: boolean
    public data: CodeWriterData

    // ---------------------------
    constructor(fn1: string, data: CodeWriterData, fn2: string = '', fn3: string = '') {
        this.filenames = [fn1, fn2, fn3]
        this.data = data
        // Initialize output array
        this.lineNum = 1
        this.column = 1
        this.currLine = []
        this.lines = [[], [], []]
    }

    // ---------------------------
    selectOutStream(index: 0|1|2) :void {
        this.newLine()
        this.selectedStream = index
    }

    // ---------------------------
    write(text: string) :void{
        // put a string into produced code
        if (text) {
            this.currLine.push(text)
            this.column += text.length
        }
    }

    // ---------------------------
    writeLine(text: string) :void{
        this.write(text)
        this.newLine()
    }

    // ---------------------------
    getIndent() :number{
        // if no .currLine.length, return 0
        if (!this.currLine.length) { return 0 }
        return this.currLine[0].countSpaces()
    }

    // ---------------------------
    newLine() :void{
        // Start New Line into produced code
        // send the current line
        if (this.currLine.length) {
            if (this.fileMode) {
                if (!this.fileIsOpen[this.selectedStream]) {
                    // make sure output dir exists
                    const filename = this.filenames[this.selectedStream]
                    assert(filename)
                    mkPath.toFile(filename)
                    // open output file
                    this.fHandles[this.selectedStream] = fs.openSync(filename, 'w')
                    this.fileIsOpen[this.selectedStream] = true
                }

                const fd = this.fHandles[this.selectedStream]
                // save all the parts to file
                if (this.indent > 0) fs.writeSync(fd, ' '.repeat(this.indent))
                // for each part in .currLine
                for (const part of this.currLine) {
                    fs.writeSync(fd, part)
                }
                // close the line: "\n"
                fs.writeSync(fd, EOL)
            } else {
                // not fileMode
                // store in array
                this.lines[this.selectedStream].push(this.currLine.join(''))
            }

            if (this.selectedStream === 0) {
                this.lineNum++
            }
        }

        this.clearCurrentLine()
    }

    // ----------------------------
    // clear current working line
    clearCurrentLine() :void{
        // clear current line
        this.currLine = []
        this.column = 1
    }

    // ----------------------------
    // return current working line
    getCurrentLine() :string{
        return this.currLine.join("")
    }

    // ---------------------------
    ensureNewLine() :void{
        // if there's something on the line, start a new one
        if (this.currLine.length) { this.newLine() }
    }

    // ---------------------------
    blankLine() :void{
        this.newLine()
        this.currLine.push('')
        this.newLine()
    }

    // ---------------------------
    getResult(inx: 0|1|2 = 0) : string{
        // get result and clear memory

        if (inx === undefined) inx = 0

        this.selectedStream = inx
        // #close last line
        this.newLine()
        return this.lines[inx]
    }

    // ---------------------------
    close() :void{
        // save last pending line
        this.newLine()

        if (this.fileMode) {
            for (let inx = 0; inx <= 2; inx++) {
                if (this.fileIsOpen[inx]) {
                    fs.closeSync(this.fHandles[inx])
                    this.fileIsOpen[inx] = false
                }
            }
        }
    }
}

'''
'''--- src/lib/Parser/Grammar.ts ---
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/*
 * This Grammar is based on [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
 * *with extensions*.
*/

// Grammar Meta-Syntax
// -------------------

// Each Grammar class, contains a 'grammar definition' as reference.
// The meta-syntax for the grammar definitions is an extended form of
// [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)

// The differences with classic PEG are:
//* instead of `Symbol <- definition`, we use `Symbol: definition` (colon instead of arrow)
//* we use `[Symbol]` for optional symbols instead of `Symbol?` (brackets also groups symbols, the entire group is optional)
//* symbols upper/lower case has meaning
//* we add `(Symbol,)` for `comma separated List of` as a powerful syntax option

// Meta-Syntax Examples:

// `function`     : all-lowercase means the literal word: "function"<br>
// `":"`              : literal symbols are quoted<br>
// `ReturnStatement`  : CamelCase is reserved for composed, non-terminal symbol<br>

// `IDENTIFIER`,`OPER` : all-uppercase denotes a entire class of symbols<br>
// `NEWLINE`,`EOF`     : or special unprintable characters<br>

// `[to]`               : Optional symbols are enclosed in brackets<br>
// `(var|let)`          : The vertical bar represents ordered alternatives<br>

// `(Oper Operand)`     : Parentheses groups symbols<br>
// `(Oper Operand)*`    : Asterisk after a group `()*` means the group can repeat (meaning one or more)<br>
// `[Oper Operand]*`    : Asterisk after a optional group `[]*` means *zero* or more of the group.<br>

// `[Expression,]` : means: "optional comma separated list of Expressions".<br>
// `Body: (Statement;)` : means "Body is a semicolon-separated list of statements".<br>

// Full Meta-Syntax Example:

// `PrintStatement: print [Expression,]`

// It reads: composed symbol `PrintStatement` is conformed by the word `print` followed by
// an _optional_ comma-separated list of `Expression`

// ###More on comma-separated lists

// Let's analyze the example: `PrintStatement: print [Expression,]`

// `[Expression,]` means *optional* **comma "Separated List"** of Expressions.
// Since the comma is inside a **[ ]** group, it means the entire list is optional.

// Another example:

// `VariableDecl: IDENTIFIER ["=" Expression]`

// `VarStatement: var (VariableDecl,)`

// It reads: composed symbol `VarStatement` is conformed by the word `var` followed by
// a comma-separated list of `VariableDecl` (at least one)

// The construction `(VariableDecl,)` means: **comma "Separated List"** of `VariableDecl`

// Since the comma is inside a **( )** group, it means _at least one VariableDecl_ is required.

import { ASTBase } from './ASTBase'
import * as logger from '../util/logger.js'
import { TokenCode } from '../Lexer/Lexer'
import { Parser } from './Parser'
import { EOL } from 'os'

// Reserved Words
// ---------------

// Words that are reserved and cannot be used as variable or function names
const RESERVED_WORDS = ['fn', 'async', 'class', 'if', 'then', 'else', 'null', 'true', 'false',
    'new', 'loop', 'while', 'crate', 'for', 'to', 'break', 'continue',
    'return', 'try', 'catch', 'throw', 'raise', 'fail', 'exception', 'finally',
    'mut', 'var', 'let',
    'yield', 'await', 'self', 'super', 'export',
    'async', 'short', 'long', 'int',
    'unsigned', 'void', 'null', 'bool', 'assert']

// Operators precedence
// --------------------
// The order of symbols here determines operators precedence
// var operatorsPrecedence = [
// '++','--', 'unary -', 'unary +', 'bitnot' ,'bitand', 'bitor', 'bitxor'
//, '>>','<<'
//, 'new','type of','instance of','has property'
//, '*','/','%','+','-','&'
//, 'into','in'
//, '>','<','>=','<=','is','<>','!==','like'
//, 'no','not','and','but','or'
//, '?',':'
// ]
const OPERATORS_PRECEDENCE = ['&', '&mut', '*',
    '!', '?',
    'unary -', 'unary +',
    'as',
    '*', '/', '%', '&', '|', '^', '>>', '<<',
    '+', '-',
    '==', '!=', '>', '<', '>=', '<=',
    '||', '&&',
    '..', '..=',
    '=', '+=', '-=', '*=', '/='
]

// --------------------------
// Grammar - AST Classes
//= ===============================
// You'll find a class for each syntax construction the parser accepts

/**
 * can include namespace::namespace::name
 * */
export class Identifier extends ASTBase {
    typeParams: string[]
    // ---------------------------
    parse() {
        this.optMut()
        this.optRef()
        this.name = this.reqToken(TokenCode.WORD)
        while (this.opt('::')) {
            this.name += '::'
            if (this.opt("<")) {
                this.typeParams = DelimitedWordList.parseOpened(this, '<', '>')
            } else {
                this.name += this.reqToken(TokenCode.WORD)
            }
        }
    }
}

// ## Oper

// ```
// Oper: ('~'|'&'|'^'|'|'|'>>'|'<<'
// |'*'|'/'|'+'|'-'|mod
// |'>'|'<'|'>='|'<='
// etc.
// ```

// An Oper sits between two Operands ("Oper" is a "Binary Operator",
// different from *UnaryOperators* which optionally precede a Operand)

// If an Oper is found after an Operand, a second Operand is expected.

export class Oper extends ASTBase {
    negated: boolean
    left: Operand
    right: Operand
    pushed: boolean
    precedence: number
    // ---------------------------
    parse() {
        if (this.owner.lexer.token.value == "as") { // typecast operation
            this.lock()
            this.name = this.req("as")
        } else {
            this.name = this.reqToken(TokenCode.OPERATOR)
            this.lock()

            // check range operator
            if (this.name == ".." && this.opt("=")) {
                this.name = "..="
            }
        }
        // Get operator precedence index
        this.getPrecedence()
    }

    // ---------------------------
    getPrecedence = function() {
        this.precedence = OPERATORS_PRECEDENCE.indexOf(this.name)
        if (this.precedence === -1) {
            this.sayErr(`OPER '${this.name}' not found in the operator precedence list`)
        }
    }

    // ----------------
    produce() {
        this.left?.produce()
        this.owner.codeWriter.write(' ' + this.name + ' ')
        this.right?.produce()
    }
}
// end class Oper

export class UnaryOper extends Oper {
    // ---------------------------
    parse() {
        this.name = this.reqOneOf(['+', '-', '!'])
        // Lock, we have a unary oper
        this.lock()

        // Rename - and + to 'unary -' and 'unary +',
        // if .name is '-'
        if (this.name == '-' || this.name == '+') {
            this.precedence = 0
        } else {
            // calculate precedence - Oper.getPrecedence()
            this.getPrecedence()
        }
    }
}
// end class UnaryOper

// ## NumberLiteral
// `NumberLiteral: [0-9_.u] | '0x[0-9a-fA-F] | 0b[0-1][u0-9] `
export class NumberLiteral extends ASTBase {
    tokenCode: TokenCode // save token format: decimal, hexa, binary
    // ---------------------------
    parse() {
        this.tokenCode = this.owner.lexer.token.tokenCode
        this.name = this.reqList([TokenCode.NUMBER, TokenCode.HEXANUMBER, TokenCode.BINARYNUMBER]) as string
        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
// end class NumberLiteral

// ## StringLiteral
// `StringLiteral: '"' [ any* | '\"' ] '"' | ''' [ any* | '\'' ] '''
// A string constant token. Can be anything the lexer supports, including single or double-quoted strings.
// The token includes the enclosing quotes
export class StringLiteral extends ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.LITERAL_STRING)
        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversi�n
    }

    // ---------------------------
    unquoted(): string {
        return this.name.slice(1, -1)
    }
}
// end class StringLiteral

// ## RegExpLiteral
// `RegExpLiteral: REGEX`
// A regular expression token constant. Can be anything the lexer supports.
export class RegExpLiteral extends ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.LITERAL_STRING)
        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
// end class RegExpLiteral

// ## Operand

// ```
// Operand: (
// (NumberLiteral|StringLiteral|RegExpLiteral|ArrayLiteral|ObjectLiteral
// |ParenExpression|FunctionDeclaration)[Accessors])
// |VariableRef)
// ```

// Examples:
// <br> 4 + 3 -> `Operand Oper Operand`
// <br> -4    -> `UnaryOper Operand`

// A `Operand` is the data on which the operator operates.
// It's the left and right part of a binary operator.
// It's the data affected (righ) by a UnaryOper.

export class Operand extends ASTBase {
    // -------------------------
    // value is at children[0]
    // -------------------------
    parse() {
        // Let's look for operands in a expression, i.e: "a" and "b" in  "a+b*5"

        const t = this.owner.lexer.token

        if ([TokenCode.NUMBER, TokenCode.HEXANUMBER, TokenCode.BINARYNUMBER].includes(t.tokenCode)) {
            this.children.push(this.reqClass(NumberLiteral))
            return //* *** early exit
        }
        if (t.tokenCode == TokenCode.LITERAL_STRING) {
            this.children.push(this.reqClass(StringLiteral))
            return //* *** early exit
        }

        if (t.value == "match") { // Rust match expression
            this.name = 'match'
            this.children.push(this.reqClass(MatchExpression))
            return //* *** early exit
        }

        if (t.value == "[") { // array expression
            this.name = 'array expression'
            this.children.push(this.reqClass(ArrayLiteral))
            return //* *** early exit
        }

        if (t.value == "(") { // parenthized expression
            this.name = 'parentized'
            this.children.push(this.reqClass(ParenExpression))
            return //* *** early exit
        }

        if (t.value == "|") { // closure expression
            this.name = 'closure'
            this.children.push(this.reqClass(RustClosure))
            return //* *** early exit
        }

        if (t.value == "let") { // if let => destructuring, check if the Rvalue is of the Lvalue struct
            this.name = 'if-let'
            this.req("let")
            this.reqChild(Operand) // expression like Some(a / Foo::Bar / Foo::Bar { field })
            this.req("=")
            this.reqChild(Identifier) // rvalue is the variable to check against lvalue
            return //* *** early exit
        }

        if (t.value == "if") { // let x = if... if expression
            this.name = 'if-expr'
            this.reqChild(IfStatement) // expression like Some(a / Foo::Bar / Foo::Bar { field })
            return //* *** early exit
        }

        // here, the OPERAND is a var reference, fn-call or macro!
        this.owner.lexer.savePosition()
        const vr = this.reqClass(VarRef)

        // let's see if this is a macro! invocation
        if (this.owner.lexer.token.value == '!') { // it's a macro!
            this.owner.lexer.restoreSavedPosition()
            this.keyword = "macro!"
            this.name = vr.name
            this.children.push(this.reqClass(MacroInvocation))
            return //* *** early exit
        }

        // it's not a macro, last options are var reference or fn-call
        // the vr is good for both
        this.owner.lexer.discardSavedPosition()

        // let's see if this is a struct instantiation expression
        // rust's struct instantiation can only be detected by 'Self {...' or 'Declared-Struct-Type-Name {...' used as a statement
        // ojo ambiguos if we're in [match expr '{' ... '}' ] - commented
        if (this.owner.lexer.token.value == "{" &&
            this.parent.parent.name != 'match' && // for all this statements { => start body
            this.parent.parent.name != 'if' &&
            this.parent.parent.name != 'for'
        ) { // it's a struct Instantiation
            const objectLiteral = this.reqClass(ObjectLiteral)
            objectLiteral.name = vr.name
            objectLiteral.keyword = "struct-instantiation"
            this.children.push(objectLiteral)
            return //* *** early exit
        }

        // last option, this is just a varRef acting as a expression
        this.name = vr.name
        this.children.push(vr)
    }

    // --------
    produce() {
        this.produceChildren()
    }
}
// end class Operand

export class FunctionArgument extends ASTBase {
    expression: Expression
    // ---------------------------
    parse() {
        this.lock()
        if (this.owner.lexer.token.value == "_") { //  _ => wildcard, ignore param
            this.name = "_"
            this.owner.lexer.advance()
            return // early exit
        }
        this.optRef()
        this.optMut()
        this.expression = this.reqClass(Expression) as Expression
    }
}// end class FunctionArgument

// -----------
// ## Expression

// `Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`

// The expression class parses intially a *flat* array of nodes.
// After the expression is parsed, a *Expression Tree* is created based on operator precedence.

export class Expression extends ASTBase {
    root: UnaryOper | Oper | Operand
    operandCount: number
    ternaryCount: number
    // ---------------------------
    parse() {
        const arr = []
        this.operandCount = 0
        this.ternaryCount = 0

        // (performance) Fast exit for no-expression `);{` => end of expression.
        if (');}'.includes(this.owner.lexer.token.value)) {
            return // early exit
        }

        while (true) {
            // Get optional unary operator
            // (performance) check token first

            if (['+', '-', '!'].includes(this.owner.lexer.token.value)) {
                const unaryOper = this.opt(UnaryOper)
                if (unaryOper) {
                    arr.push(unaryOper)
                    this.lock()
                }
            }

            // Get operand
            arr.push(this.reqClass(Operand))
            this.operandCount++
            this.lock()

            // (performance) Fast exit for common tokens: `=> , ] ) ; { ` => end of expression.
            if (this.owner.lexer.token.value == "=>" || ',]);{'.includes(this.owner.lexer.token.value)) {
                break // early exit
            }

            // Try to parse next token as an operator
            const oper = this.opt(Oper)
            // if no oper then break # no more operators, end of expression
            if (!oper) { break }

            // If it was an operator, store, and continue because we expect another operand.
            // (operators sits between two operands)
            arr.push(oper)
        }

        // Now we create a tree from .arr[], based on operator precedence
        this.growExpressionTree(arr)
    }

    // ---------------------------
    growExpressionTree = function(arr) {
        // do while arr.length > 1
        while (arr.length > 1) {
            // find the one with highest precedence (lower number) to push down
            // (on equal precedende, we use the leftmost)

            let pos = -1
            let minPrecedenceInx = 100
            for (let inx = 0, item; inx < arr.length; inx++) {
                item = arr[inx]

                // debug "item at #{inx} #{item.name}, Oper? #{item instanceof Oper}. precedence:",item.precedence

                if (item instanceof Oper) {
                    // if not item.pushed and item.precedence < minPrecedenceInx
                    if (!(item.pushed) && item.precedence < minPrecedenceInx) {
                        pos = inx
                        minPrecedenceInx = item.precedence
                    }
                }
            }
            // end for

            // #control
            if (pos < 0) {
                this.throwError("can't find highest precedence operator")
            }

            // Un-flatten: Push down the operands a level down
            const oper = arr[pos]
            oper.pushed = true
            if (oper instanceof UnaryOper) {
                // #control
                if (pos === arr.length) {
                    this.throwError(`can't get RIGHT operand for unary operator '${oper}'`)
                }

                // # if it's a unary operator, take the only (right) operand, and push-it down the tree
                oper.right = arr.splice(pos + 1, 1)[0]
            } else {
                // #control
                if (pos === arr.length) {
                    this.throwError(`can't get RIGHT operand for binary operator '${oper}'`)
                }
                if (pos === 0) {
                    this.throwError(`can't get LEFT operand for binary operator '${oper}'`)
                }

                // # if it's a binary operator, take the left and right operand, and push them down the tree
                oper.right = arr.splice(pos + 1, 1)[0]
                oper.left = arr.splice(pos - 1, 1)[0]
            }

            // loop #until there's only one operator
        }

        // Store the root operator
        this.root = arr[0]
    }

    static checkNativeRustConversionMapCollect(node: ASTBase) {
        if (node.tokVal() == ".") {
            node.nativeSuffixes = node.reqClass(RustNativeSuffixes)
        }
    }
}
// end class Expression

export class RustNativeSuffixes extends ASTBase {
    // ---------------------------
    parse() {
        // check for .into() o .as_u128() .to_vec() .map() . collect() etc,

        while (this.owner.lexer.token.value == '.') {
            this.owner.lexer.advance()

            if (this.owner.lexer.token.tokenCode == TokenCode.NUMBER) {
                // tuple item acess
                this.reqChild(NumberLiteral)
            } else {
                const suffix = this.reqClass(Identifier)
                if (this.opt("(")) {
                    if (suffix.name == "map" || suffix.name == "filter") { // .map() && filter param are rust's closures
                        suffix.reqChild(RustClosure)
                    } else if (this.tokVal() != ')') { // has parameters
                        suffix.reqChild(Expression)
                    }
                    this.req(")")
                }
            }
        }
    }
}

// ## NameValuePair
// `NameValuePair: (IDENTIFIER|StringLiteral|NumberLiteral) ':' Expression`
// A single item inside a `ObjectLiteral / StructInstantiation.value`
// a `property-name: value` pair.
export class NameValuePair extends ASTBase {
    value: Expression
    // ---------------------------
    parse() {
        this.owner.lexer.savePosition()
        this.name = this.reqToken(TokenCode.WORD)
        if (this.opt(':')) { // por alguna razon en rust decidieron q se podia instanciar un obj por posicion, los : son opcionales
            this.owner.lexer.discardSavedPosition()
            this.lock()
            this.value = this.reqClass(Expression) as Expression
        } else {
            // asumpo posicional
            this.owner.lexer.restoreSavedPosition()
            this.name = "[positional]"
            this.value = this.reqClass(Expression) as Expression
        }
    }

    // ---------------------------
    produce() {
        this.owner.codeWriter.write(this.name)
        this.owner.codeWriter.write(" : ")
        this.value.produce()
    }
}
// end class NameValuePair

// ## ObjectLiteral

// `ObjectLiteral: '{' NameValuePair* '}'`

// Defines an object with a list of key value pairs. This is a JavaScript-style definition.
// For LiteC (the Litescript-to-C compiler), a ObjectLiteral crates a `Map string to any` on the fly.

// `x = {a:1,b:2,c:{d:1}}`

interface ObjectLiteralForEachCallback{
    (nameValue: NameValuePair)
}

export class ObjectLiteral extends ASTBase {
    // ---------------------------
    parse() {
        this.req('{')
        this.lock()
        this.children = this.optSeparatedList(NameValuePair, ',', '}')

        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversi�n
    }

    // ---------------------------
    forEach(callback: ObjectLiteralForEachCallback) {
        // for each nameValue in .items
        for (const nameValue  of this.children) {
            callback(nameValue as NameValuePair)
        }
    }

    // ---------------------------
    produce() {
        this.owner.codeWriter.write("{")
        this.produceChildren("," + EOL)
        this.owner.codeWriter.write("}")
    }
}

export class StaticDeclaration extends ASTBase {
    valueExpression: Expression
    // ---------------------------
    parse() {
        this.req('static')
        // At this point we lock because it is definitely a `static` declaration. Failure to parse the expression
        // from this point is a syntax error.
        this.lock()
        // After the word 'static' we require an identifier:type=value
        this.name = this.reqToken(TokenCode.WORD)
        this.req(":")
        this.reqChild(TypeAnnotation)
        this.req("=")
        this.reqChild(Expression)
    }
}
// end static place declaration

// ## ArrayLiteral
// `ArrayLiteral: '[' (Expression,)* ']'`
// An array definition, such as `a = [1,2,3]`
export class ArrayLiteral extends ASTBase {
    items: Expression[] = []
    // ---------------------------
    parse() {
        this.req('[')
        this.lock()
        // closer "]" required
        this.items = this.optSeparatedList(Expression, ',', ']') as Expression[]
    }
}// end class ArrayLiteral

export class ConstDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('const')
        // At this point we lock because it is definitely a `const` declaration. Failure to parse the expression
        // from this point is a syntax error.
        this.lock()
        // After the word 'const' we require an identifier
        this.name = this.reqToken(TokenCode.WORD)
        this.req(":")
        this.reqChild(TypeAnnotation)
        this.req("=")
        this.reqChild(Expression)
    }
}
// end ConstValueDeclaration

// ## ParenExpression
// `ParenExpression: '(' Expression ')'`
// An expression enclosed by parentheses, like `(a + b)`.
export class ParenExpression extends ASTBase {
    expr: Expression
    // ---------------------------
    parse() {
        this.req('(')
        this.lock()
        while (true) {
            this.reqChild(Expression)
            if (this.opt(",")) {
                // tuple paren expression
                this.keyword = "tuple"
                continue
            } else {
                break
            }
        }
        this.req(')')

        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversion
    }
}
// end class ParenExpression

/**
 * a type annotation with optional <type-paramenters,...>
 *      IDENT [ '<' (type-paramenter,) '>' ]
 * */
export class TypeAnnotation extends ASTBase {
    typeParams: string[];
    parse() {
        this.optRef()
        this.optMut()
        if (this.opt("(")) { // tuple type annotation
            this.lock()
            this.keyword = "tuple type"
            this.name = "(tuple)"
            this.children = this.reqSeparatedList(TypeAnnotation, ',', ')')
        } else if (this.opt("[")) { // arr type annotation
            this.lock()
            this.keyword = "arr type"
            this.name = "(arr)"
            this.reqChild(Identifier)
            if (this.opt(";")) {
                this.reqChild(NumberLiteral)
            }
            this.req("]")
        } else {
            const ident = this.reqClass(Identifier)
            this.name = ident.name // composed::namespace::name
            // check for (nested) type parameters
            const initial = (this.opt('<') || this.opt("<'")) as string
            if (initial) {
                this.typeParams = DelimitedWordList.parseAfter(initial,this, '<', '>')
            }
        }
    }
}

/**
 * class UseDeclaration
 *      'use' WORD ([::WORD...]  | '{' (Identifier,) '}' | * )
 * */
export class UseDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('use')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        while (this.owner.lexer.token.value == '::') {
            this.name += '::'
            const nextValue = this.owner.lexer.advance()
            if (nextValue == '{') { // special rust case, several use declarations sharing the same root
                this.owner.lexer.advance()
                this.children = this.reqSeparatedList(Identifier, ",", "}")
                break // no more ::'s possible
            } else if (nextValue == '*') { // special: all items
                this.name += '*'
                this.owner.lexer.advance()
                break // no more ::'s possible
            } else { // more indentifiers
                this.name += this.reqToken(TokenCode.WORD)
            }
        }
    }
}

export class ModDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('mod')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        Body.optIntoChildren(this)
    }
}

export class TypeDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('type')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        this.req('=')
        this.reqChild(Expression)
    }
}

export class DelimitedWordList {

    static parse(node: ASTBase,  opener: string, closer: string): string[] {
        const initial = node.req(opener)
        return DelimitedWordList.parseAfter(initial, node, opener,closer)
    }

    static parseOpened(node: ASTBase,  opener: string, closer: string): string[] {
        return DelimitedWordList.parseAfter(opener, node, opener,closer)
    }

    static parseAfter(initial: string, node: ASTBase, opener: string, closer: string): string[] {
        // read balanced openers/closers { } / () or up to ;
        // because it's a "macro" anything goes (can't use AST Body parser)
        const macroWords: string[] = []
        macroWords.push(initial)
        let openBalance = 1
        while (openBalance > 0) {
            const word = node.owner.lexer.advance()
            if (opener && word == opener) { openBalance++ } else if (word == closer) { openBalance-- }
            macroWords.push(word)
        }
        node.owner.lexer.advance() // consume the closer
        return macroWords
    }
}

export class MacroInvocation extends ASTBase {
    macroWords: string[] = []
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.WORD)
        this.name += this.req('!')
        this.lock()

        // handle standard rust macro parameter delimiters
        const initial = this.owner.lexer.token.value
        let opener = initial; let closer: string
        if (initial == '{') {
            closer = '}'
        } else if (initial == '(') {
            closer = ')'
        } else if (initial == '[') {
            closer = ']'
        } else {
            opener = undefined
            closer = ';'
        }

        // special recognized macros: assert_eq!(a,b) => expect(a).toBe(b)
        if (this.name == "assert_eq!" && opener == "(") {
            // parse the 2 expression and store at children[]
            this.req("(")
            this.reqChild(Expression)
            this.req(",")
            this.reqChild(Expression)
            if (this.opt(",")) { // third parameter, message if asssert failed
                this.reqChild(Expression)
            }
            this.req(")")
        } else {
            // read balanced openers/closers { } / () or up to ;
            // because it's a "macro" anything goes (can't use AST Body parser)
            this.macroWords = DelimitedWordList.parseAfter(initial, this, opener, closer)
        }

        // check if the macro!() ends with .into() .as_bytes() .as_U128() etc
        Expression.checkNativeRustConversionMapCollect(this)

        this.owner.lexer.semiNotRequired = true // no need for a semicolon after this
    }

    toString() {
        return Function.apply(ASTBase.toString, this) + ' ' + this.macroWords.join(' ')
    }
}

export class StructDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('struct')
        this.name = this.reqToken(TokenCode.WORD)
        this.req('{')
        this.children = this.reqSeparatedList(VariableDecl, ",", "}")
    }
}

export class EnumItem extends ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.WORD)
        if (this.opt('{')) {
            this.children = this.reqSeparatedList(VariableDecl, ",", "}")
        }
    }
}

export class EnumDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('enum')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        this.req('{')
        this.children = this.reqSeparatedList(EnumItem, ",", "}")
    }
}

export class ImplDeclaration extends ASTBase {
    for: Identifier
    // ---------------------------
    parse() {
        this.req('impl')
        this.lock()
        const ident = this.reqClass(Identifier)
        this.name = ident.name
        if (this.opt('for')) {
            this.for = this.reqClass(Identifier) as Identifier
        }
        this.req("{")
        Body.parseIntoChildren(this) // parse as a Body (no separator, several fn { } blocks) => children
    }
}

/**
 * A single-line attribute
 * comments attached to statements are stored in Statement.comment
 * */
export class LineAttribute extends ASTBase {
    parse() {
        this.name = this.reqToken(TokenCode.ATTRIBUTE)
    }
}

export class IdentifierMaybeTuple extends ASTBase {
    // ---------------------------
    parse() {
        if (this.opt("(")) {
            this.lock()
            this.children = this.reqSeparatedList(Identifier, ",", ")") // closure params as tuples?
        } else {
            this.reqChild(Identifier)
        }
    }
}

// ## RustClosure
//
// `RustClosure: ` '|' (WORD,...) '|' ( Body | Expression | fn-call ) `
//
export class RustClosure extends ASTBase {
    mapItemName: string
    params: Identifier[]

    // ---------------------------
    parse() {
        this.req('|')
        this.lock()
        if (this.opt("(")) {
            this.params = this.reqSeparatedList(Identifier, ",", ")") as Identifier[] // closure params as tuples?
            this.req('|')
        } else {
            this.params = this.reqSeparatedList(Identifier, ",", "|") as Identifier[] // closure params
        }

        // it's a body?
        if (this.opt('{')) {
            Body.parseIntoChildren(this)
        } else {
            // let's assume it is an Expression
            this.children.push(this.reqClass(Expression))
        }
    }
}
// end class RustClosure

// ## MatchPair
//
// `MatchPair: ` (Expression | '_' ) '=>' Expression
//
export class MatchPair extends ASTBase {
    left: Expression
    right: ASTBase
    // ---------------------------
    parse() {
        if (this.opt('_')) {
            this.left = null
        } else {
            this.left = this.reqClass(Expression) as Expression
        }
        this.req("=>")
        if (this.owner.lexer.token.value == "{") { // match pair right item is a block
            this.right = this.reqClass(Body)
        } else {
            this.right = this.reqClass(Expression)
        }
    }

    toString() {
        return Function.apply(ASTBase.toString, this) + (this.left ? this.left.name : '_') + " => " + this.right.name
    }
}

// ## MatchExpression
//
// `MatchExpression: ` match Expression '{' ( (Expression | '_' ) => Expression ,... ) '}'`
//
export class MatchExpression extends ASTBase {
    exprToMatch: Expression
    // ---------------------------
    parse() {
        this.req('match')
        this.lock()
        this.exprToMatch = this.reqClass(Expression) as Expression
        this.req('{')
        this.children = this.optSeparatedList(MatchPair, ",", "}")

        Expression.checkNativeRustConversionMapCollect(this) // veo si tiene una llamada a .to_vec() u otra conversi�n
    }
}
// end class MatchExpression

// ## FunctionDeclaration
//
// `FunctionDeclaration: 'function [IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`
//
// Functions: parametrized pieces of callable code.
//
export class FunctionDeclaration extends ASTBase {
    paramsDeclarations: FunctionParameters

    // ---------------------------
    parse() {
        // manage special keywords like 'pub'
        this.optPub()

        this.req('fn')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)

        // get parameters declarations
        this.paramsDeclarations = this.opt(FunctionParameters) as FunctionParameters

        // get the return-type (optional)
        if (this.opt('->')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation) as TypeAnnotation
        }

        // now parse the body
        if (this.owner.lexer.token.value == ";") {
            // just a fn signature declaration (no body)
        } 
        else {
            if (this.owner.options.skipFunctionBody){  //do not parse function body
                DelimitedWordList.parse(this,"{","}")
            }
            else {
                Body.parseIntoChildren(this)
            }
        }

    }

}
// end class FunctionDeclaration

/**
 * [pub mut &] Name,Type and optional assignment
 *
 * Identifier: TypeAnnotation [ = Expression ]
 *
 * */
export class VariableDecl extends ASTBase {
    typeAnnotation: TypeAnnotation
    assignedExpression: Expression
    // ---------------------------
    parse() {
        // manage special keywords like 'pub' & mut
        this.optPub()
        this.optRef()
        this.optMut()
        this.optDecorators()

        this.name = this.reqToken(TokenCode.WORD)
        this.lock()

        // if .parent instance of VarStatement
        if (this.parent instanceof LetStatement && RESERVED_WORDS.indexOf(this.name) >= 0) {
            this.sayErr(`"${this.name}" is a reserved word`)
        }

        // optional type annotation
        if (this.opt(':')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation) as TypeAnnotation
        }

        // optional assigned value
        if (this.opt('=')) {
            this.assignedExpression = this.reqClass(Expression) as Expression
        }
    }

    toString():string {
        return (this.isRef ? "&" : "") + (this.isMut ? "mut " : "") + this.name + (this.typeAnnotation ? this.typeAnnotation.name + ":" : "")
    }
}
// end class VariableDecl

export class LetStatement extends ASTBase {
    // ---------------------------
    parse() {
        this.req('let')
        this.optMut()
        this.lock()
        if (this.opt("(")) { // tuple assignment
            this.keyword = "tuple"
            this.children = this.reqSeparatedList(Identifier, ',', ')')
            // optional assigned value
            if (this.opt('=')) {
                this.children.push(this.reqClass(Expression) as Expression)
            }
        } else {
            this.children = this.reqSeparatedList(VariableDecl, ',', ';')
        }
    }
}

// ------------------
export class FunctionParameters extends ASTBase {
    // ---------------------------
    parse() {
        // if we define a list of specific parameters, fuction is no longer variadic
        this.lock()

        this.req('(')
        this.children = this.optSeparatedList(VariableDecl, ',', ')') as VariableDecl[]
    }

    toString():string {
        return "(" + this.children.map((c) => c.toString()).join(",") + ")"
    }
}// end class FunctionParameters

// ------------------------------------------
export class TraitDeclaration extends ASTBase {
    traitAncestors: Identifier[]
    // ---------------------------
    parse() {
        this.req('trait')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)

        // See if there is an inheritance declaration
        if (this.opt(':')) {
            // now a list of references (to other traits, separated by "+", ended by the "{" )
            this.traitAncestors = this.reqSeparatedList(Identifier, '+', '{') as Identifier[]
        }

        // Now get the trait body
        this.req("{")
        Body.parseIntoChildren(this)
    }
}
// end class TraitDeclaration

/**
 * 'return' [Expression]
 * */
export class ReturnStatement extends ASTBase {
    expr: Expression
    // ---------------------------
    parse() {
        this.req('return')
        this.lock()
        this.optChild(Expression)
    }
}
// end class ReturnStatement

// ---------------------------
export class IfStatement extends ASTBase {
    conditional: Expression
    // ---------------------------
    parse() {
        this.req('if')
        this.lock()
        this.conditional = this.reqClass(Expression) as Expression
        Body.reqAsChild(this, "then-block") // first child, then block
        if (this.opt('else')) {
            Body.reqAsChild(this, "else-block") // second child, optional else block
        }
    }
}
// end class IfStatement

// ---------------------------
export class WhileStatement extends ASTBase {
    conditional: Expression
    // ---------------------------
    parse() {
        this.req('while')
        this.lock()
        this.conditional = this.reqClass(Expression) as Expression
        this.req("{")
        Body.parseIntoChildren(this)
    }

    toString() {
        return Function.apply(ASTBase.toString, this) + ' ' + this.conditional.name
    }
}
// end class WhileStatement

// ## Range Expression
export class RangeExpression extends ASTBase {
    inclusive: boolean = false;
    // ---------------------------
    parse() {
        this.reqChild(Expression)
        this.req('..')
        if (this.opt("=")) this.inclusive = true
        this.reqChild(Expression)
    }
}// end class RangeExpression

// ## For Statement
export class ForStatement extends ASTBase {
    ident: IdentifierMaybeTuple
    range: Expression
    // ---------------------------
    parse() {
        // We start with commonn `for` keyword
        this.req('for')
        this.lock()
        this.ident = this.reqClass(IdentifierMaybeTuple) as IdentifierMaybeTuple
        this.req('in')
        this.range = this.reqClass(Expression) as Expression

        this.req('{')
        Body.parseIntoChildren(this) // first child, then block
    }
}// end class ForStatement

// -----------------------
// ## Accessors
// `Accessors: (PropertyAccess | FunctionAccess | IndexAccess)`

// Accessors:
// `PropertyAccess: '.' IDENTIFIER`
// `IndexAccess: '[' Expression ']'`
// `FunctionAccess: '('[Expression,] * ')'`

// Accessors can appear after a VariableRef (most common case)
// but also after a String constant, a Regex Constant,
// a ObjectLiteral and a ArrayLiteral

// Examples:
// - `myObj.item.fn(call)`  <-- 3 accesors, two PropertyAccess and a FunctionAccess
// - `myObj[5](param).part`  <-- 3 accesors, IndexAccess, FunctionAccess and PropertyAccess
// - `[1, 2, 3, 4].indexOf(3)` <-- 2 accesors, PropertyAccess and FunctionAccess

// #####Actions:

// `.` -> PropertyAccess: Search the property in the object and in his pototype chain.
// It resolves to the property value

// `[...]` -> IndexAccess: Same as PropertyAccess

// `(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed.
// It resolves to the function return value.

// ## Implementation
// We provide a class Accessor to be super class for the three accessors types.

export class Accessor extends ASTBase {
    static parseAccessors(node: VarRef) {
        let accessorFound = true
        // Loop parsing accessors
        while (accessorFound) {
            if (node.owner.lexer.token.tokenCode == TokenCode.COMMENT) { // skip comments
                node.owner.lexer.advance()
                continue
            }

            switch (node.owner.lexer.token.value) {
            case '.': // . => property acceess
                node.reqChild(PropertyAccess)
                node.isFunctionCall = false
                break

            case '(': // ( => function access
                node.reqChild(FunctionAccess)
                node.isFunctionCall = true // if the very last accesor is "(", it means the entire expression is a function call
                node.hasSideEffects = true // if any accessor is a function call, this statement is assumed to have side-effects
                break

            case '[': // [ => array access
                node.reqChild(IndexAccess)
                node.isFunctionCall = false
                break

            default:
                accessorFound = false
            }
        }
    }
}
// end class Accessor

export class FunctionAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('(')
        this.lock()
        this.children = this.optSeparatedList(FunctionArgument, ',', ')')
    }

    // ---------------------------
    toString() {
        return '(...)'
    }

    produce() {
        const o = this.owner.codeWriter
        // function accessor => function call
        o.write("(")
        this.produceChildren(", ")
        o.write(")")
    }
}
// end class FunctionAccess

export class PropertyAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('.')
        this.lock()
        // check for NumberLiteral  x.0 rust tuple dot-index access. https://stackoverflow.com/questions/32030756/reasons-for-dot-notation-for-tuple
        if (this.owner.lexer.token.tokenCode == TokenCode.NUMBER) {
            this.keyword = "tuple-index"
            this.extraInfo = this.owner.lexer.token.value
            this.owner.lexer.advance()
        } else {
            // let's assume .field access
            this.name = this.reqToken(TokenCode.WORD)
        }
    }

    // ---------------------------
    toString() {
        return `.${this.name} `
    }

    produce() {
        const o = this.owner.codeWriter
        // function accessor => function call
        o.write(".")
        o.write(this.name)
    }
}
// end class PropertyAccess

export class IndexAccess extends Accessor {
    // ---------------------------
    parse() {
        this.name = this.req('[')
        this.lock()
        this.reqChild(Expression)
        this.req(']')
    }// ---------------------------

    toString() {
        return '[...]'
    }

    produce() {
        const o = this.owner.codeWriter
        // function accessor => function call
        o.write("[")
        this.produceChildren()
        o.write("]")
    }
}
// end class IndexAccess

// -----------------------
/**
 * a VarRef can be:
 * 1. A "place" or L-Value, an Identifier with optional Accessors referencig a specific memory location with a type
 * 2. A Function call, returning a value (an R-value)
 *
 * When used in Expressions, both interpretations are used as an R-Value, either by reading the value from the referenced place or executing the function call
 *
 * The property `VarRref.isFunctionCall = true` marks it as a Function Call
 *
 * A VarRef be an "Operand" of "InfixExpression"
 *
 * Examples:
 *      myVar
 *      std::Rand(5)
 *      myData[7]
 *      myData[utils::getIndex(s)]
 *      myStruct.name
 *      myStruct.values[7].price
 *
 * */
export class VarRef extends ASTBase {
    preIncDec
    postIncDec
    isFunctionCall: boolean
    hasSideEffects: boolean
    // ---------------------------
    parse() {
        this.preIncDec = this.optList(['--', '++'])
        this.isFunctionCall = false

        this.optMut()
        this.optRef()
        this.optDeRef()
        this.name = this.reqClass(Identifier).name
        this.lock()

        // Now we check for accessors:
        // <br>`.`->**PropertyAccess**
        // <br>`[...]`->**IndexAccess**
        // <br>`(...)`->**FunctionAccess**

        // Note: **.paserAccessors()** will:
        // - set .hasSideEffects=true if a function accessor is parsed
        // - set .isFunctionCall=true if the last accessor is a function accessor

        // .parseAccessors
        Accessor.parseAccessors(this)

        // .postIncDec = .opt('--','++')
        this.postIncDec = this.optList(['--', '++'])

        // If this variable ref has ++ or --, IT IS CONSIDERED a "call to execution" in itself,
        // a "imperative statement", because it has side effects.
        // (`i++` has a "imperative" part, It means: "give me the value of i, and then increment it!")

        if (this.preIncDec || this.postIncDec) {
            this.isFunctionCall = true
            this.hasSideEffects = true
        }
    }

    // ---------------------------
    toString() {
        // This method is only valid to be used in error reporting.
        // function accessors will be output as "(...)", and index accessors as [...]
        let result = `${this.preIncDec || ''}${this.name}`
        if (this.children) {
            for (const ac of this.children) {
                result = `${result}${ac.toString()} `
            }
        }
        return `${result}${this.postIncDec || ''}`
    }
}
// end class VariableRef

// ##Statement

// A `Statement` is an imperative statment (command) or a control construct.

// The `Statement` node is a generic container for all previously defined statements.

// The generic `Statement` is used to define `Body: (Statement;)`, that is,
//* *Body** is a list of semicolon (or NEWLINE) separated **Statements**.

// Grammar:
// ```
// Statement: [Adjective]* (TraitDeclaration|FunctionDeclaration
// |IfStatement|ForStatement|WhileUntilLoop|DoLoop
// |AssignmentStatement
// |LoopControlStatement|ThrowStatement
// |TryCatch|ExceptionBlock
// |ReturnStatement|PrintStatement|DoNothingStatement)

// Statement: ( AssignmentStatement | fnCall-VariableRef [ ["("] (Expression,) [")"] ] )
// ```

// public class Statement extends ASTBase
// constructor
export class Statement {
    // ----------------------------------------
    // Table-based (fast) Statement parsing
    // ------------------------------------
    // This a extension to PEGs.
    // To make the compiler faster and easier to debug, we define an
    // object with name-value pairs: `"keyword" : AST node class`
    // We look here for fast-statement parsing, selecting the right AST node to call `parse()` on
    // based on `token.value`. (instead of parsing by ordered trial & error)
    // This table makes a direct parsing of almost all statements, thanks to a core definition of LiteScript:
    // Anything standing alone in it's own line, its an imperative statement (it does something, it produces effects).
    static DirectKeywordMap: Record<string, typeof ASTBase> = {
        use: UseDeclaration,
        mod: ModDeclaration,
        const: ConstDeclaration,
        static: StaticDeclaration,
        trait: TraitDeclaration,
        type: TypeDeclaration,
        '#': LineAttribute,
        struct: StructDeclaration,
        enum: EnumDeclaration,
        impl: ImplDeclaration,
        fn: FunctionDeclaration,
        let: LetStatement,
        if: IfStatement,
        while: WhileStatement,
        for: ForStatement,
        match: MatchExpression,
        return: ReturnStatement,
    }

    // ---------------------------
    /** static Statement.tryParse
     *  try to parse a statement and return the specific node found | throws
     * @param node
     */
    static tryParse(node: ASTBase): ASTBase {
        node.lock() // no other option than a statement

        // manage rust attributes (lines starting with #)
        if (node.owner.lexer.token.tokenCode == TokenCode.ATTRIBUTE) {
            return node.reqClass(LineAttribute)
        }

        // manage special keywords like 'pub'
        const isPublic = (node.opt('pub') == 'pub')

        const key = node.owner.lexer.token.value

        const resultASTNode = Statement.tryParseByKeyword(node, key)

        resultASTNode.keyword = key
        resultASTNode.isPublic = isPublic
        Expression.checkNativeRustConversionMapCollect(resultASTNode) // veo si tiene una llamada a .to_vec() u otra conversi�n

        return resultASTNode
    }

    private static tryParseByKeyword(node: ASTBase, key: string): ASTBase {
        // manage rust macros
        if (node.owner.lexer.nextToken().value == '!') { // it's a macro!
            return node.reqClass(MacroInvocation)
        }

        // rust expression as as statement, discarded or returned if it is the last expression in the function
        if (key == '(') { // it's a (Expression-maybeReturn-Statement)
            return node.reqClass(Expression)
        }

        // Now we can look up the keyword in the **StatementsDirect** table, and parse the specific AST node
        const ClassByKeyword = Statement.DirectKeywordMap[key]
        if (ClassByKeyword) {
            // keyword found, use the AST class to parse
            return node.reqClass(ClassByKeyword)
        }

        // if keyword not found in table
        // It's an expression
        return node.reqClass(Expression) as Expression

        // let's asume it's a fn call or an assignment statement
        // lets try then to parse a varRef, that could result in a fn-call or in an L-Value for an assignment
        const vr: VarRef = node.reqClass(VarRef) as VarRef
        if (vr.isFunctionCall) { // it was a fn call
            return vr
        }

        // let's see if node is a struct instantiation expression
        // rust's struct instantiation have the form: IDENT ObjectLiteral
        // ObjectLiteral  = '{' [ NameValuePair, ] '}'
        if (node.owner.lexer.token.value == "{") { // let's assume is a Struct Instantiation
            // it's a Struct Instantiation
            const objectLiteral = node.reqClass(ObjectLiteral)
            objectLiteral.name = vr.name
            objectLiteral.keyword = "struct-instantiation"
            return objectLiteral
        }

        // it wasn't a function call,
        // if there's an assignmen token => AssignmentStatement
        // else is just an expression-maybe-return-value
        if (node.owner.lexer.token.tokenCode == TokenCode.OPERATOR) {
            // it's is an AssignmentStatement
            // const assignmentStatement = node.reqClass(AssignmentStatement) as AssignmentStatement
            // assignmentStatement.lvalue = vr //complete the AssignmentStatement L-value with the prevously parsed VarRef
            // return assignmentStatement
        }

        // finally, just a expression
        // the preParsedVarRef is just a R-Value, an expression-maybe-return-value
        return vr
    }
}
// end class Statement

// ## Body
// a Body is a (optional)semicolon-separated list of statements (At least one) ending with a "closer", either '}' or EOF
// Body is used for "fn" body, for body, if& else bodies, etc.
// Anywhere a list of semicolon separated statements apply.
/**
 * '{' [Statements;] '}'
 * */
export class Body extends ASTBase {
    parse() {
        this.req("{")
        this.lock()
        Body.parseIntoChildren(this)
    }

    // ---------------------------
    produce() {
        this.produceBody(4)
    }

    // ---------------------------
    static reqAsChild(parent: ASTBase, name: string = "Body"): void {
        const newBlock = parent.reqClass(Body)
        newBlock.name = name
        parent.children.push(newBlock)
    }

    // ---------------------------
    static optIntoChildren(node: ASTBase, closer: string = "}") {
        if (node.opt("{")) {
            Body.parseIntoChildren(node, closer)
        }
    }

    // ---------------------------
    static parseIntoChildren(node: ASTBase, closer: string = "}") {
        node.lock()
        // We accept statements and comments as items in the body
        // A Body is a list of Statements|LineComments separated by *semicolon* and, closed by "}"
        const separator = ';'
        logger.debug(`Body for ${node.constructor.name}: get LineComments & Statements separated by '${separator}' closer:`, closer || ' to EOF')

        while (true) {
            node.owner.lexer.skipWhiteSpaceAndNewLine()

            // pre comments and attrs
            const preComments: string[] = []
            node.owner.lexer.consumeCommentsAndAttr(preComments)

            if (node.owner.lexer.token.tokenCode == TokenCode.EOF) break // break on EOF
            if (closer && node.opt(closer)) break // on closer:'}', break - end of body, (a single extra separator before closer is allowed)

            if (logger.debugFrom && node.owner.lexer.token.line > logger.debugFrom) logger.setDebugLevel(1)
            if (logger.debugTo && node.owner.lexer.token.line > logger.debugTo) logger.setDebugLevel(0)

            // -----------------------
            // here we assume it's a Statement
            // Statement.tryParse will return the right AST class parsed
            const statement = Statement.tryParse(node)
            // attach pre-comments to the statement
            statement.commentsAndAttr = preComments
            // keep a dict of declaredStructs in order to be able to recognize struct instantiation
            // (there's no keyword in a struct instantiation, just the struct's name | Self)
            if (statement instanceof StructDeclaration) {
                node.owner.declaredStructs[statement.name] = statement
            }
            // add post comments and attr - NO, se come precomments del sieguiente after a struct { }
            // node.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr)

            node.children.push(statement)

            if (node.opt(closer)) break // if closer '}' found here, break - end of body

            // special case: check if now comes a separator (;) followed of a comment on the same line...
            statement.attachedComment = node.owner.lexer.getAttachedCommentAfter(separator)
            if (statement.attachedComment) {
                // keep the comments atttached to the statement
                continue // Next sentence, separator found and consumed
            }

            // if the statement had a body defined by { }, or the statemente consumend the separator ";" -- it's OK
            if (node.owner.lexer.token.value != separator) {
                // allow exceptions, separator is not required
                continue
            }

            // if there is a 'separator' (semicolon), let's consume it
            node.owner.lexer.semiNotRequired = false
            node.req(separator)
        }// try another item after the separator

        logger.debug(`End Body on '${closer}'`)

        if (closer == '}') node.owner.lexer.semiNotRequired = true // no need for a semicolon if closed by '}'
    }
}
// end class Body

// ## Module
// The `Module` represents a complete source file.
export class ASTModule extends ASTBase {
    dependencyTreeLevel = 0
    dependencyTreeLevelOrder = 0
    importOrder = 0
    // ------------
    constructor(owner: Parser, filename: string) {
        super(null, filename)
        this.owner = owner
    }

    parse() {
        const closer = undefined // parse until EOF
        Body.parseIntoChildren(this, closer)
    }
}

'''
'''--- src/lib/Parser/Parser.ts ---
import { Lexer } from "../Lexer/Lexer"
import { ASTModule, StructDeclaration } from "./Grammar"
import { CodeWriter } from "./CodeWriter"

type ParserOptions = {
    skipFunctionBody?:boolean;
}

export class Parser {
    lexer: Lexer
    hardError: Error;
    codeWriter: CodeWriter

    // declaredStructs = new Map<string, StructDeclaration>()
    declaredStructs: { [index: string]: StructDeclaration } = { };

    options: ParserOptions;

    constructor(options:ParserOptions){
        this.options=options
    }
    
    /**
     * creates the AST
     * returns Root Node: type Module
     * */
    parse(lexer: Lexer): ASTModule {
        this.lexer = lexer
        const ASTRoot = new ASTModule(this, lexer.filename)
        ASTRoot.parse()
        return ASTRoot
    }

    parseFile(filename:string): ASTModule {
        const lexer = new Lexer()
        lexer.openFile(filename)
        return this.parse(lexer)
    }
}

'''
'''--- src/lib/util/CommandLineArgs.ts ---
/**
 #Simple and minimum command line args parser
 *
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args.
 *    --Note:  spaces *must* be used around { and }
 *

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/

import { sep } from "path" // host OS path separator
import { inspect } from "util"
import { KeyObject } from "crypto"
import * as color from './color.js'

export type OptionDeclaration =
    {
        shortName: string
        valueType?: string
        helpText?: string
        value?: any
    }

// ----------------------------------------------------
// construct and show help page based on valid options
// ----------------------------------------------------
export function ShowHelpOptions(optionsDeclaration: any) {
    // show help about declared options
    console.log()
    console.log("-".repeat(60))
    console.log("Options:")
    for (const key in optionsDeclaration) {
        let line = ""
        const opt = optionsDeclaration[key]
        let text = "--" + key
        if (opt.valueType) text = text + " " + opt.valueType
        if (opt.shortName) {
            text = text + ", -" + opt.shortName
            if (opt.valueType) text = text + " " + opt.valueType
        }
        line = `  ${text}`.padEnd(50) + (opt.helpText ? opt.helpText : "")
        console.log(line)
    }
    console.log("-".repeat(60))
}

// ----------------------------------------------------
// construct and show a help page based on the API for the commands
// ----------------------------------------------------
export function ShowHelpPage(command: string, contractAPI: any, optionsDeclaration: any) {
    const commandsHelp: any = {}

    // check all functions in the ContractAPI class, except the class constructor
    const methodNames =
        Object.getOwnPropertyNames(contractAPI.__proto__)
            .filter(name => name !== "constructor" && (command === "" || name === command)) // filter requested command

    // populate commandsHelp
    methodNames.forEach((value) => commandsHelp[value] = "")

    // see which functions have proper help text
    // check all *_help string items in the ContractAPI class
    const properHelpStrings = Object.getOwnPropertyNames(contractAPI)
    for (const item of properHelpStrings) {
        if (item.endsWith("_help") && typeof contractAPI[item] === "string") {
            const method = item.replace("_help", "")
            if (command === "" || command == method) { // filter the requested help
                commandsHelp[method] = contractAPI[item] as string // add proper help
            }
        }
    }
    // print all commands and their help if it's there
    for (const key in commandsHelp) {
        console.log("-".repeat(60))
        console.log('command: ' + key) // name the command
        console.log(commandsHelp[key]) // print the help
    }

    ShowHelpOptions(optionsDeclaration)
}

// --------------------------
// --  main exported class --
// --------------------------
export class CommandLineArgs {
    clArgs: string[] // initial list process.argv

    positional: (string | {})[] // string or JSON objects -- positional arguments

    optDeclarations: any; // pointer to passed option declarations

    constructor(options: any) {
        this.clArgs = process.argv
        this.optDeclarations = options
        this.positional = []

        // remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node' ||
            this.clArgs[0].endsWith(sep + 'node')) ||
            this.clArgs[0].endsWith(sep + 'node.exe')
        ) {
            this.clArgs = this.clArgs.slice(1)
        }

        // remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1)

        // process each item separating options from posiitonal args

        // First: process --options
        for (const key in options) {
            const optionDecl = options[key]
            // search for option name & variations
            const pos = this.searchOption(optionDecl)
            if (pos >= 0) { // found in command line args
                const literal = this.clArgs[pos] // as written
                this.clArgs.splice(pos, 1) // remove from cl args

                if (optionDecl.valueType) { // has a value
                    if (pos >= this.clArgs.length) {
                        color.logErr("expecting value after " + literal)
                        process.exit(1)
                    }
                    const value = this.clArgs[pos] // take value
                    options[key].value = value // set value
                    this.clArgs.splice(pos, 1) // also remove value from list
                } else // valueless option
                {
                    options[key].value = true // set as present
                }
            }
        }

        // if at this point there are still --options in the command line args array, those are unknown options
        let hasErrors = false
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                color.logErr("UNKNOWN option: " + item)
                hasErrors = true
            }
        }
        if (hasErrors) {
            ShowHelpOptions(options)
            process.exit(1)
        }

        // create consumible positional arguments, parsing also JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index]
            if (item == "{") { // a JSON object in the command line
                const extracted = this.extractJSONObject(index)
                this.positional.push(extracted.value)
                index = extracted.end
            } else {
                this.positional.push(item)
            }
        }
    }

    /**
     * When the first argument is the command to execute
     * returns "" if there's no arguments
     */
    getCommand() {
        if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            color.logErr("expected a command as first argument'")
            process.exit(1)
        } else {
            if (this.positional.length === 0) return ""
            // take the first argument as this.command
            return this.positional.shift() as string
        }
    }

    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which:string) {
        if (this.positional.length == 0) return false

        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected a string argument, got {... }`)
            process.exit(1)
        }
        if (this.positional[0] == which) {
            this.positional.shift() // consume
            return true
        }
        return false // not the expected string
    }

    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name: string) {
        if (this.positional.length == 0) {
            color.logErr(`expected '${name}' argument`)
            process.exit(1)
        }
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected ${name} string argument, got {... }`)
            process.exit(1)
        }
        return this.positional.shift() as string
    }

    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name: string, units: "N" | "Y"): string {
        const value = this.consumeString(name)
        return this.convertAmount(value, units, name)
    }

    /**
     * requires a JSON as the next positional arg
     * @param name
     */
    consumeJSON(name: string) {
        if (this.positional.length == 0) {
            color.logErr(`expected ${name} as { }`)
            process.exit(1)
        }
        if (typeof this.positional[0] === "string") {
            color.logErr(`expected ${name} as {... } got a string: '${this.positional[0]}'`)
            process.exit(1)
        }
        return this.positional.shift() as any
    }

    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs() {
        if (this.positional.length) {
            color.logErr(`unrecognized extra arguments`)
            console.log(inspect(this.positional))
            process.exit(1)
        }
    }

    private findDeclarationKey(opt: OptionDeclaration) {
        for (const key in this.optDeclarations) {
            if (opt.shortName && this.optDeclarations[key].shortName == opt.shortName) return key
            if (opt.helpText && this.optDeclarations[key].helpText == opt.helpText) return key
        }
        throw new Error("shortName|helpText not found in declarations: " + inspect(opt))
    }

    /**
     * requires the presence of an option with a string value
     * @param optionName option name
     */
    requireOptionString(opt: OptionDeclaration): void {
        if (opt.value == undefined || opt.value == "" || opt.value == {}) {
            const key = this.findDeclarationKey(opt)
            color.logErr(`required --${key}`)
            process.exit(1)
        }
    }

    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(opt: OptionDeclaration, units: "N" | "Y"): void {
        const value: string = opt.value.toString().trim()

        const key = this.findDeclarationKey(opt)
        if (!value) {
            color.logErr(`required --${key} [number]`)
            process.exit(1)
        }

        const converted = this.convertAmount(value, units, key)
        opt.value = converted // store in the required units
    }

    /**
     * search for the presence of an option
     * removes it from the options if found
     *
     * @param optionName option name
     */
    consumeOption(opt: OptionDeclaration, defaultValue?: string): string {
        const value: string = opt.value as string

        if (value) { // found
            opt.value = undefined // remove from options (consume)
        }

        return value
    }

    /**
     * add options found in command line to nearCliArgs for near-cli
     * @param spawnProcessArgs prepared array for spawning anothe cli tool
     */
    addOptionsTo(spawnProcessArgs: string[]) {
        // for each option
        for (const key in this.optDeclarations) {
            const opt = this.optDeclarations[key] as OptionDeclaration
            const value = opt.value
            if (value) { // if it was set
                spawnProcessArgs.push("--" + key) // add option presence
                if (opt.valueType) { // if the option included a value
                    spawnProcessArgs.push(opt.value) // add option value
                }
            }
        }
    }

    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     *
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value: string, requiredUnits: "N" | "Y", name:string) {
        let result: string
        name = color.yellow + name + color.normal

        if (value.length > 1 && value.endsWith("N")) { // NEARS
            result = value.slice(0, -1) // remove N
            result = result.replace("_", "") // allow 100_000_000, ignore _
            if (requiredUnits == "N") return result // already in Nears

            // Yoctos required -- convert to yoctos
            const parts = result.split(".")
            if (parts.length > 2) {
                color.logErr(name + ": invalid amount format, too many decimal points: " + value)
                process.exit(1)
            }
            if (parts.length == 1) parts.push("") // .0
            const decimalString = parts[1].padEnd(24, '0')
            result = parts[0] + "" + decimalString // +""+ is for making sure + means concat here
            return result
        } else if (value.length > 1 && value.endsWith("Y")) { // YOCTOS
            if (value.includes(".")) {
                color.logErr(name + ": invalid amount format, YOCTOS can't have decimals: " + value)
                process.exit(1)
            }

            result = value.slice(0, -1) // remove Y
            result = result.replace("_", "") // allow 100_000_000, ignore _
            if (requiredUnits == "Y") return result // already in Yoctos

            // NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24)
            } else {
                // insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24)
            }
            return result
        } else {
            color.logErr(name + ": invalid amount format, expecting [0-9.](Y|N). Received: " + value)
            console.log("valid examples are: 0.5N | 100N | 100_000_000Y")
            process.exit(1)
        }
    }

    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    private extractJSONObject(start: number) {
        // find the closing "}"
        let opened = 1
        let end = -1
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n]
            if (item == "{") {
                opened++
            } else if (item == "}") {
                opened--
                if (opened == 0) {
                    end = n
                    break
                }
            }
        }

        if (end == -1) { // unmatched opener error
            color.logErr("Unmatched '{' . remember to put spaces around { and }")
            this.clArgs[start] = color.yellow + "{" + color.normal
            console.log(this.clArgs.join(" "))
            process.exit(1)
        }

        // Here we have start & end for matching { }
        const resultObj:any = {}
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index]
            let propValue

            if (propName == ",") continue

            if ("{}".includes(propName)) {
                color.logErr("expected name:value")
                this.clArgs[index] = color.yellow + propName + color.normal
                console.log(this.clArgs.slice(start, end + 1).join(" "))
                process.exit(1)
            }

            const parts = propName.split(":")
            if (parts.length > 2) {
                color.logErr(` too many ':' (found ${parts.length - 1}) at ${propName}`)
                process.exit(1)
            }
            propName = parts[0]?.trim()
            propValue = parts[1]?.trim()

            if (propValue == undefined || propValue == "") {
                // let's assume the user typed "name: value" instead of "name:value"
                index++ // take the next arg
                propValue = this.clArgs[index]
                if (propValue.endsWith(":")) {
                    color.logErr(` missing value after ':' for ${propName}`)
                }
                if (index >= end || propValue == "}") {
                    console.log(`ERROR: expected value after ${propName}`)
                    process.exit(1)
                }
            }

            if (propValue == "{") { // subornidated object
                const subObj = this.extractJSONObject(index) // recursive***
                // store as object
                resultObj[propName] = subObj.value
                index = subObj.end // skip internal object
                continue
            }
            // it's a string
            // remove ending "," if it's there
            if (propValue.endsWith(",")) propValue = propValue.slice(0, propValue.length - 1)
            // check if it's a number
            if (propValue.slice(0, 1).match(/[0-9]/)) { // starts with a digit
                if (propValue.endsWith("N")) { // amount in nears
                    propValue = this.convertAmount(propValue, "Y", propName) // convert to yocto
                } else if (propValue.endsWith("Y")) { // amount in yocto
                    propValue = propValue.slice(0, -1)
                    propValue = propValue.replace("_", "") // just remove _'s
                }
            }
            // store
            resultObj[propName] = propValue
        } // end for

        // return positions and composed object
        return { start: start, end: end, value: resultObj }
    }

    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */

    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */

    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    private searchOption(option: OptionDeclaration): number {
        const name = this.findDeclarationKey(option)
        const shortName = option.shortName

        // search several possible forms of the option, e.g. -o --o -outdir --outdir
        const variants = ['-' + name, '--' + name]
        if (shortName) { variants.push('--' + shortName, '-' + shortName) }

        // for each item in list
        for (const variant of variants) {
            const inx = this.clArgs.indexOf(variant)
            if (inx >= 0) {
                return inx // found
            }
        }
        return -1// not found
    }
}
// end class CommandLineArgs

'''
'''--- src/lib/util/ControlledError.ts ---
export class ControlledError extends Error {
    soft:boolean

    constructor(message?:string) {
        super(message)
    }
}

'''
'''--- src/lib/util/String.extensions.ts ---
// utils.ts
// ## utility methods

interface String {
  replaceAll: (searched: string, newStr: string) => string;
  quoted(quoteChar: string): string;
  countSpaces(): number;
}

String.prototype.replaceAll = function(searched: string, newStr: string) {
    return searched.replace(new RegExp(searched, 'g'), newStr)
}
String.prototype.quoted = function(quoteChar: string) {
    return `${quoteChar}${this}${quoteChar}`
}
String.prototype.countSpaces = function() {
    // var inx=0
    let inx = 0
    // while inx<this.length
    while (inx < this.length) {
    // if this.charAt(inx) isnt ' ', break
        if (this.charAt(inx) !== ' ') { break }
        // inx++
        inx++
    }// end loop

    // return inx
    return inx
}

/*
//Helper methods to class String.
//Also add 'remove' & 'clear' to class Array

    //    append to class String

        //shim method startsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'startsWith'))
        startsWith = function(text){
            //return this.slice(0, text.length) is text
            return this.slice(0, text.length) === text;
        };

        //shim method endsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'endsWith'))
        endsWith = function(text){
            //return this.slice(-text.length) is text
            return this.slice(-text.length) === text;
        };

        //shim method trimRight()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimRight'))
        trimRight = function(){
            //if no this.length into var inx, return this //empty str
            var inx:=undefined
            if (!((inx=this.length))) {return this};
            //do
            do{

                //inx--
                inx--;
            } while (inx >= 0 && this.charAt(inx) === ' ');// end loop
            //return this.slice(0,inx+1)
            return this.slice(0, inx + 1);
        };

        //shim method trimLeft()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimLeft'))
        trimLeft = function(){
            //if no this.length into var len, return this
            var len:=undefined
            if (!((len=this.length))) {return this};
            //var inx=0
            var inx = 0;
            //while inx<len and this.charAt(inx) is ' '
            while(inx < len && this.charAt(inx) === ' '){
                //inx++
                inx++;
            };// end loop
            //return this.slice(inx)
            return this.slice(inx);
        };

//.capitalized

        //method capitalized returns string
        // ---------------------------
        capitalized = function(){
           //if this, return "#{this.charAt(0).toUpperCase()}#{this.slice(1)}"
           if (this) {return `${this.charAt(0).toUpperCase()}#{this.slice(1)}`};
        };

//.replaceAll, equiv. to .replace(/./g, newStr)

        //shim method replaceAll(searched,newStr)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'replaceAll'))
        replaceAll = function(searched, newStr){
           //return this.replace(new RegExp(searched,"g"), newStr)
           return this.replace(new RegExp(searched, 'g'), newStr);
        };

//.countSpaces()

        //shim method countSpaces()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'countSpaces'))
        countSpaces = function(){
            //var inx=0
            var inx = 0;
            //while inx<this.length
            while(inx < this.length){
                //if this.charAt(inx) isnt ' ', break
                if (this.charAt(inx) !== ' ') {break};
                //inx++
                inx++;
            };// end loop

            //return inx
            return inx;
        };

//.quoted(quotechar)

        //method quoted(quoteChar)
        // ---------------------------
        quoted = function(quoteChar){
            //return '#{quoteChar}#{this}#{quoteChar}'
            return `${quoteChar}#{this}#{quoteChar}`;
        };

        //shim method rpad(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'rpad'))
        rpad = function(howMany){
            //return .concat(String.spaces(howMany-.length))
            return this.concat(String.spaces(howMany - this.length));
        };

//repeat(howMany)

        //shim method repeat(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'repeat'))
        repeat = function(howMany){
            //if howMany<=0, return ''
            if (howMany <= 0) {return ''};

            //var a=''
            var a = '';
            //while howMany--
            while(howMany--){
                //a &= this
                a += this;
            };// end loop

            //return a
            return a;
        };

    //    append to namespace String

//Checks if a name is Capitalized, unicode aware.
//capitalized is like: /^[A-Z]+[$_a-z0-9]+$/ ,but unicode aware.

        //method isCapitalized(text:string) returns boolean
        // ---------------------------
        isCapitalized = function(text){
            //if text and text.charAt(0) is text.charAt(0).toUpperCase()
            if (text && text.charAt(0) === text.charAt(0).toUpperCase()) {

                //if text.length is 1, return true;
                if (text.length === 1) {return true};

                //for n=1 while n<text.length
                for( var n=1; n < text.length; n++) {
                    //if text.charAt(n) is text.charAt(n).toLowerCase(), return true
                    if (text.charAt(n) === text.charAt(n).toLowerCase()) {return true};
                };// end for n

            };

            //return false
            return false;
        };

//String.findMatchingPair(text,start,closer).
//Note: text[start] MUST be the opener char

        //method findMatchingPair(text:string, start, closer)
        // ---------------------------
        findMatchingPair = function(text, start, closer){
            //var opener=text.charAt(start);
            var opener = text.charAt(start);
            //var opencount=1;
            var opencount = 1;
            //for n=start+1 while n<text.length
            for( var n=start + 1; n < text.length; n++) {
                //if text.charAt(n) is closer and --opencount is 0
                if (text.charAt(n) === closer && --opencount === 0) {

                    //return n
                    return n;
                }
                //if text.charAt(n) is closer and --opencount is 0

                else if (text.charAt(n) === opener) {

                    //opencount++
                    opencount++;
                };
            };// end for n

            //return -1
            return -1;
        };

    //    append to class Array

//method .remove(element)

        //shim method remove(element)  [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'remove'))
        Object.defineProperty(
        ,'remove',{value:function(element){

            //if this.indexOf(element) into var inx >= 0
            var inx:=undefined
            if ((inx=this.indexOf(element)) >= 0) {

                 //return this.splice(inx,1)
                 return this.splice(inx, 1);
            };
        }
        ,enumerable:false
        });

        //shim method clear       [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'clear'))
        Object.defineProperty(
        ,'clear',{value:function(){
            //empty the array
            //for n=1 to .length
            var _end7=this.length;
            for( var n=1; n<=_end7; n++) {
                //.pop
                this.pop();
            };// end for n

        }
        ,enumerable:false
        });

//##Console group

    //    append to namespace console

//Note: Today, Node.js "console" object do not have `group` & `groupEnd` methods
//neither do older browsers

        //properties indentLevel

        //properties indentLevel

        //shim method group()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'group'))
        group = function(){
            //console.log.apply undefined,arguments
            console.log.apply(undefined, Array.prototype.slice.call(arguments));
            //console.indentLevel = console.indentLevel or 0 + 1
            console.indentLevel = console.indentLevel || 0 + 1;
        };

        //shim method groupEnd()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'groupEnd'))
        groupEnd = function(){
            //if console.indentLevel
            if (console.indentLevel) {

                //console.indentLevel--
                console.indentLevel--;
            };
        };
// -----------
// Module code
// -----------
// end of module
*/

'''
'''--- src/lib/util/UTF8FileReader.ts ---
// --------------------
// UTF8FileReader
// --------------------
import * as fs from 'fs'
import { StringDecoder } from "string_decoder"

export class UTF8FileReader {
    filename: string;
    isOpen: boolean = false;
    private chunkSize: number;
    private fd: number; // file handle from fs.OpenFileSync
    private readFilePos: number;
    private readBuffer: Buffer;

    private utf8decoder: StringDecoder

    /**
     * open the file | throw
     * @param filename
     */
    open(filename, chunkSize: number = 16 * 1024) {
        this.chunkSize = chunkSize

        try {
            this.fd = fs.openSync(filename, 'r')
        } catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString())
        }

        this.filename = filename
        this.isOpen = true

        this.readBuffer = Buffer.alloc(this.chunkSize)
        this.readFilePos = 0

        // a StringDecoder is a buffered object that ensures complete UTF-8 multibyte decoding from a byte buffer
        this.utf8decoder = new StringDecoder('utf8')
    }

    /**
     * read another chunk from the file
     * return the decoded UTF8 into a string
     * (or throw)
     * */
    readChunk(): string {
        let decodedString = '' // return '' by default

        if (!this.isOpen) {
            return decodedString
        }

        let readByteCount: number
        try {
            readByteCount = fs.readSync(this.fd, this.readBuffer, 0, this.chunkSize, this.readFilePos)
        } catch (e) {
            throw new Error("reading " + this.filename + ", error:" + e.toString())
        }

        if (readByteCount) {
            // some data read, advance readFilePos
            this.readFilePos += readByteCount
            // get only the read bytes (if we reached the end of the file)
            const onlyReadBytesBuf = this.readBuffer.slice(0, readByteCount)
            // correctly decode as utf8, and store in decodedString
            // yes, the api is called "write", but it decodes a string - it's a write-decode-and-return the string kind-of-thing :)
            decodedString = this.utf8decoder.write(onlyReadBytesBuf)
        } else {
            // read returns 0 => all bytes read
            this.close()
        }
        return decodedString
    }

    close() {
        if (!this.isOpen) {
            return
        }
        fs.closeSync(this.fd)
        this.isOpen = false
        this.utf8decoder.end()
    }
}

'''
'''--- src/lib/util/UTF8FileWriter.ts ---
// --------------------
// UTF8FileReader
// --------------------
import * as fs from 'fs'

export class UTF8FileWriter {
    filename: string;
    isOpen: boolean = false;
    private fd: number; // file handle from fs.OpenFileSync
    indent: number=0

    /**
     * open the file | throw
     * @param filename
     */
    open(filename) {
        try {
            this.fd = fs.openSync(filename, 'w')
        } catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString())
        }

        this.filename = filename
        this.isOpen = true
    }

    /**
     * write text to the file
     * (or throw)
     * */
    write(s: string) {
        if (!this.isOpen) {
            throw new Error(this.filename + " is closed.")
        }

        try {
            fs.writeSync(this.fd, s)
        } catch (e) {
            throw new Error("writing to " + this.filename + ", error:" + e.toString())
        }
    }

    writeLine(s: string) {
        this.write(' '.repeat(this.indent) + s + '\n')
    }

    close() {
        if (!this.isOpen) {
            return
        }
        fs.closeSync(this.fd)
        this.isOpen = false
    }
}

'''
'''--- src/lib/util/color.ts ---

export const normal = '\x1b[39;49m'
export const red = '\x1b[91m'
export const yellow = '\x1b[93m'
export const green = '\x1b[32m'

export function action(msg:string) :void {
    process.stdout.write(msg.padEnd(60,"."))
}
export function logErr(text: string) :void {
    console.error(red + "ERR: " + text + normal)
}
export function greenOK() :void {
    console.log(green + ": OK" + normal)
}

'''
'''--- src/lib/util/logger.ts ---
import * as color from './color.js'
import { ControlledError } from './ControlledError.js'

// Main namespace
/* eslint no-inner-declarations: "off" */

// errorCount = 0
// warningCount = 0

// if storeMessages, messages are pushed at messages[] instead of console.

// storeMessages: boolean
// messages: string Array = []

// Implementation
// ---------------

//     properties

// errorCount = 0
// warningCount = 0

// if storeMessages, messages are pushed at messages[] instead of console.

export let storeMessages: boolean
export const verboseLevel = 1
export let errorCount = 0
export const warningLevel = 0
export let warningCount = 0
export let messages = []

export let debugLevel = 0
export let debugFrom = 0
export let debugTo = 0
export function setDebugLevel(level:number): void {
    debugLevel = level
}
export function setDebugRange(fromLine:number, toLine?:number): void {
    debugFrom = fromLine 
    debugTo = toLine || 0
}

//     method debug
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function debug(...args: any[]): void {
    if (debugLevel) {
        console.error(...args)
    }
}

//     method debugGroup
// ---------------------------
export function debugGroup(...args:string[]) : void{
    if (debugLevel) {
        console.error(...args)
        console.group(...args)
    }
}

//     method debugGroupEnd
// ---------------------------
export function debugGroupEnd():void {
    if (debugLevel) {
        console.groupEnd()
    }
}

//     method error
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function error(...args: any[]):void {
    errorCount++
    // add "ERROR:", send to debug logger
    args.unshift('ERROR:')
    debug(...args)

    // if messages should be stored...
    if (storeMessages) {
        messages.push(args.join(' '))
    } else {
        args.unshift(color.red)
        args.push(color.normal)
        console.error.apply(args.join(' '))
    }
}

//     method warning
// ---------------------------
export function warning(...args: string[]): void {
    warningCount++

    args.unshift('WARNING:')
    debug(...args)

    if (warningLevel > 0) {
        // if messages should be stored...
        if (storeMessages) {
            messages.push(args.join(' '))
        } else {
            args.unshift(color.yellow)
            args.push(color.normal)
            console.error(args.join(' '))
        }
    }
}

//     method msg
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function msg(...args: any[]):void {
    debug(...args)
    if (verboseLevel >= 1) {
        // if messages should be stored...
        if (storeMessages) {
            messages.push(args.join(' '))
        } else {
            console.log(...args)
        }
    }
}

//     method info
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function info(...args:any[]):void {
    if (verboseLevel >= 2) {
        // msg.apply(undefined,args)
        msg(...args)
    }
}

//     method extra
// ---------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function extra(...args:any[]):void {
    if (verboseLevel >= 3) {
        msg(...args)
    }
}

//     method getMessages
// ---------------------------
export function getMessages():string[] {
    // get & clear
    const result = messages
    messages = []
    return result
}

//     method throwControlled(msg)
// ---------------------------
export function throwControlled(errorMsg: string):void {
    // Throws Error, but with a "controlled" flag set,
    // to differentiate from unexpected compiler errors

    debug('Controlled ERROR:', errorMsg)
    throw new ControlledError(errorMsg)
}

'''
'''--- src/lib/util/mkPath.ts ---
// Generated by LiteScript compiler v0.8.9, source: lib/mkPath.lite.md
// -----------
// Module Init
// -----------
//= ============

// import fs, path
import * as fs from 'fs'
import * as path from 'path'

// ---------------------------
// mkPath.toFile
// ---------------------------
export function toFile(filename: string) :void{
    // Create a path to a file
    create(path.dirname(filename))
}

// ---------------------------
// mkPath.create(dirPath)
// ---------------------------
export function create(dirPath:string) :void {
    // Make sure a path exists - Recursive

    if (dirExists(dirPath)) { return } // ok! dir exists

    // else... recursive:
    // try a folder up, until a dir is found (or an error thrown)
    create(path.dirname(dirPath)) // recurse

    // ok, found parent dir! - make the children dir
    fs.mkdirSync(dirPath)

    // return into recursion, creating children subdirs in reverse order (of recursion)
}

//    helper function dirExists(dirPath)
// ---------------------------
export function dirExists(dirPath:string): boolean {
    try {
        if (fs.statSync(dirPath).isDirectory()) {
            return true // ok! exists and is a directory
        } else {
            throw new Error(`${dirPath} exists but IT IS NOT a directory`)
        }
    } catch (err) {
        // if dir does not exists, return false
        if (err.code === 'ENOENT') { return false }
        throw err // another error
    }
}

'''
'''--- src/main/CLIOptions.ts ---
export const options = {

    contractName: {
        shortName: "c",
        helpText: `AccountId where the contract is deployed`,
        valueType: "string",
        value: ""
    },

    accountId: {
        shortName: "acc",
        valueType: "string",
        value: "",
        helpText: `default user accountId, sets signer`
    },

    help: {
        shortName: "h",
        value: false
    },

    verbose: {
        shortName: "v",
        helpText: 'Prints out verbose output',
        value: false
    },

    networkId: {
        shortName: "net",
        helpText: 'default NEAR network ID for the cli-tool being created (defaults to NODE_ENV)',
        valueType: "string",
        value: ""
    },

    output: {
        shortName: "o",
        valueType: "string",
        helpText: `output path (Default .)`,
        value: "."
    },

    nolink: {
        shortName: "nl",
        helpText: `do not run npm link after creation`,
        value: false
    }
}

'''
'''--- src/main/ContractAPI-producer.ts ---
import { ASTBase } from "../lib/Parser/ASTBase"
import * as Grammar from "../lib/Parser/Grammar"
import { Parser } from "../lib/Parser/Parser"
import { CodeWriter, CodeWriterData } from "../lib/Parser/CodeWriter"
import * as logger from "../lib/util/logger"

// let globalTestFlag = false; //if the rust fn is decorated with "#[test]
// let debugProduceLineNumbers = false

class ASTModuleWriter extends Grammar.ASTModule {
    produce() {
        const o = this.owner.codeWriter
        o.writeLine(`
    // ----------------------------------------------
    // generated by create-contract-cli from ${this.owner.lexer.filename}
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    `)
        o.indent += 2
        o.newLine()

        let mainImpl

        // look for main Impl (the one with #[init])
        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                for (const fns of implDecl.children) {
                    if (fns.commentsAndAttr.includes("#[init]")) {
                        mainImpl = implDecl
                    }
                }
            }
        }

        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                if (mainImpl !== undefined && implDecl !== mainImpl) {
                    continue
                } else {
                    // produce children of main impl
                    for (const child of implDecl.children) {
                        child.produce()
                        o.newLine()
                    }
                }
            }
        }
        o.indent -= 2
        o.newLine()
        o.writeLine(`}`)
        o.writeLine(`module.exports = ContractAPI;`)
    }
}
Grammar.ASTModule.prototype.produce = ASTModuleWriter.prototype.produce

class EmptyProducer extends Grammar.Statement {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    produce() {
    }
}
Grammar.ImplDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.StructDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.StaticDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.UseDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.ModDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.ConstDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.TypeDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.MacroInvocation.prototype.produce = EmptyProducer.prototype.produce
Grammar.MatchExpression.prototype.produce = EmptyProducer.prototype.produce

class FunctionDeclarationWriter extends Grammar.FunctionDeclaration {

    produceContractAPI() :void{

        const o = this.owner.codeWriter
        if (!this.isPublic) {
            // o.writeLine(`NON-PUB fn ${this.name}`) //debug
            return // only pub fns are part of the ContractAPI
        }

        const fnName = this.name
        let isView = true
        if (fnName == 'new') {
            // always !isVew, doesn't have &[mut] self
            isView = false
        } else {
            const selfParam: Grammar.VariableDecl = this.paramsDeclarations.children[0] as Grammar.VariableDecl
            // pub fn(&mut self) are "calls" -- alter state
            // pub fn(&self) are views -- do not alter state
            isView = !(selfParam.isMut)
        }
        if (isView && this.commentsAndAttr.includes("#[init]")) {
            // it's the init/new pub fn
            isView = false
        }
        logger.debug(">>> " + (isView ? "[view]" : "[call]") + " pub fn " + fnName + this.paramsDeclarations.toString())

        // output pub fn comments
        // this.writeComments() -- no, they're include in the help string

        o.writeLine(`${fnName}_HELP(){ return \``) // start help declaration

        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (let s of this.commentsAndAttr) {
                while (s.startsWith("/")) s = s.slice(1) // remove starting //
                if (s.endsWith("/")) s = s.slice(0, s.length - 1) // remove ending /
                o.writeLine(s.replace(/`/g, "'"))
            }
        }
        o.blankLine()

        // construct usage example from pub fn params
        let argsDecl = ""
        const hasJSONArguments = this.paramsDeclarations.children.length > 1 // 1st = 'self'
        if (hasJSONArguments) {
            o.write("{")
            let inx = 0
            for (const paramDecl of this.paramsDeclarations.children) {
                if (paramDecl.name !== 'self') { // rust 'self' is implicit 'this' in ts
                    if (inx > 0) o.write(", ")
                    paramDecl.produce()
                    inx++
                }
            }
            o.write("}")
        }
        argsDecl = o.getCurrentLine() // save line
        o.clearCurrentLine() // clear
        if (hasJSONArguments) {
            // ensure all { and } have spaces around
            argsDecl = argsDecl.replace(/\{/g, " { ")
            argsDecl = argsDecl.replace(/\}/g, " } ").trim()
        }

        o.writeLine("usage:")
        o.writeLine("> " + o.data.nickname + " " + fnName + " " + argsDecl)

        // Type Annotation -- remove
        /* let hasReturnValue = false;
        if (this.typeAnnotation) {
            if (this.typeAnnotation.name !== "Self") {
                this.typeAnnotation?.produce()
                hasReturnValue = true
            }
        }
        */

        const isPayable = (this.commentsAndAttr.includes("#[payable]"))

        // EXAMPLE -- for the user to add
        // o.blankLine()
        // o.writeLine("example:")
        // o.writeLine(PromptNickName + " " + argsDecl)
        // o.writeLine("this command will " + fnName)
        // o.blankLine()

        o.writeLine("`};") // close help string & help function
        o.blankLine()

        // function as method of ContractAPI
        o.write(fnName)
        o.writeLine(`(a /*:CommandLineArgs*/) /*:${isView?"string":"void"}*/{`) // API receives CommandLineArgs parser utlity
        o.indent += 2 // start body
        o.blankLine()

        if (isPayable) {
            o.writeLine("//function is #payable, --amount option is required")
            o.writeLine("a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required")
        }

        // commented options for the user to expand
        o.writeLine('//--these are some examples on how to consume arguments')
        o.writeLine('//const toAccount = a.consumeString("to Account")')
        o.writeLine('//const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")')
        o.blankLine()

        // get JSON args for the fn
        if (hasJSONArguments) {
            o.writeLine('//get fn arguments as JSON')
            o.writeLine(`const fnJSONParams = a.consumeJSON("${argsDecl}")`)
        } else {
            o.writeLine(`//--${fnName} has no arguments, if you add some, uncomment the following line and send the params in this.call/view`)
            o.writeLine('//const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")')
        }
        o.blankLine()

        // standard end of args mark
        o.writeLine("a.noMoreArgs() // no more positional args should remain")
        o.blankLine()

        // make the view/call
        let invoke:string
        if (isView){
            invoke="return this._view"
        }
        else {
            invoke="this._call"
        }

        let invokeArgs = `"${fnName}"`
        if (hasJSONArguments) invokeArgs += ",fnJSONParams";

        o.writeLine(`${invoke}(${invokeArgs})`)
        o.blankLine()

        //end method
        o.indent -= 2 // end APi method body
        o.writeLine("}")
        o.blankLine()

    // rust contract pub fn Body
    // if (this.children.length) {
    //    o.write(' {')
    //    RustFnBodyWriter.prototype.produceBody.call(this, 4, hasReturnValue)
    //    o.writeLine('}')
    // }
    }
}
Grammar.FunctionDeclaration.prototype.produce = FunctionDeclarationWriter.prototype.produceContractAPI

export class TypeAnnotationWriter extends Grammar.TypeAnnotation {
    produceTS() :void {
        const o = this.owner.codeWriter
        o.write(": ")
        // this.optAddrOf()
        // this.optMut()
        let replaced = this.name.replace("::", ".")
        switch (replaced) {
        case 'str': replaced = "string"; break
        default:
        }
        o.write(replaced)
    // if (this.opt('<')) {
    //    this.children = this.reqSeparatedList(Identifier, ',', '>')
    // }
    }
}
Grammar.TypeAnnotation.prototype.produce = TypeAnnotationWriter.prototype.produceTS

export class VarDeclWriter extends Grammar.VariableDecl {
    produceTS() :void{
        const o = this.owner.codeWriter
        o.write(this.name)
        this.typeAnnotation?.produce()

        if (this.assignedExpression) {
            o.write(" = ")

            if (this.assignedExpression.name === 'env') { // rust 'env' => AS 'Context'
                o.write('Context.')

                switch (this.assignedExpression.root.name) {
                case 'env::signer_account_id':
                    o.write('sender')
                    break

                default:
                    this.assignedExpression.root.produce()
                }
            } else {
                this.assignedExpression.produce()
            }
        }
    }
}
Grammar.VariableDecl.prototype.produce = VarDeclWriter.prototype.produceTS

export class ExpressionWriter extends Grammar.Expression {
    produceTS() :void{
    // const o = this.owner.codeWriter
        this.root?.produce()
    }
}
Grammar.Expression.prototype.produce = ExpressionWriter.prototype.produceTS

export class ParenExpressionWriter extends Grammar.ParenExpression {
    produceTS() :void{
        const o = this.owner.codeWriter
        o.write("(")
        this.produceChildren()
        o.write(")")
    }
}
Grammar.ParenExpression.prototype.produce = ParenExpressionWriter.prototype.produceTS

export class LetStatementWriter extends Grammar.LetStatement {
    produceTS() :void{
        const o = this.owner.codeWriter
        o.write("let ")
        this.produceChildren(", ")
    }
}
Grammar.LetStatement.prototype.produce = LetStatementWriter.prototype.produceTS

export class VarRefWriter extends Grammar.VarRef {
    produceTS() :void{
        const o = this.owner.codeWriter
        if (this.name == 'self') {
            o.write('this')
        } else if (this.name == 'env::log') { // rust 'env::log' => AS logging.log
            o.write('logging.log')
        } else {
            o.write(this.name.replace("::", "."))
        }
        // accessors
        this.produceChildren()
    }
}
Grammar.VarRef.prototype.produce = VarRefWriter.prototype.produceTS

const superObjectLiteralProduce = Grammar.ObjectLiteral.prototype.produce
export class ObjectLiteralWriter extends Grammar.ObjectLiteral {
    produceTS() :void{
        const o = this.owner.codeWriter
        o.indent += 4
        superObjectLiteralProduce.call(this)
        if (this.name) { // "struct-instantiation") {
            o.write(` as ${this.name}`)
        }
        o.indent -= 4
    }
}
Grammar.ObjectLiteral.prototype.produce = ObjectLiteralWriter.prototype.produceTS

export class FunctionArgumentWriter extends Grammar.FunctionArgument {
    produceTS() :void{
        const o = this.owner.codeWriter
        if (this.expression) {
            this.expression.produce()
        } else {
            o.write("undefined") // rust _ wildcard argument
        }
    }
}
Grammar.FunctionArgument.prototype.produce = FunctionArgumentWriter.prototype.produceTS

// ---------------------------
// function outNativeRustConversionMapCollect(item: ASTBase) {
//    //veo si al final de la expresion hay uno o mas .into() o .as_u128() .to_vec() .map() . collect() etc,
//    // que son sufijos de conversiones de rust y de map()
//    const o = item.owner.codeWriter
//    if (item.nativeSuffixes) {
//        for (const suffixIdent of item.nativeSuffixes.children) {
//            o.write(".")
//            suffixIdent.produce()
//            o.write("(")
//            suffixIdent.produceChildren()
//            o.write(")")
//        }
//    }
// }

export class RustClosureWriter extends Grammar.RustClosure {
    produceTS() :void{
        const o = this.owner.codeWriter
        o.write("function(")
        for (const param of this.params) {
            param.produce()
        }
        o.writeLine(") {")
        if (this.children.length == 1 && this.children[0] instanceof Grammar.Expression) {
            o.write("return ")
        }
        this.produceChildren()
        o.writeLine("}")
    }
}
Grammar.RustClosure.prototype.produce = RustClosureWriter.prototype.produceTS

// ---------------------------
export class IfStatementWriter extends Grammar.IfStatement {
    // conditional: Expression
    // ---------------------------
    produceTS() :void{
        const o = this.owner.codeWriter
        o.write("if (")
        this.conditional.produce()
        o.write("){")
        this.children[0].produce()
        o.write("}")
        if (this.children.length > 1) {
            o.write("else {")
            this.children[0].produce()
            o.write("}")
        }
    }
}
Grammar.IfStatement.prototype.produce = IfStatementWriter.prototype.produceTS
// end class IfStatement

export class ContractAPIProducer {
    static produce(root: ASTBase, data: CodeWriterData, outFilename: string) :void{
        const parser: Parser = root.owner
        parser.codeWriter = new CodeWriter(outFilename, data)

        root.produce()

        parser.codeWriter.close()
    }
}

'''
'''--- src/main/create-contract-cli.ts ---
import * as path from "path"
import * as fs from "fs"
import * as mkPath from "../lib/util/mkPath"
import * as color from '../lib/util/color.js'
import * as child_process from "child_process"
import * as logger from "../lib/util/logger"
import { Parser } from "../lib/Parser/Parser"
import { ContractAPIProducer as Producer } from "./ContractAPI-producer"
import { ASTModule } from "../lib/Parser/Grammar"
import { CommandLineArgs, ShowHelpOptions } from "../lib/util/CommandLineArgs"
import { options } from "./CLIOptions"
//import { URL } from "url"

type dataInfo = {
    nickname: string;
}

// produce ContractAPI by parsing cotract/src/lib.rs
export function parseAndProduceAPIfor(rustFile: string, data: dataInfo, outFile: string): void {
    logger.setDebugLevel(0)

    // parse
    color.action(`Parsing ${rustFile}`)
    let parsedModule: ASTModule
    try {
        const parser = new Parser({ skipFunctionBody: true })
        // parse rust lib file
        parsedModule = parser.parseFile(rustFile)
    } catch (ex) {
        console.log(color.red + "ERR")
        console.log(ex.message + color.normal)
        color.logErr("parsing " + rustFile)
        console.log(color.green + "Workarounds:" + color.normal)
        console.log("* [fast] Simplify yout lib.rs (move non pub fns to internal.rs or util.rs)")
        console.log("* [slow] Report this issue at github.com/luciotato/create-contract-cli/issues - include your lib.rs" + color.normal)
        if (logger.debugLevel) {
            console.log(ex)
            throw (ex)
        }
        process.exit(1)
    }
    color.greenOK()

    // make output path
    try {
        mkPath.create(path.dirname(outFile))
    } catch (ex) {
        color.logErr("creating dir " + path.dirname(outFile))
        throw (ex)
    }

    // produce
    color.action(`Producing ${outFile}`)
    try {
        Producer.produce(parsedModule, data, outFile)
    } catch (ex) {
        console.log(color.red + "ERR")
        console.log(ex.message + color.normal)
        color.logErr("producing for " + parsedModule?.name)
        // console.log(color.green + "Workarounds:" + color.normal)
        // console.log("* Simplify yout lib.rs (move to util.rs or internal.rs) [fast]")
        // console.log("* You can report an issue on github.com/luciotato/create-contract-cli/issues [slow]" + color.normal)
        if (logger.debugLevel) {
            console.log(ex)
            throw (ex)
        }
        process.exit(2)
    }
    color.greenOK()
}

// ---------------------------
// ------ MAIN ---------------
// ---------------------------
function main() {
    const args = new CommandLineArgs(options)

    // Show help
    if (options.help.value) {
        console.log("create-command-cli")
        console.log("Parses your rust NEAR contract code interface from src/lib.rs and generates a cli-tool tailored to that contract")
        console.log()
        console.log("usage:")
        console.log(" > create-contact-cli [nickname] path/to/rust-project -c contract_account_id --accountId user_account_id ")
        console.log("where [nickname] is the name of your new cli-tool")
        console.log()
        console.log("Example:")
        console.log(" > create-contact-cli staky core-contracts/staker-pool -c mystaker.stakehouse.betanet --accountId lucio.testnet")
        console.log("This wil create a new cli tool named 'staky', to control the contract at mystaker.stakehouse.betanet")
        console.log("Type 'staky --help' after creation")
        ShowHelpOptions(options)
        process.exit(0)
    }

    const nickname = args.consumeString("nickname")

    const pathToRustProject = args.consumeString("path/to/rust-project")

    //TODO - parse other files besides lib.rs (see core-contracts/lockup)
    // check if we can find the rust source
    const rustSourceFile = path.join(pathToRustProject, "src", "lib.rs")
    try {
        fs.statSync(rustSourceFile)
    } catch (ex) {
        color.logErr("can't find " + rustSourceFile)
        color.logErr(ex.message)
        process.exit(1)
    }

    // both -c & -acc are required
    args.requireOptionString(options.contractName)
    args.requireOptionString(options.accountId)

    // create project dir
    let projectDir = `${nickname}-cli`
    if (options.output.value) projectDir = path.join(options.output.value, projectDir)
    color.action(`Creating dir ${projectDir}`)
    if (mkPath.dirExists(projectDir)){
        color.logErr("dir already exists: "+projectDir)
        process.exit(1)
    }
    try {
        mkPath.create(projectDir)
    } catch (ex) {
        color.logErr("can't mkdir " + projectDir)
        throw (ex)
    }
    color.greenOK()

    // create ContractAPI
    const generatedContractAPI = path.join(projectDir, "ContractAPI.js")
    // by parsing cotract/src/lib.rs
    const data = {
        nickname: nickname,
        defaultContractName: options.contractName.value,
        defaultUserAccountId: options.accountId.value
    }
    //TODO - parse other files besides lib.rs (see core-contracts/lockup)
    parseAndProduceAPIfor(rustSourceFile, data, generatedContractAPI)

    // add auxiliary files
    //console.log("Current dir: " +process.cwd())
    //console.log("this script: " +process.argv[1]) // \usr\local\bin\npm\node_modules\create-contract-cli\bin\cli
    let basedir = path.join(__dirname,"..","..")
    //console.log(__dirname);
    // Prints: /Users/mjr
    //console.log(path.dirname(__filename));
    // Prints: /Users/mjr    
    //let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..")
    if (basedir.startsWith("\\")) basedir = basedir.slice(1) // windows compat remove extra "\"
    basedir=path.relative(process.cwd(),basedir)
    
    color.action(`Completing from ${basedir}/model`)
    try {
        mkPath.create(path.join(projectDir, "util"))

        //create package.json
        let pkg = fs.readFileSync(path.join(basedir, "res", "packageES2018.json")).toString()
        pkg = pkg.replace(/{nickname}/g, nickname)
        pkg = pkg.replace(/{contract}/g, pathToRustProject.replace(/\\/g, "/")) // windows compat: c.\./
        pkg = pkg.replace(/{contractAddress}/g, options.contractName.value)
        fs.writeFileSync(path.join(projectDir, "package.json"), pkg)

        //create cli.js
        let cli = fs.readFileSync(path.join(basedir, "res", "cli.js")).toString()
        cli = cli.replace(/{nickname}/g, nickname)
        fs.writeFileSync(path.join(projectDir, "cli.js"), cli)

        //create CLIConfig.js
        const cliConfigPath = path.join(projectDir, "CLIConfig.js")
        const text = `
        module.exports = {
            nickname: "${nickname}",
            userAccount: "${options.accountId.value}",
            contractAccount: "${options.contractName.value}"
        }
        `;
        fs.writeFileSync(cliConfigPath, text)

        //create ${nickname}.js from model
        //type:module const modelPath = path.join(basedir, "dist", "model", "hand-coded-tom")
        const modelPath = path.join(basedir, "res", "model-ES2018")
        fs.copyFileSync(path.join(modelPath, "tomES2018.js"), path.join(projectDir, nickname + ".js"))

        //copy common files - main dir
        for (const file of ["CLIOptions", "ExtensionAPI"]) {
            fs.copyFileSync(path.join(modelPath, file + ".js"), path.join(projectDir, file + ".js"))
        }
        //copy common files - util dir
        for (const file of ["SpawnNearCli", "CommandLineArgs", "saveConfig", "color"]) {
            fs.copyFileSync(path.join(modelPath, "util", file + ".js"), path.join(projectDir, "util", file + ".js"))
        }

    } catch (ex) {
        color.logErr("copying auxiliary files")
        throw (ex)
    }
    color.greenOK()

    if (options.nolink.value) {
        color.action(`${path.join(projectDir,nickname)} created`)
        color.greenOK()
    }
    else {
        console.log(`cd ${projectDir}`)
        console.log(`Executing npm link`)
        const spawnOptions: child_process.CommonSpawnOptions = {
            shell: true, // shell:true => to be able to invoke on windows
            cwd: projectDir,
            stdio: "inherit"
        }
        const execResult = child_process.spawnSync("npm", ["link"], spawnOptions)
        if (execResult.error) {
            color.logErr(execResult.error.message)
            process.exit(5)
        }

        console.log()
        if (execResult.stderr?.toString().includes("EEXISTS")){
            console.log(color.yellow + "WARN: nmp link may report ERR:code EEXISTS. You can ignore that." + color.normal)
            console.log()
        }
        console.log("now type:")
        console.log(` > ${nickname} --help`)
    }

}

main()

'''
'''--- src/model-TS/.vscode/tasks.json ---
{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    "version": "2.0.0",
    "tasks": [
      {
        "type": "typescript",
        "tsconfig": "tsconfig.json",
        "problemMatcher": ["$tsc"],
        "group": {
          "kind": "build",
          "isDefault": true
        }
      }
    ]
  }
'''
'''--- src/model-TS/CLIConfig.ts ---
export const cliConfig =
{
    userAccount: "luciotato.betanet",
    contractAccount: "testcontract.betanet"
}

'''
'''--- src/model-TS/CLIOptions.ts ---
export const options = {

    accountId: {
        shortName: "acc",
        valueType: "string",
        value: "",
        helpText: `signer accountId`
    },

    masterAccount: {
        shortName: "ma",
        valueType: "string",
        value: "",
        helpText: `master account`
    },

    help: {
        shortName: "h",
        value: false
    },

    info: {
        shortName: "i",
        value: false,
        helpText: 'show configured contract account, default user accountId'
    },

    verbose: {
        shortName: "v",
        helpText: 'Prints out verbose output',
        name: "verbose"
    },

    amount: {
        shortName: "am",
        valueType: "NEAR",
        value: "",
        helpText: `attach NEAR tokens to this call. Example: --amount 100N`

    },
    networkId: {
        shortName: "net",
        valueType: "string",
        value: "",
        helpText: 'NEAR network ID (default is NODE_ENV)'
    },

    contractName: {
        shortName: "c",
        valueType: "string",
        value: "",
        helpText: `Sets default contract account when used with --cliconfig. Otherwise, sets --contractName argument for the near call`
    },

    cliConfig: {
        shortName: "cliconfig",
        value: false,
        helpText: `config this cli, add --contractName xx and --accountId yy to set default contract accountId and user`
    },
}
// # sourceMappingURL=CLIOptions.js.map

'''
'''--- src/model-TS/ContractAPI.ts ---
import * as nearCli from "./util/SpawnNearCli.js"
import { CommandLineArgs } from "./util/CommandLineArgs.js"
import { options } from "./CLIOptions.js"
import { cliConfig } from "./CLIConfig.js"

// name of this script
export const nickname = "tom"

// one function for each pub fn in the contract
// get parameters by consuming from CommandLineParser
export class ContractAPI {
    // this.view helper function
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    _view(command:string, fnJSONparams?:any): string {
        return nearCli.view(cliConfig.contractAccount, command, fnJSONparams, options)
    }
    // this.call helper function
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    _call(command:string, fnJSONparams?:any): string {
        return nearCli.call(cliConfig.contractAccount, command, fnJSONparams, options)
    }

    deploy_help = `
    deploy a WASM file into the account ${cliConfig.contractAccount} and call init function
    
    usage:
    > ${nickname} deploy [--account xx] code.WASM new { owner_id:string, stake_public_key:string, reward_fee_fraction: { numerator:x, denominator:y } }
    
    example:
    > ${nickname} deploy code.WASM new { owner_id:lucio.near, stake_public_key:"7fa387483934", reward_fee_fraction: { numerator:8, denominator:100 } }
    willl deploy code.WASM at ${cliConfig.contractAccount} and then initialize it
    `;

    deploy(a: CommandLineArgs): void {

        const wasmFile = a.consumeString("wasmFile")

        a.optionalString("new") // can be omitted

        const initArgs = a.consumeJSON("init fn params")

        a.noMoreArgs()

        nearCli.spawnNearCli( [
            'deploy',cliConfig.contractAccount, wasmFile,
            "new", initArgs
        ], options)
    }

    ping_help = `
    Distributes rewards and restakes if needed.
    
    usage:
    > ${nickname} ping `;

    ping(a: CommandLineArgs) :void{
        a.noMoreArgs() // end of arguments

        this._call("ping")
    }

    get_accounts_help: string = `
    get registered accounts from the contract
    
    usage:
    > ${nickname} get_accounts { from_index:number, limit:number }
    
    example:
    > ${nickname} get_accounts { from_index:0, limit:10 }
    will get 10 accounts starting from 0
    `;

    get_accounts(a: CommandLineArgs) :string{
        const params = a.consumeJSON("{ from_index:number, limit:number }")

        a.noMoreArgs()

        return this._view("get_accounts", params)
    }

    deposit_help: string = `
    deposit into the contract for staking later
    
    usage:
    > ${nickname} deposit --attach Near-amount
    
    example:
    > ${nickname} deposit --attach 40N
    will deposit 40N on behalf of your account into the pool
    
    `;

    deposit(a: CommandLineArgs) :void{
        a.requireOptionWithAmount(options.amount, "N") // require --amount, in Nears

        a.noMoreArgs()

        this._call("deposit")
    }

    stake_help: string = `
stake deposited unstaked amount

usage:
> ${nickname} stake { amount: 10N }

example:
> ${nickname} stake { amount: 10N }
will stake 10N from the unstaked balance of myaccount.betanet 

`;

    stake(a: CommandLineArgs) :void{
        const stakeJSONargs = a.consumeJSON("{ amount: x }")

        a.noMoreArgs()

        this._call("stake", stakeJSONargs)
    }

    get_total_staked_balance(a: CommandLineArgs) :string{
        a.noMoreArgs()

        return this._view("get_total_staked_balance")
    }

    get_owner_id(a: CommandLineArgs) : string{
        a.noMoreArgs()

        return this._view("get_owner_id")
    }

    get_staking_key(a: CommandLineArgs) :string{
        a.noMoreArgs()

        return this._view("get_staking_key")
    }
}

'''
'''--- src/model-TS/ExtensionAPI.ts ---
#!/bin/node
import { cliConfig } from "./CLIConfig.js"
import { nickname, ContractAPI } from "./ContractAPI.js"
import { options } from "./CLIOptions.js"
import { CommandLineArgs } from "./util/CommandLineArgs.js"
import * as color from "./util/color.js"
import * as nearCli from "./util/SpawnNearCli.js"

// -------------------------
// Contract API extensions
// -------------------------
export class ExtensionAPI extends ContractAPI {

    // hm handy extension example
    hm_help = `How much? 
	converts an amount in Yoctos into a more readable format. 
    Example: 
    >${nickname} hm 30037100000000000000000000
    `
    hm(a: CommandLineArgs): void {
        const str = a.consumeString("amount")
        console.log(color.green,a.convertAmount(str + "Y", "N", "amount"),color.normal)
    }

    // where extension example
    where_help = `Where is the contract? 
    show contract accountId
    Example extension, gives the same information as: ${nickname} --info
    
    Usage:
    >${nickname} where [are] [you]
    `
    where(a: CommandLineArgs): void {
        a.optionalString("are")
        a.optionalString("you")
        a.noMoreArgs()
        console.log("Contract is at ",color.green,cliConfig.contractAccount,color.normal)
        console.log("Default user is ",color.green,cliConfig.userAccount,color.normal)
    }

    // balance extension example
    state_help = `
    Get contract's account state, with more readable numbers
    
    Usage:
    >${nickname} state
    `
    state(a: CommandLineArgs): void {
        a.noMoreArgs()
        nearCli.spawnNearCli(["state", cliConfig.contractAccount], options)
    }

    // deploy extension example
    deploy_help = `call near deploy on ${cliConfig.contractAccount} 
    Example: 
    >${nickname} deploy path/to/wasm
    `
    deploy(a: CommandLineArgs): void {
        //get path from command line
        const wasmFile = a.consumeString("path/to/contract.wasm")
        //spawn near-cli, command=deploy
        nearCli.spawnNearCli(["deploy", cliConfig.contractAccount, wasmFile], options);
    }

    // -----------------------------------------------
    // -----------------------------------------------
    // You can add more extension commands here
    // -----------------------------------------------
    // -----------------------------------------------

    // -----------------------------------------------
    // info Example extension
    // -----------------------------------------------
    /*
    myfn_help = `This is a command extension example wiht variable args. 
	Handy commands you can create composing fn calls to this contract or others

	Usage:
	>${nickname} myfn [account]+
    `
    myfn(a: CommandLineArgs) {
        if (a.positional.length == 0) {
            this.view("myfn", {}) // call myfn on this contract
        } else {
            while (a.positional.length) {
                const account = a.consumeString("another account")
                nearCli.view(account, "myfn", {}, options) // call myfn on one or mode accounts
            }
        }
        process.exit(0)
    }
    */

    // -----------------------------------------------
    // NEP21 Example extension
    // -----------------------------------------------
    /*
    nep21_help = `Call functions on NEP21 contracts.
    Examples:
    >>${nickname} nep21 balance gold.nep21.near         -> get how much gold this contract has
    >>${nickname} nep21 balance my gold.nep21.near      -> get how much gold you have
    >>${nickname} nep21 mint mytoken.near               -> (dev) calls mytoken.near.mint(), minting tokens for you

    >${nickname} nep21 transfer 50 gold.near to lucio.testnet  -> transfer 50e24 gold.near tokens to account lucio.testnet

`
    nep21(a: CommandLineArgs) {
        const subcommand = a.consumeString("sub-command")

        if (subcommand == "balance") {
            let tokenOwner = cliConfig.contractAccount
            if (a.optionalString("my")) tokenOwner = cliConfig.userAccount

            while (a.positional.length) {
                const token = a.consumeString("nep21-contract")
                nearCli.view(token, "get_balance", { owner_id: tokenOwner }, options)
            }
        } else if (subcommand == "mint") {
            const token = a.consumeString("nep21-contract")
            nearCli.call(token, "mint_1e3", {}, options)
        }

        // nearswap nep21 transfer 50000 gold to lucio.testnet
        else if (subcommand == "transfer") {
            const tokAmount = a.consumeAmount("token amount", "Y")

            const token = a.consumeString("nep21-contract")

            a.optionalString("to")

            let toAcc = a.consumeString("to account")
            if (toAcc == "contract") toAcc = cliConfig.contractAccount // this contract

            nearCli.call(token, "transfer", { new_owner_id: toAcc, amount: tokAmount }, options)
        } else {
            console.log("nep21 UNK subcommand " + color.red + subcommand + color.normal)
            process.exit(1)
        }

        process.exit(0)
    }
    */

    /*
    // function depo: example manually coded composed/aternative command
    depo_help: string = `
    shotcut for deposit

    usage:
    > ${nickname} depo amountN [and] [stake]

    example:
    > ${nickname} depo 40N 
    will deposit 40N on into ${nickname}'s pool
    > ${nickname} depo 40N and stake
    will deposit 40N into ${nickname}'s pool and stake it in the same transaction

    `;

    depo(a: CommandLineArgs) {
        options.amount.value = a.consumeAmount("amount to deposit", "N")

        // check if [and] [stake] is next in the command line
        a.optionalString("and")
        const stake = a.optionalString("stake")

        const fnToCall = stake ? "deposit_and_stake" : "deposit"

        a.noMoreArgs()

        return this.call(fnToCall)
    }
    */

    // function info: example manually coded composed command
    /*
    info_help = "get_owner_id, get_staking_key & get_total_staked_balance"

    info(a: CommandLineArgs) {
        this.get_owner_id(a)
        this.get_staking_key(a)
        this.get_total_staked_balance(a)
    }
    */

}
module.exports = ExtensionAPI

'''
'''--- src/model-TS/package-lock.json ---
{
  "name": "hand-coded-tom",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@types/node": {
      "version": "14.11.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.11.2.tgz",
      "integrity": "sha512-jiE3QIxJ8JLNcb1Ps6rDbysDhN4xa8DJJvuC9prr6w+1tIh+QAbYyNF3tyiZNLDBIuBCf4KEcV2UvQm/V60xfA==",
      "dev": true
    },
    "typescript": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.3.tgz",
      "integrity": "sha512-tEu6DGxGgRJPb/mVPIZ48e69xCn2yRmCgYmDugAVwmJ6o+0u1RI18eO7E7WBTLYLaEVVOhwQmcdhQHweux/WPg==",
      "dev": true
    }
  }
}

'''
'''--- src/model-TS/package.json ---
{
  "name": "hand-coded-tom",
  "version": "1.0.0",
  "description": "model for create-command-cli",
  "main": "tom.js",
  "scripts": {
    "test": "tom --help"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/luciotato/tom.git"
  },
  "keywords": [
    "create-command-cli"
  ],
  "author": "Lucio Tato",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/tom/issues"
  },
  "homepage": "https://github.com/luciotato/tom/#readme",
  "devDependencies": {
    "@types/node": "^14.11.2",
    "typescript": "^4.0.3"
  }
}

'''
'''--- src/model-TS/tom.ts ---
#!/bin/node
import { cliConfig } from "./CLIConfig.js"
import { nickname } from "./ContractAPI.js"
import { options } from "./CLIOptions.js"
import { CommandLineArgs, OptionDeclaration, ShowHelpPage } from "./util/CommandLineArgs.js"
import * as color from "./util/color.js"
import { ExtensionAPI } from "./ExtensionAPI.js"
import { saveConfig } from "./util/saveConfig.js"

// default accountId
options.accountId.value = cliConfig.userAccount

// process command line args
const args = new CommandLineArgs(options as unknown as Record<string,OptionDeclaration>)

// command is the 1st positional argument
const command = args.getCommand()

// Show config info if requested
// Set config if requested
if (options.cliConfig.value) {
    saveConfig(options.accountId.value, options.contractName.value)
    process.exit(0)
}
if (options.info.value) {
    console.log(`config.js:`)
    console.log(`  Your account    : ${color.yellow}${cliConfig.userAccount}${color.normal}`)
    console.log(`  Contract account: ${color.yellow}${cliConfig.contractAccount}${color.normal}`)
    process.exit(0)
}

// TODO configure
// if (command=="configure") {
//     args.requireOptionString(options.accountId,"default account Id")
//     process.exit(0);
// }

// -------------------
// PROCESS COMMAND //
// -------------------

// get contract API + Extensions
const API = new ExtensionAPI()

// check the command is in the API
// eslint-disable-next-line @typescript-eslint/no-explicit-any
if (command && typeof (API as any)[command] !== "function") {
    color.logErr("unknown command " + color.yellow + command + color.normal)
    console.log(`${nickname} --help to see a list of commands`)
    process.exit(1)
}

// Show help if requested or if no command
if (options.help.value || !command) {
    ShowHelpPage(command, API as unknown as Record<string,unknown>, options as unknown as Record<string,OptionDeclaration>)
    process.exit(0)
}

// call the contract API function
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(API as any)[command](args)

'''
'''--- src/model-TS/tsconfig.json ---
{
    "$schema": "https://json.schemastore.org/tsconfig",
    "display": "Node 12+es2020",
   
    "compilerOptions": {
      "lib": ["es2020", "es2020.promise", "es2020.bigint", "es2020.string"],
      "module": "es2020",
      "target": "es2020",
      "outDir": "dist",
      "sourceMap": true,
   
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    }  
  }
'''
'''--- src/model-TS/util/CommandLineArgs.ts ---
/**
 #Simple and minimum command line args parser
 *
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args.
 *    --Note:  spaces *must* be used around { and }
 *

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/

import { sep } from "path" // host OS path separator
import { inspect } from "util"
import * as color from './color.js'

export type OptionDeclaration =
    {
        shortName: string
        valueType?: string
        helpText?: string
        value?: string|number|boolean
    }

// ----------------------------------------------------
// construct and show help page based on valid options
// ----------------------------------------------------
export function ShowHelpOptions(optionsDeclaration: Record<string,OptionDeclaration>) :void {
    // show help about declared options
    console.log()
    console.log("-".repeat(60))
    console.log("Options:")
    for (const key in optionsDeclaration) {
        let line = ""
        const opt = optionsDeclaration[key]
        let text = "--" + key
        if (opt.valueType) text = text + " " + opt.valueType
        if (opt.shortName) {
            text = text + ", -" + opt.shortName
            if (opt.valueType) text = text + " " + opt.valueType
        }
        line = `  ${text}`.padEnd(50) + (opt.helpText ? opt.helpText : "")
        console.log(line)
    }
    console.log("-".repeat(60))
}

// ----------------------------------------------------
// construct and show a help page based on the API for the commands
// ----------------------------------------------------
export function ShowHelpPage(command: string, contractAPI: Record<string,unknown>, optionsDeclaration: Record<string,OptionDeclaration>): void {
    const commandsHelp: Record<string,string> = {}

    // check all functions in the ContractAPI class, except the class constructor
    const methodNames =
        Object.getOwnPropertyNames(contractAPI.__proto__)
            .filter(name => name !== "constructor" && (command === "" || name === command)) // filter requested command

    // populate commandsHelp
    methodNames.forEach((value) => commandsHelp[value] = "")

    // see which functions have proper help text
    // check all *_help string items in the ContractAPI class
    const properHelpStrings = Object.getOwnPropertyNames(contractAPI)
    for (const item of properHelpStrings) {
        if (item.endsWith("_help") && typeof contractAPI[item] === "string") {
            const method = item.replace("_help", "")
            if (command === "" || command == method) { // filter the requested help
                commandsHelp[method] = contractAPI[item] as string // add proper help
            }
        }
    }
    // print all commands and their help if it's there
    for (const key in commandsHelp) {
        console.log("-".repeat(60))
        console.log('command: ' + key) // name the command
        console.log(commandsHelp[key]) // print the help
    }

    ShowHelpOptions(optionsDeclaration)
}

// --------------------------
// --  main exported class --
// --------------------------
export class CommandLineArgs {
    clArgs: string[] // initial list process.argv

    positional: (string | Record<string,unknown>)[] // string or JSON objects -- positional arguments

    optDeclarations: Record<string,OptionDeclaration>; // pointer to passed option declarations

    constructor(options: Record<string,OptionDeclaration>) {
        this.clArgs = process.argv
        this.optDeclarations = options
        this.positional = []

        // remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node' ||
            this.clArgs[0].endsWith(sep + 'node')) ||
            this.clArgs[0].endsWith(sep + 'node.exe')
        ) {
            this.clArgs = this.clArgs.slice(1)
        }

        // remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1)

        // process each item separating options from posiitonal args

        // First: process --options
        for (const key in options) {
            const optionDecl = options[key]
            // search for option name & variations
            const pos = this.searchOption(optionDecl)
            if (pos >= 0) { // found in command line args
                const literal = this.clArgs[pos] // as written
                this.clArgs.splice(pos, 1) // remove from cl args

                if (optionDecl.valueType) { // has a value
                    if (pos >= this.clArgs.length) {
                        color.logErr("expecting value after " + literal)
                        process.exit(1)
                    }
                    const value = this.clArgs[pos] // take value
                    options[key].value = value // set value
                    this.clArgs.splice(pos, 1) // also remove value from list
                } else // valueless option
                {
                    options[key].value = true // set as present
                }
            }
        }

        // if at this point there are still --options in the command line args array, those are unknown options
        let hasErrors = false
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                color.logErr("UNKNOWN option: " + item)
                hasErrors = true
            }
        }
        if (hasErrors) {
            ShowHelpOptions(options)
            process.exit(1)
        }

        // create consumible positional arguments, parsing also JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index]
            if (item == "{") { // a JSON object in the command line
                const extracted = this.extractJSONObject(index)
                this.positional.push(extracted.value)
                index = extracted.end
            } else {
                this.positional.push(item)
            }
        }
    }

    /**
     * When the first argument is the command to execute
     * returns "" if there's no arguments
     */
    getCommand():string {
        if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            color.logErr("expected a command as first argument'")
            process.exit(1)
        } else {
            if (this.positional.length === 0) return ""
            // take the first argument as this.command
            return this.positional.shift() as string
        }
    }

    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which:string):boolean {
        if (this.positional.length == 0) return false

        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected a string argument, got {... }`)
            process.exit(1)
        }
        if (this.positional[0] == which) {
            this.positional.shift() // consume
            return true
        }
        return false // not the expected string
    }

    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name: string):string {
        if (this.positional.length == 0) {
            color.logErr(`expected '${name}' argument`)
            process.exit(1)
        }
        if (typeof this.positional[0] !== "string") {
            color.logErr(`expected ${name} string argument, got {... }`)
            process.exit(1)
        }
        return this.positional.shift() as string
    }

    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name: string, units: "N"|"Y"|"I"|"F"): string|number {
        const value = this.consumeString(name)
        return this.convertAmount(value, units, name)
    }

    /**
     * requires a JSON as the next positional arg
     * @param name
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consumeJSON(name: string):any {
        if (this.positional.length == 0) {
            color.logErr(`expected ${name} as { }`)
            process.exit(1)
        }
        if (typeof this.positional[0] === "string") {
            color.logErr(`expected ${name} as {... } got a string: '${this.positional[0]}'`)
            process.exit(1)
        }
        return this.positional.shift() as Record<string,unknown>
    }

    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs():void {
        if (this.positional.length) {
            color.logErr(`unrecognized extra arguments`)
            console.log(inspect(this.positional))
            process.exit(1)
        }
    }

    private findDeclarationKey(opt: OptionDeclaration) {
        for (const key in this.optDeclarations) {
            if (opt.shortName && this.optDeclarations[key].shortName == opt.shortName) return key
            if (opt.helpText && this.optDeclarations[key].helpText == opt.helpText) return key
        }
        throw new Error("shortName|helpText not found in declarations: " + inspect(opt))
    }

    /**
     * requires the presence of an option with a string value
     * @param optionName option name
     */
    requireOptionString(opt: OptionDeclaration): void {
        if (opt.value == undefined || opt.value == "" ) {
            const key = this.findDeclarationKey(opt)
            color.logErr(`required --${key}`)
            process.exit(1)
        }
    }

    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(opt: OptionDeclaration, units: "N" | "Y"): void {
        const value: string = opt.value?.toString().trim()||""

        const key = this.findDeclarationKey(opt)
        if (!value) {
            color.logErr(`required --${key} [number]`)
            process.exit(1)
        }

        const converted = this.convertAmount(value, units, key)
        opt.value = converted // store in the required units
    }

    /**
     * search for the presence of an option
     * removes it from the options if found
     *
     * @param optionName option name
     */
    consumeOption(opt: OptionDeclaration): string {
        const value: string = opt.value as string

        if (value) { // found
            opt.value = undefined // remove from options (consume)
        }

        return value
    }

    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     *
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value: string, requiredUnits: "N"|"Y"|"I"|"F", name:string): string|number {
        let result = value.toUpperCase()
        name = color.yellow + name + color.normal
        result = result.replace("_", "") // allow 100_000_000, ignore _

        if (result.endsWith("Y")) { // value ends in "Y"OCTOS
            if (result.includes(".")) {
                color.logErr(name + ": invalid amount format, YOCTOS can't have decimals: " + value)
                process.exit(1)
            }
            result = result.slice(0, -1) // remove Y
            if (requiredUnits == "Y") { return result } // already in Yoctos
            if (requiredUnits == "I"||requiredUnits == "F") { return Number(result) } // a js Number
            // NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24)
            } else {
                // insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24)
            }
            return result
        } else { // other, assume amount in NEARS (default)
            if (!result.slice(-1).match(/\d|N|I|F/)) { //should end with N|I|F or a digit
                color.logErr(name + ": invalid denominator, expected Y|N|I|F => yoctos|near|int|float. Received:"  + result)
                process.exit(1)
            }
            if (result.endsWith("I")||result.endsWith("F")) {
                result = result.slice(0, -1) // remove denom, store as number
                return Number(result)
            }
            if (result.endsWith("N")) result = result.slice(0, -1) // remove N
            if (requiredUnits == "N") { return result } // already in Nears
            // Yoctos required -- convert to yoctos
            const parts = result.split(".")
            if (parts.length > 2) {
                color.logErr(name + ": invalid amount format, too many decimal points: " + value)
                process.exit(1)
            }
            if (parts.length == 1) { parts.push("") } // .0
            const decimalString = parts[1].padEnd(24, '0')
            result = parts[0] + "" + decimalString // +""+ is for making sure + means concat here
            return result
        }
    }

    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    private extractJSONObject(start: number) {
        // find the closing "}"
        let opened = 1
        let end = -1
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n]
            if (item == "{") {
                opened++
            } else if (item == "}") {
                opened--
                if (opened == 0) {
                    end = n
                    break
                }
            }
        }

        if (end == -1) { // unmatched opener error
            color.logErr("Unmatched '{' . remember to put spaces around { and }")
            this.clArgs[start] = color.yellow + "{" + color.normal
            console.log(this.clArgs.join(" "))
            process.exit(1)
        }

        // Here we have start & end for matching { }
        const resultObj:Record<string,unknown> = {}
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index]
            let propValue

            if (propName == ",") continue

            if ("{}".includes(propName)) {
                color.logErr("expected name:value")
                this.clArgs[index] = color.yellow + propName + color.normal
                console.log(this.clArgs.slice(start, end + 1).join(" "))
                process.exit(1)
            }

            const parts = propName.split(":")
            if (parts.length > 2) {
                color.logErr(` too many ':' (found ${parts.length - 1}) at ${propName}`)
                process.exit(1)
            }
            propName = parts[0]?.trim()
            propValue = parts[1]?.trim()

            if (propValue == undefined || propValue == "") {
                // let's assume the user typed "name: value" instead of "name:value"
                index++ // take the next arg
                propValue = this.clArgs[index]
                if (propValue.endsWith(":")) {
                    color.logErr(` missing value after ':' for ${propName}`)
                }
                if (index >= end || propValue == "}") {
                    console.log(`ERROR: expected value after ${propName}`)
                    process.exit(1)
                }
            }

            if (propValue == "{") { // subornidated object
                const subObj = this.extractJSONObject(index) // recursive***
                // store as object
                resultObj[propName] = subObj.value
                index = subObj.end // skip internal object
                continue
            }
            // it's a string
            // remove ending "," if it's there
            if (propValue.endsWith(",")) propValue = propValue.slice(0, propValue.length - 1)
            // check if it's a number
            if (propValue.toUpperCase().match(/^[0-9.]+[Y|N|I|F]{0,1}$/)) { // amount (optionally [Y|N|I|F] expressed in nears. yoctos, integer or float
                propValue = this.convertAmount(propValue, "Y", propName) // process and convert to Yoctos if expressed in nears
            }
            // store
            resultObj[propName] = propValue
        } // end for

        // return positions and composed object
        return { start: start, end: end, value: resultObj }
    }

    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */

    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */

    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    private searchOption(option: OptionDeclaration): number {
        const name = this.findDeclarationKey(option)
        const shortName = option.shortName

        // search several possible forms of the option, e.g. -o --o -outdir --outdir
        const variants = ['-' + name, '--' + name]
        if (shortName) { variants.push('--' + shortName, '-' + shortName) }

        // for each item in list
        for (const variant of variants) {
            const inx = this.clArgs.indexOf(variant)
            if (inx >= 0) {
                return inx // found
            }
        }
        return -1// not found
    }
}
// end class CommandLineArgs

'''
'''--- src/model-TS/util/SpawnNearCli.ts ---
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */

import * as child_process from "child_process"

let debug = 0
export function setDebug(value: 0 | 1 | 2):void { debug = value }

export function decodeHTMLEntities(str:string):string {
    str = str.replace(/&#(\d+);/g, function(match, dec) {
        return String.fromCharCode(dec)
    })
    str = str.replace(/&#(x[A-F0-9]+);/g, function(match, dec) {
        return String.fromCharCode(parseInt("0" + dec))
    })
    return str.replace(/&quot;/g, "'")
}

export function yton(yoctos:string):string {
    let units = yoctos
    if (units.length < 25) units = units.padStart(25, '0')
    units = units.slice(0, -24) + "." + units.slice(-24)
    return units
}

export function spawnNearCli(args:(string|any)[], options:any):string {
    
    //remove empty args
    let inx=0
    while(inx<args.length) if (args[inx]==undefined) args.splice(inx,1); else inx++;
    
    // add options to args for near-cli
    // for each option
    for (const key in options) {
        const opt = options[key]
        const value = opt.value
        if (value) { // if it was set
            args.push("--" + key) // add option presence
            if (opt.valueType) { // if the option included a value
                args.push(opt.value) // add option value
            }
        }
    }

    // -----------------------------
    // near-cli uses NODE_ENV to define --networkId
    // -----------------------------
    // get process.env, clone the actual env vars
    const env = Object.create(process.env)
    const pos = args.indexOf("--networkId")
    if (pos >= 0) {
        const network = args[pos + 1]
        env.NODE_ENV = network
        console.log(`NODE_ENV=${network}`)
    }
    // -----------------------------

    for (let i = 0; i < args.length; i++) {
        if (typeof args[i] !== "string") { // JSON
            args[i] = JSON.stringify(args[i])
            args[i] = args[i].replace(/"/g, '\\"') // add escape before each quote
            args[i] = "\"" + args[i] + "\""
        }
    }

    if (debug || options.verbose?.value) console.log(`near ${args.join(" ")}`)
    const execResult = child_process.spawnSync("near", args, { shell: true, env: env }) // shell:true => to be able to invoke near-cli on windows

    // console.log(execResult.stdout.toString())
    // console.log(execResult.stderr.toString())

    if (execResult.error) {
        console.log(execResult.error)
        process.exit(1)
    }
    let stdo = ""
    if (execResult.stdout) {
        // console.log("stdout:")
        // console.log("-*-")
        // fixes for  near-cli output
        stdo = decodeHTMLEntities(execResult.stdout.toString())
        process.stdout.write(stdo)
        // console.log("-*-")
    }
    if (execResult.stderr) {
        // console.log("stderr:")
        // console.log("-*-")
        process.stdout.write(decodeHTMLEntities(execResult.stderr.toString()))
        // console.log("-*-")
    }

    // show numbers in yoctos converted to more readable units
    // get all numbers where number.lenght>=20
    const numbersFound = stdo.replace(/'/g," ").replace(/"/g," ").match(/.*?['" ]\d{14,50}/g)
    if (numbersFound) {
        // deduplicate
        const numbers = [...new Set(numbersFound)]
        // show conversion to NEARs
        console.log("amounts denomination:")
        for (const text of numbers) {
            const parts=text.split(" ")
            const num=parts.pop()||""
            if (num.length >= 20) {
                // show reference line
                console.log(text.padStart(60, ' ').slice(-60) + " Yoctos => " + yton(num).padStart(38, ' '))
            }
        }
    }

    if (execResult.status != 0) {
        process.exit(execResult.status as number)
    }

    return stdo
}

// -------------------------------------
// extension helper fns at ContractAPI
// -------------------------------------
function nearCli(cv:"call"|"view", contract:string, command:string, fnJSONparams:any, options:any) {
    const nearCliArgs = [
        cv,
        contract,
        command,
        fnJSONparams
    ]
    return spawnNearCli(nearCliArgs, options)
}
// --------------------- call  contract
export function call(contract: string, command: string, fnJSONparams: any, options:any) {
    return nearCli("call", contract, command, fnJSONparams, options)
}
// --------------------- view on contract
export function view(contract: string, command: string, fnJSONparams: any, options:any) {
    return nearCli("view", contract, command, fnJSONparams, options)
}

// format output helper functions
// get single number output on a near view call
export function lastNumber(stdo:string) {
    if (!stdo) return ""
    const items = stdo.split("\n")
    if (items.length < 2) return ""
    return items[items.length - 2].replace(/'/g, "")
}

// formats a large amount adding _ as thousands separator
export function thsep(stdonum:string) {
    if (stdonum && stdonum.length > 3) {
        for (let n = stdonum.length - 3; n >= 1; n -= 3) {
            stdonum = stdonum.slice(0, n) + "_" + stdonum.slice(n)
        }
    }
    return stdonum
}

'''
'''--- src/model-TS/util/color.ts ---

export const normal = '\x1b[39;49m'
export const red = '\x1b[91m'
export const yellow = '\x1b[93m'
export const green = '\x1b[32m'

export function logErr(text: string): void {
    console.error(red + "ERR: " + normal + text)
}

export function greenOK(): void {
    console.log(green + "OK" + normal)
}

'''
'''--- src/model-TS/util/saveConfig.ts ---
import { writeFileSync } from "fs"
import * as path from "path"
import { cliConfig } from "../CLIConfig"
import { red, green, normal } from "./color"

export function saveConfig(userAccount: string, contractAccount: string): void {
    // @ts-ignore -- import.meta.url
    let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..")
    if (basedir.startsWith("\\")) basedir = basedir.slice(1) // windows compat remove extra "\"
    const cliConfigPath = path.join(basedir, "CLIConfig.js")
    process.stdout.write(`saving cli-config to ${cliConfigPath}...`)
    try {

        if (!userAccount) userAccount = cliConfig.userAccount;
        if (!contractAccount) contractAccount = cliConfig.contractAccount;

        const text = `
        export const cliConfig =
            {
                userAccount: "${userAccount}",
                contractAccount: "${contractAccount}"
            }
        `;

        writeFileSync(cliConfigPath, text)
        console.log(`${green}OK${normal}`)
    }
    catch (err) {
        console.log(`${red}ERR:${err.message}${normal}`)
        throw (err)
    }

}
'''
'''--- src/test/expect.ts ---
import { inspect } from "util"
// ------------------------------
// -- function expect().toBe() --
// ------------------------------

// ---------------------------
function deepEqual(object1:any, object2:any) {
    const keys1 = Object.keys(object1)
    const keys2 = Object.keys(object2)

    if (keys1.length !== keys2.length) {
        return false
    }

    for (const key of keys1) {
        const val1 = object1[key]
        const val2 = object2[key]
        const areObjects = isObject(val1) && isObject(val2)
        if (
            areObjects && !deepEqual(val1, val2) ||
            !areObjects && val1 !== val2
        ) {
            console.log(red + val1 + " !== " + val2 + normal)
            return false
        }
    }

    return true
}

function isObject(object) {
    return object != null && typeof object === 'object'
}

let savedTitle: string
let saveReceived: any
const red = '\x1b[91m'
const yellow = '\x1b[93m'
const green = '\x1b[32m'
const normal = '\x1b[39;49m'

function expect(title:string, received:any) {
    savedTitle = title || ""
    saveReceived = received
    return expect.prototype
}
expect.prototype.toBe = function(expected:any) {
    let eq = false
    if (isObject(expected) && isObject(saveReceived)) {
        eq = deepEqual(expected, saveReceived)
    } else {
        eq = (expected == saveReceived)
    }
    if (!eq) {
        console.log(red + "ERR: expect failed: " + savedTitle + normal)
        console.log("      received: " + yellow + inspect(saveReceived, { depth: 10 }) + normal)
        console.log("      expected: " + green + inspect(expected, { depth: 10 }) + normal)
        process.exit(1)
    } else {
        console.log(green + "OK: " + normal + savedTitle)
    }
    return expect.prototype
}

export default expect

'''
'''--- src/test/test-debug.txt ---

//create a cli
node dist/main/main res/test/rust/NEARSwap swap -c nearswap.testnet -o out

//run cli
node dist/model/hand-coded-tom/tom stake { amount: 100N }
'''
'''--- src/test/test-deploy.ts ---
import * as path from "path"
import * as fs from "fs"
import * as mkPath from "../lib/util/mkPath"
import * as color from '../lib/util/color.js'
import * as child_process from "child_process"

let nickname: string = "";
let contractCli: string = "";

//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd: string, args: string[], options?: Record<string, unknown>): number {

    const spawnOptions: child_process.CommonSpawnOptions = {
        shell: true, // shell:true => to be able to invoke on windows
        //cwd: basedir,
        stdio: "inherit"
    }

    if (!options || !options["hideCommand"]) console.log(color.yellow, ">", cmd, ...args, color.normal)
    const execResult = child_process.spawnSync(cmd, args, spawnOptions)
    if (execResult.error) {
        color.logErr(execResult.error.message)
        process.exit(5)
    }
    if (execResult.status !== 0 && (!options || options["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`)
        process.exit(execResult.status)
    }
    return execResult.status
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
function near(command: string, args: string[], options?: Record<string, unknown>): number {
    args.unshift(command)
    return spawn("near", args, options)
}
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command: string, args: string, options?: Record<string, unknown>): number {
    const argsArray = args.split(" ")
    argsArray.unshift(command)
    return spawn("node", argsArray, options)
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args: string, options?: Record<string, unknown>): number {
    console.log(color.yellow, ">", nickname, args, color.normal)

    const argsArray = args.split(" ")
    argsArray.unshift(contractCli)

    if (!options) options = {}
    options["hideCommand"] = true
    return spawn("node", argsArray, options)
}

//-----------------------------------
//-----------------------------------

console.log("---------- START TESTNET DEPLOY TESTS ---------")

const validNetworks = ["test", "testnet", "ci", "development", "local"]
if (!validNetworks.includes(process.env.NODE_ENV)) {
    color.logErr("NODE_ENV must be one of: " + validNetworks.join("|"))
    process.exit(1)
}

// @ts-ignore -- import.meta.url
//let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..")
let basedir = path.join(__dirname, "..","..")
if (basedir.startsWith("\\")) basedir = basedir.slice(1) // windows compat remove extra "\"
basedir = path.relative(process.cwd(), basedir)
console.log(`basedir: ${basedir}`)

// create project dir
const outDir = path.join(basedir, "out")
process.stdout.write(`Creating dir ${outDir}/...`)
try {
    mkPath.create(outDir)
} catch (ex) {
    color.logErr("can't mkdir " + outDir)
    throw (ex)
}
color.greenOK()

const contractAccountFile = path.join(basedir, "neardev", "dev-account");
let contractAccount: string;
//get test account where `near dev-deploy` deployed the contract (if already run)
try {
    contractAccount = fs.readFileSync(contractAccountFile).toString();
}
catch {
    contractAccount = undefined;
}

if (contractAccount) {
    // delete account
    const result = near("delete", [contractAccount, "lucio.testnet"], { ignoreExitStatus: true })
    if (result == 0) fs.unlinkSync(contractAccountFile) //rm file
}

const rustDir = path.join(basedir, "res", "test", "rust")
const wasmFile = path.join(rustDir, "staking-pool", "staking_pool.wasm")
//deploy the contract with near dev-deploy
near("dev-deploy", [wasmFile])

//get contract account
contractAccount = fs.readFileSync(contractAccountFile).toString();
near("state", [contractAccount])

//create a user account different from the contract account
const userAccount = `user.${contractAccount}`
near("create-account", [userAccount, "--masterAccount", contractAccount], { ignoreExitStatus: true })

//create contract-cli named 'staky' for the deployed staking-pool
nickname = "staky"
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`)

//test new staky command
contractCli = path.join(outDir, `${nickname}-cli`, `${nickname}`)

//test call fn "new" - init the contract
cli(`new { owner_id:${userAccount}, stake_public_key:BnLACoaywKGfAEoeKn5HuiAzpn1NTcjTuUkjs44dMiPp, reward_fee_fraction: { numerator:8i, denominator:100i } }`,
    { ignoreExitStatus: true }) //ignore if alerady initialized

cli("get_owner_id")

cli("get_reward_fee_fraction")

cli("deposit -am 1")

cli("deposit -am 0.5")

cli("withdraw_all")

//-------------
// cleanup
//-------------
{
    // delete user account
    near("delete", [userAccount, contractAccount], { ignoreExitStatus: true })
    // delete contract account
    const result = near("delete", [contractAccount, "lucio.testnet"], { ignoreExitStatus: true })
    if (result == 0) fs.unlinkSync(contractAccountFile) //rm file
}

console.log("---------- END TESTNET DEPLOY TESTS ---------")

'''
'''--- src/test/test-staking-pool.ts ---
import * as path from "path"
import * as fs from "fs"
import * as mkPath from "../lib/util/mkPath"
import * as color from '../lib/util/color.js'
import * as child_process from "child_process"

let nickname: string = "";
let contractCli: string = "";

//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd: string, args: string[], options?: Record<string, unknown>): number {

    const spawnOptions: child_process.CommonSpawnOptions = {
        shell: true, // shell:true => to be able to invoke on windows
        //cwd: basedir,
        stdio: "inherit"
    }

    if (!options || !options["hideCommand"]) console.log(color.yellow, ">", cmd, ...args, color.normal)
    const execResult = child_process.spawnSync(cmd, args, spawnOptions)
    if (execResult.error) {
        color.logErr(execResult.error.message)
        process.exit(5)
    }
    if (execResult.status !== 0 && (!options || options["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`)
        process.exit(execResult.status)
    }
    return execResult.status
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
function near(command: string, args: string[], options?: Record<string, unknown>): number {
    args.unshift(command)
    return spawn("near", args, options)
}
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command: string, args: string, options?: Record<string, unknown>): number {
    const argsArray = args.split(" ")
    argsArray.unshift(command)
    return spawn("node", argsArray, options)
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args: string, options?: Record<string, unknown>): number {
    console.log(color.yellow, ">", nickname, args, color.normal)

    const argsArray = args.split(" ")
    argsArray.unshift(contractCli)

    if (!options) options = {}
    options["hideCommand"] = true
    return spawn("node", argsArray, options)
}

//-----------------------------------
//-----------------------------------

console.log("---------- START TESTNET DEPLOY TESTS ---------")

const validNetworks = ["test", "testnet", "ci", "development", "local"]
if (!validNetworks.includes(process.env.NODE_ENV)) {
    color.logErr("NODE_ENV must be one of: " + validNetworks.join("|"))
    process.exit(1)
}

// @ts-ignore -- import.meta.url
let basedir = path.join(path.dirname(new URL(import.meta.url).pathname), "..", "..")
if (basedir.startsWith("\\")) basedir = basedir.slice(1) // windows compat remove extra "\"
basedir = path.relative(process.cwd(), basedir)
console.log(`basedir: ${basedir}`)

// create project dir
const outDir = path.join(basedir, "out")
process.stdout.write(`Creating dir ${outDir}/...`)
try {
    mkPath.create(outDir)
} catch (ex) {
    color.logErr("can't mkdir " + outDir)
    throw (ex)
}
color.greenOK()

const contractAccountFile = path.join(basedir, "neardev", "dev-account");

const rustDir = path.join(basedir, "res", "test", "rust")
const wasmFile = path.join(rustDir, "staking-pool", "staking_pool.wasm")
//deploy the contract with near dev-deploy
near("dev-deploy", [wasmFile])

//get contract account
const contractAccount = fs.readFileSync(contractAccountFile).toString();
near("state", [contractAccount])

//create a user account different from the contract account
const userAccount = `user.${contractAccount}`
near("create-account", [userAccount, "--masterAccount", contractAccount], { ignoreExitStatus: true })

//create contract-cli named 'staky' for the deployed staking-pool
nickname = "staky"
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`)

//test new staky command
contractCli = path.join(outDir, `${nickname}-cli`, `${nickname}`)

//test call fn "new" - init the contract
cli(`new { owner_id:${userAccount}, stake_public_key:BnLACoaywKGfAEoeKn5HuiAzpn1NTcjTuUkjs44dMiPp, reward_fee_fraction: { numerator:8i, denominator:100i } }`,
    { ignoreExitStatus: true }) //ignore if alerady initialized

cli("get_owner_id")

cli("get_reward_fee_fraction")

//cli("deposit -am 1")

cli("deposit_and_stake -am 0.1")
cli("deposit_and_stake -am 0.2")
cli("deposit_and_stake -am 0.3")
cli("deposit_and_stake -am 0.5")

//cli("withdraw_all")
cli("ping")

console.log("---------- END TESTNET DEPLOY TESTS ---------")

'''
'''--- src/test/test.ContractAPI.ts ---
import * as path from "path"
import * as mkPath from "../lib/util/mkPath.js"
import * as logger from "../lib/util/logger.js"
import * as color from '../lib/util/color.js'
import { readFileSync } from "fs"
import { Parser } from "../lib/Parser/Parser.js"
import { ContractAPIProducer as Producer } from "../main/ContractAPI-producer"
import { spawn } from "child_process"

const TESTNAME = "ContractAPI Producer"

type dataInfo = {
    nickname: string;
    defaultContractName: string;
}

export function testFor(rustFile: string, expectedFile:string, data: dataInfo) : void {
    console.log("Testing " + TESTNAME)

    // parse
    let parsedModule
    try {
        const parser = new Parser({skipFunctionBody:true})
        // parse rust lib file
        parsedModule = parser.parseFile(rustFile)
    } catch (ex) {
        console.log(color.red + ex.message + color.normal)
        console.log(ex)
        console.log(process.cwd())
        console.log("Error parsing " + parsedModule?.name)
        throw (ex)
    }

    console.log("parsed ok: " + parsedModule?.name)

    const outPath = "out"
    mkPath.create(outPath)

    console.log("writing temp files in " + path.join(process.cwd(), outPath))

    const generatedFile = path.join(outPath, data.nickname + "-API.js")

    // produce
    try {
        Producer.produce(parsedModule, data, generatedFile)
    } catch (ex) {
        console.log(ex)
        console.log("Error producing " + parsedModule?.name)
        throw (ex)
    }

    const generated = readFileSync(generatedFile)

    const expected = readFileSync(expectedFile)

    if (generated.toString() !== expected.toString()) {
        console.log(color.red + "FAILED " + color.normal)
        console.log("generated: " + generatedFile)
        console.log("expected: " + expectedFile)
        const compareCommand="meld " + generatedFile + " " + expectedFile
        console.log(" > "+compareCommand)
        spawn("meld",[generatedFile,expectedFile])
    } else {
        console.log(TESTNAME + " Test " + color.green + "OK" + color.normal)
    }
}

export function testContractAPIProducer() : void{
    logger.setDebugLevel(0)
    //logger.setDebugRange(1490,1800)

    testFor('./res/test/rust/div-pool/src/lib.rs', "./res/test/expected/div-pool-API.js",
        { nickname: "div", defaultContractName: "diversifying.pools.guildnet" }
    )

    logger.setDebugLevel(0)
    //logger.setDebugRange(1450,1500)

    //testFor('./res/test/rust/NEARSwap/src/lib.rs', "./res/test/expected/swap-API.js",
    //    { nickname: "swap", defaultContractName: "near-clp.betanet" }
    //)

    // logger.setDebugLevel(0)
    //logger.setDebugRange(1450,1500)

    testFor('./res/test/rust/staking-pool/src/lib.rs', "./res/test/expected/staking-pool-API.js",
        { nickname: "staky", defaultContractName: "tomstaker.stakehouse.betanet" }
    )

    // logger.setDebugLevel(0)
    //logger.setDebugRange(1450,1500)

    testFor('./res/test/rust/lockup/src/lib.rs', "./res/test/expected/lockup-API.js",
        { nickname: "lockup", defaultContractName: "testcontract.testnet" }
    )

    testFor('./res/test/rust/multisig/src/lib.rs', "./res/test/expected/multisig-API.js",
        { nickname: "multisig", defaultContractName: "testcontract.testnet" }
    )

    testFor('./res/test/rust/staking-pool-factory/src/lib.rs', "./res/test/expected/factory-API.js",
        { nickname: "factory", defaultContractName: "testcontract.testnet" }
    )

    testFor('./res/test/rust/voting/src/lib.rs', "./res/test/expected/vote-API.js",
        { nickname: "vote", defaultContractName: "testcontract.testnet" }
    )
}

'''
'''--- src/test/test.Tokenizer.ts ---
import { TokenCode, Lexer, Token } from "../lib/Lexer/Lexer.js"
import expect from "./expect.js"

function testThis(rustCode:string, expected:string[]) {
    process.stdout.write("Testing tokenizer ")

    const lexer = new Lexer()

    lexer.startFromString(rustCode)

    const tokens: string[] = []
    while (true) {
        const t: Token = lexer.token
        if (!t.isSpace()) tokens.push(`(${TokenCode[t.tokenCode]} ${t.value})`)
        if (t.tokenCode == TokenCode.EOF) break
        lexer.advance()
    }

    expect("tokenizer", tokens).toBe(expected)
}

export function testTokenizer(): void {
    let rustCode = "\n\
    /// The amount of gas given to complete `vote` call.\n\
    const VOTE_GAS: u64 = 100_000_000_000_000;\n\
    \n\
    /// The amount of gas given to complete internal `on_stake_action` call.\n\
    const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;\n\
    "

    testThis(rustCode,
        ["(COMMENT /// The amount of gas given to complete `vote` call.)",
            "(WORD const)", "(WORD VOTE_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(OPERATOR =)", "(NUMBER 100_000_000_000_000)", "(PUNCTUATION ;)",
            "(COMMENT /// The amount of gas given to complete internal `on_stake_action` call.)",
            "(WORD const)", "(WORD ON_STAKE_ACTION_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(OPERATOR =)", "(NUMBER 20_000_000_000_000)", "(PUNCTUATION ;)",
            "(EOF )"]
    )

    // ---------------------
    rustCode = `
        impl fmt::Display for PoolInfo {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                return write!(
                    f,
                    "({}, {}, {})",
                    self.ynear, self.reserve, self.total_shares
                );
            }
        }`

    testThis(rustCode,
        ['(WORD impl)', '(WORD fmt)', '(PUNCTUATION ::)', '(WORD Display)', '(WORD for)', '(WORD PoolInfo)', '(PUNCTUATION {)',
            '(WORD fn)', '(WORD fmt)', '(PUNCTUATION ()', '(OPERATOR &)', '(WORD self)', '(PUNCTUATION ,)', '(WORD f)',
            '(PUNCTUATION :)', '(OPERATOR &)', '(WORD mut)', '(WORD fmt)', '(PUNCTUATION ::)',
            '(WORD Formatter)', "(PUNCTUATION <')", '(WORD _)', '(OPERATOR >)', '(PUNCTUATION ))',
            '(OPERATOR ->)', '(WORD fmt)', '(PUNCTUATION ::)', '(WORD Result)', '(PUNCTUATION {)',
            '(WORD return)', '(WORD write)', '(OPERATOR !)', '(PUNCTUATION ()',
            '(WORD f)', '(PUNCTUATION ,)',
            '(LITERAL_STRING "({}, {}, {})")',
            '(PUNCTUATION ,)',
            '(WORD self)', '(PUNCTUATION .)', '(WORD ynear)', '(PUNCTUATION ,)', '(WORD self)', '(PUNCTUATION .)', '(WORD reserve)',
            '(PUNCTUATION ,)', '(WORD self)', '(PUNCTUATION .)', '(WORD total_shares)', '(PUNCTUATION ))', '(PUNCTUATION ;)',
            '(PUNCTUATION })',
            '(PUNCTUATION })',
            '(EOF )']
    )
}

'''
'''--- src/test/test.ts ---
import { testTokenizer } from "./test.Tokenizer.js"
import { testContractAPIProducer } from "./test.ContractAPI.js"
import expect from "./expect.js"
import * as child_process from "child_process"
import * as color from '../lib/util/color.js'

import CommandLineArgs = require("../../res/model-ES2018/util/CommandLineArgs.js")
import options = require("../../res/model-ES2018/CLIOptions.js")

const nickname="testy"
const testyContractCliPath="out/"+nickname+"-cli"

//-----------------------------------
// helper fn spawn 
//-----------------------------------
function spawn(cmd: string, args: string[], spawnOpt?: Record<string, unknown>): number {

    const spawnOptions: child_process.CommonSpawnOptions = {
        shell: true, // shell:true => to be able to invoke on windows
        //cwd: basedir,
        stdio: "inherit"
    }

    if (!spawnOpt || !spawnOpt["hideCommand"]) console.log(color.yellow, ">", cmd, ...args, color.normal)
    const execResult = child_process.spawnSync(cmd, args, spawnOptions)
    if (execResult.error) {
        color.logErr(execResult.error.message)
        process.exit(5)
    }
    if (execResult.status !== 0 && (!spawnOpt || spawnOpt["ignoreExitStatus"] == false)) {
        color.logErr(`exit status:${execResult.status}: ${cmd} ${args.join(" ")}`)
        process.exit(execResult.status)
    }
    return execResult.status
}
//-----------------------------------
// helper fn near => spawn near-cli
//-----------------------------------
// function near(command: string, args: string[], spawnOpt?: Record<string, unknown>): number {
//     args.unshift(command)
//     return spawn("near", args, spawnOpt)
// }
//-----------------------------------
// helper fn node => spawn node
//-----------------------------------
function node(command: string, args: string, spawnOpt?: Record<string, unknown>): number {
    const argsArray = args.split(" ")
    argsArray.unshift(command)
    return spawn("node", argsArray, spawnOpt)
}
//-----------------------------------
// helper fn cli => spawn node nickname
//-----------------------------------
function cli(args: string, spawnOpt?: Record<string, unknown>): number {
    console.log(color.yellow, ">", nickname, args, color.normal)

    const argsArray = args.split(" ")
    argsArray.unshift(testyContractCliPath)

    if (!spawnOpt) spawnOpt = {}
    spawnOpt["hideCommand"] = true
    return spawn("node", argsArray, spawnOpt)
}

//-----------------------------
function testCLIparser() {

    let cmdline = `node nearswap add_liquidity { token: "gold.nearswap.testnet", max_tokens: 10, min_shares: 5 } --amount 10`

    process.argv = cmdline.split(' ')

    let a = new CommandLineArgs(options)

    expect("command", a.consumeString("cmd")).toBe("add_liquidity")

    expect("JSON", a.consumeJSON("json args")).toBe({ token:'"gold.nearswap.testnet"', max_tokens: "10" + "".padEnd(24, "0"), min_shares: "5" + "".padEnd(24, "0") })

    expect("options.amount", options.amount.value).toBe(10)

    //no spaces around { }
    cmdline = `node nearswap add_liquidity {token:gold.nearswap.testnet max_tokens:10 min_shares:5} --amount 10`

    process.argv = cmdline.split(' ')

    a = new CommandLineArgs(options)

    expect("command", a.consumeString("cmd")).toBe("add_liquidity")

    expect("JSON", a.consumeJSON("json args")).toBe({ token:"gold.nearswap.testnet", max_tokens: "10" + "".padEnd(24, "0"), min_shares: "5" + "".padEnd(24, "0") })

    expect("options.amount", options.amount.value).toBe(10)

    //no spaces around { } v2
    cmdline = `node staky new {account:lucio.testnet, reward_fee_fraction: {numerator:10i, denominator:8i}} --amount 10N`

    process.argv = cmdline.split(' ')

    a = new CommandLineArgs(options)

    expect("command", a.consumeString("cmd")).toBe("new")

    expect("JSON", a.consumeJSON("json args")).toBe({ account:"lucio.testnet",reward_fee_fraction:{numerator:10, denominator:8}})

    expect("options.amount", options.amount.value).toBe("10N")

}

//------------------------------------------------------
console.log("---------- START PARSE TESTS ---------")

spawn("rm",["-rf","out"])

testCLIparser()

testTokenizer()

testContractAPIProducer()

console.log("---------- END PARSE TESTS ---------")

//------------------------------------------------------
console.log("---------- START dist/main/create-contract-cli TEST ---------")

const contractAccount="AcontractAccount"
const userAccount="AuserAccount"
const outDir = "out" // will add out/testy-cli

//create contract-cli named 'staky' for the deployed staking-pool
node(`dist/main/create-contract-cli`, `${nickname} res/test/rust/staking-pool --contractName ${contractAccount} --accountId ${userAccount} --nolink -o ${outDir}`)

//test json parsing

//test configure contractName & accountId
cli("--cliConfig --contractName contract.account.testnet --accountId yourAccount.near")
cli("--info")
cli(`--cliConfig --contractName ${contractAccount} --accountId test.near`)
cli("--info")

//cleanup (leave /out for meld comparisions)
//spawn("cd",["out", "&&", "rm","-rf", "testy-cli"])

console.log("---------- dist/main/create-contract-cli ---------")

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "module": "CommonJS",
        "target": "ES2018",
        "sourceMap": true,
        "outDir": "dist",
        "rootDir": "src",
    },
    "include": ["src"],
    "exclude": ["z-old","out","dist"]
}

'''