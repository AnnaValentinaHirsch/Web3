*GitHub Repository "mapprotocol/compass"*

'''--- README.md ---
# Compass

Compass is the Golang implementation of cross-chain communication maintainer for MAP Protocol. It currently supports bridging between EVM based chains.

The Compass is an independent service, it contains two operating modes, [Maintainer](#maintainer) and [Messenger](#messenger) mode, users need specify a mode to start the service program

The newly designed compass version contains all the functions required to run the relay node. With this tool, you can run nodes on almost all hardware platforms.

This project is inspired by [ChainSafe/ChainBridge](https://github.com/ChainSafe/ChainBridge)

# Contents

- [Compass](#compass)
- [Contents](#contents)
- [Quick Start](#quick-start)
    - [2. Prepare the accounts for each chain](#2-prepare-the-accounts-for-each-chain)
    - [3. Modify the configuration file](#3-modify-the-configuration-file)
    - [4. Running the executable](#4-running-the-executable)
- [Building](#building)
- [Maintainer](#maintainer)
- [Messenger](#messenger)
- [Monitor](#monitor)
- [Configuration](#configuration)
    - [Options](#options)
  - [Blockstore](#blockstore)
  - [Keystore](#keystore)
- [Chain Implementations](#chain-implementations)
  - [Near](#near)

# Quick Start

the recommanded way to get the executable is to download it from the release page.

>if you want to build it from the source code,check the [building](#building) section below.

### 2. Prepare the accounts for each chain
fund some accounts in order to send txs on each chain, you want to provice crosse-chain service.
the esaiest way is to using the same one address for every chain. Please prepare an account keystore.

### 3. Modify the configuration file
copy a example configure file from
```json
{
  "mapchain": {
    "id": "212",
    "endpoint": "http://18.142.54.137:7445",
    "from": "0xE0DC8D7f134d0A79019BEF9C2fd4b2013a64fCD6",
    "keystorePath": "/root/UTC-E0DC8D7f134d0A79019BEF9C2fd4b2013a64fCD6",
    "opts": {
      "mcs": "0x0ac4611305254cdd257beC56CB79CBeC720Cd02D",
      "lightnode": "0x000068656164657273746F726541646472657373",
      "http": "true",
      "gasLimit": "4000000000000",
      "maxGasPrice": "2000000000000",
      "syncIdList": "[34434]"
    }
  },
  "chains": [
    {
      "name": "pri-eth",
      "type": "ethereum",
      "id": "34434",
      "endpoint": "http://18.138.248.113:8545",
      "from": "0xE0DC8D7f134d0A79019BEF9C2fd4b2013a64fCD6",
      "keystorePath": "/root/UTC-E0DC8D7f134d0A79019BEF9C2fd4b2013a64fCD6",
      "opts": {
        "mcs": "0xcfc80beddb70f12af6da768fc30e396889dfce26",
        "lightnode": "0x80Be41aEBFdaDBD58a65aa549cB266dAFb6b8304",
        "http": "true",
        "gasLimit": "400000000000",
        "maxGasPrice": "200000000000",
        "syncToMap": "true"
      }
    }
  ]
}
```
modify the configuration accordingly.  
fill the accounts for each chain.

### 4. Running the executable
lauch and keep the executable runing simply by run:
```zsh
compass-oracle maintainer --blockstore ./block-eth-map --config ./config-mcs-erh-map.json
```
you will be asked to input the password to unlock your account.(which you have inputed at step 2)
if everything runs smoothly. it's all set

# Building

Building compass requires a [Go](https://github.com/golang/go) compiler(version 1.16 or later)

under the root directory of the repo

`make build`: Builds `compass` in `./build`.  
`make install`: Uses `go install` to add `compass` to your GOBIN.

# Oracle

use the `oracle` mode to synchronize the information of blocks in each chain according to the information in the configuration file

Start with the following command:
```zsh
compass-oracle oracle --blockstore ./block-eth-map --config ./config.json --keystorePath ./key.json
```

# Maintainer

Synchronize the information of blocks in each chain according to the information in the configuration file

Start with the following command:
```zsh
compass-oracle maintainer --blockstore ./block-eth-map --config ./config.json
```

# Messenger

Synchronize the log information of transactions of blocks in each chain according to the information in the configuration file

Start with the following command:
```zsh
compass-oracle messenger --blockstore ./block-eth-map --config ./config.json
```

# Configuration

the configuration file is a small JSON file.

```
{
  "mapchain": {
        "id": "0",                          // Chain ID of the MAP chain
        "endpoint": "ws://<host>:<port>",   // Node endpoint
        "from": "0xff93...",                // MAP chain address of maintainer
        "opts": {}                          // MAP Chain configuration options (see below)
    },
  "chains": []                              // List of Chain configurations
}

```

A chain configurations take this form:

```
{
    "name": "eth",                      // Human-readable name
    "type": "ethereum",                 // Chain type (Please see the following cousin for details)
    "id": "0",                          // Chain ID
    "endpoint": "ws://<host>:<port>",   // Node endpoint
    "from": "0xff93...",                // On-chain address of maintainer
    "keystorePath" : "keystore/path/",  // keystore path, plase user abs path
    "opts": {},                         // Chain-specific configuration options (see below)
}
```

|  chain   | type     |
|:--------:|----------|
| ethereum | ethereum |
|   bsc    | bsc      |
|  goerli  | eth2     |
| polygon  | matic    |
|   near   | near     |
|  klaytn  | klaytn   |
|  platon  | platon   |
| conflux  | conflux  |
|  merlin  | ethereum |
|  blast   | ethereum |
| filecoin | ethereum |
|   bevm   | ethereum |
|   bttc   | bttc     |

See `config.json.example` for an example configuration.

### Options

Since MAP is also a EVM based chain, so the opts of the **mapchain** is following the options below as well  
Ethereum chains support the following additional options:

```
{
    "mcs": "0x12345...",                                    // Address of the bridge contract (required)
    "maxGasPrice": "0x1234",                                // Gas price for transactions (default: 50000000)
    "gasLimit": "0x1234",                                   // Gas limit for transactions (default: 1000000)
    "gasMultiplier": "1.25",                                // Multiplies the gas price by the supplied value (default: 1)
    "startBlock": "1234",                                   // The block to start processing events from (default: 0)
    "blockConfirmations": "10"                              // Number of blocks to wait before processing a block (default: 20)
    "lightnode": "0x12345...",                              // the lightnode to sync header
    "syncToMap": "false",                                   // Whether sync blockchain headers to Map，(default : true)
    "syncIdList": "[214]"                                   // Those chain ids are synchronized to the map，and This configuration can only be used in mapchain
    "event": "mapTransferOut(...)|depositOutToken(...)",    // MCS events monitored by the program, multiple with | interval，
                                                            // Here we give the events that need to be monitored，Map:mapTransferOut(bytes,bytes,bytes32,uint256,uint256,bytes,uint256,bytes) Near: 2ef1cdf83614a69568ed2c96a275dd7fb2e63a464aa3a0ffe79f55d538c8b3b5|150bd848adaf4e3e699dcac82d75f111c078ce893375373593cc1b9208998377
    "oracleNode": "1234"                                    // use to match oracle event                                              
}
```
## Blockstore

The blockstore is used to record the last block the maintainer processed, so it can pick up where it left off.

To disable loading from the chunk library, specify the "--fresh" flag. Add the fresh flag, and the program will execute from height 0，

In addition, the configuration file provides the "startBlock" option, and the program will execute from the startBlock

## Keystore

Compass requires keys to sign and submit transactions, and to identify each bridge node on chain.

To use secure keys, see `compass accounts --help`. The keystore password can be supplied with the `KEYSTORE_PASSWORD` environment variable.

To import external ethereum keys, such as those generated with geth, use `compass accounts import --ethereum /path/to/key`.

To import private keys as keystores, use `compass accounts import --privateKey key`.

# Chain Implementations

- Ethereum (Solidity): [contracts](https://github.com/mapprotocol/contracts)
  The Solidity contracts required for compass. Includes scripts for deployment.

## Near

If you need to synchronize the near block, please install the near cli first. Here is a simple tutorial. For more information, 

please check [Near cli installation tutorial](https://docs.near.org/tools/near-cli#installation)

First, install npm. Depending on the system, the running command is different. The following is an example of the installation command in 

the ubuntu system. Use the `apt install npm` command to run `npm install -g near cli`,

After installation, use 'near -- version' to check whether the installation is successful

Configure the environment you need, for example:

`
  export NEAR_CLI_LOCALNET_RPC_SERVER_URL=https://archival-rpc.testnet.near.org

  export NEAR_ENV=testnet
`

Use the 'near login' command , Creates a key pair locally in `.near-credentials` with an implicit account as the accountId. (hash representation of the public key)

And record the directory to the keystorePath option in the configuration file

In addition, another program needs to be run for near messenger. Please check [near-lake-s3](./near-lake-s3/README.md)

'''
'''--- chains/bsc/chain.go ---
package bsc

import (
	"context"
	"fmt"
	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/core/types"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/bsc"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"math/big"
	"strconv"
)

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error,
	role mapprotocol.Role) (core.Chain, error) {
	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection, chain.OptOfSync2Map(syncHeaderToMap),
		chain.OptOfInitHeight(mapprotocol.HeaderCountOfBsc), chain.OptOfAssembleProof(assembleProof), chain.OptOfOracleHandler(chain.DefaultOracleHandler))
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	remainder := big.NewInt(0).Mod(new(big.Int).Sub(latestBlock, new(big.Int).SetInt64(mapprotocol.HeaderCountOfBsc-1)),
		big.NewInt(mapprotocol.EpochOfBsc))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}
	// synced height check
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get current synced Height failed", "err", err)
		return err
	}
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("CurrentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}
	m.Log.Info("Find sync block", "current height", latestBlock)
	headers := make([]types.Header, mapprotocol.HeaderCountOfBsc)
	for i := 0; i < mapprotocol.HeaderCountOfBsc; i++ {
		headerHeight := new(big.Int).Sub(latestBlock, new(big.Int).SetInt64(int64(i)))
		header, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return err
		}
		headers[mapprotocol.HeaderCountOfBsc-i-1] = *header
	}

	params := make([]bsc.Header, 0, len(headers))
	for _, h := range headers {
		params = append(params, bsc.ConvertHeader(h))
	}
	input, err := mapprotocol.Bsc.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(params)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message   msg.Message
		orderId   = log.Data[:32]
		method    = m.GetMethod(log.Topics[0])
		bigNumber = big.NewInt(int64(log.BlockNumber))
	)
	txsHash, err := tx.GetTxsHashByBlockNumber(m.Conn.Client(), bigNumber)
	if err != nil {
		return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	var receipts []*types.Receipt
	key := strconv.FormatUint(uint64(m.Cfg.Id), 10) + "_" + bigNumber.String()
	if v, ok := proof.CacheReceipt[key]; ok {
		receipts = v
		m.Log.Info("use cache receipt", "latestBlock ", bigNumber, "txHash", log.TxHash)
	} else {
		receipts, err = tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
		if err != nil {
			return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
		}
		proof.CacheReceipt[key] = receipts
	}

	headers := make([]types.Header, mapprotocol.HeaderCountOfBsc)
	for i := 0; i < mapprotocol.HeaderCountOfBsc; i++ {
		headerHeight := new(big.Int).Add(bigNumber, new(big.Int).SetInt64(int64(i)))
		header, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return nil, err
		}
		headers[i] = *header
	}

	params := make([]bsc.Header, 0, len(headers))
	for _, h := range headers {
		params = append(params, bsc.ConvertHeader(h))
	}

	payload, err := bsc.AssembleProof(params, log, receipts, method, m.Cfg.Id, proofType)
	if err != nil {
		return nil, fmt.Errorf("unable to Parse Log: %w", err)
	}

	msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
	message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	return &message, nil
}

'''
'''--- chains/bttc/bttc.go ---
package bttc

import (
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/klaytn/klaytn/rlp"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
)

type BlockHeader struct {
	ParentHash       []byte         `json:"parentHash"`
	Sha3Uncles       []byte         `json:"sha3Uncles"`
	Miner            common.Address `json:"miner"`
	StateRoot        []byte         `json:"stateRoot"`
	TransactionsRoot []byte         `json:"transactionsRoot"`
	ReceiptsRoot     []byte         `json:"receiptsRoot"`
	LogsBloom        []byte         `json:"logsBloom"`
	Difficulty       *big.Int       `json:"difficulty"`
	Number           *big.Int       `json:"number"`
	GasLimit         *big.Int       `json:"gasLimit"`
	GasUsed          *big.Int       `json:"gasUsed"`
	Timestamp        *big.Int       `json:"timestamp"`
	ExtraData        []byte         `json:"extraData"`
	MixHash          []byte         `json:"mixHash"`
	Nonce            []byte         `json:"nonce"`
}

func convertHeader(header *types.Header) BlockHeader {
	bloom := make([]byte, 0, len(header.Bloom))
	for _, b := range header.Bloom {
		bloom = append(bloom, b)
	}
	nonce := make([]byte, 0, len(header.Nonce))
	for _, b := range header.Nonce {
		nonce = append(nonce, b)
	}
	return BlockHeader{
		ParentHash:       util.HashToByte(header.ParentHash),
		Sha3Uncles:       util.HashToByte(header.UncleHash),
		Miner:            constant.ZeroAddress,
		StateRoot:        util.HashToByte(header.Root),
		TransactionsRoot: util.HashToByte(header.TxHash),
		ReceiptsRoot:     util.HashToByte(header.ReceiptHash),
		LogsBloom:        bloom,
		Difficulty:       header.Difficulty,
		Number:           header.Number,
		GasLimit:         new(big.Int).SetUint64(header.GasLimit),
		GasUsed:          new(big.Int).SetUint64(header.GasUsed),
		Timestamp:        new(big.Int).SetUint64(header.Time),
		ExtraData:        header.Extra,
		MixHash:          util.HashToByte(header.MixDigest),
		Nonce:            nonce,
	}
}

type ProofData struct {
	Headers      []BlockHeader
	ReceiptProof ReceiptProof
}

type ReceiptProof struct {
	TxReceipt mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

func AssembleProof(headers []BlockHeader, txIndex uint, fId msg.ChainId, allR []*types.Receipt, cullSys []*types.Receipt, method string) ([]byte, error) {
	receipt, err := mapprotocol.GetTxReceipt(allR[txIndex])
	if err != nil {
		return nil, err
	}

	prf, err := proof.Get(types.Receipts(cullSys), txIndex)
	if err != nil {
		return nil, err
	}

	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))
	ek := util.Key2Hex(key, len(prf))

	pd := ProofData{
		Headers: headers,
		ReceiptProof: ReceiptProof{
			TxReceipt: *receipt,
			KeyIndex:  ek,
			Proof:     prf,
		},
	}

	input, err := mapprotocol.Bttc.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(pd)
	if err != nil {
		return nil, err
	}
	pack, err := mapprotocol.PackInput(mapprotocol.Mcs, method, new(big.Int).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, err
	}

	return pack, nil
}

'''
'''--- chains/bttc/chain.go ---
package bttc

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/mapprotocol/compass/internal/constant"
	"io"
	"math/big"
	"net/http"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

func NewChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection,
		chain.OptOfSync2Map(syncHeaderToMap),
		chain.OptOfInitHeight(mapprotocol.HeaderOneCount),
		chain.OptOfMos(mosHandler),
		chain.OptOfOracleHandler(chain.DefaultOracleHandler),
	)
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	remainder := big.NewInt(0).Mod(new(big.Int).Sub(latestBlock, big.NewInt(mapprotocol.HeaderLenOfBttc)), big.NewInt(mapprotocol.HeaderCountOfBttc))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get current synced Height failed", "err", err)
		return err
	}
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("CurrentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}

	m.Log.Info("Find sync block", "current height", latestBlock)
	startBlock := new(big.Int).Sub(latestBlock, new(big.Int).SetInt64(mapprotocol.HeaderLenOfBttc+1))
	headers := make([]*types.Header, mapprotocol.HeaderLenOfBttc)
	for i := 0; i < int(mapprotocol.HeaderLenOfBttc); i++ {
		headerHeight := new(big.Int).Add(startBlock, new(big.Int).SetInt64(int64(i)))
		header, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return err
		}
		headers[i] = header
	}

	mHeaders := make([]BlockHeader, 0, len(headers))
	for _, h := range headers {
		mHeaders = append(mHeaders, convertHeader(h))
	}

	input, err := mapprotocol.Bttc.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(mHeaders)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func mosHandler(m *chain.Messenger, latestBlock *big.Int) (int, error) {
	if !m.Cfg.SyncToMap {
		return 0, nil
	}
	count := 0
	for idx, topic := range m.Cfg.Events {
		logs, err := filterLogs(m.Cfg.Endpoint, topic.GetTopic().String(), latestBlock)
		if err != nil {
			return 0, fmt.Errorf("unable to Filter Logs: %w", err)
		}

		m.Log.Debug("event", "latestBlock ", latestBlock, " logs ", len(logs))
		for _, log := range logs {
			var message msg.Message
			orderId := log.Data[:32]
			method := m.GetMethod(common.HexToHash(log.Topics[0]))
			txsHash, err := tx.GetTxsHashByBlockNumber(m.Conn.Client(), latestBlock)
			if err != nil {
				return 0, fmt.Errorf("unable to get tx hashes Logs: %w", err)
			}
			allR, cullSys, err := getReceiptsAndTxs(m, txsHash)
			if err != nil {
				return 0, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
			}

			headers := make([]*types.Header, mapprotocol.HeaderLenOfBttc)
			for i := 0; i < int(mapprotocol.HeaderLenOfBttc); i++ {
				headerHeight := new(big.Int).Add(latestBlock, new(big.Int).SetInt64(int64(i)))
				tmp, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
				if err != nil {
					return 0, fmt.Errorf("getHeader failed, err is %v", err)
				}
				headers[i] = tmp
			}

			mHeaders := make([]BlockHeader, 0, len(headers))
			for _, h := range headers {
				mHeaders = append(mHeaders, convertHeader(h))
			}

			payload, err := AssembleProof(mHeaders, 0, m.Cfg.Id, allR, cullSys, method)
			if err != nil {
				return 0, fmt.Errorf("unable to Parse Log: %w", err)
			}

			msgPayload := []interface{}{payload, orderId, latestBlock.Uint64(), log.TransactionHash}
			message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
			message.Idx = idx

			m.Log.Info("Event found", "BlockNumber", log.BlockNumber, "txHash", log.TransactionHash, "logIdx", log.TransactionIndex)
			err = m.Router.Send(message)
			if err != nil {
				m.Log.Error("subscription error: failed to route message", "err", err)
			}
			count++
		}
	}

	return count, nil
}

func getReceiptsAndTxs(m *chain.Messenger, txsHash []common.Hash) ([]*types.Receipt, []*types.Receipt, error) {
	var (
		rs      = make([]*types.Receipt, 0, len(txsHash))
		cullSys = make([]*types.Receipt, 0, len(txsHash))
	)
	for _, h := range txsHash {
		r, err := m.Conn.Client().TransactionReceipt(context.Background(), h)
		if err != nil {
			if err.Error() == "not found" {
				continue
			}
			return nil, nil, err
		}
		if len(txsHash) > 1000 {
			time.Sleep(time.Millisecond * 10)
		}
		rs = append(rs, r)

		oneTx, _, err := m.Conn.Client().TransactionByHash(context.Background(), h)
		if err != nil {
			if err.Error() == "not found" {
				continue
			}
			return nil, nil, err
		}
		message, err := oneTx.AsMessage(types.NewEIP155Signer(big.NewInt(int64(m.Cfg.Id))), nil)
		if err != nil {
			return nil, nil, err
		}
		m.Log.Info("check address", "hash", oneTx.Hash(), "from", message.From(), "to", oneTx.To())
		if oneTx.To().String() == constant.ZeroAddress.String() && message.From() == constant.ZeroAddress {
			continue
		}
		cullSys = append(cullSys, r)
	}
	return rs, cullSys, nil
}

func filterLogs(endpoint, topic string, latestBlock *big.Int) ([]Log, error) {
	url := fmt.Sprintf("%s&topic0=%s&fromBlock=%v&toBlock=%v", endpoint, topic, latestBlock.String(), latestBlock.String())
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}

	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != 299 {
		return nil, fmt.Errorf("getLogs back code is (%v)", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	ret := &Logs{}
	err = json.Unmarshal(body, ret)
	if err != nil {
		return nil, err
	}

	return ret.Result, nil
}

type Logs struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	Result  []Log  `json:"result"`
}

type Log struct {
	Address          string   `json:"address"`
	Topics           []string `json:"topics"`
	Data             string   `json:"data"`
	BlockNumber      string   `json:"blockNumber"`
	BlockHash        string   `json:"blockHash"`
	TimeStamp        string   `json:"timeStamp"`
	GasPrice         string   `json:"gasPrice"`
	GasUsed          string   `json:"gasUsed"`
	LogIndex         string   `json:"logIndex"`
	TransactionHash  string   `json:"transactionHash"`
	TransactionIndex string   `json:"transactionIndex"`
}

'''
'''--- chains/conflux/chain.go ---
package conflux

import (
	"context"
	"fmt"
	"github.com/ethereum/go-ethereum/core/types"
	"math/big"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common/hexutil"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/conflux"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

var (
	skippedRound, startNumber uint64
	cli                       = &conflux.Client{}
)

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	client, err := conflux.NewClient(chainCfg.Opts[chain.Eth2Url])
	if err != nil {
		panic("conflux init client failed" + err.Error())
	}
	cli = client
	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection,
		chain.OptOfSync2Map(syncHeaderToMap),
		chain.OptOfInitHeight(mapprotocol.HeaderOneCount),
		chain.OptOfAssembleProof(assembleProof),
		chain.OptOfOracleHandler(chain.DefaultOracleHandler),
	)
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	state, err := getState(m)
	if err != nil {
		m.Log.Error("Conflux GetConfluxState Failed", "err", err)
		return err
	}
	m.Log.Info("Conflux GetState", "state", state)
	epoch := state.Epoch.Uint64()
	round := state.Round.Uint64() + 1
	if skippedRound > 0 {
		round = skippedRound + 1
	}
	if startNumber == 0 {
		startNumber = state.FinalizedBlockNumber.Uint64()
	} else if state.FinalizedBlockNumber.Uint64() > startNumber {
		m.Log.Info("conflux update endBlock", "startNumber", startNumber, "endNumber", state.FinalizedBlockNumber.Uint64())
		if state.FinalizedBlockNumber.Uint64()-startNumber > 200 {
			err = updateHeaders(m, startNumber, state.FinalizedBlockNumber.Uint64())
			if err != nil {
				return err
			}
		}
		startNumber = state.FinalizedBlockNumber.Uint64()
	}

	committed, err := isCommitted(epoch, round)
	if err != nil {
		m.Log.Error("Conflux isCommitted Failed", "err", err)
		return err
	}
	m.Log.Info("Conflux isCommitted", "committed", committed, "epoch", epoch, "round", round)
	if !committed {
		time.Sleep(time.Second * 5)
		return nil
	}

	ledger, err := cli.GetLedgerInfoByEpochAndRound(
		context.Background(),
		hexutil.Uint64(epoch),
		hexutil.Uint64(round),
	)
	if err != nil && err.Error() != "not found" {
		return errors.WithMessage(err, "Failed to get ledger")
	}

	// no ledger in round, just skip it
	if ledger == nil {
		m.Log.Info("No ledger info in this round", "epoch", epoch)
		skippedRound = round
		time.Sleep(time.Second * 5)
		return nil
	}

	pivot := ledger.LedgerInfo.CommitInfo.Pivot

	// both committee and pow pivot block unchanged
	if ledger.LedgerInfo.CommitInfo.NextEpochState == nil {
		if pivot == nil || uint64(pivot.Height) <= state.FinalizedBlockNumber.Uint64() {
			m.Log.Info("Pos block pivot not changed", "pivot", pivot,
				"finalizedBlockNumber", state.FinalizedBlockNumber, "epoch", epoch, "round", round)
			skippedRound = round
			return nil
		}
	}

	input, err := mapprotocol.Conflux.Methods["relayPOS"].Inputs.Pack(conflux.ConvertLedger(ledger))
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input, true}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	skippedRound = 0
	return nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message msg.Message
		orderId = log.Data[:32]
		method  = m.GetMethod(log.Topics[0])
	)

	pivot, err := nearestPivot(m, new(big.Int).SetUint64(log.BlockNumber+conflux.DeferredExecutionEpochs))
	if err != nil {
		return nil, err
	}

	m.Log.Info("getPivot", "pivot", pivot)
	payload, err := conflux.AssembleProof(cli, log.TxHash, log.BlockNumber, pivot.Uint64(), uint64(proofType), method, m.Cfg.Id)
	if err != nil {
		return nil, fmt.Errorf("unable to Parse Log: %w", err)
	}

	msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
	message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	return &message, nil
}

func getState(m *chain.Maintainer) (*conflux.ILightNodeState, error) {
	data, err := mapprotocol.GetDataByManager(mapprotocol.MethodClientState, big.NewInt(int64(m.Cfg.Id)))
	if err != nil {
		return nil, err
	}
	analysis, err := mapprotocol.Other.Methods[mapprotocol.MethodOfState].Outputs.Unpack(data)
	if err != nil {
		return nil, errors.Wrap(err, "analysis")
	}
	ret := new(conflux.ILightNodeState)
	if err = mapprotocol.Other.Methods[mapprotocol.MethodOfState].Outputs.Copy(&ret, analysis); err != nil {
		return nil, errors.Wrap(err, "analysis copy")
	}
	return ret, nil
}

func nearestPivot(m *chain.Messenger, height *big.Int) (*big.Int, error) {
	pack, err := mapprotocol.Conflux.Methods[mapprotocol.MethodOfNearestPivot].Inputs.Pack(height)
	if err != nil {
		return nil, err
	}
	data, err := mapprotocol.GetDataByManager(mapprotocol.MethodOFinalizedState, big.NewInt(int64(m.Cfg.Id)), pack)
	if err != nil {
		return nil, err
	}
	analysis, err := mapprotocol.Conflux.Methods[mapprotocol.MethodOfNearestPivot].Outputs.Unpack(data)
	if err != nil {
		return nil, errors.Wrap(err, "nearestPivot unpack failed")
	}
	ret := new(big.Int)
	if err = mapprotocol.Conflux.Methods[mapprotocol.MethodOfNearestPivot].Outputs.Copy(&ret, analysis); err != nil {
		return nil, errors.Wrap(err, "nearestPivot copy failed")
	}
	return ret, nil
}

func updateHeaders(m *chain.Maintainer, startNumber, endNumber uint64) error {
	m.Log.Info("Sync Header", "startNumber", startNumber, "endNumber", endNumber)
	headers := make([][]byte, mapprotocol.HeaderLengthOfConflux)
	idx := mapprotocol.HeaderLengthOfConflux - 1
	for i := endNumber; i >= startNumber; i-- {
		blk, err := cli.GetBlockByEpochNumber(context.Background(), hexutil.Uint64(i))
		if err != nil {
			return err
		}

		m.Log.Info("updateHeaders ", "height", i, "idx", idx)
		ele := conflux.MustRLPEncodeBlock(blk)
		headers[idx] = ele
		idx--
		if idx != -1 && i != startNumber {
			continue
		}
		if i == startNumber {
			headers = headers[idx+1:]
		}

		input, err := mapprotocol.Conflux.Methods[mapprotocol.MethodOfGetBlockHeadersBytes].Inputs.Pack(headers)
		if err != nil {
			m.Log.Error("Failed to header abi pack", "err", err)
			return err
		}
		id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
		data, err := mapprotocol.PackInput(mapprotocol.LightManger, mapprotocol.MethodUpdateBlockHeader, id, input)
		if err != nil {
			m.Log.Error("block2Map Failed to pack abi data", "err", err)
			return err
		}
		msgPayload := []interface{}{id, data}
		message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
		err = m.Router.Send(message)
		if err != nil {
			m.Log.Error("Subscription header error: failed to route message", "err", err)
			return nil
		}
		err = m.WaitUntilMsgHandled(1)
		if err != nil {
			return err
		}
		if i != startNumber {
			i++ // special handle
		}
		idx = mapprotocol.HeaderLengthOfConflux - 1
		time.Sleep(time.Second * 2)
	}

	return nil
}

func isCommitted(epoch, round uint64) (bool, error) {
	status, err := cli.GetStatus(context.Background())
	if err != nil {
		return false, errors.WithMessage(err, "Failed to get pos status")
	}

	block, err := cli.GetBlockByNumber(context.Background(), conflux.NewBlockNumber(status.LatestCommitted))
	if err != nil {
		return false, errors.WithMessage(err, "Failed to get the latest committed block")
	}

	if block == nil {
		logrus.Fatal("Latest committed PoS block is nil")
	}

	logrus.WithFields(logrus.Fields{
		"epoch": uint64(block.Epoch),
		"round": uint64(block.Round),
	}).Debug("Latest committed block found")

	if epoch > uint64(block.Epoch) {
		return false, nil
	}

	if epoch < uint64(block.Epoch) {
		return true, nil
	}

	return round <= uint64(block.Round), nil
}

'''
'''--- chains/eth2/chain.go ---
package eth2

import (
	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/log"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/connections/eth2"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/keystore"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/abi"
	"github.com/mapprotocol/compass/pkg/contract"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/pkg/errors"
)

var _ core.Chain = new(Chain)

type Chain struct {
	cfg    *core.ChainConfig   // The config of the chain
	conn   core.Eth2Connection // The chains connection
	writer *chain.Writer       // The writer of the chain
	listen chains.Listener     // The listener of this chain
	stop   chan<- int
}

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (*Chain, error) {
	cfg, err := chain.ParseConfig(chainCfg)
	if err != nil {
		return nil, err
	}

	kpI, err := keystore.KeypairFromEth(cfg.KeystorePath)
	if err != nil {
		return nil, err
	}
	//kp, _ := kpI.(*secp256k1.Keypair)
	bs, err := chain.SetupBlockStore(cfg, role)
	if err != nil {
		return nil, err
	}

	stop := make(chan int)
	conn := eth2.NewConnection(cfg.Endpoint, cfg.Eth2Endpoint, cfg.Http, kpI, logger, cfg.GasLimit, cfg.MaxGasPrice,
		cfg.GasMultiplier)
	err = conn.Connect()
	if err != nil {
		return nil, err
	}

	if chainCfg.LatestBlock {
		curr, err := conn.LatestBlock()
		if err != nil {
			return nil, err
		}
		cfg.StartBlock = curr
	}

	// simplified a little bit
	var listen chains.Listener
	cs := chain.NewCommonSync(conn, cfg, logger, stop, sysErr, bs, chain.OptOfOracleHandler(chain.DefaultOracleHandler))
	switch role {
	case mapprotocol.RoleOfMaintainer:
		fn := mapprotocol.Map2EthHeight(cfg.From, cfg.LightNode, conn.Client())
		height, err := fn()
		if err != nil {
			return nil, errors.Wrap(err, "eth2 get init headerHeight failed")
		}
		logger.Info("map2eth2 Current situation", "height", height, "lightNode", cfg.LightNode)
		mapprotocol.SyncOtherMap[cfg.Id] = height
		mapprotocol.Map2OtherHeight[cfg.Id] = fn
		listen = NewMaintainer(cs, conn.Eth2Client())
	case mapprotocol.RoleOfMessenger:
		oracleAbi, _ := abi.New(mapprotocol.OracleAbiJson)
		call := contract.New(conn, cfg.McsContract, oracleAbi)
		mapprotocol.ContractMapping[cfg.Id] = call
		listen = NewMessenger(cs)
	case mapprotocol.RoleOfOracle:
		listen = chain.NewOracle(cs)
	}
	wri := chain.NewWriter(conn, cfg, logger, stop, sysErr)

	return &Chain{
		cfg:    chainCfg,
		conn:   conn,
		writer: wri,
		stop:   stop,
		listen: listen,
	}, nil
}

func (c *Chain) SetRouter(r *core.Router) {
	r.Listen(c.cfg.Id, c.writer)
	c.listen.SetRouter(r)
}

func (c *Chain) Start() error {
	err := c.listen.Sync()
	if err != nil {
		return err
	}

	log.Debug("Successfully started chain")
	return nil
}

func (c *Chain) Id() msg.ChainId {
	return c.cfg.Id
}

func (c *Chain) Name() string {
	return c.cfg.Name
}

// Stop signals to any running routines to exit
func (c *Chain) Stop() {
	close(c.stop)
	if c.conn != nil {
		c.conn.Close()
	}
}

// EthClient return EthClient for global map connection
func (c *Chain) EthClient() *ethclient.Client {
	return c.conn.Client()
}

// Conn return Connection interface for relayer register
func (c *Chain) Conn() core.Connection {
	return c.conn
}

'''
'''--- chains/eth2/maintainer.go ---
package eth2

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"strconv"
	"time"

	log "github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/eth2"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/mapprotocol"
)

type Maintainer struct {
	*chain.CommonSync
	syncedHeight *big.Int
	eth2Client   *eth2.Client
}

func NewMaintainer(cs *chain.CommonSync, eth2Client *eth2.Client) *Maintainer {
	return &Maintainer{
		CommonSync:   cs,
		eth2Client:   eth2Client,
		syncedHeight: new(big.Int),
	}
}

func (m *Maintainer) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.Log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Maintainer will poll for the latest block and proceed to parse the associated events as it sees new blocks.
// Polling begins at the block defined in `m.Cfg.StartBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to BlockRetryLimit times before continuing to the next block.
func (m *Maintainer) sync() error {
	if !m.Cfg.SyncToMap {
		time.Sleep(time.Hour * 2400)
		return nil
	}
	var currentBlock = m.Cfg.StartBlock
	m.Log.Info("Polling Blocks...", "block", currentBlock)

	err := m.updateSyncHeight()
	if err != nil {
		m.Log.Error("Get synced Height failed", "err", err)
		return err
	}

	if m.syncedHeight.Cmp(currentBlock) != 0 {
		currentBlock.Add(m.syncedHeight, new(big.Int).SetInt64(1))
		m.Log.Info("SyncedHeight is higher or lower than currentHeight, so let currentHeight = syncedHeight",
			"syncedHeight", m.syncedHeight, "currentBlock", currentBlock)
	}

	for {
		select {
		case <-m.Stop:
			return errors.New("polling terminated")
		default:
			err := m.updateSyncHeight()
			if err != nil {
				m.Log.Error("UpdateSyncHeight failed", "err", err)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			startNumber, endNumber, err := mapprotocol.GetEth22MapNumber(m.Cfg.Id)
			if err != nil {
				m.Log.Error("Get startNumber failed", "err", err)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			log.Info("UpdateRange ", "startNumber", startNumber, "endNumber", endNumber)
			if startNumber.Int64() != 0 && endNumber.Int64() != 0 {
				// updateHeader 流程
				err = m.updateHeaders(startNumber, endNumber)
				if err != nil {
					m.Log.Error("updateHeaders failed", "err", err)
					time.Sleep(constant.QueryRetryInterval)
					util.Alarm(context.Background(), fmt.Sprintf("eth2 sync header failed, err is %s", err.Error()))
					continue
				}
			}

			resp, err := m.eth2Client.BeaconHeaders(context.Background(), constant.FinalBlockIdOfEth2)
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			lastFinalizedSlotOnContract := m.syncedHeight
			lastFinalizedSlotOnEth, ok := new(big.Int).SetString(resp.Data.Header.Message.Slot, 10)
			if !ok {
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			if !m.isEnoughBlocksForLightClientUpdate(lastFinalizedSlotOnContract, lastFinalizedSlotOnEth) {
				time.Sleep(time.Second * 60)
				continue
			}

			latestBlock, err := m.Conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			err = m.sendRegularLightClientUpdate(lastFinalizedSlotOnContract, lastFinalizedSlotOnEth)
			if err != nil {
				m.Log.Error("Failed to listen header for block", "block", currentBlock, "err", err)
				if !errors.Is(err, constant.ErrUnWantedSync) {
					util.Alarm(context.Background(), fmt.Sprintf("eth2 sync lightClient failed, err is %s", err.Error()))
				}
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			// Write to block store. Not a critical operation, no need to retry
			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(time.Second * 10)
			} else {
				time.Sleep(time.Millisecond * 20)
			}
		}
	}
}

func (m *Maintainer) updateSyncHeight() error {
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get synced Height failed", "err", err)
		return err
	}

	m.Log.Info("Check Sync Status...", "synced", syncedHeight)
	m.syncedHeight = syncedHeight
	return nil
}

func (m *Maintainer) isEnoughBlocksForLightClientUpdate(lastFinalizedSlotOnContract, lastFinalizedSlotOnEth *big.Int) bool {
	if (lastFinalizedSlotOnEth.Int64() - lastFinalizedSlotOnContract.Int64()) < (constant.SlotsPerEpoch * 1) {
		m.Log.Info("Light client update were send less then 1 epochs ago. Skipping sending light client update",
			"lastFinalizedSlotOnEth", lastFinalizedSlotOnEth, "lastFinalizedSlotOnContract", lastFinalizedSlotOnContract)
		return false
	}
	if lastFinalizedSlotOnEth.Uint64() <= lastFinalizedSlotOnContract.Uint64() {
		m.Log.Info("Last finalized slot on Eth equal to last finalized slot on Contract. Skipping sending light client update.",
			"lastFinalizedSlotOnEth", lastFinalizedSlotOnEth, "lastFinalizedSlotOnContract", lastFinalizedSlotOnContract)
		return false
	}

	return true
}

func (m *Maintainer) getPeriodForSlot(slot uint64) uint64 {
	return slot / uint64(constant.SlotsPerEpoch*constant.EpochsPerPeriod)
}

// sendRegularLightClientUpdate listen header from current chain to Map chain
func (m *Maintainer) sendRegularLightClientUpdate(lastFinalizedSlotOnContract, lastFinalizedSlotOnEth *big.Int) error {
	lastEth2PeriodOnContract := m.getPeriodForSlot(lastFinalizedSlotOnContract.Uint64())
	endPeriod := m.getPeriodForSlot(lastFinalizedSlotOnEth.Uint64())

	var (
		err             error
		lightUpdateData = &eth2.LightClientUpdate{}
	)
	m.Log.Info("Period check", "periodOnContract", lastEth2PeriodOnContract, "endPeriod", endPeriod,
		"slotOnEth", lastFinalizedSlotOnEth, "slotOnContract", lastFinalizedSlotOnContract)
	if lastEth2PeriodOnContract == endPeriod {
		lightUpdateData, err = m.getFinalityLightClientUpdate(lastFinalizedSlotOnContract)
	} else {
		lightUpdateData, err = m.getLightClientUpdateForLastPeriod(lastEth2PeriodOnContract)
	}
	if err != nil {
		return err
	}
	lightClientInput, err := mapprotocol.Eth2.Methods[mapprotocol.MethodOfGetUpdatesBytes].Inputs.Pack(lightUpdateData)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, lightClientInput, true}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)
	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return nil
	}
	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func (m *Maintainer) getFinalityLightClientUpdate(lastFinalizedSlotOnContract *big.Int) (*eth2.LightClientUpdate, error) {
	resp, err := m.eth2Client.FinallyUpdate(context.Background())
	if err != nil {
		return nil, err
	}

	bitvector512 := util.NewBitvector512(util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeBits))
	count := bitvector512.Count()

	m.Log.Info("521 check", "len", len(util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeBits)),
		"count", count, "512Len", bitvector512.Len())

	if count*3 < bitvector512.Len()*2 {
		m.Log.Warn(fmt.Sprintf("not enought sync committe count %d", count))
		return nil, constant.ErrUnWantedSync
	}

	//signatureSlot, err := m.getSignatureSlot(resp.Data.AttestedHeader.Beacon.Slot, &resp.Data.SyncAggregate)
	//if err != nil {
	//	return nil, err
	//}
	signatureSlot, err := strconv.ParseUint(resp.Data.SignatureSlot, 10, 64)
	if err != nil {
		return nil, err
	}

	fhSlot, _ := big.NewInt(0).SetString(resp.Data.FinalizedHeader.Beacon.Slot, 10)
	fhProposerIndex, ok := big.NewInt(0).SetString(resp.Data.FinalizedHeader.Beacon.ProposerIndex, 10)
	if !ok {
		return nil, errors.New("FinalizedHeader Slot Not Number")
	}

	if fhSlot.Cmp(lastFinalizedSlotOnContract) <= 0 {
		m.Log.Warn("Finally slot less than slot on contract", "slot", fhSlot.Int64(), "contract.Int64()", lastFinalizedSlotOnContract.Int64())
		return nil, constant.ErrUnWantedSync
	}

	m.Log.Info("Slot compare", "fhSlot", resp.Data.FinalizedHeader.Beacon.Slot, "fsOnContract ", lastFinalizedSlotOnContract)
	slot, _ := big.NewInt(0).SetString(resp.Data.AttestedHeader.Beacon.Slot, 10)
	proposerIndex, ok := big.NewInt(0).SetString(resp.Data.AttestedHeader.Beacon.ProposerIndex, 10)
	if !ok {
		return nil, errors.New("AttestedHeader Slot Not Number")
	}
	finalityBranch := make([][32]byte, 0, len(resp.Data.FinalityBranch))
	for _, fb := range resp.Data.FinalityBranch {
		finalityBranch = append(finalityBranch, common.HexToHash(fb))
	}

	exeFinalityBranch := make([][32]byte, 0)
	execution := &eth2.ContractExecution{}
	//fmt.Println("resp.Version ", resp.Version)
	if resp.Version == "capella" {
		branches := make([]string, 0, len(resp.Data.FinalizedHeader.ExecutionBranch))
		branches = append(branches, resp.Data.FinalizedHeader.ExecutionBranch...)
		exeFinalityBranch = eth2.GenerateByApi(branches)
		execution, err = eth2.ConvertExecution(&resp.Data.FinalizedHeader.Execution)
		if err != nil {
			return nil, err
		}
	} else {
		block, err := m.eth2Client.GetBlocks(context.Background(), resp.Data.FinalizedHeader.Beacon.Slot)
		if err != nil {
			return nil, err
		}
		branches, txRoot, wdRoot, err := eth2.Generate(resp.Data.FinalizedHeader.Beacon.Slot, m.Cfg.Eth2Endpoint)
		if err != nil {
			return nil, err
		}
		exeFinalityBranch = branches
		block.Data.Message.Body.ExecutionPayload.TransactionsRoot = txRoot
		block.Data.Message.Body.ExecutionPayload.WithdrawalsRoot = wdRoot
		execution, err = eth2.ConvertExecution(&block.Data.Message.Body.ExecutionPayload)
		if err != nil {
			return nil, err
		}
	}

	return &eth2.LightClientUpdate{
		SignatureSlot: signatureSlot,
		SyncAggregate: eth2.ContractSyncAggregate{
			SyncCommitteeBits:      util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeBits),
			SyncCommitteeSignature: util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeSignature),
		},
		AttestedHeader: eth2.BeaconBlockHeader{
			Slot:          slot.Uint64(),
			ProposerIndex: proposerIndex.Uint64(),
			ParentRoot:    common.HexToHash(resp.Data.AttestedHeader.Beacon.ParentRoot),
			StateRoot:     common.HexToHash(resp.Data.AttestedHeader.Beacon.StateRoot),
			BodyRoot:      common.HexToHash(resp.Data.AttestedHeader.Beacon.BodyRoot),
		},
		NextSyncCommittee: eth2.ContractSyncCommittee{
			Pubkeys:         make([]byte, 0),
			AggregatePubkey: make([]byte, 0),
		},
		NextSyncCommitteeBranch: nil,
		FinalityBranch:          finalityBranch,
		FinalizedHeader: eth2.BeaconBlockHeader{
			Slot:          fhSlot.Uint64(),
			ProposerIndex: fhProposerIndex.Uint64(),
			ParentRoot:    common.HexToHash(resp.Data.FinalizedHeader.Beacon.ParentRoot),
			StateRoot:     common.HexToHash(resp.Data.FinalizedHeader.Beacon.StateRoot),
			BodyRoot:      common.HexToHash(resp.Data.FinalizedHeader.Beacon.BodyRoot),
		},
		ExecutionBranch:    exeFinalityBranch,
		FinalizedExecution: execution,
	}, nil
}

func (m *Maintainer) getSignatureSlot(slot string, sa *eth2.SyncAggregate) (uint64, error) {
	var CheckSlotsForwardLimit uint64 = 10
	ahSlot, ok := big.NewInt(0).SetString(slot, 10)
	if !ok {
		return 0, errors.New("ahSlot not number")
	}
	var signatureSlot = ahSlot.Uint64() + 1
	for {
		blocks, err := m.eth2Client.GetBlocks(context.Background(), strconv.FormatUint(signatureSlot, 10))
		if err != nil {
			m.Log.Info("GetSignatureSlot GetBlocks failed", "blockId", signatureSlot, "err", err)
		}

		if blocks != nil && blocks.Data.Message.Body.SyncAggregate.SyncCommitteeSignature == sa.SyncCommitteeSignature {
			break
		}

		signatureSlot += 1
		if signatureSlot-ahSlot.Uint64() > CheckSlotsForwardLimit {
			return 0, errors.New("signature slot not found")
		}
	}

	return signatureSlot, nil
}

func (m *Maintainer) getLightClientUpdateForLastPeriod(lastEth2PeriodOnContract uint64) (*eth2.LightClientUpdate, error) {
	headers, err := m.eth2Client.BeaconHeaders(context.Background(), constant.HeadBlockIdOfEth2)
	if err != nil {
		return nil, err
	}

	headerSlot, ok := big.NewInt(0).SetString(headers.Data.Header.Message.Slot, 10)
	if !ok {
		return nil, errors.New("BeaconHeaders Slot Not Number")
	}

	lastPeriod := m.getPeriodForSlot(headerSlot.Uint64())
	if lastPeriod-lastEth2PeriodOnContract != 1 { // More than one intervals
		lastPeriod = lastEth2PeriodOnContract + 1
	}
	resp, err := m.eth2Client.LightClientUpdate(context.Background(), lastPeriod)
	if err != nil {
		return nil, err
	}
	slot, _ := big.NewInt(0).SetString(resp.Data.AttestedHeader.Beacon.Slot, 10)
	proposerIndex, ok := big.NewInt(0).SetString(resp.Data.AttestedHeader.Beacon.ProposerIndex, 10)
	if !ok {
		return nil, errors.New("AttestedHeader Slot Not Number")
	}

	nextSyncCommitteeBranch := make([][32]byte, 0, len(resp.Data.NextSyncCommitteeBranch))
	for _, b := range resp.Data.NextSyncCommitteeBranch {
		nextSyncCommitteeBranch = append(nextSyncCommitteeBranch, common.HexToHash(b))
	}
	pubKeys := make([]byte, 0, len(resp.Data.NextSyncCommittee.Pubkeys)*48)
	for _, pk := range resp.Data.NextSyncCommittee.Pubkeys {
		pubKeys = append(pubKeys, util.FromHexString(pk)...)
	}
	finalityBranch := make([][32]byte, 0, len(resp.Data.FinalityBranch))
	for _, fb := range resp.Data.FinalityBranch {
		finalityBranch = append(finalityBranch, common.HexToHash(fb))
	}
	fhSlot, _ := big.NewInt(0).SetString(resp.Data.FinalizedHeader.Beacon.Slot, 10)
	fhProposerIndex, ok := big.NewInt(0).SetString(resp.Data.FinalizedHeader.Beacon.ProposerIndex, 10)
	if !ok {
		return nil, errors.New("FinalizedHeader  Slot Not Number")
	}

	exeFinalityBranch := make([][32]byte, 0)
	execution := &eth2.ContractExecution{}
	signatureSlot, err := strconv.ParseUint(resp.Data.SignatureSlot, 10, 64)
	if err != nil {
		return nil, err
	}
	//fmt.Println("resp.Version ", resp.Version)
	if resp.Version == "capella" {
		branches := make([]string, 0, len(resp.Data.FinalizedHeader.ExecutionBranch))
		branches = append(branches, resp.Data.FinalizedHeader.ExecutionBranch...)
		exeFinalityBranch = eth2.GenerateByApi(branches)
		execution, err = eth2.ConvertExecution(&resp.Data.FinalizedHeader.Execution)
		if err != nil {
			return nil, err
		}
	} else {
		block, err := m.eth2Client.GetBlocks(context.Background(), resp.Data.FinalizedHeader.Beacon.Slot)
		if err != nil {
			return nil, err
		}
		branches, txRoot, wdRoot, err := eth2.Generate(resp.Data.FinalizedHeader.Beacon.Slot, m.Cfg.Eth2Endpoint)
		if err != nil {
			return nil, err
		}
		exeFinalityBranch = branches
		block.Data.Message.Body.ExecutionPayload.TransactionsRoot = txRoot
		block.Data.Message.Body.ExecutionPayload.WithdrawalsRoot = wdRoot
		execution, err = eth2.ConvertExecution(&block.Data.Message.Body.ExecutionPayload)
		if err != nil {
			return nil, err
		}
	}
	return &eth2.LightClientUpdate{
		AttestedHeader: eth2.BeaconBlockHeader{
			Slot:          slot.Uint64(),
			ProposerIndex: proposerIndex.Uint64(),
			ParentRoot:    common.HexToHash(resp.Data.AttestedHeader.Beacon.ParentRoot),
			StateRoot:     common.HexToHash(resp.Data.AttestedHeader.Beacon.StateRoot),
			BodyRoot:      common.HexToHash(resp.Data.AttestedHeader.Beacon.BodyRoot),
		},
		SyncAggregate: eth2.ContractSyncAggregate{
			SyncCommitteeBits:      util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeBits),
			SyncCommitteeSignature: util.FromHexString(resp.Data.SyncAggregate.SyncCommitteeSignature),
		},
		SignatureSlot:           signatureSlot,
		NextSyncCommitteeBranch: nextSyncCommitteeBranch,
		NextSyncCommittee: eth2.ContractSyncCommittee{
			Pubkeys:         pubKeys,
			AggregatePubkey: util.FromHexString(resp.Data.NextSyncCommittee.AggregatePubkey),
		},
		FinalityBranch: finalityBranch,
		FinalizedHeader: eth2.BeaconBlockHeader{
			Slot:          fhSlot.Uint64(),
			ProposerIndex: fhProposerIndex.Uint64(),
			ParentRoot:    common.HexToHash(resp.Data.FinalizedHeader.Beacon.ParentRoot),
			StateRoot:     common.HexToHash(resp.Data.FinalizedHeader.Beacon.StateRoot),
			BodyRoot:      common.HexToHash(resp.Data.FinalizedHeader.Beacon.BodyRoot),
		},
		ExecutionBranch:    exeFinalityBranch,
		FinalizedExecution: execution,
	}, nil
}

func (m *Maintainer) updateHeaders(startNumber, endNumber *big.Int) error {
	m.Log.Info("Sync Header", "startNumber", startNumber, "endNumber", endNumber)
	headers := make([]eth2.BlockHeader, mapprotocol.HeaderLengthOfEth2)
	idx := mapprotocol.HeaderLengthOfEth2 - 1
	for i := endNumber.Int64(); i >= startNumber.Int64(); i-- {
		header, err := m.Conn.Client().EthLatestHeaderByNumber(m.Cfg.Endpoint, new(big.Int).SetInt64(i))
		if err != nil {
			return err
		}

		headers[idx] = *eth2.ConvertHeader(header)
		idx--
		if idx != -1 && i != startNumber.Int64() {
			continue
		}
		if i == startNumber.Int64() {
			headers = headers[idx+1:]
		}
		input, err := mapprotocol.Eth2.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(headers)
		if err != nil {
			m.Log.Error("Failed to header abi pack", "err", err)
			return err
		}

		id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
		msgPayload := []interface{}{id, input}
		message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
		err = m.Router.Send(message)
		if err != nil {
			m.Log.Error("Subscription header error: failed to route message", "err", err)
			return nil
		}
		err = m.WaitUntilMsgHandled(1)
		if err != nil {
			return err
		}
		idx = mapprotocol.HeaderLengthOfEth2 - 1
		time.Sleep(time.Second * 2)
	}

	return nil
}

'''
'''--- chains/eth2/messenger.go ---
package eth2

import (
	"context"
	"errors"
	"fmt"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/mapprotocol"
	"math/big"
	"strconv"
	"time"

	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/eth2"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/msg"
)

type Messenger struct {
	*chain.CommonSync
}

func NewMessenger(cs *chain.CommonSync) *Messenger {
	return &Messenger{
		CommonSync: cs,
	}
}

func (m *Messenger) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.Log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Messenger will poll for the latest block and listen the log information of transactions in the block
// Polling begins at the block defined in `m.Cfg.StartBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to BlockRetryLimit times before continuing to the next block.
// However，an error in synchronizing the log will cause the entire program to block
func (m *Messenger) sync() error {
	if !m.Cfg.SyncToMap {
		time.Sleep(time.Hour * 2400)
	}
	var currentBlock = m.Cfg.StartBlock

	for {
		select {
		case <-m.Stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.Conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.RetryLongInterval)
				continue
			}

			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.BlockConfirmations) == -1 {
				m.Log.Debug("Block not ready, will retry", "target", currentBlock, "latest", latestBlock)
				time.Sleep(constant.BalanceRetryInterval)
				continue
			}
			count, err := m.getEventsForBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to get events for block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				util.Alarm(context.Background(), fmt.Sprintf("eth2 mos failed, err is %s", err.Error()))
				continue
			}

			// hold until all messages are handled
			_ = m.WaitUntilMsgHandled(count)

			// Write to block store. Not a critical operation, no need to retry
			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			// Goto next block and reset retry counter
			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(time.Second * 10)
			} else {
				time.Sleep(time.Millisecond * 20)
			}
		}
	}
}

// getEventsForBlock looks for the deposit event in the latest block
func (m *Messenger) getEventsForBlock(latestBlock *big.Int) (int, error) {
	count := 0
	for idx, addr := range m.Cfg.McsContract {
		query := m.BuildQuery(addr, m.Cfg.Events, latestBlock, latestBlock)
		logs, err := m.Conn.Client().FilterLogs(context.Background(), query)
		if err != nil {
			return 0, fmt.Errorf("unable to Filter Logs: %w", err)
		}

		for _, log := range logs {
			// evm event to msg
			var message msg.Message
			orderId := log.Data[:32]
			toChainID, _ := strconv.ParseUint(mapprotocol.MapId, 10, 64)
			if _, ok := mapprotocol.OnlineChaId[msg.ChainId(toChainID)]; !ok {
				m.Log.Info("Map Found a log that is not the current task ", "blockNumber", log.BlockNumber, "toChainID", toChainID)
				continue
			}
			m.Log.Info("Event found", "BlockNumber", log.BlockNumber, "txHash", log.TxHash, "orderId", ethcommon.Bytes2Hex(orderId))
			if err != nil {
				return 0, err
			}
			method := m.GetMethod(log.Topics[0])
			header, err := m.Conn.Client().EthLatestHeaderByNumber(m.Cfg.Endpoint, latestBlock)
			if err != nil {
				return 0, err
			}
			// when syncToMap we need to assemble a tx proof
			txsHash, err := mapprotocol.GetMapTransactionsHashByBlockNumber(m.Conn.Client(), latestBlock)
			if err != nil {
				return 0, fmt.Errorf("unable to get tx hashes Logs: %w", err)
			}
			receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
			if err != nil {
				return 0, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
			}
			payload, err := eth2.AssembleProof(*eth2.ConvertHeader(header), log, receipts, method, m.Cfg.Id, constant.ProofTypeOfOracle)
			if err != nil {
				return 0, fmt.Errorf("unable to Parse Log: %w", err)
			}

			msgPayload := []interface{}{payload, orderId, latestBlock.Uint64(), log.TxHash}
			message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
			message.Idx = idx

			err = m.Router.Send(message)
			if err != nil {
				m.Log.Error("Subscription error: failed to route message", "err", err)
			}
			count++
		}
	}

	return count, nil
}

'''
'''--- chains/ethereum/chain.go ---
package ethereum

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/mapo"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/pkg/errors"
	"math/big"
	"strconv"
	"strings"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error,
	role mapprotocol.Role) (core.Chain, error) {
	opts := make([]chain.SyncOpt, 0)

	opts = append(opts, chain.OptOfInitHeight(mapprotocol.HeaderOneCount))
	if strconv.FormatUint(uint64(chainCfg.Id), 10) == mapprotocol.MapId {
		opts = append(opts, chain.OptOfSync2Map(mapToOther))
		opts = append(opts, chain.OptOfInitHeight(mapprotocol.EpochOfMap))
	} else {
		opts = append(opts, chain.OptOfSync2Map(headerToMap))
	}
	opts = append(opts, chain.OptOfAssembleProof(assembleProof))
	opts = append(opts, chain.OptOfOracleHandler(chain.DefaultOracleHandler))
	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection, opts...)
}

func mapToOther(m *chain.Maintainer, latestBlock *big.Int) error {
	if latestBlock.Cmp(big.NewInt(0)) == 0 {
		return nil
	}
	remainder := big.NewInt(0).Mod(latestBlock, big.NewInt(mapprotocol.EpochOfMap))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}
	m.Log.Info("sync block ", "current", latestBlock)
	header, err := m.Conn.Client().MAPHeaderByNumber(context.Background(), latestBlock)
	if err != nil {
		return err
	}

	h := mapprotocol.ConvertHeader(header)
	aggPK, ist, aggPKBytes, err := mapprotocol.GetAggPK(m.Conn.Client(), new(big.Int).Sub(header.Number, big.NewInt(1)), header.Extra)
	if err != nil {
		return err
	}
	istanbulExtra := mapprotocol.ConvertIstanbulExtra(ist)
	input, err := mapprotocol.PackInput(mapprotocol.Map2Other, mapprotocol.MethodUpdateBlockHeader, h, istanbulExtra, aggPK)
	if err != nil {
		return err
	}
	m.Log.Debug("sync block ", "current", latestBlock, "data", common.Bytes2Hex(input))
	msgpayload := []interface{}{input}
	waitCount := len(m.Cfg.SyncChainIDList)
	for _, cid := range m.Cfg.SyncChainIDList {
		if v, ok := mapprotocol.SyncOtherMap[cid]; ok && latestBlock.Cmp(v) <= 0 {
			waitCount--
			m.Log.Info("map to other current less than synchronized headerHeight", "toChainId", cid, "synced height", v,
				"current height", latestBlock)
			continue
		}
		// Query the latest height for comparison
		if fn, ok := mapprotocol.Map2OtherHeight[cid]; ok {
			height, err := fn()
			if err != nil {
				return fmt.Errorf("get headerHeight failed, err is %v", err)
			}
			if latestBlock.Cmp(height) <= 0 {
				waitCount--
				m.Log.Info("currentBlock less than latest synchronized headerHeight", "toChainId", cid, "synced height", height,
					"current height", latestBlock)
				continue
			}
		}
		if name, ok := mapprotocol.OnlineChaId[cid]; ok && strings.ToLower(name) == "near" {
			param := map[string]interface{}{
				"header": mapprotocol.ConvertNearNeedHeader(header),
				"agg_pk": map[string]interface{}{
					"xr": "0x" + common.Bytes2Hex(aggPKBytes[32:64]),
					"xi": "0x" + common.Bytes2Hex(aggPKBytes[:32]),
					"yi": "0x" + common.Bytes2Hex(aggPKBytes[64:96]),
					"yr": "0x" + common.Bytes2Hex(aggPKBytes[96:128]),
				},
			}
			data, _ := json.Marshal(param)
			msgpayload = []interface{}{data}
		} else {
			msgpayload = []interface{}{input}
		}
		message := msg.NewSyncFromMap(m.Cfg.MapChainID, cid, msgpayload, m.MsgCh)
		err = m.Router.Send(message)
		if err != nil {
			m.Log.Error("subscription error: failed to route message", "err", err)
			return nil
		}
	}

	err = m.WaitUntilMsgHandled(waitCount)
	if err != nil {
		return err
	}
	return nil
}

func headerToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get synced Height failed", "err", err)
		return err
	}
	// If the current block is lower than the latest height, it will not be synchronized
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("currentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}
	m.Log.Info("Sync Header to Map Chain", "current", latestBlock)
	header, err := m.Conn.Client().HeaderByNumber(context.Background(), latestBlock)
	if err != nil {
		return err
	}
	enc, err := rlpEthereumHeaders(m.Cfg.Id, m.Cfg.MapChainID, []types.Header{*header})
	if err != nil {
		m.Log.Error("failed to rlp ethereum headers", "err", err)
		return err
	}
	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	data, err := mapprotocol.PackInput(mapprotocol.LightManger, mapprotocol.MethodUpdateBlockHeader, id, enc)
	if err != nil {
		m.Log.Error("block2Map Failed to pack abi data", "err", err)
		return err
	}
	msgpayload := []interface{}{id, data}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message   msg.Message
		orderId   = log.Data[:32]
		method    = m.GetMethod(log.Topics[0])
		bigNumber = big.NewInt(int64(log.BlockNumber))
	)
	if log.Topics[0].Hex() == constant.TopicsOfSwapInVerified {
		data, err := mapprotocol.Mcs.Events[mapprotocol.EventOfSwapInVerified].Inputs.UnpackValues(log.Data)
		if err != nil {
			return nil, errors.Wrap(err, "swapIn unpackData failed")
		}

		input, _ := mapprotocol.Mcs.Pack(mapprotocol.MethodOfSwapInVerified, data[0].([]byte))
		msgPayload := []interface{}{input, orderId, log.BlockNumber, log.TxHash, mapprotocol.MethodOfSwapInVerified}
		message = msg.NewSwapWithMerlin(m.Cfg.MapChainID, m.Cfg.Id, msgPayload, m.MsgCh)
		return &message, nil
	}
	if m.Cfg.Id == m.Cfg.MapChainID {
		header, err := m.Conn.Client().MAPHeaderByNumber(context.Background(), bigNumber)
		if err != nil {
			return nil, fmt.Errorf("unable to query header Logs: %w", err)
		}
		txsHash, err := tx.GetTxsHashByBlockNumber(m.Conn.Client(), bigNumber)
		if err != nil {
			return nil, fmt.Errorf("idSame unable to get tx hashes Logs: %w", err)
		}
		receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
		if err != nil {
			return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
		}
		remainder := big.NewInt(0).Mod(bigNumber, big.NewInt(mapprotocol.EpochOfMap))
		if remainder.Cmp(mapprotocol.Big0) == 0 {
			lr, err := mapprotocol.GetLastReceipt(m.Conn.Client(), bigNumber)
			if err != nil {
				return nil, fmt.Errorf("unable to get last receipts in epoch last %w", err)
			}
			receipts = append(receipts, lr)
		}

		if toChainID == constant.MerlinChainId {
			method = mapprotocol.MethodOfVerifyAndStore
		}
		_, payload, err := mapo.AssembleMapProof(m.Conn.Client(), log, receipts, header, m.Cfg.MapChainID, method, m.Cfg.ApiUrl, proofType)
		if err != nil {
			return nil, fmt.Errorf("unable to Parse Log: %w", err)
		}

		msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash, method}
		message = msg.NewSwapWithMapProof(m.Cfg.MapChainID, msg.ChainId(toChainID), msgPayload, m.MsgCh)
		if toChainID == constant.MerlinChainId {
			message = msg.NewSwapWithMerlin(m.Cfg.MapChainID, msg.ChainId(toChainID), msgPayload, m.MsgCh)
		}
	} else if m.Cfg.SyncToMap {
		txsHash, err := mapprotocol.GetMapTransactionsHashByBlockNumber(m.Conn.Client(), bigNumber)
		if err != nil {
			return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
		}
		receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
		if err != nil {
			return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
		}
		payload, err := mapo.AssembleEthProof(m.Conn.Client(), log, receipts, method, m.Cfg.Id, proofType)
		if err != nil {
			return nil, fmt.Errorf("unable to Parse Log: %w", err)
		}

		msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
		message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	}
	return &message, nil
}

func rlpEthereumHeaders(source, destination msg.ChainId, headers []types.Header) ([]byte, error) {
	h, err := rlp.EncodeToBytes(&headers)
	if err != nil {
		return nil, fmt.Errorf("rpl encode ethereum headers error: %v", err)
	}

	params := struct {
		From    *big.Int
		To      *big.Int
		Headers []byte
	}{
		From:    big.NewInt(int64(source)),
		To:      big.NewInt(int64(destination)),
		Headers: h,
	}

	enc, err := rlp.EncodeToBytes(params)
	if err != nil {
		return nil, fmt.Errorf("rpl encode params error: %v", err)
	}
	return enc, nil
}

'''
'''--- chains/interfaces.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package chains

import (
	"github.com/mapprotocol/compass/msg"
)

type Router interface {
	Send(message msg.Message) error
}

type Listener interface {
	Sync() error
	SetRouter(r Router)
}

const (
	Bsc      = "bsc"
	Matic    = "matic"
	Klaytn   = "klaytn"
	Eth2     = "eth2"
	Platon   = "platon"
	Near     = "near"
	Ethereum = "ethereum"
	Conflux  = "conflux"
	Bttc     = "bttc"
	Tron     = "tron"
)

'''
'''--- chains/klaytn/chain.go ---
package klaytn

import (
	"context"
	"fmt"
	"github.com/ethereum/go-ethereum/core/types"
	"math/big"
	"strings"
	"time"

	"github.com/mapprotocol/compass/internal/tx"

	"github.com/ethereum/go-ethereum/rlp"

	"github.com/klaytn/klaytn/common"

	"github.com/ChainSafe/log15"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/klaytn"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

var (
	kClient = &klaytn.Client{}
)

func connectKClient(endpoint string) error {
	kc, err := klaytn.DialHttp(endpoint, true)
	if err != nil {
		return err
	}
	kClient = kc
	return nil
}

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	err := connectKClient(chainCfg.Endpoint)
	if err != nil {
		return nil, err
	}

	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection,
		chain.OptOfSync2Map(syncHeaderToMap),
		chain.OptOfAssembleProof(assembleProof),
		chain.OptOfOracleHandler(chain.DefaultOracleHandler))
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	if err := syncValidatorHeader(m, latestBlock); err != nil {
		return err
	}

	if err := syncHeader(m, latestBlock); err != nil {
		return err
	}

	return nil
}

func syncValidatorHeader(m *chain.Maintainer, latestBlock *big.Int) error {
	kHeader, err := kClient.BlockByNumber(context.Background(), latestBlock)
	if err != nil {
		return err
	}

	if kHeader.VoteData == "0x" {
		return nil
	}
	m.Log.Info("Get voteData", "blockHeight", latestBlock, "voteData", kHeader.VoteData)
	data := common.Hex2Bytes(strings.TrimPrefix(kHeader.VoteData, klaytn.PrefixOfHex))
	gVote := new(klaytn.GovernanceVote)
	err = rlp.DecodeBytes(data, gVote)
	if err != nil {
		m.Log.Error("Failed to decode a vote", "number", kHeader.Number, "key", gVote.Key, "value", gVote.Value, "validator", gVote.Validator)
		return err
	}

	if gVote.Key != "governance.addvalidator" && gVote.Key != "governance.removevalidator" {
		return nil
	}

	time.Sleep(time.Second)
	m.Log.Info("Send Validator Header", "blockHeight", latestBlock)
	return sendSyncHeader(m, latestBlock, 2)
}

func syncHeader(m *chain.Maintainer, latestBlock *big.Int) error {
	remainder := big.NewInt(0).Mod(latestBlock, big.NewInt(mapprotocol.EpochOfKlaytn))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}

	m.Log.Info("Find sync block", "current height", latestBlock)
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get current synced Height failed", "err", err)
		return err
	}
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("CurrentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}

	return sendSyncHeader(m, latestBlock, mapprotocol.HeaderOneCount)
}

func sendSyncHeader(m *chain.Maintainer, latestBlock *big.Int, count int) error {
	headers, err := assembleHeader(m.Conn.Client(), latestBlock, count)
	if err != nil {
		return err
	}

	input, err := mapprotocol.Klaytn.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(headers)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func assembleHeader(client *ethclient.Client, latestBlock *big.Int, count int) ([]klaytn.Header, error) {
	headers := make([]klaytn.Header, count)
	for i := 0; i < count; i++ {
		headerHeight := new(big.Int).Add(latestBlock, new(big.Int).SetInt64(int64(i)))
		header, err := client.HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return nil, err
		}
		hKheader, err := kClient.BlockByNumber(context.Background(), headerHeight)
		if err != nil {
			return nil, err
		}

		headers[count-count+i] = klaytn.ConvertContractHeader(header, hKheader)
	}

	return headers, nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message   msg.Message
		orderId   = log.Data[:32]
		method    = m.GetMethod(log.Topics[0])
		bigNumber = big.NewInt(int64(log.BlockNumber))
	)

	txsHash, err := klaytn.GetTxsHashByBlockNumber(kClient, bigNumber)
	if err != nil {
		return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
	if err != nil {
		return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
	}
	// get block
	header, err := m.Conn.Client().HeaderByNumber(context.Background(), bigNumber)
	if err != nil {
		return nil, err
	}
	kHeader, err := kClient.BlockByNumber(context.Background(), bigNumber)
	if err != nil {
		return nil, err
	}

	payload, err := klaytn.AssembleProof(kClient, klaytn.ConvertContractHeader(header, kHeader), log, m.Cfg.Id, receipts, method, proofType)
	if err != nil {
		return nil, fmt.Errorf("unable to Parse Log: %w", err)
	}

	msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
	message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	return &message, nil
}

'''
'''--- chains/matic/chain.go ---
package matic

import (
	"context"
	"fmt"
	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/core/types"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/matic"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"math/big"
	"strconv"
)

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	return chain.New(chainCfg, logger, sysErr, role, connection.NewConnection,
		chain.OptOfSync2Map(syncHeaderToMap),
		chain.OptOfInitHeight(12),
		chain.OptOfOracleHandler(chain.DefaultOracleHandler),
		chain.OptOfAssembleProof(assembleProof),
	)
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	remainder := big.NewInt(0).Mod(new(big.Int).Sub(latestBlock, mapprotocol.ConfirmsOfMatic), big.NewInt(mapprotocol.HeaderCountOfMatic))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get current synced Height failed", "err", err)
		return err
	}
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("CurrentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}

	m.Log.Info("Find sync block", "current height", latestBlock)
	startBlock := new(big.Int).Sub(latestBlock, new(big.Int).SetInt64(mapprotocol.ConfirmsOfMatic.Int64()+1))
	headers := make([]*types.Header, mapprotocol.ConfirmsOfMatic.Int64())
	for i := 0; i < int(mapprotocol.ConfirmsOfMatic.Int64()); i++ {
		headerHeight := new(big.Int).Add(startBlock, new(big.Int).SetInt64(int64(i)))
		header, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return err
		}
		headers[i] = header
	}

	mHeaders := make([]matic.BlockHeader, 0, len(headers))
	for _, h := range headers {
		mHeaders = append(mHeaders, matic.ConvertHeader(h))
	}

	input, err := mapprotocol.Matic.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(mHeaders)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message   msg.Message
		orderId   = log.Data[:32]
		method    = m.GetMethod(log.Topics[0])
		bigNumber = big.NewInt(int64(log.BlockNumber))
	)
	txsHash, err := tx.GetTxsHashByBlockNumber(m.Conn.Client(), bigNumber)
	if err != nil {
		return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	var receipts []*types.Receipt
	key := strconv.FormatUint(uint64(m.Cfg.Id), 10) + "_" + bigNumber.String()
	if v, ok := proof.CacheReceipt[key]; ok {
		receipts = v
		m.Log.Info("use cache receipt", "bigNumber ", bigNumber, "txHash", log.TxHash)
	} else {
		tmp, err := tx.GetMaticReceiptsByTxsHash(m.Conn.Client(), txsHash)
		if err != nil {
			return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
		}
		for _, t := range tmp {
			if t == nil {
				continue
			}
			receipts = append(receipts, t)
		}
		proof.CacheReceipt[key] = receipts
	}

	headers := make([]*types.Header, mapprotocol.ConfirmsOfMatic.Int64())
	for i := 0; i < int(mapprotocol.ConfirmsOfMatic.Int64()); i++ {
		headerHeight := new(big.Int).Add(bigNumber, new(big.Int).SetInt64(int64(i)))
		tmp, err := m.Conn.Client().HeaderByNumber(context.Background(), headerHeight)
		if err != nil {
			return nil, fmt.Errorf("getHeader failed, err is %v", err)
		}
		headers[i] = tmp
	}

	mHeaders := make([]matic.BlockHeader, 0, len(headers))
	for _, h := range headers {
		mHeaders = append(mHeaders, matic.ConvertHeader(h))
	}

	payload, err := matic.AssembleProof(mHeaders, log, m.Cfg.Id, receipts, method, proofType)
	if err != nil {
		return nil, fmt.Errorf("unable to Parse Log: %w", err)
	}

	msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
	message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	return &message, nil
}

'''
'''--- chains/near/chain.go ---
package near

import (
	"github.com/mapprotocol/compass/pkg/redis"
	"math/big"

	"github.com/pkg/errors"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/atlas/accounts/abi/bind"
	"github.com/mapprotocol/compass/chains"
	connection "github.com/mapprotocol/compass/connections/near"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/keystore"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/blockstore"
	nearclient "github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/types/key"
)

type Connection interface {
	Connect() error
	Keypair() *key.KeyPair
	Opts() *bind.TransactOpts
	CallOpts() *bind.CallOpts
	LockAndUpdateOpts(bool) error
	UnlockOpts()
	Client() *nearclient.Client
	EnsureHasBytecode(address string) error
	LatestBlock() (*big.Int, error)
	WaitForBlock(block *big.Int, delay *big.Int) error
	Close()
}

type Chain struct {
	cfg    *core.ChainConfig // The config of the chain
	conn   Connection        // The chains connection
	writer *writer           // The writer of the chain
	stop   chan<- int
	listen chains.Listener // The listener of this chain
}

func setupBlockstore(cfg *Config, kp *key.KeyPair, role mapprotocol.Role) (*blockstore.Blockstore, error) {
	bs, err := blockstore.NewBlockstore(cfg.BlockstorePath, cfg.Id, kp.PublicKey.ToPublicKey().Hash(), role)
	if err != nil {
		return nil, err
	}

	if !cfg.FreshStart {
		latestBlock, err := bs.TryLoadLatestBlock()
		if err != nil {
			return nil, err
		}

		if latestBlock.Cmp(cfg.StartBlock) == 1 {
			cfg.StartBlock = latestBlock
		}
	}

	return bs, nil
}

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error,
	role mapprotocol.Role) (*Chain, error) {
	cfg, err := parseChainConfig(chainCfg)
	if err != nil {
		return nil, err
	}

	kp, err := keystore.NearKeyPairFrom(chainCfg.Network, cfg.KeystorePath, cfg.From)
	if err != nil {
		return nil, err
	}

	bs, err := setupBlockstore(cfg, &kp, role)
	if err != nil {
		return nil, err
	}

	stop := make(chan int)
	conn := connection.NewConnection(cfg.Endpoint, cfg.Http, &kp, logger, cfg.GasLimit, cfg.MaxGasPrice, big.NewFloat(cfg.GasMultiplier))
	err = conn.Connect()
	if err != nil {
		return nil, err
	}

	if chainCfg.LatestBlock {
		curr, err := conn.LatestBlock()
		if err != nil {
			return nil, err
		}
		cfg.StartBlock = curr
	}

	// simplified a little bit
	var listen chains.Listener
	cs := NewCommonListen(conn, cfg, logger, stop, sysErr, bs)
	if role == mapprotocol.RoleOfMessenger {
		redis.Init(cfg.redisUrl)
		listen = NewMessenger(cs)
	} else if role == mapprotocol.RoleOfMaintainer {
		fn := mapprotocol.Map2NearHeight(cfg.lightNode, conn.Client())
		height, err := fn()
		if err != nil {
			return nil, errors.Wrap(err, "near get init headerHeight failed")
		}
		logger.Info("Map2Near Current situation", "height", height, "lightNode", cfg.lightNode)
		mapprotocol.SyncOtherMap[cfg.Id] = height
		mapprotocol.Map2OtherHeight[cfg.Id] = fn
		listen = NewMaintainer(cs)
	}
	writer := NewWriter(conn, cfg, logger, stop, sysErr)

	return &Chain{
		cfg:    chainCfg,
		conn:   conn,
		writer: writer,
		stop:   stop,
		listen: listen,
	}, nil
}

func (c *Chain) SetRouter(r *core.Router) {
	r.Listen(c.cfg.Id, c.writer)
	c.listen.SetRouter(r)
}

func (c *Chain) Start() error {
	err := c.listen.Sync()
	if err != nil {
		return err
	}

	err = c.writer.start()
	if err != nil {
		return err
	}

	c.writer.log.Debug("Successfully started chain")
	return nil
}

func (c *Chain) Id() msg.ChainId {
	return c.cfg.Id
}

func (c *Chain) Name() string {
	return c.cfg.Name
}

// Stop signals to any running routines to exit
func (c *Chain) Stop() {
	close(c.stop)
	if c.conn != nil {
		c.conn.Close()
	}
}

// EthClient return EthClient for global map connection
func (c *Chain) EthClient() *nearclient.Client {
	return c.conn.Client()
}

// Conn return Connection interface for relayer register
func (c *Chain) Conn() core.Connection {
	return nil
}

'''
'''--- chains/near/common_listen.go ---
package near

import (
	"math/big"
	"time"

	metrics "github.com/ChainSafe/chainbridge-utils/metrics/types"
	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/pkg/blockstore"
)

var (
	RetryInterval = time.Second * 5
	RetryLimit    = 5
)

type CommonListen struct {
	cfg                Config
	conn               Connection
	log                log15.Logger
	router             chains.Router
	stop               <-chan int
	msgCh              chan struct{}
	sysErr             chan<- error // Reports fatal error to core
	latestBlock        metrics.LatestBlock
	blockConfirmations *big.Int
	blockStore         blockstore.Blockstorer
}

// NewCommonListen creates and returns a listener
func NewCommonListen(conn Connection, cfg *Config, log log15.Logger, stop <-chan int, sysErr chan<- error,
	bs blockstore.Blockstorer) *CommonListen {
	return &CommonListen{
		cfg:                *cfg,
		conn:               conn,
		log:                log,
		stop:               stop,
		sysErr:             sysErr,
		latestBlock:        metrics.LatestBlock{LastUpdated: time.Now()},
		blockConfirmations: cfg.BlockConfirmations,
		msgCh:              make(chan struct{}),
		blockStore:         bs,
	}
}

func (c *CommonListen) SetRouter(r chains.Router) {
	c.router = r
}

func (c *CommonListen) GetLatestBlock() metrics.LatestBlock {
	return c.latestBlock
}

// waitUntilMsgHandled this function will block untill message is handled
func (c *CommonListen) waitUntilMsgHandled(counter int) error {
	c.log.Debug("waitUntilMsgHandled", "counter", counter)
	for counter > 0 {
		<-c.msgCh
		counter -= 1
	}
	return nil
}

'''
'''--- chains/near/config.go ---
package near

import (
	"fmt"
	"strings"

	"github.com/mapprotocol/compass/internal/chain"

	"github.com/mapprotocol/compass/core"
)

type Config struct {
	chain.Config
	lightNode, redisUrl string
	events, mcsContract []string
}

// parseChainConfig uses a core.ChainConfig to construct a corresponding Config
func parseChainConfig(chainCfg *core.ChainConfig) (*Config, error) {
	cfg, err := chain.ParseConfig(chainCfg)
	if err != nil {
		return nil, err
	}
	ret := Config{
		Config:      *cfg,
		lightNode:   "",
		mcsContract: nil,
	}

	if v, ok := chainCfg.Opts[chain.Event]; ok && v != "" {
		vs := strings.Split(v, "|")
		for _, s := range vs {
			ret.events = append(ret.events, s)
		}
	}

	if contract, ok := chainCfg.Opts[chain.McsOpt]; ok && contract != "" {
		for _, addr := range strings.Split(contract, ",") {
			ret.mcsContract = append(ret.mcsContract, addr)
		}
	} else {
		return nil, fmt.Errorf("must provide opts.mcs field for ethereum config")
	}

	if v, ok := chainCfg.Opts[chain.RedisOpt]; ok && v != "" {
		ret.redisUrl = v
		delete(chainCfg.Opts, chain.RedisOpt)
	}

	if v, ok := chainCfg.Opts[chain.LightNode]; ok && v != "" {
		ret.lightNode = v
		delete(chainCfg.Opts, chain.LightNode)
	}

	return &ret, nil
}

'''
'''--- chains/near/maintainer.go ---
package near

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"time"

	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/internal/near"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/near-api-go/pkg/client/block"
)

var NearEpochSize = big.NewInt(43200)

type Maintainer struct {
	*CommonListen
	syncedHeight *big.Int
}

func NewMaintainer(cs *CommonListen) *Maintainer {
	return &Maintainer{
		CommonListen: cs,
	}
}

func (m *Maintainer) Sync() error {
	m.log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Maintainer will poll for the latest block and proceed to parse the associated events as it sees new blocks.
// Polling begins at the block defined in `m.cfg.startBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to RetryLimit times before continuing to the next block.
func (m Maintainer) sync() error {
	for {
		select {
		case <-m.stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.conn.LatestBlock()
			if err != nil {
				m.log.Error("Unable to get latest block", "block", latestBlock, "err", err)
				time.Sleep(RetryInterval)
				continue
			}

			if m.cfg.SyncToMap {
				// listen when catchup
				m.log.Info("Sync Header to Map Chain", "target", latestBlock)
				err = m.toMapChain(latestBlock)
				if err != nil {
					m.log.Error("Failed to listen header for block", "block", latestBlock, "err", err)
					time.Sleep(constant.QueryRetryInterval)
					util.Alarm(context.Background(), fmt.Sprintf("near sync header failed, err is %s", err.Error()))
					continue
				}
			}

			m.latestBlock.Height = big.NewInt(0).Set(latestBlock)
			m.latestBlock.LastUpdated = time.Now()
		}
	}
}

// toMapChain listen header from current chain to Map chain
func (m *Maintainer) toMapChain(latestBlock *big.Int) error {
	height, err := mapprotocol.Get2MapHeight(m.cfg.Id)
	if err != nil {
		return err
	}
	if latestBlock.Cmp(height) == -1 {
		return nil
	}

	blocks := new(big.Int).Sub(latestBlock, height)
	gap := new(big.Int).Sub(NearEpochSize, blocks).Int64()
	if gap > 0 {
		m.log.Info("wait for the next light client block to be generated", "target", new(big.Int).Add(height, NearEpochSize).Uint64())
		time.Sleep(time.Duration(gap/10) * time.Second)
		return nil
	}

	count := new(big.Int).Div(blocks, NearEpochSize).Uint64()
	number := height.Uint64()
	id := big.NewInt(0).SetUint64(uint64(m.cfg.Id))
	for i := uint64(0); i < count; i++ {
		blockDetails, err := m.conn.Client().BlockDetails(context.Background(), block.BlockID(number))
		if err != nil {
			m.log.Error("failed to get block", "err", err, "number", number)
			return err
		}
		m.log.Info("get block complete", "number", number, "hash", blockDetails.Header.Hash)

		lightBlock, err := m.conn.Client().NextLightClientBlock(context.Background(), blockDetails.Header.Hash)
		if err != nil {
			m.log.Error("failed to get next light client block", "err", err, "number", lightBlock.InnerLite.Height, "hash", lightBlock.NextBlockInnerHash)
			return err
		}
		m.log.Info("get next light client block complete", "number", lightBlock.InnerLite.Height, "hash", lightBlock.NextBlockInnerHash)

		number = lightBlock.InnerLite.Height

		message := msg.NewSyncToMap(m.cfg.Id, m.cfg.MapChainID, []interface{}{id, near.Borshify(lightBlock)}, m.msgCh)
		err = m.router.Send(message)
		if err != nil {
			m.log.Error("subscription error: failed to route message", "err", err)
			return nil
		}
		err = m.waitUntilMsgHandled(1)
		if err != nil {
			return err
		}
	}
	return nil
}

'''
'''--- chains/near/messenger.go ---
package near

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/util"

	rds "github.com/go-redis/redis/v8"
	"github.com/mapprotocol/compass/internal/near"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/redis"
	"github.com/mapprotocol/near-api-go/pkg/client"
	nearclient "github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/client/block"
	"github.com/pkg/errors"
)

type Messenger struct {
	*CommonListen
}

func NewMessenger(cs *CommonListen) *Messenger {
	return &Messenger{
		CommonListen: cs,
	}
}

func (m *Messenger) Sync() error {
	m.log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Messenger will poll for the latest block and listen the log information of transactions in the block
// Polling begins at the block defined in `m.cfg.startBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to RetryLimit times before continuing to the next block.
// However，an error in synchronizing the log will cause the entire program to block
func (m *Messenger) sync() error {
	var currentBlock = m.cfg.StartBlock

	for {
		select {
		case <-m.stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.conn.LatestBlock()
			if err != nil {
				m.log.Error("Unable to get latest block", "err", err)
				time.Sleep(constant.RetryLongInterval)
				continue
			}

			// Sleep if the difference is less than BlockDelay; (latest - current) < BlockDelay
			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.blockConfirmations) == -1 {
				m.log.Debug("Block not ready, will retry", "target", currentBlock, "latest", latestBlock)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			count, err := m.getEventsForBlock(currentBlock)
			if err != nil {
				m.log.Error("Failed to get events for block", "block", currentBlock, "err", err)
				time.Sleep(RetryInterval)
				util.Alarm(context.Background(), fmt.Sprintf("near mos failed, err is %s", err.Error()))
				continue
			}

			// hold until all messages are handled
			_ = m.waitUntilMsgHandled(count)

			// Write to block store. Not a critical operation, no need to retry
			err = m.blockStore.StoreBlock(currentBlock)
			if err != nil {
				m.log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}
			m.latestBlock.LastUpdated = time.Now()

			currentBlock.Add(currentBlock, big.NewInt(1))
		}
	}
}

// getEventsForBlock looks for the deposit event in the latest block
func (m *Messenger) getEventsForBlock(latestBlock *big.Int) (int, error) {
	if !m.cfg.SyncToMap {
		return 0, nil
	}
	// querying for logs
	ctx := context.Background()
	cmd := redis.GetClient().RPop(ctx, redis.ListKey)
	result, err := cmd.Result()
	if err != nil && !errors.Is(err, rds.Nil) {
		return 0, errors.Wrap(err, "rPop failed")
	}

	if err != nil && errors.Is(err, rds.Nil) {
		return 0, nil
	}

	data := mapprotocol.StreamerMessage{}
	err = json.Unmarshal([]byte(result), &data)
	if err != nil {
		return 0, errors.Wrap(err, "json marshal failed")
	}
	target := make([]mapprotocol.IndexerExecutionOutcomeWithReceipt, 0)
	for _, shard := range data.Shards {
		for _, outcome := range shard.ReceiptExecutionOutcomes {
			if m.Idx(outcome.ExecutionOutcome.Outcome.ExecutorID) == -1 {
				continue
			}
			if len(outcome.ExecutionOutcome.Outcome.Logs) == 0 {
				continue
			}
			match := false
			for _, ls := range outcome.ExecutionOutcome.Outcome.Logs {
				if !match {
					match = m.match(ls)
				}
			}
			if match {
				m.log.Info("Event found", "log", outcome.ExecutionOutcome.Outcome.Logs, "contract", outcome.ExecutionOutcome.Outcome.ExecutorID)
				target = append(target, outcome)
			} else {
				m.log.Info("Event Not Match", "log", outcome.ExecutionOutcome.Outcome.Logs)
			}
		}
	}

	if len(target) == 0 {
		return 0, nil
	}

	ret, err := m.makeMessage(target)
	if err != nil {
		m.log.Error("make message failed", "err", err)
		cmd := redis.GetClient().RPush(context.Background(), redis.ListKey, result)
		_, err = cmd.Result()
		if err != nil {
			m.log.Error("make message failed, retry insert failed", "err", err)
		}
		time.Sleep(constant.TxRetryInterval)
	}

	return ret, nil
}

func (m *Messenger) match(log string) bool {
	for _, e := range m.cfg.events {
		if strings.HasPrefix(log, e) {
			return true
		}
	}

	return false
}

func (m *Messenger) Idx(contract string) int {
	ret := -1
	for idx, addr := range m.cfg.mcsContract {
		if addr == contract {
			ret = idx
			break
		}
	}

	return ret
}

func (m *Messenger) makeMessage(target []mapprotocol.IndexerExecutionOutcomeWithReceipt) (int, error) {
	ret := 0
	for _, tg := range target {
		m.log.Debug("makeMessage receive one message", "tg", tg)
		time.Sleep(time.Second * 3)
		var (
			err        error
			retryCount = 0
			blk        client.LightClientBlockView
			proof      client.RpcLightClientExecutionProofResponse
		)
		for {
			retryCount++
			if retryCount == RetryLimit {
				return 0, errors.New("make message, retries exceeded")
			}
			blk, err = m.conn.Client().NextLightClientBlock(context.Background(), tg.ExecutionOutcome.BlockHash)
			if err != nil {
				m.log.Warn("get nextLightClientBlock failed, will retry", "err", err)
				time.Sleep(RetryInterval)
				continue
			}

			clientHead, err := m.conn.Client().BlockDetails(context.Background(), block.BlockID(blk.InnerLite.Height))
			if err != nil {
				m.log.Warn("get blockDetails failed, will retry", "err", err)
				time.Sleep(RetryInterval)
				continue
			}

			proof, err = m.conn.Client().LightClientProof(context.Background(), nearclient.Receipt{
				ReceiptID:       tg.ExecutionOutcome.ID,
				ReceiverID:      tg.Receipt.ReceiverID,
				LightClientHead: clientHead.Header.Hash,
			})
			if err != nil {
				m.log.Warn("get lightClientProof failed, will retry", "err", err)
				time.Sleep(RetryInterval)
				continue
			}
			if len(proof.BlockProof) <= 0 {
				time.Sleep(RetryInterval)
				continue
			}
			break
		}

		blkBytes := near.Borshify(blk)
		proofBytes, err := near.BorshifyOutcomeProof(proof)
		if err != nil {
			return 0, errors.Wrap(err, "borshifyOutcomeProof failed")
		}

		all, err := mapprotocol.Near.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(blkBytes, proofBytes)
		if err != nil {
			return 0, errors.Wrap(err, "getBytes pack failed")
		}

		// get fromChainId and toChainId
		logs := strings.SplitN(tg.ExecutionOutcome.Outcome.Logs[0], ":", 2)
		out := near.TransferOut{}
		err = json.Unmarshal([]byte(logs[1]), &out)
		if err != nil {
			return 0, errors.Wrap(err, "logs format failed")
		}

		method := mapprotocol.MethodOfTransferIn
		if strings.HasPrefix(tg.ExecutionOutcome.Outcome.Logs[1], mapprotocol.NearOfDepositIn) {
			method = mapprotocol.MethodOfDepositIn
		} else if strings.HasPrefix(tg.ExecutionOutcome.Outcome.Logs[1], mapprotocol.NearOfSwapIn) {
			method = mapprotocol.MethodOfSwapIn
		}
		input, err := mapprotocol.Mcs.Pack(method, new(big.Int).SetUint64(uint64(m.cfg.Id)), all)
		if err != nil {
			return 0, errors.Wrap(err, "transferIn pack failed")
		}

		ids := common.HexToHash(out.OrderId)
		orderId := make([]byte, 0, len(ids))
		for _, id := range ids {
			orderId = append(orderId, id)
		}
		msgPayload := []interface{}{input, orderId, 0, tg.ExecutionOutcome.Outcome.ReceiptIDs}
		message := msg.NewSwapWithProof(m.cfg.Id, m.cfg.MapChainID, msgPayload, m.msgCh)
		message.Idx = m.Idx(tg.ExecutionOutcome.Outcome.ExecutorID)
		err = m.router.Send(message)
		ret++
	}
	return ret, nil
}

'''
'''--- chains/near/write.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package near

import (
	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/msg"
)

var _ core.Writer = &writer{}

type writer struct {
	cfg    Config
	conn   Connection
	log    log15.Logger
	stop   <-chan int
	sysErr chan<- error // Reports fatal error to core
}

// NewWriter creates and returns writer
func NewWriter(conn Connection, cfg *Config, log log15.Logger, stop <-chan int, sysErr chan<- error) *writer {
	return &writer{
		cfg:    *cfg,
		conn:   conn,
		log:    log,
		stop:   stop,
		sysErr: sysErr,
	}
}

func (w *writer) start() error {
	w.log.Debug("Starting ethereum writer...")
	return nil
}

// ResolveMessage handles any given message based on type
// A bool is returned to indicate failure/success, this should be ignored except for within tests.
func (w *writer) ResolveMessage(m msg.Message) bool {
	w.log.Info("Near Attempting to resolve message", "type", m.Type, "src", m.Source, "dst", m.Destination)

	switch m.Type {
	case msg.SyncFromMap:
		return w.exeSyncMapMsg(m)
	case msg.SwapWithMapProof:
		return w.exeSwapMsg(m)
	default:
		w.log.Error("Unknown message type received", "type", m.Type)
		return false
	}
}

'''
'''--- chains/near/write_method.go ---
package near

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/mapprotocol/compass/pkg/util"

	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/near-api-go/pkg/client/block"

	"github.com/mapprotocol/compass/internal/near"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/types"
	"github.com/mapprotocol/near-api-go/pkg/types/action"
	"github.com/mapprotocol/near-api-go/pkg/types/hash"
)

const (
	MethodOfUpdateBlockHeader  = "update_block_header"
	MethodOfTransferIn         = "transfer_in"
	MethodOfSwapIn             = "swap_in"
	MethodOfVerifyReceiptProof = "verify_receipt_proof"
)

var (
	OrderIdIsUsed         = "the event with order id"
	OrderIdIsUsedFlag2    = "is used"
	VerifyRangeMatch      = "cannot get epoch record for block"
	VerifyRangeMatchFlag2 = "expected range"
)

var ignoreError = map[string]struct{}{
	"invalid to address":                                        {},
	"invalid to chain token address":                            {},
	"transfer in token failed, maybe TO account does not exist": {},
	"amount should be greater than 0":                           {},
	"near is not mcs token or fungible token or native token":   {},
	"index exceeds event size":                                  {},
	"not map swap out event":                                    {},
	"unexpected map mcs address":                                {},
	"unexpected to chain":                                       {},
	"invalid target token address:":                             {},
	"amount in should be == 0":                                  {},
	"min amount out should be greater than 0":                   {},
	"invalid swap param path":                                   {},
	"invalid path format:":                                      {},
	"invalid account id in path:":                               {},
	"bridge in token should be equal to the first token in":     {},
	"last token out should be equal to wrapped token if target token is zero address":  {},
	"target token should be equal to the last token out":                               {},
	"bridge in token should be equal to wrapped token if target token is zero address": {},
	"bridge in token should be equal to target token":                                  {},
	"is not bridgeable token":                                                            {},
	"the transfer in event is already processed":                                         {},
	"is not mcs token or fungible token or native token":                                 {},
	"the swap in event is already processe":                                              {},
	"promise has too many results":                                                       {},
	"used amount != amount in && used amount != 0, please check core state!":             {},
	"[SWAP FAILURE] call core to do swap in failed, maybe mos doesn't have enough token": {},
	"[FAILURE] mint or transfer token to core failed":                                    {},
}

// exeSyncMapMsg executes sync msg, and send tx to the destination blockchain
func (w *writer) exeSyncMapMsg(m msg.Message) bool {
	var errorCount int64
	for {
		select {
		case <-w.stop:
			return false
		default:
			err := w.conn.LockAndUpdateOpts(false)
			if err != nil {
				w.log.Error("Failed to update nonce", "err", err)
				return false
			}

			txHash, err := w.sendTx(w.cfg.lightNode, MethodOfUpdateBlockHeader, m.Payload[0].([]byte))
			w.conn.UnlockOpts()
			if err == nil {
				// message successfully handled
				w.log.Info("Sync MapHeader to Near tx execution", "tx", txHash.String(), "src", m.Source, "dst", m.Destination)
				m.DoneCh <- struct{}{}
				return true
			} else if strings.Index(err.Error(), "block header height is incorrect") != -1 {
				w.log.Error("The header may have been synchronized，Continue to execute the next header")
				m.DoneCh <- struct{}{}
				return true
			} else {
				w.log.Warn("Execution failed will retry", "err", err)
			}
			errorCount++
			if errorCount >= 10 {
				util.Alarm(context.Background(), fmt.Sprintf("map2Near updateHeader failed, err is %s", err.Error()))
				errorCount = 0
			}
			time.Sleep(constant.TxRetryInterval)
		}
	}
}

// exeSwapMsg executes swap msg, and send tx to the destination blockchain
func (w *writer) exeSwapMsg(m msg.Message) bool {
	var errorCount int64
	var inputHash interface{}
	if len(m.Payload) > 3 {
		inputHash = m.Payload[3]
	}
	data := m.Payload[0].([]byte)
	addr := w.cfg.mcsContract[m.Idx]

	for {
		// First request whether the orderId already exists
		orderId := m.Payload[1].([]byte)
		exits, err := w.checkOrderId(addr, orderId)
		if err != nil {
			w.log.Error("check orderId exist failed ", "err", err, "orderId", common.Bytes2Hex(orderId))
		}
		if exits {
			w.log.Info("Mcs orderId has been processed, Skip this request", "orderId", common.Bytes2Hex(orderId))
			m.DoneCh <- struct{}{}
			return true
		}

		md := make(map[string]interface{}, 0)
		_ = json.Unmarshal(data, &md)
		verify, err := json.Marshal(map[string]interface{}{
			"receipt_proof": md["receipt_proof"],
		})
		if err != nil {
			w.log.Error("Verify Execution failed, Will retry", "srcHash", inputHash, "err", err)
			return false
		}
		txHash, err := w.sendTx(addr, MethodOfVerifyReceiptProof, verify)
		if err == nil {
			w.log.Info("Verify Success", "mcsTx", txHash.String(), "srcHash", inputHash, "addr", addr)
			time.Sleep(time.Second)
			break
		} else {
			for e := range ignoreError {
				if strings.Index(err.Error(), e) != -1 {
					w.log.Info("Ignore This Error, Continue to the next", "method", MethodOfVerifyReceiptProof, "srcHash", inputHash, "err", err)
					m.DoneCh <- struct{}{}
					return true
				}
			}
			w.log.Warn("Verify Execution failed, Will retry", "srcHash", inputHash, "err", err)
			errorCount++
			if errorCount >= 3 {
				if strings.Index(err.Error(), "unexpected end of JSON input") == -1 {
					util.Alarm(context.Background(), fmt.Sprintf("map2Near mos(verify_receipt_proof) failed, srcHash=%v err is %s", inputHash, err.Error()))
				}
				errorCount = 0
			}
			time.Sleep(constant.NearTxRetryInterval)
		}
	}

	errorCount = 0
	for {
		select {
		case <-w.stop:
			return false
		default:
			method := MethodOfTransferIn
			if m.Payload[4].(string) == mapprotocol.MethodOfSwapIn {
				method = MethodOfSwapIn
			}
			w.log.Info("Send transaction", "srcHash", inputHash, "method", method, "addr", addr)
			txHash, err := w.sendTx(addr, method, data)
			if err == nil {
				w.log.Info("Submitted cross tx execution", "mcsTx", txHash.String(), "srcHash", inputHash)
				m.DoneCh <- struct{}{}
				return true
			} else if strings.Index(err.Error(), OrderIdIsUsed) != -1 && strings.Index(err.Error(), OrderIdIsUsedFlag2) != -1 {
				w.log.Info("Order id is used, Continue to the next", "srcHash", inputHash, "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else if strings.Index(err.Error(), VerifyRangeMatch) != -1 && strings.Index(err.Error(), VerifyRangeMatchFlag2) != -1 {
				abandon := w.resolveVerifyRangeError(m.Payload[2].(uint64), err)
				w.log.Error("The block where the transaction is located is no longer verifiable", "srcHash", inputHash, "abandon", abandon, "err", err)
				if abandon {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "srcHash", inputHash, "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range ignoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "method", method, "srcHash", inputHash, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
				w.log.Warn("Execution failed, tx may already be complete", "srcHash", inputHash, "err", err)
				errorCount++
				if errorCount >= 3 {
					if strings.Index(err.Error(), "unexpected end of JSON input") == -1 {
						util.Alarm(context.Background(), fmt.Sprintf("map2Near mos(%s) failed, srcHash=%v err is %s", method, inputHash, err.Error()))
					}
					errorCount = 0
				}
			}
			time.Sleep(constant.NearTxRetryInterval)
		}
	}
}

// sendTx send tx to an address with value and input data
func (w *writer) sendTx(toAddress string, method string, input []byte) (hash.CryptoHash, error) {
	w.log.Info("sendTx", "toAddress", toAddress)
	ctx := client.ContextWithKeyPair(context.Background(), *w.conn.Keypair())
	b := types.Balance{}
	if method == MethodOfTransferIn || method == MethodOfSwapIn || method == MethodOfVerifyReceiptProof {
		b, _ = types.BalanceFromString(near.Deposit)
	}
	res, err := w.conn.Client().TransactionSendAwait(
		ctx,
		w.cfg.From,
		toAddress,
		[]action.Action{
			action.NewFunctionCall(method, input, near.NewFunctionCallGas, b),
		},
		client.WithLatestBlock(),
		client.WithKeyPair(*w.conn.Keypair()),
	)
	if err != nil {
		return hash.CryptoHash{}, fmt.Errorf("failed to do txn: %w", err)
	}
	w.log.Debug("sendTx success", "res", res)
	if len(res.Status.Failure) != 0 {
		return hash.CryptoHash{}, fmt.Errorf("%s", string(res.Status.Failure))
	}
	return res.Transaction.Hash, nil
}

func (w *writer) checkOrderId(toAddress string, input []byte) (bool, error) {
	var fixedOrderId [32]byte
	for idx, v := range input {
		fixedOrderId[idx] = v
	}
	m := map[string]interface{}{
		"order_id": fixedOrderId,
	}
	data, err := json.Marshal(m)
	if err != nil {
		return false, err
	}
	ctx := client.ContextWithKeyPair(context.Background(), *w.conn.Keypair())
	res, err := w.conn.Client().ContractViewCallFunction(ctx, toAddress, mapprotocol.MethodOfIsUsedEvent,
		base64.StdEncoding.EncodeToString(data), block.FinalityFinal())
	if err != nil {
		return false, fmt.Errorf("checkOrderId ContractViewCallFunction failed: %w", err)
	}
	var exist bool
	err = json.Unmarshal(res.Result, &exist)
	if err != nil {
		return false, err
	}
	return exist, nil
}

func (w *writer) resolveVerifyRangeError(currentHeight uint64, par error) (isAbandon bool) {
	var entityError Error
	err := json.Unmarshal([]byte(par.Error()), &entityError)
	if err != nil {
		w.log.Warn("near mcs back err is not appoint json format", "err", par)
		return
	}
	leftIdx := strings.Index(entityError.ActionError.Kind.FunctionCallError.ExecutionError, "[")
	rightIdx := strings.Index(entityError.ActionError.Kind.FunctionCallError.ExecutionError, "]")
	rangeStr := entityError.ActionError.Kind.FunctionCallError.ExecutionError[leftIdx:rightIdx]
	verifyRange := strings.Split(strings.TrimSpace(rangeStr), ",")
	if len(verifyRange) != 2 {
		w.log.Warn("near mcs back err is not appoint json format", "err", par)
		return
	}
	left, err := strconv.ParseInt(strings.TrimSpace(verifyRange[0]), 10, 64)
	if err != nil {
		w.log.Warn("left range resolve failed", "str", verifyRange[0], "err", par)
		return
	}
	right, err := strconv.ParseInt(strings.TrimSpace(verifyRange[1]), 10, 64)
	if err != nil {
		w.log.Warn("right range resolve failed", "str", verifyRange[1], "err", par)
		return
	}
	if currentHeight < uint64(left) {
		isAbandon = true
		return
	}
	if currentHeight > uint64(right) {
		time.Sleep(time.Minute * 2)
	}
	return
}

type Error struct {
	ActionError ActionError `json:"ActionError"`
}

type ActionError struct {
	Index int  `json:"index"`
	Kind  Kind `json:"kind"`
}

type Kind struct {
	FunctionCallError FunctionCallError `json:"FunctionCallError"`
}

type FunctionCallError struct {
	ExecutionError string `json:"ExecutionError"`
}

'''
'''--- chains/near/write_method_test.go ---
package near

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"testing"

	"github.com/mapprotocol/compass/mapprotocol"

	"github.com/mapprotocol/compass/keystore"
	"github.com/mapprotocol/near-api-go/pkg/client"
	nearclient "github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/client/block"
	"github.com/mapprotocol/near-api-go/pkg/types"
	"github.com/mapprotocol/near-api-go/pkg/types/action"
)

var (
	from     = "xm.test.near"
	to       = "atlas.test.near"
	endPoint = "http://127.0.0.1:3030"
)

func dailRpc() *nearclient.Client {
	client, err := nearclient.NewClient(endPoint)
	if err != nil {
		panic(err)
	}
	return &client
}

func Test_writer_sendTx(t *testing.T) {
	kp, err := keystore.NearKeyPairFrom("local", "/Users/xm", from)
	if err != nil {
		t.Fatalf("keypair err %v", err)
	}

	ctx := client.ContextWithKeyPair(context.Background(), kp)
	s := `{
		"agg_pk": {
            "xi": "0x08ccd7feb39031341784777bf41ddcbac670e60ee2b466e159e18af9d0b0f565",
            "xr": "0x1e703741166519a7e278c11a8dc96ef9535dec8f4b0ab2b503f2b4d507198afc",
            "yi": "0x0667f9dad6aafa5745043addf652ea155885c7b7e88dca296b6e2cc96c475098",
            "yr": "0x21a73b10c7523524cbc37d791c730ce12b5fe7c1031da4d899bffad808b7b305"
        },
        "header": {
            "baseFee": "0x174876e800",
            "bloom": "0x10040000000000000000000000000000000000000000000000000000081020010000000080800000000000000000000000000000000008800000000004000000100000200000000000000008000000000000000000800000000000000000000000008000020000000000000100000800000000000a00000000000010000008000000000000000000000000000000000000000000000000000000200000000000000000000000000080002000000080020000000000800000000000000000000000000002000002000000000100000000000080000000010000000000000020000400000000000000000000000000000000004000000000004000000000000000",
            "coinbase": "0x7A3a26123DBD9CFeFc1725fe7779580B987251Cb",
            "extra": "0xd7820304846765746888676f312e31352e36856c696e75780000000000000000f8d3c0c0c080b841ec94af426b69d37aa5b3da5015b6920b9dd21021c7d3867c3fe6df1dd07530b3239ac9ad4055971426ae6415bb9fd0b953dcb0e506e45856fcc0debc31c7336901f84407b8401e961ced90d2132b36e9dee49427eff38f46d359dba22c86da66caa064990ab62dc6c3dcaca9fd593f01deba3a81627ca0671c1694241ba35db1e69f894de97f80f8440fb84011a759c98d54d7ed6b3333839f7d88ab5690e2be79b1e06b292cae5baa2f3baf03007c6a2617efc13079d62a86582beb2fdb13069a4586b3ae22da8efe689f9080",
            "gasLimit": "0x7a1200",
            "gasUsed": "0x0",
            "minDigest": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "nonce": "0x0000000000000000",
            "number": "0x7d0",
            "parentHash": "0x9887e5ccdf1e53f2857ecc31426280a38182617c0e72c91853872dd12f71fc83",
            "receiptHash": "0x0c26c8fa37c6951b3f012347cfcc98f44068e027035a50571e0ae53ed2068b78",
            "root": "0xba396db6fffc6209c941330b925e3b8fa6a1a63c9dca393ac4ae1b2d5504480b",
            "time": "0x62a2f7e8",
            "txHash": "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"
        }
	}`

	res, err := dailRpc().TransactionSendAwait(
		ctx,
		from,
		endPoint,
		[]action.Action{
			action.NewFunctionCall(MethodOfUpdateBlockHeader, []byte(s), types.DefaultFunctionCallGas, types.Balance{}),
		},
		client.WithLatestBlock(),
		client.WithKeyPair(kp),
	)

	if err != nil {
		t.Errorf("failed to do txn: %s", err)
	}
	t.Logf("sendTx success %v", res)
}

func Test_new(t *testing.T) {
	kp, err := keystore.NearKeyPairFrom("local", "/Users/xm", from)
	if err != nil {
		t.Fatalf("keypair err %v", err)
	}

	ctx := client.ContextWithKeyPair(context.Background(), kp)
	s := `{
    "threshold": 3,
    "epoch": 1,
    "epoch_size": 1000,
    "validators": [
        {
            "address": "0xb4e1bc0856f70a55764fd6b3f8dd27f2162108e9",
            "weight": 1,
            "g1_pub_key": {
                "x": "0x13524ec450b9ac611fb332a25b6c2eb436d13ac8a540f69a50d6ff8d4fe9f249",
                "y": "0x2b7d0f6e80e80e9b5f9c7a9fa2d482c2e8ea6c1657057c5548b7e30412d48bc3"
            },
            "_BLSPublicKey": "0x1446c55bf2cd8f31d31eaa58b081b30cea50b4d8d9096682576688c2f9ae627d27f97e09b64c99b0e49e7c33c864c089ba5c03cf27e04af4ac457edb46d12ce92aa1ca438667203f7d1696549bd861bf6f11cd3cb7d67738222428137ecadac91b68426ad13c8af92a9b8dc62475fbb1617640c635b812733efc9b7d21c8ab49",
            "_BLSG1PublicKey": "0x13524ec450b9ac611fb332a25b6c2eb436d13ac8a540f69a50d6ff8d4fe9f2492b7d0f6e80e80e9b5f9c7a9fa2d482c2e8ea6c1657057c5548b7e30412d48bc3",
            "_UncompressedBLSPublicKey": "FEbFW/LNjzHTHqpYsIGzDOpQtNjZCWaCV2aIwvmuYn0n+X4JtkyZsOSefDPIZMCJulwDzyfgSvSsRX7bRtEs6SqhykOGZyA/fRaWVJvYYb9vEc08t9Z3OCIkKBN+ytrJG2hCatE8ivkqm43GJHX7sWF2QMY1uBJzPvybfSHIq0k="
        },
        {
            "address": "0x7a3a26123dbd9cfefc1725fe7779580b987251cb",
            "weight": 1,
            "g1_pub_key": {
                "x": "0x0e3450c5b583e57d8fe736d276e9e4bb2ce4b38a5e9ac77b1289ba14a5e9cf58",
                "y": "0x1ce786f52d5bd0e77c1eacfa3dd5df0e22464888fa4bfab6eff9f29e8f86084b"
            },
            "_BLSPublicKey": "0x25f8387695e95f4224919051cfebe64efa2efb4ca8b82bd04cada59edb9e54920a10ea0f9064067049aaf12299592b4746fe4085516fc3f00fbc7dbdd1c545fe126f7bd8d6b5eff857e6fa227c58eea0da0984b80922f5bb33dba1832cf8722f26dc97985df5bf1b4db96f102b905c6982192feecf860ffba2d5eb4db3a64bda",
            "_BLSG1PublicKey": "0x0e3450c5b583e57d8fe736d276e9e4bb2ce4b38a5e9ac77b1289ba14a5e9cf581ce786f52d5bd0e77c1eacfa3dd5df0e22464888fa4bfab6eff9f29e8f86084b",
            "_UncompressedBLSPublicKey": "Jfg4dpXpX0IkkZBRz+vmTvou+0youCvQTK2lntueVJIKEOoPkGQGcEmq8SKZWStHRv5AhVFvw/APvH290cVF/hJve9jWte/4V+b6InxY7qDaCYS4CSL1uzPboYMs+HIvJtyXmF31vxtNuW8QK5BcaYIZL+7Phg/7otXrTbOmS9o="
        },
        {
            "address": "0x7607c9cdd733d8cda0a644839ec2bac5fa180ed4",
            "weight": 1,
            "g1_pub_key": {
                "x": "0x2f6dd4eda4296d9cf85064adbe2507901fcd4ece425cc996827ba4a2c111c812",
                "y": "0x1e6fe59e1d18c107d480077debf3ea265a52325725a853a710f7ec3af5e32869"
            },
            "_BLSPublicKey": "0x2c87c9887cd5af4e33cf09b0a7c4840f87b53bfe5a21d9e18051228577fb191615bb9e374b2625f11e47737292a8688c9ce1c8533ab8000f495a4cc2e55f5531303a6a1542be1e2b6a0e6f37fe2f3f2d60d39b7516f831cb9a3811e82f2a2f1825467b24b96006ee5f494e7469b5a599ec6ab885df02d0ead0926ca45c4f2a1b",
            "_BLSG1PublicKey": "0x2f6dd4eda4296d9cf85064adbe2507901fcd4ece425cc996827ba4a2c111c8121e6fe59e1d18c107d480077debf3ea265a52325725a853a710f7ec3af5e32869",
            "_UncompressedBLSPublicKey": "LIfJiHzVr04zzwmwp8SED4e1O/5aIdnhgFEihXf7GRYVu543SyYl8R5Hc3KSqGiMnOHIUzq4AA9JWkzC5V9VMTA6ahVCvh4rag5vN/4vPy1g05t1Fvgxy5o4EegvKi8YJUZ7JLlgBu5fSU50abWlmexquIXfAtDq0JJspFxPKhs="
        },
        {
            "address": "0x65b3fee569bf82ff148bdded9c3793fb685f9333",
            "weight": 1,
            "g1_pub_key": {
                "x": "0x05fde1416ab5b30e4b140ad4a29a52cd9bc85ca27bd4662ba842a2e22118bea6",
                "y": "0x0dc32694f317d886daac5419b39412a33ee89e07d39d557e4e2b0e48696ac311"
            },
            "_BLSPublicKey": "0x138cf64f20414eed4eb6e5b1b0e08b03944d368d2df78461b493c16cee52fca12741fc9a64ca55a6c08987eba75fc1d1e13a64b9e1e6f6a4413acda3b4997adf184ae5b75a5bd807d5d03d698cd0366d443786276749d2831416dd497d3e53170b14f7028a3245c0383e378130ed3c439aff3b29be9195d778c13e462e4a4afa",
            "_BLSG1PublicKey": "0x05fde1416ab5b30e4b140ad4a29a52cd9bc85ca27bd4662ba842a2e22118bea60dc32694f317d886daac5419b39412a33ee89e07d39d557e4e2b0e48696ac311",
            "_UncompressedBLSPublicKey": "E4z2TyBBTu1OtuWxsOCLA5RNNo0t94RhtJPBbO5S/KEnQfyaZMpVpsCJh+unX8HR4TpkueHm9qRBOs2jtJl63xhK5bdaW9gH1dA9aYzQNm1EN4YnZ0nSgxQW3Ul9PlMXCxT3AooyRcA4PjeBMO08Q5r/Oym+kZXXeME+Ri5KSvo="
        }
    ]
}`
	data, _ := json.Marshal(s)
	res, err := dailRpc().TransactionSendAwait(
		ctx,
		from,
		endPoint,
		[]action.Action{
			action.NewFunctionCall("new", data, 0, types.Balance{}),
		},
		client.WithLatestBlock(),
		client.WithKeyPair(kp),
	)

	if err != nil {
		t.Errorf("failed to do txn: %s", err)
	}
	t.Logf("sendTx success %+v", res)
}

func Test_get_sync_header_height(t *testing.T) {
	//args := []byte("{}")
	res, err := dailRpc().ContractViewCallFunction(context.Background(), to, "get_header_height", "e30=", block.FinalityFinal())
	if err != nil {
		t.Fatalf("pack lightNode headerHeight Input failed, err is %v", err.Error())
	}

	if res.Error != nil {
		t.Fatalf("request back resp, exist error, err is %v", res.Error)
	}

	result := &Result{}
	err = json.Unmarshal(res.Result, result)
	if err != nil {
		t.Fatalf("json marshal failed, err is %v, data is %v", err.Error(), string(res.Result))
	}
	t.Logf("resp is ----------- %v", result.Result)
	t.Logf("resp is ----------- %v", string(result.Result))
	height, _ := new(big.Int).SetString(string(result.Result), 10)
	t.Logf("---------------- height %v", height)
}

type Result struct {
	BlockHash   string        `json:"block_hash"`
	BlockHeight int           `json:"block_height"`
	Logs        []interface{} `json:"logs"`
	Result      []byte        `json:"result"`
}

func Test_Json(t *testing.T) {
	str := "{\"block\":{\"author\":\"cryptium.poolv1.near\",\"chunks\":[{\"balance_burnt\":\"3673917769667200000000\",\"chunk_hash\":\"3518YUTebvcpTT25pPVDR1AZ7bNazoj66HAfZ3gJqSNN\",\"encoded_length\":7195,\"encoded_merkle_root\":\"2Fs41gBKVAKNAxHq5xYhngL2QHGYgRLF3UyBDNTNniqM\",\"gas_limit\":1000000000000000,\"gas_used\":69125569346482,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"5CDva6FguHqqRbLA6ZyhDCYCEwv7aQxRntkopdjwtpEp\",\"outgoing_receipts_root\":\"9b9JpF3dVZZFUdC2hbKYQTQPCuDp98aW5pnBRqJsdqcD\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"3Evr1EQKgDxcMXzucMDKZAeG6Xggi967dKpvA783dZtP\",\"rent_paid\":\"0\",\"shard_id\":0,\"signature\":\"ed25519:4d591Wh2iqeEyTVdy8ugmCgaAnccTBotpHnoRqmnwa6JxP8fzspu4GzAqSLXBUEZd6QEi9unFnK9p4fc8aV5DyyY\",\"tx_root\":\"GikyZtkzXpiXtLEZAkcqiJrcr2gMZ8VAUiX7Wn4kmZSN\",\"validator_proposals\":[],\"validator_reward\":\"0\"},{\"balance_burnt\":\"830964127214000000000\",\"chunk_hash\":\"HEvcb6D3ccK3uBa2jvPR1cyJKtizmajSetCtfzDTJuX4\",\"encoded_length\":314,\"encoded_merkle_root\":\"HGcw4GhAFX3miVA8Cd3comzt54JeMwS6xsAGmvPRaGvd\",\"gas_limit\":1000000000000000,\"gas_used\":9789559232514,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"EGNwA73SqFkV2oFR5J5QiPkjqzUx3nBYA2evTTtr1NQV\",\"outgoing_receipts_root\":\"AAUZMgaJxUNLt98ZsjSEhZ7vYu2jQHjujc2HfNT5Bf5R\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"8jtQjg2MMSowY6oF6Shvdc3Z4dhibEk7sR8LiAHUm9GA\",\"rent_paid\":\"0\",\"shard_id\":1,\"signature\":\"ed25519:2SNLCU3NHGuaerJ5jPa275wwtxnnu4DQvBh4ozMvXJZuzgs4EJPCfhb2vesnJ5CrF1RyQc9dfDZBn91FRLRP9Njp\",\"tx_root\":\"11111111111111111111111111111111\",\"validator_proposals\":[],\"validator_reward\":\"0\"},{\"balance_burnt\":\"728420795086600000000\",\"chunk_hash\":\"HjHqxNa9rqi4PAuLcrtaM4zuAvLPdaedigT16oUucKmE\",\"encoded_length\":3112,\"encoded_merkle_root\":\"rwG6Cm5h14wnXdeKaFk9WhXRJF8hbi8zXTkEe5vrc15\",\"gas_limit\":1000000000000000,\"gas_used\":32557076638366,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"28VCHwcMJusGdHxdVsT1ApioKXjL4oKDFZtjS8artpej\",\"outgoing_receipts_root\":\"GnMYZchhfax4ZSYKt4EvcgS8vPYDV6P9aWtBTZxUgaBp\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"88eTF9FGBspzrHGuqH327iwSdT9aqvpuMe3ViVkB4Z97\",\"rent_paid\":\"0\",\"shard_id\":2,\"signature\":\"ed25519:5z1AgUsUvmmHW7kZoffsTnFvTzKvtHzFvKpY6UwvJLB6nnbh1k8dHbch3yWkj2urTkgtRRW8F6sJBi8Rcoqe6ZsZ\",\"tx_root\":\"6hq1U2Wu8LyjtKcAH6VDRhwYdjMGaw1evTqSdWfnFjDB\",\"validator_proposals\":[],\"validator_reward\":\"0\"},{\"balance_burnt\":\"4431194740007700000000\",\"chunk_hash\":\"FGrEj1N5jaPWQv3Mwk9k46ueeLbhbJoovLB541E8dQ7T\",\"encoded_length\":4150,\"encoded_merkle_root\":\"B17LQpVRJpA6rBEan5GE5t7hE6VTEUZGXk1weNopMhVo\",\"gas_limit\":1000000000000000,\"gas_used\":47693094182334,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"6vwLNVugzL1qsNJQbKFgbZHWWhyXNHCzDmSoFgpMqM5o\",\"outgoing_receipts_root\":\"Gh239kg5WpGJvWhgyV7dUa9h9ZTWdrc61SRiwkmUzxrT\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"CtbeSZLSj7agT6Br5hPU3azbfEyns9bf3sGZKNwbLCR5\",\"rent_paid\":\"0\",\"shard_id\":3,\"signature\":\"ed25519:3K6h2mYkjbLzrz4B9UkzydVfVjHNrdBSY4vaoyLEX71w1KZUQQUFuPG8ZTXym2HJCxgRSRVZo6LBgtJUWqv3FPmC\",\"tx_root\":\"BdrjJVKTui5UgFNxCW1Yze6t1obLssHR3yevdk59TzmU\",\"validator_proposals\":[],\"validator_reward\":\"0\"}],\"header\":{\"approvals\":[null,\"ed25519:eCd8KKP1x3d8TWw26wncRdvA2xEDYmQLcDqUWHpz4YjSK5CUrYJFeN2YXH3fEbSceJjzE3Vc2WYGsNdjdCDreGm\",\"ed25519:4nvFrj3Q8oQaVjw4ShQ6boZ4EXbypP4Vopdhj6usWU93EqdvA2cTHtDNj2UWnD3vRTe4gzGEfjFHxixwhJkKGD8h\",\"ed25519:4YXoCi5sBqDrwNKUvtkoxgPxbthciY15JXSfWa2UMfnLixfBrbkj4njR3huvcbRB1MN9cGg7t6CvCjEqc5pHrEMb\",null,\"ed25519:fwKdNSk5iP5EwubBA3ciMZArQUCfuN2j6GSVKaB25EvALfBwZujooMszp4NWYNcceUKPqoDkiz8bx7keSa6qxPZ\",null,null,\"ed25519:k4KxAzi148Aidgowo3ndJgndThaEWXx6mxZwvxQHpQRzfPTfuzdSPf1SZ5XPw1yy1GNLHugMgBvXz8juxYdMqpZ\",null,null,null,\"ed25519:5iRJQ89rcJHCSfJCajjhYriJ9sw579uEcS5Qfu5v2qD51bCtccUgTR7SMgC9rn9rUNTE3VDm7PycCdwh6D2ZjNQm\",\"ed25519:jfgaJEh1U4b2hKwg6bU84qJzjFa3paKe97PToj67ZCjsaF9j4J4TqXzGDErfWp2B2RXYjVmhfdzWiHv4ugMaQ7o\",\"ed25519:4ZfT8eVwj1fw9mzRqDssDqPtcm7uXmki8yzoAiEfAgnNiY6dwhxPv6yrLfTvkpnZNCmMVW5LvQw9ASsLDUgG9Kvg\",\"ed25519:4JBPSvS4yt9FmdKs6qqNDtfKEmHymgmJeFB3x8bc6xUwD8aoD53e7w35YSz5ATfhANm48HsBrvPg4jUkXC77oWkg\",\"ed25519:kaEzztJV5ribPMQZKvvdtkxaf9VrHULtZJ9iBCHcxNNBPqT43iLBUQ1LDXPZMw3z8BSDEaKqJyKRFWqpBcj9ixN\",\"ed25519:3iPL5AbGTKdB3XrzA5q76wStk9QvBycu7ECaZsgsohkWb72gPncUejvNNT8LFqT9fY5cyBR3fSQm6AbCkFT6cyAJ\",\"ed25519:4Xp1LMYePNxm4fhyaiHcBzy8xGBY4nSxQ3xmwGvCKpkke3BZ4GrS27CPchQALTZccVoAyy4GsppUujqmnhEhqnci\",\"ed25519:3srFV7qAerVAFC9mC6CEGePx7S2782RhxHnH8eMP6puUrxAWeUppqPQ1Az4y7fYJpqMPtGQ2aYDB2nucFiPaB9i6\",\"ed25519:26jvFvpzQP9388bQNzEHNGN4SmZyF6KPbwKVWeMFqpdrE5hvRukTbKQx5MgQj1q7yzBRCrZcwfbUU7WMNa4Fwhsd\",\"ed25519:4kWDdyM3XmLzvoTDVYasfo1FSxec66wdbeHb2xmH288RpzrGrtPpnxpLY5AiFUcV5Vtgc7UKnQXiK4DpfV1csKip\",\"ed25519:5NpeprDfUYaswnzQTmUGEuJN7hzGHRqZGR8dn5TC7hkEVv3dGBSHLcFHooLSSb8FE6j9FGBzQKKA57QKZ3iKnGaq\",\"ed25519:2kTsbh2R8BgG75sWAPraRzgcZ65NQ4uYrc7N7rcVx5QVZQ8Wg9DPuu9GdXi7whY8LjyapaE5rqmjjtmVWwWnB6DX\",\"ed25519:5uGi5vx7oxGRW4oq2Xo3adGprwSy1f9Uw8TVj6Z51cYw4SuYgSyyGJYxvtAdQXHaQ73FvURMoJgaQpDtPgvdHLHN\",\"ed25519:21ETACHzBMffKsrwxj7i3RezFRdmdiK1zV19Rxhxg4jfFhJR7DNXiomDHJZ2tNKozTzBEA2uVpoExnJHmMsTMutk\",\"ed25519:5NnA63h1CkyMfTuhNioo95kG6THzLZabcCCVvx3yCQcevDVJgPRZfoLgVCnQhzP34ctiBpaxBsH5BDeL9gpymNxe\",\"ed25519:2bEgFu5w5oJRSBgaGFpCsUt25HatHpRUkRQhRdVTazFbedby96Dgx3NnVsmpwKNDBZxBd2nUV9NjsmGngCmEQ8kb\",null,\"ed25519:4bWkPqPLuuvhLWqbCCaHgY8trM2Le842aNZ7Ux5ntxcCk9F1zfLaBFJbthcHccCegabrd5bp3bDy4c5QeTjqryw8\",\"ed25519:jhgqkCRtM2aSW5AbyseCTAVGKm9DANuJRG396DF2UZnivUjXQLaCzryu9erCEChtpzKkXt3nNM8UcXWCMnrd4db\",\"ed25519:3WAPn1R1Lec59guHPAirN5V4uvKTAC91h4LG4TfYkzksdN1VytMpdaGxBRSQpD7mDjMtuq1nYrDRsvRPDNeZja7J\",null,null,\"ed25519:4Rh2skZoVPSwc6jJZXDNgSne9nfzSEAsqRxSA6aCrGv1E8mLJfae26K3ZvmDG3BfPH5Uc9eMxuRbtt8sdqwRawuy\",\"ed25519:3feqAGznE8X93xA6c11Baq7mWbAkhTP7jN4faAPXvWgWDFaV4hKVPJyd22Q7c1b2siVUuSEBRzv6Yh5piWucG3ge\",\"ed25519:5kZDoyossBzuqK651voUtKYGvmJf4NzrTTNYsJn5356GT9WFikCMv3E96CE9fetuNsfD6MYdSB77r1QGpshz7gqn\",\"ed25519:38iMTv1RwvhCG51ZNP2PgC1Kke199nmiDcYKjQRRMbqibjaRr5ALrm7LKYFpwUjQUkiGAWWcDKk6DYHtMoNtWRQT\",\"ed25519:55QQTAM2K8fAMLRH2kG19z9KTxyR1U3LrArz19AhVRJPbyWBudKtA1tSLneBDkPHLHnDLNb5NHB74ZCzVy7PaCrS\",\"ed25519:4gTCSxdSZzVgvCEHEuJixVEmtSB4mbnJiwCrE9JYSwxXc1enBK6SxoRnFK5Y3sxZ7QYxrQR1bYfLRXnediwUdx13\",\"ed25519:41unugwRXVdp52B2FGFjE6VCV6kRNsjPoYyMcJtcHSj7sB68sZ33eC1wtdLymHb95KFByyVuTkKTNjBSXvLyibAg\",\"ed25519:qwykXLhB8jkTj2F4H744BYJhNmq6ywE3mfEn343APBJ5e9HrB7QrJcxyoUD1dme3eUsLUrA61uxjp55o1KBByWb\",\"ed25519:4GDu4pjts2sxYeNFK65tsGYK7YvZWJSrCAPZuJsyPNDowi1BcVw8RXW2m83AytL1ZF2txeWhP3ruwmrUagXZKLVp\",null,null,\"ed25519:3S1qhwBVrQb2kQF2CJ4ELeUwoWQdpz7DdzWF5PKjbTRpa1eRRxgDQzi1Ce67CmSeeantHZuYNtxvWk1tdqivVhK6\",null,\"ed25519:2VVc1dec1zyriQQnYQ1t2zSxtXvHj2CopqNzhAU4Fv6V5bMGwpWWNDuhEpg2KvaTSz37AKpBYu1Pd7mCpZm3jsdc\",\"ed25519:2EkJn7K9UfHiALVsSrLajf3Zep1pVbZdBQBPSuJ2t7dfBeTij8yEeSaVEjfZ2iopbUEzPSHsRSjpvD1AH9SqRGGn\",\"ed25519:5TGiURvj8TCUJeprQukespyFSMyRoB55x3Hz6Zn7SfKzryTaaJLD3TnjwWcnCzVBpub2uySHmrYrCvPsdJkTh9y\",\"ed25519:2BuD2XHasEGdsBPCngDYXrAr4Hg7mDYqYfogc32eGDamLKLPtE4njjKMgWGm4fZifFCBHzvFRQke2YhKJV9xwfFi\",\"ed25519:2BEPbsc4BkBJrmjgAeFxiXcxTvLYtfcAZrKscA8gzEGuQMxeJh7eNMR1EWwtYh4mqfHsLDMyR5seF89iV65Kn6G5\",\"ed25519:3UUoWxkFmZnXJszEqYF6hiKjxywR7zPxjdgEHJUDnin8EMro93zv8yNVER215at2dDxqZpDm2yxNS34aHg2f5PaR\",\"ed25519:bFiA8wxSSRPx7QmvsmwpoWj7WVjB7LHnvVvAJG7Wao7wA2Dt3zxjLpm3njf8FH2YohjHk8XUHowHfaUeBU4aBnv\",\"ed25519:iN5Xj1bSSy2SeBjnhVLn8sdiJGjaNRmkzoKc6KBc9wEzp1tazmusa7ySTJEuNXoy25aXBq7XQzZqbV8hqjHTKF7\",\"ed25519:Wg3yK5AQcURJUjpLFFshv6WwSnYTuKAoy3zdvDFmdPZFUn6TpJzrfg7VmJs4eoWJqzTwxCQqKxJTD82gSCUr3bU\",\"ed25519:2fbLm2DZsjJUgbctcYMr7C3nfQ2PBZGrBRzHwWLMEmrbSdNZ3fg3o3ufc4aQtDe1gJnUVV2XdRdx8sH3dWdsNNNb\",\"ed25519:3nF1bQWPqUWtos1jWvJdgckZRoiE4vrduMGTm8mSW225D26uFs9wmvYva751B3EsWPEnwLG7BBKernf5N1YXXNCZ\",\"ed25519:4fUczkvw5BWwfm4MD6VQe1CqrAXyskj7DCJswXdQRipxrieeaBj1vhdESJ7WCmGhCv99kq5wANh69ifbUYrMX1FH\",\"ed25519:5Y8vTvxMFDVAqFyyTBDWARNv2S2yAfxms8NCydxogTv5NsrX5DwBLcAoNPAHcEfZNvNc4mDxwX6pQab7aPbNJ24\",\"ed25519:stYY1HAyMh23PzighAdTPsUMRxaeRUmFAMKHZ1dqff9Ah18KefWvt4jLeqAkFmGDNworNow8T5qLEjr4HzDvxKQ\",null,\"ed25519:5zbyJRJPjdrMtGcYmx4CozRbwQYahbrMC9RvAkXDNDJwu7iXwhuu3SsR2NkVvMK5KyHUzarz8XQ8SVybGg5px7gJ\",\"ed25519:3Z8nZYnzyeZjxXHUgiBRDyTtmMkwAHw2KNRKXYXKU74buj5VZ8rLoCc1GZ6hUegJQp7xDo482H2tfa3hY4bVTRFj\",\"ed25519:vXJnFzrUALMQxTzw6SUkmAhKMev3b2BHHsSP2zwbWVYUMQxJonNoUF314NK1SogxiQJ9XyPbmbUZedESKP7JMLg\",null,\"ed25519:zVn1uPVGd3JcpvaLNRx5Am1Bs6G5QuVXU8cYYmCZrxwDGCJZpQ6jg45ssKtY6yQ33AGFPPdtynCu41o9uxK7ikV\",\"ed25519:nWVUJFqBKinAqm2tXaWebFKoJ5H7wjgbwrTpC2YmhZSFfShRrgTZrpF6Jy3nBCYh4QTPedmRczQhkSrETQ1UpDa\",\"ed25519:3zQK6ppmN46mZkP6mukCEigCgtfeBUVge8ahWuvUgARfVRuzyuTtuMDRHiLmAcmiXhP3woFDe8Mwvq8bdyXFpJ3x\",\"ed25519:3SBXpwiWhgTmncaVqew1kxmYPpKj5HX9LzGjMg3aq8bLn58SKx2jPwaSwk1Bb4g8NuXCqNi7unGXMU6qYwJcYjeK\",\"ed25519:2XVAKNKiWQ5Bs4dVNR1gXjNwaMxJNXy6tLVjDFzbHfJFceuXsG3kR3ikVttfdqugEt6hMrtLFyp1jAEW23aK7ZHu\",\"ed25519:3cHqt3yvkZGXYNz3VvWjSJHhnfafZQMTLhYM2sVRpUwY9WqLbNqjgLPCbenwA9XrLWN69M7tyzdVck3VaTtZcZrP\",null,\"ed25519:wJYsZei4toE73V2S2exMhBFdpxjRC29BR5grGkuHxHN3qvt3gqrGn4yAfPeZfbehHWA5deq3iskQQspDSaE3vW1\",\"ed25519:3uKW8oYUFmYfCKrMYpBD571qnDUdY6kDwQiJxDRQBNTncHdoH7JorNWdKqjbsbRqymhHdRN5V7Y5M2GA7woNXKQ7\",null,\"ed25519:2sbVxGXx21qkMAU2w8s6hPhBt6uEvdrPiGpLhgizRc7ZX6FAt4oWJ7D4z8UoFPUBXay8DY7iZt2Wj7cgiL4sNozT\",\"ed25519:5Hw2no22fWrqKRNPHMGkCSJmYJtBTaXN7FJvr7rTNPtGVx2cbseDGP1XgC8pMKuJL8Rsy6oyYZyMxvsH3JJJ5wbe\",\"ed25519:5gATsDEW3kJwmDVoGYw9hyZK3UDvQ6kq9N9mcksoF3GK3NHH8rMjodjHxM1C9NFAGvPU7MXBpvq3Cvpxbb8mC9M\",\"ed25519:2whiGFBoA1FtDdD9ZSiDTsVvgvE9D93ouNLsyX14R6dvhGN75uXhvmGL92QmZJRwqZMFEhohSQGXC2uXAHUZuqN3\",\"ed25519:2ZMfn2SD6gsFGFBNFSsGqV7VvGqPmE3KLfRu1WLSPNsBNuBU9PXrnYEM2tdrg7LKmXYR1HGjhtVAtiyPY5WVBSMA\",\"ed25519:2NLcY5v4miS3JWMuTUPFnD5PB8hZk9jMJGh3TPjynAKmcz8zhogbSssRxJHP8SmrdNfpTNhJaRJmoqHuSeHprCzx\",\"ed25519:65nKEveCXYc8gBA9PKpNhXQNJuVkrR17vb5WdJ43SJsaQzoiwn5mUFg1nUoSYo1BQCt3ik3kKedmVz5firVJQC1\",\"ed25519:2Vay5w643mnBqCBym2aLTpiPKAo44wtJEdE7nRjMSFoFsJE9gKK6CfhhaBzNS9iBBWztv2JsDy5aqcfaF4K2TUvW\",null,\"ed25519:5yKdRPiPG8pVhpfsUS5sLBALev7Qz13cEtURDNAFpRPH4rMGSDNjcvU7vCQURUqopd4N3V5YXwdQBriBNibPSvUr\",null,\"ed25519:4UAx2iJUTtuUsPaCjJAvKP9eKWhhneFEeHWjpqJ7ee29uWo26JSF9ev3uVL5WAGj9YXR65UkyrzPRfGaXL9kRjqC\",\"ed25519:3qM8adhK3P663i2BThbPCXZ69Uj37TLkPiBBGGjaWxjHSUJjiSCuuALYRRyuVswLRaacoWxfWt8rPWwuVwnFNbGC\",\"ed25519:5gxYuKU5StJHG87Wni5AfzE3eT9iti9VrP77KwHuTjhHhawYVXfp9dvvbSRrYHAq9nZoZySXag27LtUFJ6yycHh6\",\"ed25519:TRAQVHY6BRXQmgKNT7ZCzxvjT5dsG3yWn61g7NMMtZuaskjRjnZnWboSRxEJQCWjWvNxMNR8nvWf7EuaFP64GLG\",\"ed25519:7p1FQ39HjzTakkT8jfayA2RRdw8EBHEtmfBWEwHQG1pK3NMoArhsbZmv2tKrUwT38TbWxXVKHDYiCfgqYgDYxaV\",\"ed25519:tYRPcLJspJsUTa2TCG3AUuuSpxVwr37zA6YX59BGhNRPFt5xptFfur3quydpgrTc6LpvfYr9fJiuGnFqvtAEfEA\",\"ed25519:5SaLTSxK2M6ZWpqQgSnuDvPDxmJNVhMWfZvCJGn3mdFDHGSLgf21i9ZXoJPnxkjZvE3XobR5Lxh9tHWcsTYvMwr4\",null,null,\"ed25519:49qtGSAbejxi32jAGNmaZ7tm5RzyB5xoHu8TLxNV381Qu6WGWN8NCDawC2NK9a9sHLk9FUwM27MNMXXU8vvRpRTJ\",null,\"ed25519:34MER6t7bRZ9mRqK1sdEAwHg4srWoJ1Bq6GYMJxWw5g6PCB3jYCEaZbgVZGih2UWRKQy2E65ZqjhKjUkn5UUXWdJ\",\"ed25519:doWjdHEmP2yLhDVLBhvL2MGNwYoqvy9sitiReXqdMHdjk8sPGobm5hMgZ8M3TVLqvciPf6VMAzpPTtwnc4DjTNp\"],\"block_merkle_root\":\"AQpJdEWniTQt2vGV8rwec8hcqBFR4LeFv5xQt5FRkB3N\",\"block_ordinal\":82716163,\"challenges_result\":[],\"challenges_root\":\"11111111111111111111111111111111\",\"chunk_headers_root\":\"DCUwn6yMtLpei4bpDDCkHUvu4qE91Wxs5ktsTr5MnKmz\",\"chunk_mask\":[true,true,true,true],\"chunk_receipts_root\":\"FBCpZToM7huLoqunHmddEmuttvRvCGCSc6FAoUaKt4gK\",\"chunk_tx_root\":\"7HYSbfJG3PNgitbw8Ap5jv92ATu65LHGFjrhRWT3J7Qp\",\"chunks_included\":4,\"epoch_id\":\"AcySQ4RQTqSHu5nScK67GgRDjjbWhi8hyhTZgonA6qMX\",\"epoch_sync_data_hash\":null,\"gas_price\":\"100000000\",\"hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"height\":92764782,\"last_ds_final_block\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"last_final_block\":\"C4dvkQmz1cTkMT7RiQUxofKVYDimuBBMaC32Vu9e5cg4\",\"latest_protocol_version\":60,\"next_bp_hash\":\"DKskg8RHMyRfCgLSmGaDjJByaufGrzvL5LKeaVUsh8WL\",\"next_epoch_id\":\"2XQVEh6YG1DergPk89PNBQdMQpFZG51iqrA66q43392Q\",\"outcome_root\":\"APsRn1xM9v551kRpyAMgvRFudrYeGisaNWBn4onB1idB\",\"prev_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_height\":92764781,\"prev_state_root\":\"2teD5VbzszQgi4SDH6re5LAMTJ4rJW7YjfWqbgrYtaHA\",\"random_value\":\"DoMa3oanQVPK9rfJLQ8uanv1F38mp4VmKzyVjTMsS1m\",\"rent_paid\":\"0\",\"signature\":\"ed25519:266K5gX8WYX2F8PVtBYjyiMqMKkbtxndVRZgACP8QUK5aL4Km8MgeASAZ6CrCngzJmScBXwWDAHmEWUBdN5sEgf2\",\"timestamp\":1685118680614918699,\"timestamp_nanosec\":\"1685118680614918699\",\"total_supply\":\"1136439149802763608645345483700628\",\"validator_proposals\":[],\"validator_reward\":\"0\"}},\"shards\":[{\"chunk\":{\"author\":\"stardust.poolv1.near\",\"header\":{\"balance_burnt\":\"3673917769667200000000\",\"chunk_hash\":\"3518YUTebvcpTT25pPVDR1AZ7bNazoj66HAfZ3gJqSNN\",\"encoded_length\":7195,\"encoded_merkle_root\":\"2Fs41gBKVAKNAxHq5xYhngL2QHGYgRLF3UyBDNTNniqM\",\"gas_limit\":1000000000000000,\"gas_used\":69125569346482,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"5CDva6FguHqqRbLA6ZyhDCYCEwv7aQxRntkopdjwtpEp\",\"outgoing_receipts_root\":\"9b9JpF3dVZZFUdC2hbKYQTQPCuDp98aW5pnBRqJsdqcD\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"3Evr1EQKgDxcMXzucMDKZAeG6Xggi967dKpvA783dZtP\",\"rent_paid\":\"0\",\"shard_id\":0,\"signature\":\"ed25519:4d591Wh2iqeEyTVdy8ugmCgaAnccTBotpHnoRqmnwa6JxP8fzspu4GzAqSLXBUEZd6QEi9unFnK9p4fc8aV5DyyY\",\"tx_root\":\"GikyZtkzXpiXtLEZAkcqiJrcr2gMZ8VAUiX7Wn4kmZSN\",\"validator_proposals\":[],\"validator_reward\":\"0\"},\"receipts\":[{\"predecessor_id\":\"app.nearcrowd.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoicmFib3RhcGVybTMubmVhciIsInNvbHV0aW9uX2hhc2giOlsxODAsMjMsMTQ5LDE3OCwxNzQsMTMwLDM3LDg3LDIwOCwxOTIsOTgsMTg3LDE4OSw0Niw2MSwxNzAsMTA3LDIzMCw5NSwxODcsNjQsMTA0LDIzMywyMTcsMTMyLDE2NCwxOCwxMzksMjI3LDU5LDEwMiwxMThdfQ==\",\"deposit\":\"0\",\"gas\":200000000000000,\"method_name\":\"approve_solution\"}}],\"gas_price\":\"335989893\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"app.nearcrowd.near\",\"signer_public_key\":\"ed25519:aSgLALWzkhfCa5D66V8x8QgP1qU46mWVA2CikGJNYVm\"}},\"receipt_id\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"receiver_id\":\"app.nearcrowd.near\"},{\"predecessor_id\":\"6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOko5ZGp6cVlYblktNmZhZWZmYTQ4MGE1MDJhMWVjMGZjYjI1YTQyMzdjNGQ1M2VjMWZmZjk0NTVlNjdiODQyY2FmODRjOTI3YTkxNyJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"109272700\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\",\"signer_public_key\":\"ed25519:4BiExDrNAgX822LmEJLP6mjcADnQfNwoimRNrnuvtmuL\"}},\"receipt_id\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"receiver_id\":\"token.sweat\"},{\"predecessor_id\":\"a081b1bb750d7c1e20e2a033e6237cba2f2709b4f7aebd3a3623ca198a7dbd35\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYTA4MWIxYmI3NTBkN2MxZTIwZTJhMDMzZTYyMzdjYmEyZjI3MDliNGY3YWViZDNhMzYyM2NhMTk4YTdkYmQzNSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a081b1bb750d7c1e20e2a033e6237cba2f2709b4f7aebd3a3623ca198a7dbd35\",\"signer_public_key\":\"ed25519:BoYwAfniA8RwSet9fyqaa1o9eCkodzx6vENZs1FasDq6\"}},\"receipt_id\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"receiver_id\":\"usdt.tether-token.near\"},{\"predecessor_id\":\"0182e5d62f1c3d6a4b26b49c934d58a0052e0f9cadf046e22dfa5cff1e92d835\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"0182e5d62f1c3d6a4b26b49c934d58a0052e0f9cadf046e22dfa5cff1e92d835\",\"signer_public_key\":\"ed25519:6uB7bgkaNN1aRVGJ4MtS44jcN5AcBa5UwEodUK3jxfn\"}},\"receipt_id\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"receiver_id\":\"tge-lockup.sweat\"},{\"predecessor_id\":\"3d50d495-a.embr.playember_reserve.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhcGlfaWQiOiJteXRlc3RhcGkuZW1ici5wbGF5ZW1iZXJfcmVzZXJ2ZS5uZWFyIn0=\",\"deposit\":\"0\",\"gas\":30000000000000,\"method_name\":\"register_account_as_player\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"3d50d495-a.embr.playember_reserve.near\",\"signer_public_key\":\"ed25519:BLepEWpZwFvZSjT8XARNKbZZ9qYcjBLzsQUNoRJjxAF9\"}},\"receipt_id\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"receiver_id\":\"embr.playember_reserve.near\"},{\"predecessor_id\":\"64abffbe659f5da752d0821a72d9f0cb660c4bc84e90b1104a4b4065d98a6c75\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiNjRhYmZmYmU2NTlmNWRhNzUyZDA4MjFhNzJkOWYwY2I2NjBjNGJjODRlOTBiMTEwNGE0YjQwNjVkOThhNmM3NSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"64abffbe659f5da752d0821a72d9f0cb660c4bc84e90b1104a4b4065d98a6c75\",\"signer_public_key\":\"ed25519:7mytRQ2oBzrUjXBkcjKUNeum9N6obX3Z3E5GYpgiq5Yp\"}},\"receipt_id\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"receiver_id\":\"usdt.tether-token.near\"},{\"predecessor_id\":\"1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOko5ZGp6cVlYblktMWQxM2Q0NjNiNjdkM2E2Nzk0ZjVhMDU2YzRkNmE5ZTZhZWE5MGI3NmQwZjBjZWQ1MTJjYjE3OWM4MWJhMDhmNyJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"109272700\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\",\"signer_public_key\":\"ed25519:2xWMvK1meQnUGoaxNs1ZDVeerCcq3kufNQnwz398d3jU\"}},\"receipt_id\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"receiver_id\":\"token.sweat\"},{\"predecessor_id\":\"a3e1f5b1724f18cba5cf35ad3d20037feaf7e7c5709e8838b83759d7504b0bcc\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYTNlMWY1YjE3MjRmMThjYmE1Y2YzNWFkM2QyMDAzN2ZlYWY3ZTdjNTcwOWU4ODM4YjgzNzU5ZDc1MDRiMGJjYyJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a3e1f5b1724f18cba5cf35ad3d20037feaf7e7c5709e8838b83759d7504b0bcc\",\"signer_public_key\":\"ed25519:C2jJ6HMnY24Srb58aivEoy5DKkxBsXffp29ZcMpBxHZu\"}},\"receipt_id\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"receiver_id\":\"usdt.tether-token.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"67682515494078360916120\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"app.nearcrowd.near\",\"signer_public_key\":\"ed25519:6MP4bCPHEud33eKXM9kg7f9fVNhmn97CNUyn5ZwM375U\"}},\"receipt_id\":\"wkEmrrch8JHi6WyZGwLeQLxPia8jAKWFty3BSQKo2mL\",\"receiver_id\":\"app.nearcrowd.near\"},{\"predecessor_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJzZW5kZXJfaWQiOiJlMDMzNjFmNTY1MjdiMjc5MjUzMzQyNTA5OTNmZGNiODY2MjNlOTA4MjU0YjhmOGFlZDhhZTAzN2ZmMmUxYmI1IiwiYW1vdW50IjoiNDcwNTk0OTYiLCJtc2ciOiJ7XCJ0eXBlXCI6XCJUcmFuc2ZlclwiLFwidG9cIjpcIjB4MDc1N2JGOUIxNDg4NDUzM2E0QjNFODlGRDhEODc4ZjU0OENGQ0M0RVwiLFwidG9fY2hhaW5cIjpcIjIyNzc2XCJ9In0=\",\"deposit\":\"0\",\"gas\":270000000000000,\"method_name\":\"ft_on_transfer\"}}],\"gas_price\":\"625040174\",\"input_data_ids\":[],\"output_data_receivers\":[{\"data_id\":\"DJzQmhhaummUUFNzP99semWjwgwjmjo86A4pAqUBzch3\",\"receiver_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\"}],\"signer_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"signer_public_key\":\"ed25519:G6BmWT85Uu4At6rPxkma6ERZGFQd5opn8JunAzTu8UMA\"}},\"receipt_id\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"receiver_id\":\"mos.mfac.butternetwork.near\"},{\"predecessor_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJzZW5kZXJfaWQiOiJlMDMzNjFmNTY1MjdiMjc5MjUzMzQyNTA5OTNmZGNiODY2MjNlOTA4MjU0YjhmOGFlZDhhZTAzN2ZmMmUxYmI1IiwicmVjZWl2ZXJfaWQiOiJtb3MubWZhYy5idXR0ZXJuZXR3b3JrLm5lYXIiLCJhbW91bnQiOiI0NzA1OTQ5NiJ9\",\"deposit\":\"0\",\"gas\":5000000000000,\"method_name\":\"ft_resolve_transfer\"}}],\"gas_price\":\"625040174\",\"input_data_ids\":[\"DJzQmhhaummUUFNzP99semWjwgwjmjo86A4pAqUBzch3\"],\"output_data_receivers\":[],\"signer_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"signer_public_key\":\"ed25519:G6BmWT85Uu4At6rPxkma6ERZGFQd5opn8JunAzTu8UMA\"}},\"receipt_id\":\"D4r4dFz1v6hhAWSeEznH89yLWfw2pjotmmX6AwqyQbCE\",\"receiver_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13211855362853269146864\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"signer_public_key\":\"ed25519:G6BmWT85Uu4At6rPxkma6ERZGFQd5opn8JunAzTu8UMA\"}},\"receipt_id\":\"BDqp8fioCtqie4jtZnsHf2dVFAyGURNoFnba463s4tdt\",\"receiver_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13214028874009742651168\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"nearcrowd_2.near\",\"signer_public_key\":\"ed25519:2RRwQPTGRZkavm5sf1gJEbay34MpBMpw7LTriD3ZeLBZ\"}},\"receipt_id\":\"EVzjwprJmpvwATvvy6vMDB5Y5UJWfksE8aWb9PvcNepm\",\"receiver_id\":\"nearcrowd_2.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"669547687500000000\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"mytestapi.embr.playember_reserve.near\",\"signer_public_key\":\"ed25519:CKyBFz2ncy7GP9oqDqUojEQm4aPzntmQf4zswVyj4kSH\"}},\"receipt_id\":\"CtQACcsYrAuAWoGPoUE7uM6c3JoZ9rHQNfhtMMbJoyYD\",\"receiver_id\":\"mytestapi.embr.playember_reserve.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13236703872667742651168\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"rezerv-42.near\",\"signer_public_key\":\"ed25519:5NVcZnEZY9xcknHjb5BzmzhHdD7P8TD8LvQ9kBJWNbbQ\"}},\"receipt_id\":\"4AztGSk1EGUy7WU7NgoZKe1Wrnh59zcQc114vxvM7ubf\",\"receiver_id\":\"rezerv-42.near\"}],\"transactions\":[{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"HVua5uD1PUjoakRF3mVKW5a3qaRzugvAoYgYkVHxcyd\",\"outcome\":{\"executor_id\":\"89addbfbfc6b34ae6403f39ee2c92280827d80a98dc40d15729824d232be343d\",\"gas_burnt\":2428135649664,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"9zBu3257Zd4ierBx8jNW458zM3C4DzarmrYhZUvW1VsJ\"],\"status\":{\"SuccessReceiptId\":\"9zBu3257Zd4ierBx8jNW458zM3C4DzarmrYhZUvW1VsJ\"},\"tokens_burnt\":\"242813564966400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"4HpCDZB1i1torRYMPV1eCFpUp8S9juoMiv1tzpfzMqPn\"},{\"direction\":\"Right\",\"hash\":\"FbcQDRUthNMUCeYqgdqx6JGrPAK9Ni3d6vr6urhiRgbx\"},{\"direction\":\"Right\",\"hash\":\"DYL3X5j4XT1tj57z2qChMWGmwSp53gtyN9fMRuJGeomy\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiODlhZGRiZmJmYzZiMzRhZTY0MDNmMzllZTJjOTIyODA4MjdkODBhOThkYzQwZDE1NzI5ODI0ZDIzMmJlMzQzZCJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"hash\":\"HVua5uD1PUjoakRF3mVKW5a3qaRzugvAoYgYkVHxcyd\",\"nonce\":73754297000120,\"public_key\":\"ed25519:AGScmR9rZXuSuKaSZtZYzGZsxKor1NPCfNam6aaFbdMN\",\"receiver_id\":\"usdt.tether-token.near\",\"signature\":\"ed25519:2uNaLs1anQbYkutHT1pDWp1nnFBhuwgX2pACE7omnbNr4vDeyS2GwBV4Y4aujuNMnHkxw4utkdeLEhkPjSFUaug4\",\"signer_id\":\"89addbfbfc6b34ae6403f39ee2c92280827d80a98dc40d15729824d232be343d\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"9PYCn1h6f3UwP2fGoUKLToZRPvUmDTJ3aHhyBrPqEKTd\",\"outcome\":{\"executor_id\":\"1d6c1c8b24edf29e581613a2b5501d023ab762b55541d731bbd6f1926a857978\",\"gas_burnt\":2427936651538,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"Hf5mXqej3Sqfx32wDvdw8e3crUz7FRontCW63ezVNiDW\"],\"status\":{\"SuccessReceiptId\":\"Hf5mXqej3Sqfx32wDvdw8e3crUz7FRontCW63ezVNiDW\"},\"tokens_burnt\":\"242793665153800000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"DxBTaA7HNpj7Rtsc4apH5Vz9MP3gbem3BxVnvBkiP65A\"},{\"direction\":\"Right\",\"hash\":\"FbcQDRUthNMUCeYqgdqx6JGrPAK9Ni3d6vr6urhiRgbx\"},{\"direction\":\"Right\",\"hash\":\"DYL3X5j4XT1tj57z2qChMWGmwSp53gtyN9fMRuJGeomy\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"hash\":\"9PYCn1h6f3UwP2fGoUKLToZRPvUmDTJ3aHhyBrPqEKTd\",\"nonce\":82709690000066,\"public_key\":\"ed25519:5hF5RjYCQsW1PAfVbT68gBRHZ7wSy3Zqtz8TeeX4mCaD\",\"receiver_id\":\"tge-lockup.sweat\",\"signature\":\"ed25519:4HhLFaaYiQy7nawsWf5hEexYe9NsoPZ7Nra8tQ2SGzmGjkfrnNakJpogWfmEpoD2hsAaV5c8vwwgQ4temdCmt54o\",\"signer_id\":\"1d6c1c8b24edf29e581613a2b5501d023ab762b55541d731bbd6f1926a857978\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"4zPqfd2F5DGfADGLLAMK4Ya4atDeXWgWpunRkhaTRdm6\",\"outcome\":{\"executor_id\":\"7fc1dd34509cf7b0d6692179bb99ab99ae71f224e3e6d119dbc7e40b6a5458d0\",\"gas_burnt\":2428314524384,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"Bnyhao6bmyymAuJMymzBvi4WjxV1BoJUbw2dFvs7t23y\"],\"status\":{\"SuccessReceiptId\":\"Bnyhao6bmyymAuJMymzBvi4WjxV1BoJUbw2dFvs7t23y\"},\"tokens_burnt\":\"242831452438400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"HgejmBu9zQ3nAsnBm1rzLEHUdwmm5zeqxBoSpwEs6Qsi\"},{\"direction\":\"Left\",\"hash\":\"BKmUYuHMznYU84EshTJSgJBsDqzMGnRj1cwMMxnNxoDG\"},{\"direction\":\"Right\",\"hash\":\"DYL3X5j4XT1tj57z2qChMWGmwSp53gtyN9fMRuJGeomy\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOnlFWldFUFo0YTAtN2ZjMWRkMzQ1MDljZjdiMGQ2NjkyMTc5YmI5OWFiOTlhZTcxZjIyNGUzZTZkMTE5ZGJjN2U0MGI2YTU0NThkMCJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"hash\":\"4zPqfd2F5DGfADGLLAMK4Ya4atDeXWgWpunRkhaTRdm6\",\"nonce\":73110403000008,\"public_key\":\"ed25519:9biETR76Ar5A9gdcN4M1VCRCYNh95bMkbKUV2wZYv41m\",\"receiver_id\":\"token.sweat\",\"signature\":\"ed25519:3n5z9pzozpQi8uvZrJC1s9idcJTv7xBcfZ6Wix7Yfz54zGBn4JYL7kD3B3dRRvt1CppBQFojVRyE2GAoZNvt2G6G\",\"signer_id\":\"7fc1dd34509cf7b0d6692179bb99ab99ae71f224e3e6d119dbc7e40b6a5458d0\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"4Fgd5NkSW8KAw4vo6yoa9uWN7evpgkRFxDLw68ZZUdas\",\"outcome\":{\"executor_id\":\"998aef31da68f8a525d54d3ce3dc8a68adfd9392969b4e1ce1a943a275d667b4\",\"gas_burnt\":4748337011632,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"2gFryBxfNpuo6hsD2sKdS3qQykWv89AQFVPafoiT3jxD\"],\"status\":{\"SuccessReceiptId\":\"2gFryBxfNpuo6hsD2sKdS3qQykWv89AQFVPafoiT3jxD\"},\"tokens_burnt\":\"474833701163200000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"4GzT1nWTDHgYcKrZFFQ3QcFCGGXTivnscxZHua8Tdteh\"},{\"direction\":\"Left\",\"hash\":\"BKmUYuHMznYU84EshTJSgJBsDqzMGnRj1cwMMxnNxoDG\"},{\"direction\":\"Right\",\"hash\":\"DYL3X5j4XT1tj57z2qChMWGmwSp53gtyN9fMRuJGeomy\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6ImYxZGI2MjEwM2ZiNDczZGY0ZDJiODlhZTc3MTBmMzAzYmE4Y2UyNGNhYWQ5ZTQ0Yjg4NWY3Yzg4OGI5YjFkNjIiLCJhbW91bnQiOiI4NjYwMDAwMDAwMDAwMDAwMDAwIiwibWVtbyI6InN3OnQ6TFE2TkwxYWxRRCJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}},{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6ImZlZXMuc3dlYXQiLCJhbW91bnQiOiIxMTIwMDAwMDAwMDAwMDAwMDAwIiwibWVtbyI6InN3OnQ6ZmVlOkxRNk5MMWFsUUQifQ==\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"hash\":\"4Fgd5NkSW8KAw4vo6yoa9uWN7evpgkRFxDLw68ZZUdas\",\"nonce\":86193362000020,\"public_key\":\"ed25519:Ds2WiuryPoxnHUGgKEoQP89Un3rcACu52az89zv6pFke\",\"receiver_id\":\"token.sweat\",\"signature\":\"ed25519:2hM7VDJmNDgFhGQCQ75P8YfWEVVXRDLjABiKTAhmz94XsCBnSKuawm7CN2YaMBHd4TC9auzVH3desBm35h1AX5Au\",\"signer_id\":\"998aef31da68f8a525d54d3ce3dc8a68adfd9392969b4e1ce1a943a275d667b4\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"725pXT1Xa3y3VaeW8oTb66MuVh28bU11YdzhRQSfnbuQ\",\"outcome\":{\"executor_id\":\"633df47e6fe62de8d6b3db7cb410f85a7b12a957a5e84d49236aa683c962016b\",\"gas_burnt\":2428314524384,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"9wXtaskQ13Dreb7JUYuaP1Ap5v63osZWEh2TYSqCbBWr\"],\"status\":{\"SuccessReceiptId\":\"9wXtaskQ13Dreb7JUYuaP1Ap5v63osZWEh2TYSqCbBWr\"},\"tokens_burnt\":\"242831452438400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"88X6qHEGKb5RmFMgZoUYUsnKuhMpmJZMGXdjCSDNr7rK\"},{\"direction\":\"Right\",\"hash\":\"6eHyprQvWcJxkAwseG3mXnX2mb4gesgevFUFmMZgzHNo\"},{\"direction\":\"Left\",\"hash\":\"7Dfb2vHxCahwTCZugK7xWamCwSmRYNogcaKbN63jwzLE\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOnlLNVdyRTk0MTItNjMzZGY0N2U2ZmU2MmRlOGQ2YjNkYjdjYjQxMGY4NWE3YjEyYTk1N2E1ZTg0ZDQ5MjM2YWE2ODNjOTYyMDE2YiJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"hash\":\"725pXT1Xa3y3VaeW8oTb66MuVh28bU11YdzhRQSfnbuQ\",\"nonce\":66746200000070,\"public_key\":\"ed25519:7gQA1ugkWgJWHzBNqPofUVh3cuXo3Xjx6tQ4BBbhto4E\",\"receiver_id\":\"token.sweat\",\"signature\":\"ed25519:43rfgqojWh8B89uNHh1qKPEPz44SAjhteDrWfgQ85BZNyayjykKZZAVJfVcZxkU1biLf7HziCd4Fqmf7Lh1wh75k\",\"signer_id\":\"633df47e6fe62de8d6b3db7cb410f85a7b12a957a5e84d49236aa683c962016b\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"6c7eBqD46vA51qxUivd6jJBfef2HGy6aB8kM3F4r6aQf\",\"outcome\":{\"executor_id\":\"app.nearcrowd.near\",\"gas_burnt\":2428334647790,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\"],\"status\":{\"SuccessReceiptId\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\"},\"tokens_burnt\":\"242833464779000000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"DuxkimWfk3KRaUY2RzspW5vpyivd6D4xweWgWJ4Bh7E3\"},{\"direction\":\"Right\",\"hash\":\"6eHyprQvWcJxkAwseG3mXnX2mb4gesgevFUFmMZgzHNo\"},{\"direction\":\"Left\",\"hash\":\"7Dfb2vHxCahwTCZugK7xWamCwSmRYNogcaKbN63jwzLE\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoicmFib3RhcGVybTMubmVhciIsInNvbHV0aW9uX2hhc2giOlsxODAsMjMsMTQ5LDE3OCwxNzQsMTMwLDM3LDg3LDIwOCwxOTIsOTgsMTg3LDE4OSw0Niw2MSwxNzAsMTA3LDIzMCw5NSwxODcsNjQsMTA0LDIzMywyMTcsMTMyLDE2NCwxOCwxMzksMjI3LDU5LDEwMiwxMThdfQ==\",\"deposit\":\"0\",\"gas\":200000000000000,\"method_name\":\"approve_solution\"}}],\"hash\":\"6c7eBqD46vA51qxUivd6jJBfef2HGy6aB8kM3F4r6aQf\",\"nonce\":43616664839556,\"public_key\":\"ed25519:aSgLALWzkhfCa5D66V8x8QgP1qU46mWVA2CikGJNYVm\",\"receiver_id\":\"app.nearcrowd.near\",\"signature\":\"ed25519:VrzQPazZW6XSwW9b5jRNZyfiCFn4kUnaUjhANccts2B6R2hvRvB5W9bXKgmPpvCBdFMtnW7ensKVEdWa9gkuqGo\",\"signer_id\":\"app.nearcrowd.near\"}}]},\"receipt_execution_outcomes\":[{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"outcome\":{\"executor_id\":\"app.nearcrowd.near\",\"gas_burnt\":3268580321039,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"104961404250\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"86640000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"13049316000\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"323113305\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7551495558\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20599458\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"123442110\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"706580754\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1832554542\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1675001106\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"386446942224\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"24629200860\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"11215179444\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"612848700\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"11462089944\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"878161284\"}],\"version\":3},\"receipt_ids\":[\"4S6nFp6Hv5Fvc936k1HE7ryBdXBYtC8a1nyZA9nxEPXA\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"326858032103900000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"E6xxA1eZsVkcRVnqX68wPwmjmwdvhS2KXsuRZtZMBUE9\"},{\"direction\":\"Left\",\"hash\":\"35WpA5eZTVA6Wo7aw4k1CsyPQWaKrjsCttgsoeedX3X8\"},{\"direction\":\"Left\",\"hash\":\"7Dfb2vHxCahwTCZugK7xWamCwSmRYNogcaKbN63jwzLE\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":{\"predecessor_id\":\"app.nearcrowd.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoicmFib3RhcGVybTMubmVhciIsInNvbHV0aW9uX2hhc2giOlsxODAsMjMsMTQ5LDE3OCwxNzQsMTMwLDM3LDg3LDIwOCwxOTIsOTgsMTg3LDE4OSw0Niw2MSwxNzAsMTA3LDIzMCw5NSwxODcsNjQsMTA0LDIzMywyMTcsMTMyLDE2NCwxOCwxMzksMjI3LDU5LDEwMiwxMThdfQ==\",\"deposit\":\"0\",\"gas\":200000000000000,\"method_name\":\"approve_solution\"}}],\"gas_price\":\"335989893\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"app.nearcrowd.near\",\"signer_public_key\":\"ed25519:aSgLALWzkhfCa5D66V8x8QgP1qU46mWVA2CikGJNYVm\"}},\"receipt_id\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"receiver_id\":\"app.nearcrowd.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"wkEmrrch8JHi6WyZGwLeQLxPia8jAKWFty3BSQKo2mL\",\"outcome\":{\"executor_id\":\"app.nearcrowd.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"5y1C3zB5tMjn9rx32CathQwFo13JhLXYEaLZEgrimKSz\"},{\"direction\":\"Left\",\"hash\":\"35WpA5eZTVA6Wo7aw4k1CsyPQWaKrjsCttgsoeedX3X8\"},{\"direction\":\"Left\",\"hash\":\"7Dfb2vHxCahwTCZugK7xWamCwSmRYNogcaKbN63jwzLE\"},{\"direction\":\"Right\",\"hash\":\"DDEAhsCW9dyfhBsviTNRy7mnrg2sH2Nynh9ujbUhn9Uy\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"67682515494078360916120\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"app.nearcrowd.near\",\"signer_public_key\":\"ed25519:6MP4bCPHEud33eKXM9kg7f9fVNhmn97CNUyn5ZwM375U\"}},\"receipt_id\":\"wkEmrrch8JHi6WyZGwLeQLxPia8jAKWFty3BSQKo2mL\",\"receiver_id\":\"app.nearcrowd.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"EGUtwPTotLcKHePRHSnjf9LMsEabpGaedc8s6aphefLU\",\"outcome\":{\"executor_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"ELqyFiTWVun73VTpDseE4ztjAa5ijiDkYBKeS6XptJyP\"},{\"direction\":\"Right\",\"hash\":\"3VD9SLrVM9kXKnyXcpbd7vqFGy5qyPoMnZtKhxzaXUNb\"},{\"direction\":\"Right\",\"hash\":\"hDyE63jjg6jKyB8Wp2enbUJpJVKPBSmVi6TZR5pTbzH\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1387847081208855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\",\"signer_public_key\":\"ed25519:6QcN7PVG1vTXn5D1noy7ySuwp25wNfAjpwMUbew9RAkw\"}},\"receipt_id\":\"EGUtwPTotLcKHePRHSnjf9LMsEabpGaedc8s6aphefLU\",\"receiver_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"7LJHuTJtB1mwCW2d1boxHfrH3yqWEzAL9E5xNacVZ26T\",\"outcome\":{\"executor_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"BYwpVDfbUDpwKZ2JXUWuh54VKkTGDnUEqvwDMytrdy94\"},{\"direction\":\"Right\",\"hash\":\"3VD9SLrVM9kXKnyXcpbd7vqFGy5qyPoMnZtKhxzaXUNb\"},{\"direction\":\"Right\",\"hash\":\"hDyE63jjg6jKyB8Wp2enbUJpJVKPBSmVi6TZR5pTbzH\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3644939925066522787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\",\"signer_public_key\":\"ed25519:C6PoMvWCUZjn5etgoZtV3AL8uAUguxQvi1YXpztSuXZJ\"}},\"receipt_id\":\"7LJHuTJtB1mwCW2d1boxHfrH3yqWEzAL9E5xNacVZ26T\",\"receiver_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"EfrMsmNUQPuuvqSsEcwUf32gwKUPTmLxza5goBcjD9oM\",\"outcome\":{\"executor_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"F3m2WYzXtJEuMncqBuiXQaXSQXCXAgvLokymtcT9BPRa\"},{\"direction\":\"Left\",\"hash\":\"6LqosNhAB2DKAQY2HwrBmWG6bqBR8b72YRgMBhktGAAf\"},{\"direction\":\"Right\",\"hash\":\"hDyE63jjg6jKyB8Wp2enbUJpJVKPBSmVi6TZR5pTbzH\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453947853555455516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\",\"signer_public_key\":\"ed25519:7c4aKGGRKEXPvs6NyV7KVnPPT989ybzad7WyRpvmReC1\"}},\"receipt_id\":\"EfrMsmNUQPuuvqSsEcwUf32gwKUPTmLxza5goBcjD9oM\",\"receiver_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"63uRd5CF4r4nFMyAXt2nxosRgWKwEvY1a3St6UWKnP3B\",\"outcome\":{\"executor_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"AipnxckbYg3kjZPTtQn7pBuULnaL9ich5jXuHZhocUqa\"},{\"direction\":\"Left\",\"hash\":\"6LqosNhAB2DKAQY2HwrBmWG6bqBR8b72YRgMBhktGAAf\"},{\"direction\":\"Right\",\"hash\":\"hDyE63jjg6jKyB8Wp2enbUJpJVKPBSmVi6TZR5pTbzH\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453949828169855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\",\"signer_public_key\":\"ed25519:Gdyiwso3herrNehT3Y2v5ZeRa3LFH2e7ghvrvzuqT7cV\"}},\"receipt_id\":\"63uRd5CF4r4nFMyAXt2nxosRgWKwEvY1a3St6UWKnP3B\",\"receiver_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"EgM2FYLA7MLq1mu2ZEFfJqR2KMcEp9hHTN6itQcRqJS1\",\"outcome\":{\"executor_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"CWWXtdxFs6trzreuoePLtZuN9mFKFUhS8yKtAKddzT9F\"},{\"direction\":\"Right\",\"hash\":\"HkjReC1dpNnUyPEXBDF13UcCzSykrj2UTvZZyH2o8Sc1\"},{\"direction\":\"Left\",\"hash\":\"9biivFU7bgitUxdUB2gA2XA7kAmBKQH8QzZYN9RjXJQm\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453948511760255516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\",\"signer_public_key\":\"ed25519:Et4VVriLX9S6gg4pHMfSdWASY4rk5vyJxufe1HnscEw\"}},\"receipt_id\":\"EgM2FYLA7MLq1mu2ZEFfJqR2KMcEp9hHTN6itQcRqJS1\",\"receiver_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"G36EY7JbD8Fuqdhagc5d7QTX8nJwQbMGXzrnQsKZYzsw\",\"outcome\":{\"executor_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"8CevjeiMYtN7CrbuqQNsZNSoKrqrLDFuAogyQV7R5rDe\"},{\"direction\":\"Right\",\"hash\":\"HkjReC1dpNnUyPEXBDF13UcCzSykrj2UTvZZyH2o8Sc1\"},{\"direction\":\"Left\",\"hash\":\"9biivFU7bgitUxdUB2gA2XA7kAmBKQH8QzZYN9RjXJQm\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3676415604628722787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\",\"signer_public_key\":\"ed25519:AtU6HQQSXW3ZpRzFBx5sdgjCssXL4bFdzPBzVeWgqVqb\"}},\"receipt_id\":\"G36EY7JbD8Fuqdhagc5d7QTX8nJwQbMGXzrnQsKZYzsw\",\"receiver_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"95GSz1TgWKAniZct6ruPsfLsrDhZKJgb5ggRYmMu48x\",\"outcome\":{\"executor_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"8WTWp8MFkuz2Ka5DR7rcGinWTCfA5nY3n5vF2Km9vZy8\"},{\"direction\":\"Left\",\"hash\":\"EDK54wzVnz68TCA3e397oFX98oPzHTttdiHyWjYkmXSG\"},{\"direction\":\"Left\",\"hash\":\"9biivFU7bgitUxdUB2gA2XA7kAmBKQH8QzZYN9RjXJQm\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3674122231792122787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\",\"signer_public_key\":\"ed25519:4sbqB2C9gB2opvbppj2dbqSPYL3KAi7WmumHTdXTV2pe\"}},\"receipt_id\":\"95GSz1TgWKAniZct6ruPsfLsrDhZKJgb5ggRYmMu48x\",\"receiver_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"JU2BBLxYb2JqxDqvW8bWXvXcaUHmJzySJYLayrtTEPw\",\"outcome\":{\"executor_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"EgE8uELbUBBXJ75GuSxgYTXAkPmFKnDdeyA6ry7cpnBD\"},{\"direction\":\"Left\",\"hash\":\"EDK54wzVnz68TCA3e397oFX98oPzHTttdiHyWjYkmXSG\"},{\"direction\":\"Left\",\"hash\":\"9biivFU7bgitUxdUB2gA2XA7kAmBKQH8QzZYN9RjXJQm\"},{\"direction\":\"Left\",\"hash\":\"6UJVKxW7wsTn5Z9DJQ1N1FuGgRHcuZWFgn5cVxLV7WgJ\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3679637641325922787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\",\"signer_public_key\":\"ed25519:67dj1hMYcS9Nywx8SVscss3fuFC8w8D84UknNDdZCJqf\"}},\"receipt_id\":\"JU2BBLxYb2JqxDqvW8bWXvXcaUHmJzySJYLayrtTEPw\",\"receiver_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\"}}],\"shard_id\":0,\"state_changes\":[{\"cause\":{\"receipt_hash\":\"EgM2FYLA7MLq1mu2ZEFfJqR2KMcEp9hHTN6itQcRqJS1\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\",\"amount\":\"39487555560414499999988\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"9PYCn1h6f3UwP2fGoUKLToZRPvUmDTJ3aHhyBrPqEKTd\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"1d6c1c8b24edf29e581613a2b5501d023ab762b55541d731bbd6f1926a857978\",\"amount\":\"90554939608117150993531\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"95GSz1TgWKAniZct6ruPsfLsrDhZKJgb5ggRYmMu48x\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\",\"amount\":\"48193056997992000000000\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"63uRd5CF4r4nFMyAXt2nxosRgWKwEvY1a3St6UWKnP3B\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\",\"amount\":\"38118153165737999999925\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"JU2BBLxYb2JqxDqvW8bWXvXcaUHmJzySJYLayrtTEPw\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\",\"amount\":\"27744945708671399999981\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":264},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"EGUtwPTotLcKHePRHSnjf9LMsEabpGaedc8s6aphefLU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\",\"amount\":\"69878118593702699999951\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"EfrMsmNUQPuuvqSsEcwUf32gwKUPTmLxza5goBcjD9oM\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\",\"amount\":\"58063870523474699999955\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"725pXT1Xa3y3VaeW8oTb66MuVh28bU11YdzhRQSfnbuQ\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"633df47e6fe62de8d6b3db7cb410f85a7b12a957a5e84d49236aa683c962016b\",\"amount\":\"39124549646773544483143\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"4zPqfd2F5DGfADGLLAMK4Ya4atDeXWgWpunRkhaTRdm6\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"7fc1dd34509cf7b0d6692179bb99ab99ae71f224e3e6d119dbc7e40b6a5458d0\",\"amount\":\"42560438434895244483193\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"HVua5uD1PUjoakRF3mVKW5a3qaRzugvAoYgYkVHxcyd\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"89addbfbfc6b34ae6403f39ee2c92280827d80a98dc40d15729824d232be343d\",\"amount\":\"1973088651770369477211934\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"G36EY7JbD8Fuqdhagc5d7QTX8nJwQbMGXzrnQsKZYzsw\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\",\"amount\":\"33419251951148899999990\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"4Fgd5NkSW8KAw4vo6yoa9uWN7evpgkRFxDLw68ZZUdas\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"998aef31da68f8a525d54d3ce3dc8a68adfd9392969b4e1ce1a943a275d667b4\",\"amount\":\"61306954596810168364616\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"7LJHuTJtB1mwCW2d1boxHfrH3yqWEzAL9E5xNacVZ26T\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\",\"amount\":\"48163874691266400000000\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"6c7eBqD46vA51qxUivd6jJBfef2HGy6aB8kM3F4r6aQf\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"amount\":\"3906305571940326122040431880\",\"code_hash\":\"DyHG2t99dBZWiPgX53Z4UbbBQR6JJoxmqXwaKD4hTeyP\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":3655277},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"amount\":\"3906305571940326122040431880\",\"code_hash\":\"DyHG2t99dBZWiPgX53Z4UbbBQR6JJoxmqXwaKD4hTeyP\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":3655370},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"amount\":\"3906305597147696319440431880\",\"code_hash\":\"DyHG2t99dBZWiPgX53Z4UbbBQR6JJoxmqXwaKD4hTeyP\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":3655370},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"wkEmrrch8JHi6WyZGwLeQLxPia8jAKWFty3BSQKo2mL\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"amount\":\"3906373279663190397801348000\",\"code_hash\":\"DyHG2t99dBZWiPgX53Z4UbbBQR6JJoxmqXwaKD4hTeyP\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":3655370},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"9PYCn1h6f3UwP2fGoUKLToZRPvUmDTJ3aHhyBrPqEKTd\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":82709690000066,\"permission\":\"FullAccess\"},\"account_id\":\"1d6c1c8b24edf29e581613a2b5501d023ab762b55541d731bbd6f1926a857978\",\"public_key\":\"ed25519:5hF5RjYCQsW1PAfVbT68gBRHZ7wSy3Zqtz8TeeX4mCaD\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"725pXT1Xa3y3VaeW8oTb66MuVh28bU11YdzhRQSfnbuQ\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":66746200000070,\"permission\":\"FullAccess\"},\"account_id\":\"633df47e6fe62de8d6b3db7cb410f85a7b12a957a5e84d49236aa683c962016b\",\"public_key\":\"ed25519:7gQA1ugkWgJWHzBNqPofUVh3cuXo3Xjx6tQ4BBbhto4E\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"4zPqfd2F5DGfADGLLAMK4Ya4atDeXWgWpunRkhaTRdm6\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":73110403000008,\"permission\":\"FullAccess\"},\"account_id\":\"7fc1dd34509cf7b0d6692179bb99ab99ae71f224e3e6d119dbc7e40b6a5458d0\",\"public_key\":\"ed25519:9biETR76Ar5A9gdcN4M1VCRCYNh95bMkbKUV2wZYv41m\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"HVua5uD1PUjoakRF3mVKW5a3qaRzugvAoYgYkVHxcyd\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":73754297000120,\"permission\":\"FullAccess\"},\"account_id\":\"89addbfbfc6b34ae6403f39ee2c92280827d80a98dc40d15729824d232be343d\",\"public_key\":\"ed25519:AGScmR9rZXuSuKaSZtZYzGZsxKor1NPCfNam6aaFbdMN\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"4Fgd5NkSW8KAw4vo6yoa9uWN7evpgkRFxDLw68ZZUdas\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":86193362000020,\"permission\":\"FullAccess\"},\"account_id\":\"998aef31da68f8a525d54d3ce3dc8a68adfd9392969b4e1ce1a943a275d667b4\",\"public_key\":\"ed25519:Ds2WiuryPoxnHUGgKEoQP89Un3rcACu52az89zv6pFke\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"6c7eBqD46vA51qxUivd6jJBfef2HGy6aB8kM3F4r6aQf\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":43616664839556,\"permission\":\"FullAccess\"},\"account_id\":\"app.nearcrowd.near\",\"public_key\":\"ed25519:aSgLALWzkhfCa5D66V8x8QgP1qU46mWVA2CikGJNYVm\"},\"type\":\"access_key_update\"},{\"cause\":{\"receipt_hash\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"EgAAAGFwcC5uZWFyY3Jvd2QubmVhcg==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"5ZmodVAgA86mwcXsh2nYwyyfzkvFNKdwDkaUJRKzb86N\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"app.nearcrowd.near\",\"key_base64\":\"YRAAAAByYWJvdGFwZXJtMy5uZWFy\",\"value_base64\":\"tBeVsq6CJVfQwGK7vS49qmvmX7tAaOnZhKQSi+M7ZnY=\"},\"type\":\"data_update\"}]},{\"chunk\":{\"author\":\"figment.poolv1.near\",\"header\":{\"balance_burnt\":\"830964127214000000000\",\"chunk_hash\":\"HEvcb6D3ccK3uBa2jvPR1cyJKtizmajSetCtfzDTJuX4\",\"encoded_length\":314,\"encoded_merkle_root\":\"HGcw4GhAFX3miVA8Cd3comzt54JeMwS6xsAGmvPRaGvd\",\"gas_limit\":1000000000000000,\"gas_used\":9789559232514,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"EGNwA73SqFkV2oFR5J5QiPkjqzUx3nBYA2evTTtr1NQV\",\"outgoing_receipts_root\":\"AAUZMgaJxUNLt98ZsjSEhZ7vYu2jQHjujc2HfNT5Bf5R\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"8jtQjg2MMSowY6oF6Shvdc3Z4dhibEk7sR8LiAHUm9GA\",\"rent_paid\":\"0\",\"shard_id\":1,\"signature\":\"ed25519:2SNLCU3NHGuaerJ5jPa275wwtxnnu4DQvBh4ozMvXJZuzgs4EJPCfhb2vesnJ5CrF1RyQc9dfDZBn91FRLRP9Njp\",\"tx_root\":\"11111111111111111111111111111111\",\"validator_proposals\":[],\"validator_reward\":\"0\"},\"receipts\":[{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188376657220304586639852\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"relay.aurora\",\"signer_public_key\":\"ed25519:F2nobX5Ruw6LR5mxErzJ41u6J4p6YHmuPYr5Lq8roXp1\"}},\"receipt_id\":\"6f3TNmYXE8VXotRzhDxajmP3GThEEn56DJMRyUKRFL6\",\"receiver_id\":\"relay.aurora\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188703998464321986639852\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"relay.aurora\",\"signer_public_key\":\"ed25519:ECTjgvJKWrpoCNzC5BGyMAWZcFjqe24n3mMV9ndFcpfy\"}},\"receipt_id\":\"bm7V3pZbt3hbo3dq5NndWdEe89smD7UWBXKqHF8q3MY\",\"receiver_id\":\"relay.aurora\"}],\"transactions\":[]},\"receipt_execution_outcomes\":[],\"shard_id\":1,\"state_changes\":[]},{\"chunk\":{\"author\":\"binancenode1.poolv1.near\",\"header\":{\"balance_burnt\":\"728420795086600000000\",\"chunk_hash\":\"HjHqxNa9rqi4PAuLcrtaM4zuAvLPdaedigT16oUucKmE\",\"encoded_length\":3112,\"encoded_merkle_root\":\"rwG6Cm5h14wnXdeKaFk9WhXRJF8hbi8zXTkEe5vrc15\",\"gas_limit\":1000000000000000,\"gas_used\":32557076638366,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"28VCHwcMJusGdHxdVsT1ApioKXjL4oKDFZtjS8artpej\",\"outgoing_receipts_root\":\"GnMYZchhfax4ZSYKt4EvcgS8vPYDV6P9aWtBTZxUgaBp\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"88eTF9FGBspzrHGuqH327iwSdT9aqvpuMe3ViVkB4Z97\",\"rent_paid\":\"0\",\"shard_id\":2,\"signature\":\"ed25519:5z1AgUsUvmmHW7kZoffsTnFvTzKvtHzFvKpY6UwvJLB6nnbh1k8dHbch3yWkj2urTkgtRRW8F6sJBi8Rcoqe6ZsZ\",\"tx_root\":\"6hq1U2Wu8LyjtKcAH6VDRhwYdjMGaw1evTqSdWfnFjDB\",\"validator_proposals\":[],\"validator_reward\":\"0\"},\"receipts\":[{\"predecessor_id\":\"b5acefe75a5e4b2ddb252d43d3f1b8df457001ba1f589dfb2769470c02a36b9a\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYjVhY2VmZTc1YTVlNGIyZGRiMjUyZDQzZDNmMWI4ZGY0NTcwMDFiYTFmNTg5ZGZiMjc2OTQ3MGMwMmEzNmI5YSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"b5acefe75a5e4b2ddb252d43d3f1b8df457001ba1f589dfb2769470c02a36b9a\",\"signer_public_key\":\"ed25519:3y5fUDm1yY1SK8TRaj7DEMJMLHgh9Fq85AbN1K1ifCZr\"}},\"receipt_id\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"receiver_id\":\"usdt.tether-token.near\"},{\"predecessor_id\":\"e52871e21c00eb1df7d672dc2cd8d0033fbb1ee6babcb84a9165b1d081a293c4\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e52871e21c00eb1df7d672dc2cd8d0033fbb1ee6babcb84a9165b1d081a293c4\",\"signer_public_key\":\"ed25519:GRY8gUPSMduGWDapXpgVu2dvDxqdmtyJAPzPxvEDRUom\"}},\"receipt_id\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"receiver_id\":\"tge-lockup.sweat\"},{\"predecessor_id\":\"ca3615a0d2e244761f8452be382defc99caad8e5e89ef6e72836d2c622ff4c08\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiY2EzNjE1YTBkMmUyNDQ3NjFmODQ1MmJlMzgyZGVmYzk5Y2FhZDhlNWU4OWVmNmU3MjgzNmQyYzYyMmZmNGMwOCJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"ca3615a0d2e244761f8452be382defc99caad8e5e89ef6e72836d2c622ff4c08\",\"signer_public_key\":\"ed25519:EcMBstSN5TXWkvVLQpchNchogUPXQwrN1ehkG7ALshSX\"}},\"receipt_id\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"receiver_id\":\"usdt.tether-token.near\"}],\"transactions\":[{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"HiBtdcgFjGr8Dhzcz2zXKzsyc9v7cLDT2ZxLybyduVgN\",\"outcome\":{\"executor_id\":\"e2a4479e0abd3c275feafc676906652b9cf22095bc26dc3a4814f56e4cc01b62\",\"gas_burnt\":2428135649664,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"FMCxCw3waZhnb1f5WueZXbxuU4fwG8VLjgJHvcfhYmxs\"],\"status\":{\"SuccessReceiptId\":\"FMCxCw3waZhnb1f5WueZXbxuU4fwG8VLjgJHvcfhYmxs\"},\"tokens_burnt\":\"242813564966400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"2Bs2Rcpw5BcKWLKG9xmmWHT6CqLaGLt5jbdjx16hcKyL\"},{\"direction\":\"Right\",\"hash\":\"H1E8teAEF4UR971WTTihFDxJkNHztNqyTR1TwHPJN4m6\"},{\"direction\":\"Right\",\"hash\":\"Bez2jppo61YH72P2mW5SjKgacW3da9UvtvgZLvJQ4W9a\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiZTJhNDQ3OWUwYWJkM2MyNzVmZWFmYzY3NjkwNjY1MmI5Y2YyMjA5NWJjMjZkYzNhNDgxNGY1NmU0Y2MwMWI2MiJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"hash\":\"HiBtdcgFjGr8Dhzcz2zXKzsyc9v7cLDT2ZxLybyduVgN\",\"nonce\":92364842000001,\"public_key\":\"ed25519:GFiRuysw4vnSqhwgjKe3U4WZHLq2uhGa3Gs8yRM78Bgm\",\"receiver_id\":\"usdt.tether-token.near\",\"signature\":\"ed25519:5SepUC9fShDneSAmJnCV92AZRKUK2nu2r4bdwnuZV2Xa4XRZNGbaXxFapJvGUocjyALC3pq7KpLQg6jRkUUXaYeW\",\"signer_id\":\"e2a4479e0abd3c275feafc676906652b9cf22095bc26dc3a4814f56e4cc01b62\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"4JmRYstCvLy6buVi4YuDPSneDSnTFAu7zrjuSTkNKrot\",\"outcome\":{\"executor_id\":\"d6b519b284df72f2ac632984323b4eb96a80e021702848bc0afd8f73396fc903\",\"gas_burnt\":2427936651538,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"215N9jh3rAqLwc4Pons9Df3ZCaDZ2iCAGgLmFCrpHtED\"],\"status\":{\"SuccessReceiptId\":\"215N9jh3rAqLwc4Pons9Df3ZCaDZ2iCAGgLmFCrpHtED\"},\"tokens_burnt\":\"242793665153800000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"CqPhJFL7R9Myqg5Pqy4teN4FbC7UVhs6oFLdZipFfE6J\"},{\"direction\":\"Right\",\"hash\":\"H1E8teAEF4UR971WTTihFDxJkNHztNqyTR1TwHPJN4m6\"},{\"direction\":\"Right\",\"hash\":\"Bez2jppo61YH72P2mW5SjKgacW3da9UvtvgZLvJQ4W9a\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"hash\":\"4JmRYstCvLy6buVi4YuDPSneDSnTFAu7zrjuSTkNKrot\",\"nonce\":73672043000039,\"public_key\":\"ed25519:FT8QyjH4GfZQvbynxqVUaAAMZwzy3pqCBPFXqhR6szJ6\",\"receiver_id\":\"tge-lockup.sweat\",\"signature\":\"ed25519:27SvxqeAghD2b1sN1pHFEcmzsav2SP7kmwNqNhdEhvr7gEEh53ALcTywc99GtYwggQydLEb7yWjNrnjMUmmtTW8e\",\"signer_id\":\"d6b519b284df72f2ac632984323b4eb96a80e021702848bc0afd8f73396fc903\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"DHkBYbjiL84Dc5dmyYtLvk1yS3mVco8HBH2bPy5su7Y5\",\"outcome\":{\"executor_id\":\"ef18bfaf4c0dd0578d8321a90e10942bbfe44b4e381ca9cf8cf25c679f5f1221\",\"gas_burnt\":2428135649664,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"HPCBzuEK1iNw5VJw2aVNDfuaFXX2pn7Gf54MBrTcUQGD\"],\"status\":{\"SuccessReceiptId\":\"HPCBzuEK1iNw5VJw2aVNDfuaFXX2pn7Gf54MBrTcUQGD\"},\"tokens_burnt\":\"242813564966400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"CTCyfeHtu6nAgnwRsPDWcLL9rTXZvrg3bwpGXAPNeiTT\"},{\"direction\":\"Left\",\"hash\":\"9Z37Tmt8fyeLMmxRX19u1VYHafYHCGHiDmiC3UzVLX6E\"},{\"direction\":\"Right\",\"hash\":\"Bez2jppo61YH72P2mW5SjKgacW3da9UvtvgZLvJQ4W9a\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiZWYxOGJmYWY0YzBkZDA1NzhkODMyMWE5MGUxMDk0MmJiZmU0NGI0ZTM4MWNhOWNmOGNmMjVjNjc5ZjVmMTIyMSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"hash\":\"DHkBYbjiL84Dc5dmyYtLvk1yS3mVco8HBH2bPy5su7Y5\",\"nonce\":63871139000097,\"public_key\":\"ed25519:H6LL1PTifVj6sTTUtPGVKVN6QaN1Fy1swVu7tqk11xv4\",\"receiver_id\":\"usdt.tether-token.near\",\"signature\":\"ed25519:2HW7MiP1xcKd7jyJiexyNVN4Hw51PzSsAzmQpQsNw1iRT6mdxKF4hgC2PCVJ7qUKUTR58iaywWZ8ugouh65xmNR\",\"signer_id\":\"ef18bfaf4c0dd0578d8321a90e10942bbfe44b4e381ca9cf8cf25c679f5f1221\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"AFvit7ckbH3uGJtvYXa12AAb9eQCGm8752Xi4du63Dz6\",\"outcome\":{\"executor_id\":\"iorange.near\",\"gas_burnt\":2427992549888,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"62o8pgs23gEV9nzm8HXaL1awHc5u32qq7W9xG77p7KNM\"],\"status\":{\"SuccessReceiptId\":\"62o8pgs23gEV9nzm8HXaL1awHc5u32qq7W9xG77p7KNM\"},\"tokens_burnt\":\"242799254988800000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"9E7YXVXic57VatmqJHPzSu4N19bzxSDaU35D7QM9xnkT\"},{\"direction\":\"Left\",\"hash\":\"9Z37Tmt8fyeLMmxRX19u1VYHafYHCGHiDmiC3UzVLX6E\"},{\"direction\":\"Right\",\"hash\":\"Bez2jppo61YH72P2mW5SjKgacW3da9UvtvgZLvJQ4W9a\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJuZXdfdGFza19vcmQiOjF9\",\"deposit\":\"0\",\"gas\":30000000000000,\"method_name\":\"change_taskset\"}}],\"hash\":\"AFvit7ckbH3uGJtvYXa12AAb9eQCGm8752Xi4du63Dz6\",\"nonce\":91395695002427,\"public_key\":\"ed25519:6RrJuhH5xkdYJVQPEPWoRWjYhRSyATQ8bk89D8X3Q2gB\",\"receiver_id\":\"app.nearcrowd.near\",\"signature\":\"ed25519:2kiBC8mNBRSzHvWbvGgyK4eaRYWZiY4FwrY8gvH7AeDUhGXBia4mPiu2gNKkgURufM3puJaVjGaKW7GRPKrwb1rb\",\"signer_id\":\"iorange.near\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"HVywQx2CGR2uv5DEbay4QJyHuP4xLgtNsh5ZVrCAsVju\",\"outcome\":{\"executor_id\":\"c49e13a65bee574b944d7d5d4fd69fb74314dff7b75254bdd0806eedb9277dcf\",\"gas_burnt\":2428135649664,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"Bo1JTY4ZRp3wX9mJr1fNYyzYE2eeikxBP4k2x1HwgKRy\"],\"status\":{\"SuccessReceiptId\":\"Bo1JTY4ZRp3wX9mJr1fNYyzYE2eeikxBP4k2x1HwgKRy\"},\"tokens_burnt\":\"242813564966400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"FqDhNjv27TVLYoPrdZAGYUM7XJ5dUyoowAx6goYZy4F2\"},{\"direction\":\"Right\",\"hash\":\"D8TWTXSwttZtoAPSSWSYsQ8soDaBJ1BLVG8VSeUmhScr\"},{\"direction\":\"Left\",\"hash\":\"BoHGsztE67nUJUDnXSG5p8NwWHrsKzUhAJUEYDa1Wk86\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYzQ5ZTEzYTY1YmVlNTc0Yjk0NGQ3ZDVkNGZkNjlmYjc0MzE0ZGZmN2I3NTI1NGJkZDA4MDZlZWRiOTI3N2RjZiJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"hash\":\"HVywQx2CGR2uv5DEbay4QJyHuP4xLgtNsh5ZVrCAsVju\",\"nonce\":92376352000001,\"public_key\":\"ed25519:EEWiLLuYq41bMgyWxsDsHz3UHWPrhoMUhPfmFyMeetES\",\"receiver_id\":\"usdt.tether-token.near\",\"signature\":\"ed25519:2V9ptBnpqoA3U42dY18DmYGPYuPYiiMqqqLmwxFRRzFBzeTK12S7GNYqYAxXihWpay6K11eerVGg3riyv2fz5N77\",\"signer_id\":\"c49e13a65bee574b944d7d5d4fd69fb74314dff7b75254bdd0806eedb9277dcf\"}},{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"6b72yL4bRL3CREdxRKRPCPCD41zNzFCURfByi3b1GVuZ\",\"outcome\":{\"executor_id\":\"b864da0e88a03cd2e1d533bdca9335a70ed206eff93666ba1773a38987e443c9\",\"gas_burnt\":2428314524384,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"Ch3bcjnGdqwhKUc7VVnKiyMtqWwvEVsWYvh6xF8pLHHQ\"],\"status\":{\"SuccessReceiptId\":\"Ch3bcjnGdqwhKUc7VVnKiyMtqWwvEVsWYvh6xF8pLHHQ\"},\"tokens_burnt\":\"242831452438400000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"FGGqzwNpjacAZKsNUEsxXRKkKXq4dT7M8o2pDXTJogLH\"},{\"direction\":\"Right\",\"hash\":\"D8TWTXSwttZtoAPSSWSYsQ8soDaBJ1BLVG8VSeUmhScr\"},{\"direction\":\"Left\",\"hash\":\"BoHGsztE67nUJUDnXSG5p8NwWHrsKzUhAJUEYDa1Wk86\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOko5ZGp6cVlYblktYjg2NGRhMGU4OGEwM2NkMmUxZDUzM2JkY2E5MzM1YTcwZWQyMDZlZmY5MzY2NmJhMTc3M2EzODk4N2U0NDNjOSJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"hash\":\"6b72yL4bRL3CREdxRKRPCPCD41zNzFCURfByi3b1GVuZ\",\"nonce\":63942231000084,\"public_key\":\"ed25519:DQoDCAvazAK9wqBkgtnrxAofiDy9KHr5Z5tMjiwaLtoi\",\"receiver_id\":\"token.sweat\",\"signature\":\"ed25519:4gcsxUzf11Gaskt6z4xPQAwue65sj991tkDru3GwKSqw7VVXbmFZmPWzyqtLfacWEReYHrzwtkVuGZ1VVruG8o8v\",\"signer_id\":\"b864da0e88a03cd2e1d533bdca9335a70ed206eff93666ba1773a38987e443c9\"}}]},\"receipt_execution_outcomes\":[{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"outcome\":{\"executor_id\":\"embr.playember_reserve.near\",\"gas_burnt\":3834744708490,\"logs\":[\"Registering existing Account @AccountId(\\\\\\\"3d50d495-a.embr.playember_reserve.near\\\\\\\")\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4501057887\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"454267901250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1069102071\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"95760000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18269042400\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1151803899\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"10068660744\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"23359194\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"54039896625\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1293215490\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"622821555\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3565021077\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3383177616\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3939354453\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"466956721854\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3111779061\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"23618018799\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"42170358780\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"14018974305\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"689114316\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"14327612430\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1322944272\"}],\"version\":3},\"receipt_ids\":[\"2F2oSF2THosqKG9KQnnzNBtQyRC3YkZAKSB16bKrCRH8\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"383474470849000000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"4YKnst42B2MqW97LvmTDvvDmFwzGiAaamjpJ1ZhKiuzd\"},{\"direction\":\"Left\",\"hash\":\"Azs36BgwrSD4zvNbGX2yGNSb6AA66LzhYp2UhdYVbFS5\"},{\"direction\":\"Left\",\"hash\":\"BoHGsztE67nUJUDnXSG5p8NwWHrsKzUhAJUEYDa1Wk86\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":{\"predecessor_id\":\"3d50d495-a.embr.playember_reserve.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhcGlfaWQiOiJteXRlc3RhcGkuZW1ici5wbGF5ZW1iZXJfcmVzZXJ2ZS5uZWFyIn0=\",\"deposit\":\"0\",\"gas\":30000000000000,\"method_name\":\"register_account_as_player\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"3d50d495-a.embr.playember_reserve.near\",\"signer_public_key\":\"ed25519:BLepEWpZwFvZSjT8XARNKbZZ9qYcjBLzsQUNoRJjxAF9\"}},\"receipt_id\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"receiver_id\":\"embr.playember_reserve.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"BDqp8fioCtqie4jtZnsHf2dVFAyGURNoFnba463s4tdt\",\"outcome\":{\"executor_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"GrvaJGduwotHMVs5mo2v2n93n6fWaVHoKgcjA5KQaKr4\"},{\"direction\":\"Left\",\"hash\":\"Azs36BgwrSD4zvNbGX2yGNSb6AA66LzhYp2UhdYVbFS5\"},{\"direction\":\"Left\",\"hash\":\"BoHGsztE67nUJUDnXSG5p8NwWHrsKzUhAJUEYDa1Wk86\"},{\"direction\":\"Right\",\"hash\":\"7oMEED6TMfCbuuULc3Ew22bUT3g64WVJwCyjD5CssBgp\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13211855362853269146864\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"signer_public_key\":\"ed25519:G6BmWT85Uu4At6rPxkma6ERZGFQd5opn8JunAzTu8UMA\"}},\"receipt_id\":\"BDqp8fioCtqie4jtZnsHf2dVFAyGURNoFnba463s4tdt\",\"receiver_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"9YMjqYMCcfeVmWRbnt9QanAfj5ttTnT1VryMRga1CzZU\",\"outcome\":{\"executor_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"BfQ6Y61H1zfGaFC1VqXz5AufmXKSbWGmtXkdnMrApJsv\"},{\"direction\":\"Right\",\"hash\":\"e9RXBLQ6psQu7XqoQMyThhUPfnyAo9z3inunTKVyGwy\"},{\"direction\":\"Left\",\"hash\":\"4XRdz1yujywjrQW9qCUKUpPJccRhbvnHFskWh9BUQncL\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3677797800221322787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\",\"signer_public_key\":\"ed25519:F1rrgG8yisGFTCLKuVUTeKAeXxHn1fQN6FyBw2HgobZo\"}},\"receipt_id\":\"9YMjqYMCcfeVmWRbnt9QanAfj5ttTnT1VryMRga1CzZU\",\"receiver_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"7VzREkbKrh789KUmK9Uu23ubNBtmLfYzjRHNCPn8JaqT\",\"outcome\":{\"executor_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"CHKhVpawseJCYYkEh8R2hzvsa9cTRSLpR42HgqMqZKb\"},{\"direction\":\"Right\",\"hash\":\"e9RXBLQ6psQu7XqoQMyThhUPfnyAo9z3inunTKVyGwy\"},{\"direction\":\"Left\",\"hash\":\"4XRdz1yujywjrQW9qCUKUpPJccRhbvnHFskWh9BUQncL\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1455789998376855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\",\"signer_public_key\":\"ed25519:GXL3DidCeD3TThExQZ5RLDHtgHd6qJhH1pZ4XJvafEwo\"}},\"receipt_id\":\"7VzREkbKrh789KUmK9Uu23ubNBtmLfYzjRHNCPn8JaqT\",\"receiver_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"9M3DkQGf3rLEtx8d4tBrSpQEiA3XZBLZAav4xZNxMnKi\",\"outcome\":{\"executor_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\",\"gas_burnt\":4174947687500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"AxCNwPS43jjcEeseKdgekn9RBRear5j3aR3suexYxwNf\"},{\"direction\":\"Left\",\"hash\":\"4XRdz1yujywjrQW9qCUKUpPJccRhbvnHFskWh9BUQncL\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3677802736757322787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\",\"signer_public_key\":\"ed25519:7ufz9DV3Z2wFcyag1U3LztRtvvd5tfLHon2TNHjXPQif\"}},\"receipt_id\":\"9M3DkQGf3rLEtx8d4tBrSpQEiA3XZBLZAav4xZNxMnKi\",\"receiver_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\"}}],\"shard_id\":2,\"state_changes\":[{\"cause\":{\"tx_hash\":\"6b72yL4bRL3CREdxRKRPCPCD41zNzFCURfByi3b1GVuZ\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"b864da0e88a03cd2e1d533bdca9335a70ed206eff93666ba1773a38987e443c9\",\"amount\":\"31081520545391144483135\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9M3DkQGf3rLEtx8d4tBrSpQEiA3XZBLZAav4xZNxMnKi\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\",\"amount\":\"44632323927606599999997\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"HVywQx2CGR2uv5DEbay4QJyHuP4xLgtNsh5ZVrCAsVju\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"c49e13a65bee574b944d7d5d4fd69fb74314dff7b75254bdd0806eedb9277dcf\",\"amount\":\"44518934766199877212032\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9YMjqYMCcfeVmWRbnt9QanAfj5ttTnT1VryMRga1CzZU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\",\"amount\":\"54495011390494499999994\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"4JmRYstCvLy6buVi4YuDPSneDSnTFAu7zrjuSTkNKrot\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"d6b519b284df72f2ac632984323b4eb96a80e021702848bc0afd8f73396fc903\",\"amount\":\"38998708633258850993574\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"BDqp8fioCtqie4jtZnsHf2dVFAyGURNoFnba463s4tdt\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"amount\":\"1777027078396319415447193\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"HiBtdcgFjGr8Dhzcz2zXKzsyc9v7cLDT2ZxLybyduVgN\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"e2a4479e0abd3c275feafc676906652b9cf22095bc26dc3a4814f56e4cc01b62\",\"amount\":\"44518934766199877212032\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"7VzREkbKrh789KUmK9Uu23ubNBtmLfYzjRHNCPn8JaqT\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\",\"amount\":\"41722487016619799999995\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"DHkBYbjiL84Dc5dmyYtLvk1yS3mVco8HBH2bPy5su7Y5\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"ef18bfaf4c0dd0578d8321a90e10942bbfe44b4e381ca9cf8cf25c679f5f1221\",\"amount\":\"66439411269296377211948\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"embr.playember_reserve.near\",\"amount\":\"932786899124499425661976983\",\"code_hash\":\"ArmoZroKpV3XEfBaz4JpUL2wMXFsJDupQmz4UHFnkL6J\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":27959187},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"embr.playember_reserve.near\",\"amount\":\"932786941324112750761976983\",\"code_hash\":\"ArmoZroKpV3XEfBaz4JpUL2wMXFsJDupQmz4UHFnkL6J\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":27959187},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"AFvit7ckbH3uGJtvYXa12AAb9eQCGm8752Xi4du63Dz6\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"iorange.near\",\"amount\":\"11784962720167065821887231\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":881},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"6b72yL4bRL3CREdxRKRPCPCD41zNzFCURfByi3b1GVuZ\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":63942231000084,\"permission\":\"FullAccess\"},\"account_id\":\"b864da0e88a03cd2e1d533bdca9335a70ed206eff93666ba1773a38987e443c9\",\"public_key\":\"ed25519:DQoDCAvazAK9wqBkgtnrxAofiDy9KHr5Z5tMjiwaLtoi\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"HVywQx2CGR2uv5DEbay4QJyHuP4xLgtNsh5ZVrCAsVju\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":92376352000001,\"permission\":\"FullAccess\"},\"account_id\":\"c49e13a65bee574b944d7d5d4fd69fb74314dff7b75254bdd0806eedb9277dcf\",\"public_key\":\"ed25519:EEWiLLuYq41bMgyWxsDsHz3UHWPrhoMUhPfmFyMeetES\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"4JmRYstCvLy6buVi4YuDPSneDSnTFAu7zrjuSTkNKrot\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":73672043000039,\"permission\":\"FullAccess\"},\"account_id\":\"d6b519b284df72f2ac632984323b4eb96a80e021702848bc0afd8f73396fc903\",\"public_key\":\"ed25519:FT8QyjH4GfZQvbynxqVUaAAMZwzy3pqCBPFXqhR6szJ6\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"HiBtdcgFjGr8Dhzcz2zXKzsyc9v7cLDT2ZxLybyduVgN\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":92364842000001,\"permission\":\"FullAccess\"},\"account_id\":\"e2a4479e0abd3c275feafc676906652b9cf22095bc26dc3a4814f56e4cc01b62\",\"public_key\":\"ed25519:GFiRuysw4vnSqhwgjKe3U4WZHLq2uhGa3Gs8yRM78Bgm\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"DHkBYbjiL84Dc5dmyYtLvk1yS3mVco8HBH2bPy5su7Y5\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":63871139000097,\"permission\":\"FullAccess\"},\"account_id\":\"ef18bfaf4c0dd0578d8321a90e10942bbfe44b4e381ca9cf8cf25c679f5f1221\",\"public_key\":\"ed25519:H6LL1PTifVj6sTTUtPGVKVN6QaN1Fy1swVu7tqk11xv4\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"AFvit7ckbH3uGJtvYXa12AAb9eQCGm8752Xi4du63Dz6\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":91395695002427,\"permission\":{\"FunctionCall\":{\"allowance\":\"277031005033055107737344\",\"method_names\":[],\"receiver_id\":\"app.nearcrowd.near\"}}},\"account_id\":\"iorange.near\",\"public_key\":\"ed25519:6RrJuhH5xkdYJVQPEPWoRWjYhRSyATQ8bk89D8X3Q2gB\"},\"type\":\"access_key_update\"},{\"cause\":{\"receipt_hash\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"embr.playember_reserve.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"AQAAAGEA4fUFAAAAAAAAAAAAAAAAfQAAAAAAAAABAAAAbRYAAABwbGF5ZW1iZXJfcmVzZXJ2ZS5uZWFyAQAAAG8BAAAAZwEAAABjGwAAAGVtYnIucGxheWVtYmVyX3Jlc2VydmUubmVhcgEAAABw\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"9C6nmXFWSGEUjxvFfW43qfEv5zWpnbju4AyuR63dVP9a\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"embr.playember_reserve.near\",\"key_base64\":\"YyYAAAAzZDUwZDQ5NS1hLmVtYnIucGxheWVtYmVyX3Jlc2VydmUubmVhcg==\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"}]},{\"chunk\":{\"author\":\"dqw9k3e4422cxt92masmy.poolv1.near\",\"header\":{\"balance_burnt\":\"4431194740007700000000\",\"chunk_hash\":\"FGrEj1N5jaPWQv3Mwk9k46ueeLbhbJoovLB541E8dQ7T\",\"encoded_length\":4150,\"encoded_merkle_root\":\"B17LQpVRJpA6rBEan5GE5t7hE6VTEUZGXk1weNopMhVo\",\"gas_limit\":1000000000000000,\"gas_used\":47693094182334,\"height_created\":92764782,\"height_included\":92764782,\"outcome_root\":\"6vwLNVugzL1qsNJQbKFgbZHWWhyXNHCzDmSoFgpMqM5o\",\"outgoing_receipts_root\":\"Gh239kg5WpGJvWhgyV7dUa9h9ZTWdrc61SRiwkmUzxrT\",\"prev_block_hash\":\"3eB4b25NLhCE4eSa5UsQNeSZxd1qpG46wDCMBZTuWdhp\",\"prev_state_root\":\"CtbeSZLSj7agT6Br5hPU3azbfEyns9bf3sGZKNwbLCR5\",\"rent_paid\":\"0\",\"shard_id\":3,\"signature\":\"ed25519:3K6h2mYkjbLzrz4B9UkzydVfVjHNrdBSY4vaoyLEX71w1KZUQQUFuPG8ZTXym2HJCxgRSRVZo6LBgtJUWqv3FPmC\",\"tx_root\":\"BdrjJVKTui5UgFNxCW1Yze6t1obLssHR3yevdk59TzmU\",\"validator_proposals\":[],\"validator_reward\":\"0\"},\"receipts\":[{\"predecessor_id\":\"papaya.recurforever.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJ0byI6IjQyMDZjNDE0ZjE0ZTNmMzhkMjQ1ZTcyOWY3ZTYwNzY3ZTQ0ZDA3Mjg2ZjAwYjUyMGU1ZjA0YmJkZjZmMzExZWEiLCJ0b2tlbl9pZCI6IjM2NDA1NiIsInJveWFsdHlfcGVyY2VudCI6MTAwMH0=\",\"deposit\":\"5000000000000000000000\",\"gas\":100000000000000,\"method_name\":\"mint\"}}],\"gas_price\":\"180611124\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"papaya.recurforever.near\",\"signer_public_key\":\"secp256k1:icvWegs3SdDR5Hgvxg9HJX1m2SWbrVTfECFx6AT7z3vZn7QANnDieH6sLunNcR4T7XmcfkwMFxLnFtC2k5C41Bn\"}},\"receipt_id\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"receiver_id\":\"papaya.recurforever.near\"},{\"predecessor_id\":\"learn.sweat\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6ImUwNWNmMmQzMDM2NDVkYTE0ZjcxOGVjYWZiNTYxYzdiNzkwMmE0YjBmYjdkMGI5MzliYzIzNmYxMDQ3OTBhMjUiLCJhbW91bnQiOiIxMDAwMDAwIiwibWVtbyI6InN3OnRyOm13V1IyeG1XNnEifQ==\",\"deposit\":\"1\",\"gas\":30000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"learn.sweat\",\"signer_public_key\":\"ed25519:9wRicBBHSqTtPzooqYTmhijZcQXonJM7FjQxvh6cfKzo\"}},\"receipt_id\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"receiver_id\":\"usdt.tether-token.near\"},{\"predecessor_id\":\"watcher02.ref-watchdog.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJ0b2tlbl9pZCI6Im1ldGEtcG9vbC5uZWFyIn0=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"update_token_rate\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"watcher02.ref-watchdog.near\",\"signer_public_key\":\"ed25519:3g2J3UmwRdmo9scukmM6A9qQzKbu7pCPFaQPU9pngMce\"}},\"receipt_id\":\"6B1ZnWtTQPLyYmhWcZ4rQ5iFpt6NjLtRWPa9CyqBjeYH\",\"receiver_id\":\"v2.ref-finance.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1387847081208855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\",\"signer_public_key\":\"ed25519:6QcN7PVG1vTXn5D1noy7ySuwp25wNfAjpwMUbew9RAkw\"}},\"receipt_id\":\"EGUtwPTotLcKHePRHSnjf9LMsEabpGaedc8s6aphefLU\",\"receiver_id\":\"5056c7872cfc439db2ea265d4c4a71bc77a3a7c3286ec2defbce052f80f18b78\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3644939925066522787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\",\"signer_public_key\":\"ed25519:C6PoMvWCUZjn5etgoZtV3AL8uAUguxQvi1YXpztSuXZJ\"}},\"receipt_id\":\"7LJHuTJtB1mwCW2d1boxHfrH3yqWEzAL9E5xNacVZ26T\",\"receiver_id\":\"a4d23d50a736298dc642a3ee1d573a652fabf348741af1506b1f7da70d7444d9\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453947853555455516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\",\"signer_public_key\":\"ed25519:7c4aKGGRKEXPvs6NyV7KVnPPT989ybzad7WyRpvmReC1\"}},\"receipt_id\":\"EfrMsmNUQPuuvqSsEcwUf32gwKUPTmLxza5goBcjD9oM\",\"receiver_id\":\"62217dd0183ad47712dfb16db9000fd8d0ecc8d6993cd02e2c5f34353086e912\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453949828169855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\",\"signer_public_key\":\"ed25519:Gdyiwso3herrNehT3Y2v5ZeRa3LFH2e7ghvrvzuqT7cV\"}},\"receipt_id\":\"63uRd5CF4r4nFMyAXt2nxosRgWKwEvY1a3St6UWKnP3B\",\"receiver_id\":\"3b85021542769d2cf82b2eb5b9cebcd509a1e4722ea67ae36c868d8e93ef12e4\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1453948511760255516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\",\"signer_public_key\":\"ed25519:Et4VVriLX9S6gg4pHMfSdWASY4rk5vyJxufe1HnscEw\"}},\"receipt_id\":\"EgM2FYLA7MLq1mu2ZEFfJqR2KMcEp9hHTN6itQcRqJS1\",\"receiver_id\":\"038e48d2b37cf304b256bdec10afae201247ba7496cfa969409a75e4504cc734\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3676415604628722787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\",\"signer_public_key\":\"ed25519:AtU6HQQSXW3ZpRzFBx5sdgjCssXL4bFdzPBzVeWgqVqb\"}},\"receipt_id\":\"G36EY7JbD8Fuqdhagc5d7QTX8nJwQbMGXzrnQsKZYzsw\",\"receiver_id\":\"92e86f8284c5604e4445608a071705ad2445a140df75bdae23ed94de2ab49d42\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3674122231792122787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\",\"signer_public_key\":\"ed25519:4sbqB2C9gB2opvbppj2dbqSPYL3KAi7WmumHTdXTV2pe\"}},\"receipt_id\":\"95GSz1TgWKAniZct6ruPsfLsrDhZKJgb5ggRYmMu48x\",\"receiver_id\":\"39897bf9a78b1d67918ee33c27364b11b480b2b279930b09f0a9c1b926da8aaf\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3679637641325922787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\",\"signer_public_key\":\"ed25519:67dj1hMYcS9Nywx8SVscss3fuFC8w8D84UknNDdZCJqf\"}},\"receipt_id\":\"JU2BBLxYb2JqxDqvW8bWXvXcaUHmJzySJYLayrtTEPw\",\"receiver_id\":\"4bfd719f2f327fb9b743925e92f10e3578efa6b25f9144f5cc0776a394b5dd22\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3677797800221322787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\",\"signer_public_key\":\"ed25519:F1rrgG8yisGFTCLKuVUTeKAeXxHn1fQN6FyBw2HgobZo\"}},\"receipt_id\":\"9YMjqYMCcfeVmWRbnt9QanAfj5ttTnT1VryMRga1CzZU\",\"receiver_id\":\"d03bfd6987d885750d832e1160b64ff84199213ab10ffe555bb0dcc699c27816\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"1455789998376855516800\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\",\"signer_public_key\":\"ed25519:GXL3DidCeD3TThExQZ5RLDHtgHd6qJhH1pZ4XJvafEwo\"}},\"receipt_id\":\"7VzREkbKrh789KUmK9Uu23ubNBtmLfYzjRHNCPn8JaqT\",\"receiver_id\":\"e6a4413a9a3073fddd20d9ff597bfb633bc5a19ca77d8fc645d3c2f659ca469e\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"3677802736757322787968\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\",\"signer_public_key\":\"ed25519:7ufz9DV3Z2wFcyag1U3LztRtvvd5tfLHon2TNHjXPQif\"}},\"receipt_id\":\"9M3DkQGf3rLEtx8d4tBrSpQEiA3XZBLZAav4xZNxMnKi\",\"receiver_id\":\"bd3040965be489fd80ed8d58950eeb5f8baf48f709d4cca475eee598031baf59\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"69757213628944665882360\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"operator.meta-pool.near\",\"signer_public_key\":\"ed25519:3hpXGXHhxxq4C3KFWYcSApTLPhgerNLcU2NgCB3WGz5M\"}},\"receipt_id\":\"Cu26A2ouAPUXSxi6yofGNJ5henyxHyYShtLr8BFnX1DD\",\"receiver_id\":\"operator.meta-pool.near\"},{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188712065628723398213284\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"stader-epoch-runner.near\",\"signer_public_key\":\"ed25519:AVv8KsWqKd8acYPVdbCnrXAZ2FB2jjxJH1c3djHuW2JD\"}},\"receipt_id\":\"CZAqWPwfgBrykmfZPZoLMJMxg4FsGFNLvapr3qXNeBWV\",\"receiver_id\":\"stader-epoch-runner.near\"}],\"transactions\":[{\"outcome\":{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"CWhKBgYmHHR5woSixizwqThvF9NgE7kRdBQzVuf429qw\",\"outcome\":{\"executor_id\":\"papaya.recurforever.near\",\"gas_burnt\":2428189312080,\"logs\":[],\"metadata\":{\"gas_profile\":null,\"version\":1},\"receipt_ids\":[\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\"],\"status\":{\"SuccessReceiptId\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\"},\"tokens_burnt\":\"242818931208000000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"3q1oFDPZYDKTSNH3kaKoU3dR6eVB1KWriTyfK7TEzwTY\"},{\"direction\":\"Right\",\"hash\":\"APb2m5m2AKf6g3drTbXkDdWyUmcG64PavHq6t4gTn32v\"},{\"direction\":\"Right\",\"hash\":\"HZzdU8o8fyvRFqS822KJvx9TbaqU4FVqJVqy7e7grk9J\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":null},\"transaction\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJ0byI6IjQyMDZjNDE0ZjE0ZTNmMzhkMjQ1ZTcyOWY3ZTYwNzY3ZTQ0ZDA3Mjg2ZjAwYjUyMGU1ZjA0YmJkZjZmMzExZWEiLCJ0b2tlbl9pZCI6IjM2NDA1NiIsInJveWFsdHlfcGVyY2VudCI6MTAwMH0=\",\"deposit\":\"5000000000000000000000\",\"gas\":100000000000000,\"method_name\":\"mint\"}}],\"hash\":\"CWhKBgYmHHR5woSixizwqThvF9NgE7kRdBQzVuf429qw\",\"nonce\":88017794000106,\"public_key\":\"secp256k1:icvWegs3SdDR5Hgvxg9HJX1m2SWbrVTfECFx6AT7z3vZn7QANnDieH6sLunNcR4T7XmcfkwMFxLnFtC2k5C41Bn\",\"receiver_id\":\"papaya.recurforever.near\",\"signature\":\"secp256k1:JTWxtgUbpEA9NkDigFJ8euThD7nZbxfqrcmp32QR8c2yAZnvpLJS3ezwxQawFA287GGwEKqchjqyC5j4KTPjTvzwR\",\"signer_id\":\"papaya.recurforever.near\"}}]},\"receipt_execution_outcomes\":[{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"outcome\":{\"executor_id\":\"papaya.recurforever.near\",\"gas_burnt\":32672866473111,\"logs\":[\"EVENT_JSON:{\\\\\\\"standard\\\\\\\":\\\\\\\"nep171\\\\\\\",\\\\\\\"version\\\\\\\":\\\\\\\"1.0.0\\\\\\\",\\\\\\\"event\\\\\\\":\\\\\\\"nft_mint\\\\\\\",\\\\\\\"data\\\\\\\":[{\\\\\\\"owner_id\\\\\\\":\\\\\\\"4206c414f14e3f38d245e729f7e60767e44d07286f00b520e5f04bbdf6f311ea\\\\\\\",\\\\\\\"token_ids\\\\\\\":[\\\\\\\"364056\\\\\\\"],\\\\\\\"royalty_percent\\\\\\\":{\\\\\\\"364056\\\\\\\":\\\\\\\"1000\\\\\\\"}}]}\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8207811441\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"127377255750\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2864137647\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"433200000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"41757811200\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5671588836\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"15102991116\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"78356790\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"216159586500\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"9545161950\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"169070537250\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2383345041\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3360991995\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"256786944000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"19238266893\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5709112227\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"25031960973\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"515262589632\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3111779061\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"63272963943\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"28270833279084\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"19626564027\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2208979092\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20058657402\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5177730168\"}],\"version\":3},\"receipt_ids\":[\"B7rMKDGzowqLxxDAJtXwNYoYXDTg91hvpCod8UKUMd7A\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"3267286647311100000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"GR9hJghQsZfHdkvEcP5Y1pczWmQjgyKD5DqfxUVUhFYg\"},{\"direction\":\"Right\",\"hash\":\"APb2m5m2AKf6g3drTbXkDdWyUmcG64PavHq6t4gTn32v\"},{\"direction\":\"Right\",\"hash\":\"HZzdU8o8fyvRFqS822KJvx9TbaqU4FVqJVqy7e7grk9J\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"papaya.recurforever.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJ0byI6IjQyMDZjNDE0ZjE0ZTNmMzhkMjQ1ZTcyOWY3ZTYwNzY3ZTQ0ZDA3Mjg2ZjAwYjUyMGU1ZjA0YmJkZjZmMzExZWEiLCJ0b2tlbl9pZCI6IjM2NDA1NiIsInJveWFsdHlfcGVyY2VudCI6MTAwMH0=\",\"deposit\":\"5000000000000000000000\",\"gas\":100000000000000,\"method_name\":\"mint\"}}],\"gas_price\":\"180611124\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"papaya.recurforever.near\",\"signer_public_key\":\"secp256k1:icvWegs3SdDR5Hgvxg9HJX1m2SWbrVTfECFx6AT7z3vZn7QANnDieH6sLunNcR4T7XmcfkwMFxLnFtC2k5C41Bn\"}},\"receipt_id\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"receiver_id\":\"papaya.recurforever.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"6f3TNmYXE8VXotRzhDxajmP3GThEEn56DJMRyUKRFL6\",\"outcome\":{\"executor_id\":\"relay.aurora\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"fTrMsxtTwcNN2LMEq7KtCDVsDbwYY1AfcFdMkgtHXiC\"},{\"direction\":\"Left\",\"hash\":\"C68JmkiFShiDMH1a9WKBvan76HnJYVAFnM9Kxh83r96N\"},{\"direction\":\"Right\",\"hash\":\"HZzdU8o8fyvRFqS822KJvx9TbaqU4FVqJVqy7e7grk9J\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188376657220304586639852\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"relay.aurora\",\"signer_public_key\":\"ed25519:F2nobX5Ruw6LR5mxErzJ41u6J4p6YHmuPYr5Lq8roXp1\"}},\"receipt_id\":\"6f3TNmYXE8VXotRzhDxajmP3GThEEn56DJMRyUKRFL6\",\"receiver_id\":\"relay.aurora\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"bm7V3pZbt3hbo3dq5NndWdEe89smD7UWBXKqHF8q3MY\",\"outcome\":{\"executor_id\":\"relay.aurora\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"HaucqGKNawiCu6FPwqrqcb2F3PXx4UzpbjBVcyjYK7NR\"},{\"direction\":\"Left\",\"hash\":\"C68JmkiFShiDMH1a9WKBvan76HnJYVAFnM9Kxh83r96N\"},{\"direction\":\"Right\",\"hash\":\"HZzdU8o8fyvRFqS822KJvx9TbaqU4FVqJVqy7e7grk9J\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188703998464321986639852\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"relay.aurora\",\"signer_public_key\":\"ed25519:ECTjgvJKWrpoCNzC5BGyMAWZcFjqe24n3mMV9ndFcpfy\"}},\"receipt_id\":\"bm7V3pZbt3hbo3dq5NndWdEe89smD7UWBXKqHF8q3MY\",\"receiver_id\":\"relay.aurora\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"outcome\":{\"executor_id\":\"token.sweat\",\"gas_burnt\":3999515671520,\"logs\":[\"EVENT_JSON:{\\\\\\\"standard\\\\\\\":\\\\\\\"nep141\\\\\\\",\\\\\\\"version\\\\\\\":\\\\\\\"1.0.0\\\\\\\",\\\\\\\"event\\\\\\\":\\\\\\\"ft_transfer\\\\\\\",\\\\\\\"data\\\\\\\":[{\\\\\\\"old_owner_id\\\\\\\":\\\\\\\"6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\\\\\\\",\\\\\\\"new_owner_id\\\\\\\":\\\\\\\"reward-optin.sweat\\\\\\\",\\\\\\\"amount\\\\\\\":\\\\\\\"1000000000000000000\\\\\\\",\\\\\\\"memo\\\\\\\":\\\\\\\"sw:rew:optin:J9djzqYXnY-6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\\\\\\\"}]}\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7413507108\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"44831486250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4355601030\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"287280000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36538084800\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2820589086\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"27688817046\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"48393942\"},{\"cost\":\"SHA256_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18163881000\"},{\"cost\":\"SHA256_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3955245564\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"169070537250\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2259534909\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"572322510\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"192590208000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3275965314\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5145249291\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3163890978\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"531364545558\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3111779061\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"96221558070\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56205753384\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"33645538332\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1380952404\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"34386269832\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2132677404\"}],\"version\":3},\"receipt_ids\":[\"DPbMx82LuY9QYTeGw2JcXaKkqQzH2FXcA8LzAFKLCqUR\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"399951567152000000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"E9n2bHZ1MTNTdGLpJiow7VHw95gyCf6RammEwNRLQ3UC\"},{\"direction\":\"Right\",\"hash\":\"8APBq7Bgt3V3XyTtwCgDaB89Spmms5t5rRNL5Y64KVd1\"},{\"direction\":\"Left\",\"hash\":\"ARNjm5JG8FecnGsFH78aREzs8Vb6vYPSgpqo3CJsh9CZ\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOko5ZGp6cVlYblktNmZhZWZmYTQ4MGE1MDJhMWVjMGZjYjI1YTQyMzdjNGQ1M2VjMWZmZjk0NTVlNjdiODQyY2FmODRjOTI3YTkxNyJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"109272700\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"6faeffa480a502a1ec0fcb25a4237c4d53ec1fff9455e67b842caf84c927a917\",\"signer_public_key\":\"ed25519:4BiExDrNAgX822LmEJLP6mjcADnQfNwoimRNrnuvtmuL\"}},\"receipt_id\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"receiver_id\":\"token.sweat\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3433084527432,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"145920000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20878905600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1493923869\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5034330372\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18825342\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108079793250\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4249136610\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"617210550\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3532903770\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5215732158\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3908335914\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"402548898150\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36422585364\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8411384583\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"563820804\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8596567458\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1144270764\"}],\"version\":3},\"receipt_ids\":[\"6zZJuVeUuxuj1MF8S1Esj6jKndBbzxughUzDoAXnXmmS\"],\"status\":{\"SuccessValue\":\"eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0=\"},\"tokens_burnt\":\"343308452743200000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"EkoQerRU468jeKuXwkzxRTMUL2dNyZizKu5MoShdSVV3\"},{\"direction\":\"Right\",\"hash\":\"8APBq7Bgt3V3XyTtwCgDaB89Spmms5t5rRNL5Y64KVd1\"},{\"direction\":\"Left\",\"hash\":\"ARNjm5JG8FecnGsFH78aREzs8Vb6vYPSgpqo3CJsh9CZ\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"a081b1bb750d7c1e20e2a033e6237cba2f2709b4f7aebd3a3623ca198a7dbd35\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYTA4MWIxYmI3NTBkN2MxZTIwZTJhMDMzZTYyMzdjYmEyZjI3MDliNGY3YWViZDNhMzYyM2NhMTk4YTdkYmQzNSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a081b1bb750d7c1e20e2a033e6237cba2f2709b4f7aebd3a3623ca198a7dbd35\",\"signer_public_key\":\"ed25519:BoYwAfniA8RwSet9fyqaa1o9eCkodzx6vENZs1FasDq6\"}},\"receipt_id\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"outcome\":{\"executor_id\":\"tge-lockup.sweat\",\"gas_burnt\":8545263986541,\"logs\":[\"Claiming 117050908932009518924 form lockup #78957\",\"Total claim 117050908932009518924\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"FUNCTION_CALL_BASE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"4639723000000\"},{\"cost\":\"FUNCTION_CALL_BYTE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"889901732\"},{\"cost\":\"NEW_ACTION_RECEIPT\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"289092464624\"},{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8472579552\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"50686337250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7086626100\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1082300862\"},{\"cost\":\"PROMISE_RETURN\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"560152386\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"123120000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"46977537600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3200722386\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"17620156302\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"44845710\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"169070537250\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2569060239\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1178311050\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6487696014\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"986760138\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6265744878\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"450854765928\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"12447116244\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"31782272211\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"70130898684\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"22430358888\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1282896612\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"22924179888\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1931194512\"}],\"version\":3},\"receipt_ids\":[\"5RUpKZyknLY7YYQGm9KWvDHKHvsDNb6ABtrz7qAi8Cds\",\"79rykPk9g6DWttZeYQqzc4ePEwouLn5QbsX5ys8GhnxK\",\"CxFh99xfh2a3kFLCXatXPmvyod83hdM7VvPqMFCtvZS5\"],\"status\":{\"SuccessReceiptId\":\"79rykPk9g6DWttZeYQqzc4ePEwouLn5QbsX5ys8GhnxK\"},\"tokens_burnt\":\"854526398654100000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"7s4c1zuK9cgwc5Hiwsw7fZjzDHXrzJet4E3mGuVbfFn3\"},{\"direction\":\"Left\",\"hash\":\"7sF8aXeWJKnC6PZudGpfHptSNVbybt2bkYekqmHuBMxL\"},{\"direction\":\"Left\",\"hash\":\"ARNjm5JG8FecnGsFH78aREzs8Vb6vYPSgpqo3CJsh9CZ\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"0182e5d62f1c3d6a4b26b49c934d58a0052e0f9cadf046e22dfa5cff1e92d835\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"0182e5d62f1c3d6a4b26b49c934d58a0052e0f9cadf046e22dfa5cff1e92d835\",\"signer_public_key\":\"ed25519:6uB7bgkaNN1aRVGJ4MtS44jcN5AcBa5UwEodUK3jxfn\"}},\"receipt_id\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"receiver_id\":\"tge-lockup.sweat\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3118327731810,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"104880000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20878905600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1493923869\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5034330372\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18825342\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108079793250\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4249136610\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"617210550\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3532903770\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5215732158\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3908335914\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128815647408\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36439040484\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8411384583\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"563820804\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8596567458\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1144270764\"}],\"version\":3},\"receipt_ids\":[\"9ytgtqFVJhmS1ZcedkUBMM66guh59F3eq4Xjo9JzJ777\"],\"status\":{\"SuccessValue\":\"eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0=\"},\"tokens_burnt\":\"311832773181000000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"7bKza1fcc3MpmuT3Hfx2mmnkc99ZA5aFGmXkinYWwo3n\"},{\"direction\":\"Left\",\"hash\":\"7sF8aXeWJKnC6PZudGpfHptSNVbybt2bkYekqmHuBMxL\"},{\"direction\":\"Left\",\"hash\":\"ARNjm5JG8FecnGsFH78aREzs8Vb6vYPSgpqo3CJsh9CZ\"},{\"direction\":\"Right\",\"hash\":\"C9DMvDZzpN646SVCFWCuz2xzP2pQtGLGV6A2mpwuyaRM\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"64abffbe659f5da752d0821a72d9f0cb660c4bc84e90b1104a4b4065d98a6c75\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiNjRhYmZmYmU2NTlmNWRhNzUyZDA4MjFhNzJkOWYwY2I2NjBjNGJjODRlOTBiMTEwNGE0YjQwNjVkOThhNmM3NSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"64abffbe659f5da752d0821a72d9f0cb660c4bc84e90b1104a4b4065d98a6c75\",\"signer_public_key\":\"ed25519:7mytRQ2oBzrUjXBkcjKUNeum9N6obX3Z3E5GYpgiq5Yp\"}},\"receipt_id\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"outcome\":{\"executor_id\":\"token.sweat\",\"gas_burnt\":3412157981540,\"logs\":[\"EVENT_JSON:{\\\\\\\"standard\\\\\\\":\\\\\\\"nep141\\\\\\\",\\\\\\\"version\\\\\\\":\\\\\\\"1.0.0\\\\\\\",\\\\\\\"event\\\\\\\":\\\\\\\"ft_transfer\\\\\\\",\\\\\\\"data\\\\\\\":[{\\\\\\\"old_owner_id\\\\\\\":\\\\\\\"1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\\\\\\\",\\\\\\\"new_owner_id\\\\\\\":\\\\\\\"reward-optin.sweat\\\\\\\",\\\\\\\"amount\\\\\\\":\\\\\\\"1000000000000000000\\\\\\\",\\\\\\\"memo\\\\\\\":\\\\\\\"sw:rew:optin:J9djzqYXnY-1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\\\\\\\"}]}\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7413507108\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"44831486250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4355601030\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"118560000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36538084800\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2820589086\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"27688817046\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"48393942\"},{\"cost\":\"SHA256_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18163881000\"},{\"cost\":\"SHA256_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3955245564\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"169070537250\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2259534909\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"572322510\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"192590208000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3275965314\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5145249291\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3163890978\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"112713691482\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3111779061\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"96221558070\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56218917480\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"33645538332\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1380952404\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"34386269832\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2132677404\"}],\"version\":3},\"receipt_ids\":[\"BDJHv84oMe8gCuNEfRWBKfTqfrbwvXomqAsQtUkbTjGa\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"341215798154000000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"G6HUgG9ykWjXvX1CbJE73st2AxpBc29qwZModqTAojrR\"},{\"direction\":\"Right\",\"hash\":\"74VZPjX17DSwsKm4B49KdLYNPcSbQZNNLNwzqWemKfpa\"},{\"direction\":\"Right\",\"hash\":\"9kwjECYJQyMcjc6CvM145Xxy12BeXLkPtunNGKeMtbCk\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6InJld2FyZC1vcHRpbi5zd2VhdCIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAiLCJtZW1vIjoic3c6cmV3Om9wdGluOko5ZGp6cVlYblktMWQxM2Q0NjNiNjdkM2E2Nzk0ZjVhMDU2YzRkNmE5ZTZhZWE5MGI3NmQwZjBjZWQ1MTJjYjE3OWM4MWJhMDhmNyJ9\",\"deposit\":\"1\",\"gas\":14000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"109272700\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"1d13d463b67d3a6794f5a056c4d6a9e6aea90b76d0f0ced512cb179c81ba08f7\",\"signer_public_key\":\"ed25519:2xWMvK1meQnUGoaxNs1ZDVeerCcq3kufNQnwz398d3jU\"}},\"receipt_id\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"receiver_id\":\"token.sweat\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3095235592398,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"114000000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20878905600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1493923869\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5034330372\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18825342\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108079793250\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4249136610\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"617210550\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3532903770\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5215732158\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3908335914\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"96611735556\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36430812924\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8411384583\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"563820804\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8596567458\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1144270764\"}],\"version\":3},\"receipt_ids\":[\"BPfaXbaZFDRRTv9goDHfsnH8V5hANe9UqaFauqqrQLnt\"],\"status\":{\"SuccessValue\":\"eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0=\"},\"tokens_burnt\":\"309523559239800000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"8TqstA3pYhukrnnbbYGegaNwLdJSwQgqNwfe1LXHoKsr\"},{\"direction\":\"Right\",\"hash\":\"74VZPjX17DSwsKm4B49KdLYNPcSbQZNNLNwzqWemKfpa\"},{\"direction\":\"Right\",\"hash\":\"9kwjECYJQyMcjc6CvM145Xxy12BeXLkPtunNGKeMtbCk\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"a3e1f5b1724f18cba5cf35ad3d20037feaf7e7c5709e8838b83759d7504b0bcc\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYTNlMWY1YjE3MjRmMThjYmE1Y2YzNWFkM2QyMDAzN2ZlYWY3ZTdjNTcwOWU4ODM4YjgzNzU5ZDc1MDRiMGJjYyJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"a3e1f5b1724f18cba5cf35ad3d20037feaf7e7c5709e8838b83759d7504b0bcc\",\"signer_public_key\":\"ed25519:C2jJ6HMnY24Srb58aivEoy5DKkxBsXffp29ZcMpBxHZu\"}},\"receipt_id\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"outcome\":{\"executor_id\":\"mos.mfac.butternetwork.near\",\"gas_burnt\":4393831001662,\"logs\":[\"transfer out: {\\\\\\\"from_chain\\\\\\\":\\\\\\\"1360100178526209\\\\\\\",\\\\\\\"to_chain\\\\\\\":\\\\\\\"22776\\\\\\\",\\\\\\\"order_id\\\\\\\":\\\\\\\"0x80ca3f9550bb152087161001c7228f5213270dc82111a6112e431efdab6e29de\\\\\\\",\\\\\\\"token\\\\\\\":[97,48,98,56,54,57,57,49,99,54,50,49,56,98,51,54,99,49,100,49,57,100,52,97,50,101,57,101,98,48,99,101,51,54,48,54,101,98,52,56,46,102,97,99,116,111,114,121,46,98,114,105,100,103,101,46,110,101,97,114],\\\\\\\"from\\\\\\\":[101,48,51,51,54,49,102,53,54,53,50,55,98,50,55,57,50,53,51,51,52,50,53,48,57,57,51,102,100,99,98,56,54,54,50,51,101,57,48,56,50,53,52,98,56,102,56,97,101,100,56,97,101,48,51,55,102,102,50,101,49,98,98,53],\\\\\\\"to\\\\\\\":[7,87,191,155,20,136,69,51,164,179,232,159,216,216,120,245,72,207,204,78],\\\\\\\"amount\\\\\\\":\\\\\\\"47059496\\\\\\\",\\\\\\\"to_chain_token\\\\\\\":[]}\",\"2ef1cdf83614a69568ed2c96a275dd7fb2e63a464aa3a0ffe79f55d538c8b3b5f8c78704d501000000018258f8a080ca3f9550bb152087161001c7228f5213270dc82111a6112e431efdab6e29deb83c613062383639393163363231386233366331643139643461326539656230636533363036656234382e666163746f72792e6272696467652e6e656172b84065303333363166353635323762323739323533333432353039393366646362383636323365393038323534623866386165643861653033376666326531626235940757bf9b14884533a4b3e89fd8d878f548cfcc4e8402ce122880\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"NEW_DATA_RECEIPT_BYTE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"103272066\"},{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7943043330\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"198397994250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7086626100\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"15218206023\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"173280000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"28708495200\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8210879280\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"22654486674\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108023952\"},{\"cost\":\"SHA256_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4540970250\"},{\"cost\":\"SHA256_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3834658809\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"281784228750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4859547681\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4309251840\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"64196736000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"21936120681\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"352414335\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"21185662137\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"483058677780\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6223558122\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"336192292287\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"204705806580\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"28037948610\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3028834464\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"28655224860\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6762982356\"}],\"version\":3},\"receipt_ids\":[\"CjrEGsSxUrbSSWizWUCJhSyHMGcqGZ99QGEPSwua9kwo\"],\"status\":{\"SuccessValue\":\"IjAi\"},\"tokens_burnt\":\"439383100166200000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"BsvaMht3DWLfh4Hh8J1Tvkb4TarDc1eLhEkj8iNZYTLn\"},{\"direction\":\"Left\",\"hash\":\"329geyiXck8GcSWvGETw44d9etCScCqZkUnaP1sTvsjb\"},{\"direction\":\"Right\",\"hash\":\"9kwjECYJQyMcjc6CvM145Xxy12BeXLkPtunNGKeMtbCk\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJzZW5kZXJfaWQiOiJlMDMzNjFmNTY1MjdiMjc5MjUzMzQyNTA5OTNmZGNiODY2MjNlOTA4MjU0YjhmOGFlZDhhZTAzN2ZmMmUxYmI1IiwiYW1vdW50IjoiNDcwNTk0OTYiLCJtc2ciOiJ7XCJ0eXBlXCI6XCJUcmFuc2ZlclwiLFwidG9cIjpcIjB4MDc1N2JGOUIxNDg4NDUzM2E0QjNFODlGRDhEODc4ZjU0OENGQ0M0RVwiLFwidG9fY2hhaW5cIjpcIjIyNzc2XCJ9In0=\",\"deposit\":\"0\",\"gas\":270000000000000,\"method_name\":\"ft_on_transfer\"}}],\"gas_price\":\"625040174\",\"input_data_ids\":[],\"output_data_receivers\":[{\"data_id\":\"DJzQmhhaummUUFNzP99semWjwgwjmjo86A4pAqUBzch3\",\"receiver_id\":\"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\"}],\"signer_id\":\"e03361f56527b27925334250993fdcb86623e908254b8f8aed8ae037ff2e1bb5\",\"signer_public_key\":\"ed25519:G6BmWT85Uu4At6rPxkma6ERZGFQd5opn8JunAzTu8UMA\"}},\"receipt_id\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"receiver_id\":\"mos.mfac.butternetwork.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"EVzjwprJmpvwATvvy6vMDB5Y5UJWfksE8aWb9PvcNepm\",\"outcome\":{\"executor_id\":\"nearcrowd_2.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"5wvf7p1Y4sJFdk7pHsVkc3MQa7QCPKjo11MrCUDw1RCG\"},{\"direction\":\"Left\",\"hash\":\"329geyiXck8GcSWvGETw44d9etCScCqZkUnaP1sTvsjb\"},{\"direction\":\"Right\",\"hash\":\"9kwjECYJQyMcjc6CvM145Xxy12BeXLkPtunNGKeMtbCk\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13214028874009742651168\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"nearcrowd_2.near\",\"signer_public_key\":\"ed25519:2RRwQPTGRZkavm5sf1gJEbay34MpBMpw7LTriD3ZeLBZ\"}},\"receipt_id\":\"EVzjwprJmpvwATvvy6vMDB5Y5UJWfksE8aWb9PvcNepm\",\"receiver_id\":\"nearcrowd_2.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"CtQACcsYrAuAWoGPoUE7uM6c3JoZ9rHQNfhtMMbJoyYD\",\"outcome\":{\"executor_id\":\"mytestapi.embr.playember_reserve.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"As9h8f8UZdPNLbopn8vVxJvvxXzkR3xUyivDbReB6v25\"},{\"direction\":\"Right\",\"hash\":\"5uQQ5YdK91ZFg56TgpJADpYenvNYEaWVjcqyLk3c15Yh\"},{\"direction\":\"Left\",\"hash\":\"62f4EWTnhFEq8XaRqQmR7Y5NVHb89Ge29MS7FMWJWGJt\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"669547687500000000\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"mytestapi.embr.playember_reserve.near\",\"signer_public_key\":\"ed25519:CKyBFz2ncy7GP9oqDqUojEQm4aPzntmQf4zswVyj4kSH\"}},\"receipt_id\":\"CtQACcsYrAuAWoGPoUE7uM6c3JoZ9rHQNfhtMMbJoyYD\",\"receiver_id\":\"mytestapi.embr.playember_reserve.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"4AztGSk1EGUy7WU7NgoZKe1Wrnh59zcQc114vxvM7ubf\",\"outcome\":{\"executor_id\":\"rezerv-42.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"6WPacWUweJPEtbkkAwmnr5EjdPqofedzQJBF8DgcpLYC\"},{\"direction\":\"Right\",\"hash\":\"5uQQ5YdK91ZFg56TgpJADpYenvNYEaWVjcqyLk3c15Yh\"},{\"direction\":\"Left\",\"hash\":\"62f4EWTnhFEq8XaRqQmR7Y5NVHb89Ge29MS7FMWJWGJt\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"13236703872667742651168\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"rezerv-42.near\",\"signer_public_key\":\"ed25519:5NVcZnEZY9xcknHjb5BzmzhHdD7P8TD8LvQ9kBJWNbbQ\"}},\"receipt_id\":\"4AztGSk1EGUy7WU7NgoZKe1Wrnh59zcQc114vxvM7ubf\",\"receiver_id\":\"rezerv-42.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3086099137278,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"104880000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20878905600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1493923869\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5034330372\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18825342\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108079793250\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4249136610\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"617210550\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3532903770\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5215732158\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3908335914\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"96611735556\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36414357804\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8411384583\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"563820804\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8596567458\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1144270764\"}],\"version\":3},\"receipt_ids\":[\"CNa2SnH47PXc9hWTQUJdVx3JRkiHd1Wqzr1LJd2Gs4EW\"],\"status\":{\"SuccessValue\":\"eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0=\"},\"tokens_burnt\":\"308609913727800000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"4RAEmJPbThMn6wpHEnxnrp6jXkg4ftFEm87oWrazqGAZ\"},{\"direction\":\"Left\",\"hash\":\"6B3gvAqo7HVr2WzxtmZNmh5C5o4tV4UAgd1tYjPis2F2\"},{\"direction\":\"Left\",\"hash\":\"62f4EWTnhFEq8XaRqQmR7Y5NVHb89Ge29MS7FMWJWGJt\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"b5acefe75a5e4b2ddb252d43d3f1b8df457001ba1f589dfb2769470c02a36b9a\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiYjVhY2VmZTc1YTVlNGIyZGRiMjUyZDQzZDNmMWI4ZGY0NTcwMDFiYTFmNTg5ZGZiMjc2OTQ3MGMwMmEzNmI5YSJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"b5acefe75a5e4b2ddb252d43d3f1b8df457001ba1f589dfb2769470c02a36b9a\",\"signer_public_key\":\"ed25519:3y5fUDm1yY1SK8TRaj7DEMJMLHgh9Fq85AbN1K1ifCZr\"}},\"receipt_id\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"outcome\":{\"executor_id\":\"tge-lockup.sweat\",\"gas_burnt\":8371735803441,\"logs\":[\"Claiming 413481309571140133379 form lockup #12061336\",\"Total claim 413481309571140133379\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"FUNCTION_CALL_BASE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"4639723000000\"},{\"cost\":\"FUNCTION_CALL_BYTE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"896609534\"},{\"cost\":\"NEW_ACTION_RECEIPT\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"289092464624\"},{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8472579552\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"50686337250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7086626100\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1121897235\"},{\"cost\":\"PROMISE_RETURN\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"560152386\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"93480000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"46977537600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3223530384\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"17620156302\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"44845710\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"169070537250\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2569060239\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1178311050\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6487696014\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"986760138\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6265744878\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"305937162594\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"12447116244\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"32657013648\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"70216465308\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"22430358888\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1282896612\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"22924179888\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1931194512\"}],\"version\":3},\"receipt_ids\":[\"BschasESynttNVH91Sn8ZeE3pP7mgT2T1mjoJBjTUZn7\",\"9p35Fe9ydop9Ud5R7U91aQQZzpyNasj38kpNYhAYGZCz\",\"6ZUsqMkHnUaGhpYPwvykgeSpyJh8z2p5QeeAkznSnA4\"],\"status\":{\"SuccessReceiptId\":\"9p35Fe9ydop9Ud5R7U91aQQZzpyNasj38kpNYhAYGZCz\"},\"tokens_burnt\":\"837173580344100000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"9TaV4tVLZU5W1fsn1XWH5jK23v3ETTpyMDA29NjWU5xS\"},{\"direction\":\"Left\",\"hash\":\"6B3gvAqo7HVr2WzxtmZNmh5C5o4tV4UAgd1tYjPis2F2\"},{\"direction\":\"Left\",\"hash\":\"62f4EWTnhFEq8XaRqQmR7Y5NVHb89Ge29MS7FMWJWGJt\"},{\"direction\":\"Left\",\"hash\":\"DTaeeWiNENGLW1CdiC3RNSqyqez3ARiUcA68b7GFBJDN\"},{\"direction\":\"Right\",\"hash\":\"6p6EovC3S8VAfuksHKXsbvPJimxLCJPj7JxDMEi2aos5\"}]},\"receipt\":{\"predecessor_id\":\"e52871e21c00eb1df7d672dc2cd8d0033fbb1ee6babcb84a9165b1d081a293c4\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"e30=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"claim\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"e52871e21c00eb1df7d672dc2cd8d0033fbb1ee6babcb84a9165b1d081a293c4\",\"signer_public_key\":\"ed25519:GRY8gUPSMduGWDapXpgVu2dvDxqdmtyJAPzPxvEDRUom\"}},\"receipt_id\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"receiver_id\":\"tge-lockup.sweat\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3086115592398,\"logs\":[],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3177217332\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"104880000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20878905600\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1493923869\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5034330372\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"18825342\"},{\"cost\":\"STORAGE_HAS_KEY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"108079793250\"},{\"cost\":\"STORAGE_HAS_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4249136610\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"56356845750\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"154762665\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"617210550\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"128393472000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3532903770\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5215732158\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3908335914\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"96611735556\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"36430812924\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8411384583\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"563820804\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"8596567458\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1144270764\"}],\"version\":3},\"receipt_ids\":[\"GiBqUZeqLG62Evf6bEWSv8DDS2YUNgEpk2m27VBDUSpt\"],\"status\":{\"SuccessValue\":\"eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0=\"},\"tokens_burnt\":\"308611559239800000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"7Jpvn9QpXQUdUUXu1J8B1tiR9MRpacVv8uz62czAYmft\"},{\"direction\":\"Right\",\"hash\":\"C61mVYcrDFnoZLshDjkswsD3Ar6sz1Du7AkBWfX4Bpk8\"},{\"direction\":\"Right\",\"hash\":\"HrXzQEZzTxoQMCL9oJidcz8RBFQZwnTi3RJm4NnLDC8U\"},{\"direction\":\"Left\",\"hash\":\"BGpbfgADZjZniQsjKyuKYHzdSDroTeDZJYJxYRJyiNvB\"}]},\"receipt\":{\"predecessor_id\":\"ca3615a0d2e244761f8452be382defc99caad8e5e89ef6e72836d2c622ff4c08\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJhY2NvdW50X2lkIjoiY2EzNjE1YTBkMmUyNDQ3NjFmODQ1MmJlMzgyZGVmYzk5Y2FhZDhlNWU4OWVmNmU3MjgzNmQyYzYyMmZmNGMwOCJ9\",\"deposit\":\"1250000000000000000000\",\"gas\":30000000000000,\"method_name\":\"storage_deposit\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"ca3615a0d2e244761f8452be382defc99caad8e5e89ef6e72836d2c622ff4c08\",\"signer_public_key\":\"ed25519:EcMBstSN5TXWkvVLQpchNchogUPXQwrN1ehkG7ALshSX\"}},\"receipt_id\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"outcome\":{\"executor_id\":\"usdt.tether-token.near\",\"gas_burnt\":3649532331252,\"logs\":[\"EVENT_JSON:{\\\\\\\"standard\\\\\\\":\\\\\\\"nep141\\\\\\\",\\\\\\\"version\\\\\\\":\\\\\\\"1.0.0\\\\\\\",\\\\\\\"event\\\\\\\":\\\\\\\"ft_transfer\\\\\\\",\\\\\\\"data\\\\\\\":[{\\\\\\\"old_owner_id\\\\\\\":\\\\\\\"learn.sweat\\\\\\\",\\\\\\\"new_owner_id\\\\\\\":\\\\\\\"e05cf2d303645da14f718ecafb561c7b7902a4b0fb7d0b939bc236f104790a25\\\\\\\",\\\\\\\"amount\\\\\\\":\\\\\\\"1000000\\\\\\\",\\\\\\\"memo\\\\\\\":\\\\\\\"sw:tr:mwWR2xmW6q\\\\\\\"}]}\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"7413507108\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"60194509500\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3154511049\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"241680000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"28708495200\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2193369141\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"20137321488\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"31835526\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"225427383000\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3280968498\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"796762710\"},{\"cost\":\"STORAGE_WRITE_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"192590208000\"},{\"cost\":\"STORAGE_WRITE_EVICTED_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4560657594\"},{\"cost\":\"STORAGE_WRITE_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"6343458030\"},{\"cost\":\"STORAGE_WRITE_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"4404632538\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"225427382964\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3111779061\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"69687734481\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"64986205416\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"25234153749\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"923358708\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"25789702374\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1646077212\"}],\"version\":3},\"receipt_ids\":[\"EgpWB3ret7L6pMncazaueV8xwAvcVkmT8dsEdqruCRV5\"],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"364953233125200000000\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"5rkuqJE5zh6NanNtZdf3baFAqDMUq7Se8gWXY9b9w7aK\"},{\"direction\":\"Right\",\"hash\":\"C61mVYcrDFnoZLshDjkswsD3Ar6sz1Du7AkBWfX4Bpk8\"},{\"direction\":\"Right\",\"hash\":\"HrXzQEZzTxoQMCL9oJidcz8RBFQZwnTi3RJm4NnLDC8U\"},{\"direction\":\"Left\",\"hash\":\"BGpbfgADZjZniQsjKyuKYHzdSDroTeDZJYJxYRJyiNvB\"}]},\"receipt\":{\"predecessor_id\":\"learn.sweat\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJyZWNlaXZlcl9pZCI6ImUwNWNmMmQzMDM2NDVkYTE0ZjcxOGVjYWZiNTYxYzdiNzkwMmE0YjBmYjdkMGI5MzliYzIzNmYxMDQ3OTBhMjUiLCJhbW91bnQiOiIxMDAwMDAwIiwibWVtbyI6InN3OnRyOm13V1IyeG1XNnEifQ==\",\"deposit\":\"1\",\"gas\":30000000000000,\"method_name\":\"ft_transfer\"}}],\"gas_price\":\"122987387\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"learn.sweat\",\"signer_public_key\":\"ed25519:9wRicBBHSqTtPzooqYTmhijZcQXonJM7FjQxvh6cfKzo\"}},\"receipt_id\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"receiver_id\":\"usdt.tether-token.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"6B1ZnWtTQPLyYmhWcZ4rQ5iFpt6NjLtRWPa9CyqBjeYH\",\"outcome\":{\"executor_id\":\"v2.ref-finance.near\",\"gas_burnt\":8109117838804,\"logs\":[\"Caller watcher02.ref-watchdog.near invokes token meta-pool.near rait async-update.\"],\"metadata\":{\"gas_profile\":[{\"cost\":\"FUNCTION_CALL_BASE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"4639723000000\"},{\"cost\":\"FUNCTION_CALL_BYTE\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"160987248\"},{\"cost\":\"NEW_ACTION_RECEIPT\",\"cost_category\":\"ACTION_COST\",\"gas_used\":\"289092464624\"},{\"cost\":\"BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"5824898442\"},{\"cost\":\"CONTRACT_LOADING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"35445963\"},{\"cost\":\"CONTRACT_LOADING_BYTES\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"160704302250\"},{\"cost\":\"LOG_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"3543313050\"},{\"cost\":\"LOG_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1082300862\"},{\"cost\":\"PROMISE_RETURN\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"560152386\"},{\"cost\":\"READ_CACHED_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"41040000000\"},{\"cost\":\"READ_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"31318358400\"},{\"cost\":\"READ_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"923723919\"},{\"cost\":\"READ_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"12585825930\"},{\"cost\":\"READ_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"51449364\"},{\"cost\":\"STORAGE_READ_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"112713691500\"},{\"cost\":\"STORAGE_READ_KEY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"619050660\"},{\"cost\":\"STORAGE_READ_VALUE_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"2508119235\"},{\"cost\":\"TOUCHING_TRIE_NODE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"193223471112\"},{\"cost\":\"UTF8_DECODING_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"9335337183\"},{\"cost\":\"UTF8_DECODING_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"33531755085\"},{\"cost\":\"WASM_INSTRUCTION\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"110763526500\"},{\"cost\":\"WRITE_MEMORY_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"14018974305\"},{\"cost\":\"WRITE_MEMORY_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1421808984\"},{\"cost\":\"WRITE_REGISTER_BASE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"14327612430\"},{\"cost\":\"WRITE_REGISTER_BYTE\",\"cost_category\":\"WASM_HOST_COST\",\"gas_used\":\"1984416408\"}],\"version\":3},\"receipt_ids\":[\"4uDz75BmNVeEmHnb7nEqmCnQLZMSD5pXW2r6bZ95gsb7\",\"E8h66oyjeDaCEiRNCYgxa3uB7k5Rydj3BNy91t6XcSpa\",\"JEF2Yst14azL3VPXhVdRrV5654gAgxB5wqJmRH5coo2T\"],\"status\":{\"SuccessReceiptId\":\"E8h66oyjeDaCEiRNCYgxa3uB7k5Rydj3BNy91t6XcSpa\"},\"tokens_burnt\":\"810911783880400000000\"},\"proof\":[{\"direction\":\"Right\",\"hash\":\"5EBfTpZR6RTSaN5EqBo3s3rzy3pH4SPxC3EJa1QxcjLR\"},{\"direction\":\"Left\",\"hash\":\"BVpsMELbZCRqqYqu9fF8bGeRAMLQ77PixMouD8Yo3UPC\"},{\"direction\":\"Right\",\"hash\":\"HrXzQEZzTxoQMCL9oJidcz8RBFQZwnTi3RJm4NnLDC8U\"},{\"direction\":\"Left\",\"hash\":\"BGpbfgADZjZniQsjKyuKYHzdSDroTeDZJYJxYRJyiNvB\"}]},\"receipt\":{\"predecessor_id\":\"watcher02.ref-watchdog.near\",\"receipt\":{\"Action\":{\"actions\":[{\"FunctionCall\":{\"args\":\"eyJ0b2tlbl9pZCI6Im1ldGEtcG9vbC5uZWFyIn0=\",\"deposit\":\"0\",\"gas\":100000000000000,\"method_name\":\"update_token_rate\"}}],\"gas_price\":\"186029458\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"watcher02.ref-watchdog.near\",\"signer_public_key\":\"ed25519:3g2J3UmwRdmo9scukmM6A9qQzKbu7pCPFaQPU9pngMce\"}},\"receipt_id\":\"6B1ZnWtTQPLyYmhWcZ4rQ5iFpt6NjLtRWPa9CyqBjeYH\",\"receiver_id\":\"v2.ref-finance.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"Cu26A2ouAPUXSxi6yofGNJ5henyxHyYShtLr8BFnX1DD\",\"outcome\":{\"executor_id\":\"operator.meta-pool.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"CJSi9hF8zJEAefYoxTequpQ7TML7XEk46if4EyePr53j\"},{\"direction\":\"Left\",\"hash\":\"BVpsMELbZCRqqYqu9fF8bGeRAMLQ77PixMouD8Yo3UPC\"},{\"direction\":\"Right\",\"hash\":\"HrXzQEZzTxoQMCL9oJidcz8RBFQZwnTi3RJm4NnLDC8U\"},{\"direction\":\"Left\",\"hash\":\"BGpbfgADZjZniQsjKyuKYHzdSDroTeDZJYJxYRJyiNvB\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"69757213628944665882360\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"operator.meta-pool.near\",\"signer_public_key\":\"ed25519:3hpXGXHhxxq4C3KFWYcSApTLPhgerNLcU2NgCB3WGz5M\"}},\"receipt_id\":\"Cu26A2ouAPUXSxi6yofGNJ5henyxHyYShtLr8BFnX1DD\",\"receiver_id\":\"operator.meta-pool.near\"}},{\"execution_outcome\":{\"block_hash\":\"9DBzUMMZEvipLQRk8uYHspC1xmjV8hTxPgmfFjZcpwSa\",\"id\":\"CZAqWPwfgBrykmfZPZoLMJMxg4FsGFNLvapr3qXNeBWV\",\"outcome\":{\"executor_id\":\"stader-epoch-runner.near\",\"gas_burnt\":223182562500,\"logs\":[],\"metadata\":{\"gas_profile\":[],\"version\":3},\"receipt_ids\":[],\"status\":{\"SuccessValue\":\"\"},\"tokens_burnt\":\"0\"},\"proof\":[{\"direction\":\"Left\",\"hash\":\"F1SED3zPduvsyCZi1pFeRVGn9mcRz5SKXww2dNzp8XB8\"},{\"direction\":\"Left\",\"hash\":\"BGpbfgADZjZniQsjKyuKYHzdSDroTeDZJYJxYRJyiNvB\"}]},\"receipt\":{\"predecessor_id\":\"system\",\"receipt\":{\"Action\":{\"actions\":[{\"Transfer\":{\"deposit\":\"188712065628723398213284\"}}],\"gas_price\":\"0\",\"input_data_ids\":[],\"output_data_receivers\":[],\"signer_id\":\"stader-epoch-runner.near\",\"signer_public_key\":\"ed25519:AVv8KsWqKd8acYPVdbCnrXAZ2FB2jjxJH1c3djHuW2JD\"}},\"receipt_id\":\"CZAqWPwfgBrykmfZPZoLMJMxg4FsGFNLvapr3qXNeBWV\",\"receiver_id\":\"stader-epoch-runner.near\"}}],\"shard_id\":3,\"state_changes\":[{\"cause\":{\"receipt_hash\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"mos.mfac.butternetwork.near\",\"amount\":\"267177595630699948599985632\",\"code_hash\":\"aGvH4wVFr7yiKZtm6iWGyvm7KrTjHQtSBPv7SLQHuHz\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":5645337},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"mos.mfac.butternetwork.near\",\"amount\":\"267177654593041599999985632\",\"code_hash\":\"aGvH4wVFr7yiKZtm6iWGyvm7KrTjHQtSBPv7SLQHuHz\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":5645337},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"CtQACcsYrAuAWoGPoUE7uM6c3JoZ9rHQNfhtMMbJoyYD\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"mytestapi.embr.playember_reserve.near\",\"amount\":\"142724515333661303291726970\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"EVzjwprJmpvwATvvy6vMDB5Y5UJWfksE8aWb9PvcNepm\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"nearcrowd_2.near\",\"amount\":\"2281060988056732006815357\",\"code_hash\":\"B6cTvbdTFEoDXs1Y8MGjmQTUgJTBjdq9ALDGdPfUtTr1\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":149064},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"Cu26A2ouAPUXSxi6yofGNJ5henyxHyYShtLr8BFnX1DD\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"operator.meta-pool.near\",\"amount\":\"49629261360520277173001174\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":182},\"type\":\"account_update\"},{\"cause\":{\"tx_hash\":\"CWhKBgYmHHR5woSixizwqThvF9NgE7kRdBQzVuf429qw\",\"type\":\"transaction_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"amount\":\"9695286352516597344422080\",\"code_hash\":\"FVNRYiwRzkDABcHGcCVgJMHLNFLCuxpa4mK1hLgPY6n6\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":619479},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"amount\":\"9700286352516597344422080\",\"code_hash\":\"FVNRYiwRzkDABcHGcCVgJMHLNFLCuxpa4mK1hLgPY6n6\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":619778},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"amount\":\"9701193692831428244422080\",\"code_hash\":\"FVNRYiwRzkDABcHGcCVgJMHLNFLCuxpa4mK1hLgPY6n6\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":619778},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"6f3TNmYXE8VXotRzhDxajmP3GThEEn56DJMRyUKRFL6\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"relay.aurora\",\"amount\":\"3722792617337240846198093947\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":149094},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"bm7V3pZbt3hbo3dq5NndWdEe89smD7UWBXKqHF8q3MY\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"relay.aurora\",\"amount\":\"3722981321335705168184733799\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":149094},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"4AztGSk1EGUy7WU7NgoZKe1Wrnh59zcQc114vxvM7ubf\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"rezerv-42.near\",\"amount\":\"187734276231567460276833\",\"code_hash\":\"7DcAdMUT1MjaZ9s7zhXdyxKvQsRsSfnmBGdzeZaquqDE\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1493},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"CZAqWPwfgBrykmfZPZoLMJMxg4FsGFNLvapr3qXNeBWV\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"stader-epoch-runner.near\",\"amount\":\"29951657418180409375197454\",\"code_hash\":\"11111111111111111111111111111111\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1590},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"amount\":\"51413046802067504674395940938\",\"code_hash\":\"21wTg75GYpVCanPeoiX1F8BfFTfZmJS3FqS5pG9UF9dN\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":4249534161},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"amount\":\"51413046985587324724395940938\",\"code_hash\":\"21wTg75GYpVCanPeoiX1F8BfFTfZmJS3FqS5pG9UF9dN\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":4249534161},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"amount\":\"51413046985587324724395940937\",\"code_hash\":\"21wTg75GYpVCanPeoiX1F8BfFTfZmJS3FqS5pG9UF9dN\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":4249534161},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"amount\":\"51413047163901299281395940937\",\"code_hash\":\"21wTg75GYpVCanPeoiX1F8BfFTfZmJS3FqS5pG9UF9dN\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":4249534161},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"amount\":\"41999895590807248257459564804\",\"code_hash\":\"FMy4MTxATGtfxqTg5PZfGhQpRWej9Ppbttwo7FWF13wA\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1746773038},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"token.sweat\",\"amount\":\"41999895637943282671459564804\",\"code_hash\":\"FMy4MTxATGtfxqTg5PZfGhQpRWej9Ppbttwo7FWF13wA\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1746773038},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"amount\":\"41999895637943282671459564805\",\"code_hash\":\"FMy4MTxATGtfxqTg5PZfGhQpRWej9Ppbttwo7FWF13wA\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1746773038},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"token.sweat\",\"amount\":\"41999895667458586386059564805\",\"code_hash\":\"FMy4MTxATGtfxqTg5PZfGhQpRWej9Ppbttwo7FWF13wA\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":1746773038},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174792511483090334888327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108213},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174792541631556667888327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108213},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174793791631556667888327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108338},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174793812337319132188327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108338},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174795062337319132188327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108463},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174795082350317414188327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108463},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174796332350317414188327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108588},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174796352089222042588327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108588},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174797602089222042588327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108713},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174797621828620324588327208\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108713},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174797621828620324588327209\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108713},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"amount\":\"174797658467703495388327209\",\"code_hash\":\"51tHbmQkA8qAi8c6MoUor5mCx6CnL6tZyC2sqQifKPZC\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":14108713},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"6B1ZnWtTQPLyYmhWcZ4rQ5iFpt6NjLtRWPa9CyqBjeYH\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"v2.ref-finance.near\",\"amount\":\"3692521320485906631549188673\",\"code_hash\":\"ELTWoZ9sfPgNZp48GQeetbYfvofhjZidLWF9p9n77diH\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":56828952},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"6B1ZnWtTQPLyYmhWcZ4rQ5iFpt6NjLtRWPa9CyqBjeYH\",\"type\":\"action_receipt_gas_reward\"},\"change\":{\"account_id\":\"v2.ref-finance.near\",\"amount\":\"3692521490918726206749188673\",\"code_hash\":\"ELTWoZ9sfPgNZp48GQeetbYfvofhjZidLWF9p9n77diH\",\"locked\":\"0\",\"storage_paid_at\":0,\"storage_usage\":56828952},\"type\":\"account_update\"},{\"cause\":{\"receipt_hash\":\"EVzjwprJmpvwATvvy6vMDB5Y5UJWfksE8aWb9PvcNepm\",\"type\":\"receipt_processing\"},\"change\":{\"access_key\":{\"nonce\":91718936001631,\"permission\":{\"FunctionCall\":{\"allowance\":\"8457582309680570200000000\",\"method_names\":[],\"receiver_id\":\"app.nearcrowd.near\"}}},\"account_id\":\"nearcrowd_2.near\",\"public_key\":\"ed25519:2RRwQPTGRZkavm5sf1gJEbay34MpBMpw7LTriD3ZeLBZ\"},\"type\":\"access_key_update\"},{\"cause\":{\"tx_hash\":\"CWhKBgYmHHR5woSixizwqThvF9NgE7kRdBQzVuf429qw\",\"type\":\"transaction_processing\"},\"change\":{\"access_key\":{\"nonce\":88017794000106,\"permission\":\"FullAccess\"},\"account_id\":\"papaya.recurforever.near\",\"public_key\":\"secp256k1:icvWegs3SdDR5Hgvxg9HJX1m2SWbrVTfECFx6AT7z3vZn7QANnDieH6sLunNcR4T7XmcfkwMFxLnFtC2k5C41Bn\"},\"type\":\"access_key_update\"},{\"cause\":{\"receipt_hash\":\"4AztGSk1EGUy7WU7NgoZKe1Wrnh59zcQc114vxvM7ubf\",\"type\":\"receipt_processing\"},\"change\":{\"access_key\":{\"nonce\":92395788000736,\"permission\":{\"FunctionCall\":{\"allowance\":\"8763028714718603800000000\",\"method_names\":[],\"receiver_id\":\"app.nearcrowd.near\"}}},\"account_id\":\"rezerv-42.near\",\"public_key\":\"ed25519:5NVcZnEZY9xcknHjb5BzmzhHdD7P8TD8LvQ9kBJWNbbQ\"},\"type\":\"access_key_update\"},{\"cause\":{\"receipt_hash\":\"5jAZr8vHTCWmmCSnvbCxa4fiwLQrdwuXSNHQft6UZ1io\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"mos.mfac.butternetwork.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"HQAAAGNsaWVudDIuY2ZhYy5tYXBwcm90b2NvbC5uZWFyYwEFGJxxFGZ6cXmqV/B2R6X0K38CAAAAbWkBAAAAAAAAAAIAAABtawEAAAAAAAAAAgAAAG12AgAAAGdpAwAAAAAAAAACAAAAZ2sDAAAAAAAAAAIAAABndgIAAABiaQQAAAAAAAAAAgAAAGJrBAAAAAAAAAACAAAAYnYCAAAAbGkFAAAAAAAAAAIAAABsawUAAAAAAAAAAgAAAGx2AAAAAAIAAABjaQQAAAAAAAAAAgAAAGNrBAAAAAAAAAACAAAAY3YCAAAAdWk5OAAAAAAAAAIAAAB1ZQIAAAAGaTI4AAAAAAAAAgAAAAZlIAAAAG11bHRpc2lnLm1mYWMuYnV0dGVybmV0d29yay5uZWFyAABIVjcZPMNDAAAAAAAAAAkAAAB3cmFwLm5lYXIBAAAAAdUEAAAAAAAAAAAA+FgAAAAAAAAAAAAAAAAAAPQ3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAHJpBQAAAAAAAAACAAAAcmsFAAAAAAAAAAIAAABydhMAAAB2Mi5yZWYtZmluYW5jZS5uZWFyAgAAACEAAABjb3JlMTEuY29yZWZhYy5idXR0ZXJuZXR3b3JrLm5lYXIhAAAAY29yZTEwLmNvcmVmYWMuYnV0dGVybmV0d29yay5uZWFyAwAAACAAAABjb3JlMS5jb3JlZmFjLmJ1dHRlcm5ldHdvcmsubmVhciEAAABjb3JlMTAuY29yZWZhYy5idXR0ZXJuZXR3b3JrLm5lYXIhAAAAY29yZTExLmNvcmVmYWMuYnV0dGVybmV0d29yay5uZWFyAAAAAAIAAABuaQAAAAAAAAAAAgAAAG5rAAAAAAAAAAACAAAAbnY=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"key_base64\":\"MDM2NDA1Ng==\",\"value_base64\":\"MTAw\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"key_base64\":\"MzQyMDZjNDE0ZjE0ZTNmMzhkMjQ1ZTcyOWY3ZTYwNzY3ZTQ0ZDA3Mjg2ZjAwYjUyMGU1ZjA0YmJkZjZmMzExZWE=\",\"value_base64\":\"eyJ0b2tlbl9pZHMiOlsiMTYzMjkwIiwiMzM5NzciLCIzNjQwNTYiXX0=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"eyJzeW1ib2wiOiJORlRVIiwibmFtZSI6Ik5GVFUiLCJpY29uIjoiIiwiYmFzZV91cmkiOiJodHRwczovL3VzZTEtY29tbW9uLXJlc3RhcGkucHJvZC5yZWN1cmZvcmV2ZXIuY29tL3BsYXRmb3JtLWxhbWJkYXMvbWV0YWRhdGEvdG9rZW4vUEFQQVlBLyIsInJveWFsdHlfcGF5bWVudF9hZGRyZXNzIjoiOWE3ZGFkZDUxYzFlMjQzZDJhMWQ2OWY5YmIyYzYwMjg5NjllMmFlYWMyY2Y3NjA4MWE2ZjhhODFhMjI0ODZkMSIsInRlcm1zX29mX3NlcnZpY2VfdGV4dCI6Imh0dHBzOi8vd3d3LnJlY3VyZm9yZXZlci5jb20vdGVybXMtb2Ytc2VydmljZSIsInRva2VuX2NvdW50IjoxMDEsImlzX3BhdXNlZCI6ZmFsc2UsIm93bmVyX2FjY291bnQiOiJwYXBheWEucmVjdXJmb3JldmVyLm5lYXIiLCJ0b2tlbnMiOnsicHJlZml4IjoiIiwibGVuZ3RoIjoxMDF9LCJ0b2tlbl90b19pbmRleCI6eyJrZXlQcmVmaXgiOiIwIn0sImJsYWNrbGlzdGVkX2FjY291bnRzIjp7ImtleVByZWZpeCI6IjEifSwibG9ja2VkX3Rva2VucyI6eyJrZXlQcmVmaXgiOiIyIn0sIm93bmVyX3Rva2VucyI6eyJrZXlQcmVmaXgiOiIzIn19\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"DZdLEbDeBRKapvRo4tUkx3hxgjCwRzKox2m3PZLVuUyJ\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"papaya.recurforever.near\",\"key_base64\":\"ZAAAAA==\",\"value_base64\":\"eyJ0b2tlbl9pZCI6IjM2NDA1NiIsIm93bmVyX2lkIjoiNDIwNmM0MTRmMTRlM2YzOGQyNDVlNzI5ZjdlNjA3NjdlNDRkMDcyODZmMDBiNTIwZTVmMDRiYmRmNmYzMTFlYSIsInJveWFsdHlfcGVyY2VudCI6MTAwMCwiaXNzdWVkX2F0IjoxNjg1MTE4NjgwNjE0LCJhcHByb3ZlZF9hY2NvdW50c19pZHMiOnt9LCJuZXh0X2FwcHJvdmFsX2lkIjowfQ==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"key_base64\":\"AG00AQAAAAAA\",\"value_base64\":\"QAAAADAxODJlNWQ2MmYxYzNkNmE0YjI2YjQ5YzkzNGQ1OGEwMDUyZTBmOWNhZGYwNDZlMjJkZmE1Y2ZmMWU5MmQ4MzUDAAAAj0YgYwAAAAAAAAAAAAAAAAAAAACQRiBjAND9nOlSbMkdAAAAAAAAABD/42YAIOohID073ikBAAAAAAAAqgrQLh1vIWt7AAAAAAAAAAA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"key_base64\":\"AJgKuAAAAAAA\",\"value_base64\":\"QAAAAGU1Mjg3MWUyMWMwMGViMWRmN2Q2NzJkYzJjZDhkMDAzM2ZiYjFlZTZiYWJjYjg0YTkxNjViMWQwODFhMjkzYzQDAAAAj0YgYwAAAAAAAAAAAAAAAAAAAACQRiBjABCWY+gyLxsJAAAAAAAAABD/42YAoNzjE/3XD1sAAAAAAAAAoztcICjHA7slAAAAAAAAAAA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"GKCJmBtpCqvvz9oYxydyaY1n5a3Ly41ueXKFTTj8fiac\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"CwAAAHRva2VuLnN3ZWF0ydbNAAAAAAABAAAAAAEAAAABAgAAAAJpAQAAAAAAAAACAAAAAmU=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"BdSkBCq7HtNPybcChSk6o2suvDz42hFB94HxCDePVCci\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"tge-lockup.sweat\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"CwAAAHRva2VuLnN3ZWF0ydbNAAAAAAABAAAAAAEAAAABAgAAAAJpAQAAAAAAAAACAAAAAmU=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"AgAAAHNpAQAAAAAAAAACAAAAc2UBAAAAdAEIAAAALnUuc3dlYXTZhTiyDwE8EXwk3kgAAAAAWgAAAAAAAADernXIFAMAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"AgAAAHNpAQAAAAAAAAACAAAAc2UBAAAAdAEIAAAALnUuc3dlYXTZhTiyDwE8EXwk3kgAAAAAWgAAAAAAAADernXIFAMAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"dAAIwtNTIl0oBqKzqsbwvTl9sKe+80DRyHN+1AGj4RbjWQ==\",\"value_base64\":\"xCl/gGfl58QAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"dACGEzizsoMxL2O52QbNDpf5P9RYAzbWaOsGDToxPCiSmg==\",\"value_base64\":\"j4QT/Z2PjNIAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"Fma1RnScq8DEB8wmY1antx4tBsVx84rffvs2o5S2vcBR\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"dADCUiigKPOTAl1jqrFvCFMV6YPDQuu8kGehwLHx0CgpIw==\",\"value_base64\":\"AABSVjuGS9b/AwIAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HRxnJyEFygJg1QtWzMFN5DMRfPyemPQbFEGYdUUrD43T\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"token.sweat\",\"key_base64\":\"dADCUiigKPOTAl1jqrFvCFMV6YPDQuu8kGehwLHx0CgpIw==\",\"value_base64\":\"AAC2/e48LOT/AwIAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"U1RBVEU=\",\"value_base64\":\"FQAAAHRldGhlci5tdWx0aXNhZmUubmVhchUAAAB0ZXRoZXIubXVsdGlzYWZlLm5lYXIBAAAAYUCSSCeMBAAAAAAAAAAAAAB9AAAAAAAAAAEAAABtAgAAAGNpAAAAAAAAAAACAAAAY2UBAAAAYgA=\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YQsAAABsZWFybi5zd2VhdA==\",\"value_base64\":\"AJxRGhEAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"9Se9uAo3caHJG6wAFFh4VmPpjyZwLmR7zcVNWaKrrFb3\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAAA2NGFiZmZiZTY1OWY1ZGE3NTJkMDgyMWE3MmQ5ZjBjYjY2MGM0YmM4NGU5MGIxMTA0YTRiNDA2NWQ5OGE2Yzc1\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"8LyaPknFFRiEwZn9Zg76NDvfDShTg4P1CoiAVXYTcB3S\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAABhMDgxYjFiYjc1MGQ3YzFlMjBlMmEwMzNlNjIzN2NiYTJmMjcwOWI0ZjdhZWJkM2EzNjIzY2ExOThhN2RiZDM1\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"7NQ2puUQk5YdphCtyESCCdav1gMNCNcBC22Ub99yqPDm\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAABhM2UxZjViMTcyNGYxOGNiYTVjZjM1YWQzZDIwMDM3ZmVhZjdlN2M1NzA5ZTg4MzhiODM3NTlkNzUwNGIwYmNj\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"6Xb4nNi8zGg6KdVhXRWM8uUURfhzFbX4R82E3soep9ES\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAABiNWFjZWZlNzVhNWU0YjJkZGIyNTJkNDNkM2YxYjhkZjQ1NzAwMWJhMWY1ODlkZmIyNzY5NDcwYzAyYTM2Yjlh\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"BEHb8nxPsFPjbd7tjkBrVbtj5TBy6xbDCBXKhQvwuFLH\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAABjYTM2MTVhMGQyZTI0NDc2MWY4NDUyYmUzODJkZWZjOTljYWFkOGU1ZTg5ZWY2ZTcyODM2ZDJjNjIyZmY0YzA4\",\"value_base64\":\"AAAAAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"},{\"cause\":{\"receipt_hash\":\"HFhq6ajK6euvmbz6pRCDeZhBAvLe5b5QaFZdfJeKNTxU\",\"type\":\"receipt_processing\"},\"change\":{\"account_id\":\"usdt.tether-token.near\",\"key_base64\":\"YUAAAABlMDVjZjJkMzAzNjQ1ZGExNGY3MThlY2FmYjU2MWM3Yjc5MDJhNGIwZmI3ZDBiOTM5YmMyMzZmMTA0NzkwYTI1\",\"value_base64\":\"QEIPAAAAAAAAAAAAAAAAAA==\"},\"type\":\"data_update\"}]}]}"

	data := mapprotocol.StreamerMessage{}
	fmt.Println("err --------------- ", json.Unmarshal([]byte(str), &data))
	fmt.Println("data --------------- ", data)
}

'''
'''--- chains/platon/chain.go ---
package platon

import (
	"context"
	"fmt"
	"github.com/ethereum/go-ethereum/core/types"
	"math/big"

	"github.com/mapprotocol/compass/internal/platon"

	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/tx"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

func InitializeChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	return chain.New(chainCfg, logger, sysErr, role, platon.NewConn, chain.OptOfSync2Map(syncHeaderToMap), chain.OptOfAssembleProof(assembleProof), chain.OptOfOracleHandler(chain.DefaultOracleHandler))
}

func syncHeaderToMap(m *chain.Maintainer, latestBlock *big.Int) error {
	remainder := big.NewInt(0).Mod(latestBlock, big.NewInt(mapprotocol.HeaderCountOfPlaton))
	if remainder.Cmp(mapprotocol.Big0) != 0 {
		return nil
	}
	syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
	if err != nil {
		m.Log.Error("Get current synced Height failed", "err", err)
		return err
	}
	if latestBlock.Cmp(syncedHeight) <= 0 {
		m.Log.Info("CurrentBlock less than synchronized headerHeight", "synced height", syncedHeight,
			"current height", latestBlock)
		return nil
	}
	m.Log.Info("Find sync block", "current height", latestBlock)
	headers := make([]*platon.BlockHeader, 1)
	header, err := m.Conn.Client().PlatonGetBlockByNumber(context.Background(), latestBlock)
	if err != nil {
		return err
	}
	headers = append(headers, platon.ConvertHeader(header))

	block, err := platon.GetHeaderParam(m.Conn.Client(), latestBlock)
	if err != nil {
		return err
	}

	validators := make([]platon.Validator, 0, len(block.Validators))
	for _, v := range block.Validators {
		validators = append(validators, platon.Validator{
			Address:   ethcommon.HexToAddress(v.Address),
			NodeId:    ethcommon.Hex2Bytes(v.NodeId),
			BlsPubKey: ethcommon.Hex2Bytes(v.BlsPubKey),
		})
	}
	input, err := mapprotocol.Platon.Methods[mapprotocol.MethodOfGetHeadersBytes].Inputs.Pack(block.Header, block.Cert, validators)
	if err != nil {
		m.Log.Error("Failed to abi pack", "err", err)
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	msgpayload := []interface{}{id, input}
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, msgpayload, m.MsgCh)

	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("Subscription error: failed to route message", "err", err)
		return err
	}

	err = m.WaitUntilMsgHandled(1)
	if err != nil {
		return err
	}
	return nil
}

func assembleProof(m *chain.Messenger, log *types.Log, proofType int64, toChainID uint64) (*msg.Message, error) {
	var (
		message   msg.Message
		orderId   = log.Data[:32]
		method    = m.GetMethod(log.Topics[0])
		bigNumber = big.NewInt(int64(log.BlockNumber))
	)
	headerParam, err := platon.GetHeaderParam(m.Conn.Client(), bigNumber)
	if err != nil {
		return nil, err
	}
	txsHash, err := tx.GetTxsHashByBlockNumber(m.Conn.Client(), bigNumber)
	if err != nil {
		return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
	if err != nil {
		return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
	}

	payload, err := platon.AssembleProof(headerParam, log, receipts, method, m.Cfg.Id, proofType)
	if err != nil {
		return nil, fmt.Errorf("unable to Parse Log: %w", err)
	}

	msgPayload := []interface{}{payload, orderId, log.BlockNumber, log.TxHash}
	message = msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, msgPayload, m.MsgCh)
	return &message, nil
}

'''
'''--- chains/tron/chain.go ---
package tron

import (
	"fmt"
	connection "github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/keystore"
	"math/big"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/log"
	"github.com/lbtsm/gotron-sdk/pkg/client"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
)

func NewChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role) (core.Chain, error) {
	return createChain(chainCfg, logger, sysErr, role)
}

func createChain(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role, opts ...chain.SyncOpt) (core.Chain, error) {
	config, err := parseCfg(chainCfg)
	if err != nil {
		return nil, err
	}

	conn := NewConnection(config.Endpoint, logger)
	err = conn.Connect()
	if err != nil {
		return nil, err
	}

	ethConn := connection.NewConnection(config.Eth2Endpoint, true, nil, logger, config.GasLimit, config.MaxGasPrice, 0)
	err = ethConn.Connect()
	if err != nil {
		return nil, err
	}

	pswd := keystore.GetPassword(fmt.Sprintf("Enter password for key %s:", chainCfg.From))

	var (
		stop   = make(chan int)
		listen chains.Listener
	)
	bs, err := chain.SetupBlockStore(&config.Config, role)
	if err != nil {
		return nil, err
	}
	cs := chain.NewCommonSync(ethConn, &config.Config, logger, stop, sysErr, bs)

	switch role {
	case mapprotocol.RoleOfMaintainer:
		fn := Map2Tron(config.From, config.LightNode, conn.cli)
		height, err := fn()
		if err != nil {
			return nil, errors.Wrap(err, "Map2Tron get init headerHeight failed")
		}
		logger.Info("Map2other Current situation", "id", config.Id, "height", height, "lightNode", config.LightNode)
		mapprotocol.SyncOtherMap[config.Id] = height
		mapprotocol.Map2OtherHeight[config.Id] = fn
		listen = NewMaintainer(logger)
	case mapprotocol.RoleOfMessenger:
		listen = newSync(cs, messengerHandler, conn)
	case mapprotocol.RoleOfOracle:
		listen = newSync(cs, oracleHandler, conn)
	}

	return &Chain{
		conn:   conn,
		stop:   stop,
		listen: listen,
		cfg:    chainCfg,
		writer: newWriter(conn, config, logger, stop, sysErr, pswd),
	}, nil
}

type Chain struct {
	cfg    *core.ChainConfig
	conn   core.Connection
	writer *Writer
	stop   chan<- int
	listen chains.Listener
}

func (c *Chain) SetRouter(r *core.Router) {
	r.Listen(c.cfg.Id, c.writer)
	c.listen.SetRouter(r)
}

func (c *Chain) Start() error {
	err := c.listen.Sync()
	if err != nil {
		return err
	}

	log.Debug("Successfully started Chain")
	return nil
}

func (c *Chain) Id() msg.ChainId {
	return c.cfg.Id
}

func (c *Chain) Name() string {
	return c.cfg.Name
}

// Stop signals to any running routines to exit
func (c *Chain) Stop() {
	close(c.stop)
	if c.conn != nil {
		c.conn.Close()
	}
}

// Conn return Connection interface for relayer register
func (c *Chain) Conn() core.Connection {
	return c.conn
}

func Map2Tron(fromUser, lightNode string, client *client.GrpcClient) mapprotocol.GetHeight {
	return func() (*big.Int, error) {
		call, err := client.TriggerConstantContract(fromUser, lightNode, "headerHeight()", "")
		if err != nil {
			return nil, fmt.Errorf("map2tron call headerHeight failed, err is %v", err.Error())
		}
		return mapprotocol.UnpackHeaderHeightOutput(call.ConstantResult[0])
	}
}

'''
'''--- chains/tron/config.go ---
package tron

import (
	"strings"

	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
)

type Config struct {
	chain.Config
	LightNode   string
	McsContract []string
}

func parseCfg(chainCfg *core.ChainConfig) (*Config, error) {
	cfg, err := chain.ParseConfig(chainCfg)
	if err != nil {
		return nil, err
	}
	ret := Config{
		Config:      *cfg,
		LightNode:   "",
		McsContract: nil,
	}

	if ele, ok := chainCfg.Opts[chain.LightNode]; ok && ele != "" {
		ret.LightNode = ele
	}
	if ele, ok := chainCfg.Opts[chain.McsOpt]; ok && ele != "" {
		for _, addr := range strings.Split(ele, ",") {
			ret.McsContract = append(ret.McsContract, addr)
		}
	}
	return &ret, nil
}

'''
'''--- chains/tron/conn.go ---
package tron

import (
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/mapprotocol/compass/internal/constant"
	"google.golang.org/grpc"
	"math/big"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/lbtsm/gotron-sdk/pkg/client"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type Connection struct {
	endpoint                  string
	cli                       *client.GrpcClient
	log                       log15.Logger
	stop                      chan int
	reqTime, cacheBlockNumber int64
}

func NewConnection(endpoint string, log log15.Logger) *Connection {
	return &Connection{
		endpoint: endpoint,
		log:      log,
		stop:     make(chan int),
	}
}

// Connect starts the ethereum WS connection
func (c *Connection) Connect() error {
	c.log.Info("Connecting to tron chain...", "url", c.endpoint)
	c.cli = client.NewGrpcClient(c.endpoint)
	err := c.cli.Start(grpc.WithInsecure())
	if err != nil {
		return err
	}
	return nil
}

func (c *Connection) Keypair() *keystore.Key {
	return nil
}

func (c *Connection) Client() *ethclient.Client {
	return nil
}

func (c *Connection) Opts() *bind.TransactOpts {
	return nil
}

func (c *Connection) CallOpts() *bind.CallOpts {
	return nil
}

func (c *Connection) UnlockOpts() {
}

func (c *Connection) LockAndUpdateOpts(needNewNonce bool) error {
	return nil
}

// LatestBlock returns the latest block from the current chain
func (c *Connection) LatestBlock() (*big.Int, error) {
	// 1s req
	if time.Now().Unix()-c.reqTime < constant.ReqInterval {
		return big.NewInt(0).SetInt64(c.cacheBlockNumber), nil
	}

	bnum, err := c.cli.GetNowBlock()
	if err != nil {
		return nil, err
	}
	c.cacheBlockNumber = bnum.GetBlockHeader().GetRawData().Number
	c.reqTime = time.Now().Unix()

	return big.NewInt(0).SetInt64(bnum.GetBlockHeader().GetRawData().Number), nil
}

// EnsureHasBytecode asserts if contract code exists at the specified address
func (c *Connection) EnsureHasBytecode(addr ethcommon.Address) error {
	return nil
}

func (c *Connection) WaitForBlock(targetBlock *big.Int, delay *big.Int) error {
	return nil
}

func (c *Connection) Close() {
	if c.cli != nil {
		_ = c.cli.Conn.Close()
	}
	close(c.stop)
}

'''
'''--- chains/tron/proof.go ---
package tron

import (
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
	"math/big"
)

func assembleProof(log *types.Log, receipts []*types.Receipt, method string, fId msg.ChainId, proofType int64) ([]byte, error) {
	receipt, err := mapprotocol.GetTxReceipt(receipts[log.TxIndex])
	if err != nil {
		return nil, err
	}
	prf, err := proof.Get(types.Receipts(receipts), log.TxIndex)
	if err != nil {
		return nil, err
	}

	var key, ret []byte
	key = rlp.AppendUint64(key[:0], uint64(log.TxIndex))

	switch proofType {
	case constant.ProofTypeOfOracle:
		pd := proof.Data{
			BlockNum: big.NewInt(int64(log.BlockNumber)),
			ReceiptProof: proof.ReceiptProof{
				TxReceipt: *receipt,
				KeyIndex:  util.Key2Hex(key, len(prf)),
				Proof:     prf,
			},
		}
		ret, err = proof.Pack(fId, method, mapprotocol.OracleAbi, pd)
	default:
		panic("not support")
	}

	if err != nil {
		return nil, err
	}
	return ret, nil
}

'''
'''--- chains/tron/sync.go ---
package tron

import (
	"context"
	"fmt"
	eth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethdb/memorydb"
	"github.com/ethereum/go-ethereum/trie"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/mapprotocol/compass/pkg/util"
	"github.com/pkg/errors"
	"math/big"
	"strconv"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/chains"
)

type Maintainer struct {
	Log log15.Logger
}

func NewMaintainer(log log15.Logger) *Maintainer {
	return &Maintainer{Log: log}
}

func (m *Maintainer) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		time.Sleep(time.Hour * 2400)
	}()

	return nil
}

func (m *Maintainer) SetRouter(r chains.Router) {

}

type Handler func(*sync, *big.Int) (int, error)

type sync struct {
	*chain.CommonSync
	handler Handler
	conn    core.Connection
}

func newSync(cs *chain.CommonSync, handler Handler, conn core.Connection) *sync {
	return &sync{CommonSync: cs, handler: handler, conn: conn}
}

func (m *sync) Sync() error {
	m.Log.Info("Starting listener...")
	if !m.Cfg.SyncToMap {
		time.Sleep(time.Hour * 2400)
		return nil
	}
	var currentBlock = m.Cfg.StartBlock

	select {
	case <-m.Stop:
		return errors.New("polling terminated")
	default:
		for {
			latestBlock, err := m.conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "err", err)
				time.Sleep(constant.RetryLongInterval)
				continue
			}

			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.BlockConfirmations) == -1 {
				m.Log.Debug("Block not ready, will retry", "currentBlock", currentBlock, "latest", latestBlock)
				time.Sleep(constant.BalanceRetryInterval)
				continue
			}

			count, err := m.handler(m, currentBlock)
			if err != nil {
				m.Log.Error("Failed to get events for block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				util.Alarm(context.Background(), fmt.Sprintf("mos failed, chain=%s, err is %s", m.Cfg.Name, err.Error()))
				continue
			}

			_ = m.WaitUntilMsgHandled(count)

			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(constant.MessengerInterval)
			}
		}
	}
}

func messengerHandler(m *sync, current *big.Int) (int, error) {
	m.Log.Debug("Querying block for events", "block", current)
	count := 0
	for idx, addr := range m.Cfg.TronContract {
		query := m.BuildQuery(addr, m.Cfg.Events[0:0], current, current)
		query = eth.FilterQuery{
			FromBlock: current,
			ToBlock:   current,
		}
		logs, err := m.Conn.Client().FilterLogs(context.Background(), query)
		if err != nil {
			return 0, fmt.Errorf("unable to Filter Logs: %w", err)
		}

		if len(logs) == 0 {
			continue
		}

		key := strconv.FormatUint(uint64(m.Cfg.Id), 10) + "_" + current.String()
		for _, l := range logs {
			if !existTopic(l.Topics[0], m.Cfg.Events) {
				m.Log.Debug("ignore log, because topics not match", "blockNumber", l.BlockNumber, "logTopic", l.Topics[0])
				continue
			}

			var receipts []*types.Receipt
			if v, ok := proof.CacheReceipt[key]; ok {
				receipts = v
				m.Log.Info("use cache receipt", "latestBlock ", current, "txHash", l.TxHash)
			} else {
				txsHash, err := getTxsByBN(m.Conn.Client(), current)
				if err != nil {
					return 0, fmt.Errorf("unable to get tx hashes Logs: %w", err)
				}
				receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
				if err != nil {
					return 0, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
				}
				proof.CacheReceipt[key] = receipts
			}

			orderId := l.Data[:32]
			method := m.GetMethod(l.Topics[0])
			toChainID, _ := strconv.ParseUint(mapprotocol.MapId, 10, 64)
			m.Log.Info("Event found", "block", current, "txHash", l.TxHash, "logIdx", l.Index, "orderId", common.Bytes2Hex(orderId))
			proofType, err := chain.PreSendTx(idx, uint64(m.Cfg.Id), toChainID, current, orderId)
			if errors.Is(err, chain.OrderExist) {
				m.Log.Info("This orderId exist", "block", current, "txHash", l.TxHash, "orderId", common.Bytes2Hex(orderId))
				continue
			}
			if err != nil {
				return 0, err
			}

			tmp := l
			input, err := assembleProof(&tmp, receipts, method, m.Cfg.Id, proofType)
			if err != nil {
				return 0, err
			}

			message := msg.NewSwapWithProof(m.Cfg.Id, m.Cfg.MapChainID, []interface{}{input, orderId, l.BlockNumber, l.TxHash}, m.MsgCh)
			err = m.Router.Send(message)
			if err != nil {
				m.Log.Error("subscription error: failed to route message", "err", err)
				return 0, nil
			}
			count++
		}
	}

	return count, nil
}

func existTopic(target common.Hash, dst []constant.EventSig) bool {
	for _, d := range dst {
		if target == d.GetTopic() {
			return true
		}
	}
	return false
}

func oracleHandler(m *sync, latestBlock *big.Int) (int, error) {
	query := m.BuildQuery(m.Cfg.OracleNode, m.Cfg.Events[:1], latestBlock, latestBlock)
	logs, err := m.Conn.Client().FilterLogs(context.Background(), query)
	if err != nil {
		return 0, fmt.Errorf("sync unable to Filter Logs: %w", err)
	}
	if len(logs) == 0 {
		return 0, nil
	}
	m.Log.Info("Find log", "block", latestBlock, "log", len(logs))
	txsHash, err := getTxsByBN(m.Conn.Client(), latestBlock)
	if err != nil {
		return 0, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
	if err != nil {
		return 0, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
	}
	tr, _ := trie.New(common.Hash{}, trie.NewDatabase(memorydb.New()))
	tr = proof.DeriveTire(types.Receipts(receipts), tr)
	m.Log.Info("oracle tron receipt", "blockNumber", latestBlock, "hash", tr.Hash())
	receiptHash := tr.Hash()
	input, err := mapprotocol.OracleAbi.Methods[mapprotocol.MethodOfPropose].Inputs.Pack(latestBlock, receiptHash)

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, []interface{}{id, input}, m.MsgCh)
	err = m.Router.Send(message)
	if err != nil {
		m.Log.Error("subscription error: failed to route message", "err", err)
		return 0, nil
	}

	return 1, nil
}

func getTxsByBN(conn *ethclient.Client, number *big.Int) ([]common.Hash, error) {
	block, err := conn.TronBlockByNumber(context.Background(), number)
	if err != nil {
		return nil, err
	}

	txs := make([]common.Hash, 0, len(block.Transactions))
	for _, tmp := range block.Transactions {
		ele := common.HexToHash(tmp.Hash)
		txs = append(txs, ele)
	}
	return txs, nil
}

'''
'''--- chains/tron/writer.go ---
package tron

import (
	"context"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/lbtsm/gotron-sdk/pkg/store"

	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/pkg/errors"

	"github.com/lbtsm/gotron-sdk/pkg/proto/core"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/lbtsm/gotron-sdk/pkg/client/transaction"
	"github.com/lbtsm/gotron-sdk/pkg/keystore"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
)

var multiple = big.NewInt(420)

type Writer struct {
	cfg    *Config
	log    log15.Logger
	conn   *Connection
	stop   <-chan int
	sysErr chan<- error
	pass   []byte
	ks     *keystore.KeyStore
	acc    *keystore.Account
}

func newWriter(conn *Connection, cfg *Config, log log15.Logger, stop <-chan int, sysErr chan<- error, pass []byte) *Writer {
	return &Writer{
		cfg:    cfg,
		conn:   conn,
		log:    log,
		stop:   stop,
		sysErr: sysErr,
		pass:   pass,
	}
}

func (w *Writer) ResolveMessage(m msg.Message) bool {
	w.log.Info("Attempting to resolve message", "type", m.Type, "src", m.Source, "dst", m.Destination)
	switch m.Type {
	case msg.SyncFromMap:
		return w.syncMapToTron(m)
	case msg.SwapWithMapProof:
		return w.exeMcs(m)
	default:
		w.log.Error("Unknown message type received", "type", m.Type)
		return false
	}
}

func (w *Writer) syncMapToTron(m msg.Message) bool {
	var (
		errorCount int64
	)
	for {
		select {
		case <-w.stop:
			return false
		default:
			input := m.Payload[0].([]byte)
			tx, err := w.sendTx(w.cfg.LightNode, input)
			if err == nil {
				w.log.Info("Sync Map Header to tron chain tx execution", "tx", tx, "src", m.Source, "dst", m.Destination)
				err = w.txStatus(tx)
				if err != nil {
					w.log.Warn("TxHash Status is not successful, will retry", "err", err)
				} else {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range constant.IgnoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "id", m.Destination, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
			}
			errorCount++
			if errorCount >= 10 {
				util.Alarm(context.Background(), fmt.Sprintf("map2tron updateHeader failed, err is %s", err.Error()))
				errorCount = 0
			}
			time.Sleep(constant.BalanceRetryInterval)
		}
	}
}

func (w *Writer) exeMcs(m msg.Message) bool {
	var errorCount, checkIdCount int64
	for {
		select {
		case <-w.stop:
			return false
		default:
			addr := w.cfg.McsContract[m.Idx]
			orderId := m.Payload[1].([]byte)
			exits, err := w.checkOrderId(addr, orderId)
			if err != nil {
				w.log.Error("check orderId exist failed ", "err", err, "orderId", common.Bytes2Hex(orderId))
				checkIdCount++
				if checkIdCount == 10 {
					util.Alarm(context.Background(), fmt.Sprintf("writer mos checkOrderId failed, err is %s", err.Error()))
					checkIdCount = 0
				}
			}
			if exits {
				w.log.Info("Mcs orderId has been processed, Skip this request", "orderId", common.Bytes2Hex(orderId))
				m.DoneCh <- struct{}{}
				return true
			}

			var inputHash interface{}
			if len(m.Payload) > 3 {
				inputHash = m.Payload[3]
			}
			w.log.Info("Send transaction", "addr", addr, "srcHash", inputHash)
			mcsTx, err := w.sendTx(addr, m.Payload[0].([]byte))
			if err == nil {
				w.log.Info("Submitted cross tx execution", "src", m.Source, "dst", m.Destination, "srcHash", inputHash, "mcsTx", mcsTx)
				err = w.txStatus(mcsTx)
				if err != nil {
					w.log.Warn("TxHash Status is not successful, will retry", "err", err)
				} else {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError && errorCount >= 9 {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "srcHash", inputHash, "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range constant.IgnoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "id", m.Destination, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
				w.log.Warn("Execution failed, will retry", "srcHash", inputHash, "err", err)
			}
			errorCount++
			if errorCount >= 10 {
				w.mosAlarm(inputHash, err)
				errorCount = 0
			}
			time.Sleep(constant.TxRetryInterval)
		}
	}
}

func (w *Writer) sendTx(addr string, input []byte) (string, error) {
	// online estimateEnergy
	contract, err := w.conn.cli.TriggerConstantContractByEstimate(w.cfg.From, addr, input)
	if err != nil {
		w.log.Error("Failed to TriggerConstantContract EstimateEnergy", "err", err)
		return "", err
	}
	//// estimateEnergy
	//estimate, err := w.conn.cli.EstimateEnergy(w.cfg.From, addr, input, 0, "", 0)
	//if err != nil {
	//	w.log.Error("Failed to EstimateEnergy", "err", err)
	//	return "", err
	//}
	feeLimit := big.NewInt(0).Mul(big.NewInt(contract.EnergyUsed), multiple)
	w.log.Info("EstimateEnergy", "estimate", contract.EnergyUsed, "multiple", multiple, "feeLimit", feeLimit)
	// send transaction
	tx, err := w.conn.cli.TriggerContract(w.cfg.From, addr, input, feeLimit.Int64(), 0, "", 0)
	if err != nil {
		w.log.Error("Failed to TriggerContract", "err", err)
		return "", err
	}

	ks, acc, err := store.UnlockedKeystore(w.cfg.From, string(w.pass))
	if err != nil {
		w.log.Error("Failed to UnlockedKeystore", "err", err)
		return "", err
	}
	controller := transaction.NewController(w.conn.cli, ks, acc, tx.Transaction)
	if err = controller.ExecuteTransaction(); err != nil {
		w.log.Error("Failed to ExecuteTransaction", "err", err)
		return "", err
	}
	if controller.GetResultError() != nil {
		return "", fmt.Errorf("contro resultError is %v", controller.GetResultError())
	}
	return common.Bytes2Hex(tx.GetTxid()), nil
}

func (w Writer) txStatus(txHash string) error {
	var count int64
	time.Sleep(time.Second * 2)
	for {
		id, err := w.conn.cli.GetTransactionByID(txHash)
		if err != nil {
			w.log.Error("Failed to GetTransactionByID", "err", err)
			time.Sleep(constant.QueryRetryInterval)
			count++
			if count == 60 {
				return err
			}
			continue
		}
		if id.Ret[0].ContractRet == core.Transaction_Result_SUCCESS {
			w.log.Info("Tx receipt status is success", "hash", txHash)
			return nil
		}
		return fmt.Errorf("txHash(%s), status not success, current status is (%s)", txHash, id.Ret[0].ContractRet.String())
	}
}

func (w *Writer) mosAlarm(tx interface{}, err error) {
	util.Alarm(context.Background(), fmt.Sprintf("mos map2tron failed, srcHash=%v err is %s", tx, err.Error()))
}

func (w *Writer) checkOrderId(toAddress string, input []byte) (bool, error) {
	param := fmt.Sprintf("[{\"bytes32\":\"%v\"}]", common.Bytes2Hex(input))
	call, err := w.conn.cli.TriggerConstantContract(w.cfg.From, toAddress, "orderList(bytes32)", param)
	if err != nil {
		return false, fmt.Errorf("call orderList failed, %v", err.Error())
	}

	resp, err := mapprotocol.Mcs.Methods[mapprotocol.MethodOfOrderList].Outputs.Unpack(call.ConstantResult[0])
	if err != nil {
		return false, errors.Wrap(err, "output Unpack failed")
	}

	var exist bool
	err = mapprotocol.Mcs.Methods[mapprotocol.MethodOfOrderList].Outputs.Copy(&exist, resp)
	if err != nil {
		return false, errors.Wrap(err, "checkOrderId output copy failed")
	}
	return exist, nil
}

'''
'''--- cmd/compass/account.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package main

import (
	"fmt"
	"github.com/pkg/errors"
	"path/filepath"

	"github.com/lbtsm/gotron-sdk/pkg/account"

	log "github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/config"
	"github.com/mapprotocol/compass/keystore"
	"github.com/urfave/cli/v2"
)

// dataHandler is a struct which wraps any extra data our CMD functions need that cannot be passed through parameters
type dataHandler struct {
	datadir string
}

// wrapHandler takes in a Cmd function (all declared below) and wraps
// it in the correct signature for the Cli Commands
func wrapHandler(hdl func(*cli.Context, *dataHandler) error) cli.ActionFunc {

	return func(ctx *cli.Context) error {
		err := startLogger(ctx)
		if err != nil {
			return err
		}

		datadir, err := getDataDir(ctx)
		if err != nil {
			return fmt.Errorf("failed to access the datadir: %w", err)
		}

		return hdl(ctx, &dataHandler{datadir: datadir})
	}
}

// handleImportCmd imports external keystores into the bridge
func handleImportCmd(ctx *cli.Context, dHandler *dataHandler) error {
	log.Info("Importing key...")

	if !ctx.Bool(config.TronFlag.Name) {
		return errors.New("only support tron")
	}
	var err error

	var password []byte = nil
	if pwdflag := ctx.String(config.PasswordFlag.Name); pwdflag != "" {
		password = []byte(pwdflag)
	}
	privkeyflag := ctx.String(config.PrivateKeyFlag.Name)
	if privkeyflag == "" {
		return fmt.Errorf("privateKey is nil")
	}
	if password == nil {
		password = keystore.GetPassword("Enter password to encrypt keystore file:")
	}

	name := ctx.String(config.TronKeyNameFlag.Name)
	keyName, err := account.ImportFromPrivateKey(privkeyflag, name, string(password))
	if err != nil {
		return fmt.Errorf("tron import private key failed, err is %v", err)
	}
	fmt.Println("tron keystore save, key is", keyName, " please save you config file")
	return nil
}

// getDataDir obtains the path to the keystore and returns it as a string
func getDataDir(ctx *cli.Context) (string, error) {
	// key directory is datadir/keystore/
	if dir := ctx.String(config.KeystorePathFlag.Name); dir != "" {
		datadir, err := filepath.Abs(dir)
		if err != nil {
			return "", err
		}
		log.Trace(fmt.Sprintf("Using keystore dir: %s", datadir))
		return datadir, nil
	}
	return "", fmt.Errorf("datadir flag not supplied")
}

'''
'''--- cmd/compass/main.go ---
package main

import (
	"errors"
	"os"
	"strconv"

	"github.com/mapprotocol/compass/chains/tron"

	"github.com/mapprotocol/compass/chains/bttc"

	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/chains/conflux"
	"github.com/mapprotocol/compass/chains/platon"

	"github.com/mapprotocol/compass/chains/bsc"

	log "github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/chains/eth2"
	"github.com/mapprotocol/compass/chains/ethereum"
	"github.com/mapprotocol/compass/chains/klaytn"
	"github.com/mapprotocol/compass/chains/matic"
	"github.com/mapprotocol/compass/chains/near"
	"github.com/mapprotocol/compass/config"
	"github.com/mapprotocol/compass/core"
	chain2 "github.com/mapprotocol/compass/internal/chain"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/urfave/cli/v2"
)

var app = cli.NewApp()

var cliFlags = []cli.Flag{
	config.ConfigFileFlag,
	config.VerbosityFlag,
	config.KeystorePathFlag,
	config.KeyPathFlag,
	config.BlockstorePathFlag,
	config.FreshStartFlag,
	config.LatestBlockFlag,
	config.SkipErrorFlag,
}

var devFlags = []cli.Flag{
	config.TestKeyFlag,
}

var importFlags = []cli.Flag{
	config.EthereumImportFlag,
	config.PrivateKeyFlag,
	config.PasswordFlag,
	config.KeystorePathFlag,
	config.TronFlag,
	config.TronKeyNameFlag,
}

var accountCommand = cli.Command{
	Name:  "accounts",
	Usage: "manage bridge keystore",
	Description: "The accounts command is used to manage the bridge keystore.\n" +
		"\tTo import a tron private key file: compass accounts import --privateKey private_key",
	Subcommands: []*cli.Command{
		{
			Action: wrapHandler(handleImportCmd),
			Name:   "import",
			Usage:  "import bridge keystore",
			Flags:  importFlags,
			Description: "The import subcommand is used to import a keystore for the bridge.\n" +
				"\tA path to the keystore must be provided\n" +
				"\tUse --privateKey to create a keystore from a provided private key.",
		},
	},
}

var maintainerCommand = cli.Command{
	Name:  "maintainer",
	Usage: "manage maintainer operations",
	Description: "The maintainer command is used to manage maintainer on Map chain.\n" +
		"\tTo register an account : compass relayers register --account '0x0...'",
	Action:      maintainer,
	Subcommands: []*cli.Command{},
	Flags:       append(app.Flags, cliFlags...),
}

var messengerCommand = cli.Command{
	Name:        "messenger",
	Usage:       "manage messenger operations",
	Description: "The messenger command is used to sync the log information of transactions in the block",
	Action:      messenger,
	Flags:       append(app.Flags, cliFlags...),
}

var oracleCommand = cli.Command{
	Name:        "oracle",
	Usage:       "manage oracle operations",
	Description: "The oracle command is used to sync the log information of transactions in the block",
	Action:      oracle,
	Flags:       append(app.Flags, cliFlags...),
}

var (
	Version = "1.2.1"
)

// init initializes CLI
func init() {
	//app.Action = run
	app.Copyright = "Copyright 2021 MAP Protocol 2021 Authors"
	app.Name = "compass"
	app.Usage = "Compass"
	app.Authors = []*cli.Author{{Name: "MAP Protocol 2021"}}
	app.Version = Version
	app.EnableBashCompletion = true
	app.Commands = []*cli.Command{
		&accountCommand,
		&maintainerCommand,
		&messengerCommand,
		&oracleCommand,
	}

	app.Flags = append(app.Flags, cliFlags...)
	app.Flags = append(app.Flags, devFlags...)
}

func main() {
	if err := app.Run(os.Args); err != nil {
		log.Error(err.Error())
		os.Exit(1)
	}
}

func startLogger(ctx *cli.Context) error {
	logger := log.Root()
	handler := logger.GetHandler()
	var lvl log.Lvl

	if lvlToInt, err := strconv.Atoi(ctx.String(config.VerbosityFlag.Name)); err == nil {
		lvl = log.Lvl(lvlToInt)
	} else if lvl, err = log.LvlFromString(ctx.String(config.VerbosityFlag.Name)); err != nil {
		return err
	}
	log.Root().SetHandler(log.LvlFilterHandler(lvl, handler))

	return nil
}

func maintainer(ctx *cli.Context) error {
	return run(ctx, mapprotocol.RoleOfMaintainer)
}

func messenger(ctx *cli.Context) error {
	return run(ctx, mapprotocol.RoleOfMessenger)
}

func oracle(ctx *cli.Context) error {
	return run(ctx, mapprotocol.RoleOfOracle)
}

func run(ctx *cli.Context, role mapprotocol.Role) error {
	err := startLogger(ctx)
	if err != nil {
		return err
	}

	log.Info("Starting Compass...")

	cfg, err := config.GetConfig(ctx)
	if err != nil {
		return err
	}

	log.Debug("Config on initialization...", "config", *cfg)

	util.Init(cfg.Other.Env, cfg.Other.MonitorUrl)
	// Used to signal core shutdown due to fatal error
	sysErr := make(chan error)
	mapcid, err := strconv.Atoi(cfg.MapChain.Id)
	if err != nil {
		return err
	}
	c := core.NewCore(sysErr, msg.ChainId(mapcid), role)
	// merge map chain
	allChains := make([]config.RawChainConfig, 0, len(cfg.Chains)+1)
	allChains = append(allChains, cfg.MapChain)
	allChains = append(allChains, cfg.Chains...)

	for idx, chain := range allChains {
		ks := chain.KeystorePath
		if ks == "" {
			ks = ctx.String(config.KeyPathFlag.Name)
		}
		chainId, err := strconv.Atoi(chain.Id)
		if err != nil {
			return err
		}
		// write Map chain id to opts
		mapprotocol.MapId = cfg.MapChain.Id
		chain.Opts[config.MapChainID] = cfg.MapChain.Id
		chainConfig := &core.ChainConfig{
			Name:             chain.Name,
			Id:               msg.ChainId(chainId),
			Endpoint:         chain.Endpoint,
			From:             chain.From,
			Network:          chain.Network,
			KeystorePath:     ks,
			NearKeystorePath: chain.KeystorePath,
			BlockstorePath:   ctx.String(config.BlockstorePathFlag.Name),
			FreshStart:       ctx.Bool(config.FreshStartFlag.Name),
			LatestBlock:      ctx.Bool(config.LatestBlockFlag.Name),
			Opts:             chain.Opts,
			SkipError:        ctx.Bool(config.SkipErrorFlag.Name),
		}
		var (
			newChain core.Chain
		)

		logger := log.Root().New("chain", chainConfig.Name)
		logger.Info("This task set skip error", "skip", ctx.Bool(config.SkipErrorFlag.Name))

		switch chain.Type {
		case chains.Ethereum:
			newChain, err = ethereum.InitializeChain(chainConfig, logger, sysErr, role)
			if err != nil {
				return err
			}
			if idx == 0 {
				mapprotocol.GlobalMapConn = newChain.(*chain2.Chain).EthClient()
				mapprotocol.Init2GetEth22MapNumber(common.HexToAddress(chainConfig.Opts[chain2.LightNode]))
				mapprotocol.InitOtherChain2MapHeight(common.HexToAddress(chainConfig.Opts[chain2.LightNode]))
				mapprotocol.InitLightManager(common.HexToAddress(chainConfig.Opts[chain2.LightNode]))
			}
		case chains.Near:
			newChain, err = near.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Bsc:
			newChain, err = bsc.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Matic:
			newChain, err = matic.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Klaytn:
			newChain, err = klaytn.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Eth2:
			newChain, err = eth2.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Platon:
			newChain, err = platon.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Conflux:
			newChain, err = conflux.InitializeChain(chainConfig, logger, sysErr, role)
		case chains.Bttc:
			newChain, err = bttc.NewChain(chainConfig, logger, sysErr, role)
		case chains.Tron:
			newChain, err = tron.NewChain(chainConfig, logger, sysErr, role)
		default:
			return errors.New("unrecognized Chain Type")
		}
		if err != nil {
			return err
		}

		mapprotocol.OnlineChaId[chainConfig.Id] = chainConfig.Name
		c.AddChain(newChain)
	}
	c.Start()

	return nil
}

'''
'''--- config/config.go ---
package config

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ethereum/go-ethereum/log"
	"github.com/urfave/cli/v2"
)

const DefaultConfigPath = "./config.json"
const DefaultKeystorePath = "./keys"
const MapChainID = "mapChainId"

type Config struct {
	MapChain RawChainConfig   `json:"mapchain"`
	Chains   []RawChainConfig `json:"chains"`
	Other    Construction     `json:"other,omitempty"`
}

// RawChainConfig is parsed directly from the config file and should be using to construct the core.ChainConfig
type RawChainConfig struct {
	Name         string            `json:"name"`
	Type         string            `json:"type"`
	Id           string            `json:"id"`       // ChainID
	Endpoint     string            `json:"endpoint"` // url for rpc endpoint
	From         string            `json:"from"`     // address of key to use
	Network      string            `json:"network"`
	KeystorePath string            `json:"keystorePath"`
	Opts         map[string]string `json:"opts"`
}

type Construction struct {
	MonitorUrl string `json:"monitor_url,omitempty"`
	Env        string `json:"env,omitempty"`
}

func (c *Config) ToJSON(file string) *os.File {
	var (
		newFile *os.File
		err     error
	)

	var raw []byte
	if raw, err = json.Marshal(*c); err != nil {
		log.Warn("error marshalling json", "err", err)
		os.Exit(1)
	}

	newFile, err = os.Create(file)
	if err != nil {
		log.Warn("error creating config file", "err", err)
	}
	_, err = newFile.Write(raw)
	if err != nil {
		log.Warn("error writing to config file", "err", err)
	}

	if err := newFile.Close(); err != nil {
		log.Warn("error closing file", "err", err)
	}
	return newFile
}

func (c *Config) validate() error {
	for _, chain := range c.Chains {
		if chain.Id == "" {
			return fmt.Errorf("required field chain.Id empty for chain %s", chain.Id)
		}
		if chain.Type == "" {
			return fmt.Errorf("required field chain.Type empty for chain %s", chain.Id)
		}
		if chain.Endpoint == "" {
			return fmt.Errorf("required field chain.Endpoint empty for chain %s", chain.Id)
		}
		if chain.Name == "" {
			return fmt.Errorf("required field chain.Name empty for chain %s", chain.Id)
		}
		if chain.From == "" {
			return fmt.Errorf("required field chain.From empty for chain %s", chain.Id)
		}
	}
	// check map chain
	if c.MapChain.Id == "" {
		return fmt.Errorf("required field chain.Id empty for chain %s", c.MapChain.Id)
	}
	if c.MapChain.Endpoint == "" {
		return fmt.Errorf("required field mapchain.Endpoint empty for chain %s", c.MapChain.Id)
	}
	if c.MapChain.From == "" {
		return fmt.Errorf("required field chain.From empty for chain %s", c.MapChain.Id)
	}

	return nil
}

func GetConfig(ctx *cli.Context) (*Config, error) {
	var fig Config
	path := DefaultConfigPath
	if file := ctx.String(ConfigFileFlag.Name); file != "" {
		path = file
	}
	err := loadConfig(path, &fig)
	if err != nil {
		log.Warn("err loading json file", "err", err.Error())
		return &fig, err
	}
	log.Debug("Loaded config", "path", path)
	err = fig.validate()
	// fill map chain config
	fig.MapChain.Type = "ethereum"
	fig.MapChain.Name = "map"

	if err != nil {
		return nil, err
	}
	return &fig, nil
}

func loadConfig(file string, config *Config) error {
	ext := filepath.Ext(file)
	fp, err := filepath.Abs(file)
	if err != nil {
		return err
	}

	log.Debug("Loading configuration", "path", filepath.Clean(fp))

	f, err := os.Open(filepath.Clean(fp))
	if err != nil {
		return err
	}

	if ext == ".json" {
		if err = json.NewDecoder(f).Decode(&config); err != nil {
			return err
		}
	} else {
		return fmt.Errorf("unrecognized extention: %s", ext)
	}

	return nil
}

'''
'''--- config/flags.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package config

import (
	log "github.com/ChainSafe/log15"
	"github.com/urfave/cli/v2"
)

var (
	ConfigFileFlag = &cli.StringFlag{
		Name:  "config",
		Usage: "JSON configuration file",
	}

	VerbosityFlag = &cli.StringFlag{
		Name:  "verbosity",
		Usage: "Supports levels crit (silent) to trce (trace)",
		Value: log.LvlInfo.String(),
	}

	KeystorePathFlag = &cli.StringFlag{
		Name:  "keystore",
		Usage: "Path to keystore directory",
		Value: DefaultKeystorePath,
	}

	KeyPathFlag = &cli.StringFlag{
		Name:  "keystorePath",
		Usage: "Path to keystore",
	}

	TronFlag = &cli.BoolFlag{
		Name:  "tron",
		Usage: "Flag of tron",
		Value: false,
	}
	TronKeyNameFlag = &cli.StringFlag{
		Name:  "tronKeyName",
		Usage: "Flag of tron",
		Value: "",
	}

	BlockstorePathFlag = &cli.StringFlag{
		Name:  "blockstore",
		Usage: "Specify path for blockstore",
		Value: "", // Empty will use home dir
	}

	FreshStartFlag = &cli.BoolFlag{
		Name:  "fresh",
		Usage: "Disables loading from blockstore at start. Opts will still be used if specified.",
	}

	LatestBlockFlag = &cli.BoolFlag{
		Name:  "latest",
		Usage: "Overrides blockstore and start block, starts from latest block",
	}

	SkipErrorFlag = &cli.BoolFlag{
		Name:  "skipError",
		Usage: "Skip Error",
	}
)

var (
	PasswordFlag = &cli.StringFlag{
		Name:  "password",
		Usage: "Password used to encrypt the keystore. Used with --generate, --import, or --unlock",
	}
)

var (
	EthereumImportFlag = &cli.BoolFlag{
		Name:  "ethereum",
		Usage: "Import an existing ethereum keystore, such as from geth.",
	}
	PrivateKeyFlag = &cli.StringFlag{
		Name:  "privateKey",
		Usage: "Import a hex representation of a private key into a keystore.",
	}
)

var (
	TestKeyFlag = &cli.StringFlag{
		Name:  "testkey",
		Usage: "Applies a predetermined test keystore to the chains.",
	}
)

'''
'''--- config/pri_test.go ---
package config

import (
	"encoding/hex"
	"io/ioutil"
	"testing"

	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/mapprotocol/atlas/accounts/keystore"
)

func Test_GetPrivateKeyFromFile(t *testing.T) {
	password := ""
	keyfile := "/Users/xm/Desktop/WL/code/atlas/node-1/keystore/UTC--2022-06-15T07-51-25.301943000Z--e0dc8d7f134d0a79019bef9c2fd4b2013a64fcd6"

	file, err := ioutil.ReadFile(keyfile)
	if err != nil {
		fmt.Printf("failed to read the keyfile at '%s': %v", keyfile, err)
	}
	key, err := keystore.DecryptKey(file, password)
	if err != nil {
		panic(fmt.Errorf("error decrypting key: %v", err))
	}

	private := key.PrivateKey
	fmt.Println("==============================  private key:", hex.EncodeToString(crypto.FromECDSA(private)))
	fmt.Println("==============================  public key:", common.Bytes2Hex(crypto.FromECDSAPub(&private.PublicKey)))
}

'''
'''--- connections/eth2/connection.go ---
package eth2

import (
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"math/big"

	"github.com/mapprotocol/compass/core"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/connections/ethereum"
	"github.com/mapprotocol/compass/internal/eth2"
)

type Connection struct {
	endpoint, eth2Endpoint string
	core.Connection
	eth2Conn *eth2.Client
}

// NewConnection returns an uninitialized connection, must call Connection.Connect() before using.
func NewConnection(endpoint, eth2Endpoint string, http bool, kp *keystore.Key, log log15.Logger, gasLimit, gasPrice *big.Int,
	gasMultiplier float64) core.Eth2Connection {
	conn := ethereum.NewConnection(endpoint, http, kp, log, gasLimit, gasPrice, gasMultiplier)
	return &Connection{
		Connection:   conn,
		endpoint:     endpoint,
		eth2Endpoint: eth2Endpoint,
	}
}

func (c *Connection) Eth2Client() *eth2.Client {
	return c.eth2Conn
}

// Connect starts the ethereum WS connection
func (c *Connection) Connect() error {
	if err := c.Connection.Connect(); err != nil {
		return err
	}

	client, err := eth2.DialHttp(c.eth2Endpoint)
	if err != nil {
		return err
	}
	c.eth2Conn = client
	return nil
}

'''
'''--- connections/ethereum/connection.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package ethereum

import (
	"context"
	"errors"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"math/big"
	"sync"
	"time"

	"github.com/mapprotocol/compass/core"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethcrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type Connection struct {
	endpoint                  string
	http                      bool
	kp                        *keystore.Key
	gasLimit                  *big.Int
	maxGasPrice               *big.Int
	gasMultiplier             *big.Float
	conn                      *ethclient.Client
	opts                      *bind.TransactOpts
	callOpts                  *bind.CallOpts
	nonce                     uint64
	optsLock                  sync.Mutex
	log                       log15.Logger
	stop                      chan int // All routines should exit when this channel is closed
	reqTime, cacheBlockNumber int64
}

// NewConnection returns an uninitialized connection, must call Connection.Connect() before using.
func NewConnection(endpoint string, http bool, kp *keystore.Key, log log15.Logger, gasLimit, gasPrice *big.Int,
	gasMultiplier float64) core.Connection {
	bigFloat := new(big.Float).SetFloat64(gasMultiplier)
	return &Connection{
		endpoint:      endpoint,
		http:          http,
		kp:            kp,
		gasLimit:      gasLimit,
		maxGasPrice:   gasPrice,
		gasMultiplier: bigFloat,
		log:           log,
		stop:          make(chan int),
	}
}

// Connect starts the ethereum WS connection
func (c *Connection) Connect() error {
	c.log.Info("Connecting to ethereum chain...", "url", c.endpoint)
	var rpcClient *rpc.Client
	var err error
	// Start http or ws client
	if c.http {
		rpcClient, err = rpc.DialHTTP(c.endpoint)
	} else {
		rpcClient, err = rpc.DialContext(context.Background(), c.endpoint)
	}
	if err != nil {
		return err
	}
	c.conn = ethclient.NewClient(rpcClient, c.endpoint)

	// Construct tx opts, call opts, and nonce mechanism
	opts, _, err := c.newTransactOpts(big.NewInt(0), c.gasLimit, c.maxGasPrice)
	if err != nil {
		return err
	}
	c.opts = opts
	c.nonce = 0
	return nil
}

// newTransactOpts builds the TransactOpts for the connection's keypair.
func (c *Connection) newTransactOpts(value, gasLimit, gasPrice *big.Int) (*bind.TransactOpts, uint64, error) {
	if c.kp == nil {
		return nil, 0, nil
	}
	privateKey := c.kp.PrivateKey
	address := ethcrypto.PubkeyToAddress(privateKey.PublicKey)

	nonce, err := c.conn.PendingNonceAt(context.Background(), address)
	if err != nil {
		return nil, 0, err
	}

	id, err := c.conn.ChainID(context.Background())
	if err != nil {
		return nil, 0, err
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, id)
	if err != nil {
		return nil, 0, err
	}

	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = value
	auth.GasLimit = uint64(gasLimit.Int64())
	auth.GasPrice = gasPrice
	auth.Context = context.Background()

	return auth, nonce, nil
}

func (c *Connection) Keypair() *keystore.Key {
	return c.kp
}

func (c *Connection) Client() *ethclient.Client {
	return c.conn
}

func (c *Connection) Opts() *bind.TransactOpts {
	return c.opts
}

func (c *Connection) CallOpts() *bind.CallOpts {
	return c.callOpts
}

func (c *Connection) SafeEstimateGas(ctx context.Context) (*big.Int, error) {
	var suggestedGasPrice *big.Int
	c.log.Debug("Fetching gasPrice from node")
	nodePriceEstimate, err := c.conn.SuggestGasPrice(context.TODO())
	if err != nil {
		return nil, err
	} else {
		suggestedGasPrice = nodePriceEstimate
	}

	gasPrice := multiplyGasPrice(suggestedGasPrice, c.gasMultiplier)

	// Check we aren't exceeding our limit
	if gasPrice.Cmp(c.maxGasPrice) == 1 {
		return c.maxGasPrice, nil
	} else {
		return gasPrice, nil
	}
}

func (c *Connection) EstimateGasLondon(ctx context.Context, baseFee *big.Int) (*big.Int, *big.Int, error) {
	var maxPriorityFeePerGas, maxFeePerGas *big.Int
	if c.maxGasPrice.Cmp(baseFee) < 0 {
		maxPriorityFeePerGas = big.NewInt(1000000000)
		maxFeePerGas = new(big.Int).Add(c.maxGasPrice, maxPriorityFeePerGas)
		return maxPriorityFeePerGas, maxFeePerGas, nil
	}

	maxPriorityFeePerGas, err := c.conn.SuggestGasTipCap(context.TODO())
	if err != nil {
		return nil, nil, err
	}
	c.log.Info("EstimateGasLondon", "maxPriorityFeePerGas", maxPriorityFeePerGas)

	maxFeePerGas = new(big.Int).Add(
		maxPriorityFeePerGas,
		baseFee,
	)

	// Check we aren't exceeding our limit
	if maxFeePerGas.Cmp(c.maxGasPrice) == 1 {
		c.log.Info("EstimateGasLondon maxFeePerGas more than set", "maxFeePerGas", maxFeePerGas, "baseFee", baseFee)
		maxPriorityFeePerGas.Sub(c.maxGasPrice, baseFee)
		maxFeePerGas = c.maxGasPrice
	}
	return maxPriorityFeePerGas, maxFeePerGas, nil
}

func multiplyGasPrice(gasEstimate *big.Int, gasMultiplier *big.Float) *big.Int {
	gasEstimateFloat := new(big.Float).SetInt(gasEstimate)
	result := gasEstimateFloat.Mul(gasEstimateFloat, gasMultiplier)
	gasPrice := new(big.Int)
	result.Int(gasPrice)
	return gasPrice
}

// LockAndUpdateOpts acquires a lock on the opts before updating the nonce
// and gas price.
func (c *Connection) LockAndUpdateOpts(needNewNonce bool) error {
	//c.optsLock.Lock()
	head, err := c.conn.HeaderByNumber(context.TODO(), nil)
	// cos map chain dont have this section in return,this err will be raised
	if err != nil && err.Error() != "missing required field 'sha3Uncles' for Header" {
		c.UnlockOpts()
		c.log.Error("LockAndUpdateOpts HeaderByNumber", "err", err)
		return err
	}

	if head.BaseFee != nil {
		c.opts.GasTipCap, c.opts.GasFeeCap, err = c.EstimateGasLondon(context.TODO(), head.BaseFee)
		// Both gasPrice and (maxFeePerGas or maxPriorityFeePerGas) cannot be specified: https://github.com/ethereum/go-ethereum/blob/95bbd46eabc5d95d9fb2108ec232dd62df2f44ab/accounts/abi/bind/base.go#L254
		c.opts.GasPrice = nil
		if err != nil {
			// if EstimateGasLondon failed, fall back to suggestGasPrice
			c.opts.GasPrice, err = c.conn.SuggestGasPrice(context.TODO())
			if err != nil {
				//c.UnlockOpts()
				return err
			}
		}
		c.log.Info("LockAndUpdateOpts ", "head.BaseFee", head.BaseFee, "maxGasPrice", c.maxGasPrice,
			"gasTipCap", c.opts.GasTipCap, "gasFeeCap", c.opts.GasFeeCap)
	} else {
		var gasPrice *big.Int
		gasPrice, err = c.SafeEstimateGas(context.TODO())
		if err != nil {
			//c.UnlockOpts()
			return err
		}
		c.opts.GasPrice = gasPrice
	}

	if !needNewNonce {
		return nil
	}
	nonce, err := c.conn.PendingNonceAt(context.Background(), c.opts.From)
	if err != nil {
		//c.optsLock.Unlock()
		return err
	}
	c.opts.Nonce.SetUint64(nonce)
	return nil
}

func (c *Connection) UnlockOpts() {
	//c.optsLock.Unlock()
}

// LatestBlock returns the latest block from the current chain
func (c *Connection) LatestBlock() (*big.Int, error) {
	// 1s req
	if time.Now().Unix()-c.reqTime < constant.ReqInterval {
		return big.NewInt(0).SetInt64(c.cacheBlockNumber), nil
	}
	bnum, err := c.conn.BlockNumber(context.Background())
	if err != nil {
		return nil, err
	}
	c.cacheBlockNumber = int64(bnum)
	c.reqTime = time.Now().Unix()
	return big.NewInt(0).SetUint64(bnum), nil
}

// EnsureHasBytecode asserts if contract code exists at the specified address
func (c *Connection) EnsureHasBytecode(addr ethcommon.Address) error {
	//code, err := c.conn.CodeAt(context.Background(), addr, nil)
	//if err != nil {
	//	return err
	//}
	//
	//if len(code) == 0 {
	//	return fmt.Errorf("no bytecode found at %s", addr.Hex())
	//}
	return nil
}

// WaitForBlock will poll for the block number until the current block is equal or greater.
// If delay is provided it will wait until currBlock - delay = targetBlock
func (c *Connection) WaitForBlock(targetBlock *big.Int, delay *big.Int) error {
	for {
		select {
		case <-c.stop:
			return errors.New("connection terminated")
		default:
			currBlock, err := c.LatestBlock()
			if err != nil {
				return err
			}

			if delay != nil {
				currBlock.Sub(currBlock, delay)
			}

			// Equal or greater than target
			if currBlock.Cmp(targetBlock) >= 0 {
				return nil
			}
			c.log.Trace("Block not ready, waiting", "target", targetBlock, "current", currBlock, "delay", delay)
			time.Sleep(constant.BlockRetryInterval)
			continue
		}
	}
}

// Close terminates the client connection and stops any running routines
func (c *Connection) Close() {
	if c.conn != nil {
		c.conn.Close()
	}
	close(c.stop)
}

'''
'''--- connections/near/connection.go ---
package near

import (
	"context"
	"errors"
	"math/big"
	"sync"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/atlas/accounts/abi/bind"
	nearclient "github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/client/block"
	"github.com/mapprotocol/near-api-go/pkg/types/key"
)

var BlockRetryInterval = time.Second * 5

type Connection struct {
	endpoint      string
	http          bool
	kp            *key.KeyPair
	gasLimit      *big.Int
	maxGasPrice   *big.Int
	gasMultiplier *big.Float
	conn          *nearclient.Client
	opts          *bind.TransactOpts
	callOpts      *bind.CallOpts
	nonce         uint64
	optsLock      sync.Mutex
	log           log15.Logger
	stop          chan int // All routines should exit when this channel is closed
}

// NewConnection returns an uninitialized connection, must call Connection.Connect() before using.
func NewConnection(endpoint string, http bool, kp *key.KeyPair, log log15.Logger, gasLimit, gasPrice *big.Int,
	gasMultiplier *big.Float) *Connection {
	return &Connection{
		endpoint:      endpoint,
		http:          http,
		kp:            kp,
		gasLimit:      gasLimit,
		maxGasPrice:   gasPrice,
		gasMultiplier: gasMultiplier,
		log:           log,
		stop:          make(chan int),
	}
}

// Connect starts the ethereum WS connection
func (c *Connection) Connect() error {
	c.log.Info("Connecting to near chain...", "url", c.endpoint)
	client, err := nearclient.NewClient(c.endpoint)
	if err != nil {
		return err
	}

	resp, err := client.NetworkStatusValidators(context.Background())
	if err != nil {
		return err
	}

	c.log.Info("Connecting success near chain...", "chainId", resp.ChainID)
	c.conn = &client
	return nil
}

func (c *Connection) Keypair() *key.KeyPair {
	return c.kp
}

func (c *Connection) Client() *nearclient.Client {
	return c.conn
}

func (c *Connection) Opts() *bind.TransactOpts {
	return c.opts
}

func (c *Connection) CallOpts() *bind.CallOpts {
	return c.callOpts
}

func (c *Connection) SafeEstimateGas(ctx context.Context) (*big.Int, error) {
	return c.maxGasPrice, nil
}

func (c *Connection) EstimateGasLondon(ctx context.Context, baseFee *big.Int) (*big.Int, *big.Int, error) {
	var maxPriorityFeePerGas *big.Int
	var maxFeePerGas *big.Int

	return maxPriorityFeePerGas, maxFeePerGas, nil
}

func multiplyGasPrice(gasEstimate *big.Int, gasMultiplier *big.Float) *big.Int {

	gasEstimateFloat := new(big.Float).SetInt(gasEstimate)

	result := gasEstimateFloat.Mul(gasEstimateFloat, gasMultiplier)

	gasPrice := new(big.Int)

	result.Int(gasPrice)

	return gasPrice
}

// LockAndUpdateOpts acquires a lock on the opts before updating the nonce
// and gas price.
func (c *Connection) LockAndUpdateOpts(needNewNonce bool) error {
	return nil
}

func (c *Connection) UnlockOpts() {
}

// LatestBlock returns the latest block from the current chain
func (c *Connection) LatestBlock() (*big.Int, error) {
	resp, err := c.conn.BlockDetails(context.Background(), block.FinalityFinal())
	if err != nil {
		return nil, err
	}

	return big.NewInt(0).SetUint64(resp.Header.Height), nil
}

// EnsureHasBytecode asserts if contract code exists at the specified address
func (c *Connection) EnsureHasBytecode(addr string) error {
	return nil
}

// WaitForBlock will poll for the block number until the current block is equal or greater.
// If delay is provided it will wait until currBlock - delay = targetBlock
func (c *Connection) WaitForBlock(targetBlock *big.Int, delay *big.Int) error {
	for {
		select {
		case <-c.stop:
			return errors.New("connection terminated")
		default:
			currBlock, err := c.LatestBlock()
			if err != nil {
				return err
			}

			if delay != nil {
				currBlock.Sub(currBlock, delay)
			}

			// Equal or greater than target
			if currBlock.Cmp(targetBlock) >= 0 {
				return nil
			}
			c.log.Trace("Block not ready, waiting", "target", targetBlock, "current", currBlock, "delay", delay)
			time.Sleep(BlockRetryInterval)
			continue
		}
	}
}

// Close terminates the client connection and stops any running routines
func (c *Connection) Close() {
	//if c.conn != nil {
	//	c.conn.Close()
	//}
	close(c.stop)
}

'''
'''--- core/chain.go ---
package core

import (
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"math/big"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/eth2"
	"github.com/mapprotocol/compass/internal/klaytn"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type Chain interface {
	Start() error // Start chain
	SetRouter(*Router)
	Id() msg.ChainId
	Name() string
	Stop()
	Conn() Connection
}

type ChainConfig struct {
	Name             string            // Human-readable chain name
	Id               msg.ChainId       // ChainID
	Endpoint         string            // url for rpc endpoint
	Network          string            //
	From             string            // address of key to use
	KeystorePath     string            // Location of key files
	NearKeystorePath string            // Location of key files
	Insecure         bool              // Indicated whether the test keyring should be used
	BlockstorePath   string            // Location of blockstore
	FreshStart       bool              // If true, blockstore is ignored at start.
	LatestBlock      bool              // If true, overrides blockstore or latest block in config and starts from current block
	Opts             map[string]string // Per chain options
	SkipError        bool              // Flag of Skip Error
}

type Connection interface {
	Connect() error
	Keypair() *keystore.Key
	Opts() *bind.TransactOpts
	CallOpts() *bind.CallOpts
	LockAndUpdateOpts(bool) error
	UnlockOpts()
	Client() *ethclient.Client
	EnsureHasBytecode(address common.Address) error
	LatestBlock() (*big.Int, error)
	WaitForBlock(block *big.Int, delay *big.Int) error
	Close()
}

type KConnection interface {
	Connection
	KClient() *klaytn.Client
}

type Eth2Connection interface {
	Connection
	Eth2Client() *eth2.Client
}

type CreateConn func(string, bool, *keystore.Key, log15.Logger, *big.Int, *big.Int, float64) Connection

'''
'''--- core/core.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package core

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/mapprotocol/compass/mapprotocol"

	utilcore "github.com/ChainSafe/chainbridge-utils/core"
	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/msg"
)

type Core struct {
	Registry []Chain
	route    *Router
	log      log15.Logger
	sysErr   <-chan error
	role     mapprotocol.Role
}

func NewCore(sysErr <-chan error, mapcid msg.ChainId, role mapprotocol.Role) *Core {
	return &Core{
		Registry: make([]Chain, 0),
		route:    NewRouter(log15.New("system", "router"), mapcid),
		log:      log15.New("system", "core"),
		sysErr:   sysErr,
		role:     role,
	}
}

// AddChain registers the chain in the Registry and calls Chain.SetRouter()
func (c *Core) AddChain(chain Chain) {
	c.Registry = append(c.Registry, chain)
	chain.SetRouter(c.route)
}

// Start will call all registered chains' Start methods and block forever (or until signal is received)
func (c *Core) Start() {
	for _, chain := range c.Registry {
		err := chain.Start()
		if err != nil {
			c.log.Error("failed to start chain", "chain", chain.Id(), "err", err)
			return
		}
		c.log.Info(fmt.Sprintf("Started %s chain", chain.Name()))
	}

	sigc := make(chan os.Signal, 1)
	signal.Notify(sigc, syscall.SIGINT, syscall.SIGTERM)
	defer signal.Stop(sigc)

	// Block here and wait for a signal
	select {
	case err := <-c.sysErr:
		c.log.Error("FATAL ERROR. Shutting down.", "err", err)
	case <-sigc:
		c.log.Warn("Interrupt received, shutting down now.")
	}

	// Signal chains to shutdown
	for _, chain := range c.Registry {
		chain.Stop()
	}
}

func (c *Core) Errors() <-chan error {
	return c.sysErr
}

func (c *Core) ToUCoreRegistry() []utilcore.Chain {
	ucRegistry := make([]utilcore.Chain, len(c.Registry))

	for idx, reg := range c.Registry {
		ucRegistry[idx] = reg.(utilcore.Chain)
	}
	return ucRegistry
}

'''
'''--- core/router.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package core

import (
	"fmt"
	"sync"

	log "github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/msg"
)

// Writer consumes a message and makes the requried on-chain interactions.
type Writer interface {
	ResolveMessage(message msg.Message) bool
}

// Router forwards messages from their source to their destination
type Router struct {
	registry map[msg.ChainId]Writer
	lock     *sync.RWMutex
	log      log.Logger
	mapcid   msg.ChainId
}

func NewRouter(log log.Logger, mapcid msg.ChainId) *Router {
	return &Router{
		registry: make(map[msg.ChainId]Writer),
		lock:     &sync.RWMutex{},
		log:      log,
		mapcid:   mapcid,
	}
}

// Send passes a message to the destination Writer if it exists
func (r *Router) Send(msg msg.Message) error {
	r.lock.Lock()
	defer r.lock.Unlock()

	r.log.Trace("Routing message", "src", msg.Source, "dest", msg.Destination)
	dest := msg.Destination

	w := r.registry[dest]
	if w == nil {
		return fmt.Errorf("unknown destination chainId: %d", msg.Destination)
	}

	go w.ResolveMessage(msg)
	return nil
}

// Listen registers a Writer with a ChainId which Router.Send can then use to propagate messages
func (r *Router) Listen(id msg.ChainId, w Writer) {
	r.lock.Lock()
	defer r.lock.Unlock()
	r.log.Debug("Registering new chain in router", "id", id)
	r.registry[id] = w
}

'''
'''--- core/router_test.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package core

import (
	"reflect"
	"testing"
	"time"

	"github.com/ChainSafe/log15"
	"github.com/mapprotocol/compass/msg"
)

type mockWriter struct {
	msgs []msg.Message
}

func (w *mockWriter) Start() error { return nil }
func (w *mockWriter) Stop() error  { return nil }

func (w *mockWriter) ResolveMessage(msg msg.Message) bool {
	w.msgs = append(w.msgs, msg)
	return true
}

func TestRouter(t *testing.T) {
	tLog := log15.New("test_router")
	tLog.SetHandler(log15.LvlFilterHandler(log15.LvlTrace, tLog.GetHandler()))
	router := NewRouter(tLog)

	ethW := &mockWriter{msgs: *new([]msg.Message)}
	router.Listen(msg.ChainId(0), ethW)

	ctfgW := &mockWriter{msgs: *new([]msg.Message)}
	router.Listen(msg.ChainId(1), ctfgW)

	msgEthToCtfg := msg.Message{
		Source:      msg.ChainId(0),
		Destination: msg.ChainId(1),
	}

	msgCtfgToEth := msg.Message{
		Source:      msg.ChainId(1),
		Destination: msg.ChainId(0),
	}

	err := router.Send(msgCtfgToEth)
	if err != nil {
		t.Fatal(err)
	}
	err = router.Send(msgEthToCtfg)
	if err != nil {
		t.Fatal(err)
	}

	time.Sleep(time.Second)

	if !reflect.DeepEqual(ethW.msgs[0], msgCtfgToEth) {
		t.Error("Unexpected message")
	}

	if !reflect.DeepEqual(ctfgW.msgs[0], msgEthToCtfg) {
		t.Error("Unexpected message")
	}
}

'''
'''--- internal/arb/arb.go ---
package arb

import (
	"bytes"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
)

const (
	ArbitrumLegacyTxType = 120
)

type Receipts []*Receipt

type Receipt struct {
	*types.Receipt
}

func (r *Receipt) statusEncoding() []byte {
	if len(r.PostState) == 0 {
		if r.Status == constant.ReceiptStatusFailed {
			return constant.ReceiptStatusFailedRLP
		}
		return constant.ReceiptStatusSuccessfulRLP
	}
	return r.PostState
}

// Len returns the number of receipts in this list.
func (rs Receipts) Len() int { return len(rs) }

// EncodeIndex encodes the i'th receipt to w.
func (rs Receipts) EncodeIndex(i int, w *bytes.Buffer) {
	r := rs[i]
	data := &proof.ReceiptRLP{PostStateOrStatus: r.statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, Bloom: r.Bloom, Logs: r.Logs}
	switch r.Type {
	case constant.LegacyTxType, ArbitrumLegacyTxType:
		rlp.Encode(w, data)
	default:
		w.WriteByte(r.Type)
		rlp.Encode(w, data)
	}
}

'''
'''--- internal/bsc/bsc.go ---
package bsc

import (
	"github.com/mapprotocol/compass/internal/mapo"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	iproof "github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

type Header struct {
	ParentHash       []byte         `json:"parentHash"`
	Sha3Uncles       []byte         `json:"sha3Uncles"`
	Miner            common.Address `json:"miner"`
	StateRoot        []byte         `json:"stateRoot"`
	TransactionsRoot []byte         `json:"transactionsRoot"`
	ReceiptsRoot     []byte         `json:"receiptsRoot"`
	LogsBloom        []byte         `json:"logsBloom"`
	Difficulty       *big.Int       `json:"difficulty"`
	Number           *big.Int       `json:"number"`
	GasLimit         *big.Int       `json:"gasLimit"`
	GasUsed          *big.Int       `json:"gasUsed"`
	Timestamp        *big.Int       `json:"timestamp"`
	ExtraData        []byte         `json:"extraData"`
	MixHash          []byte         `json:"mixHash"`
	Nonce            []byte         `json:"nonce"`
	BaseFeePerGas    *big.Int       `json:"baseFeePerGas"`
}

func ConvertHeader(header types.Header) Header {
	bloom := make([]byte, 0, len(header.Bloom))
	for _, b := range header.Bloom {
		bloom = append(bloom, b)
	}
	nonce := make([]byte, 0, len(header.Nonce))
	for _, b := range header.Nonce {
		nonce = append(nonce, b)
	}
	if header.BaseFee == nil {
		header.BaseFee = new(big.Int)
	}
	return Header{
		ParentHash:       hashToByte(header.ParentHash),
		Sha3Uncles:       hashToByte(header.UncleHash),
		Miner:            header.Coinbase,
		StateRoot:        hashToByte(header.Root),
		TransactionsRoot: hashToByte(header.TxHash),
		ReceiptsRoot:     hashToByte(header.ReceiptHash),
		LogsBloom:        bloom,
		Difficulty:       header.Difficulty,
		Number:           header.Number,
		GasLimit:         new(big.Int).SetUint64(header.GasLimit),
		GasUsed:          new(big.Int).SetUint64(header.GasUsed),
		Timestamp:        new(big.Int).SetUint64(header.Time),
		ExtraData:        header.Extra,
		MixHash:          hashToByte(header.MixDigest),
		Nonce:            nonce,
		BaseFeePerGas:    header.BaseFee,
	}
}

func hashToByte(h common.Hash) []byte {
	ret := make([]byte, 0, len(h))
	for _, b := range h {
		ret = append(ret, b)
	}
	return ret
}

type ProofData struct {
	Headers      []Header
	ReceiptProof ReceiptProof
}

type ReceiptProof struct {
	TxReceipt mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

func AssembleProof(header []Header, log *types.Log, receipts []*types.Receipt, method string, fId msg.ChainId, proofType int64) ([]byte, error) {
	txIndex := log.TxIndex
	receipt, err := mapprotocol.GetTxReceipt(receipts[txIndex])
	if err != nil {
		return nil, err
	}

	prf, err := iproof.Get(types.Receipts(receipts), txIndex)
	if err != nil {
		return nil, err
	}

	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))
	ek := mapo.Key2Hex(key, len(prf))

	pd := ProofData{
		Headers: header,
		ReceiptProof: ReceiptProof{
			TxReceipt: *receipt,
			KeyIndex:  ek,
			Proof:     prf,
		},
	}

	pack, err := iproof.Pack(fId, method, mapprotocol.Bsc, pd)
	if err != nil {
		return nil, err
	}
	return pack, nil
}

'''
'''--- internal/chain/block_2map.go ---
package chain

import (
	"context"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

// execToMapMsg executes sync msg, and send tx to the destination blockchain
// the current function is only responsible for sending messages and is not responsible for processing data formats，
func (w *Writer) execToMapMsg(m msg.Message) bool {
	var (
		errorCount int64
		needNonce  = true
	)
	for {
		select {
		case <-w.stop:
			return false
		default:
			id, _ := m.Payload[0].(*big.Int)
			marshal, _ := m.Payload[1].([]byte)
			isEth2 := false
			if len(m.Payload) >= 3 {
				isEth2, _ = m.Payload[2].(bool)
			}

			method := mapprotocol.MethodUpdateBlockHeader
			if isEth2 {
				method = mapprotocol.MethodUpdateLightClient
			}

			err := w.toMap(m, id, marshal, method, needNonce)
			if err != nil {
				needNonce = w.needNonce(err)
				time.Sleep(constant.TxRetryInterval)
				errorCount++
				if errorCount >= 10 {
					util.Alarm(context.Background(), fmt.Sprintf("%s2map updateHeader failed, err is %s",
						mapprotocol.OnlineChaId[m.Source], err.Error()))
					errorCount = 0
				}
				continue
			}
			m.DoneCh <- struct{}{}
			return true
		}
	}
}

func (w *Writer) toMap(m msg.Message, id *big.Int, marshal []byte, method string, needNonce bool) error {
	err := w.conn.LockAndUpdateOpts(needNonce)
	if err != nil {
		w.log.Error("BlockToMap Failed to update nonce", "err", err)
		return err
	}

	data, err := mapprotocol.PackInput(mapprotocol.LightManger, method, id, marshal)
	if err != nil {
		w.log.Error("block2Map Failed to pack abi data", "err", err)
		w.conn.UnlockOpts()
		return err
	}
	tx, err := w.sendTx(&w.cfg.LightNode, nil, data)
	w.conn.UnlockOpts()
	if err == nil {
		// message successfully handled
		w.log.Info("Sync Header to map tx execution", "tx", tx.Hash(), "src", m.Source, "dst", m.Destination,
			"method", method, "needNonce", needNonce, "nonce", w.conn.Opts().Nonce)
		err = w.txStatus(tx.Hash())
		if err != nil {
			w.log.Warn("TxHash Status is not successful, will retry", "err", err)
		} else {
			return nil
		}
	} else if w.cfg.SkipError {
		w.log.Warn("Execution failed, ignore this error, Continue to the next ", "err", err)
		return nil
	} else {
		for e := range constant.IgnoreError {
			if strings.Index(err.Error(), e) != -1 {
				w.log.Info("Ignore This Error, Continue to the next", "id", id, "method", method, "err", err)
				return nil
			}
		}
		w.log.Warn("Sync Header to map Execution failed, will retry", "id", id, "method", method, "err", err)
	}
	return err
}

'''
'''--- internal/chain/block_map2other.go ---
package chain

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
)

// execMap2OtherMsg executes sync msg, and send tx to the destination blockchain
func (w *Writer) execMap2OtherMsg(m msg.Message) bool {
	var (
		errorCount int64
		needNonce  = true
	)
	for {
		select {
		case <-w.stop:
			return false
		default:
			err := w.conn.LockAndUpdateOpts(needNonce)
			if err != nil {
				w.log.Error("Failed to update nonce", "err", err)
				time.Sleep(constant.TxRetryInterval)
				continue
			}

			tx, err := w.sendTx(&w.cfg.LightNode, nil, m.Payload[0].([]byte))
			w.conn.UnlockOpts()
			if err == nil {
				// message successfully handled
				w.log.Info("Sync Map Header to other chain tx execution", "tx", tx.Hash(), "src", m.Source, "dst", m.Destination, "needNonce", needNonce, "nonce", w.conn.Opts().Nonce)
				err = w.txStatus(tx.Hash())
				if err != nil {
					w.log.Warn("TxHash Status is not successful, will retry", "err", err)
				} else {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range constant.IgnoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "id", m.Destination, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
				w.log.Warn("Sync Map Header to other chain Execution failed, header may already been synced", "id", m.Destination, "err", err)
			}
			needNonce = w.needNonce(err)
			errorCount++
			if errorCount >= 10 {
				util.Alarm(context.Background(), fmt.Sprintf("map2%s updateHeader failed, err is %s", mapprotocol.OnlineChaId[m.Destination], err.Error()))
				errorCount = 0
			}
			time.Sleep(constant.TxRetryInterval)
		}
	}
}

'''
'''--- internal/chain/blockstore.go ---
package chain

import (
	"math/big"

	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/pkg/blockstore"
)

func SetupBlockStore(cfg *Config, role mapprotocol.Role) (*blockstore.Blockstore, error) {
	bs, err := blockstore.NewBlockstore(cfg.BlockstorePath, cfg.Id, cfg.From, role)
	if err != nil {
		return nil, err
	}

	if !cfg.FreshStart {
		latestBlock, err := bs.TryLoadLatestBlock()
		if err != nil {
			return nil, err
		}
		if latestBlock == nil {
			latestBlock = new(big.Int)
		}

		if latestBlock.Cmp(cfg.StartBlock) == 1 {
			cfg.StartBlock = latestBlock
		}
	}

	return bs, nil
}

'''
'''--- internal/chain/chain.go ---
package chain

import (
	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/log"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/keystore"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/abi"
	"github.com/mapprotocol/compass/pkg/contract"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/pkg/errors"
)

type Chain struct {
	cfg    *core.ChainConfig // The config of the Chain
	conn   core.Connection   // The chains connection
	writer *Writer           // The writer of the Chain
	stop   chan<- int
	listen chains.Listener // The listener of this Chain
}

func New(chainCfg *core.ChainConfig, logger log15.Logger, sysErr chan<- error, role mapprotocol.Role,
	createConn core.CreateConn, opts ...SyncOpt) (*Chain, error) {
	cfg, err := ParseConfig(chainCfg)
	if err != nil {
		return nil, err
	}

	kpI, err := keystore.KeypairFromEth(cfg.KeystorePath)
	if err != nil {
		return nil, err
	}

	bs, err := SetupBlockStore(cfg, role)
	if err != nil {
		return nil, err
	}

	stop := make(chan int)
	conn := createConn(cfg.Endpoint, cfg.Http, kpI, logger, cfg.GasLimit, cfg.MaxGasPrice, cfg.GasMultiplier)
	err = conn.Connect()
	if err != nil {
		return nil, err
	}

	if chainCfg.LatestBlock || cfg.StartBlock == nil || cfg.StartBlock.Int64() == 0 {
		curr, err := conn.LatestBlock()
		if err != nil {
			return nil, err
		}
		cfg.StartBlock = curr
	}

	var listen chains.Listener
	cs := NewCommonSync(conn, cfg, logger, stop, sysErr, bs, opts...)
	switch role {
	case mapprotocol.RoleOfMaintainer:
		if cfg.Id != cfg.MapChainID {
			fn := mapprotocol.Map2EthHeight(cfg.From, cfg.LightNode, conn.Client())
			height, err := fn()
			if err != nil {
				return nil, errors.Wrap(err, "Map2Other get init headerHeight failed")
			}
			logger.Info("Map2other Current situation", "id", cfg.Id, "height", height, "lightNode", cfg.LightNode)
			mapprotocol.SyncOtherMap[cfg.Id] = height
			mapprotocol.Map2OtherHeight[cfg.Id] = fn
		}
		listen = NewMaintainer(cs)
	case mapprotocol.RoleOfMessenger:
		oracleAbi, _ := abi.New(mapprotocol.OracleAbiJson)
		call := contract.New(conn, cfg.McsContract, oracleAbi)
		mapprotocol.ContractMapping[cfg.Id] = call
		listen = NewMessenger(cs)
	case mapprotocol.RoleOfOracle:
		listen = NewOracle(cs)
	}
	wri := NewWriter(conn, cfg, logger, stop, sysErr)

	return &Chain{
		cfg:    chainCfg,
		conn:   conn,
		writer: wri,
		stop:   stop,
		listen: listen,
	}, nil
}

func (c *Chain) SetRouter(r *core.Router) {
	r.Listen(c.cfg.Id, c.writer)
	c.listen.SetRouter(r)
}

func (c *Chain) Start() error {
	err := c.listen.Sync()
	if err != nil {
		return err
	}

	log.Debug("Successfully started Chain")
	return nil
}

func (c *Chain) Id() msg.ChainId {
	return c.cfg.Id
}

func (c *Chain) Name() string {
	return c.cfg.Name
}

// Stop signals to any running routines to exit
func (c *Chain) Stop() {
	close(c.stop)
	if c.conn != nil {
		c.conn.Close()
	}
}

// EthClient return EthClient for global map connection
func (c *Chain) EthClient() *ethclient.Client {
	return c.conn.Client()
}

// Conn return Connection interface for relayer register
func (c *Chain) Conn() core.Connection {
	return c.conn
}

'''
'''--- internal/chain/common.go ---
package chain

import (
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
	"math/big"
)

var (
	OrderExist    = errors.New("order exist")
	NotVerifyAble = errors.New("not verify able")
)

type OrderStatusResp struct {
	Exists     bool
	Verifiable bool
	NodeType   *big.Int
}

func OrderStatus(idx int, selfChainId, toChainID uint64, blockNumber *big.Int, orderId []byte) (*OrderStatusResp, error) {
	call, ok := mapprotocol.ContractMapping[msg.ChainId(toChainID)]
	if !ok {

	}
	var fixedOrderId [32]byte
	for i, v := range orderId {
		fixedOrderId[i] = v
	}
	ret := OrderStatusResp{}
	err := call.Call(mapprotocol.MethodOfOrderStatus, &ret, idx, big.NewInt(int64(selfChainId)), blockNumber, fixedOrderId)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func PreSendTx(idx int, selfChainId, toChainID uint64, blockNumber *big.Int, orderId []byte) (int64, error) {
	ret, err := OrderStatus(idx, selfChainId, toChainID, blockNumber, orderId)
	if err != nil {
		return 0, errors.Wrap(err, "OrderStatus failed")
	}
	if ret.Exists {
		return 0, OrderExist
	}
	if !ret.Verifiable {
		return 0, NotVerifyAble
	}

	return ret.NodeType.Int64(), nil
}

'''
'''--- internal/chain/common_sync.go ---
package chain

import (
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/msg"
	"math/big"
	"time"

	"github.com/mapprotocol/compass/core"

	metrics "github.com/ChainSafe/chainbridge-utils/metrics/types"
	"github.com/ChainSafe/log15"
	eth "github.com/ethereum/go-ethereum"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/chains"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/pkg/blockstore"
)

type (
	SyncOpt        func(*CommonSync)
	SyncHeader2Map func(*Maintainer, *big.Int) error
	Mos            func(*Messenger, *big.Int) (int, error)
	AssembleProof  func(*Messenger, *types.Log, int64, uint64) (*msg.Message, error)
	OracleHandler  func(*Oracle, *big.Int) error
)

func OptOfInitHeight(height int64) SyncOpt {
	return func(sync *CommonSync) {
		sync.height = height
	}
}

func OptOfSync2Map(fn SyncHeader2Map) SyncOpt {
	return func(sync *CommonSync) {
		sync.syncHeaderToMap = fn
	}
}

func OptOfMos(fn Mos) SyncOpt {
	return func(sync *CommonSync) {
		sync.mosHandler = fn
	}
}

func OptOfOracleHandler(fn OracleHandler) SyncOpt {
	return func(sync *CommonSync) {
		sync.oracleHandler = fn
	}
}

func OptOfAssembleProof(fn AssembleProof) SyncOpt {
	return func(sync *CommonSync) {
		sync.assembleProof = fn
	}
}

type CommonSync struct {
	Cfg                Config
	Conn               core.Connection
	Log                log15.Logger
	Router             chains.Router
	Stop               <-chan int
	MsgCh              chan struct{}
	SysErr             chan<- error // Reports fatal error to core
	LatestBlock        metrics.LatestBlock
	BlockConfirmations *big.Int
	BlockStore         blockstore.Blockstorer
	height             int64
	syncHeaderToMap    SyncHeader2Map
	mosHandler         Mos
	oracleHandler      OracleHandler
	assembleProof      AssembleProof
}

// NewCommonSync creates and returns a listener
func NewCommonSync(conn core.Connection, cfg *Config, log log15.Logger, stop <-chan int, sysErr chan<- error,
	bs blockstore.Blockstorer, opts ...SyncOpt) *CommonSync {
	cs := &CommonSync{
		Cfg:                *cfg,
		Conn:               conn,
		Log:                log,
		Stop:               stop,
		SysErr:             sysErr,
		LatestBlock:        metrics.LatestBlock{LastUpdated: time.Now()},
		BlockConfirmations: cfg.BlockConfirmations,
		MsgCh:              make(chan struct{}),
		BlockStore:         bs,
		height:             1,
		mosHandler:         defaultMosHandler,
	}
	for _, op := range opts {
		op(cs)
	}

	return cs
}

func (c *CommonSync) SetRouter(r chains.Router) {
	c.Router = r
}

// WaitUntilMsgHandled this function will block untill message is handled
func (c *CommonSync) WaitUntilMsgHandled(counter int) error {
	c.Log.Debug("WaitUntilMsgHandled", "counter", counter)
	for counter > 0 {
		<-c.MsgCh
		counter -= 1
	}
	return nil
}

// BuildQuery constructs a query for the bridgeContract by hashing sig to get the event topic
func (c *CommonSync) BuildQuery(contract ethcommon.Address, sig []constant.EventSig, startBlock *big.Int, endBlock *big.Int) eth.FilterQuery {
	topics := make([]ethcommon.Hash, 0, len(sig))
	for _, s := range sig {
		topics = append(topics, s.GetTopic())
	}
	query := eth.FilterQuery{
		FromBlock: startBlock,
		ToBlock:   endBlock,
		Addresses: []ethcommon.Address{contract},
		Topics:    [][]ethcommon.Hash{topics},
	}
	return query
}

func (c *CommonSync) GetMethod(topic ethcommon.Hash) string {
	method := mapprotocol.MethodOfTransferIn
	if topic == mapprotocol.HashOfDepositIn {
		method = mapprotocol.MethodOfDepositIn
	} else if topic == mapprotocol.HashOfSwapIn {
		method = mapprotocol.MethodOfSwapIn
	}

	return method
}

'''
'''--- internal/chain/config.go ---
package chain

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mapprotocol/compass/internal/constant"
	"math/big"
	"strconv"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	gconfig "github.com/mapprotocol/compass/config"
	"github.com/mapprotocol/compass/core"
	"github.com/mapprotocol/compass/msg"
)

const (
	DefaultGasLimit           = 1000000
	DefaultGasPrice           = 50000000
	DefaultBlockConfirmations = 20
	DefaultGasMultiplier      = 1
)

// Chain specific options
var (
	McsOpt                = "mcs"
	TronMcsOpt            = "tronmcs"
	MaxGasPriceOpt        = "maxGasPrice"
	GasLimitOpt           = "gasLimit"
	GasMultiplier         = "gasMultiplier"
	LimitMultiplier       = "limitMultiplier"
	HttpOpt               = "http"
	StartBlockOpt         = "startBlock"
	BlockConfirmationsOpt = "blockConfirmations"
	SyncToMap             = "syncToMap"
	SyncIDList            = "syncIdList"
	LightNode             = "lightnode"
	Event                 = "event"
	Eth2Url               = "eth2Url"
	RedisOpt              = "redis"
	ApiUrl                = "apiUrl"
	OracleNode            = "oracleNode"
)

// Config encapsulates all necessary parameters in ethereum compatible forms
type Config struct {
	Name               string      // Human-readable chain name
	Id                 msg.ChainId // ChainID
	Endpoint           string      // url for rpc endpoint
	From               string      // address of key to use
	KeystorePath       string      // Location of keyfiles
	BlockstorePath     string
	FreshStart         bool // Disables loading from blockstore at start
	McsContract        []common.Address
	GasLimit           *big.Int
	MaxGasPrice        *big.Int
	GasMultiplier      float64
	LimitMultiplier    float64
	Http               bool // Config for type of connection
	StartBlock         *big.Int
	BlockConfirmations *big.Int
	SyncToMap          bool // Whether sync blockchain headers to Map
	MapChainID         msg.ChainId
	SyncChainIDList    []msg.ChainId  // chain ids which map sync to
	LightNode          common.Address // the lightnode to sync header
	SyncMap            map[msg.ChainId]*big.Int
	Events             []constant.EventSig
	SkipError          bool
	Eth2Endpoint       string
	ApiUrl             string
	OracleNode         common.Address
	TronContract       []common.Address
}

// ParseConfig uses a core.ChainConfig to construct a corresponding Config
func ParseConfig(chainCfg *core.ChainConfig) (*Config, error) {
	config := &Config{
		Name:               chainCfg.Name,
		Id:                 chainCfg.Id,
		Endpoint:           chainCfg.Endpoint,
		From:               chainCfg.From,
		KeystorePath:       chainCfg.KeystorePath,
		BlockstorePath:     chainCfg.BlockstorePath,
		FreshStart:         chainCfg.FreshStart,
		McsContract:        []common.Address{},
		TronContract:       []common.Address{},
		GasLimit:           big.NewInt(DefaultGasLimit),
		MaxGasPrice:        big.NewInt(DefaultGasPrice),
		GasMultiplier:      DefaultGasMultiplier,
		LimitMultiplier:    DefaultGasMultiplier,
		Http:               true,
		SyncToMap:          true,
		StartBlock:         big.NewInt(0),
		BlockConfirmations: big.NewInt(0),
		Events:             make([]constant.EventSig, 0),
		SkipError:          chainCfg.SkipError,
	}

	if contract, ok := chainCfg.Opts[McsOpt]; ok && contract != "" {
		for _, addr := range strings.Split(contract, ",") {
			config.McsContract = append(config.McsContract, common.HexToAddress(addr))
		}
	} else {
		return nil, fmt.Errorf("must provide opts.mcs field for ethereum config")
	}

	if gasPrice, ok := chainCfg.Opts[MaxGasPriceOpt]; ok {
		price := big.NewInt(0)
		_, pass := price.SetString(gasPrice, 10)
		if pass {
			config.MaxGasPrice = price
		} else {
			return nil, errors.New("unable to parse max gas price")
		}
	}

	if gasLimit, ok := chainCfg.Opts[GasLimitOpt]; ok {
		limit := big.NewInt(0)
		_, pass := limit.SetString(gasLimit, 10)
		if pass {
			config.GasLimit = limit
		} else {
			return nil, errors.New("unable to parse gas limit")
		}
	}

	if gasMultiplier, ok := chainCfg.Opts[GasMultiplier]; ok {
		float, err := strconv.ParseFloat(gasMultiplier, 64)
		if err == nil {
			config.GasMultiplier = float
		} else {
			return nil, errors.New("unable to parse gasMultiplier to float")
		}
	}

	if limitMultiplier, ok := chainCfg.Opts[LimitMultiplier]; ok {
		float, err := strconv.ParseFloat(limitMultiplier, 64)
		if err == nil {
			config.LimitMultiplier = float
		} else {
			return nil, errors.New("unable to parse limitMultiplier to float")
		}
	}

	if startBlock, ok := chainCfg.Opts[StartBlockOpt]; ok && startBlock != "" {
		block := big.NewInt(0)
		_, pass := block.SetString(startBlock, 10)
		if pass {
			config.StartBlock = block
		} else {
			return nil, fmt.Errorf("unable to parse %s", StartBlockOpt)
		}
	}

	if blockConfirmations, ok := chainCfg.Opts[BlockConfirmationsOpt]; ok && blockConfirmations != "" {
		val := big.NewInt(DefaultBlockConfirmations)
		_, pass := val.SetString(blockConfirmations, 10)
		if pass {
			config.BlockConfirmations = val
		} else {
			return nil, fmt.Errorf("unable to parse %s", BlockConfirmationsOpt)
		}
	} else {
		config.BlockConfirmations = big.NewInt(DefaultBlockConfirmations)
	}

	if syncToMap, ok := chainCfg.Opts[SyncToMap]; ok && syncToMap == "false" {
		config.SyncToMap = false
	}

	if mapChainID, ok := chainCfg.Opts[gconfig.MapChainID]; ok {
		chainId, errr := strconv.Atoi(mapChainID)
		if errr != nil {
			return nil, errr
		}
		config.MapChainID = msg.ChainId(chainId)
	}

	if syncIDList, ok := chainCfg.Opts[SyncIDList]; ok && syncIDList != "[]" {
		err := json.Unmarshal([]byte(syncIDList), &config.SyncChainIDList)
		if err != nil {
			return nil, err
		}
	}

	if lightnode, ok := chainCfg.Opts[LightNode]; ok && lightnode != "" {
		config.LightNode = common.HexToAddress(lightnode)
	}

	if oracleNode, ok := chainCfg.Opts[OracleNode]; ok && oracleNode != "" {
		config.OracleNode = common.HexToAddress(oracleNode)
	}

	if v, ok := chainCfg.Opts[Event]; ok && v != "" {
		vs := strings.Split(v, "|")
		for _, s := range vs {
			config.Events = append(config.Events, constant.EventSig(s))
		}
	}

	if eth2Url, ok := chainCfg.Opts[Eth2Url]; ok && eth2Url != "" {
		config.Eth2Endpoint = eth2Url
	}

	if v, ok := chainCfg.Opts[ApiUrl]; ok && v != "" {
		config.ApiUrl = v
	}

	if contract, ok := chainCfg.Opts[TronMcsOpt]; ok && contract != "" {
		for _, addr := range strings.Split(contract, ",") {
			config.TronContract = append(config.TronContract, common.HexToAddress(addr))
		}
	}

	if config.OracleNode == constant.ZeroAddress {
		config.OracleNode = config.LightNode
	}

	if config.Id == config.MapChainID {
		config.SyncToMap = false
	}

	return config, nil
}

'''
'''--- internal/chain/maintainer.go ---
package chain

import (
	"context"
	"fmt"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/pkg/util"
	"github.com/pkg/errors"

	"math/big"
	"time"
)

type Maintainer struct {
	*CommonSync
	syncedHeight *big.Int
}

func NewMaintainer(cs *CommonSync) *Maintainer {
	return &Maintainer{
		CommonSync:   cs,
		syncedHeight: new(big.Int),
	}
}

func (m *Maintainer) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.Log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Maintainer will poll for the latest block and proceed to parse the associated events as it sees new blocks.
// Polling begins at the block defined in `m.Cfg.StartBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to BlockRetryLimit times before continuing to the next block.
func (m *Maintainer) sync() error {
	if m.Cfg.Id != m.Cfg.MapChainID && !m.Cfg.SyncToMap {
		time.Sleep(time.Hour * 2400)
		return nil
	}
	var currentBlock = m.Cfg.StartBlock
	m.Log.Info("Polling Blocks...", "block", currentBlock)

	if m.Cfg.SyncToMap {
		syncedHeight, err := mapprotocol.Get2MapHeight(m.Cfg.Id)
		if err != nil {
			m.Log.Error("Get synced Height failed", "err", err)
			return err
		}

		m.Log.Info("Check Block Sync Status...", "synced", syncedHeight, "currentBlock", currentBlock)
		m.syncedHeight = syncedHeight

		if syncedHeight.Cmp(currentBlock) != 0 {
			currentBlock.Add(syncedHeight, new(big.Int).SetInt64(m.height))
			m.Log.Info("SyncedHeight is higher or lower than currentHeight, so let currentHeight = syncedHeight",
				"syncedHeight", syncedHeight, "currentBlock", currentBlock)
		}
	} else if m.Cfg.Id == m.Cfg.MapChainID {
		minHeight := big.NewInt(0)
		for cId, height := range mapprotocol.SyncOtherMap {
			if minHeight.Uint64() == 0 || minHeight.Cmp(height) == 1 {
				m.Log.Info("map to other chain find min sync height ", "chainId", cId,
					"syncedHeight", minHeight, "currentHeight", height)
				minHeight = height
			}
		}
		if m.Cfg.StartBlock.Cmp(minHeight) != 0 { // When the synchronized height is less than or more than the local starting height, use height
			currentBlock = big.NewInt(minHeight.Int64() + m.height)
			m.Log.Info("Map2other chain", "initial height", currentBlock)
		}
	}

	for {
		select {
		case <-m.Stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.Conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				continue
			}

			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.BlockConfirmations) == -1 {
				m.Log.Debug("Block not ready, will retry", "current", currentBlock, "latest", latestBlock)
				time.Sleep(constant.QueryRetryInterval)
				continue
			}
			difference := new(big.Int).Sub(currentBlock, latestBlock)
			if difference.Int64() > 0 {
				m.Log.Info("chain online blockNumber less than local latestBlock, waiting...", "chainBlcNum", latestBlock,
					"localBlock", currentBlock, "waiting", difference.Int64())
				time.Sleep(constant.BlockRetryInterval * time.Duration(difference.Int64()))
			}

			if m.Cfg.Id == m.Cfg.MapChainID && len(m.Cfg.SyncChainIDList) > 0 {
				err = m.syncHeaderToMap(m, currentBlock)
				if err != nil {
					m.Log.Error("Failed to listen header for block", "block", currentBlock, "err", err)
					time.Sleep(constant.QueryRetryInterval)
					util.Alarm(context.Background(), fmt.Sprintf("map sync header to other failed, err is %s", err.Error()))
					continue
				}
			} else if currentBlock.Cmp(m.syncedHeight) == 1 {
				err = m.syncHeaderToMap(m, currentBlock)
				if err != nil {
					m.Log.Error("Failed to listen header for block", "block", currentBlock, "err", err)
					time.Sleep(constant.QueryRetryInterval)
					if err.Error() != "not found" {
						util.Alarm(context.Background(), fmt.Sprintf("%s sync header failed, err is %s", m.Cfg.Name, err.Error()))
					}
					continue
				}
			} else {
				time.Sleep(time.Hour)
			}

			// Write to block store. Not a critical operation, no need to retry
			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			m.LatestBlock.Height = big.NewInt(0).Set(latestBlock)
			m.LatestBlock.LastUpdated = time.Now()

			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(constant.MaintainerInterval)
			}
		}
	}
}

'''
'''--- internal/chain/mcs.go ---
package chain

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/util"

	"github.com/mapprotocol/compass/mapprotocol"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
)

// exeSwapMsg executes swap msg, and send tx to the destination blockchain
func (w *Writer) exeSwapMsg(m msg.Message) bool {
	return w.callContractWithMsg(w.cfg.McsContract[m.Idx], m)
}

// callContractWithMsg contract using address and function signature with message info
func (w *Writer) callContractWithMsg(addr common.Address, m msg.Message) bool {
	var (
		errorCount, checkIdCount int64
		needNonce                = true
	)
	for {
		select {
		case <-w.stop:
			return false
		default:
			orderId := m.Payload[1].([]byte)
			exits, err := w.checkOrderId(&addr, orderId, mapprotocol.Mcs, mapprotocol.MethodOfOrderList)
			if err != nil {
				w.log.Error("check orderId exist failed ", "err", err, "orderId", common.Bytes2Hex(orderId))
				checkIdCount++
				if checkIdCount == 10 {
					util.Alarm(context.Background(), fmt.Sprintf("writer mos checkOrderId failed, err is %s", err.Error()))
					checkIdCount = 0
				}
			}
			if exits {
				w.log.Info("Mcs orderId has been processed, Skip this request", "orderId", common.Bytes2Hex(orderId))
				m.DoneCh <- struct{}{}
				return true
			}

			err = w.conn.LockAndUpdateOpts(needNonce)
			if err != nil {
				w.log.Error("Failed to update nonce", "err", err)
				time.Sleep(constant.TxRetryInterval)
				continue
			}

			var inputHash interface{}
			if len(m.Payload) > 3 {
				inputHash = m.Payload[3]
			}
			w.log.Info("Send transaction", "addr", addr, "srcHash", inputHash, "needNonce", needNonce, "nonce", w.conn.Opts().Nonce)
			mcsTx, err := w.sendTx(&addr, nil, m.Payload[0].([]byte))
			//err = w.call(&addr, m.Payload[0].([]byte), mapprotocol.Other, mapprotocol.MethodVerifyProofData)
			if err == nil {
				w.log.Info("Submitted cross tx execution", "src", m.Source, "dst", m.Destination, "srcHash", inputHash, "mcsTx", mcsTx.Hash())
				err = w.txStatus(mcsTx.Hash())
				if err != nil {
					w.log.Warn("TxHash Status is not successful, will retry", "err", err)
				} else {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError && errorCount >= 9 {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "srcHash", inputHash, "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range constant.IgnoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "id", m.Destination, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
				w.log.Warn("Execution failed, will retry", "srcHash", inputHash, "err", err)
			}
			needNonce = w.needNonce(err)
			errorCount++
			if errorCount >= 10 {
				w.mosAlarm(m, inputHash, err)
				errorCount = 0
			}
			time.Sleep(constant.TxRetryInterval)
		}
	}
}

func (w *Writer) merlinWithMsg(m msg.Message) bool {
	var (
		errorCount int64
		needNonce  = true
		addr       = w.cfg.McsContract[m.Idx]
	)
	for {
		select {
		case <-w.stop:
			return false
		default:
			err := w.conn.LockAndUpdateOpts(needNonce)
			if err != nil {
				w.log.Error("Failed to update nonce", "err", err)
				time.Sleep(constant.TxRetryInterval)
				continue
			}
			var inputHash = m.Payload[3]
			w.log.Info("Send transaction", "method", m.Payload[4], "srcHash", inputHash, "needNonce", needNonce, "nonce", w.conn.Opts().Nonce)
			mcsTx, err := w.sendTx(&addr, nil, m.Payload[0].([]byte))
			if err == nil {
				w.log.Info("Submitted cross tx execution", "src", m.Source, "dst", m.Destination, "srcHash", inputHash, "mcsTx", mcsTx.Hash())
				err = w.txStatus(mcsTx.Hash())
				if err != nil {
					w.log.Warn("Store TxHash Status is not successful, will retry", "err", err)
				} else {
					m.DoneCh <- struct{}{}
					return true
				}
			} else if w.cfg.SkipError && errorCount >= 9 {
				w.log.Warn("Execution failed, ignore this error, Continue to the next ", "srcHash", inputHash, "err", err)
				m.DoneCh <- struct{}{}
				return true
			} else {
				for e := range constant.IgnoreError {
					if strings.Index(err.Error(), e) != -1 {
						w.log.Info("Ignore This Error, Continue to the next", "id", m.Destination, "err", err)
						m.DoneCh <- struct{}{}
						return true
					}
				}
				w.log.Warn("Execution SwapInVerify failed, will retry", "srcHash", inputHash, "err", err)
			}

			needNonce = w.needNonce(err)
			errorCount++
			if errorCount >= 10 {
				w.mosAlarm(m, inputHash, err)
				errorCount = 0
			}
			time.Sleep(constant.TxRetryInterval)
		}
	}
}

func (w *Writer) mosAlarm(m msg.Message, tx interface{}, err error) {
	util.Alarm(context.Background(), fmt.Sprintf("mos %s2%s failed, srcHash=%v err is %s", mapprotocol.OnlineChaId[m.Source],
		mapprotocol.OnlineChaId[m.Destination], tx, err.Error()))
}

func (w *Writer) call(toAddress *common.Address, input []byte, useAbi abi.ABI, method string, ret interface{}) error {
	from := w.conn.Keypair().Address
	outPut, err := w.conn.Client().CallContract(context.Background(),
		ethereum.CallMsg{
			From: from,
			To:   toAddress,
			Data: input,
		},
		nil,
	)
	if err != nil {
		w.log.Error("Mcs callContract verify failed", "err", err.Error())
		return err
	}

	resp, err := useAbi.Methods[method].Outputs.Unpack(outPut)
	if err != nil {
		w.log.Error("Writer Unpack failed ", "method", method, "err", err.Error())
		return err
	}

	err = useAbi.Methods[method].Outputs.Copy(&ret, resp)
	if err != nil {
		return errors.Wrap(err, "resp copy failed")
	}

	return nil
}

func (w *Writer) checkOrderId(toAddress *common.Address, input []byte, useAbi abi.ABI, method string) (bool, error) {
	var fixedOrderId [32]byte
	for idx, v := range input {
		fixedOrderId[idx] = v
	}
	data, err := mapprotocol.PackInput(useAbi, method, fixedOrderId)
	if err != nil {
		return false, err
	}
	from := w.conn.Keypair().Address
	outPut, err := w.conn.Client().CallContract(context.Background(),
		ethereum.CallMsg{
			From: from,
			To:   toAddress,
			Data: data,
		},
		nil,
	)
	if err != nil {
		return false, errors.Wrap(err, "callContract failed")
	}

	resp, err := useAbi.Methods[method].Outputs.Unpack(outPut)
	if err != nil {
		return false, errors.Wrap(err, "output Unpack failed")
	}

	var exist bool
	err = useAbi.Methods[method].Outputs.Copy(&exist, resp)
	if err != nil {
		return false, errors.Wrap(err, "checkOrderId output copy failed")
	}

	return exist, nil
}

func (w *Writer) txStatus(txHash common.Hash) error {
	var count int64
	//time.Sleep(time.Second * 2)
	for {
		_, pending, err := w.conn.Client().TransactionByHash(context.Background(), txHash) // Query whether it is on the chain
		if pending {
			w.log.Info("Tx is Pending, please wait...", "tx", txHash)
			time.Sleep(w.queryInterval())
			count++
			if count == 60 {
				return errors.New("The Tx pending state is too long")
			}
			continue
		}
		if err != nil {
			time.Sleep(w.queryInterval())
			count++
			if count == 60 {
				return err
			}
			w.log.Error("Tx Found failed, please wait...", "tx", txHash, "err", err)
			continue
		}
		break
	}
	count = 0
	for {
		receipt, err := w.conn.Client().TransactionReceipt(context.Background(), txHash) // Query receipt after chaining
		if err != nil {
			if strings.Index(err.Error(), "not found") != -1 {
				w.log.Info("Tx is temporary not found, please wait...", "tx", txHash)
				time.Sleep(w.queryInterval())
				count++
				if count == 40 {
					return err
				}
				continue
			}
			return err
		}

		if receipt.Status == types.ReceiptStatusSuccessful {
			w.log.Info("Tx receipt status is success", "hash", txHash)
			return nil
		}
		return fmt.Errorf("txHash(%s), status not success, current status is (%d)", txHash, receipt.Status)
	}
}

func (w *Writer) queryInterval() time.Duration {
	switch w.cfg.Id {
	case 22776:
		return time.Second * 3
	default:
		return constant.QueryRetryInterval
	}
}

'''
'''--- internal/chain/messenger.go ---
package chain

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"math/big"
	"strconv"
	"strings"
	"time"

	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/util"
)

type Messenger struct {
	*CommonSync
}

func NewMessenger(cs *CommonSync) *Messenger {
	return &Messenger{
		CommonSync: cs,
	}
}

func (m *Messenger) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.Log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

// sync function of Messenger will poll for the latest block and listen the log information of transactions in the block
// Polling begins at the block defined in `m.Cfg.startBlock`. Failed attempts to fetch the latest block or parse
// a block will be retried up to BlockRetryLimit times before continuing to the next block.
// However，an error in synchronizing the log will cause the entire program to block
func (m *Messenger) sync() error {
	if !m.Cfg.SyncToMap && m.Cfg.Id != m.Cfg.MapChainID {
		time.Sleep(time.Hour * 2400)
		return nil
	}
	var currentBlock = m.Cfg.StartBlock

	for {
		select {
		case <-m.Stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.Conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.RetryLongInterval)
				continue
			}

			// Sleep if the difference is less than BlockDelay; (latest - current) < BlockDelay
			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.BlockConfirmations) == -1 {
				m.Log.Debug("Block not ready, will retry", "currentBlock", currentBlock, "latest", latestBlock)
				time.Sleep(constant.BalanceRetryInterval)
				continue
			}
			count, err := m.mosHandler(m, currentBlock)
			if err != nil {
				if errors.Is(err, NotVerifyAble) {
					m.Log.Error("CurrentBlock not verify", "block", currentBlock, "err", err)
					time.Sleep(constant.BalanceRetryInterval)
					continue
				}
				m.Log.Error("Failed to get events for block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				util.Alarm(context.Background(), fmt.Sprintf("mos failed, chain=%s, err is %s", m.Cfg.Name, err.Error()))
				continue
			}

			// hold until all messages are handled
			_ = m.WaitUntilMsgHandled(count)

			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(constant.MessengerInterval)
			}
		}
	}
}

func defaultMosHandler(m *Messenger, blockNumber *big.Int) (int, error) {
	count := 0
	for idx, addr := range m.Cfg.McsContract {
		query := m.BuildQuery(addr, m.Cfg.Events, blockNumber, blockNumber)
		logs, err := m.Conn.Client().FilterLogs(context.Background(), query)
		if err != nil {
			return 0, fmt.Errorf("unable to Filter Logs: %w", err)
		}

		m.Log.Debug("event", "blockNumber ", blockNumber, " logs ", len(logs))
		for _, log := range logs {
			var (
				proofType int64
				toChainID uint64
			)

			if log.Topics[0].Hex() == constant.TopicsOfSwapInVerified {
				proofType = 3
			} else {
				orderId := log.Data[:32]
				toChainID, _ = strconv.ParseUint(mapprotocol.MapId, 10, 64)
				if m.Cfg.Id == m.Cfg.MapChainID {
					toChainID = binary.BigEndian.Uint64(log.Topics[2][len(log.Topics[2])-8:])
				}
				chainName, ok := mapprotocol.OnlineChaId[msg.ChainId(toChainID)]
				if !ok {
					m.Log.Info("Map Found a log that is not the current task ", "blockNumber", log.BlockNumber, "toChainID", toChainID)
					continue
				}
				if strings.ToLower(chainName) == "near" {
					proofType = 1
				} else if strings.ToLower(chainName) == "tron" {
					proofType = 3
				} else {
					m.Log.Info("Event found", "BlockNumber", log.BlockNumber, "txHash", log.TxHash, "logIdx", log.Index,
						"orderId", common.Bytes2Hex(orderId))
					proofType, err = PreSendTx(idx, uint64(m.Cfg.Id), toChainID, blockNumber, orderId)
					if errors.Is(err, OrderExist) {
						m.Log.Info("This txHash order exist", "blockNumber", blockNumber, "txHash", log.TxHash, "orderId", common.Bytes2Hex(orderId))
						continue
					}
					if err != nil {
						return 0, err
					}
				}
			}

			tmpLog := log
			message, err := m.assembleProof(m, &tmpLog, proofType, toChainID)
			if err != nil {
				return 0, err
			}
			message.Idx = idx

			err = m.Router.Send(*message)
			if err != nil {
				m.Log.Error("Subscription error: failed to route message", "err", err)
			}
			count++
		}
	}
	return count, nil
}

'''
'''--- internal/chain/oracle.go ---
package chain

import (
	"context"
	"encoding/binary"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethdb/memorydb"
	"github.com/ethereum/go-ethereum/trie"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/internal/tx"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
	"github.com/pkg/errors"
	"math/big"
	"time"
)

type Oracle struct {
	*CommonSync
}

func NewOracle(cs *CommonSync) *Oracle {
	return &Oracle{
		CommonSync: cs,
	}
}

func (m *Oracle) Sync() error {
	m.Log.Debug("Starting listener...")
	go func() {
		err := m.sync()
		if err != nil {
			m.Log.Error("Polling blocks failed", "err", err)
		}
	}()

	return nil
}

func (m *Oracle) sync() error {
	if !m.Cfg.SyncToMap && m.Cfg.Id != m.Cfg.MapChainID {
		time.Sleep(time.Hour * 2400)
		return nil
	}
	var currentBlock = m.Cfg.StartBlock

	for {
		select {
		case <-m.Stop:
			return errors.New("polling terminated")
		default:
			latestBlock, err := m.Conn.LatestBlock()
			if err != nil {
				m.Log.Error("Unable to get latest block", "block", currentBlock, "err", err)
				time.Sleep(constant.RetryLongInterval)
				continue
			}

			if big.NewInt(0).Sub(latestBlock, currentBlock).Cmp(m.BlockConfirmations) == -1 {
				m.Log.Debug("Block not ready, will retry", "currentBlock", currentBlock, "latest", latestBlock)
				time.Sleep(constant.BalanceRetryInterval)
				continue
			}

			err = m.oracleHandler(m, currentBlock)
			if err != nil {
				m.Log.Error("Failed to get events for block", "block", currentBlock, "err", err)
				time.Sleep(constant.BlockRetryInterval)
				util.Alarm(context.Background(), fmt.Sprintf("mos failed, chain=%s, err is %s", m.Cfg.Name, err.Error()))
				continue
			}

			err = m.BlockStore.StoreBlock(currentBlock)
			if err != nil {
				m.Log.Error("Failed to write latest block to blockstore", "block", currentBlock, "err", err)
			}

			currentBlock.Add(currentBlock, big.NewInt(1))
			if latestBlock.Int64()-currentBlock.Int64() <= m.Cfg.BlockConfirmations.Int64() {
				time.Sleep(constant.MessengerInterval)
			}
		}
	}
}

func DefaultOracleHandler(m *Oracle, latestBlock *big.Int) error {
	m.Log.Debug("Querying block for events", "block", latestBlock)
	count := 0
	query := m.BuildQuery(m.Cfg.OracleNode, m.Cfg.Events, latestBlock, latestBlock)
	// querying for logs
	logs, err := m.Conn.Client().FilterLogs(context.Background(), query)
	if err != nil {
		return fmt.Errorf("oracle unable to Filter Logs: %w", err)
	}
	header, err := m.Conn.Client().HeaderByNumber(context.Background(), latestBlock)
	if err != nil {
		return fmt.Errorf("oracle get header failed, err: %w", err)
	}
	if len(logs) == 0 {
		return nil
	}
	hash, err := generateReceipt(m, latestBlock)
	if err != nil {
		return fmt.Errorf("oracle generate receipt failed, err is %w", err)
	}
	if hash != nil {
		header.ReceiptHash = *hash
	}

	m.Log.Info("Find log", "block", latestBlock, "logs", len(logs))
	input, err := mapprotocol.OracleAbi.Methods[mapprotocol.MethodOfPropose].Inputs.Pack(header.Number, header.ReceiptHash)
	if err != nil {
		return err
	}

	id := big.NewInt(0).SetUint64(uint64(m.Cfg.Id))
	for _, log := range logs {
		if m.Cfg.Id == m.Cfg.MapChainID {
			toChainID := binary.BigEndian.Uint64(log.Topics[1][len(logs[0].Topics[1])-8:])
			data, err := mapprotocol.PackInput(mapprotocol.LightManger, mapprotocol.MethodUpdateBlockHeader, big.NewInt(int64(m.Cfg.Id)), input)
			if err != nil {
				return err
			}
			for _, cid := range m.Cfg.SyncChainIDList {
				if toChainID != uint64(cid) {
					continue
				}
				message := msg.NewSyncFromMap(m.Cfg.MapChainID, cid, []interface{}{data}, m.MsgCh)
				err = m.Router.Send(message)
				if err != nil {
					m.Log.Error("subscription error: failed to route message", "err", err)
					return nil
				}
				count++
			}
		} else {
			message := msg.NewSyncToMap(m.Cfg.Id, m.Cfg.MapChainID, []interface{}{id, input}, m.MsgCh)
			err = m.Router.Send(message)
			if err != nil {
				m.Log.Error("subscription error: failed to route message", "err", err)
				return nil
			}
			count++
		}
	}

	err = m.WaitUntilMsgHandled(count)
	if err != nil {
		return err
	}
	return nil
}

func generateReceipt(m *Oracle, latestBlock *big.Int) (*common.Hash, error) {
	if !exist(int64(m.Cfg.Id), []int64{constant.MerlinChainId, constant.ZkSyncChainId, constant.B2ChainId, constant.ZkLinkChainId}) {
		return nil, nil
	}
	txsHash, err := mapprotocol.GetMapTransactionsHashByBlockNumber(m.Conn.Client(), latestBlock)
	if err != nil {
		return nil, fmt.Errorf("unable to get tx hashes Logs: %w", err)
	}
	receipts, err := tx.GetReceiptsByTxsHash(m.Conn.Client(), txsHash)
	if err != nil {
		return nil, fmt.Errorf("unable to get receipts hashes Logs: %w", err)
	}
	tr, _ := trie.New(common.Hash{}, trie.NewDatabase(memorydb.New()))
	tr = proof.DeriveTire(types.Receipts(receipts), tr)
	ret := tr.Hash()
	return &ret, nil
}

func exist(target int64, dst []int64) bool {
	for _, d := range dst {
		if target == d {
			return true
		}
	}
	return false
}

'''
'''--- internal/chain/writer.go ---
package chain

import (
	"context"
	"math/big"
	"strings"

	"github.com/mapprotocol/compass/core"

	"github.com/mapprotocol/compass/internal/constant"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/mapprotocol/compass/msg"
)

type Writer struct {
	cfg    Config
	conn   core.Connection
	log    log15.Logger
	stop   <-chan int
	sysErr chan<- error // Reports fatal error to core
}

// NewWriter creates and returns Writer
func NewWriter(conn core.Connection, cfg *Config, log log15.Logger, stop <-chan int, sysErr chan<- error) *Writer {
	return &Writer{
		cfg:    *cfg,
		conn:   conn,
		log:    log,
		stop:   stop,
		sysErr: sysErr,
	}
}

func (w *Writer) start() error {
	w.log.Debug("Starting Writer...")
	return nil
}

// ResolveMessage handles any given message based on type
// A bool is returned to indicate failure/success, this should be ignored except for within tests.
func (w *Writer) ResolveMessage(m msg.Message) bool {
	w.log.Info("Attempting to resolve message", "type", m.Type, "src", m.Source, "dst", m.Destination)

	switch m.Type {
	case msg.SyncToMap:
		return w.execToMapMsg(m)
	case msg.SyncFromMap:
		return w.execMap2OtherMsg(m)
	case msg.SwapWithProof:
		fallthrough
	case msg.SwapWithMapProof:
		return w.exeSwapMsg(m)
	case msg.SwapWithMerlin:
		return w.merlinWithMsg(m)
	default:
		w.log.Error("Unknown message type received", "type", m.Type)
		return false
	}
}

// sendTx send tx to an address with value and input data
func (w *Writer) sendTx(toAddress *common.Address, value *big.Int, input []byte) (*types.Transaction, error) {
	gasPrice := w.conn.Opts().GasPrice
	nonce := w.conn.Opts().Nonce
	from := w.conn.Keypair().Address

	msg := ethereum.CallMsg{
		From:     from,
		To:       toAddress,
		GasPrice: gasPrice,
		Value:    value,
		Data:     input,
	}
	gasLimit, err := w.conn.Client().EstimateGas(context.Background(), msg)
	if err != nil {
		w.log.Error("EstimateGas failed sendTx", "error:", err.Error())
		return nil, err
	}

	gasTipCap := w.conn.Opts().GasTipCap
	gasFeeCap := w.conn.Opts().GasFeeCap
	if w.cfg.LimitMultiplier > 1 {
		gasLimit = uint64(float64(gasLimit) * w.cfg.LimitMultiplier)
	}
	if w.cfg.GasMultiplier > 1 && gasTipCap != nil && gasFeeCap != nil {
		gasTipCap = big.NewInt(int64(float64(gasTipCap.Uint64()) * w.cfg.GasMultiplier))
		gasFeeCap = big.NewInt(int64(float64(gasFeeCap.Uint64()) * w.cfg.GasMultiplier))
	}
	w.log.Info("SendTx gasPrice", "gasPrice", gasPrice, "gasTipCap", gasTipCap, "gasFeeCap", gasFeeCap, "gasLimit", gasLimit,
		"limitMultiplier", w.cfg.LimitMultiplier, "gasMultiplier", w.cfg.GasMultiplier, "nonce", nonce.Uint64())
	// td interface
	var td types.TxData
	// EIP-1559
	if gasPrice != nil {
		// legacy branch
		td = &types.LegacyTx{
			Nonce:    nonce.Uint64(),
			Value:    value,
			To:       toAddress,
			Gas:      gasLimit,
			GasPrice: gasPrice,
			Data:     input,
		}
	} else {
		// london branch
		td = &types.DynamicFeeTx{
			Nonce:     nonce.Uint64(),
			Value:     value,
			To:        toAddress,
			Gas:       gasLimit,
			GasTipCap: gasTipCap,
			GasFeeCap: gasFeeCap,
			Data:      input,
		}
	}

	tx := types.NewTx(td)
	chainID := big.NewInt(int64(w.cfg.Id))
	privateKey := w.conn.Keypair().PrivateKey

	signedTx, err := types.SignTx(tx, types.NewLondonSigner(chainID), privateKey)
	if err != nil {
		w.log.Error("SignTx failed", "error:", err.Error())
		return nil, err
	}

	err = w.conn.Client().SendTransaction(context.Background(), signedTx)
	if err != nil {
		w.log.Error("SendTransaction failed", "error:", err.Error())
		return nil, err
	}
	return signedTx, nil
}

func (w *Writer) needNonce(err error) bool {
	if err == nil || err.Error() == constant.ErrNonceTooLow.Error() || strings.Index(err.Error(), "nonce too low") != -1 {
		return true
	}

	return false
}

'''
'''--- internal/conflux/client.go ---
// Copyright 2019 Conflux Foundation. All rights reserved.
// Conflux is free software and distributed under GNU General Public License.
// See http://www.gnu.org/licenses/

package conflux

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/mapprotocol/compass/internal/conflux/types"
	"github.com/pkg/errors"
)

const (
	contentType = "application/json"
	vsn         = "2.0"
)

var ErrNoResult = errors.New("no result in JSON-RPC response")

type Client struct {
	client    *http.Client
	url       string
	closeOnce sync.Once
	closch    chan interface{}
	mu        sync.Mutex // protcts headers
	headers   http.Header
	isHttp    bool
	idCounter uint32
}

func NewClient(endpoint string) (*Client, error) {
	// Sanity chck URL so we don't end up with a client that will fail every request.
	_, err := url.Parse(endpoint)
	if err != nil {
		return nil, err
	}

	headers := make(http.Header, 2)
	headers.Set("accept", contentType)
	headers.Set("content-type", contentType)
	return &Client{
		client:    new(http.Client),
		url:       endpoint,
		closeOnce: sync.Once{},
		closch:    make(chan interface{}),
		mu:        sync.Mutex{},
		headers:   headers,
	}, nil
}

func (c *Client) GetStatus(ctx context.Context) (*Status, error) {
	data, err := c.call(ctx, "pos_getStatus")
	if err != nil {
		return nil, err
	}
	var ret Status
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) GetBlockByNumber(ctx context.Context, blockNumber BlockNumber) (*Block, error) {
	data, err := c.call(ctx, "pos_getBlockByNumber", blockNumber)
	if err != nil {
		return nil, err
	}
	var ret Block
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) GetLedgerInfoByEpochAndRound(ctx context.Context, epochNumber hexutil.Uint64,
	round hexutil.Uint64) (*LedgerInfoWithSignatures, error) {
	data, err := c.call(ctx, "pos_getLedgerInfoByEpochAndRound", epochNumber, round)
	if err != nil {
		return nil, err
	}
	var ret LedgerInfoWithSignatures
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) GetBlockByEpochNumber(ctx context.Context, blockNumber hexutil.Uint64) (*BlockSummary, error) {
	data, err := c.call(ctx, "cfx_getBlockByEpochNumber", blockNumber, false)
	if err != nil {
		return nil, err
	}

	var ret BlockSummary
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) GetEpochReceipts(ctx context.Context, epoch types.EpochOrBlockHash,
	includeEthReceipts ...bool) ([][]types.TransactionReceipt, error) {
	includeEth := get1stBoolIfy(includeEthReceipts)
	data, err := c.call(ctx, "cfx_getEpochReceipts", epoch, includeEth)
	if err != nil {
		return nil, err
	}

	var ret [][]types.TransactionReceipt
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

func get1stBoolIfy(values []bool) bool {
	value := false
	if len(values) > 0 {
		value = values[0]
	}
	return value
}

func (c *Client) call(ctx context.Context, method string, args ...interface{}) ([]byte, error) {
	var raw json.RawMessage
	err := c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}

	data, err := raw.MarshalJSON()
	if err != nil {
		return nil, err
	}

	return data, nil
}

type jsonrpcMessage struct {
	Version string          `json:"jsonrpc,omitempty"`
	ID      json.RawMessage `json:"id,omitempty"`
	Method  string          `json:"method,omitempty"`
	Params  json.RawMessage `json:"params,omitempty"`
	Error   *jsonError      `json:"error,omitempty"`
	Result  json.RawMessage `json:"result,omitempty"`
}

type jsonError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (err *jsonError) Error() string {
	if err.Message == "" {
		return fmt.Sprintf("json-rpc error %d", err.Code)
	}
	return err.Message
}

type requestOp struct {
	ids  []json.RawMessage
	err  error
	resp chan *jsonrpcMessage // receives up to len(ids) responses
}

func (op *requestOp) wait(ctx context.Context) (*jsonrpcMessage, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case resp := <-op.resp:
		return resp, op.err
	}
}

func (c *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {
	if result != nil && reflect.TypeOf(result).Kind() != reflect.Ptr {
		return fmt.Errorf("call result parameter must be pointer or nil interface: %v", result)
	}
	msg, err := c.newMessage(method, args...)
	if err != nil {
		return err
	}
	op := &requestOp{ids: []json.RawMessage{msg.ID}, resp: make(chan *jsonrpcMessage, 1)}

	err = c.sendHTTP(ctx, op, msg)
	if err != nil {
		return err
	}

	// dispatch has accepted the request and will close the channel when it quits.
	switch resp, err := op.wait(ctx); {
	case err != nil:
		return err
	case resp.Error != nil:
		return resp.Error
	case len(resp.Result) == 0:
		return ErrNoResult
	default:
		return json.Unmarshal(resp.Result, &result)
	}
}

func (c *Client) nextID() json.RawMessage {
	id := atomic.AddUint32(&c.idCounter, 1)
	return strconv.AppendUint(nil, uint64(id), 10)
}

func (c *Client) newMessage(method string, paramsIn ...interface{}) (*jsonrpcMessage, error) {
	msg := &jsonrpcMessage{Version: vsn, ID: c.nextID(), Method: method}
	if paramsIn != nil { // prevent sending "params":null
		var err error
		if msg.Params, err = json.Marshal(paramsIn); err != nil {
			return nil, err
		}
	}
	return msg, nil
}

func (c *Client) sendHTTP(ctx context.Context, op *requestOp, msg interface{}) error {
	respBody, err := c.doRequest(ctx, msg)
	if err != nil {
		return err
	}
	defer respBody.Close()

	var respmsg jsonrpcMessage
	if err := json.NewDecoder(respBody).Decode(&respmsg); err != nil {
		return err
	}
	op.resp <- &respmsg
	return nil
}

func (c *Client) doRequest(ctx context.Context, msg interface{}) (io.ReadCloser, error) {
	body, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.url, ioutil.NopCloser(bytes.NewReader(body)))
	if err != nil {
		return nil, err
	}
	req.ContentLength = int64(len(body))

	// set headers
	c.mu.Lock()
	req.Header = c.headers.Clone()
	c.mu.Unlock()

	// do request
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		//var buf bytes.Buffer
		//var body []byte
		//if _, err := buf.ReadFrom(resp.Body); err == nil {
		//	body = buf.Bytes()
		//}

		return nil, fmt.Errorf("conflux request code is(%d)", resp.StatusCode)
		//return nil, HTTPError{
		//	Status:     resp.Status,
		//	StatusCode: resp.StatusCode,
		//	Body:       body,
		//}
	}
	return resp.Body, nil
}

'''
'''--- internal/conflux/conflux.go ---
package conflux

import (
	"context"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/conflux/mpt"
	primitives "github.com/mapprotocol/compass/internal/conflux/primipives"
	"github.com/mapprotocol/compass/internal/conflux/types"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
)

const DeferredExecutionEpochs uint64 = 5

var ErrTransactionExecutionFailed = errors.New("transaction execution failed")

func ConvertLedger(ledger *LedgerInfoWithSignatures) LedgerInfoLibLedgerInfoWithSignatures {
	committee, _ := ConvertCommittee(ledger)

	result := LedgerInfoLibLedgerInfoWithSignatures{
		Epoch:             uint64(ledger.LedgerInfo.CommitInfo.Epoch),
		Round:             uint64(ledger.LedgerInfo.CommitInfo.Round),
		Id:                common.BytesToHash(ledger.LedgerInfo.CommitInfo.Id),
		ExecutedStateId:   common.BytesToHash(ledger.LedgerInfo.CommitInfo.ExecutedStateId),
		Version:           uint64(ledger.LedgerInfo.CommitInfo.Version),
		TimestampUsecs:    uint64(ledger.LedgerInfo.CommitInfo.TimestampUsecs),
		NextEpochState:    committee,
		ConsensusDataHash: common.BytesToHash(ledger.LedgerInfo.ConsensusDataHash),
	}

	if pivot := ledger.LedgerInfo.CommitInfo.Pivot; pivot != nil {
		result.Pivot.Height = uint64(pivot.Height)
		result.Pivot.BlockHash = pivot.BlockHash.ToHash()
	}

	result.AggregatedSignature = ABIEncodeSignature(ledger.AggregatedSignature)
	for _, v := range ledger.ValidatorsSorted() {
		result.Accounts = append(result.Accounts, v)
	}

	return result
}

func ABIEncodeSignature(signature []byte) []byte {
	if len(signature) != 192 {
		return signature
	}

	encoded := make([]byte, 256)

	copy(encoded[16:64], signature[:48])
	copy(encoded[80:128], signature[48:96])
	copy(encoded[144:192], signature[96:144])
	copy(encoded[208:256], signature[144:192])

	return encoded
}

func ABIEncodePublicKey(publicKey []byte) []byte {
	if len(publicKey) != 96 {
		return publicKey
	}

	encoded := make([]byte, 128)

	copy(encoded[16:64], publicKey[:48])
	copy(encoded[80:128], publicKey[48:])

	return encoded
}

func ConvertCommittee(ledger *LedgerInfoWithSignatures) (LedgerInfoLibEpochState, bool) {
	if ledger == nil {
		return LedgerInfoLibEpochState{}, false
	}

	state := ledger.LedgerInfo.CommitInfo.NextEpochState
	if state == nil {
		return LedgerInfoLibEpochState{}, false
	}

	var validators []LedgerInfoLibValidatorInfo
	for _, v := range ledger.NextEpochValidatorsSorted() {
		info := state.Verifier.AddressToValidatorInfo[v]

		uncompressedPubKey, ok := ledger.NextEpochValidators[v]
		if !ok {
			return LedgerInfoLibEpochState{}, false
		}

		validator := LedgerInfoLibValidatorInfo{
			Account:               v,
			UncompressedPublicKey: ABIEncodePublicKey(uncompressedPubKey),
			VotingPower:           uint64(info.VotingPower),
		}

		if info.VrfPublicKey != nil {
			validator.VrfPublicKey = *info.VrfPublicKey
		}

		validators = append(validators, validator)
	}

	return LedgerInfoLibEpochState{
		Epoch:             uint64(state.Epoch),
		Validators:        validators,
		QuorumVotingPower: uint64(state.Verifier.QuorumVotingPower),
		TotalVotingPower:  uint64(state.Verifier.TotalVotingPower),
		VrfSeed:           state.VrfSeed,
	}, true
}

func MustRLPEncodeBlock(block *BlockSummary) []byte {
	val := ConvertBlock(block)
	encoded, err := rlp.EncodeToBytes(val)
	if err != nil {
		panic(err)
	}
	return encoded
}

func ConvertBlock(block *BlockSummary) BlockRlp {
	return BlockRlp{block}
}

type BlockRlp struct {
	raw *BlockSummary
}

func (header BlockRlp) EncodeRLP(w io.Writer) error {
	var adaptive uint64
	if header.raw.Adaptive {
		adaptive = 1
	}

	var referees []common.Hash
	for _, v := range header.raw.RefereeHashes {
		referees = append(referees, *v.ToCommonHash())
	}

	list := []interface{}{
		header.raw.ParentHash.ToCommonHash(),
		header.raw.Height.ToInt(),
		header.raw.Timestamp.ToInt(),
		header.raw.Miner.MustGetCommonAddress(),
		header.raw.TransactionsRoot.ToCommonHash(),
		header.raw.DeferredStateRoot.ToCommonHash(),
		header.raw.DeferredReceiptsRoot.ToCommonHash(),
		header.raw.DeferredLogsBloomHash.ToCommonHash(),
		header.raw.Blame,
		header.raw.Difficulty.ToInt(),
		adaptive,
		header.raw.GasLimit.ToInt(),
		referees,
		header.raw.Nonce.ToInt(),
	}

	if header.raw.PosReference != nil {
		// simulate RLP encoding for rust Option type
		item := []common.Hash{*header.raw.PosReference.ToCommonHash()}
		list = append(list, item)
	}

	for _, v := range header.raw.Custom {
		list = append(list, rlp.RawValue(v))
	}

	return rlp.Encode(w, list)
}

func AssembleProof(client *Client, txHash common.Hash, epochNumber, pivot, proofType uint64, method string, fId msg.ChainId) ([]byte, error) {
	if epochNumber+DeferredExecutionEpochs > pivot {
		return nil, errors.New("Pivot less than current block")
	}

	epoch := types.NewEpochNumberUint64(epochNumber)
	epochOrHash := types.NewEpochOrBlockHashWithEpoch(epoch)
	epochReceipts, err := client.GetEpochReceipts(context.Background(), *epochOrHash, true)
	if err != nil {
		return nil, errors.WithMessagef(err, "Failed to get receipts by epoch number %v", epochNumber)
	}

	blockIndex, receipt := matchReceipt(epochReceipts, txHash.Hex())
	if receipt == nil {
		return nil, nil
	}

	if receipt.MustGetOutcomeType() != types.TRANSACTION_OUTCOME_SUCCESS {
		return nil, ErrTransactionExecutionFailed
	}

	subtrees, root := CreateReceiptsMPT(epochReceipts)

	blockIndexKey := mpt.IndexToKey(blockIndex, len(subtrees))
	blockProof, ok := root.Proof(blockIndexKey)
	if !ok {
		return nil, errors.New("Failed to generate block proof")
	}

	receiptsRoot := subtrees[blockIndex].Hash()
	receiptKey := mpt.IndexToKey(int(receipt.Index), len(epochReceipts[blockIndex]))
	receiptProof, ok := subtrees[blockIndex].Proof(receiptKey)
	if !ok {
		return nil, errors.New("Failed to generate receipt proof")
	}

	var headers [][]byte
	// 195 - 200
	for i := epochNumber + DeferredExecutionEpochs; i <= pivot; i++ {
		block, err := client.GetBlockByEpochNumber(context.Background(), hexutil.Uint64(i))
		if err != nil {
			return nil, errors.WithMessagef(err, "Failed to get block summary by epoch %v", i)
		}

		headers = append(headers, MustRLPEncodeBlock(block))
	}

	proof := &mpt.TypesReceiptProof{
		Headers:      headers,
		BlockIndex:   blockIndexKey,
		BlockProof:   mpt.ConvertProofNode(blockProof),
		ReceiptsRoot: receiptsRoot,
		Index:        receiptKey,
		Receipt:      primitives.MustRLPEncodeReceipt(receipt),
		ReceiptProof: mpt.ConvertProofNode(receiptProof),
	}
	input, err := mapprotocol.Conflux.Methods[mapprotocol.MethodOfVerifyReceiptProof].Inputs.Pack(proof)
	if err != nil {
		return nil, err
	}

	pack, err := mapprotocol.PackInput(mapprotocol.Mcs, method, new(big.Int).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, err
	}

	return pack, nil
}

func matchReceipt(epochReceipts [][]types.TransactionReceipt, txHash string) (blockIndex int, receipt *types.TransactionReceipt) {
	for i, blockReceipts := range epochReceipts {
		for _, v := range blockReceipts {
			if v.MustGetOutcomeType() == types.TRANSACTION_OUTCOME_SKIPPED {
				continue
			}

			if v.TransactionHash.String() != txHash {
				continue
			}

			return i, &v
		}
	}

	return 0, nil
}

func CreateReceiptsMPT(epochReceipts [][]types.TransactionReceipt) ([]*mpt.Node, *mpt.Node) {
	var subtrees []*mpt.Node

	for _, blockReceipts := range epochReceipts {
		var root mpt.Node

		keyLen := mpt.MinReprBytes(len(blockReceipts))

		for i, v := range blockReceipts {
			key := mpt.ToIndexBytes(i, keyLen)
			value := primitives.MustRLPEncodeReceipt(&v)
			root.Insert(key, value)
		}

		subtrees = append(subtrees, &root)
	}

	var root mpt.Node
	keyLen := mpt.MinReprBytes(len(subtrees))
	for i, v := range subtrees {
		key := mpt.ToIndexBytes(i, keyLen)
		value := v.Hash().Bytes()
		root.Insert(key, value)
	}

	return subtrees, &root
}

'''
'''--- internal/conflux/mpt/key.go ---
package mpt

func IndexToKey(index, total int) []byte {
	keyLen := MinReprBytes(total)
	return ToIndexBytes(index, keyLen)
}

func MinReprBytes(numKeys int) (keyLen int) {
	switch numKeys {
	case 0:
		return 0
	case 1:
		return 1
	default:
		for tmp := numKeys - 1; tmp != 0; tmp >>= 8 {
			keyLen++
		}

		return
	}
}

func ToIndexBytes(index, keyLen int) []byte {
	result := make([]byte, keyLen)

	for i := keyLen - 1; i >= 0; i-- {
		result[i] = uint8(index)
		index >>= 8
	}

	return result
}

'''
'''--- internal/conflux/mpt/nibble_path.go ---
package mpt

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

type NibblePath struct {
	nibbles []byte
	start   int // inclusive
	end     int // exclusive
}

func NewNibblePath(key []byte) NibblePath {
	nibbles := make([]byte, 2*len(key))

	for i := 0; i < len(key); i++ {
		nibbles[2*i] = key[i] >> 4
		nibbles[2*i+1] = key[i] & 0x0F
	}

	return NibblePath{nibbles, 0, len(nibbles)}
}

func (path *NibblePath) Length() int {
	return path.end - path.start
}

func (path NibblePath) value() []byte {
	return path.nibbles[path.start:path.end]
}

func (path *NibblePath) ToChild() (childIndex byte, childPath NibblePath, ok bool) {
	if path.start == path.end {
		return
	}

	childIndex = path.nibbles[path.start]
	childPath = NibblePath{path.nibbles, path.start + 1, path.end}
	ok = true

	return
}

func (path *NibblePath) CommonPrefix(other *NibblePath) (prefix, path1, path2 NibblePath) {
	var offset int

	for {
		pathPos := path.start + offset
		if pathPos >= path.end {
			break
		}

		otherPos := other.start + offset
		if otherPos >= other.end {
			break
		}

		if path.nibbles[pathPos] != other.nibbles[otherPos] {
			break
		}

		offset++
	}

	prefix = NibblePath{
		nibbles: path.nibbles,
		start:   path.start,
		end:     path.start + offset,
	}

	path1 = NibblePath{
		nibbles: path.nibbles,
		start:   path.start + offset,
		end:     path.end,
	}

	path2 = NibblePath{
		nibbles: other.nibbles,
		start:   other.start + offset,
		end:     other.end,
	}

	return
}

func (path *NibblePath) ComputeMerkle(nodeMerkle common.Hash) common.Hash {
	if path.Length() == 0 {
		return nodeMerkle
	}

	var buffer []byte
	var start = path.start

	pathInfo := 128
	if start%2 == 1 {
		pathInfo += 64
	}
	pathInfo += path.Length() % 63
	buffer = append(buffer, byte(pathInfo))
	buffer = append(buffer, path.fullBytes()...)
	buffer = append(buffer, nodeMerkle.Bytes()...)

	return crypto.Keccak256Hash(buffer)
}

func (path *NibblePath) fullBytes() []byte {
	var result []byte

	start := path.start
	if start%2 == 1 {
		result = append(result, path.nibbles[start])
		start++
	}

	end := path.end
	if end%2 == 1 {
		end++
	}

	for i := start; i < end; i += 2 {
		key := path.nibbles[i]<<4 + path.nibbles[i+1]
		result = append(result, key)
	}

	return result
}

func (path *NibblePath) Trim() NibblePath {
	if path.start == path.end {
		return NibblePath{}
	}

	result := *path

	start := result.start
	if start%2 == 1 {
		start--
	}

	if start > 0 {
		result.nibbles = result.nibbles[start:]
		result.start -= start
		result.end -= start
	}

	end := result.end
	if end%2 == 1 {
		end++
	}

	if end < len(result.nibbles) {
		result.nibbles = result.nibbles[:end]
	}

	return result
}

'''
'''--- internal/conflux/mpt/node.go ---
package mpt

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"sync/atomic"
)

const CHILDREN_COUNT = 16

var (
	KECCAKE_EMPTY      = crypto.Keccak256Hash()
	LEAF_NODE_CHILDREN = [CHILDREN_COUNT]common.Hash{
		KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY,
		KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY,
		KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY,
		KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY, KECCAKE_EMPTY,
	}
)

type nodeType int

const (
	nodeTypeBranch = iota
	nodeTypeLeaf
)

type Node struct {
	nType    nodeType
	path     NibblePath
	value    []byte                // for leaf node only
	children [CHILDREN_COUNT]*Node // unlike Ethereum, no extension node in Conflux

	merkle atomic.Value
}

func mustNewLeafNode(path NibblePath, value []byte) (childIndex byte, leaf *Node) {
	index, childPath, ok := path.ToChild()
	if !ok {
		panic("path too short to create leaf node")
	}

	return index, &Node{
		nType: nodeTypeLeaf,
		path:  childPath,
		value: value,
	}
}

func newBranchNode(path NibblePath, children [CHILDREN_COUNT]*Node) *Node {
	return &Node{
		nType:    nodeTypeBranch,
		path:     path,
		children: children,
	}
}

// Insert inserts key and value into mpt.
// Note, key should be in the same length and inserted in order.
func (n *Node) Insert(key, value []byte) {
	if len(key) == 0 {
		panic("key is empty")
	}

	path := NewNibblePath(key)

	n.insert(path, value)
}

func (n *Node) insert(path NibblePath, value []byte) {
	switch n.nType {
	case nodeTypeBranch:
		prefix, path1, path2 := n.path.CommonPrefix(&path)
		if path2.Length() == 0 {
			panic("key length inconsistent")
		}

		if path1.Length() == 0 {
			childIndex, leaf := mustNewLeafNode(path2, value)
			if n.children[childIndex] == nil {
				n.children[childIndex] = leaf
			} else {
				n.children[childIndex].insert(leaf.path, value)
			}
		} else {
			childIndex1, path1, _ := path1.ToChild()
			if path1.Length() > 0 {
				panic("key not inserted in sequence")
			}
			child1 := newBranchNode(path1, n.children)

			childIndex2, child2 := mustNewLeafNode(path2, value)

			// update current branch node
			n.path = prefix
			n.children = [CHILDREN_COUNT]*Node{}
			n.children[childIndex1] = child1
			n.children[childIndex2] = child2
		}
	case nodeTypeLeaf:
		if n.path.Length() != path.Length() {
			panic("key length inconsistent")
		}

		// find common prefix for branch node
		prefix, path1, path2 := n.path.CommonPrefix(&path)
		if path1.Length() == 0 {
			panic("duplicate key inserted")
		}

		// construct 2 new leaf nodes
		childIndex1, leaf1 := mustNewLeafNode(path1, n.value)
		childIndex2, leaf2 := mustNewLeafNode(path2, value)

		// change current leaf node to branch node
		n.nType = nodeTypeBranch
		n.path = prefix
		n.value = nil
		n.children[childIndex1] = leaf1
		n.children[childIndex2] = leaf2
	default:
		panic("invalid node type")
	}
}

func (n *Node) Hash() common.Hash {
	switch n.nType {
	case nodeTypeBranch:
		if n.children[0] == nil {
			return KECCAKE_EMPTY
		}

		if n.children[1] == nil {
			return n.children[0].computeMerkle()
		}

		return n.computeMerkle()
	case nodeTypeLeaf:
		panic("root should be a branch node")
	default:
		panic("invalid node type")
	}
}

func (n *Node) computeMerkle() common.Hash {
	if merkle := n.merkle.Load(); merkle != nil {
		return merkle.(common.Hash)
	}

	childrenHashes := n.computeChildrenHashes()
	nodeMerkle := computeNodeMerkle(childrenHashes, n.value)
	merkle := n.path.ComputeMerkle(nodeMerkle)

	n.merkle.Store(merkle)

	return merkle
}

func (n *Node) computeChildrenHashes() (childrenHashes [CHILDREN_COUNT]common.Hash) {
	if n.nType == nodeTypeLeaf {
		return LEAF_NODE_CHILDREN
	}

	for i, v := range n.children {
		if v == nil {
			childrenHashes[i] = KECCAKE_EMPTY
		} else {
			childrenHashes[i] = v.computeMerkle()
		}
	}

	return
}

func computeNodeMerkle(children [CHILDREN_COUNT]common.Hash, value []byte) common.Hash {
	var buffer []byte

	buffer = append(buffer, 'n')

	for _, v := range children {
		buffer = append(buffer, v.Bytes()...)
	}

	if len(value) > 0 {
		buffer = append(buffer, 'v')
		buffer = append(buffer, value...)
	}

	return crypto.Keccak256Hash(buffer)
}

'''
'''--- internal/conflux/mpt/proof.go ---
package mpt

import (
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

type ProofNode struct {
	path     NibblePath
	children [CHILDREN_COUNT]common.Hash // for branch node
	value    []byte                      // for leaf node
}

func newProofNode(n *Node) *ProofNode {
	return &ProofNode{
		path:     n.path.Trim(),
		children: n.computeChildrenHashes(),
		value:    n.value,
	}
}

func (n *ProofNode) ComputeMerkle() common.Hash {
	nodeMerkle := computeNodeMerkle(n.children, n.value)
	return n.path.ComputeMerkle(nodeMerkle)
}

func (n ProofNode) String() string {
	var children [16]string
	for i, v := range n.children {
		if v == KECCAKE_EMPTY {
			children[i] = "NULL"
		} else {
			children[i] = v.Hex()
		}
	}

	return fmt.Sprintf("{ path = %v, children = %v, value = %v }", n.path, children, n.value)
}

func (n *Node) Proof(key []byte) ([]*ProofNode, bool) {
	if len(key) == 0 {
		panic("key is empty")
	}

	path := NewNibblePath(key)

	switch n.nType {
	case nodeTypeBranch:
		// empty
		if n.children[0] == nil {
			return nil, false
		}

		// first branch has 2 children at least
		if n.children[1] != nil {
			return n.proof(path)
		}

		// trim the first branch node that has only one child
		childIndex, childPath, ok := path.ToChild()
		if !ok || childIndex != 0 {
			return nil, false
		}

		return n.children[0].proof(childPath)
	case nodeTypeLeaf:
		panic("root should be a branch node")
	default:
		panic("invalid node type")
	}
}

func (n *Node) proof(path NibblePath) ([]*ProofNode, bool) {
	_, path1, path2 := n.path.CommonPrefix(&path)

	// prefix mismatch
	if path1.Length() != 0 {
		return nil, false
	}

	proofNodes := []*ProofNode{newProofNode(n)}

	switch n.nType {
	case nodeTypeLeaf:
		if path2.Length() != 0 {
			return nil, false
		}
	case nodeTypeBranch:
		childIndex, childPath, ok := path2.ToChild()
		if !ok || n.children[childIndex] == nil {
			return nil, false
		}

		childrenProofs, ok := n.children[childIndex].proof(childPath)
		if !ok {
			return nil, false
		}

		proofNodes = append(proofNodes, childrenProofs...)
	default:
		panic("invalid node type")
	}

	return proofNodes, true
}

func Prove(root common.Hash, key, value []byte, proofNodes []*ProofNode) bool {
	if len(key) == 0 || len(proofNodes) == 0 {
		return false
	}

	path := NewNibblePath(key)
	expectedHash := root

	var nibblesLen int
	for _, v := range proofNodes {
		nibblesLen += v.path.Length()
		if v.children[0] != KECCAKE_EMPTY {
			nibblesLen++
		}
	}

	if nibblesLen%2 == 1 {
		if path.nibbles[0] != 0 {
			return false
		}

		path.start++
	}

	for _, v := range proofNodes {
		if nodeHash := v.ComputeMerkle(); nodeHash != expectedHash {
			return false
		}

		_, path1, path2 := v.path.CommonPrefix(&path)
		if path1.Length() != 0 {
			return false
		}

		switch v.children[0] {
		case KECCAKE_EMPTY: // leaf node
			if path2.Length() != 0 {
				return false
			}

			return crypto.Keccak256Hash(value) == crypto.Keccak256Hash(v.value)
		default:
			childIndex, childPath, ok := path2.ToChild()
			if !ok {
				return false
			}

			path = childPath
			expectedHash = v.children[childIndex]
		}
	}

	return false
}

func ConvertProofNode(nodes []*ProofNode) []ProofLibProofNode {
	var result []ProofLibProofNode

	for _, v := range nodes {
		var children [16][32]byte
		for i, child := range v.children {
			children[i] = child
		}

		var nibbles [32]byte
		copy(nibbles[:], v.path.nibbles)

		result = append(result, ProofLibProofNode{
			Path: ProofLibNibblePath{
				Nibbles: nibbles,
				Start:   big.NewInt(int64(v.path.start)),
				End:     big.NewInt(int64(v.path.end)),
			},
			Children: children,
			Value:    v.value,
		})
	}

	return result
}

'''
'''--- internal/conflux/mpt/struct.go ---
package mpt

import "math/big"

type TypesReceiptProof struct {
	Headers      [][]byte
	BlockIndex   []byte
	BlockProof   []ProofLibProofNode
	ReceiptsRoot [32]byte
	Index        []byte
	Receipt      []byte
	ReceiptProof []ProofLibProofNode
}

type ProofLibProofNode struct {
	Path     ProofLibNibblePath
	Children [16][32]byte
	Value    []byte
}

type ProofLibNibblePath struct {
	Nibbles [32]byte
	Start   *big.Int
	End     *big.Int
}

'''
'''--- internal/conflux/primipives/bool.go ---
package primitives

import (
	"io"

	"github.com/ethereum/go-ethereum/rlp"
)

// Bool represents a bool value that could be RLP encoded in Rust version.
type Bool bool

func (b Bool) EncodeRLP(w io.Writer) error {
	if b {
		// go-ethereum encoded as 0x80
		return rlp.Encode(w, "\x01")
	}

	return rlp.Encode(w, "\x00")
}

'''
'''--- internal/conflux/primipives/receipt.go ---
package primitives

import (
	"io"
	"math/big"

	"github.com/mapprotocol/compass/internal/conflux/types"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/pkg/errors"
)

type Receipt struct {
	AccumulatedGasUsed    *big.Int
	GasFee                *big.Int
	GasSponsorPaid        Bool
	LogBloom              []byte
	Logs                  []TxLog
	OutcomeStatus         uint8
	StorageSponsorPaid    Bool
	StorageCollateralized []StorageChange
	StorageReleased       []StorageChange
}

func MustRLPEncodeReceipt(receipt *types.TransactionReceipt) []byte {
	val := ConvertReceipt(receipt)
	encoded, err := rlp.EncodeToBytes(val)
	if err != nil {
		panic(err)
	}
	return encoded
}

func ConvertReceipt(receipt *types.TransactionReceipt) Receipt {
	storageCollateralized, storageReleased := constructStorageChanges(receipt)

	return Receipt{
		AccumulatedGasUsed:    receipt.AccumulatedGasUsed.ToInt(),
		GasFee:                receipt.GasFee.ToInt(),
		GasSponsorPaid:        Bool(receipt.GasCoveredBySponsor),
		LogBloom:              hexutil.MustDecode(string(receipt.LogsBloom)),
		Logs:                  convertLogs(receipt.Logs),
		OutcomeStatus:         uint8(receipt.MustGetOutcomeType()),
		StorageSponsorPaid:    Bool(receipt.StorageCoveredBySponsor),
		StorageCollateralized: storageCollateralized,
		StorageReleased:       storageReleased,
	}
}

type StorageChange struct {
	Account     common.Address
	Collaterals uint64
}

func constructStorageChanges(receipt *types.TransactionReceipt) (collateralized, released []StorageChange) {
	for _, v := range receipt.StorageReleased {
		released = append(released, StorageChange{
			Account:     v.Address.MustGetCommonAddress(),
			Collaterals: uint64(v.Collaterals),
		})
	}

	if receipt.StorageCollateralized == 0 {
		return
	}

	var account types.Address
	if receipt.StorageCoveredBySponsor {
		account = *receipt.To
	} else {
		account = receipt.From
	}

	collateralized = append(collateralized, StorageChange{
		Account:     account.MustGetCommonAddress(),
		Collaterals: uint64(receipt.StorageCollateralized),
	})

	return
}

const (
	LogSpaceNative   uint8 = 1
	LogSpaceEthereum uint8 = 2
)

type TxLog struct {
	Addr   common.Address
	Topics []common.Hash
	Data   []byte
	Space  uint8
}

// EncodeRLP implements the rlp.Encoder interface.
func (log TxLog) EncodeRLP(w io.Writer) error {
	switch log.Space {
	case LogSpaceNative:
		return rlp.Encode(w, []interface{}{log.Addr, log.Topics, log.Data})
	case LogSpaceEthereum:
		return rlp.Encode(w, []interface{}{log.Addr, log.Topics, log.Data, log.Space})
	default:
		return errors.Errorf("invalid log space %v", log.Space)
	}
}

func convertLogs(logs []types.Log) []TxLog {
	var result []TxLog

	for _, v := range logs {
		var topics []common.Hash
		for _, t := range v.Topics {
			topics = append(topics, *t.ToCommonHash())
		}

		var space uint8
		switch *v.Space {
		case types.SPACE_NATIVE:
			space = LogSpaceNative
		case types.SPACE_EVM:
			space = LogSpaceEthereum
		default:
			panic("invalid space in log entry")
		}

		result = append(result, TxLog{
			Addr:   v.Address.MustGetCommonAddress(),
			Topics: topics,
			Data:   v.Data,
			Space:  space,
		})
	}

	return result
}

'''
'''--- internal/conflux/structs.go ---
package conflux

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"regexp"
	"sort"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/conflux/types"
	"github.com/pkg/errors"
)

type Status struct {
	LatestCommitted hexutil.Uint64  `json:"latestCommitted"`
	Epoch           hexutil.Uint64  `json:"epoch"`
	PivotDecision   Decision        `json:"pivotDecision"`
	LatestVoted     *hexutil.Uint64 `json:"latestVoted"`
	LatestTxNumber  hexutil.Uint64  `json:"latestTxNumber"`
}

type Decision struct {
	BlockHash common.Hash    `json:"blockHash"`
	Height    hexutil.Uint64 `json:"height"`
}

var (
	BlockEarliest        = &BlockNumber{"earliest", 0}
	BlockLatestCommitted = &BlockNumber{"latest_committed", 0}
	BlockLatestVoted     = &BlockNumber{"latest_voted", 0}
)

type BlockNumber struct {
	name   string
	number hexutil.Uint64
}

// String implements the fmt.Stringer interface
func (e *BlockNumber) String() string {
	if e.name == "" {
		return e.number.String()
	}

	return e.name
}

// MarshalText implements the encoding.TextMarshaler interface.
func (e BlockNumber) MarshalText() ([]byte, error) {
	// fmt.Println("marshal text for epoch")
	return []byte(e.String()), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (e *BlockNumber) UnmarshalJSON(data []byte) error {
	var input string

	if err := json.Unmarshal(data, &input); err != nil {
		return err
	}

	hexU64Pattern := `(?i)^0x[a-f0-9]*$`
	if ok, _ := regexp.Match(hexU64Pattern, []byte(input)); ok {
		numU64, err := hexutil.DecodeUint64(input)
		if err != nil {
			return errors.WithStack(err)
		}
		e.number = hexutil.Uint64(numU64)
		return nil
	}

	switch input {
	case BlockEarliest.name, BlockLatestCommitted.name, BlockLatestVoted.name:
		e.name = input
		return nil
	}

	return fmt.Errorf(`unsupported pos block number tag %v`, input)
}

type Address = common.Hash

type Signature struct {
	Account Address        `json:"account"`
	Votes   hexutil.Uint64 `json:"votes"`
}

type Block struct {
	Hash          common.Hash    `json:"hash"`
	Height        hexutil.Uint64 `json:"height"`
	Epoch         hexutil.Uint64 `json:"epoch"`
	Round         hexutil.Uint64 `json:"round"`
	LastTxNumber  hexutil.Uint64 `json:"lastTxNumber"`
	Miner         *Address       `json:"miner"`
	ParentHash    common.Hash    `json:"parentHash"`
	Timestamp     hexutil.Uint64 `json:"timestamp"`
	PivotDecision *Decision      `json:"pivotDecision"`
	Signatures    []Signature    `json:"signatures"`
}

func NewBlockNumber(number hexutil.Uint64) BlockNumber {
	return BlockNumber{"", number}
}

type LedgerInfo struct {
	CommitInfo BlockInfo `json:"commitInfo"`

	/// Hash of consensus specific data that is opaque to all parts of the
	/// system other than consensus.
	ConsensusDataHash hexutil.Bytes `json:"consensusDataHash"`
}

type BlockInfo struct {
	Epoch           hexutil.Uint64      `json:"epoch"`
	Round           hexutil.Uint64      `json:"round"`
	Id              hexutil.Bytes       `json:"id"`
	ExecutedStateId hexutil.Bytes       `json:"executedStateId"`
	Version         hexutil.Uint64      `json:"version"`
	TimestampUsecs  hexutil.Uint64      `json:"timestampUsecs"`
	NextEpochState  *EpochState         `json:"nextEpochState"`
	Pivot           *PivotBlockDecision `json:"pivot"`
}

type PivotBlockDecision struct {
	Height    hexutil.Uint64 `json:"height"`
	BlockHash H256           `json:"blockHash"`
}

type H256 string

func (h H256) ToHash() common.Hash {
	return common.HexToHash(string(h))
}

func (h H256) String() string {
	return string(h)
}

type EpochState struct {
	Epoch    hexutil.Uint64    `json:"epoch"`
	Verifier ValidatorVerifier `json:"verifier"`
	VrfSeed  hexutil.Bytes     `json:"vrfSeed"`
}

type ValidatorVerifier struct {
	// An ordered map of each validator's on-chain account address to its
	// pubkeys and voting power.
	AddressToValidatorInfo map[common.Hash]ValidatorConsensusInfo `json:"addressToValidatorInfo"`
	// The minimum voting power required to achieve a quorum
	QuorumVotingPower hexutil.Uint64 `json:"quorumVotingPower"`
	// Total voting power of all validators (cached from
	// address_to_validator_info)
	TotalVotingPower hexutil.Uint64 `json:"totalVotingPower"`
}

type ValidatorConsensusInfo struct {
	PublicKey    hexutil.Bytes  `json:"publicKey"`              // compressed BLS public key
	VrfPublicKey *hexutil.Bytes `json:"vrfPublicKey,omitempty"` // nil if VRF not needed
	VotingPower  hexutil.Uint64 `json:"votingPower"`
}

type LedgerInfoWithSignatures struct {
	LedgerInfo LedgerInfo `json:"ledgerInfo"`
	// The validator is identified by its account address: in order to verify
	// a signature one needs to retrieve the public key of the validator
	// for the given epoch.
	//
	// BLS signature in uncompressed format
	Signatures map[common.Hash]hexutil.Bytes `json:"signatures"`
	// Validators with uncompressed BLS public key (in 96 bytes) if next epoch
	// state available. Generally, this is used to verify BLS signatures at client side.
	NextEpochValidators map[common.Hash]hexutil.Bytes `json:"nextEpochValidators"`
	// Aggregated BLS signature in 192 bytes.
	AggregatedSignature hexutil.Bytes `json:"aggregatedSignature"`
}

func (info *LedgerInfoWithSignatures) ValidatorsSorted() []common.Hash {
	var accounts PoSAccounts

	for k := range info.Signatures {
		accounts = append(accounts, k)
	}

	sort.Sort(accounts)

	return accounts
}

func (info *LedgerInfoWithSignatures) NextEpochValidatorsSorted() []common.Hash {
	if info.LedgerInfo.CommitInfo.NextEpochState == nil {
		return nil
	}

	var accounts PoSAccounts

	for k := range info.LedgerInfo.CommitInfo.NextEpochState.Verifier.AddressToValidatorInfo {
		accounts = append(accounts, k)
	}

	sort.Sort(accounts)

	return accounts
}

type PoSAccounts []common.Hash

func (s PoSAccounts) Len() int { return len(s) }
func (s PoSAccounts) Less(i, j int) bool {
	return bytes.Compare(s[i].Bytes(), s[j].Bytes()) < 0
}
func (s PoSAccounts) Swap(i, j int) { s[i], s[j] = s[j], s[i] }

// ILightNodeState is an auto generated low-level Go binding around an user-defined struct.
type ILightNodeState struct {
	Epoch                *big.Int
	Round                *big.Int
	EarliestBlockNumber  *big.Int
	FinalizedBlockNumber *big.Int
	Blocks               *big.Int
	MaxBlocks            *big.Int
}

// LedgerInfoLibLedgerInfoWithSignatures is an auto generated low-level Go binding around an user-defined struct.
type LedgerInfoLibLedgerInfoWithSignatures struct {
	Epoch               uint64
	Round               uint64
	Id                  [32]byte
	ExecutedStateId     [32]byte
	Version             uint64
	TimestampUsecs      uint64
	NextEpochState      LedgerInfoLibEpochState
	Pivot               LedgerInfoLibDecision
	ConsensusDataHash   [32]byte
	Accounts            [][32]byte
	AggregatedSignature []byte
	//Signatures []LedgerInfoLibAccountSignature
}

type LedgerInfoLibEpochState struct {
	Epoch             uint64
	Validators        []LedgerInfoLibValidatorInfo
	QuorumVotingPower uint64
	TotalVotingPower  uint64
	VrfSeed           []byte
}

type LedgerInfoLibDecision struct {
	BlockHash [32]byte
	Height    uint64
}

type LedgerInfoLibAccountSignature struct {
	Account            [32]byte
	ConsensusSignature []byte
}

type LedgerInfoLibValidatorInfo struct {
	Account               [32]byte
	CompressedPublicKey   []byte
	UncompressedPublicKey []byte
	VrfPublicKey          []byte
	VotingPower           uint64
}

// Epoch represents an epoch in Conflux.
type Epoch struct {
	name   string
	number *hexutil.Big
}

// Const epoch definitions
var (
	EpochEarliest         *Epoch = &Epoch{"earliest", nil}
	EpochLatestCheckpoint *Epoch = &Epoch{"latest_checkpoint", nil}
	EpochLatestConfirmed  *Epoch = &Epoch{"latest_confirmed", nil}
	EpochLatestState      *Epoch = &Epoch{"latest_state", nil}
	EpochLatestMined      *Epoch = &Epoch{"latest_mined", nil}
	EpochLatestFinalized  *Epoch = &Epoch{"latest_finalized", nil}
)

// NewEpochNumber creates an instance of Epoch with specified number.
func NewEpochNumber(number *hexutil.Big) *Epoch {
	return &Epoch{"", number}
}

func (e *Epoch) String() string {
	if e.number != nil {
		return e.number.String()
	}

	return e.name
}

func (e *Epoch) ToInt() (result *big.Int, isSuccess bool) {
	if e.number != nil {
		return e.number.ToInt(), true
	}

	if e.name == EpochEarliest.name {
		return common.Big0, true
	}

	return nil, false
}

func (e *Epoch) Equals(target *Epoch) bool {
	if e == nil {
		panic("input could not be nil")
	}

	if target == nil {
		return false
	}

	if e == target {
		return true
	}

	if len(e.name) > 0 || len(target.name) > 0 {
		return e.name == target.name
	}

	if e.number == nil || target.number == nil {
		return e.number == target.number
	}

	return e.number.ToInt().Cmp(target.number.ToInt()) == 0
}

func (e Epoch) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

func (e *Epoch) UnmarshalJSON(data []byte) error {
	var input string
	if err := json.Unmarshal(data, &input); err != nil {
		return err
	}

	switch input {
	case EpochEarliest.name,
		EpochLatestCheckpoint.name,
		EpochLatestConfirmed.name,
		EpochLatestState.name,
		EpochLatestMined.name,
		EpochLatestFinalized.name:
		e.name = input
		return nil
	default:
		if len(input) == 66 {
			e.name = input
			return nil
		}

		epochNumber, err := hexutil.DecodeBig(input)
		if err != nil {
			return err
		}

		e.number = NewBigIntByRaw(epochNumber)
		return nil
	}
}

func NewBigIntByRaw(x *big.Int) *hexutil.Big {
	if x == nil {
		return nil
	}
	v := hexutil.Big(*x)
	return &v
}

// BlockSummary includes block header and a list of transaction hashes
type BlockSummary struct {
	BlockHeader
	//Transactions []Hash `json:"transactions"`
}

// rlpEncodableBlockSummary block summary struct used for rlp encoding
type rlpEncodableBlockSummary struct {
	BlockHeader BlockHeader
	//Transactions []Hash
}

// EncodeRLP implements the rlp.Encoder interface.
func (bs BlockSummary) EncodeRLP(w io.Writer) error {
	rbs := rlpEncodableBlockSummary{
		bs.BlockHeader,
		//bs.Transactions,
	}

	return rlp.Encode(w, rbs)
}

// DecodeRLP implements the rlp.Decoder interface.
func (bs *BlockSummary) DecodeRLP(r *rlp.Stream) error {
	var rbs rlpEncodableBlockSummary
	if err := r.Decode(&rbs); err != nil {
		return err
	}

	bs.BlockHeader = rbs.BlockHeader
	//bs.Transactions = rbs.Transactions

	return nil
}

type rlpNilableBigInt struct {
	Val *big.Int
}

type rlpEncodableBlockHeader struct {
	Hash                  types.Hash
	ParentHash            types.Hash
	Height                *big.Int
	Miner                 types.Address
	DeferredStateRoot     types.Hash
	DeferredReceiptsRoot  types.Hash
	DeferredLogsBloomHash types.Hash
	Blame                 hexutil.Uint64
	TransactionsRoot      types.Hash
	EpochNumber           *big.Int
	BlockNumber           *rlpNilableBigInt `rlp:"nil"`
	GasLimit              *big.Int
	GasUsed               *rlpNilableBigInt `rlp:"nil"`
	Timestamp             *big.Int
	Difficulty            *big.Int
	PowQuality            *big.Int
	RefereeHashes         []types.Hash
	Adaptive              bool
	Nonce                 *big.Int
	Size                  *big.Int
	Custom                []Bytes
	PosReference          *types.Hash `rlp:"nil"`
}

// EncodeRLP implements the rlp.Encoder interface.
func (bh BlockHeader) EncodeRLP(w io.Writer) error {
	rbh := rlpEncodableBlockHeader{
		Hash:                  bh.Hash,
		ParentHash:            bh.ParentHash,
		Height:                bh.Height.ToInt(),
		Miner:                 bh.Miner,
		DeferredStateRoot:     bh.DeferredStateRoot,
		DeferredReceiptsRoot:  bh.DeferredReceiptsRoot,
		DeferredLogsBloomHash: bh.DeferredLogsBloomHash,
		Blame:                 bh.Blame,
		TransactionsRoot:      bh.TransactionsRoot,
		EpochNumber:           bh.EpochNumber.ToInt(),
		GasLimit:              bh.GasLimit.ToInt(),
		Timestamp:             bh.Timestamp.ToInt(),
		Difficulty:            bh.Difficulty.ToInt(),
		PowQuality:            bh.PowQuality.ToInt(),
		RefereeHashes:         bh.RefereeHashes,
		Adaptive:              bh.Adaptive,
		Nonce:                 bh.Nonce.ToInt(),
		Size:                  bh.Size.ToInt(),
		Custom:                bh.Custom,
		PosReference:          bh.PosReference,
	}

	if bh.BlockNumber != nil {
		rbh.BlockNumber = &rlpNilableBigInt{bh.BlockNumber.ToInt()}
	}

	if bh.GasUsed != nil {
		rbh.GasUsed = &rlpNilableBigInt{bh.GasUsed.ToInt()}
	}

	return rlp.Encode(w, rbh)
}

// DecodeRLP implements the rlp.Decoder interface.
func (bh *BlockHeader) DecodeRLP(r *rlp.Stream) error {
	var rbh rlpEncodableBlockHeader
	if err := r.Decode(&rbh); err != nil {
		return err
	}

	bh.Hash, bh.ParentHash, bh.Height = rbh.Hash, rbh.ParentHash, (*hexutil.Big)(rbh.Height)
	bh.Miner, bh.DeferredStateRoot = rbh.Miner, rbh.DeferredStateRoot
	bh.DeferredReceiptsRoot, bh.DeferredLogsBloomHash = rbh.DeferredReceiptsRoot, rbh.DeferredLogsBloomHash
	bh.Blame, bh.TransactionsRoot = rbh.Blame, rbh.TransactionsRoot
	bh.EpochNumber = (*hexutil.Big)(rbh.EpochNumber)
	bh.GasLimit = (*hexutil.Big)(rbh.GasLimit)
	bh.Timestamp = (*hexutil.Big)(rbh.Timestamp)
	bh.Difficulty, bh.PowQuality = (*hexutil.Big)(rbh.Difficulty), (*hexutil.Big)(rbh.PowQuality)
	bh.RefereeHashes, bh.Adaptive = rbh.RefereeHashes, rbh.Adaptive
	bh.Nonce, bh.Size, bh.Custom = (*hexutil.Big)(rbh.Nonce), (*hexutil.Big)(rbh.Size), rbh.Custom
	bh.PosReference = rbh.PosReference

	if rbh.BlockNumber != nil {
		bh.BlockNumber = (*hexutil.Big)(rbh.BlockNumber.Val)
	}

	if rbh.GasUsed != nil {
		bh.GasUsed = (*hexutil.Big)(rbh.GasUsed.Val)
	}

	return nil
}

'''
'''--- internal/conflux/tx.go ---
package conflux

import (
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/conflux/types"
	"io"
	"math/big"
)

type Transaction struct {
	Hash             types.Hash      `json:"hash"`
	Nonce            *hexutil.Big    `json:"nonce"`
	BlockHash        *types.Hash     `json:"blockHash"`
	TransactionIndex *hexutil.Uint64 `json:"transactionIndex"`
	From             Address         `json:"from"`
	To               *Address        `json:"to"`
	Value            *hexutil.Big    `json:"value"`
	GasPrice         *hexutil.Big    `json:"gasPrice"`
	Gas              *hexutil.Big    `json:"gas"`
	ContractCreated  *Address        `json:"contractCreated"`
	Data             string          `json:"data"`
	StorageLimit     *hexutil.Big    `json:"storageLimit"`
	EpochHeight      *hexutil.Big    `json:"epochHeight"`
	ChainID          *hexutil.Big    `json:"chainId"`
	Status           *hexutil.Uint64 `json:"status"`
	V                *hexutil.Big    `json:"v"`
	R                *hexutil.Big    `json:"r"`
	S                *hexutil.Big    `json:"s"`
}

// rlpEncodableTransaction transaction struct used for rlp encoding
type rlpEncodableTransaction struct {
	Hash             types.Hash
	Nonce            *big.Int
	BlockHash        *types.Hash
	TransactionIndex *hexutil.Uint64
	From             Address
	To               *Address `rlp:"nil"`
	Value            *big.Int
	GasPrice         *big.Int
	Gas              *big.Int
	ContractCreated  *Address `rlp:"nil"` // nil means contract creation
	Data             string
	StorageLimit     *big.Int
	EpochHeight      *big.Int
	ChainID          *big.Int
	Status           *hexutil.Uint64

	//signature
	V *big.Int
	R *big.Int
	S *big.Int
}

// EncodeRLP implements the rlp.Encoder interface.
func (tx Transaction) EncodeRLP(w io.Writer) error {
	rtx := rlpEncodableTransaction{
		tx.Hash, tx.Nonce.ToInt(), tx.BlockHash, tx.TransactionIndex, tx.From, tx.To,
		tx.Value.ToInt(), tx.GasPrice.ToInt(), tx.Gas.ToInt(), tx.ContractCreated, tx.Data,
		tx.StorageLimit.ToInt(), tx.EpochHeight.ToInt(), tx.ChainID.ToInt(), tx.Status,
		tx.V.ToInt(), tx.R.ToInt(), tx.S.ToInt(),
	}

	return rlp.Encode(w, rtx)
}

// DecodeRLP implements the rlp.Decoder interface.
func (tx *Transaction) DecodeRLP(r *rlp.Stream) error {
	var rtx rlpEncodableTransaction
	if err := r.Decode(&rtx); err != nil {
		return err
	}

	tx.Hash, tx.Nonce, tx.BlockHash = rtx.Hash, (*hexutil.Big)(rtx.Nonce), rtx.BlockHash
	tx.TransactionIndex, tx.From, tx.To = rtx.TransactionIndex, rtx.From, rtx.To
	tx.Value, tx.GasPrice = (*hexutil.Big)(rtx.Value), (*hexutil.Big)(rtx.GasPrice)
	tx.Gas, tx.ContractCreated, tx.Data = (*hexutil.Big)(rtx.Gas), rtx.ContractCreated, rtx.Data
	tx.StorageLimit, tx.EpochHeight = (*hexutil.Big)(rtx.StorageLimit), (*hexutil.Big)(rtx.EpochHeight)
	tx.ChainID, tx.Status, tx.V = (*hexutil.Big)(rtx.ChainID), rtx.Status, (*hexutil.Big)(rtx.V)
	tx.R, tx.S = (*hexutil.Big)(rtx.R), (*hexutil.Big)(rtx.S)

	return nil
}

'''
'''--- internal/conflux/types.go ---
package conflux

import (
	"encoding/json"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/conflux/types"
	"io"
)

type BlockHeader struct {
	Hash                  types.Hash     `json:"hash"`
	ParentHash            types.Hash     `json:"parentHash"`
	Height                *hexutil.Big   `json:"height"`
	Miner                 types.Address  `json:"miner"`
	DeferredStateRoot     types.Hash     `json:"deferredStateRoot"`
	DeferredReceiptsRoot  types.Hash     `json:"deferredReceiptsRoot"`
	DeferredLogsBloomHash types.Hash     `json:"deferredLogsBloomHash"`
	Blame                 hexutil.Uint64 `json:"blame"`
	TransactionsRoot      types.Hash     `json:"transactionsRoot"`
	EpochNumber           *hexutil.Big   `json:"epochNumber"`
	BlockNumber           *hexutil.Big   `json:"blockNumber"`
	GasLimit              *hexutil.Big   `json:"gasLimit"`
	GasUsed               *hexutil.Big   `json:"gasUsed"`
	Timestamp             *hexutil.Big   `json:"timestamp"`
	Difficulty            *hexutil.Big   `json:"difficulty"`
	PowQuality            *hexutil.Big   `json:"powQuality"`
	RefereeHashes         []types.Hash   `json:"refereeHashes"`
	Adaptive              bool           `json:"adaptive"`
	Nonce                 *hexutil.Big   `json:"nonce"`
	Size                  *hexutil.Big   `json:"size"`
	Custom                []Bytes        `json:"custom"`
	PosReference          *types.Hash    `json:"posReference"`
}

type Bytes []byte

func (b Bytes) MarshalText() ([]byte, error) {
	return hexutil.Bytes(b).MarshalText()
}

func (b *Bytes) UnmarshalJSON(data []byte) error {
	var hex hexutil.Bytes
	if err := json.Unmarshal(data, &hex); err == nil {
		*b = Bytes([]byte(hex))
		return nil
	}

	nums := make([]uint, 0)
	if err := json.Unmarshal(data, &nums); err != nil {
		return err
	}

	for _, v := range nums {
		*b = append(*b, byte(v))
	}
	return nil
}

func (b *Bytes) ToBytes() []byte {
	return []byte(*b)
}

func (b *Bytes) ToHexBytes() hexutil.Bytes {
	return hexutil.Bytes(*b)
}

type CfxBlock struct {
	BlockHeader
	Transactions []Transaction `json:"transactions"`
}

// rlpEncodableBlock block struct used for rlp encoding
type rlpEncodableBlock struct {
	BlockHeader  BlockHeader
	Transactions []Transaction
}

// EncodeRLP implements the rlp.Encoder interface.
func (block CfxBlock) EncodeRLP(w io.Writer) error {
	rblock := rlpEncodableBlock{
		block.BlockHeader, block.Transactions,
	}

	return rlp.Encode(w, rblock)
}

// DecodeRLP implements the rlp.Decoder interface.
func (block *CfxBlock) DecodeRLP(r *rlp.Stream) error {
	var rblock rlpEncodableBlock
	if err := r.Decode(&rblock); err != nil {
		return err
	}

	block.BlockHeader = rblock.BlockHeader
	block.Transactions = rblock.Transactions

	return nil
}

'''
'''--- internal/conflux/types/address.go ---
package types

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/pkg/errors"
	"io"
	"reflect"
	"regexp"
	"strings"
)

type Address struct {
	networkType NetworkType
	addressType AddressType
	body        Body
	checksum    Checksum

	// cache
	hex       []byte
	networkID uint32
}

// String returns verbose base32 string of address
func (a Address) String() string {
	//if GetConfig().AddressStringVerbose {
	//	return a.MustGetVerboseBase32Address()
	//}
	return a.MustGetBase32Address()
}

// Equals reports whether a and target are equal
func (a *Address) Equals(target *Address) bool {
	return reflect.DeepEqual(a, target)
}

// New create conflux address by base32 string or hex40 string, if base32OrHex is base32 and networkID is passed it will create cfx Address use networkID.
func New(base32OrHex string, networkID ...uint32) (Address, error) {
	hexPattern := `(?i)^0x[a-f0-9]{40}$`
	base32Pattern := `(?i)^(cfx|cfxtest|net\d+):(type\.user:|type\.builtin:|type\.contract:|type\.null:|)\w{42}$`
	_networkID := uint32(0)
	if len(networkID) > 0 {
		_networkID = networkID[0]
	}

	if ok, _ := regexp.Match(hexPattern, []byte(base32OrHex)); ok {

		addr, err := NewFromHex(base32OrHex, _networkID)
		if err != nil {
			return Address{}, errors.Wrapf(err, "Failed to new address from hex %v networkID %v", base32OrHex, _networkID)
		}
		return addr, nil
	}

	if ok, _ := regexp.Match(base32Pattern, []byte(base32OrHex)); ok {
		addr, err := NewFromBase32(base32OrHex)
		if err != nil {
			return Address{}, errors.Wrapf(err, "Failed to new address from base32 string %v", base32OrHex)
		}
		if _networkID != 0 && addr.GetNetworkID() != _networkID {
			addr, err = NewFromHex(addr.GetHexAddress(), _networkID)
			if err != nil {
				return Address{}, errors.Wrapf(err, "Failed to new address from hex %v networkID %v", addr.GetHexAddress(), _networkID)
			}
		}
		return addr, nil
	}
	return Address{}, errors.Errorf("Input %v need be base32 string or hex40 string,", base32OrHex)
}

// MustNew create conflux address by base32 string or hex40 string, if base32OrHex is base32 and networkID is setted it will check if networkID match,
// it will painc if error occured.
func MustNew(base32OrHex string, networkID ...uint32) Address {
	address, err := New(base32OrHex, networkID...)
	if err != nil {
		panic(err)
	}
	return address
}

// NewFromBase32 creates address by base32 string
func NewFromBase32(base32Str string) (cfxAddress Address, err error) {
	if strings.ToLower(base32Str) != base32Str && strings.ToUpper(base32Str) != base32Str {
		return cfxAddress, errors.Errorf("not support base32 string with mix lowercase and uppercase %v", base32Str)
	}
	base32Str = strings.ToLower(base32Str)

	parts := strings.Split(base32Str, ":")
	if len(parts) < 2 || len(parts) > 3 {
		return cfxAddress, errors.Errorf("base32 string %v is invalid format", base32Str)
	}

	cfxAddress.networkType, err = NewNetowrkType(parts[0])
	if err != nil {
		return cfxAddress, errors.Wrapf(err, "failed to get network type of %v", parts[0])
	}

	bodyWithChecksum := parts[len(parts)-1]
	if len(bodyWithChecksum) < 8 {
		return cfxAddress, errors.Errorf("body with checksum length chould not length than 8, actual len(%v)=%v", bodyWithChecksum, len(bodyWithChecksum))
	}
	bodyStr := bodyWithChecksum[0 : len(bodyWithChecksum)-8]

	cfxAddress.body, err = NewBodyByString(bodyStr)
	if err != nil {
		return cfxAddress, errors.Wrapf(err, "failed to create body by %v", bodyStr)
	}

	_, hexAddress, err := cfxAddress.body.ToHexAddress()
	if err != nil {
		return cfxAddress, errors.Wrapf(err, "failed to get hex address by body %v", cfxAddress.body)
	}

	cfxAddress.addressType, err = CalcAddressType(hexAddress)
	if err != nil {
		return cfxAddress, errors.Wrapf(err, "failed to calc address type of %x", hexAddress)
	}

	if len(parts) == 3 && strings.ToLower(parts[1]) != cfxAddress.addressType.String() {
		return cfxAddress, errors.Errorf("invalid address type, expect %v actual %v", cfxAddress.addressType, parts[1])

	}

	cfxAddress.checksum, err = CalcChecksum(cfxAddress.networkType, cfxAddress.body)
	if err != nil {
		return cfxAddress, errors.Wrapf(err, "failed to calc checksum by network type %v and body %x", cfxAddress.networkType, cfxAddress.body)
	}

	expectChk := cfxAddress.checksum.String()
	actualChk := bodyWithChecksum[len(bodyWithChecksum)-8:]
	if expectChk != actualChk {
		err = errors.Errorf("invalid checksum, expect %v actual %v", expectChk, actualChk)
		return
	}

	if err = cfxAddress.setCache(); err != nil {
		err = errors.Wrapf(err, "failed to set cache")
		return
	}

	return
}

// NewFromHex creates address by hex address string with networkID
// If not pass networkID, it will be auto completed when it could be obtained form context.
func NewFromHex(hexAddressStr string, networkID ...uint32) (val Address, err error) {
	if hexAddressStr[0:2] == "0x" {
		hexAddressStr = hexAddressStr[2:]
	}

	hexAddress, err := hex.DecodeString(hexAddressStr)
	if err != nil {
		return val, errors.Wrapf(err, "failed to decode address string %x to hex", hexAddressStr)
	}

	return NewFromBytes(hexAddress, networkID...)
}

// NewFromCommon creates an address from common.Address with networkID
func NewFromCommon(commonAddress common.Address, networkID ...uint32) (val Address, err error) {
	return NewFromBytes(commonAddress.Bytes(), networkID...)
}

// NewFromBytes creates an address from hexAddress byte slice with networkID
func NewFromBytes(hexAddress []byte, networkID ...uint32) (val Address, err error) {
	val.networkType = NewNetworkTypeByID(get1stNetworkIDIfy(networkID))
	val.addressType, err = CalcAddressType(hexAddress)

	if err != nil {
		return val, errors.Wrapf(err, "failed to calculate address type of %x", hexAddress)
	}

	versionByte, err := CalcVersionByte(hexAddress)
	if err != nil {
		return val, errors.Wrapf(err, "failed to calculate version type of %x", hexAddress)
	}

	val.body, err = NewBodyByHexAddress(versionByte, hexAddress)
	if err != nil {
		return val, errors.Wrapf(err, "failed to create body by version byte %v and hex address %x", versionByte, hexAddress)
	}

	val.checksum, err = CalcChecksum(val.networkType, val.body)
	if err != nil {
		return val, errors.Wrapf(err, "failed to calc checksum by network type %v and body %x", val.networkType, val.body)
	}

	if err = val.setCache(); err != nil {
		err = errors.Wrapf(err, "failed to set cache")
		return
	}

	return val, nil
}

// MustNewFromBase32 creates address by base32 string and panic if error
func MustNewFromBase32(base32Str string) (address Address) {
	address, err := NewFromBase32(base32Str)
	if err != nil {
		panic(fmt.Errorf("input base32 string: %v, err:%v", base32Str, err))
	}
	return
}

// MustNewFromHex creates address by hex address string with networkID and panic if error
func MustNewFromHex(hexAddressStr string, networkID ...uint32) (val Address) {
	addr, err := NewFromHex(hexAddressStr, get1stNetworkIDIfy(networkID))
	if err != nil {
		panic(fmt.Errorf("input hex address:%v, networkID:%v, err:%v", hexAddressStr, networkID, err))
	}
	return addr
}

// MustNewFromCommon creates an address from common.Address with networkID and panic if error
func MustNewFromCommon(commonAddress common.Address, networkID ...uint32) (address Address) {
	addr, err := NewFromCommon(commonAddress, get1stNetworkIDIfy(networkID))
	if err != nil {
		panic(fmt.Errorf("input common address:%x, networkID:%v, err:%v", commonAddress, networkID, err))
	}
	return addr
}

// MustNewFromBytes creates an address from hexAddress byte slice with networkID and panic if error
func MustNewFromBytes(hexAddress []byte, networkID ...uint32) (address Address) {
	addr, err := NewFromBytes(hexAddress, get1stNetworkIDIfy(networkID))
	if err != nil {
		panic(fmt.Errorf("input common address:%x, networkID:%v, err:%v", hexAddress, networkID, err))
	}
	return addr
}

// ToHex returns hex address and networkID
func (a *Address) ToHex() (hexAddressStr string, networkID uint32) {
	validAddr := a.getDefaultIfEmpty()
	return "0x" + hex.EncodeToString(validAddr.hex), validAddr.networkID
}

// ToCommon returns common.Address and networkID
func (a *Address) ToCommon() (address common.Address, networkID uint32, err error) {
	validAddr := a.getDefaultIfEmpty()
	if len(validAddr.hex) > 42 {
		err = errors.Errorf("could not convert %v to common address which length large than 42", validAddr.hex)
		return
	}
	address = common.BytesToAddress(validAddr.hex)
	networkID = validAddr.networkID
	return
}

// MustGetBase32Address returns base32 string of address which doesn't include address type
func (a *Address) MustGetBase32Address() string {
	validAddr := a.getDefaultIfEmpty()
	return strings.ToLower(fmt.Sprintf("%v:%v%v", validAddr.networkType, validAddr.body, validAddr.checksum))
}

// MustGetVerboseBase32Address returns base32 string of address with address type
func (a *Address) MustGetVerboseBase32Address() string {
	validAddr := a.getDefaultIfEmpty()
	return strings.ToUpper(fmt.Sprintf("%v:%v:%v%v", validAddr.networkType, validAddr.addressType, validAddr.body, a.checksum))
}

// GetShortenAddress returns shorten string for display in dapp.
// When isTail4Char is 'true', the result will be like 'cfx:aat…sa4w', otherwise 'cfx:aat…5m81sa4w'
func (a *Address) GetShortenAddress(isTail4Char ...bool) string {
	validAddr := a.getDefaultIfEmpty()
	body := validAddr.body.String()[0:3]

	if len(isTail4Char) > 0 && isTail4Char[0] {
		checksum := validAddr.checksum.String()[4:]
		return strings.ToLower(fmt.Sprintf("%v:%v...%v", validAddr.networkType, body, checksum))
	}
	return strings.ToLower(fmt.Sprintf("%v:%v...%v", validAddr.networkType, body, validAddr.checksum))
}

// GetHexAddress returns hex format address and panic if error
func (a *Address) GetHexAddress() string {
	addr, _ := a.getDefaultIfEmpty().ToHex()
	return addr
}

// GetNetworkID returns networkID and panic if error
func (a *Address) GetNetworkID() uint32 {
	id, err := a.getDefaultIfEmpty().networkType.ToNetworkID()
	if err != nil {
		panic(fmt.Errorf("failed to get networkID of %v, err:%v", a, err))
	}
	return id
}

// MustGetCommonAddress returns common address and panic if error
func (a *Address) MustGetCommonAddress() common.Address {
	addr, _, err := a.ToCommon()
	if err != nil {
		panic(fmt.Errorf("failed to get common address of %v, err:%v", a, err))
	}
	return addr
}

// GetMappedEVMSpaceAddress calculate CFX space address's mapped EVM address, which is the last 20 bytes of cfx address's keccak256 hash
func (a *Address) GetMappedEVMSpaceAddress() common.Address {
	h := crypto.Keccak256Hash(a.MustGetCommonAddress().Bytes())
	var ethAddr common.Address
	copy(ethAddr[:], h[12:])
	return ethAddr
}

// GetNetworkType returns network type
func (a *Address) GetNetworkType() NetworkType {
	return a.getDefaultIfEmpty().networkType
}

// GetAddressType returuns address type
func (a *Address) GetAddressType() AddressType {
	return a.getDefaultIfEmpty().addressType
}

// GetBody returns body
func (a *Address) GetBody() Body {
	return a.getDefaultIfEmpty().body
}

// GetChecksum returns checksum
func (a *Address) GetChecksum() Checksum {
	return a.getDefaultIfEmpty().checksum
}

// CompleteByClient will set networkID by client.GetNetworkID() if a.networkID not be 0
func (a *Address) CompleteByClient(client networkIDGetter) error {
	networkID, err := client.GetNetworkID()
	if err != nil {
		return errors.Wrapf(err, "failed to get networkID")
	}
	a.CompleteByNetworkID(networkID)
	return nil
}

// CompleteByNetworkID will set networkID if current networkID isn't 0
func (a *Address) CompleteByNetworkID(networkID uint32) error {
	if a == nil {
		return nil
	}

	id, err := a.networkType.ToNetworkID()
	if err != nil || id == 0 {
		a.networkType = NewNetworkTypeByID(networkID)
		a.checksum, err = CalcChecksum(a.networkType, a.body)
		if err != nil {
			return errors.Wrapf(err, "failed to calc checksum by network type %v and body %v", a.networkType, a.body)
		}
	}
	return nil
}

// IsValid return true if address is valid
func (a *Address) IsValid() bool {
	return a.addressType == AddressTypeNull ||
		a.addressType == AddressTypeContract ||
		a.addressType == AddressTypeUser ||
		a.addressType == AddressTypeBuiltin
}

// rlpEncodableAddress address struct used for rlp encoding
type rlpEncodableAddress struct {
	NetworkType NetworkType
	AddressType AddressType
	Body        Body
	Checksum    Checksum
}

// EncodeRLP implements the rlp.Encoder interface.
func (a Address) EncodeRLP(w io.Writer) error {
	ra := rlpEncodableAddress{
		a.networkType, a.addressType, a.body, a.checksum,
	}

	return rlp.Encode(w, ra)
}

// DecodeRLP implements the rlp.Decoder interface.
func (a *Address) DecodeRLP(r *rlp.Stream) error {
	var ra rlpEncodableAddress
	if err := r.Decode(&ra); err != nil {
		return err
	}

	a.networkType, a.addressType = ra.NetworkType, ra.AddressType
	a.body, a.checksum = ra.Body, ra.Checksum

	if err := a.setCache(); err != nil {
		return err
	}

	return nil
}

// MarshalText implements the encoding.TextMarshaler interface.
func (a Address) MarshalText() ([]byte, error) {
	// fmt.Println("marshal text for epoch")
	return []byte(a.String()), nil
}

func (a *Address) UnmarshalText(data []byte) error {
	data = append([]byte("\""), data...)
	data = append(data, []byte("\"")...)
	return a.UnmarshalJSON(data)
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (a *Address) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		return nil
	}

	var str string
	err := json.Unmarshal(data, &str)
	if err != nil {
		return errors.Wrapf(err, "failed to unmarshal %x to string", data)
	}

	addr, err := NewFromBase32(str)
	if err != nil {
		return errors.Wrapf(err, "failed to create address from base32 string %v", str)
	}
	*a = addr
	return nil
}

func get1stNetworkIDIfy(networkID []uint32) uint32 {
	if len(networkID) > 0 {
		return networkID[0]
	}
	return 0
}

func (a *Address) setCache() error {
	var hexAddress []byte
	_, hexAddress, err := a.body.ToHexAddress()
	if err != nil {
		return errors.Wrapf(err, "failed convert %v to hex address", a.body)
	}
	a.hex = hexAddress

	networkID, err := a.networkType.ToNetworkID()
	if err != nil {
		return errors.Wrapf(err, "failed to get networkID of %v", networkID)
	}
	a.networkID = networkID
	return nil
}

func (a *Address) getDefaultIfEmpty() *Address {
	if (reflect.DeepEqual(*a, Address{})) {
		var zeroAddr common.Address
		cfxaddr := MustNewFromBytes(zeroAddr.Bytes(), 0)
		return &cfxaddr
	}
	return a
}

// networkIDGetter is a interface for obtaining networkID
type networkIDGetter interface {
	GetNetworkID() (uint32, error)
}

'''
'''--- internal/conflux/types/address_type.go ---
package types

import (
	"encoding/hex"
	"fmt"
	"github.com/pkg/errors"
	"reflect"
)

type AddressType string

const (
	AddressTypeBuiltin  AddressType = "builtin"
	AddressTypeUser     AddressType = "user"
	AddressTypeContract AddressType = "contract"
	AddressTypeNull     AddressType = "null"
	AddressTypeUnknown  AddressType = "unknown"
)

// CalcAddressType calculate address type of hexAddress
func CalcAddressType(hexAddress []byte) (AddressType, error) {
	if len(hexAddress) != 20 {
		return "", errors.Errorf("address must be 20 bytes, but it's %x", hexAddress)
	}

	nullAddr, err := hex.DecodeString("0000000000000000000000000000000000000000")
	if err != nil {
		return "", err
	}
	if reflect.DeepEqual(nullAddr, hexAddress) {
		return AddressTypeNull, nil
	}

	var addressType AddressType
	switch hexAddress[0] & 0xf0 {
	case 0x00:
		addressType = AddressTypeBuiltin
	case 0x10:
		addressType = AddressTypeUser
	case 0x80:
		addressType = AddressTypeContract
	default:
		addressType = AddressTypeUnknown
		// return "", errors.Errorf("Invalid address %x", hexAddress)
	}
	// fmt.Printf("calc address type of %x : %v\n", hexAddress, addressType)
	return addressType, nil
}

// ToByte returns byte represents of address type according to CIP-37
func (a AddressType) ToByte() (byte, error) {
	switch a {
	case AddressTypeNull:
		return 0x00, nil
	case AddressTypeBuiltin:
		return 0x00, nil
	case AddressTypeUser:
		return 0x10, nil
	case AddressTypeContract:
		return 0x80, nil
	}
	return 0, errors.Errorf("Invalid address type %v", a)
}

func (a AddressType) String() string {
	return fmt.Sprintf("type.%v", string(a))
}

'''
'''--- internal/conflux/types/body.go ---
package types

import (
	"github.com/pkg/errors"
	"strings"
)

var (
	ErrorBodyLen = errors.New("Body length must be 34")
)

type Body [34]byte

// NewBodyByString creates body by base32 string which contains version byte and hex address
func NewBodyByString(base32Str string) (body Body, err error) {
	if len(base32Str) != 34 {
		return body, ErrorBodyLen
	}

	for i, v := range base32Str {
		index, ok := alphabetToIndexMap[v]
		if !ok {
			err = errors.New("invalid base32 string for body")
		}
		body[i] = index
	}

	return
}

// NewBodyByHexAddress convert concat of version type and hex address to 5 bits slice
func NewBodyByHexAddress(vrsByte VersionByte, hexAddress []byte) (b Body, err error) {
	vb, err := vrsByte.ToByte()
	if err != nil {
		err = errors.Wrapf(err, "failed to encode version type %#v", vrsByte)
		return
	}
	concatenate := append([]byte{vb}, hexAddress[:]...)
	bits5, err := convert(concatenate, 8, 5)
	if err != nil {
		err = errors.Wrapf(err, "failed to convert %x from 8 to 5 bits array", concatenate)
		return
	}
	// b = bits5
	copy(b[:], bits5[:])
	return
}

// ToHexAddress decode bits5 array to version byte and hex address
func (b Body) ToHexAddress() (vrsType VersionByte, hexAddress []byte, err error) {
	if len(b) != 34 {
		err = errors.New("invalid base32 body, body need be 34 bytes")
		return
	}

	val, err := convert(b[:], 5, 8)
	vrsType = NewVersionByte(val[0])
	hexAddress = val[1:]
	return
}

// String return base32 string
func (b Body) String() string {
	return bits5sToString(b[:])
}

const (
	alphabet = "abcdefghjkmnprstuvwxyz0123456789"
)

var (
	alphabetToIndexMap map[rune]byte = make(map[rune]byte)
)

func init() {
	for i, v := range alphabet {
		alphabetToIndexMap[v] = byte(i)
	}
}

func convert(data []byte, inbits uint, outbits uint) ([]byte, error) {
	// fmt.Printf("convert %b from %v bits to %v bits\n", data, inbits, outbits)
	// only support bits length<=8
	if inbits > 8 || outbits > 8 {
		return nil, errors.New("only support bits length<=8")
	}

	accBits := uint(0) //accumulate bit length
	acc := uint16(0)   //accumulate value
	var ret []byte
	for _, d := range data {
		acc = acc<<uint16(inbits) | uint16(d)
		// fmt.Printf("acc1: %b\n", acc)
		accBits += inbits
		for accBits >= outbits {
			val := byte(acc >> uint16(accBits-outbits))
			// fmt.Printf("5bits val:%v\n", val)
			ret = append(ret, val)
			// fmt.Printf("ret: %b\n", ret)
			acc = acc & uint16(1<<(accBits-outbits)-1)
			// fmt.Printf("acc2: %b\n", acc)
			accBits -= outbits
		}
	}
	// if acc > 0 || accBits > 0 {
	if accBits > 0 && (inbits > outbits) {
		ret = append(ret, byte(acc<<uint16(outbits-accBits)))
	}
	// fmt.Printf("ret %b\n", ret)
	return ret, nil
}

func bits5sToString(dataInBits5 []byte) string {
	sb := strings.Builder{}
	for _, v := range dataInBits5 {
		sb.WriteRune(rune(alphabet[v]))
	}
	return sb.String()
}

'''
'''--- internal/conflux/types/checksum.go ---
package types

import "github.com/pkg/errors"

type Checksum [8]byte

// CalcChecksum calculates checksum by network type and body
func CalcChecksum(nt NetworkType, body Body) (c Checksum, err error) {
	var lower5bitsNettype []byte
	for _, v := range nt.String() {
		lower5bitsNettype = append(lower5bitsNettype, byte(v)&0x1f)
	}
	separator := byte(0)
	payload5Bits := body
	template := [8]byte{}

	checksumInput := append(lower5bitsNettype, separator)
	checksumInput = append(checksumInput, payload5Bits[:]...)
	checksumInput = append(checksumInput, template[:]...)

	// fmt.Printf("checksumInput:%x\n", checksumInput)

	uint64Chc := polymod(checksumInput)
	// fmt.Printf("uint64Chc:%x\n", uint64Chc)

	low40BitsChc := uint64ToBytes(uint64Chc)[3:]
	// fmt.Printf("low40BitsChc of %x:%x\n", uint64ToBytes(uint64Chc), low40BitsChc)

	checksumIn5Bits, err := convert(low40BitsChc, 8, 5)
	// fmt.Printf("low40BitsChcIn5Bits:%x\n", checksumIn5Bits)

	if err != nil {
		err = errors.Wrapf(err, "failed to convert %v from 8 to 5 bits", low40BitsChc)
		return
	}
	copy(c[:], checksumIn5Bits)
	return
}

// String returns base32 string of checksum according to CIP-37
func (c Checksum) String() string {
	return bits5sToString(c[:])
}

func polymod(v []byte) uint64 {
	c := uint64(1)
	for _, d := range v {
		c0 := byte(c >> 35)
		c = ((c & 0x07ffffffff) << 5) ^ uint64(d)
		if c0&0x01 != 0 {
			c ^= 0x98f2bc8e61
		}
		if c0&0x02 != 0 {
			c ^= 0x79b76d99e2
		}
		if c0&0x04 != 0 {
			c ^= 0xf33e5fb3c4
		}
		if c0&0x08 != 0 {
			c ^= 0xae2eabe2a8
		}
		if c0&0x10 != 0 {
			c ^= 0x1e4f43e470
		}
	}
	return c ^ 1
}

func uint64ToBytes(num uint64) []byte {
	r := make([]byte, 8)
	for i := 0; i < 8; i++ {
		r[7-i] = byte(num >> uint(i*8))
	}
	return r
}

'''
'''--- internal/conflux/types/epoch.go ---
package types

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"math/big"
)

// WebsocketEpochResponse represents result of epoch websocket subscription
type WebsocketEpochResponse struct {
	EpochHashesOrdered []Hash       `json:"epochHashesOrdered"`
	EpochNumber        *hexutil.Big `json:"epochNumber"`
}

// Epoch represents an epoch in Conflux.
type Epoch struct {
	name   string
	number *hexutil.Big
}

// Const epoch definitions
var (
	EpochEarliest         *Epoch = &Epoch{"earliest", nil}
	EpochLatestCheckpoint *Epoch = &Epoch{"latest_checkpoint", nil}
	EpochLatestConfirmed  *Epoch = &Epoch{"latest_confirmed", nil}
	EpochLatestState      *Epoch = &Epoch{"latest_state", nil}
	EpochLatestMined      *Epoch = &Epoch{"latest_mined", nil}
	EpochLatestFinalized  *Epoch = &Epoch{"latest_finalized", nil}
)

// NewEpochNumber creates an instance of Epoch with specified number.
func NewEpochNumber(number *hexutil.Big) *Epoch {
	return &Epoch{"", number}
}

// NewEpochNumberBig creates an instance of Epoch with specified big number.
func NewEpochNumberBig(number *big.Int) *Epoch {
	return &Epoch{"", NewBigIntByRaw(number)}
}

// NewEpochNumberUint64 creates an instance of Epoch with specified uint64 number.
func NewEpochNumberUint64(number uint64) *Epoch {
	return &Epoch{"", NewBigInt(number)}
}

// String implements the fmt.Stringer interface
func (e *Epoch) String() string {
	if e.number != nil {
		return e.number.String()
	}

	return e.name
}

// ToInt returns epoch number in type big.Int
func (e *Epoch) ToInt() (result *big.Int, isSuccess bool) {
	if e.number != nil {
		return e.number.ToInt(), true
	}

	if e.name == EpochEarliest.name {
		return common.Big0, true
	}

	return nil, false
}

// Equals checks if e equals target
func (e *Epoch) Equals(target *Epoch) bool {
	if e == nil {
		panic("input could not be nil")
	}

	if target == nil {
		return false
	}

	if e == target {
		return true
	}

	if len(e.name) > 0 || len(target.name) > 0 {
		return e.name == target.name
	}

	if e.number == nil || target.number == nil {
		return e.number == target.number
	}

	return e.number.ToInt().Cmp(target.number.ToInt()) == 0
}

// MarshalText implements the encoding.TextMarshaler interface.
func (e Epoch) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (e *Epoch) UnmarshalJSON(data []byte) error {
	var input string
	if err := json.Unmarshal(data, &input); err != nil {
		return err
	}

	switch input {
	case EpochEarliest.name,
		EpochLatestCheckpoint.name,
		EpochLatestConfirmed.name,
		EpochLatestState.name,
		EpochLatestMined.name,
		EpochLatestFinalized.name:
		e.name = input
		return nil
	default:
		if len(input) == 66 {
			e.name = input
			return nil
		}

		epochNumber, err := hexutil.DecodeBig(input)
		if err != nil {
			return err
		}

		e.number = NewBigIntByRaw(epochNumber)
		return nil
	}
}

type EpochOrBlockHash struct {
	epoch        *Epoch
	epochNumber  *hexutil.Big
	blockHash    *common.Hash
	requirePivot bool
}

// IsEpoch returns epoch if it is epoch, and the 2rd return value represents if is epoch.
func (e *EpochOrBlockHash) IsEpoch() (*Epoch, bool) {
	if e.epoch != nil {
		return e.epoch, true
	}
	if e.epochNumber != nil {
		return NewEpochNumber(e.epochNumber), true
	}
	return nil, false
}

// IsBlockHash returns "block hash" and "require pivot" if it is blockhash, and the 3rd return value represents if is block hash.
func (e *EpochOrBlockHash) IsBlockHash() (*common.Hash, bool, bool) {
	if e.blockHash != nil {
		return e.blockHash, e.requirePivot, true
	}
	return nil, false, false
}

// String implements the fmt.Stringer interface
func (e *EpochOrBlockHash) String() string {
	if e.epoch != nil {
		return e.epoch.String()
	}

	if e.epochNumber != nil {
		return e.epochNumber.String()
	}

	if e.blockHash != nil {
		return e.blockHash.String()
	}

	return "nil"
}

// MarshalText implements the encoding.TextMarshaler interface.
func (e EpochOrBlockHash) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

func (e EpochOrBlockHash) MarshalJSON() ([]byte, error) {
	if e.epoch != nil {
		return json.Marshal(e.epoch)
	}

	if e.epochNumber != nil {
		return json.Marshal(struct {
			EpochNumber *hexutil.Big `json:"epochNumber"`
		}{
			EpochNumber: e.epochNumber,
		})
	}

	if e.blockHash != nil {
		return json.Marshal(struct {
			BlockHash    common.Hash `json:"blockHash"`
			RequirePivot bool        `json:"requirePivot"`
		}{
			BlockHash:    *e.blockHash,
			RequirePivot: e.requirePivot,
		})
	}
	return nil, errors.New("unkown EpochOrBlockHash")
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (e *EpochOrBlockHash) UnmarshalJSON(data []byte) error {

	var epoch Epoch
	err := json.Unmarshal(data, &epoch)
	if err == nil {
		e.epoch = &epoch
		return nil
	}

	type tmpEpoch struct {
		EpochNumber  *hexutil.Big `json:"epochNumber"`
		BlockHash    *common.Hash `json:"blockHash"`
		RequirePivot bool         `json:"requirePivot"`
	}

	var val tmpEpoch
	err = json.Unmarshal(data, &val)
	if err != nil {
		return err
	}

	if val.EpochNumber != nil && val.BlockHash != nil {
		return fmt.Errorf("cannot specify both BlockHash and EpochNumber, choose one or the other")
	}
	if val.EpochNumber != nil && val.RequirePivot {
		return fmt.Errorf("cannot specify both EpochNumber and RequirePivot, choose one or the other")
	}
	if val.EpochNumber != nil {
		e.epochNumber = val.EpochNumber
		return nil
	}
	e.blockHash = val.BlockHash
	e.requirePivot = val.RequirePivot
	return nil
}

// NewEpochOrBlockHashWithEpoch creates an instance of Epoch with specified epoch.
func NewEpochOrBlockHashWithEpoch(epoch *Epoch) *EpochOrBlockHash {
	if epoch == nil {
		epoch = EpochLatestState
	}
	return &EpochOrBlockHash{epoch: epoch}
}

// NewEpochOrBlockHashWithBlockHash creates an instance of Epoch with specified block hash.
func NewEpochOrBlockHashWithBlockHash(blockHash Hash, requirePivot ...bool) *EpochOrBlockHash {
	if len(requirePivot) == 0 {
		requirePivot = append(requirePivot, false)
	}
	return &EpochOrBlockHash{nil, nil, blockHash.ToCommonHash(), requirePivot[0]}
}

'''
'''--- internal/conflux/types/eunms.go ---
package types

type TransactionOutcome uint8

const (
	TRANSACTION_OUTCOME_SUCCESS TransactionOutcome = iota
	TRANSACTION_OUTCOME_FAILURE
	TRANSACTION_OUTCOME_SKIPPED
)

type NativeSpaceOutcome uint8

const (
	NATIVE_SPACE_SUCCESS                         NativeSpaceOutcome = iota
	NATIVE_SPACE_EXCEPTION_WITH_NONCE_BUMPING                       // gas fee charged
	NATIVE_SPACE_EXCEPTION_WITHOUT_NONCE_BUMPING                    // no gas fee charged
)

type EvmSpaceOutcome uint8

const (
	EVM_SPACE_FAIL EvmSpaceOutcome = iota
	EVM_SPACE_SUCCESS
	EVM_SPACE_SKIPPED = 0xff
)

'''
'''--- internal/conflux/types/log.go ---
package types

import (
	"encoding/json"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/pkg/errors"
	"io"
	"math/big"
	"reflect"
)

type LogFilter struct {
	FromEpoch   *Epoch       `json:"fromEpoch,omitempty"`
	ToEpoch     *Epoch       `json:"toEpoch,omitempty"`
	FromBlock   *hexutil.Big `json:"fromBlock,omitempty"`
	ToBlock     *hexutil.Big `json:"toBlock,omitempty"`
	BlockHashes []Hash       `json:"blockHashes,omitempty"`
	Address     []Address    `json:"address,omitempty"`
	Topics      [][]Hash     `json:"topics,omitempty"`
}

// Log represents the event in a smart contract
type Log struct {
	Address             Address       `json:"address"`
	Topics              []Hash        `json:"topics"`
	Data                hexutil.Bytes `json:"data"`
	BlockHash           *Hash         `json:"blockHash,omitempty"`
	EpochNumber         *hexutil.Big  `json:"epochNumber,omitempty"`
	TransactionHash     *Hash         `json:"transactionHash,omitempty"`
	TransactionIndex    *hexutil.Big  `json:"transactionIndex,omitempty"`
	LogIndex            *hexutil.Big  `json:"logIndex,omitempty"`
	TransactionLogIndex *hexutil.Big  `json:"transactionLogIndex,omitempty"`
	Space               *SpaceType    `json:"space,omitempty"`
}

// rlpNilableBigInt nilable pointer to big int used for rlp encoding
type rlpNilableBigInt struct {
	Val *big.Int
}

// rlpEncodableLog log struct used for rlp encoding
type rlpEncodableLog struct {
	Address             Address
	Topics              []Hash
	Data                hexutil.Bytes
	BlockHash           *Hash             `rlp:"nil"`
	EpochNumber         *rlpNilableBigInt `rlp:"nil"`
	TransactionHash     *Hash             `rlp:"nil"`
	TransactionIndex    *rlpNilableBigInt `rlp:"nil"`
	LogIndex            *rlpNilableBigInt `rlp:"nil"`
	TransactionLogIndex *rlpNilableBigInt `rlp:"nil"`
}

func (l Log) toRlpEncodable() rlpEncodableLog {
	rlog := rlpEncodableLog{
		Address: l.Address, Topics: l.Topics, Data: l.Data,
		BlockHash: l.BlockHash, TransactionHash: l.TransactionHash,
	}

	if l.EpochNumber != nil {
		rlog.EpochNumber = &rlpNilableBigInt{l.EpochNumber.ToInt()}
	}

	if l.TransactionIndex != nil {
		rlog.TransactionIndex = &rlpNilableBigInt{l.TransactionIndex.ToInt()}
	}

	if l.LogIndex != nil {
		rlog.LogIndex = &rlpNilableBigInt{l.LogIndex.ToInt()}
	}

	if l.TransactionLogIndex != nil {
		rlog.TransactionLogIndex = &rlpNilableBigInt{l.TransactionLogIndex.ToInt()}
	}
	return rlog
}

func (r rlpEncodableLog) toNormal() Log {
	log := Log{}

	log.Address, log.Topics, log.Data = r.Address, r.Topics, r.Data
	log.BlockHash, log.TransactionHash = r.BlockHash, r.TransactionHash

	if r.EpochNumber != nil {
		log.EpochNumber = (*hexutil.Big)(r.EpochNumber.Val)
	}

	if r.TransactionIndex != nil {
		log.TransactionIndex = (*hexutil.Big)(r.TransactionIndex.Val)
	}

	if r.LogIndex != nil {
		log.LogIndex = (*hexutil.Big)(r.LogIndex.Val)
	}

	if r.TransactionLogIndex != nil {
		log.TransactionLogIndex = (*hexutil.Big)(r.TransactionLogIndex.Val)
	}
	return log
}

// EncodeRLP implements the rlp.Encoder interface.
func (log Log) EncodeRLP(w io.Writer) error {
	return rlp.Encode(w, log.toRlpEncodable())
}

// DecodeRLP implements the rlp.Decoder interface.
func (log *Log) DecodeRLP(r *rlp.Stream) error {
	var rlog rlpEncodableLog
	if err := r.Decode(&rlog); err != nil {
		return err
	}

	*log = rlog.toNormal()
	return nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (l *LogFilter) UnmarshalJSON(data []byte) error {
	type tmpLogFilter struct {
		FromEpoch   *Epoch          `json:"fromEpoch,omitempty"`
		ToEpoch     *Epoch          `json:"toEpoch,omitempty"`
		FromBlock   *hexutil.Big    `json:"fromBlock,omitempty"`
		ToBlock     *hexutil.Big    `json:"toBlock,omitempty"`
		BlockHashes []Hash          `json:"blockHashes,omitempty"`
		Address     interface{}     `json:"address,omitempty"`
		Topics      []interface{}   `json:"topics,omitempty"`
		Offset      *hexutil.Uint64 `json:"offset,omitempty"`
		Limit       *hexutil.Uint64 `json:"limit,omitempty"`
	}

	t := tmpLogFilter{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}

	var err error
	l.FromEpoch = t.FromEpoch
	l.ToEpoch = t.ToEpoch
	l.FromBlock = t.FromBlock
	l.ToBlock = t.ToBlock
	l.BlockHashes = t.BlockHashes
	if l.Address, err = resolveToAddresses(t.Address); err != nil {
		return err
	}
	if l.Topics, err = resolveToTopicsList(t.Topics); err != nil {
		return err
	}
	return nil
}

func resolveToAddresses(val interface{}) ([]Address, error) {
	// if val is nil, return
	if val == nil {
		return nil, nil
	}

	// if val is string, new address and return
	if addrStr, ok := val.(string); ok {
		addr, err := NewFromBase32(addrStr)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to create address by %v", addrStr)
		}
		return []Address{addr}, nil
	}

	// if val is string slice, new every item to cfxaddress
	if addrStrList, ok := val.([]interface{}); ok {
		addrList := make([]Address, 0)
		for _, v := range addrStrList {
			vStr, ok := v.(string)
			if !ok {
				return nil, errors.Errorf("could not conver type %v to address", reflect.TypeOf(v))
			}

			addr, err := NewFromBase32(vStr)
			if err != nil {
				return nil, errors.Wrapf(err, "failed to create address by %v", v)
			}
			addrList = append(addrList, addr)
		}
		return addrList, nil
	}

	return nil, errors.Errorf("failed to unmarshal %#v to address or address list", val)
}

func resolveToTopicsList(val []interface{}) ([][]Hash, error) {
	// if val is nil, return
	if val == nil {
		return nil, nil
	}

	// otherwise, convert every item to topics
	topicsList := make([][]Hash, 0)

	for _, v := range val {
		hashes, err := resolveToHashes(v)
		if err != nil {
			return nil, err
		}
		topicsList = append(topicsList, hashes)
	}
	return topicsList, nil
}

func resolveToHashes(val interface{}) ([]Hash, error) {
	// if val is nil, return
	if val == nil {
		return nil, nil
	}

	// if val is string, return
	if hashStr, ok := val.(string); ok {
		return []Hash{Hash(hashStr)}, nil
	}

	// if val is string slice, append every item
	if addrStrList, ok := val.([]interface{}); ok {
		addrList := make([]Hash, 0)
		for _, v := range addrStrList {
			vStr, ok := v.(string)
			if !ok {
				return nil, errors.Errorf("could not conver type %v to hash", reflect.TypeOf(v))
			}

			addrList = append(addrList, Hash(vStr))
		}
		return addrList, nil
	}

	return nil, errors.Errorf("failed to convert %v to hash or hashes", val)
}

'''
'''--- internal/conflux/types/network.go ---
package types

import (
	"fmt"
	"github.com/pkg/errors"
	"strconv"
)

type NetworkType string

func (n NetworkType) String() string {
	return string(n)
}

const (
	NetworkTypeMainnetPrefix NetworkType = "cfx"
	NetworkTypeTestNetPrefix NetworkType = "cfxtest"

	NetowrkTypeMainnetID uint32 = 1029
	NetworkTypeTestnetID uint32 = 1
)

// NewNetowrkType creates network type by string
func NewNetowrkType(netType string) (NetworkType, error) {
	if netType == NetworkTypeMainnetPrefix.String() || netType == NetworkTypeTestNetPrefix.String() {
		return NetworkType(netType), nil
	}
	_, err := getIDWhenBeginWithNet(netType)
	if err != nil {
		return "", err
	}
	return NetworkType(netType), nil
}

// NewNetworkTypeByID creates network type by network ID
func NewNetworkTypeByID(networkID uint32) NetworkType {
	var nt NetworkType
	switch networkID {
	case NetowrkTypeMainnetID:
		nt = NetworkTypeMainnetPrefix
	case NetworkTypeTestnetID:
		nt = NetworkTypeTestNetPrefix
	default:
		nt = NetworkType(fmt.Sprintf("net%v", networkID))
	}
	return nt
}

// ToNetworkID returns network ID
func (n NetworkType) ToNetworkID() (uint32, error) {
	switch n {
	case NetworkTypeMainnetPrefix:
		return NetowrkTypeMainnetID, nil
	case NetworkTypeTestNetPrefix:
		return NetworkTypeTestnetID, nil
	default:
		return getIDWhenBeginWithNet(string(n))
	}
}

func getIDWhenBeginWithNet(netIDStr string) (uint32, error) {
	if len(netIDStr) < 3 {
		return 0, errors.Errorf("Invalid network: %v", netIDStr)
	}

	if netIDStr[0:3] != "net" {
		return 0, errors.Errorf("Invalid network: %v", netIDStr)
	}

	netID, err := strconv.ParseUint(string(netIDStr[3:]), 0, 32)
	if err != nil {
		return 0, err
	}
	return uint32(netID), nil
}

'''
'''--- internal/conflux/types/transaction.go ---
package types

import (
	"encoding/json"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/pkg/errors"
	"io"
	"math/big"
)

type SpaceType string

const (
	SPACE_EVM    SpaceType = "evm"
	SPACE_NATIVE SpaceType = "native"
	SPACE_NONE   SpaceType = "none"
)

type Transaction struct {
	// Space            *string          `json:"space,omitempty"` //currently it is always "nil", so comment it now and uncomment it if need later
	Hash             Hash            `json:"hash"`
	Nonce            *hexutil.Big    `json:"nonce"`
	BlockHash        *Hash           `json:"blockHash"`
	TransactionIndex *hexutil.Uint64 `json:"transactionIndex"`
	From             Address         `json:"from"`
	To               *Address        `json:"to"`
	Value            *hexutil.Big    `json:"value"`
	GasPrice         *hexutil.Big    `json:"gasPrice"`
	Gas              *hexutil.Big    `json:"gas"`
	ContractCreated  *Address        `json:"contractCreated"`
	Data             string          `json:"data"`
	StorageLimit     *hexutil.Big    `json:"storageLimit"`
	EpochHeight      *hexutil.Big    `json:"epochHeight"`
	ChainID          *hexutil.Big    `json:"chainId"`
	Status           *hexutil.Uint64 `json:"status"`

	//signature
	V *hexutil.Big `json:"v"`
	R *hexutil.Big `json:"r"`
	S *hexutil.Big `json:"s"`
}

// rlpEncodableTransaction transaction struct used for rlp encoding
type rlpEncodableTransaction struct {
	Hash             Hash
	Nonce            *big.Int
	BlockHash        *Hash
	TransactionIndex *hexutil.Uint64
	From             Address
	To               *Address `rlp:"nil"`
	Value            *big.Int
	GasPrice         *big.Int
	Gas              *big.Int
	ContractCreated  *Address `rlp:"nil"` // nil means contract creation
	Data             string
	StorageLimit     *big.Int
	EpochHeight      *big.Int
	ChainID          *big.Int
	Status           *hexutil.Uint64

	//signature
	V *big.Int
	R *big.Int
	S *big.Int
}

// EncodeRLP implements the rlp.Encoder interface.
func (tx Transaction) EncodeRLP(w io.Writer) error {
	rtx := rlpEncodableTransaction{
		tx.Hash, tx.Nonce.ToInt(), tx.BlockHash, tx.TransactionIndex, tx.From, tx.To,
		tx.Value.ToInt(), tx.GasPrice.ToInt(), tx.Gas.ToInt(), tx.ContractCreated, tx.Data,
		tx.StorageLimit.ToInt(), tx.EpochHeight.ToInt(), tx.ChainID.ToInt(), tx.Status,
		tx.V.ToInt(), tx.R.ToInt(), tx.S.ToInt(),
	}

	return rlp.Encode(w, rtx)
}

// DecodeRLP implements the rlp.Decoder interface.
func (tx *Transaction) DecodeRLP(r *rlp.Stream) error {
	var rtx rlpEncodableTransaction
	if err := r.Decode(&rtx); err != nil {
		return err
	}

	tx.Hash, tx.Nonce, tx.BlockHash = rtx.Hash, (*hexutil.Big)(rtx.Nonce), rtx.BlockHash
	tx.TransactionIndex, tx.From, tx.To = rtx.TransactionIndex, rtx.From, rtx.To
	tx.Value, tx.GasPrice = (*hexutil.Big)(rtx.Value), (*hexutil.Big)(rtx.GasPrice)
	tx.Gas, tx.ContractCreated, tx.Data = (*hexutil.Big)(rtx.Gas), rtx.ContractCreated, rtx.Data
	tx.StorageLimit, tx.EpochHeight = (*hexutil.Big)(rtx.StorageLimit), (*hexutil.Big)(rtx.EpochHeight)
	tx.ChainID, tx.Status, tx.V = (*hexutil.Big)(rtx.ChainID), rtx.Status, (*hexutil.Big)(rtx.V)
	tx.R, tx.S = (*hexutil.Big)(rtx.R), (*hexutil.Big)(rtx.S)

	return nil
}

// TransactionReceipt represents the transaction execution result in Conflux.
// it is the response from conflux node when sending rpc request, such as cfx_getTransactionReceipt
type TransactionReceipt struct {
	TransactionHash    Hash            `json:"transactionHash"`
	Index              hexutil.Uint64  `json:"index"`
	BlockHash          Hash            `json:"blockHash"`
	EpochNumber        *hexutil.Uint64 `json:"epochNumber"`
	From               Address         `json:"from"`
	To                 *Address        `json:"to"`
	GasUsed            *hexutil.Big    `json:"gasUsed"`
	AccumulatedGasUsed *hexutil.Big    `json:"accumulatedGasUsed,omitempty"`
	GasFee             *hexutil.Big    `json:"gasFee"`
	ContractCreated    *Address        `json:"contractCreated"`
	Logs               []Log           `json:"logs"`
	LogsBloom          Bloom           `json:"logsBloom"`
	StateRoot          Hash            `json:"stateRoot"`
	OutcomeStatus      hexutil.Uint64  `json:"outcomeStatus"`
	TxExecErrorMsg     *string         `json:"txExecErrorMsg"`
	// Whether gas costs were covered by the sponsor.
	GasCoveredBySponsor bool `json:"gasCoveredBySponsor"`
	// Whether storage costs were covered by the sponsor.
	StorageCoveredBySponsor bool `json:"storageCoveredBySponsor"`
	// The amount of storage collateralized by the sender.
	StorageCollateralized hexutil.Uint64 `json:"storageCollateralized"`
	// Storage collaterals released during the execution of the transaction.
	StorageReleased []StorageChange `json:"storageReleased"`
	Space           *SpaceType      `json:"space,omitempty"`
}

func (r *TransactionReceipt) GetOutcomeType() (TransactionOutcome, error) {
	switch *r.Space {
	case SPACE_NATIVE:
		outcome := NativeSpaceOutcome(r.OutcomeStatus)
		switch outcome {
		case NATIVE_SPACE_SUCCESS:
			return TRANSACTION_OUTCOME_SUCCESS, nil
		case NATIVE_SPACE_EXCEPTION_WITH_NONCE_BUMPING:
			return TRANSACTION_OUTCOME_FAILURE, nil
		case NATIVE_SPACE_EXCEPTION_WITHOUT_NONCE_BUMPING:
			return TRANSACTION_OUTCOME_SKIPPED, nil
		}
	case SPACE_EVM:
		outcome := EvmSpaceOutcome(r.OutcomeStatus)
		switch outcome {
		case EVM_SPACE_SUCCESS:
			return TRANSACTION_OUTCOME_SUCCESS, nil
		case EVM_SPACE_FAIL:
			return TRANSACTION_OUTCOME_FAILURE, nil
		case EVM_SPACE_SKIPPED:
			return TRANSACTION_OUTCOME_SKIPPED, nil
		}
	default:
		return TransactionOutcome(0xff), errors.New("unknown space")
	}
	return TransactionOutcome(0xff), errors.New("unknown outcome status")
}

func (r *TransactionReceipt) MustGetOutcomeType() TransactionOutcome {
	result, err := r.GetOutcomeType()
	if err != nil {
		panic(err)
	}
	return result
}

// StorageChange represents storage change information of the address
type StorageChange struct {
	Address Address `json:"address"`
	/// Number of storage collateral units to deposit / refund (absolute value).
	Collaterals hexutil.Uint64 `json:"collaterals"`
}

// rlpEncodableTransactionReceipt transaction receipt struct used for rlp encoding
type rlpEncodableTransactionReceipt struct {
	TransactionHash Hash
	Index           hexutil.Uint64
	BlockHash       Hash
	EpochNumber     *hexutil.Uint64
	From            Address
	To              *Address `rlp:"nil"`
	GasUsed         *big.Int
	GasFee          *big.Int
	ContractCreated *Address `rlp:"nil"` // nil means contract creation
	Logs            []Log
	LogsBloom       Bloom
	StateRoot       Hash
	OutcomeStatus   hexutil.Uint64
	TxExecErrorMsg  *string `rlp:"nil"`
	// Whether gas costs were covered by the sponsor.
	GasCoveredBySponsor bool
	// Whether storage costs were covered by the sponsor.
	StorageCoveredBySponsor bool
	// The amount of storage collateralized by the sender.
	StorageCollateralized hexutil.Uint64
	// Storage collaterals released during the execution of the transaction.
	StorageReleased []StorageChange
}

// EncodeRLP implements the rlp.Encoder interface.
func (tr TransactionReceipt) EncodeRLP(w io.Writer) error {
	rtx := rlpEncodableTransactionReceipt{
		tr.TransactionHash, tr.Index, tr.BlockHash, tr.EpochNumber, tr.From, tr.To,
		tr.GasUsed.ToInt(), tr.GasFee.ToInt(), tr.ContractCreated, tr.Logs, tr.LogsBloom,
		tr.StateRoot, tr.OutcomeStatus, tr.TxExecErrorMsg, tr.GasCoveredBySponsor,
		tr.StorageCoveredBySponsor, tr.StorageCollateralized, tr.StorageReleased,
	}

	return rlp.Encode(w, rtx)
}

// DecodeRLP implements the rlp.Decoder interface.
func (tr *TransactionReceipt) DecodeRLP(r *rlp.Stream) error {
	var rtr rlpEncodableTransactionReceipt
	if err := r.Decode(&rtr); err != nil {
		return err
	}

	tr.TransactionHash, tr.Index, tr.BlockHash = rtr.TransactionHash, rtr.Index, rtr.BlockHash
	tr.EpochNumber, tr.From, tr.To = rtr.EpochNumber, rtr.From, rtr.To
	tr.GasUsed, tr.GasFee = (*hexutil.Big)(rtr.GasUsed), (*hexutil.Big)(rtr.GasFee)
	tr.ContractCreated, tr.Logs, tr.LogsBloom = rtr.ContractCreated, rtr.Logs, rtr.LogsBloom
	tr.StateRoot, tr.OutcomeStatus, tr.TxExecErrorMsg = rtr.StateRoot, rtr.OutcomeStatus, rtr.TxExecErrorMsg
	tr.GasCoveredBySponsor, tr.StorageCoveredBySponsor = rtr.GasCoveredBySponsor, rtr.StorageCoveredBySponsor
	tr.StorageCollateralized, tr.StorageReleased = rtr.StorageCollateralized, rtr.StorageReleased

	return nil
}

type AccountPendingTransactions struct {
	PendingTransactions []Transaction `json:"pendingTransactions"`
	// type maybe string/Pending
	FirstTxStatus *TransactionStatus `json:"firstTxStatus"`
	PendingCount  hexutil.Uint64     `json:"pendingCount"`
}

type PendingReason string

const (
	PENDING_REASON_FUTURE_NONCE     PendingReason = "futureNonce"
	PENDING_REASON_NOT_ENOUGH_CASH  PendingReason = "notEnoughCash"
	PENDING_REASON_OLD_EPOCH_HEIGHT PendingReason = "oldEpochHeight"
	PENDING_REASON_OUTDATED_STATUS  PendingReason = "outdatedStatus"
)

type pending struct {
	PendingReason PendingReason `json:"pending"`
}

type TransactionStatus struct {
	packedOrReady string
	pending       pending
}

func (ts TransactionStatus) String() string {
	if ts.packedOrReady != "" {
		return ts.packedOrReady
	}
	if (ts.pending != pending{}) {
		return string(ts.pending.PendingReason)
	}
	return ""
}

func (ts TransactionStatus) MarshalJSON() ([]byte, error) {
	if ts.packedOrReady != "" {
		return json.Marshal(ts.packedOrReady)
	}
	if (ts.pending != pending{}) {
		return json.Marshal(ts.pending)
	}
	return []byte{}, nil
}

func (ts *TransactionStatus) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		return nil
	}

	var pendingreason pending
	if err := json.Unmarshal(data, &pendingreason); err == nil {
		ts.pending = pendingreason
		return nil
	}

	var tmp string
	if err := json.Unmarshal(data, &tmp); err == nil {
		ts.packedOrReady = tmp
		return nil
	}

	return errors.Errorf("failed to json unmarshal %v to TransactionStatus", string(data))
}

func (ts *TransactionStatus) IsPending() (bool, PendingReason) {
	return ts.pending != pending{}, ts.pending.PendingReason
}

'''
'''--- internal/conflux/types/types.go ---
package types

import (
	"encoding/json"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"math/big"
)

type Hash string

// ToCommonHash converts hash to common.Hash
func (hash Hash) ToCommonHash() *common.Hash {
	newHash := common.HexToHash(string(hash))
	return &newHash
}

// String implements the interface stringer
func (hash Hash) String() string {
	return string(hash)
}

func (hash *Hash) UnmarshalJSON(input []byte) error {
	var h common.Hash
	if err := json.Unmarshal(input, &h); err != nil {
		return err
	}
	*hash = Hash(h.String())
	return nil
}

// Bloom is a hash type with 256 bytes.
type Bloom string

type NonceType int

const (
	NONCE_TYPE_AUTO NonceType = iota
	NONCE_TYPE_NONCE
	NONCE_TYPE_PENDING_NONCE
)

// NewBigInt creates a big number with specified uint64 value.
func NewBigInt(x uint64) *hexutil.Big {
	n1 := new(big.Int).SetUint64(x)
	n2 := hexutil.Big(*n1)
	return &n2
}

// NewBigIntByRaw creates a hexutil.big with specified big.int value.
func NewBigIntByRaw(x *big.Int) *hexutil.Big {
	if x == nil {
		return nil
	}
	v := hexutil.Big(*x)
	return &v
}

// NewUint64 creates a hexutil.Uint64 with specified uint64 value.
func NewUint64(x uint64) *hexutil.Uint64 {
	n1 := hexutil.Uint64(x)
	return &n1
}

// NewUint creates a hexutil.Uint with specified uint value.
func NewUint(x uint) *hexutil.Uint {
	n1 := hexutil.Uint(x)
	return &n1
}

// NewBytes creates a hexutil.Bytes with specified input value.
func NewBytes(input []byte) hexutil.Bytes {
	return hexutil.Bytes(input)
}

'''
'''--- internal/conflux/types/version_bytes.go ---
package types

import "github.com/pkg/errors"

type VersionByte struct {
	TypeBits uint8
	// current is constant 0, it's different with AddressType defined in address_type.go
	AddressType uint8
	SizeBits    uint8
}

var (
	hashSizeToBits map[uint]uint8 = make(map[uint]uint8)
)

func init() {
	hashSizeToBits[160] = 0
	hashSizeToBits[192] = 1
	hashSizeToBits[224] = 2
	hashSizeToBits[256] = 3
	hashSizeToBits[320] = 4
	hashSizeToBits[384] = 5
	hashSizeToBits[448] = 6
	hashSizeToBits[512] = 7
}

// ToByte returns byte
func (v VersionByte) ToByte() (byte, error) {
	ret := v.TypeBits & 0x80
	ret = ret | v.AddressType<<3
	ret = ret | v.SizeBits
	return ret, nil
}

// NewVersionByte creates version byte by byte
func NewVersionByte(b byte) (vt VersionByte) {
	vt.TypeBits = b >> 7
	vt.AddressType = (b & 0x7f) >> 3
	vt.SizeBits = b & 0x0f
	return
}

func CalcVersionByte(hexAddress []byte) (versionByte VersionByte, err error) {
	versionByte.TypeBits = 0
	versionByte.AddressType = 0
	addrBitsLen := uint(len(hexAddress) * 8)
	versionByte.SizeBits = hashSizeToBits[addrBitsLen]
	if versionByte.SizeBits == 0 && addrBitsLen != 160 {
		return versionByte, errors.Errorf("Invalid hash size %v", addrBitsLen)
	}
	return
}

'''
'''--- internal/constant/const.go ---
package constant

import (
	"errors"
	"github.com/ethereum/go-ethereum/common"
	"time"
)

const (
	TxRetryInterval     = time.Second * 5 // TxRetryInterval Time between retrying a failed tx
	NearTxRetryInterval = time.Second * 30
)

var (
	ErrNonceTooLow  = errors.New("nonce too low")
	ErrUnWantedSync = errors.New("unwanted Sync")
)

var (
	BlockRetryInterval = time.Second * 5
	RetryLongInterval  = time.Second * 10
	QueryRetryInterval = time.Second * 10
)

var (
	MaintainerInterval = time.Second * 3
	MessengerInterval  = time.Second * 1
)

var (
	ZeroAddress = common.HexToAddress("0x0000000000000000000000000000000000000000")
)

var (
	BalanceRetryInterval = time.Second * 60
)

var IgnoreError = map[string]struct{}{
	"order exist":                       {},
	"Header is have":                    {},
	"header is have":                    {},
	"height error":                      {},
	"invalid start block":               {},
	"invalid syncing block":             {},
	"initialized or unknown epoch":      {},
	"no need to update exe headers":     {},
	"could not replace existing tx":     {},
	"New block must have higher height": {},
	"round mismatch":                    {},
	"epoch mismatch":                    {},
	"headers size too big":              {},
	"Height error":                      {},
	"Update height0 error":              {},
	"invalid end exe header number":     {},
	"the update finalized slot should be higher than the finalized slot":      {},
	"previous exe block headers should be updated before update light client": {},
	"REVERT opcode executed":    {},
	"Validators repetition add": {},
	"oracle: already update":    {},
	"already verified":          {},
}

type BlockIdOfEth2 string

const (
	FinalBlockIdOfEth2   BlockIdOfEth2 = "finalized"
	HeadBlockIdOfEth2    BlockIdOfEth2 = "head"
	GenesisBlockIdOfEth2 BlockIdOfEth2 = "genesis"
)

const (
	SlotsPerEpoch   int64 = 32
	EpochsPerPeriod int64 = 256
)

const (
	ProofTypeOfOrigin = iota + 1
	ProofTypeOfZk
	ProofTypeOfOracle
)

const (
	LegacyTxType     = iota
	AccessListTxType = 0x01
	DynamicFeeTxType = 0x02
	BlobTxType       = 0x03
)

var (
	ReceiptStatusFailedRLP     = []byte{}
	ReceiptStatusSuccessfulRLP = []byte{0x01}
)

const (
	ReceiptStatusFailed = uint64(0)
)

const (
	MerlinChainId     = 4200
	EthChainId        = 5
	ZkSyncChainId     = 324
	B2ChainId         = 223
	OpChainId         = 10
	BaseChainId       = 8453
	BlastChainId      = 81457
	ArbChainId        = 421614
	ArbTestnetChainId = 42161
	MantleChainId     = 5000
	ScrollChainId     = 534352
	ZkLinkChainId     = 810180
)

const (
	TopicsOfSwapInVerified = "0x71b6b465a3e1914ab78a5c4e72ed92c70071ccf1a1bdee55bc47174cbcd47605"
)

const (
	ReqInterval = int64(2)
)

'''
'''--- internal/constant/events.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package constant

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

type EventSig string

func (es EventSig) GetTopic() common.Hash {
	return crypto.Keccak256Hash([]byte(es))
}

'''
'''--- internal/eth2/client.go ---
package eth2

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mapprotocol/compass/internal/constant"
)

const (
	contentType = "application/json"
	vsn         = "2.0"
)

var ErrNoResult = errors.New("no result in JSON-RPC response")

type Client struct {
	client    *http.Client
	endpoint  string
	closeOnce sync.Once
	closch    chan interface{}
	mu        sync.Mutex // protcts headers
	headers   http.Header
	isHttp    bool
	idCounter uint32
}

func DialHttp(endpoint string) (*Client, error) {
	// Sanity chck URL so we don't end up with a client that will fail every request.
	_, err := url.Parse(endpoint)
	if err != nil {
		return nil, err
	}

	headers := make(http.Header, 2)
	headers.Set("accept", contentType)
	headers.Set("content-type", contentType)
	client := &http.Client{
		Timeout: time.Second * 10,
	}
	return &Client{
		client:    client,
		endpoint:  endpoint,
		closeOnce: sync.Once{},
		closch:    make(chan interface{}),
		mu:        sync.Mutex{},
		headers:   headers,
	}, nil
}

func (c *Client) BeaconHeaders(ctx context.Context, blockId constant.BlockIdOfEth2) (*BeaconHeadersResp, error) {
	urlPath := fmt.Sprintf("%s/%s/%s", c.endpoint, "eth/v1/beacon/headers", blockId)
	var ret BeaconHeadersResp
	err := c.CallContext(ctx, urlPath, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) LightClientUpdate(ctx context.Context, startPeriod uint64) (*LightClientUpdatesResp, error) {
	urlPath := fmt.Sprintf("%s/%s?start_period=%d&count=1", c.endpoint, "eth/v1/beacon/light_client/updates", startPeriod)
	respBody, err := c.doRequest(ctx, urlPath)
	if err != nil {
		return nil, err
	}
	defer respBody.Close()
	var respMsg []CommonData
	if err = json.NewDecoder(respBody).Decode(&respMsg); err != nil {
		return nil, err
	}
	var ret LightClientUpdatesResp
	data, _ := json.Marshal(respMsg[0])
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) FinallyUpdate(ctx context.Context) (*FinalityUpdateResp, error) {
	urlPath := fmt.Sprintf("%s/%s", c.endpoint, "eth/v1/beacon/light_client/finality_update")
	var ret FinalityUpdateResp
	err := c.CallContext(ctx, urlPath, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) GetBlocks(ctx context.Context, blockId string) (*BlocksResp, error) {
	urlPath := fmt.Sprintf("%s/%s/%s", c.endpoint, "eth/v2/beacon/blocks", blockId)
	var ret BlocksResp
	err := c.CallContext(ctx, urlPath, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

type requestOp struct {
	ids  []json.RawMessage
	err  error
	resp chan *CommonData // receives up to len(ids) responses
}

func (op *requestOp) wait(ctx context.Context) (*CommonData, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case resp := <-op.resp:
		return resp, op.err
	}
}

func (c *Client) CallContext(ctx context.Context, url string, result interface{}) error {
	if result != nil && reflect.TypeOf(result).Kind() != reflect.Ptr {
		return fmt.Errorf("call result parameter must be pointer or nil interface: %v", result)
	}

	op := &requestOp{ids: []json.RawMessage{c.nextID()}, resp: make(chan *CommonData, 1)}

	err := c.sendHTTP(ctx, url, op)
	if err != nil {
		return err
	}

	// dispatch has accepted the request and will close the channel when it quits.
	switch resp, err := op.wait(ctx); {
	case err != nil:
		return err
	case resp.StatusCode == 404:
		return ErrNoResult
	case resp.Error != "":
		return errors.New(resp.Error)
	default:
		data, _ := json.Marshal(resp)
		return json.Unmarshal(data, &result)
	}
}

func (c *Client) nextID() json.RawMessage {
	id := atomic.AddUint32(&c.idCounter, 1)
	return strconv.AppendUint(nil, uint64(id), 10)
}

func (c *Client) sendHTTP(ctx context.Context, url string, op *requestOp) error {
	respBody, err := c.doRequest(ctx, url)
	if err != nil {
		return err
	}
	defer respBody.Close()

	var respMsg CommonData
	if err = json.NewDecoder(respBody).Decode(&respMsg); err != nil {
		return err
	}
	op.resp <- &respMsg
	return nil
}

func (c *Client) doRequest(ctx context.Context, url string) (io.ReadCloser, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, err
	}

	// set headers
	c.mu.Lock()
	req.Header = c.headers.Clone()
	c.mu.Unlock()

	// do request
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, fmt.Errorf("eth2 doRequest failed, code %v", resp.StatusCode)
	}
	return resp.Body, nil
}

'''
'''--- internal/eth2/eth.go ---
package eth2

import (
	"bytes"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
)

type Receipt struct {
	*types.Receipt
}

func (r *Receipt) statusEncoding() []byte {
	if len(r.PostState) == 0 {
		if r.Status == constant.ReceiptStatusFailed {
			return constant.ReceiptStatusFailedRLP
		}
		return constant.ReceiptStatusSuccessfulRLP
	}
	return r.PostState
}

type Receipts []*Receipt

func (rs Receipts) Len() int { return len(rs) }

func (rs Receipts) EncodeIndex(i int, w *bytes.Buffer) {
	r := rs[i]
	data := &proof.ReceiptRLP{PostStateOrStatus: r.statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, Bloom: r.Bloom, Logs: r.Logs}
	if r.Type == constant.LegacyTxType {
		rlp.Encode(w, data)
		return
	}
	w.WriteByte(r.Type)
	switch r.Type {
	case constant.AccessListTxType, constant.DynamicFeeTxType, constant.BlobTxType:
		rlp.Encode(w, data)
	default:
	}
}

'''
'''--- internal/eth2/proof.go ---
package eth2

import (
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/mapo"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/pkg/util"
	"math/big"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	log "github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
)

var execPath = "./eth2-proof"

func init() {
	if filepath.Dir(os.Args[0]) == "." {
		return
	}
	execPath = filepath.Join(filepath.Dir(os.Args[0]), "eth2-proof")
}

func Generate(slot, endpoint string) ([][32]byte, string, string, error) {
	c := exec.Command(execPath, "generate", "--slot", slot, "--endpoint", endpoint)
	log.Info("eth exec", "path", execPath, "cmd", c.String())
	subOutPut, err := c.CombinedOutput()
	if err != nil {
		return nil, "", "", errors.Wrap(err, "command exec failed")
	}

	outPuts := strings.Split(string(subOutPut), "\n")
	ret := make([][32]byte, 0, len(outPuts))
	var txRoot, wdRoot string
	for _, op := range outPuts {
		if strings.HasPrefix(op, "0x") {
			ret = append(ret, common.HexToHash(op))
		} else if strings.HasPrefix(op, "txRoot") {
			txRoot = strings.TrimSpace(strings.TrimPrefix(op, "txRoot"))
		} else if strings.HasPrefix(op, "wdRoot") {
			wdRoot = strings.TrimSpace(strings.TrimPrefix(op, "wdRoot"))
		}
	}

	return ret, txRoot, wdRoot, nil
}

func GenerateByApi(slot []string) [][32]byte {
	ret := make([][32]byte, 0, len(slot))
	for _, op := range slot {
		ret = append(ret, common.HexToHash(op))
	}

	return ret
}

type ReceiptProof struct {
	Header    BlockHeader
	TxReceipt mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

func AssembleProof(header BlockHeader, log types.Log, receipts []*types.Receipt, method string, fId msg.ChainId, proofType int64) ([]byte, error) {
	txIndex := log.TxIndex
	receipt, err := mapprotocol.GetTxReceipt(receipts[txIndex])
	if err != nil {
		return nil, err
	}
	pr := Receipts{}
	for _, r := range receipts {
		pr = append(pr, &Receipt{Receipt: r})
	}
	prf, err := proof.Get(pr, txIndex)
	if err != nil {
		return nil, err
	}
	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))

	var pack []byte
	switch proofType {
	case constant.ProofTypeOfOrigin:
		ek := mapo.Key2Hex(key, len(prf))
		pd := ReceiptProof{
			Header:    header,
			TxReceipt: *receipt,
			KeyIndex:  ek,
			Proof:     prf,
		}
		pack, err = proof.Pack(fId, method, mapprotocol.Eth2, pd)
	case constant.ProofTypeOfZk:
	case constant.ProofTypeOfOracle:
		pd := proof.Data{
			BlockNum: big.NewInt(int64(log.BlockNumber)),
			ReceiptProof: proof.ReceiptProof{
				TxReceipt: *receipt,
				KeyIndex:  util.Key2Hex(key, len(prf)),
				Proof:     prf,
			},
		}
		pack, err = proof.Pack(fId, method, mapprotocol.OracleAbi, pd)
	}

	return pack, nil
}

'''
'''--- internal/eth2/resp.go ---
package eth2

type CommonData struct {
	StatusCode          int         `json:"statusCode"`
	Error               string      `json:"error"`
	Message             string      `json:"message"`
	Data                interface{} `json:"data"`
	ExecutionOptimistic bool        `json:"execution_optimistic"`
	Version             string      `json:"version"`
}

type CommonDataArray struct {
	data []CommonData
}

type BeaconHeadersResp struct {
	Data                BeaconHeadersData `json:"data"`
	ExecutionOptimistic bool              `json:"execution_optimistic"`
}

type FinalityUpdateResp struct {
	Data    FinalityUpdateData `json:"data"`
	Version string             `json:"version"`
}

type BlocksResp struct {
	Data                BlockData `json:"data"`
	ExecutionOptimistic bool      `json:"execution_optimistic"`
}

type LightClientUpdatesResp struct {
	Data    LightClientUpdatesData `json:"data"`
	Version string                 `json:"version"`
}

type Message struct {
	Slot          string `json:"slot"`
	ProposerIndex string `json:"proposer_index"`
	ParentRoot    string `json:"parent_root"`
	StateRoot     string `json:"state_root"`
	BodyRoot      string `json:"body_root"`
}

type Header struct {
	Message   Message `json:"message"`
	Signature string  `json:"signature"`
}

type BeaconHeadersData struct {
	Root      string `json:"root"`
	Canonical bool   `json:"canonical"`
	Header    Header `json:"header"`
}

type AttestedHeader struct {
	Beacon          Beacon    `json:"beacon"`
	Execution       Execution `json:"execution"`
	ExecutionBranch []string  `json:"execution_branch"`
}

type FinalizedHeader struct {
	Beacon          Beacon    `json:"beacon"`
	Execution       Execution `json:"execution"`
	ExecutionBranch []string  `json:"execution_branch"`
}

type SyncAggregate struct {
	SyncCommitteeBits      string `json:"sync_committee_bits"`
	SyncCommitteeSignature string `json:"sync_committee_signature"`
}

type FinalityUpdateData struct {
	AttestedHeader  NewAttestedHeader  `json:"attested_header"`
	FinalizedHeader NewFinalizedHeader `json:"finalized_header"`
	FinalityBranch  []string           `json:"finality_branch"`
	SyncAggregate   SyncAggregate      `json:"sync_aggregate"`
	SignatureSlot   string             `json:"signature_slot"`
}

type Eth1Data struct {
	DepositRoot  string `json:"deposit_root"`
	DepositCount string `json:"deposit_count"`
	BlockHash    string `json:"block_hash"`
}

type Source struct {
	Epoch string `json:"epoch"`
	Root  string `json:"root"`
}

type Target struct {
	Epoch string `json:"epoch"`
	Root  string `json:"root"`
}

type Attestations struct {
	AggregationBits string          `json:"aggregation_bits"`
	Data            AttestationData `json:"data"`
	Signature       string          `json:"signature"`
}

type Body struct {
	RandaoReveal      string         `json:"randao_reveal"`
	Eth1Data          Eth1Data       `json:"eth1_data"`
	Graffiti          string         `json:"graffiti"`
	ProposerSlashings []interface{}  `json:"proposer_slashings"`
	AttesterSlashings []interface{}  `json:"attester_slashings"`
	Attestations      []Attestations `json:"attestations"`
	Deposits          []interface{}  `json:"deposits"`
	VoluntaryExits    []interface{}  `json:"voluntary_exits"`
	SyncAggregate     SyncAggregate  `json:"sync_aggregate"`
	ExecutionPayload  Execution      `json:"execution_payload"`
}

type BlocksMessage struct {
	Slot          string `json:"slot"`
	ProposerIndex string `json:"proposer_index"`
	ParentRoot    string `json:"parent_root"`
	StateRoot     string `json:"state_root"`
	Body          Body   `json:"body"`
}

type BlockData struct {
	Message   BlocksMessage `json:"message"`
	Signature string        `json:"signature"`
}

type NextSyncCommittee struct {
	Pubkeys         []string `json:"pubkeys"`
	AggregatePubkey string   `json:"aggregate_pubkey"`
}

type LightClientUpdatesData struct {
	AttestedHeader          NewAttestedHeader  `json:"attested_header"`
	NextSyncCommittee       NextSyncCommittee  `json:"next_sync_committee"`
	NextSyncCommitteeBranch []string           `json:"next_sync_committee_branch"`
	FinalizedHeader         NewFinalizedHeader `json:"finalized_header"`
	FinalityBranch          []string           `json:"finality_branch"`
	SyncAggregate           SyncAggregate      `json:"sync_aggregate"`
	SignatureSlot           string             `json:"signature_slot"`
}

type NewAttestedHeader struct {
	Beacon          Beacon    `json:"beacon"`
	Execution       Execution `json:"execution"`
	ExecutionBranch []string  `json:"execution_branch"`
}

type Beacon struct {
	Slot          string `json:"slot"`
	ProposerIndex string `json:"proposer_index"`
	ParentRoot    string `json:"parent_root"`
	StateRoot     string `json:"state_root"`
	BodyRoot      string `json:"body_root"`
}

type Execution struct {
	ParentHash       string `json:"parent_hash"`
	FeeRecipient     string `json:"fee_recipient"`
	StateRoot        string `json:"state_root"`
	ReceiptsRoot     string `json:"receipts_root"`
	LogsBloom        string `json:"logs_bloom"`
	PrevRandao       string `json:"prev_randao"`
	BlockNumber      string `json:"block_number"`
	GasLimit         string `json:"gas_limit"`
	GasUsed          string `json:"gas_used"`
	Timestamp        string `json:"timestamp"`
	ExtraData        string `json:"extra_data"`
	BaseFeePerGas    string `json:"base_fee_per_gas"`
	BlockHash        string `json:"block_hash"`
	TransactionsRoot string `json:"transactions_root"`
	WithdrawalsRoot  string `json:"withdrawals_root"`
}

type NewFinalizedHeader struct {
	Beacon          Beacon    `json:"beacon"`
	Execution       Execution `json:"execution"`
	ExecutionBranch []string  `json:"execution_branch"`
}

type AttestationData struct {
	BeaconBlockRoot string `json:"beacon_block_root"`
	Index           string `json:"index"`
	Slot            string `json:"slot"`
	Source          Source `json:"source"`
	Target          Target `json:"target"`
}

'''
'''--- internal/eth2/struct.go ---
package eth2

import (
	"math/big"
	"strings"

	"github.com/mapprotocol/compass/pkg/ethclient"

	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/common"
)

type LightClientUpdate struct {
	AttestedHeader          BeaconBlockHeader     `json:"attested_header"`
	SignatureSlot           uint64                `json:"signature_slot"`
	SyncAggregate           ContractSyncAggregate `json:"sync_aggregate"`
	NextSyncCommittee       ContractSyncCommittee `json:"nextSyncCommittee"`
	NextSyncCommitteeBranch [][32]byte            `json:"nextSyncCommitteeBranch"`
	FinalizedHeader         BeaconBlockHeader
	FinalityBranch          [][32]byte
	ExecutionBranch         [][32]byte
	FinalizedExecution      *ContractExecution
}

type BeaconBlockHeader struct {
	Slot          uint64   `json:"slot"`
	ProposerIndex uint64   `json:"proposer_index"`
	ParentRoot    [32]byte `json:"parent_root"` // bytes32
	StateRoot     [32]byte `json:"state_root"`  // bytes32
	BodyRoot      [32]byte `json:"body_root"`
}

type ContractSyncAggregate struct {
	SyncCommitteeBits      []byte `json:"sync_committee_bits"`
	SyncCommitteeSignature []byte `json:"sync_committee_signature"`
}

type ContractSyncCommittee struct {
	Pubkeys         []byte // 48 * 512
	AggregatePubkey []byte // 48
}

type BlockHeader struct {
	ParentHash       [32]byte       `json:"parent_hash"`
	Sha3Uncles       [32]byte       `json:"sha_3_uncles"`
	Miner            common.Address `json:"miner"`
	StateRoot        [32]byte       `json:"stateRoot"`
	TransactionsRoot [32]byte       `json:"transactionsRoot"`
	ReceiptsRoot     [32]byte       `json:"receiptsRoot"`
	LogsBloom        []byte         `json:"logsBloom"`
	Difficulty       *big.Int       `json:"difficulty"`
	Number           *big.Int       `json:"number"`
	GasLimit         *big.Int       `json:"gasLimit"`
	GasUsed          *big.Int       `json:"gasUsed"`
	Timestamp        *big.Int       `json:"timestamp"`
	ExtraData        []byte         `json:"extraData"`
	MixHash          [32]byte       `json:"mixHash"`
	Nonce            []byte         `json:"nonce"`
	BaseFeePerGas    *big.Int       `json:"baseFeePerGas"`
	WithdrawalsRoot  [32]byte       `json:"withdrawalsRoot"`
}

func ConvertHeader(header *ethclient.Header) *BlockHeader {
	withdrawalsRoot := common.HexToHash("0x0000000000000000000000000000000000000000000000000000000000000000")
	if header.WithdrawalsHash != "" {
		withdrawalsRoot = common.HexToHash(header.WithdrawalsHash)
	}
	return &BlockHeader{
		ParentHash:       header.ParentHash,
		Sha3Uncles:       header.UncleHash,
		Miner:            header.Coinbase,
		StateRoot:        header.Root,
		TransactionsRoot: header.TxHash,
		ReceiptsRoot:     header.ReceiptHash,
		LogsBloom:        header.Bloom.Bytes(),
		Difficulty:       header.Difficulty,
		Number:           header.Number,
		GasLimit:         new(big.Int).SetUint64(header.GasLimit),
		GasUsed:          new(big.Int).SetUint64(header.GasUsed),
		Timestamp:        new(big.Int).SetUint64(header.Time),
		ExtraData:        header.Extra,
		MixHash:          header.MixDigest,
		Nonce:            header.Nonce[:],
		BaseFeePerGas:    header.BaseFee,
		WithdrawalsRoot:  withdrawalsRoot,
	}
}

type ContractExecution struct {
	ParentHash       [32]byte       `json:"parent_hash"`
	FeeRecipient     common.Address `json:"fee_recipient"`
	StateRoot        [32]byte       `json:"state_root"`
	ReceiptsRoot     [32]byte       `json:"receipts_root"`
	LogsBloom        []byte         `json:"logs_bloom"`
	PrevRandao       [32]byte       `json:"prev_randao"`
	BlockNumber      *big.Int       `json:"block_number"`
	GasLimit         *big.Int       `json:"gas_limit"`
	GasUsed          *big.Int       `json:"gas_used"`
	Timestamp        *big.Int       `json:"timestamp"`
	ExtraData        []byte         `json:"extra_data"`
	BaseFeePerGas    *big.Int       `json:"base_fee_per_gas"`
	BlockHash        [32]byte       `json:"block_hash"`
	TransactionsRoot [32]byte       `json:"transactions_root"`
	WithdrawalsRoot  [32]byte       `json:"withdrawals_root"`
}

func ConvertExecution(execution *Execution) (*ContractExecution, error) {
	blockNumber, ok := big.NewInt(0).SetString(execution.BlockNumber, 10)
	if !ok {
		return nil, errors.New("execution blockNumber error")
	}
	gasLimit, ok := big.NewInt(0).SetString(execution.GasLimit, 10)
	if !ok {
		return nil, errors.New("execution gasLimit error")
	}
	gasUsed, ok := big.NewInt(0).SetString(execution.GasUsed, 10)
	if !ok {
		return nil, errors.New("execution gasUsed error")
	}
	timestamp, ok := big.NewInt(0).SetString(execution.Timestamp, 10)
	if !ok {
		return nil, errors.New("execution timestamp error")
	}
	baseFeePerGas, ok := big.NewInt(0).SetString(execution.BaseFeePerGas, 10)
	if !ok {
		return nil, errors.New("execution baseFeePerGas error")
	}
	return &ContractExecution{
		ParentHash:       common.HexToHash(execution.ParentHash),
		FeeRecipient:     common.HexToAddress(execution.FeeRecipient),
		StateRoot:        common.HexToHash(execution.StateRoot),
		ReceiptsRoot:     common.HexToHash(execution.ReceiptsRoot),
		LogsBloom:        common.Hex2Bytes(strings.TrimPrefix(execution.LogsBloom, "0x")),
		PrevRandao:       common.HexToHash(execution.PrevRandao),
		BlockNumber:      blockNumber,
		GasLimit:         gasLimit,
		GasUsed:          gasUsed,
		Timestamp:        timestamp,
		ExtraData:        common.Hex2Bytes(strings.TrimPrefix(execution.ExtraData, "0x")),
		BaseFeePerGas:    baseFeePerGas,
		BlockHash:        common.HexToHash(execution.BlockHash),
		TransactionsRoot: common.HexToHash(execution.TransactionsRoot),
		WithdrawalsRoot:  common.HexToHash(execution.WithdrawalsRoot),
	}, nil
}

'''
'''--- internal/klaytn/client.go ---
package klaytn

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"math/big"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/ethereum/go-ethereum/common"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

const (
	contentType = "application/json"
	vsn         = "2.0"
)

var ErrNoResult = errors.New("no result in JSON-RPC response")

type Client struct {
	client    *http.Client
	url       string
	closeOnce sync.Once
	closch    chan interface{}
	mu        sync.Mutex // protcts headers
	headers   http.Header
	isHttp    bool
	idCounter uint32
}

func DialHttp(endpoint string, isHttp bool) (*Client, error) {
	// Sanity chck URL so we don't end up with a client that will fail every request.
	_, err := url.Parse(endpoint)
	if err != nil {
		return nil, err
	}

	headers := make(http.Header, 2)
	headers.Set("accept", contentType)
	headers.Set("content-type", contentType)
	return &Client{
		client:    new(http.Client),
		url:       endpoint,
		closeOnce: sync.Once{},
		closch:    make(chan interface{}),
		mu:        sync.Mutex{},
		headers:   headers,
	}, nil
}

func (c *Client) BlockByNumber(ctx context.Context, number *big.Int) (*RpcHeader, error) {
	return c.getBlock(ctx, "klay_getBlockByNumber", toBlockNumArg(number), true)
}

func (c *Client) TransactionReceiptRpcOutput(ctx context.Context, txHash common.Hash) (map[string]interface{}, error) {
	return c.getReceipt(ctx, "klay_getTransactionReceipt", txHash)
}

func toBlockNumArg(number *big.Int) string {
	if number == nil {
		return "latest"
	}
	pending := big.NewInt(-1)
	if number.Cmp(pending) == 0 {
		return "pending"
	}
	return hexutil.EncodeBig(number)
}

func (c *Client) getBlock(ctx context.Context, method string, args ...interface{}) (*RpcHeader, error) {
	var raw json.RawMessage
	err := c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}

	data, err := raw.MarshalJSON()
	if err != nil {
		return nil, err
	}

	var ret RpcHeader
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return &ret, nil
}

func (c *Client) getReceipt(ctx context.Context, method string, args ...interface{}) (map[string]interface{}, error) {
	var raw json.RawMessage
	err := c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}

	data, err := raw.MarshalJSON()
	if err != nil {
		return nil, err
	}

	var ret map[string]interface{}
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

type jsonrpcMessage struct {
	Version string          `json:"jsonrpc,omitempty"`
	ID      json.RawMessage `json:"id,omitempty"`
	Method  string          `json:"method,omitempty"`
	Params  json.RawMessage `json:"params,omitempty"`
	Error   *jsonError      `json:"error,omitempty"`
	Result  json.RawMessage `json:"result,omitempty"`
}

type jsonError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (err *jsonError) Error() string {
	if err.Message == "" {
		return fmt.Sprintf("json-rpc error %d", err.Code)
	}
	return err.Message
}

type requestOp struct {
	ids  []json.RawMessage
	err  error
	resp chan *jsonrpcMessage // receives up to len(ids) responses
}

func (op *requestOp) wait(ctx context.Context) (*jsonrpcMessage, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case resp := <-op.resp:
		return resp, op.err
	}
}

func (c *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {
	if result != nil && reflect.TypeOf(result).Kind() != reflect.Ptr {
		return fmt.Errorf("call result parameter must be pointer or nil interface: %v", result)
	}
	msg, err := c.newMessage(method, args...)
	if err != nil {
		return err
	}
	op := &requestOp{ids: []json.RawMessage{msg.ID}, resp: make(chan *jsonrpcMessage, 1)}

	err = c.sendHTTP(ctx, op, msg)
	if err != nil {
		return err
	}

	// dispatch has accepted the request and will close the channel when it quits.
	switch resp, err := op.wait(ctx); {
	case err != nil:
		return err
	case resp.Error != nil:
		return resp.Error
	case len(resp.Result) == 0:
		return ErrNoResult
	default:
		return json.Unmarshal(resp.Result, &result)
	}
}

func (c *Client) nextID() json.RawMessage {
	id := atomic.AddUint32(&c.idCounter, 1)
	return strconv.AppendUint(nil, uint64(id), 10)
}

func (c *Client) newMessage(method string, paramsIn ...interface{}) (*jsonrpcMessage, error) {
	msg := &jsonrpcMessage{Version: vsn, ID: c.nextID(), Method: method}
	if paramsIn != nil { // prevent sending "params":null
		var err error
		if msg.Params, err = json.Marshal(paramsIn); err != nil {
			return nil, err
		}
	}
	return msg, nil
}

func (c *Client) sendHTTP(ctx context.Context, op *requestOp, msg interface{}) error {
	respBody, err := c.doRequest(ctx, msg)
	if err != nil {
		return err
	}
	defer respBody.Close()

	var respmsg jsonrpcMessage
	if err := json.NewDecoder(respBody).Decode(&respmsg); err != nil {
		return err
	}
	op.resp <- &respmsg
	return nil
}

func (c *Client) doRequest(ctx context.Context, msg interface{}) (io.ReadCloser, error) {
	body, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.url, ioutil.NopCloser(bytes.NewReader(body)))
	if err != nil {
		return nil, err
	}
	req.ContentLength = int64(len(body))

	// set headers
	c.mu.Lock()
	req.Header = c.headers.Clone()
	c.mu.Unlock()

	// do request
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		//var buf bytes.Buffer
		//var body []byte
		//if _, err := buf.ReadFrom(resp.Body); err == nil {
		//	body = buf.Bytes()
		//}

		//return nil, nil
		return nil, fmt.Errorf("klaytn request code is(%d)", resp.StatusCode)
		//HTTPError{
		//	Status:     resp.Status,
		//	StatusCode: resp.StatusCode,
		//	Body:       body,
		//}
	}
	return resp.Body, nil
}

'''
'''--- internal/klaytn/klaytn.go ---
package klaytn

import (
	"bytes"
	"context"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/pkg/util"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/pkg/errors"
)

type Header struct {
	ParentHash       []byte         `json:"parentHash"`
	Reward           common.Address `json:"reward"`
	StateRoot        []byte         `json:"stateRoot"`
	TransactionsRoot []byte         `json:"transactionsRoot"`
	ReceiptsRoot     []byte         `json:"receiptsRoot"`
	LogsBloom        []byte         `json:"logsBloom"`
	BlockScore       *big.Int       `json:"blockScore"`
	Number           *big.Int       `json:"number"`
	GasUsed          *big.Int       `json:"gasUsed"`
	Timestamp        *big.Int       `json:"timestamp"`
	TimestampFoS     *big.Int       `json:"timestampFoS"`
	ExtraData        []byte         `json:"extraData"`
	GovernanceData   []byte         `json:"governanceData"`
	VoteData         []byte         `json:"voteData"`
	BaseFee          *big.Int       `json:"baseFee"`
}

const (
	PrefixOfHex = "0x"
)

type RpcHeader struct {
	BaseFeePerGas    string         `json:"baseFeePerGas"`
	BlockScore       string         `json:"blockscore"`
	ExtraData        string         `json:"extraData"`
	GasUsed          string         `json:"gasUsed"`
	GovernanceData   string         `json:"governanceData"`
	Hash             common.Hash    `json:"hash"`
	LogsBloom        string         `json:"logsBloom"`
	Number           string         `json:"number"`
	ParentHash       common.Hash    `json:"parentHash"`
	ReceiptsRoot     common.Hash    `json:"receiptsRoot"`
	Reward           common.Address `json:"reward"`
	Size             string         `json:"size"`
	StateRoot        common.Hash    `json:"stateRoot"`
	Timestamp        string         `json:"timestamp"`
	TimestampFoS     string         `json:"timestampFoS"`
	TotalBlockScore  string         `json:"totalBlockScore"`
	TransactionsRoot common.Hash    `json:"transactionsRoot"`
	Transactions     []Transactions `json:"transactions"`
	VoteData         string         `json:"voteData"`
}

type Transactions struct {
	AccessList           []interface{} `json:"accessList,omitempty"`
	BlockHash            string        `json:"blockHash"`
	BlockNumber          string        `json:"blockNumber"`
	ChainID              string        `json:"chainId,omitempty"`
	From                 string        `json:"from"`
	Gas                  string        `json:"gas"`
	GasPrice             string        `json:"gasPrice"`
	Hash                 string        `json:"hash"`
	Input                string        `json:"input"`
	MaxFeePerGas         string        `json:"maxFeePerGas,omitempty"`
	MaxPriorityFeePerGas string        `json:"maxPriorityFeePerGas,omitempty"`
	Nonce                string        `json:"nonce"`
	R                    string        `json:"r"`
	S                    string        `json:"s"`
	To                   string        `json:"to"`
	TransactionIndex     string        `json:"transactionIndex"`
	Type                 string        `json:"type"`
	V                    string        `json:"v"`
	Value                string        `json:"value"`
}

type GovernanceVote struct {
	Validator common.Address `json:"validator"`
	Key       string         `json:"key"`
	Value     interface{}    `json:"value"`
}

func ConvertContractHeader(ethHeader *types.Header, rh *RpcHeader) Header {
	bloom := make([]byte, 0, len(ethHeader.Bloom))
	for _, b := range ethHeader.Bloom {
		bloom = append(bloom, b)
	}
	blockScore := new(big.Int)
	blockScore.SetString(strings.TrimPrefix(rh.BlockScore, PrefixOfHex), 16)
	baseFeePerGas := new(big.Int)
	baseFeePerGas.SetString(strings.TrimPrefix(rh.BaseFeePerGas, PrefixOfHex), 16)
	timestamp := new(big.Int)
	timestamp.SetString(strings.TrimPrefix(rh.Timestamp, PrefixOfHex), 16)
	timestampFos := new(big.Int)
	timestampFos.SetString(strings.TrimPrefix(rh.TimestampFoS, PrefixOfHex), 16)
	return Header{
		ParentHash:       hashToByte(ethHeader.ParentHash),
		Reward:           rh.Reward,
		StateRoot:        hashToByte(ethHeader.Root),
		TransactionsRoot: hashToByte(ethHeader.TxHash),
		ReceiptsRoot:     hashToByte(ethHeader.ReceiptHash),
		LogsBloom:        bloom,
		BlockScore:       blockScore,
		BaseFee:          baseFeePerGas,
		Number:           ethHeader.Number,
		GasUsed:          new(big.Int).SetUint64(ethHeader.GasUsed),
		Timestamp:        timestamp,
		TimestampFoS:     timestampFos,
		ExtraData:        common.Hex2Bytes(strings.TrimPrefix(rh.ExtraData, PrefixOfHex)),
		GovernanceData:   common.Hex2Bytes(strings.TrimPrefix(rh.GovernanceData, PrefixOfHex)),
		VoteData:         common.Hex2Bytes(strings.TrimPrefix(rh.VoteData, PrefixOfHex)),
	}
}

func hashToByte(h common.Hash) []byte {
	ret := make([]byte, 0, len(h))
	for _, b := range h {
		ret = append(ret, b)
	}
	return ret
}

func GetTxsHashByBlockNumber(conn *Client, number *big.Int) ([]common.Hash, error) {
	block, err := conn.BlockByNumber(context.Background(), number)
	if err != nil {
		return nil, err
	}

	txs := make([]common.Hash, 0, len(block.Transactions))
	for _, tx := range block.Transactions {
		txs = append(txs, common.HexToHash(tx.Hash))
	}
	return txs, nil
}

type ReceiptProofOriginal struct {
	Header    Header
	Proof     [][]byte
	TxReceipt []byte
	KeyIndex  []byte
}

type ReceiptProof struct {
	Proof     []byte
	DeriveSha DeriveShaOriginal
}

type DeriveShaOriginal uint8

const (
	DeriveShaOrigin DeriveShaOriginal = iota
	DeriveShaSimple
	DeriveShaConcat
)

type ReceiptRLP struct {
	Status  uint
	GasUsed uint64
	Bloom   types.Bloom
	Logs    []*types.Log
}

// ReceiptRlps implements DerivableList for receipts.
type ReceiptRlps []*ReceiptRLP

// Len returns the number of receipts in this list.
func (rs ReceiptRlps) Len() int { return len(rs) }

// EncodeIndex encodes the i'th receipt to w.
func (rs ReceiptRlps) EncodeIndex(i int, w *bytes.Buffer) {
	rlp.Encode(w, rs[i])
}

type TxLog struct {
	Addr   common.Address
	Topics [][]byte
	Data   []byte
}

func AssembleProof(cli *Client, header Header, log *types.Log, fId msg.ChainId, receipts []*types.Receipt, method string, proofType int64) ([]byte, error) {
	GetReceiptsByTxsHash(cli, receipts)
	receiptRlps := make(ReceiptRlps, 0, len(receipts))
	for _, receipt := range receipts {
		logs := make([]TxLog, 0, len(receipt.Logs))
		for _, lg := range receipt.Logs {
			topics := make([][]byte, len(lg.Topics))
			for i := range lg.Topics {
				topics[i] = lg.Topics[i][:]
			}
			logs = append(logs, TxLog{
				Addr:   lg.Address,
				Topics: topics,
				Data:   lg.Data,
			})
		}
		receiptRlps = append(receiptRlps, &ReceiptRLP{
			Status:  uint(receipt.Status),
			GasUsed: receipt.GasUsed,
			Bloom:   receipt.Bloom,
			Logs:    receipt.Logs,
		})
	}
	prf, err := proof.Get(receiptRlps, log.TxIndex)
	if err != nil {
		return nil, err
	}
	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(log.TxIndex))
	ek := util.Key2Hex(key, len(prf))
	receipt, err := GetTxReceipt(receipts[log.TxIndex])
	if err != nil {
		return nil, err
	}

	data, err := rlp.EncodeToBytes(receipt)
	if err != nil {
		return nil, err
	}

	pd := ReceiptProofOriginal{
		Header:    header,
		Proof:     prf,
		TxReceipt: data,
		KeyIndex:  ek,
	}

	input, err := mapprotocol.Klaytn.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(pd)
	if err != nil {
		return nil, errors.Wrap(err, "getBytes pack")
	}
	finpd := ReceiptProof{
		Proof:     input,
		DeriveSha: DeriveShaOrigin,
	}
	input, err = mapprotocol.Klaytn.Methods[mapprotocol.MethodOfGetFinalBytes].Inputs.Pack(finpd)
	if err != nil {
		return nil, errors.Wrap(err, "getFinalBytes pack")
	}

	pack, err := mapprotocol.PackInput(mapprotocol.Mcs, method, new(big.Int).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, err
	}

	return pack, nil
}

func GetReceiptsByTxsHash(cli *Client, receipts []*types.Receipt) {
	for idx, receipt := range receipts {
		if receipt.Status != 0 {
			continue
		}
		kr, err := cli.TransactionReceiptRpcOutput(context.Background(), receipt.TxHash)
		if err != nil {
			return
		}
		txError, _ := big.NewInt(0).SetString(strings.TrimPrefix(kr["txError"].(string), "0x"), 16)
		receipts[idx].Status = txError.Uint64()
	}
}

type TxReceipt struct {
	PostStateOrStatus []byte
	CumulativeGasUsed *big.Int
	Bloom             []byte
	Logs              []mapprotocol.TxLog
}

func GetTxReceipt(receipt *types.Receipt) (*TxReceipt, error) {
	logs := make([]mapprotocol.TxLog, 0, len(receipt.Logs))
	for _, lg := range receipt.Logs {
		topics := make([][]byte, len(lg.Topics))
		for i := range lg.Topics {
			topics[i] = lg.Topics[i][:]
		}
		logs = append(logs, mapprotocol.TxLog{
			Addr:   lg.Address,
			Topics: topics,
			Data:   lg.Data,
		})
	}

	return &TxReceipt{
		PostStateOrStatus: mapprotocol.StatusEncoding(receipt),
		CumulativeGasUsed: new(big.Int).SetUint64(receipt.GasUsed),
		Bloom:             receipt.Bloom[:],
		Logs:              logs,
	}, nil
}

'''
'''--- internal/mapo/callcontract.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package mapo

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/json"
	"github.com/mapprotocol/compass/internal/arb"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/op"
	"github.com/mapprotocol/compass/internal/scroll"
	"github.com/mapprotocol/compass/pkg/util"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	maptypes "github.com/mapprotocol/atlas/core/types"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/pkg/errors"
)

func AssembleEthProof(conn *ethclient.Client, log *types.Log, receipts []*types.Receipt, method string, fId msg.ChainId, proofType int64) ([]byte, error) {
	var (
		pack []byte
		err  error
	)
	switch proofType {
	case constant.ProofTypeOfOrigin:
	case constant.ProofTypeOfZk:
	case constant.ProofTypeOfOracle:
		receipt, err := mapprotocol.GetTxReceipt(receipts[log.TxIndex])
		if err != nil {
			return nil, err
		}

		prf, err := ethProof(conn, fId, log.TxIndex, receipts)
		if err != nil {
			return nil, err
		}

		var key []byte
		key = rlp.AppendUint64(key[:0], uint64(log.TxIndex))
		pack, err = proof.Oracle(log.BlockNumber, receipt, key, prf, fId, method, mapprotocol.ProofAbi)
	}

	if err != nil {
		return nil, err
	}

	return pack, nil
}

func ethProof(conn *ethclient.Client, fId msg.ChainId, txIdx uint, receipts []*types.Receipt) ([][]byte, error) {
	var dls proof.DerivableList
	switch fId {
	case constant.ArbChainId, constant.ArbTestnetChainId, constant.MantleChainId:
		pr := arb.Receipts{}
		for _, r := range receipts {
			pr = append(pr, &arb.Receipt{Receipt: r})
		}
		dls = pr
	case constant.ScrollChainId:
		pr := scroll.Receipts{}
		for _, r := range receipts {
			pr = append(pr, &scroll.Receipt{Receipt: r})
		}
		dls = pr
	case constant.OpChainId, constant.BaseChainId, constant.BlastChainId:
		pr := op.Receipts{}
		for _, r := range receipts {
			tmp, err := conn.OpReceipt(context.Background(), r.TxHash)
			if err != nil {
				continue
			}
			vptr := uint64(0)
			nptr := uint64(0)
			if tmp.DepositReceiptVersion != "" {
				version, _ := big.NewInt(0).SetString(strings.TrimPrefix(tmp.DepositReceiptVersion, "0x"), 16)
				vptr = version.Uint64()
			}
			if tmp.DepositNonce != "" {
				nonce, _ := big.NewInt(0).SetString(strings.TrimPrefix(tmp.DepositNonce, "0x"), 16)
				nptr = nonce.Uint64()
			}
			pr = append(pr, &op.Receipt{Receipt: r, DepositReceiptVersion: &vptr, DepositNonce: &nptr})
		}
		dls = pr
	default:
		dls = types.Receipts(receipts)
	}
	ret, err := proof.Get(dls, txIdx)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

func AssembleMapProof(cli *ethclient.Client, log *types.Log, receipts []*types.Receipt,
	header *maptypes.Header, fId msg.ChainId, method, zkUrl string, proofType int64) (uint64, []byte, error) {
	toChainID := log.Topics[2]
	uToChainID := binary.BigEndian.Uint64(toChainID[len(toChainID)-8:])
	txIndex := log.TxIndex
	aggPK, ist, aggPKBytes, err := mapprotocol.GetAggPK(cli, new(big.Int).Sub(header.Number, big.NewInt(1)), header.Extra)
	if err != nil {
		return 0, nil, err
	}

	receipt, err := mapprotocol.GetTxReceipt(receipts[txIndex])
	prf, err := proof.Get(types.Receipts(receipts), txIndex)
	if err != nil {
		return 0, nil, err
	}

	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))
	ek := util.Key2Hex(key, len(prf))
	if name, ok := mapprotocol.OnlineChaId[msg.ChainId(uToChainID)]; ok && strings.ToLower(name) != "near" {
		istanbulExtra := mapprotocol.ConvertIstanbulExtra(ist)
		nr := mapprotocol.MapTxReceipt{
			PostStateOrStatus: receipt.PostStateOrStatus,
			CumulativeGasUsed: receipt.CumulativeGasUsed,
			Bloom:             receipt.Bloom,
			Logs:              receipt.Logs,
		}

		nrRlp, err := rlp.EncodeToBytes(nr)
		if err != nil {
			return 0, nil, err
		}
		rp := mapprotocol.NewMapReceiptProof{
			Header:   mapprotocol.ConvertHeader(header),
			AggPk:    aggPK,
			KeyIndex: ek,
			Proof:    prf,
			Ist:      *istanbulExtra,
			TxReceiptRlp: mapprotocol.TxReceiptRlp{
				ReceiptType: receipt.ReceiptType,
				ReceiptRlp:  nrRlp,
			},
		}

		var payloads []byte
		switch proofType {
		case constant.ProofTypeOfOrigin:
			payloads, err = proof.Pack(fId, method, mapprotocol.Map2Other, rp)
		case constant.ProofTypeOfZk:
			zkProof, err := mapprotocol.GetZkProof(zkUrl, fId, header.Number.Uint64())
			if err != nil {
				return 0, nil, errors.Wrap(err, "GetZkProof failed")
			}
			payloads, err = proof.Pack(fId, method, mapprotocol.Mcs, rp, zkProof)
		case constant.ProofTypeOfOracle:
			if uToChainID == constant.EthChainId {
				pd := proof.Data{
					BlockNum: header.Number,
					ReceiptProof: proof.ReceiptProof{
						TxReceipt: *receipt,
						KeyIndex:  util.Key2Hex(key, len(prf)),
						Proof:     prf,
					},
				}

				payloads, err = proof.Pack(fId, method, mapprotocol.OracleAbi, pd)
			} else {
				payloads, err = proof.Oracle(header.Number.Uint64(), receipt, key, prf, fId, method, mapprotocol.ProofAbi)
			}
		}

		if err != nil {
			return 0, nil, err
		}
		return uToChainID, payloads, nil
	}

	bytesBuffer := bytes.NewBuffer([]byte{})
	err = binary.Write(bytesBuffer, binary.LittleEndian, uint64(txIndex))
	if err != nil {
		return 0, nil, err
	}

	nProof := make([]string, 0, len(prf))
	for _, p := range prf {
		nProof = append(nProof, "0x"+common.Bytes2Hex(p))
	}
	m := map[string]interface{}{
		"header": mapprotocol.ConvertNearNeedHeader(header),
		"agg_pk": map[string]interface{}{
			"xr": "0x" + common.Bytes2Hex(aggPKBytes[32:64]),
			"xi": "0x" + common.Bytes2Hex(aggPKBytes[:32]),
			"yi": "0x" + common.Bytes2Hex(aggPKBytes[64:96]),
			"yr": "0x" + common.Bytes2Hex(aggPKBytes[96:128]),
		},
		"key_index": "0x" + common.Bytes2Hex(key),
		"receipt":   ConvertNearReceipt(receipt),
		"proof":     nProof,
	}

	idx := 0
	match := false
	for lIdx, l := range receipt.Logs {
		for _, topic := range l.Topics {
			if common.BytesToHash(topic) == log.Topics[0] {
				idx = lIdx
				match = true
				break
			}
		}
		if match {
			break
		}
	}
	data, _ := json.Marshal(map[string]interface{}{
		"receipt_proof": m,
		"index":         idx,
	})
	return uToChainID, data, nil
}

func Key2Hex(str []byte, proofLength int) []byte {
	ret := make([]byte, 0)
	if len(ret)+1 == proofLength {
		ret = append(ret, str...)
	} else {
		for _, b := range str {
			ret = append(ret, b/16)
			ret = append(ret, b%16)
		}
	}
	return ret
}

type TxReceipt struct {
	ReceiptType       string  `json:"receipt_type"`
	PostStateOrStatus string  `json:"post_state_or_status"`
	CumulativeGasUsed string  `json:"cumulative_gas_used"`
	Bloom             string  `json:"bloom"`
	Logs              []TxLog `json:"logs"`
}

type TxLog struct {
	Address common.Address `json:"address"`
	Topics  []string       `json:"topics"`
	Data    string         `json:"data"`
}

func ConvertNearReceipt(h *mapprotocol.TxReceipt) *TxReceipt {
	logs := make([]TxLog, 0, len(h.Logs))
	for _, log := range h.Logs {
		topics := make([]string, 0, len(log.Topics))
		for _, t := range log.Topics {
			topics = append(topics, "0x"+common.Bytes2Hex(t))
		}
		logs = append(logs, TxLog{
			Address: log.Addr,
			Topics:  topics,
			Data:    "0x" + common.Bytes2Hex(log.Data),
		})
	}
	return &TxReceipt{
		ReceiptType:       h.ReceiptType.String(),
		PostStateOrStatus: "0x" + common.Bytes2Hex(h.PostStateOrStatus),
		CumulativeGasUsed: h.CumulativeGasUsed.String(),
		Bloom:             "0x" + common.Bytes2Hex(h.Bloom),
		Logs:              logs,
	}
}

'''
'''--- internal/matic/matic.go ---
package matic

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/mapo"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
	"math/big"
)

type BlockHeader struct {
	ParentHash       []byte         `json:"parentHash"`
	Sha3Uncles       []byte         `json:"sha3Uncles"`
	Miner            common.Address `json:"miner"`
	StateRoot        []byte         `json:"stateRoot"`
	TransactionsRoot []byte         `json:"transactionsRoot"`
	ReceiptsRoot     []byte         `json:"receiptsRoot"`
	LogsBloom        []byte         `json:"logsBloom"`
	Difficulty       *big.Int       `json:"difficulty"`
	Number           *big.Int       `json:"number"`
	GasLimit         *big.Int       `json:"gasLimit"`
	GasUsed          *big.Int       `json:"gasUsed"`
	Timestamp        *big.Int       `json:"timestamp"`
	ExtraData        []byte         `json:"extraData"`
	MixHash          []byte         `json:"mixHash"`
	Nonce            []byte         `json:"nonce"`
	BaseFeePerGas    *big.Int       `json:"baseFeePerGas"`
}

func ConvertHeader(header *types.Header) BlockHeader {
	bloom := make([]byte, 0, len(header.Bloom))
	for _, b := range header.Bloom {
		bloom = append(bloom, b)
	}
	nonce := make([]byte, 0, len(header.Nonce))
	for _, b := range header.Nonce {
		nonce = append(nonce, b)
	}
	return BlockHeader{
		ParentHash:       hashToByte(header.ParentHash),
		Sha3Uncles:       hashToByte(header.UncleHash),
		Miner:            constant.ZeroAddress,
		StateRoot:        hashToByte(header.Root),
		TransactionsRoot: hashToByte(header.TxHash),
		ReceiptsRoot:     hashToByte(header.ReceiptHash),
		LogsBloom:        bloom,
		Difficulty:       header.Difficulty,
		Number:           header.Number,
		GasLimit:         new(big.Int).SetUint64(header.GasLimit),
		GasUsed:          new(big.Int).SetUint64(header.GasUsed),
		Timestamp:        new(big.Int).SetUint64(header.Time),
		ExtraData:        header.Extra,
		MixHash:          hashToByte(header.MixDigest),
		Nonce:            nonce,
		BaseFeePerGas:    header.BaseFee,
	}
}

func hashToByte(h common.Hash) []byte {
	ret := make([]byte, 0, len(h))
	for _, b := range h {
		ret = append(ret, b)
	}
	return ret
}

type ProofData struct {
	Headers      []BlockHeader
	ReceiptProof ReceiptProof
}

type ReceiptProof struct {
	TxReceipt mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

func AssembleProof(headers []BlockHeader, log *types.Log, fId msg.ChainId, receipts []*types.Receipt, method string, proofType int64) ([]byte, error) {
	txIndex := log.TxIndex
	receipt, err := mapprotocol.GetTxReceipt(receipts[txIndex])
	if err != nil {
		return nil, err
	}

	prf, err := proof.Get(types.Receipts(receipts), txIndex)
	if err != nil {
		return nil, err
	}

	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))
	ek := mapo.Key2Hex(key, len(prf))

	var pack []byte
	switch proofType {
	case constant.ProofTypeOfOrigin:
		pd := ProofData{
			Headers: headers,
			ReceiptProof: ReceiptProof{
				TxReceipt: *receipt,
				KeyIndex:  ek,
				Proof:     prf,
			},
		}

		pack, err = proof.Pack(fId, method, mapprotocol.Matic, pd)
	case constant.ProofTypeOfZk:
	case constant.ProofTypeOfOracle:
		pd := proof.Data{
			BlockNum: big.NewInt(int64(log.BlockNumber)),
			ReceiptProof: proof.ReceiptProof{
				TxReceipt: *receipt,
				KeyIndex:  util.Key2Hex(key, len(prf)),
				Proof:     prf,
			},
		}

		pack, err = proof.Pack(fId, method, mapprotocol.OracleAbi, pd)
	}

	if err != nil {
		return nil, err
	}

	return pack, nil
}

'''
'''--- internal/near/borsh.go ---
package near

import (
	"bytes"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/mr-tron/base58"

	"github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/types/key"
	"github.com/mapprotocol/near-api-go/pkg/types/signature"
)

const (
	Version2         = "V2"
	ValidatorStakeV1 = 0
	ValidatorStakeV2 = 1
)

const (
	ProofDirectionRight = "Right"
	ProofDirectionLeft  = "Left"
)

func Borshify(block client.LightClientBlockView) []byte {
	var (
		buf                bytes.Buffer
		innerLite          bytes.Buffer
		nextBps            bytes.Buffer
		littleEndian       bytes.Buffer
		approvalsAfterNext bytes.Buffer
	)

	buf.Write(MustBase58Decode(block.PrevBlockHash.String()))
	buf.Write(MustBase58Decode(block.NextBlockInnerHash.String()))

	MustToLittleEndian(&littleEndian, block.InnerLite.Height)
	innerLite.Write(littleEndian.Bytes())

	innerLite.Write(MustBase58Decode(block.InnerLite.EpochID.String()))
	innerLite.Write(MustBase58Decode(block.InnerLite.NextEpochId.String()))
	innerLite.Write(MustBase58Decode(block.InnerLite.PrevStateRoot.String()))
	innerLite.Write(MustBase58Decode(block.InnerLite.OutcomeRoot.String()))

	littleEndian.Reset()
	MustToLittleEndian(&littleEndian, block.InnerLite.Timestamp)
	innerLite.Write(littleEndian.Bytes())

	innerLite.Write(MustBase58Decode(block.InnerLite.NextBpHash.String()))
	innerLite.Write(MustBase58Decode(block.InnerLite.BlockMerkleRoot.String()))
	buf.Write(innerLite.Bytes())

	buf.Write(MustBase58Decode(block.InnerRestHash.String()))
	buf.Write([]byte{1})

	littleEndian.Reset()
	MustToLittleEndian(&littleEndian, int64(len(block.NextBps)))
	buf.Write(littleEndian.Next(4))

	for _, bp := range block.NextBps {
		var nextBp bytes.Buffer
		if bp.ValidatorStakeStructVersion == Version2 {
			nextBp.Write([]byte{ValidatorStakeV2})
		} else {
			nextBp.Write([]byte{ValidatorStakeV1})
		}

		littleEndian.Reset()
		MustToLittleEndian(&littleEndian, int64(len(bp.AccountID)))
		nextBp.Write(littleEndian.Next(4))

		nextBp.Write([]byte(bp.AccountID))
		if bp.PublicKey.Type == key.KeyTypeED25519 {
			nextBp.Write([]byte{0})
		} else {
			nextBp.Write([]byte{1})
		}
		nextBp.Write(MustBase58Decode(bp.PublicKey.Value))

		stake, ok := new(big.Int).SetString(bp.Stake.String(), 10)
		if !ok {
			panic(fmt.Sprintf("stake convert to big.Int failed, stake: %s", bp.Stake.String()))
		}
		nextBp.Write(reverse16(stake.Bytes()))
		nextBps.Write(nextBp.Bytes())
	}
	buf.Write(nextBps.Bytes())

	littleEndian.Reset()
	MustToLittleEndian(&littleEndian, int64(len(block.ApprovalsAfterNext)))
	buf.Write(littleEndian.Next(4))
	for _, sign := range block.ApprovalsAfterNext {
		var aan bytes.Buffer
		if sign == nil {
			aan.Write([]byte{0})
		} else {
			aan.Write([]byte{1})
			if sign.Type == signature.SignatureTypeED25519 {
				aan.Write([]byte{0})
			} else {
				aan.Write([]byte{1})
			}
			aan.Write(MustBase58Decode(sign.Value))
		}
		approvalsAfterNext.Write(aan.Bytes())
	}
	buf.Write(approvalsAfterNext.Bytes())

	return buf.Bytes()
}

func BorshifyOutcomeProof(proof client.RpcLightClientExecutionProofResponse) ([]byte, error) {
	var (
		buf           bytes.Buffer
		tmp           bytes.Buffer
		outcomeProof  bytes.Buffer
		outcomeProof2 bytes.Buffer
	)

	// Step1：outComeProof.proof length
	MustToLittleEndian(&tmp, int64(len(proof.OutcomeProof.Proof)))
	outcomeProof.Write(tmp.Next(4))
	tmp.Reset()
	// Step2：outComeProof.proof
	for _, p := range proof.OutcomeProof.Proof {
		tmp.Write(MustBase58Decode(p.Hash.String()))
		if p.Direction == ProofDirectionRight {
			tmp.Write([]byte{1})
		} else {
			tmp.Write([]byte{0})
		}
		outcomeProof.Write(tmp.Bytes())
		tmp.Reset()
	}
	buf.Write(outcomeProof.Bytes())
	buf.Write(MustBase58Decode(proof.OutcomeProof.BlockHash.String()))
	buf.Write(MustBase58Decode(proof.OutcomeProof.ID.String()))
	// step3: outComeProof.outCome.logs
	// 3.1 length
	MustToLittleEndian(&tmp, int64(len(proof.OutcomeProof.Outcome.Logs)))
	outcomeProof2.Write(tmp.Next(4))
	tmp.Reset()
	// 3.2 logs
	logBuf := bytes.Buffer{}
	for _, l := range proof.OutcomeProof.Outcome.Logs {
		var lb bytes.Buffer
		MustToLittleEndian(&tmp, int64(len(l)))
		lb.Write(tmp.Next(4))
		tmp.Reset()
		lb.Write([]byte(l))
		logBuf.Write(lb.Bytes())
	}
	outcomeProof2.Write(logBuf.Bytes())
	// step4: outComeProof.outCome.receiptIDs
	MustToLittleEndian(&tmp, int64(len(proof.OutcomeProof.Outcome.ReceiptIDs)))
	outcomeProof2.Write(tmp.Next(4))
	tmp.Reset()
	// step:4.1
	receiptIDs := bytes.Buffer{}
	for _, rId := range proof.OutcomeProof.Outcome.ReceiptIDs {
		var rIdBuf bytes.Buffer
		rIdBuf.Write(MustBase58Decode(rId.String()))
		receiptIDs.Write(rIdBuf.Bytes())
	}
	outcomeProof2.Write(receiptIDs.Bytes())
	// step:4.2
	MustToLittleEndian(&tmp, proof.OutcomeProof.Outcome.GasBurnt)
	outcomeProof2.Write(tmp.Next(8))
	// step:4.3
	MustToLittleEndian(&tmp, proof.OutcomeProof.Outcome.TokensBurnt)
	outcomeProof2.Write(tmp.Next(16))
	tmp.Reset()
	// step:4.4
	MustToLittleEndian(&tmp, int64(len(proof.OutcomeProof.Outcome.ExecutorID)))
	outcomeProof2.Write(tmp.Next(4))
	tmp.Reset()
	// step:4.5
	outcomeProof2.Write([]byte(proof.OutcomeProof.Outcome.ExecutorID))
	// step:4.6
	statusByte, err := resolveStatus(&proof.OutcomeProof.Outcome.Status)
	if err != nil {
		return nil, err
	}
	outcomeProof2.Write(statusByte)
	// step5 outcomeRootProof
	MustToLittleEndian(&tmp, int64(len(proof.OutcomeRootProof)))
	outcomeProof2.Write(tmp.Next(4))
	tmp.Reset()
	// step5.1 outcome_root_proof
	rootProof := bytes.Buffer{}
	for _, p := range proof.OutcomeRootProof {
		var pt bytes.Buffer
		pt.Write(MustBase58Decode(p.Hash.String()))
		if p.Direction == ProofDirectionRight {
			pt.Write([]byte{1})
		} else {
			pt.Write([]byte{0})
		}
		rootProof.Write(pt.Bytes())
	}
	outcomeProof2.Write(rootProof.Bytes())
	// step6 block_header_lite
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.PrevBlockHash.String()))
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerRestHash.String()))
	MustToLittleEndian(&tmp, proof.BlockHeaderLite.InnerLite.Height)
	outcomeProof2.Write(tmp.Next(8))
	tmp.Reset()
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.EpochID.String()))
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.NextEpochId.String()))
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.PrevStateRoot.String()))
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.OutcomeRoot.String()))
	MustToLittleEndian(&tmp, proof.BlockHeaderLite.InnerLite.Timestamp)
	outcomeProof2.Write(tmp.Next(8))
	tmp.Reset()
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.NextBpHash.String()))
	outcomeProof2.Write(MustBase58Decode(proof.BlockHeaderLite.InnerLite.BlockMerkleRoot.String()))
	// step7 blockProof
	MustToLittleEndian(&tmp, int64(len(proof.BlockProof)))
	outcomeProof2.Write(tmp.Next(4))
	tmp.Reset()
	var bpBuf bytes.Buffer
	for _, bp := range proof.BlockProof {
		var bpb bytes.Buffer
		bpb.Write(MustBase58Decode(bp.Hash.String()))
		if bp.Direction == ProofDirectionRight {
			bpb.Write([]byte{1})
		} else {
			bpb.Write([]byte{0})
		}
		bpBuf.Write(bpb.Bytes())
	}
	outcomeProof2.Write(bpBuf.Bytes())
	buf.Write(outcomeProof2.Bytes())
	return buf.Bytes(), nil
}

func resolveStatus(status *client.TransactionStatus) ([]byte, error) {
	data, err := json.Marshal(status)
	if err != nil {
		return nil, err
	}
	m := make(map[string]interface{})
	err = json.Unmarshal(data, &m)
	if err != nil {
		return nil, err
	}

	var ret bytes.Buffer
	if v, ok := m["SuccessValue"]; ok {
		// step1
		ret.Write([]byte{2})
		// step2
		res, err := base64.StdEncoding.DecodeString(v.(string))
		if err != nil {
			return nil, err
		}
		var tmp bytes.Buffer
		MustToLittleEndian(&tmp, int64(len(res)))
		ret.Write(tmp.Next(4))
		// step3
		ret.Write(res)
	} else if v, ok := m["SuccessReceiptId"]; ok {
		ret.Write([]byte{3})
		ret.Write(MustBase58Decode(v.(string)))
	} else {
		return nil, errors.New("transaction status not supported")
	}

	return ret.Bytes(), nil
}

func reverse16(bs []byte) []byte {
	length := len(bs)
	wbs := make([]byte, length)
	copy(wbs, bs)

	for i := 0; i < len(wbs)/2; i++ {
		wbs[i], wbs[len(wbs)-i-1] = wbs[len(wbs)-i-1], wbs[i]
	}

	fillSize := 16 - length
	if fillSize > 0 {
		for i := 0; i < fillSize; i++ {
			wbs = append(wbs, 0)
		}
	}
	return wbs
}

func MustBase58Decode(str string) []byte {
	dec, err := base58.Decode(str)
	if err != nil {
		panic(err)
	}
	return dec
}

func MustToLittleEndian(w io.Writer, data interface{}) {
	if err := binary.Write(w, binary.LittleEndian, data); err != nil {
		panic(err)
	}
}

'''
'''--- internal/near/protocol.go ---
package near

import (
	"github.com/mapprotocol/near-api-go/pkg/types"
)

var (
	NewFunctionCallGas types.Gas = 30 * 10000000000000
	Deposit                      = "0.3"
)

type Result struct {
	BlockHash   string        `json:"block_hash"`
	BlockHeight int           `json:"block_height"`
	Logs        []interface{} `json:"logs"`
	Result      []byte        `json:"result"`
}

type TransferOut struct {
	FromChain string `json:"from_chain"`
	ToChain   string `json:"to_chain"`
	OrderId   string `json:"order_id"`
}

'''
'''--- internal/op/op.go ---
package op

import (
	"bytes"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
)

const (
	LegacyTxType     = 0x00
	AccessListTxType = 0x01
	DynamicFeeTxType = 0x02
	BlobTxType       = 0x03
)

const DepositTxType = 0x7E

type Receipt struct {
	*types.Receipt
	DepositNonce          *uint64 `json:"depositNonce,omitempty"`
	DepositReceiptVersion *uint64 `json:"depositReceiptVersion,omitempty"`
}

func (r *Receipt) statusEncoding() []byte {
	if len(r.PostState) == 0 {
		if r.Status == constant.ReceiptStatusFailed {
			return constant.ReceiptStatusFailedRLP
		}
		return constant.ReceiptStatusSuccessfulRLP
	}
	return r.PostState
}

type depositReceiptRLP struct {
	PostStateOrStatus     []byte
	CumulativeGasUsed     uint64
	Bloom                 types.Bloom
	Logs                  []*types.Log
	DepositNonce          *uint64 `rlp:"optional"`
	DepositReceiptVersion *uint64 `rlp:"optional"`
}

type Receipts []*Receipt

func (rs Receipts) Len() int { return len(rs) }

func (rs Receipts) EncodeIndex(i int, w *bytes.Buffer) {
	r := rs[i]
	data := &proof.ReceiptRLP{PostStateOrStatus: r.statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, Bloom: r.Bloom, Logs: r.Logs}
	if r.Type == constant.LegacyTxType {
		rlp.Encode(w, data)
		return
	}
	w.WriteByte(r.Type)
	switch r.Type {
	case AccessListTxType, DynamicFeeTxType, BlobTxType:
		rlp.Encode(w, data)
	case DepositTxType:
		if r.DepositReceiptVersion != nil {
			// post-canyon receipt hash computation update
			depositData := &depositReceiptRLP{data.PostStateOrStatus, data.CumulativeGasUsed, r.Bloom, r.Logs, r.DepositNonce, r.DepositReceiptVersion}
			rlp.Encode(w, depositData)
		} else {
			rlp.Encode(w, data)
		}
	default:
	}
}

'''
'''--- internal/platon/connection.go ---
package platon

import (
	"context"
	"errors"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"math/big"
	"sync"
	"time"

	"github.com/mapprotocol/compass/core"

	"github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethcrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type Connection struct {
	endpoint      string
	http          bool
	kp            *keystore.Key
	gasLimit      *big.Int
	maxGasPrice   *big.Int
	gasMultiplier *big.Float
	conn          *ethclient.Client
	opts          *bind.TransactOpts
	callOpts      *bind.CallOpts
	nonce         uint64
	optsLock      sync.Mutex
	log           log15.Logger
	stop          chan int // All routines should exit when this channel is closed
}

// NewConn returns an uninitialized connection, must call Connection.Connect() before using.
func NewConn(endpoint string, http bool, kp *keystore.Key, log log15.Logger, gasLimit, gasPrice *big.Int,
	gasMultiplier float64) core.Connection {
	bigFloat := new(big.Float).SetFloat64(gasMultiplier)
	conn := Connection{
		endpoint:      endpoint,
		http:          http,
		kp:            kp,
		gasLimit:      gasLimit,
		maxGasPrice:   gasPrice,
		gasMultiplier: bigFloat,
		log:           log,
		stop:          make(chan int),
	}
	return &conn
}

// Connect starts the ethereum WS connection
func (c *Connection) Connect() error {
	c.log.Info("Connecting to ethereum chain...", "url", c.endpoint)
	var rpcClient *rpc.Client
	var err error
	// Start http or ws client
	if c.http {
		rpcClient, err = rpc.DialHTTP(c.endpoint)
	} else {
		rpcClient, err = rpc.DialContext(context.Background(), c.endpoint)
	}
	if err != nil {
		return err
	}
	c.conn = ethclient.NewClient(rpcClient, c.endpoint)

	// Construct tx opts, call opts, and nonce mechanism
	opts, _, err := c.newTransactOpts(big.NewInt(0), c.gasLimit, c.maxGasPrice)
	if err != nil {
		return err
	}
	c.opts = opts
	c.nonce = 0
	c.callOpts = &bind.CallOpts{From: c.kp.Address}
	return nil
}

// newTransactOpts builds the TransactOpts for the connection's keypair.
func (c *Connection) newTransactOpts(value, gasLimit, gasPrice *big.Int) (*bind.TransactOpts, uint64, error) {
	privateKey := c.kp.PrivateKey
	address := ethcrypto.PubkeyToAddress(privateKey.PublicKey)

	nonce, err := c.conn.PendingNonceAt(context.Background(), address)
	if err != nil {
		return nil, 0, err
	}

	id, err := c.conn.ChainID(context.Background())
	if err != nil {
		return nil, 0, err
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, id)
	if err != nil {
		return nil, 0, err
	}

	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = value
	auth.GasLimit = uint64(gasLimit.Int64())
	auth.GasPrice = gasPrice
	auth.Context = context.Background()

	return auth, nonce, nil
}

func (c *Connection) Keypair() *keystore.Key {
	return c.kp
}

func (c *Connection) Client() *ethclient.Client {
	return c.conn
}

func (c *Connection) Opts() *bind.TransactOpts {
	return c.opts
}

func (c *Connection) CallOpts() *bind.CallOpts {
	return c.callOpts
}

func (c *Connection) SafeEstimateGas(ctx context.Context) (*big.Int, error) {
	var suggestedGasPrice *big.Int
	c.log.Debug("Fetching gasPrice from node")
	nodePriceEstimate, err := c.conn.SuggestGasPrice(ctx)
	if err != nil {
		return nil, err
	} else {
		suggestedGasPrice = nodePriceEstimate
	}

	gasPrice := multiplyGasPrice(suggestedGasPrice, c.gasMultiplier)

	// Check we aren't exceeding our limit
	if gasPrice.Cmp(c.maxGasPrice) == 1 {
		return c.maxGasPrice, nil
	} else {
		return gasPrice, nil
	}
}

func (c *Connection) EstimateGasLondon(ctx context.Context, baseFee *big.Int) (*big.Int, *big.Int, error) {
	var maxPriorityFeePerGas *big.Int
	var maxFeePerGas *big.Int

	if c.maxGasPrice.Cmp(baseFee) < 0 {
		maxPriorityFeePerGas = big.NewInt(1000000000)
		maxFeePerGas = new(big.Int).Add(c.maxGasPrice, maxPriorityFeePerGas)
		return maxPriorityFeePerGas, maxFeePerGas, nil
	}

	maxPriorityFeePerGas, err := c.conn.SuggestGasTipCap(ctx)
	if err != nil {
		return nil, nil, err
	}
	c.log.Info("EstimateGasLondon", "maxPriorityFeePerGas", maxPriorityFeePerGas)

	maxFeePerGas = new(big.Int).Add(
		maxPriorityFeePerGas,
		baseFee,
	)

	// Check we aren't exceeding our limit
	if maxFeePerGas.Cmp(c.maxGasPrice) == 1 {
		c.log.Info("EstimateGasLondon maxFeePerGas more than set", "maxFeePerGas", maxFeePerGas, "baseFee", baseFee)
		maxPriorityFeePerGas.Sub(c.maxGasPrice, baseFee)
		maxFeePerGas = c.maxGasPrice
	}
	return maxPriorityFeePerGas, maxFeePerGas, nil
}

func multiplyGasPrice(gasEstimate *big.Int, gasMultiplier *big.Float) *big.Int {
	gasEstimateFloat := new(big.Float).SetInt(gasEstimate)
	result := gasEstimateFloat.Mul(gasEstimateFloat, gasMultiplier)
	gasPrice := new(big.Int)
	result.Int(gasPrice)
	return gasPrice
}

// LockAndUpdateOpts acquires a lock on the opts before updating the nonce
// and gas price.
func (c *Connection) LockAndUpdateOpts(needNewNonce bool) error {
	//c.optsLock.Lock()
	//head, err := c.conn.PlatonGetBlockByNumber(context.TODO(), nil)
	//// cos map chain dont have this section in return,this err will be raised
	//if err != nil && err.Error() != "missing required field 'sha3Uncles' for Header" {
	//	c.UnlockOpts()
	//	c.log.Error("LockAndUpdateOpts HeaderByNumber", "err", err)
	//	return err
	//}

	//if head.BaseFee != nil {
	//	c.opts.GasTipCap, c.opts.GasFeeCap, err = c.EstimateGasLondon(context.TODO(), head.BaseFee)
	//
	//	// Both gasPrice and (maxFeePerGas or maxPriorityFeePerGas) cannot be specified: https://github.com/ethereum/go-ethereum/blob/95bbd46eabc5d95d9fb2108ec232dd62df2f44ab/accounts/abi/bind/base.go#L254
	//	c.opts.GasPrice = nil
	//	if err != nil {
	//		// if EstimateGasLondon failed, fall back to suggestGasPrice
	//		c.opts.GasPrice, err = c.conn.SuggestGasPrice(context.TODO())
	//		if err != nil {
	//			c.UnlockOpts()
	//			return err
	//		}
	//	}
	//	c.log.Info("LockAndUpdateOpts ", "head.BaseFee", head.BaseFee, "maxGasPrice", c.maxGasPrice)
	//} else {
	var gasPrice *big.Int
	gasPrice, err := c.SafeEstimateGas(context.TODO())
	if err != nil {
		//c.UnlockOpts()
		return err
	}
	c.opts.GasPrice = gasPrice
	//}

	if !needNewNonce {
		return nil
	}
	nonce, err := c.conn.PendingNonceAt(context.Background(), c.opts.From)
	if err != nil {
		//c.optsLock.Unlock()
		return err
	}
	c.opts.Nonce.SetUint64(nonce)
	return nil
}

func (c *Connection) UnlockOpts() {
	//c.optsLock.Unlock()
}

// LatestBlock returns the latest block from the current chain
func (c *Connection) LatestBlock() (*big.Int, error) {
	bnum, err := c.conn.BlockNumber(context.Background())
	if err != nil {
		return nil, err
	}
	return big.NewInt(0).SetUint64(bnum), nil
}

// EnsureHasBytecode asserts if contract code exists at the specified address
func (c *Connection) EnsureHasBytecode(addr ethcommon.Address) error {
	//code, err := c.conn.CodeAt(context.Background(), addr, nil)
	//if err != nil {
	//	return err
	//}

	//if len(code) == 0 {
	//	return fmt.Errorf("no bytecode found at %s", addr.Hex())
	//}
	return nil
}

// WaitForBlock will poll for the block number until the current block is equal or greater.
// If delay is provided it will wait until currBlock - delay = targetBlock
func (c *Connection) WaitForBlock(targetBlock *big.Int, delay *big.Int) error {
	for {
		select {
		case <-c.stop:
			return errors.New("connection terminated")
		default:
			currBlock, err := c.LatestBlock()
			if err != nil {
				return err
			}

			if delay != nil {
				currBlock.Sub(currBlock, delay)
			}

			// Equal or greater than target
			if currBlock.Cmp(targetBlock) >= 0 {
				return nil
			}
			c.log.Trace("Block not ready, waiting", "target", targetBlock, "current", currBlock, "delay", delay)
			time.Sleep(constant.BlockRetryInterval)
			continue
		}
	}
}

// Close terminates the client connection and stops any running routines
func (c *Connection) Close() {
	if c.conn != nil {
		c.conn.Close()
	}
	close(c.stop)
}

'''
'''--- internal/platon/platon.go ---
package platon

import (
	"context"
	"github.com/mapprotocol/compass/internal/mapo"
	"math/big"

	"github.com/mapprotocol/compass/pkg/platon"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/proof"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type BlockHeader struct {
	ParentHash       []byte
	Miner            common.Address
	StateRoot        []byte
	TransactionsRoot []byte
	ReceiptsRoot     []byte
	LogsBloom        []byte
	Number           *big.Int
	GasLimit         *big.Int
	GasUsed          *big.Int
	Timestamp        *big.Int
	ExtraData        []byte
	Nonce            []byte
}

type UpdateBlock struct {
	Header     *BlockHeader
	Validators []ethclient.Validator
	Cert       *QuorumCert
}

func ConvertHeader(header *platon.Header) *BlockHeader {
	bloom := make([]byte, 0, len(header.Bloom))
	for _, b := range header.Bloom {
		bloom = append(bloom, b)
	}
	nonce := make([]byte, 0, len(header.Nonce))
	for _, b := range header.Nonce {
		nonce = append(nonce, b)
	}

	return &BlockHeader{
		ParentHash:       header.ParentHash.Bytes(),
		Miner:            common.HexToAddress(header.Coinbase.String()),
		StateRoot:        header.Root.Bytes(),
		TransactionsRoot: header.TxHash.Bytes(),
		ReceiptsRoot:     header.ReceiptHash.Bytes(),
		LogsBloom:        bloom,
		Number:           header.Number,
		GasLimit:         new(big.Int).SetUint64(header.GasLimit),
		GasUsed:          new(big.Int).SetUint64(header.GasUsed),
		Timestamp:        new(big.Int).SetUint64(header.Time),
		ExtraData:        header.Extra,
		Nonce:            nonce,
	}
}

type ProofData struct {
	ReceiptProof *ReceiptProof
	Header       *BlockHeader
	QuorumCert   *QuorumCert
}

type QuorumCert struct {
	BlockHash           [32]byte `json:"blockHash"`
	BlockIndex          *big.Int `json:"blockIndex"`
	BlockNumber         *big.Int `json:"blockNumber"`
	Epoch               *big.Int `json:"epoch"`
	ViewNumber          *big.Int `json:"viewNumber"`
	Signature           []byte   `json:"signature"`
	ValidatorSignBitMap *big.Int
	SignedCount         *big.Int
	// ValidatorSet        []byte   `json:"validatorSet"`
}

type Validator struct {
	Address   common.Address
	NodeId    []byte
	BlsPubKey []byte
}

type ReceiptProof struct {
	TxReceipt *mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

func AssembleProof(block *UpdateBlock, log *types.Log, receipts []*types.Receipt, method string, fId msg.ChainId, proofType int64) ([]byte, error) {
	txIndex := log.TxIndex
	receipt, err := mapprotocol.GetTxReceipt(receipts[txIndex])
	if err != nil {
		return nil, err
	}

	pr, err := proof.Get(types.Receipts(receipts), txIndex)
	if err != nil {
		return nil, err
	}

	var key []byte
	key = rlp.AppendUint64(key[:0], uint64(txIndex))
	ek := mapo.Key2Hex(key, len(pr))

	rp := &ReceiptProof{
		TxReceipt: receipt,
		KeyIndex:  ek,
		Proof:     pr,
	}

	input, err := mapprotocol.Platon.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(ProofData{
		ReceiptProof: rp,
		Header:       block.Header,
		QuorumCert:   block.Cert,
	})
	if err != nil {
		return nil, err
	}

	pack, err := mapprotocol.PackInput(mapprotocol.Mcs, method, new(big.Int).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, err
	}
	return pack, nil
}

func GetHeaderParam(client *ethclient.Client, latestBlock *big.Int) (*UpdateBlock, error) {
	header, err := client.PlatonGetBlockByNumber(context.Background(), latestBlock)
	if err != nil {
		return nil, err
	}
	pHeader := ConvertHeader(header)
	validator, err := client.PlatonGetValidatorByNumber(context.Background(), new(big.Int).Add(pHeader.Number, big.NewInt(1)))
	if err != nil {
		return nil, err
	}
	quorumCert, err := client.PlatonGetBlockQuorumCertByHash(context.Background(), []common.Hash{common.HexToHash(header.Hash().String())})
	if err != nil {
		return nil, err
	}

	cert := &QuorumCert{
		BlockHash:           [32]byte{},
		BlockIndex:          big.NewInt(0),
		BlockNumber:         big.NewInt(0),
		Epoch:               big.NewInt(0),
		ViewNumber:          big.NewInt(0),
		Signature:           make([]byte, 0),
		ValidatorSignBitMap: big.NewInt(0),
		SignedCount:         big.NewInt(0),
	}
	if len(quorumCert) > 0 {
		vsb, sc := handlerValidatorSet(quorumCert[0].ValidatorSet)
		cert = &QuorumCert{
			BlockHash:           common.HexToHash(quorumCert[0].BlockHash),
			BlockIndex:          big.NewInt(quorumCert[0].BlockIndex),
			BlockNumber:         big.NewInt(quorumCert[0].BlockNumber),
			Epoch:               big.NewInt(quorumCert[0].Epoch),
			ViewNumber:          big.NewInt(quorumCert[0].ViewNumber),
			Signature:           common.Hex2Bytes(quorumCert[0].Signature),
			ValidatorSignBitMap: big.NewInt(vsb),
			SignedCount:         big.NewInt(sc),
		}
	}

	return &UpdateBlock{
		Header:     pHeader,
		Validators: validator,
		Cert:       cert,
	}, nil
}

func handlerValidatorSet(set string) (int64, int64) {
	var validatorSignBitMap, signedCount int64
	for idx, x := range set {
		if x != 'x' {
			continue
		}
		signedCount++
		validatorSignBitMap += int64(1 << (len(set) - idx - 1))
	}
	return validatorSignBitMap, signedCount
}

'''
'''--- internal/platon/platon_test.go ---
package platon

import "testing"

func Test_handlerValidatorSet(t *testing.T) {
	got, got1 := handlerValidatorSet("_xxxx")
	t.Log("got ------", got)
	t.Log("got1 ------", got1)
}

'''
'''--- internal/proof/proof.go ---
package proof

import (
	"bytes"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/util"
	"github.com/pkg/errors"
	"math/big"
	"sync"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethdb/memorydb"
	"github.com/ethereum/go-ethereum/light"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/trie"
)

var (
	CacheReceipt = make(map[string][]*types.Receipt) // key -> chainId_blockHeight
)

type ReceiptRLP struct {
	PostStateOrStatus []byte
	CumulativeGasUsed uint64
	Bloom             types.Bloom
	Logs              []*types.Log
}

type Data struct {
	BlockNum     *big.Int
	ReceiptProof ReceiptProof
}

type ReceiptProof struct {
	TxReceipt mapprotocol.TxReceipt
	KeyIndex  []byte
	Proof     [][]byte
}

type NewData struct {
	BlockNum     *big.Int
	ReceiptProof NewReceiptProof
}

type NewReceiptProof struct {
	TxReceipt   []byte
	ReceiptType *big.Int
	KeyIndex    []byte
	Proof       [][]byte
}

var encodeBufferPool = sync.Pool{
	New: func() interface{} { return new(bytes.Buffer) },
}

func Get(receipts DerivableList, txIndex uint) ([][]byte, error) {
	tr, err := trie.New(common.Hash{}, trie.NewDatabase(memorydb.New()))
	if err != nil {
		return nil, err
	}

	tr = DeriveTire(receipts, tr)
	ns := light.NewNodeSet()
	key, err := rlp.EncodeToBytes(txIndex)
	if err != nil {
		return nil, err
	}
	if err = tr.Prove(key, 0, ns); err != nil {
		return nil, err
	}

	proof := make([][]byte, 0, len(ns.NodeList()))
	for _, v := range ns.NodeList() {
		proof = append(proof, v)
	}

	return proof, nil
}

func DeriveTire(rs DerivableList, tr *trie.Trie) *trie.Trie {
	valueBuf := encodeBufferPool.Get().(*bytes.Buffer)
	defer encodeBufferPool.Put(valueBuf)

	var indexBuf []byte
	for i := 1; i < rs.Len() && i <= 0x7f; i++ {
		indexBuf = rlp.AppendUint64(indexBuf[:0], uint64(i))
		value := encodeForDerive(rs, i, valueBuf)
		tr.Update(indexBuf, value)
	}
	if rs.Len() > 0 {
		indexBuf = rlp.AppendUint64(indexBuf[:0], 0)
		value := encodeForDerive(rs, 0, valueBuf)
		tr.Update(indexBuf, value)
	}
	for i := 0x80; i < rs.Len(); i++ {
		indexBuf = rlp.AppendUint64(indexBuf[:0], uint64(i))
		value := encodeForDerive(rs, i, valueBuf)
		tr.Update(indexBuf, value)
	}
	return tr
}

type DerivableList interface {
	Len() int
	EncodeIndex(int, *bytes.Buffer)
}

func encodeForDerive(list DerivableList, i int, buf *bytes.Buffer) []byte {
	buf.Reset()
	list.EncodeIndex(i, buf)
	return common.CopyBytes(buf.Bytes())
}

func Pack(fId msg.ChainId, method string, abi abi.ABI, params ...interface{}) ([]byte, error) {
	input, err := abi.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(params...)
	if err != nil {
		return nil, errors.Wrap(err, "pack getBytes failed")
	}

	ret, err := mapprotocol.PackInput(mapprotocol.Mcs, method, big.NewInt(0).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, errors.Wrap(err, "pack mcs input failed")
	}

	return ret, nil
}

func Oracle(blockNumber uint64, receipt *mapprotocol.TxReceipt, key []byte, prf [][]byte, fId msg.ChainId, method string,
	abi abi.ABI) ([]byte, error) {
	nr := mapprotocol.MapTxReceipt{
		PostStateOrStatus: receipt.PostStateOrStatus,
		CumulativeGasUsed: receipt.CumulativeGasUsed,
		Bloom:             receipt.Bloom,
		Logs:              receipt.Logs,
	}
	nrRlp, err := rlp.EncodeToBytes(nr)
	if err != nil {
		return nil, err
	}

	pd := NewData{
		BlockNum: big.NewInt(int64(blockNumber)),
		ReceiptProof: NewReceiptProof{
			TxReceipt:   nrRlp,
			ReceiptType: receipt.ReceiptType,
			KeyIndex:    util.Key2Hex(key, len(prf)),
			Proof:       prf,
		},
	}

	input, err := abi.Methods[mapprotocol.MethodOfGetBytes].Inputs.Pack(pd)
	if err != nil {
		return nil, errors.Wrap(err, "pack getBytes failed")
	}

	ret, err := mapprotocol.PackInput(mapprotocol.Mcs, method, big.NewInt(0).SetUint64(uint64(fId)), input)
	if err != nil {
		return nil, errors.Wrap(err, "pack mcs input failed")
	}

	return ret, nil
}

'''
'''--- internal/scroll/receipt.go ---
package scroll

import (
	"bytes"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/internal/proof"
)

type Receipts []*Receipt

type Receipt struct {
	*types.Receipt
}

func (r *Receipt) statusEncoding() []byte {
	if len(r.PostState) == 0 {
		if r.Status == constant.ReceiptStatusFailed {
			return constant.ReceiptStatusFailedRLP
		}
		return constant.ReceiptStatusSuccessfulRLP
	}
	return r.PostState
}

// Len returns the number of receipts in this list.
func (rs Receipts) Len() int { return len(rs) }

// EncodeIndex encodes the i'th receipt to w.
func (rs Receipts) EncodeIndex(i int, w *bytes.Buffer) {
	r := rs[i]
	data := &proof.ReceiptRLP{PostStateOrStatus: r.statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, Bloom: r.Bloom, Logs: r.Logs}
	switch r.Type {
	case constant.LegacyTxType:
		rlp.Encode(w, data)
	default:
		w.WriteByte(r.Type)
		rlp.Encode(w, data)
	}
}

'''
'''--- internal/tx/eth_client.go ---
package tx

import (
	"context"
	"errors"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"math/big"
	"time"
)

func GetTxsHashByBlockNumber(conn *ethclient.Client, number *big.Int) ([]common.Hash, error) {
	block, err := conn.BlockByNumber(context.Background(), number)
	if err != nil {
		return nil, err
	}

	txs := make([]common.Hash, 0, len(block.Transactions()))
	for _, tx := range block.Transactions() {
		txs = append(txs, tx.Hash())
	}
	return txs, nil
}

func GetReceiptsByTxsHash(conn *ethclient.Client, txsHash []common.Hash) ([]*types.Receipt, error) {
	type ele struct {
		r   *types.Receipt
		idx int
	}
	var (
		count      = len(txsHash)
		errReceive = make(chan error)
		receive    = make(chan *ele, len(txsHash))
		rs         = make([]*types.Receipt, len(txsHash))
	)
	go func() {
		for idx, h := range txsHash {
			tmpIdx := idx
			tmpHash := h
			go func(i int, tx common.Hash) {
				for {
					r, err := conn.TransactionReceipt(context.Background(), tx)
					if err != nil {
						if err.Error() == "not found" {
							time.Sleep(time.Millisecond * 100)
							continue
						}
						errReceive <- err
						return
					}
					receive <- &ele{
						r:   r,
						idx: i,
					}
					break
				}
			}(tmpIdx, tmpHash)

			if idx%30 == 0 {
				time.Sleep(time.Millisecond * 500)
			}
		}
	}()

	for {
		select {
		case v, ok := <-receive:
			if !ok {
				return nil, errors.New("receive chan is closed")
			}
			if v != nil {
				rs[v.idx] = v.r
			}
			count--
			if count == 0 {
				return rs, nil
			}
		case err := <-errReceive:
			return nil, err
		}
	}
}

func GetMaticReceiptsByTxsHash(conn *ethclient.Client, txsHash []common.Hash) ([]*types.Receipt, error) {
	type ele struct {
		r   *types.Receipt
		idx int
	}
	var (
		count      = len(txsHash)
		errReceive = make(chan error)
		receive    = make(chan *ele, len(txsHash))
		rs         = make([]*types.Receipt, len(txsHash))
	)
	go func() {
		for idx, h := range txsHash {
			tmpIdx := idx
			tmpHash := h
			go func(i int, tx common.Hash) {
				for {
					r, err := conn.TransactionReceipt(context.Background(), tx)
					if err != nil {
						if err.Error() == "not found" {
							receive <- &ele{
								r:   nil,
								idx: i,
							}
							break
						}
						errReceive <- err
						return
					}
					receive <- &ele{
						r:   r,
						idx: i,
					}
					break
				}
			}(tmpIdx, tmpHash)

			if idx%30 == 0 {
				time.Sleep(time.Millisecond * 500)
			}
		}
	}()

	for {
		select {
		case v, ok := <-receive:
			if !ok {
				return nil, errors.New("receive chan is closed")
			}
			if v != nil {
				rs[v.idx] = v.r
			}
			count--
			if count == 0 {
				return rs, nil
			}
		case err := <-errReceive:
			return nil, err
		}
	}
}

'''
'''--- keystore/encrypt.go ---
package keystore

import (
	"fmt"
	"syscall"

	terminal "golang.org/x/term"
)

// GetPassword prompt user to enter password for encrypted keystore
func GetPassword(msg string) []byte {
	for {
		fmt.Println(msg)
		fmt.Print("> ")
		password, err := terminal.ReadPassword(int(syscall.Stdin))
		if err != nil {
			fmt.Printf("invalid input: %s\n", err)
		} else {
			fmt.Printf("\n")
			return password
		}
	}
}

'''
'''--- keystore/keystore.go ---
package keystore

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/mapprotocol/near-api-go/pkg/types"
	"github.com/mapprotocol/near-api-go/pkg/types/key"
)

const (
	EnvPassword = "KEYSTORE_PASSWORD"
)

var pswCache = make(map[string][]byte)

func KeypairFromEth(path string) (*keystore.Key, error) {
	// Make sure key exists before prompting password
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil, fmt.Errorf("key file not found: %s", path)
	}

	var pswd = pswCache[path]
	if len(pswd) == 0 {
		pswd = GetPassword(fmt.Sprintf("Enter password for key %s:", path))
	}

	file, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read keyFile failed, err:%s", err)
	}
	ret, err := keystore.DecryptKey(file, string(pswd))
	if err != nil {
		return nil, fmt.Errorf("DecryptKey failed, err:%s", err)
	}
	pswCache[path] = pswd

	return ret, nil
}

func NearKeyPairFrom(networkName, path string, id types.AccountID) (kp key.KeyPair, err error) {
	var creds struct {
		AccountID  types.AccountID     `json:"account_id"`
		PublicKey  key.Base58PublicKey `json:"public_key"`
		PrivateKey key.KeyPair         `json:"private_key"`
	}

	home := path
	if home == "" {
		home, err = os.UserHomeDir()
		if err != nil {
			return
		}
	}

	credsFile := filepath.Join(home, ".near-credentials", networkName, fmt.Sprintf("%s.json", id))

	var cf *os.File
	if cf, err = os.Open(credsFile); err != nil {
		return
	}
	defer cf.Close()

	if err = json.NewDecoder(cf).Decode(&creds); err != nil {
		return
	}

	if creds.PublicKey.String() != creds.PrivateKey.PublicKey.String() {
		err = fmt.Errorf("inconsistent public key, %s != %s", creds.PublicKey.String(), creds.PrivateKey.PublicKey.String())
		return
	}
	kp = creds.PrivateKey

	return
}

'''
'''--- mapprotocol/abi_json.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package mapprotocol

const (
	NearAbiJson                  = `[{"inputs":[{"internalType":"bytes","name":"head","type":"bytes"},{"internalType":"bytes","name":"proof","type":"bytes"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"stateMutability":"view","type":"function"}]`
	McsAbi                       = `[{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"orderList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"name":"executeIn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"name":"swapIn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_fromChain","type":"uint256"},{"internalType":"bytes","name":"receiptProof","type":"bytes"}],"name":"depositIn","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"receiptProof","type":"bytes"}],"name":"transferIn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"coinbase","type":"address"},{"internalType":"bytes","name":"root","type":"bytes"},{"internalType":"bytes","name":"txHash","type":"bytes"},{"internalType":"bytes","name":"receiptHash","type":"bytes"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"time","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixDigest","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct ILightNodePoint.blockHeader","name":"header","type":"tuple"},{"components":[{"internalType":"address[]","name":"validators","type":"address[]"},{"internalType":"bytes[]","name":"addedPubKey","type":"bytes[]"},{"internalType":"bytes[]","name":"addedG1PubKey","type":"bytes[]"},{"internalType":"uint256","name":"removeList","type":"uint256"},{"internalType":"bytes","name":"seal","type":"bytes"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"aggregatedSeal","type":"tuple"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"parentAggregatedSeal","type":"tuple"}],"internalType":"struct ILightNodePoint.istanbulExtra","name":"ist","type":"tuple"},{"components":[{"internalType":"uint256","name":"xr","type":"uint256"},{"internalType":"uint256","name":"xi","type":"uint256"},{"internalType":"uint256","name":"yr","type":"uint256"},{"internalType":"uint256","name":"yi","type":"uint256"}],"internalType":"struct IBLSPoint.G2","name":"aggPk","type":"tuple"},{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"receiptRlp","type":"bytes"}],"internalType":"struct ILightNodePoint.TxReceiptRlp","name":"txReceiptRlp","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct ILightNodePoint.receiptProof","name":"_receiptProof","type":"tuple"},{"internalType": "uint256[8]","name": "_zkProofs","type": "uint256[8]"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"name":"swapInVerify","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getStoredCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"logArray","type":"bytes"}],"name":"swapInVerified","outputs":[],"stateMutability":"nonpayable","type":"function"},{"anonymous": false,"inputs": [{"indexed": false,"internalType": "bytes","name": "logs","type": "bytes"}],"name": "mapSwapInVerified","type": "event"}]`
	LightMangerAbi               = `[{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"finalizedState","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"updateLightClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"clientState","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_blockHeader","type":"bytes"}],"name":"updateBlockHeader","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"headerHeight","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"name":"verifyProofData","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"string","name":"message","type":"string"},{"internalType":"bytes","name":"logs","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"verifiableHeaderRange","outputs":[{"internalType":"uint256","name":"left","type":"uint256"},{"internalType":"uint256","name":"right","type":"uint256"}],"stateMutability":"view","type":"function"}]`
	BscAbiJson                   = `[{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"}],"internalType":"struct Verify.BlockHeader[]","name":"_blockHeaders","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"}],"internalType":"struct Verify.BlockHeader[]","name":"headers","type":"tuple[]"},{"components":[{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Verify.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"struct Verify.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Verify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"struct LightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	KlaytnAbiJson                = `[{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"reward","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"blockScore","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"timestampFoS","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"governanceData","type":"bytes"},{"internalType":"bytes","name":"voteData","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct ILightNodePoint.BlockHeader[]","name":"_blockHeaders","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"proof","type":"bytes"},{"internalType":"enum ILightNodePoint.DeriveShaOriginal","name":"deriveSha","type":"uint8"}],"internalType":"struct ILightNodePoint.ReceiptProof","name":"_proof","type":"tuple"}],"name":"getFinalBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"reward","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"blockScore","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"timestampFoS","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"governanceData","type":"bytes"},{"internalType":"bytes","name":"voteData","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct IKlaytn.BlockHeader","name":"header","type":"tuple"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"},{"internalType":"bytes","name":"txReceipt","type":"bytes"},{"internalType":"bytes","name":"keyIndex","type":"bytes"}],"internalType":"struct IKlaytn.ReceiptProofOriginal","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	HeightAbiJson                = `[{"inputs":[],"name":"headerHeight","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]`
	VerifiableHeaderRangeAbiJson = `[{"inputs":[],"name":"verifiableHeaderRange","outputs":[{"internalType":"uint256","name":"left","type":"uint256"},{"internalType":"uint256","name":"right","type":"uint256"}],"stateMutability":"view","type":"function"}]`
	Map2OtherAbi                 = `[{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"coinbase","type":"address"},{"internalType":"bytes","name":"root","type":"bytes"},{"internalType":"bytes","name":"txHash","type":"bytes"},{"internalType":"bytes","name":"receiptHash","type":"bytes"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"time","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixDigest","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct ILightNodePoint.blockHeader","name":"bh","type":"tuple"},{"components":[{"internalType":"address[]","name":"validators","type":"address[]"},{"internalType":"bytes[]","name":"addedPubKey","type":"bytes[]"},{"internalType":"bytes[]","name":"addedG1PubKey","type":"bytes[]"},{"internalType":"uint256","name":"removeList","type":"uint256"},{"internalType":"bytes","name":"seal","type":"bytes"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"aggregatedSeal","type":"tuple"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"parentAggregatedSeal","type":"tuple"}],"internalType":"struct ILightNodePoint.istanbulExtra","name":"ist","type":"tuple"},{"components":[{"internalType":"uint256","name":"xr","type":"uint256"},{"internalType":"uint256","name":"xi","type":"uint256"},{"internalType":"uint256","name":"yr","type":"uint256"},{"internalType":"uint256","name":"yi","type":"uint256"}],"internalType":"struct IBLSPoint.G2","name":"aggPk","type":"tuple"}],"name":"updateBlockHeader","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"coinbase","type":"address"},{"internalType":"bytes","name":"root","type":"bytes"},{"internalType":"bytes","name":"txHash","type":"bytes"},{"internalType":"bytes","name":"receiptHash","type":"bytes"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"time","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixDigest","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct ILightNodePoint.blockHeader","name":"header","type":"tuple"},{"components":[{"internalType":"address[]","name":"validators","type":"address[]"},{"internalType":"bytes[]","name":"addedPubKey","type":"bytes[]"},{"internalType":"bytes[]","name":"addedG1PubKey","type":"bytes[]"},{"internalType":"uint256","name":"removeList","type":"uint256"},{"internalType":"bytes","name":"seal","type":"bytes"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"aggregatedSeal","type":"tuple"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"parentAggregatedSeal","type":"tuple"}],"internalType":"struct ILightNodePoint.istanbulExtra","name":"ist","type":"tuple"},{"components":[{"internalType":"uint256","name":"xr","type":"uint256"},{"internalType":"uint256","name":"xi","type":"uint256"},{"internalType":"uint256","name":"yr","type":"uint256"},{"internalType":"uint256","name":"yi","type":"uint256"}],"internalType":"struct IBLSPoint.G2","name":"aggPk","type":"tuple"},{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"receiptRlp","type":"bytes"}],"internalType":"struct ILightNodePoint.TxReceiptRlp","name":"txReceiptRlp","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct ILightNodePoint.receiptProof","name":"_receiptProof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	MaticAbiJson                 = `[{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"}],"internalType":"struct Verify.BlockHeader[]","name":"_blockHeaders","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"}],"internalType":"struct Verify.BlockHeader[]","name":"headers","type":"tuple[]"},{"components":[{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Verify.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"struct Verify.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Verify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"struct LightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	Eth2AbiJson                  = `[{"inputs":[],"name":"clientStateAnalysis","outputs":[{"internalType":"uint256","name":"startNumber","type":"uint256"},{"internalType":"uint256","name":"endNumber","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"uint64","name":"slot","type":"uint64"},{"internalType":"uint64","name":"proposerIndex","type":"uint64"},{"internalType":"bytes32","name":"parentRoot","type":"bytes32"},{"internalType":"bytes32","name":"stateRoot","type":"bytes32"},{"internalType":"bytes32","name":"bodyRoot","type":"bytes32"}],"internalType":"struct Types.BeaconBlockHeader","name":"attestedHeader","type":"tuple"},{"components":[{"internalType":"bytes","name":"pubkeys","type":"bytes"},{"internalType":"bytes","name":"aggregatePubkey","type":"bytes"}],"internalType":"struct Types.SyncCommittee","name":"nextSyncCommittee","type":"tuple"},{"internalType":"bytes32[]","name":"nextSyncCommitteeBranch","type":"bytes32[]"},{"components":[{"internalType":"uint64","name":"slot","type":"uint64"},{"internalType":"uint64","name":"proposerIndex","type":"uint64"},{"internalType":"bytes32","name":"parentRoot","type":"bytes32"},{"internalType":"bytes32","name":"stateRoot","type":"bytes32"},{"internalType":"bytes32","name":"bodyRoot","type":"bytes32"}],"internalType":"struct Types.BeaconBlockHeader","name":"finalizedHeader","type":"tuple"},{"internalType":"bytes32[]","name":"finalityBranch","type":"bytes32[]"},{"components":[{"internalType":"bytes32","name":"parentHash","type":"bytes32"},{"internalType":"address","name":"feeRecipient","type":"address"},{"internalType":"bytes32","name":"stateRoot","type":"bytes32"},{"internalType":"bytes32","name":"receiptsRoot","type":"bytes32"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"bytes32","name":"prevRandao","type":"bytes32"},{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"internalType":"bytes32","name":"transactionsRoot","type":"bytes32"},{"internalType":"bytes32","name":"withdrawalsRoot","type":"bytes32"}],"internalType":"struct Types.Execution","name":"finalizedExecution","type":"tuple"},{"internalType":"bytes32[]","name":"executionBranch","type":"bytes32[]"},{"components":[{"internalType":"bytes","name":"syncCommitteeBits","type":"bytes"},{"internalType":"bytes","name":"syncCommitteeSignature","type":"bytes"}],"internalType":"struct Types.SyncAggregate","name":"syncAggregate","type":"tuple"},{"internalType":"uint64","name":"signatureSlot","type":"uint64"}],"internalType":"struct Types.LightClientUpdate","name":"_update","type":"tuple"}],"name":"getUpdateBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32","name":"parentHash","type":"bytes32"},{"internalType":"bytes32","name":"sha3Uncles","type":"bytes32"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes32","name":"stateRoot","type":"bytes32"},{"internalType":"bytes32","name":"transactionsRoot","type":"bytes32"},{"internalType":"bytes32","name":"receiptsRoot","type":"bytes32"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes32","name":"mixHash","type":"bytes32"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"},{"internalType":"bytes32","name":"withdrawalsRoot","type":"bytes32"}],"internalType":"struct Types.BlockHeader[]","name":"_headers","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes32","name":"parentHash","type":"bytes32"},{"internalType":"bytes32","name":"sha3Uncles","type":"bytes32"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes32","name":"stateRoot","type":"bytes32"},{"internalType":"bytes32","name":"transactionsRoot","type":"bytes32"},{"internalType":"bytes32","name":"receiptsRoot","type":"bytes32"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes32","name":"mixHash","type":"bytes32"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFeePerGas","type":"uint256"},{"internalType":"bytes32","name":"withdrawalsRoot","type":"bytes32"}],"internalType":"struct Types.BlockHeader","name":"header","type":"tuple"},{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Types.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"struct Types.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Types.ReceiptProof","name":"receiptProof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	PlatonAbiJson                = `[{"inputs":[{"components":[{"components":[{"internalType":"uint256","name":"epoch","type":"uint256"},{"internalType":"uint256","name":"viewNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"uint256","name":"blockIndex","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"validatorSignBitMap","type":"uint256"},{"internalType":"uint256","name":"signedCount","type":"uint256"}],"internalType":"struct Verify.QuorumCert","name":"quorumCert","type":"tuple"},{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"}],"internalType":"struct Verify.BlockHeader","name":"header","type":"tuple"},{"components":[{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Verify.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"struct Verify.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Verify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"struct LightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"}],"internalType":"struct Verify.BlockHeader","name":"_blockHeader","type":"tuple"},{"components":[{"internalType":"uint256","name":"epoch","type":"uint256"},{"internalType":"uint256","name":"viewNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"uint256","name":"blockIndex","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"validatorSignBitMap","type":"uint256"},{"internalType":"uint256","name":"signedCount","type":"uint256"}],"internalType":"struct Verify.QuorumCert","name":"_quorumCert","type":"tuple"},{"components":[{"internalType":"address","name":"Address","type":"address"},{"internalType":"bytes","name":"NodeId","type":"bytes"},{"internalType":"bytes","name":"BlsPubKey","type":"bytes"}],"internalType":"struct Verify.Validator[]","name":"_validators","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	ConfluxAbiJson               = `[{"inputs":[{"internalType":"uint256","name":"height","type":"uint256"}],"name":"nearestPivot","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"headers","type":"bytes[]"}],"name":"getBlockHeaderBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"bytes[]","name":"headers","type":"bytes[]"},{"internalType":"bytes","name":"blockIndex","type":"bytes"},{"components":[{"components":[{"internalType":"bytes32","name":"nibbles","type":"bytes32"},{"internalType":"uint256","name":"start","type":"uint256"},{"internalType":"uint256","name":"end","type":"uint256"}],"internalType":"struct ProofLib.NibblePath","name":"path","type":"tuple"},{"internalType":"bytes32[16]","name":"children","type":"bytes32[16]"},{"internalType":"bytes","name":"value","type":"bytes"}],"internalType":"struct ProofLib.ProofNode[]","name":"blockProof","type":"tuple[]"},{"internalType":"bytes32","name":"receiptsRoot","type":"bytes32"},{"internalType":"bytes","name":"index","type":"bytes"},{"internalType":"bytes","name":"receipt","type":"bytes"},{"components":[{"components":[{"internalType":"bytes32","name":"nibbles","type":"bytes32"},{"internalType":"uint256","name":"start","type":"uint256"},{"internalType":"uint256","name":"end","type":"uint256"}],"internalType":"struct ProofLib.NibblePath","name":"path","type":"tuple"},{"internalType":"bytes32[16]","name":"children","type":"bytes32[16]"},{"internalType":"bytes","name":"value","type":"bytes"}],"internalType":"struct ProofLib.ProofNode[]","name":"receiptProof","type":"tuple[]"}],"internalType":"struct Types.ReceiptProof","name":"proof","type":"tuple"}],"name":"verifyReceiptProof","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint64","name":"epoch","type":"uint64"},{"internalType":"uint64","name":"round","type":"uint64"},{"internalType":"bytes32","name":"id","type":"bytes32"},{"internalType":"bytes32","name":"executedStateId","type":"bytes32"},{"internalType":"uint64","name":"version","type":"uint64"},{"internalType":"uint64","name":"timestampUsecs","type":"uint64"},{"components":[{"internalType":"uint64","name":"epoch","type":"uint64"},{"components":[{"internalType":"bytes32","name":"account","type":"bytes32"},{"internalType":"bytes","name":"uncompressedPublicKey","type":"bytes"},{"internalType":"bytes","name":"vrfPublicKey","type":"bytes"},{"internalType":"uint64","name":"votingPower","type":"uint64"}],"internalType":"struct LedgerInfoLib.ValidatorInfo[]","name":"validators","type":"tuple[]"},{"internalType":"uint64","name":"quorumVotingPower","type":"uint64"},{"internalType":"uint64","name":"totalVotingPower","type":"uint64"},{"internalType":"bytes","name":"vrfSeed","type":"bytes"}],"internalType":"struct LedgerInfoLib.EpochState","name":"nextEpochState","type":"tuple"},{"components":[{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"internalType":"uint64","name":"height","type":"uint64"}],"internalType":"struct LedgerInfoLib.Decision","name":"pivot","type":"tuple"},{"internalType":"bytes32","name":"consensusDataHash","type":"bytes32"},{"internalType":"bytes32[]","name":"accounts","type":"bytes32[]"},{"internalType":"bytes","name":"aggregatedSignature","type":"bytes"}],"internalType":"struct LedgerInfoLib.LedgerInfoWithSignatures","name":"ledgerInfo","type":"tuple"}],"name":"relayPOS","outputs":[],"stateMutability":"nonpayable","type":"function"}]`
	otherAbi                     = `[{"inputs":[],"name":"state","outputs":[{"components":[{"internalType":"uint256","name":"epoch","type":"uint256"},{"internalType":"uint256","name":"round","type":"uint256"},{"internalType":"uint256","name":"earliestBlockNumber","type":"uint256"},{"internalType":"uint256","name":"finalizedBlockNumber","type":"uint256"},{"internalType":"uint256","name":"blocks","type":"uint256"},{"internalType":"uint256","name":"maxBlocks","type":"uint256"}],"internalType":"struct ILightNode.GetStatus","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"finalizedState","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"curValiditors","type":"bytes"},{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"address","name":"coinbase","type":"address"},{"internalType":"bytes","name":"root","type":"bytes"},{"internalType":"bytes","name":"txHash","type":"bytes"},{"internalType":"bytes","name":"receiptHash","type":"bytes"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"time","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixDigest","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"},{"internalType":"uint256","name":"baseFee","type":"uint256"}],"internalType":"struct ILightNodePoint.blockHeader","name":"bh","type":"tuple"},{"components":[{"internalType":"address[]","name":"validators","type":"address[]"},{"internalType":"bytes[]","name":"addedPubKey","type":"bytes[]"},{"internalType":"bytes[]","name":"addedG1PubKey","type":"bytes[]"},{"internalType":"uint256","name":"removeList","type":"uint256"},{"internalType":"bytes","name":"seal","type":"bytes"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"aggregatedSeal","type":"tuple"},{"components":[{"internalType":"uint256","name":"bitmap","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint256","name":"round","type":"uint256"}],"internalType":"struct ILightNodePoint.istanbulAggregatedSeal","name":"parentAggregatedSeal","type":"tuple"}],"internalType":"struct ILightNodePoint.istanbulExtra","name":"ist","type":"tuple"},{"internalType":"uint256[8]","name":"zkProofs","type":"uint256[8]"}],"name":"updateBlockHeader","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"_receiptProofBytes","type":"bytes"}],"name":"verifyProofData","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"string","name":"message","type":"string"},{"internalType":"bytes","name":"logsHash","type":"bytes"}],"stateMutability":"view","type":"function"}]`
	bttcAbi                      = `[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"previousAdmin","type":"address"},{"indexed":false,"internalType":"address","name":"newAdmin","type":"address"}],"name":"AdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previous","type":"address"},{"indexed":true,"internalType":"address","name":"newAdmin","type":"address"}],"name":"AdminTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"beacon","type":"address"}],"name":"BeaconUpgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousPending","type":"address"},{"indexed":true,"internalType":"address","name":"newPending","type":"address"}],"name":"ChangePendingAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"maintainer","type":"address"},{"indexed":true,"internalType":"uint256","name":"blockHeight","type":"uint256"}],"name":"UpdateBlockHeader","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"EPOCH_NUM","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"chainId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"changeAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"clientState","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"confirms","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"","type":"bytes"}],"name":"finalizedState","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getAdmin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"}],"internalType":"struct Verify.BlockHeader[]","name":"headers","type":"tuple[]"},{"components":[{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Verify.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"struct Verify.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Verify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"struct LightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"}],"internalType":"struct Verify.BlockHeader[]","name":"_blockHeaders","type":"tuple[]"}],"name":"getHeadersBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"getImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"headerHeight","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"uint256","name":"_minEpochBlockExtraDataLen","type":"uint256"},{"internalType":"address","name":"_controller","type":"address"},{"internalType":"address","name":"_mptVerify","type":"address"},{"internalType":"uint256","name":"_confirms","type":"uint256"},{"components":[{"internalType":"bytes","name":"parentHash","type":"bytes"},{"internalType":"bytes","name":"sha3Uncles","type":"bytes"},{"internalType":"address","name":"miner","type":"address"},{"internalType":"bytes","name":"stateRoot","type":"bytes"},{"internalType":"bytes","name":"transactionsRoot","type":"bytes"},{"internalType":"bytes","name":"receiptsRoot","type":"bytes"},{"internalType":"bytes","name":"logsBloom","type":"bytes"},{"internalType":"uint256","name":"difficulty","type":"uint256"},{"internalType":"uint256","name":"number","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"bytes","name":"extraData","type":"bytes"},{"internalType":"bytes","name":"mixHash","type":"bytes"},{"internalType":"bytes","name":"nonce","type":"bytes"}],"internalType":"struct Verify.BlockHeader","name":"_header","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"maxCanVerifyNum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minEpochBlockExtraDataLen","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minValidBlocknum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"mptVerify","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingAdmin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"pendingAdmin_","type":"address"}],"name":"setPendingAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_flag","type":"bool"}],"name":"togglePause","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"_blockHeadersBytes","type":"bytes"}],"name":"updateBlockHeader","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"updateLightClient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"}],"name":"upgradeTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"validators","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"verifiableHeaderRange","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_receiptProof","type":"bytes"}],"name":"verifyProofData","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"string","name":"message","type":"string"},{"internalType":"bytes","name":"logs","type":"bytes"}],"stateMutability":"view","type":"function"}]`
	OracleAbiJson                = `[{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"bytes32","name":"_hash","type":"bytes32"}],"name":"updateBlockHeader","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"uint256","name":"_blockNum","type":"uint256"},{"internalType":"bytes32","name":"_orderId","type":"bytes32"}],"name":"getOrderStatus","outputs":[{"internalType":"bool","name":"exists","type":"bool"},{"internalType":"bool","name":"verifiable","type":"bool"},{"internalType":"uint256","name":"nodeType","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"blockNum","type":"uint256"},{"internalType":"bytes32","name":"receiptRoot","type":"bytes32"}],"name":"propose","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"blockNum","type":"uint256"},{"components":[{"components":[{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"postStateOrStatus","type":"bytes"},{"internalType":"uint256","name":"cumulativeGasUsed","type":"uint256"},{"internalType":"bytes","name":"bloom","type":"bytes"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"bytes[]","name":"topics","type":"bytes[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"structVerify.TxLog[]","name":"logs","type":"tuple[]"}],"internalType":"structVerify.TxReceipt","name":"txReceipt","type":"tuple"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"structVerify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"structLightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
	ProofAbiJson                 = `[{"inputs":[{"components":[{"internalType":"uint256","name":"blockNum","type":"uint256"},{"components":[{"internalType":"bytes","name":"txReceipt","type":"bytes"},{"internalType":"uint256","name":"receiptType","type":"uint256"},{"internalType":"bytes","name":"keyIndex","type":"bytes"},{"internalType":"bytes[]","name":"proof","type":"bytes[]"}],"internalType":"struct Verify.ReceiptProof","name":"receiptProof","type":"tuple"}],"internalType":"struct LightNode.ProofData","name":"_proof","type":"tuple"}],"name":"getBytes","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"}]`
)

'''
'''--- mapprotocol/client.go ---
package mapprotocol

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"time"

	log "github.com/ChainSafe/log15"
	eth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	maptypes "github.com/mapprotocol/atlas/core/types"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/mapprotocol/compass/pkg/util"
)

func GetMapTransactionsHashByBlockNumber(conn *ethclient.Client, number *big.Int) ([]common.Hash, error) {
	block, err := conn.MAPBlockByNumber(context.Background(), number)
	if err != nil {
		return nil, err
	}

	txs := make([]common.Hash, 0, len(block.Transactions))
	for _, tx := range block.Transactions {
		ele := common.HexToHash(tx.Hash)
		txs = append(txs, ele)
	}
	return txs, nil
}

func GetLastReceipt(conn *ethclient.Client, latestBlock *big.Int) (*types.Receipt, error) {
	query := eth.FilterQuery{
		FromBlock: latestBlock,
		ToBlock:   latestBlock,
	}
	lastLog, err := conn.FilterLogs(context.Background(), query)
	if err != nil {
		return nil, err
	}
	receipt := maptypes.NewReceipt(nil, false, 0)
	rl := make([]*maptypes.Log, 0, len(lastLog))
	el := make([]*types.Log, 0, len(lastLog))
	for idx, ll := range lastLog {
		if idx == 0 {
			continue
		}
		if ll.TxHash != ll.BlockHash {
			continue
		}
		rl = append(rl, &maptypes.Log{
			Address:     ll.Address,
			Topics:      ll.Topics,
			Data:        ll.Data,
			BlockNumber: ll.BlockNumber,
			TxHash:      ll.TxHash,
			TxIndex:     ll.TxIndex,
			BlockHash:   ll.BlockHash,
			Index:       ll.Index,
			Removed:     ll.Removed,
		})
		tl := ll
		el = append(el, &tl)
	}
	receipt.Logs = rl
	receipt.Bloom = maptypes.CreateBloom(maptypes.Receipts{receipt})
	return &types.Receipt{
		Type:              receipt.Type,
		PostState:         receipt.PostState,
		Status:            receipt.Status,
		CumulativeGasUsed: receipt.CumulativeGasUsed,
		Bloom:             types.BytesToBloom(receipt.Bloom.Bytes()),
		Logs:              el,
		TxHash:            receipt.TxHash,
		ContractAddress:   receipt.ContractAddress,
		GasUsed:           receipt.GasUsed,
		BlockHash:         receipt.BlockHash,
		BlockNumber:       receipt.BlockNumber,
		TransactionIndex:  receipt.TransactionIndex,
	}, nil
}

type Zk struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data struct {
		Height string `json:"height"`
		Status int    `json:"status"`
		Result struct {
			Proof struct {
				PiA      []string   `json:"pi_a"`
				PiB      [][]string `json:"pi_b"`
				PiC      []string   `json:"pi_c"`
				Protocol string     `json:"protocol"`
			} `json:"proof"`
			PublicInput []string `json:"public_input"`
		} `json:"result"`
		ErrorMsg string `json:"error_msg"`
	} `json:"data"`
}

func GetZkProof(endpoint string, cid msg.ChainId, height uint64) ([]*big.Int, error) {
	ret := make([]*big.Int, 0, 8)
	for {
		resp, err := http.Get(fmt.Sprintf("%s/proof?chain_id=%d&height=%d", endpoint, cid, height))
		if err != nil {
			util.Alarm(context.Background(), fmt.Sprintf("GetZkProof cid(%d) request failed, err is %v", height, err))
			log.Error("GetZkProof request failed", "err", err, "height", height, "cid", cid)
			time.Sleep(constant.BlockRetryInterval)
			continue
		}
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Error("GetZkProof read body failed", "err", err)
			time.Sleep(constant.BlockRetryInterval)
			continue
		}
		_ = resp.Body.Close()
		zk := &Zk{}
		err = json.Unmarshal(body, zk)
		if err != nil {
			util.Alarm(context.Background(), fmt.Sprintf("GetZkProof cid(%d) Unmarshal failed, err is %v", height, err))
			log.Error("GetZkProof Unmarshal failed", "err", err, "data", string(body))
			time.Sleep(constant.BlockRetryInterval)
			continue
		}
		// check status
		if zk.Data.Status != 3 {
			//util.Alarm(context.Background(), fmt.Sprintf("GetZkProof cid(%d) height(%d) Proof Not Ready", cid, height))
			log.Info("GetZkProof Proof Not Read", "cid", cid, "height", height)
			time.Sleep(constant.BalanceRetryInterval)
			continue
		}
		ret = append(ret, getId(zk.Data.Result.Proof.PiA)...)
		for _, bs := range zk.Data.Result.Proof.PiB {
			ret = append(ret, getId(bs)...)
		}
		ret = append(ret, getId(zk.Data.Result.Proof.PiC)...)
		break
	}
	return ret, nil
}

func GetCurValidators(cli *ethclient.Client, number *big.Int) ([]byte, error) {
	snapshot, err := cli.GetValidatorsBLSPublicKeys(context.Background(), number)
	if err != nil {
		return nil, err
	}

	ret := make([][]byte, 0)
	for _, v := range snapshot {
		ele := make([]byte, 0)
		for _, k := range v {
			ele = append(ele, k)
		}
		ret = append(ret, ele)
	}

	return makeValidatorInfo(ret), nil
}

func getId(ss []string) []*big.Int {
	ret := make([]*big.Int, 0, len(ss))
	for _, s := range ss {
		if s == "0" || s == "1" || len(s) <= 1 {
			continue
		}
		setString, ok := big.NewInt(0).SetString(s, 10)
		if !ok {
			continue
		}
		ret = append(ret, setString)
	}
	return ret
}

var (
	PUBLENGTH = 128
)

func makeValidatorInfo(blsPubkeys [][]byte) []byte {
	data := make([]byte, 0)
	count := len(blsPubkeys)
	left := 0
	if PUBLENGTH > count {
		left = PUBLENGTH - count
	}
	length := left * 160
	data1 := make([]byte, length)
	// info: pubkey+weight
	for i := 0; i < count; i++ {
		data = append(data, blsPubkeys[i]...)
		weight := []byte{0x01}
		weight = padTo32Bytes(weight)
		data = append(data, weight...)
	}
	data = append(data, data1...)
	return data
}

func padTo32Bytes(data []byte) []byte {
	paddingSize := 32 - len(data)
	if paddingSize <= 0 {
		return data
	}
	paddedData := make([]byte, 32)
	copy(paddedData[paddingSize:], data)
	return paddedData
}

'''
'''--- mapprotocol/mapprotocol.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package mapprotocol

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/contract"
	nearclient "github.com/mapprotocol/near-api-go/pkg/client"
	"math/big"

	"github.com/mapprotocol/near-api-go/pkg/client/block"

	"github.com/ethereum/go-ethereum"
	goeth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/msg"
	"github.com/mapprotocol/compass/pkg/ethclient"
	"github.com/pkg/errors"
)

type GetHeight func() (*big.Int, error)
type GetVerifyRange func() (*big.Int, *big.Int, error)

var (
	MapId             string
	GlobalMapConn     *ethclient.Client
	SyncOtherMap      = make(map[msg.ChainId]*big.Int)  // map to other chain init height
	Map2OtherHeight   = make(map[msg.ChainId]GetHeight) // get map to other height function collect
	ContractMapping   = make(map[msg.ChainId]*contract.Call)
	Get2MapHeight     = func(chainId msg.ChainId) (*big.Int, error) { return nil, nil }                // get other chain to map height
	GetEth22MapNumber = func(chainId msg.ChainId) (*big.Int, *big.Int, error) { return nil, nil, nil } // can reform, return data is []byte
	GetDataByManager  = func(string, ...interface{}) ([]byte, error) { return nil, nil }
)

func InitLightManager(lightNode common.Address) {
	GetDataByManager = func(method string, params ...interface{}) ([]byte, error) {
		input, err := PackInput(LightManger, method, params...)
		if err != nil {
			return nil, errors.Wrap(err, "get other2map packInput failed")
		}
		output, err := GlobalMapConn.CallContract(
			context.Background(),
			goeth.CallMsg{From: constant.ZeroAddress, To: &lightNode, Data: input},
			nil,
		)
		if err != nil {
			return nil, err
		}
		outputs := LightManger.Methods[method].Outputs
		unpack, err := outputs.Unpack(output)
		if err != nil {
			return nil, err
		}
		ret := make([]byte, 0)
		if err = outputs.Copy(&ret, unpack); err != nil {
			return nil, err
		}

		return ret, nil
	}
}

func Init2GetEth22MapNumber(lightNode common.Address) {
	GetEth22MapNumber = func(chainId msg.ChainId) (*big.Int, *big.Int, error) {
		input, err := PackInput(LightManger, MethodClientState, big.NewInt(int64(chainId)))
		if err != nil {
			return nil, nil, errors.Wrap(err, "get eth22map packInput failed")
		}

		output, err := GlobalMapConn.CallContract(context.Background(),
			goeth.CallMsg{From: constant.ZeroAddress, To: &lightNode, Data: input}, nil)
		if err != nil {
			return nil, nil, err
		}

		outputs := LightManger.Methods[MethodClientState].Outputs
		unpack, err := outputs.Unpack(output)
		if err != nil {
			return nil, nil, err
		}

		back := make([]byte, 0)
		if err = outputs.Copy(&back, unpack); err != nil {
			return nil, nil, err
		}

		ret := struct {
			StartNumber *big.Int
			EndNumber   *big.Int
		}{}
		analysis, err := Eth2.Methods[MethodClientStateAnalysis].Outputs.Unpack(back)
		if err != nil {
			return nil, nil, errors.Wrap(err, "analysis")
		}
		if err = Eth2.Methods[MethodClientStateAnalysis].Outputs.Copy(&ret, analysis); err != nil {
			return nil, nil, errors.Wrap(err, "analysis copy")
		}

		return ret.StartNumber, ret.EndNumber, nil
	}
}

func InitOtherChain2MapHeight(lightManager common.Address) {
	Get2MapHeight = func(chainId msg.ChainId) (*big.Int, error) {
		input, err := PackInput(LightManger, MethodOfHeaderHeight, big.NewInt(int64(chainId)))
		if err != nil {
			return nil, errors.Wrap(err, "get other2map by manager packInput failed")
		}

		height, err := HeaderHeight(lightManager, input)
		if err != nil {
			return nil, errors.Wrap(err, "get other2map headerHeight by lightManager failed")
		}
		return height, nil
	}
}

func Map2EthHeight(fromUser string, lightNode common.Address, client *ethclient.Client) GetHeight {
	return func() (*big.Int, error) {
		from := common.HexToAddress(fromUser)
		input, err := PackInput(Height, MethodOfHeaderHeight)
		if err != nil {
			return nil, fmt.Errorf("pack lightNode headerHeight Input failed, err is %v", err.Error())
		}
		output, err := client.CallContract(context.Background(),
			ethereum.CallMsg{
				From: from,
				To:   &lightNode,
				Data: input,
			},
			nil,
		)
		if err != nil {
			return nil, fmt.Errorf("headerHeight callContract failed, err is %v", err.Error())
		}

		return UnpackHeaderHeightOutput(output)
	}
}

func Map2NearHeight(lightNode string, client *nearclient.Client) GetHeight {
	return func() (*big.Int, error) {
		res, err := client.ContractViewCallFunction(context.Background(), lightNode, NearHeaderHeight,
			"e30=", block.FinalityFinal())
		if err != nil {
			return nil, errors.Wrap(err, "call near lightNode to headerHeight failed")
		}

		if res.Error != nil {
			return nil, fmt.Errorf("call near lightNode to get headerHeight resp exist error(%v)", *res.Error)
		}

		result := "" // use string return
		err = json.Unmarshal(res.Result, &result)
		if err != nil {
			return nil, errors.Wrap(err, "near lightNode headerHeight resp json marshal failed")
		}
		ret := new(big.Int)
		ret.SetString(result, 10)
		return ret, nil
	}
}

func PackInput(commonAbi abi.ABI, abiMethod string, params ...interface{}) ([]byte, error) {
	input, err := commonAbi.Pack(abiMethod, params...)
	if err != nil {
		return nil, err
	}
	return input, nil
}

func UnpackHeaderHeightOutput(output []byte) (*big.Int, error) {
	outputs := Height.Methods[MethodOfHeaderHeight].Outputs
	unpack, err := outputs.Unpack(output)
	if err != nil {
		return big.NewInt(0), err
	}

	height := new(big.Int)
	if err = outputs.Copy(&height, unpack); err != nil {
		return big.NewInt(0), err
	}
	return height, nil
}

func HeaderHeight(to common.Address, input []byte) (*big.Int, error) {
	output, err := GlobalMapConn.CallContract(context.Background(), goeth.CallMsg{From: constant.ZeroAddress, To: &to, Data: input}, nil)
	if err != nil {
		return nil, err
	}
	height, err := UnpackHeaderHeightOutput(output)
	if err != nil {
		return nil, err
	}
	return height, nil
}

//
//func InitOtherChain2MapVerifyRange(lightManager common.Address) {
//	Get2MapVerifyRange = func(chainId msg.ChainId) (*big.Int, *big.Int, error) {
//		input, err := PackInput(LightManger, MethodVerifiableHeaderRange, big.NewInt(int64(chainId)))
//		if err != nil {
//			return nil, nil, errors.Wrap(err, "get other2map verifyRange packInput failed")
//		}
//
//		left, right, err := VerifyRange(lightManager, input)
//		if err != nil {
//			return nil, nil, errors.Wrap(err, "get other2map verifyRange by lightManager failed")
//		}
//		return left, right, nil
//	}
//}

func Map2EthVerifyRange(fromUser string, lightNode common.Address, client *ethclient.Client) GetVerifyRange {
	return func() (*big.Int, *big.Int, error) {
		from := common.HexToAddress(fromUser)
		input, err := PackInput(Verify, MethodVerifiableHeaderRange)
		if err != nil {
			return nil, nil, errors.Wrap(err, "pack lightNode verifiableHeaderRange Input failed")
		}
		output, err := client.CallContract(context.Background(),
			ethereum.CallMsg{
				From: from,
				To:   &lightNode,
				Data: input,
			},
			nil,
		)
		if err != nil {
			return nil, nil, fmt.Errorf("verifiableHeaderRange callContract failed, err is %v", err.Error())
		}

		return UnpackVerifyRangeOutput(output)
	}
}

func Map2NearVerifyRange(lightNode string, client *nearclient.Client) GetVerifyRange {
	return func() (*big.Int, *big.Int, error) {
		res, err := client.ContractViewCallFunction(context.Background(), lightNode, NearVerifyRange,
			"e30=", block.FinalityFinal())
		if err != nil {
			return nil, nil, errors.Wrap(err, "call near lightNode to get_verifiable_header_range failed")
		}

		if res.Error != nil {
			return nil, nil, fmt.Errorf("call near lightNode to get get_verifiable_header_range resp exist error(%v)", *res.Error)
		}

		var verifyRange [2]string
		err = json.Unmarshal(res.Result, &verifyRange)
		if err != nil {
			return nil, nil, errors.Wrap(err, "near lightNode get_verifiable_header_range resp json marshal failed")
		}
		var left, right big.Int
		left.SetString(verifyRange[0], 10)
		right.SetString(verifyRange[1], 10)
		return &left, &right, nil
	}
}

func VerifyRange(to common.Address, input []byte) (*big.Int, *big.Int, error) {
	output, err := GlobalMapConn.CallContract(context.Background(), goeth.CallMsg{From: constant.ZeroAddress, To: &to, Data: input}, nil)
	if err != nil {
		return nil, nil, err
	}
	left, right, err := UnpackVerifyRangeOutput(output)
	if err != nil {
		return nil, nil, err
	}
	return left, right, nil
}

func UnpackVerifyRangeOutput(output []byte) (*big.Int, *big.Int, error) {
	outputs := Verify.Methods[MethodVerifiableHeaderRange].Outputs
	unpack, err := outputs.Unpack(output)
	if err != nil {
		return new(big.Int), new(big.Int), err
	}

	ret := struct {
		Left  *big.Int
		Right *big.Int
	}{}
	if err = outputs.Copy(&ret, unpack); err != nil {
		return new(big.Int), new(big.Int), err
	}
	return ret.Left, ret.Right, nil
}

'''
'''--- mapprotocol/near.go ---
package mapprotocol

import (
	"math/big"

	"github.com/mapprotocol/near-api-go/pkg/client"
	"github.com/mapprotocol/near-api-go/pkg/types"
	"github.com/mapprotocol/near-api-go/pkg/types/hash"
	"github.com/mapprotocol/near-api-go/pkg/types/key"
	"github.com/mapprotocol/near-api-go/pkg/types/signature"
)

const (
	TransferOut = "transfer out"
	DepositOut  = "deposit out"
)

type StreamerMessage struct {
	Block  client.BlockView `json:"block"`
	Shards []IndexerShard   `json:"shards"`
}

type IndexerShard struct {
	Chunk                    *IndexerChunkView                    `json:"chunk"`
	ReceiptExecutionOutcomes []IndexerExecutionOutcomeWithReceipt `json:"receipt_execution_outcomes"`
	ShardID                  types.ShardID                        `json:"shard_id"`
	StateChanges             StateChangesView                     `json:"state_changes"`
}

type IndexerChunkView struct {
	Author   types.AccountID        `json:"author"`
	Header   client.ChunkHeaderView `json:"header"`
	Receipts []ReceiptView          `json:"receipts"`
	//Transactions []IndexerTransactionWithOutcome `json:"transactions"`
}

type ReceiptView struct {
	PredecessorId types.AccountID `json:"predecessor_id"`
	ReceiverID    types.AccountID `json:"receiver_id"`
	ReceiptID     hash.CryptoHash `jsom:"receipt_id"`
	Receipt       Receipt         `json:"receipt"`
}

type Receipt struct {
	Action Action `json:"Action"`
}

type Action struct {
	Actions []interface{} `json:"actions"` //
	//Actions             []map[string]interface{} `json:"actions"` //
	GasPrice            string        `json:"gas_price"`
	InputDataIds        []interface{} `json:"input_data_ids"`
	OutputDataReceivers []interface{} `json:"output_data_receivers"`
	SignerID            string        `json:"signer_id"`
	SignerPublicKey     string        `json:"signer_public_key"`
}

type IndexerTransactionWithOutcome struct {
	Outcome     IndexerExecutionOutcomeWithOptionalReceipt `json:"outcome"`
	Transaction SignedTransactionView                      `json:"transaction"`
}

type SignedTransactionView struct {
	SignerID   types.AccountID           `json:"signer_id"`
	PublicKey  key.Base58PublicKey       `json:"public_key"`
	Nonce      types.Nonce               `json:"nonce"`
	ReceiverID types.AccountID           `json:"receiver_id"`
	Actions    []interface{}             `json:"actions"`
	Signature  signature.Base58Signature `json:"signature"`
	Hash       hash.CryptoHash           `json:"hash"`
}

type IndexerExecutionOutcomeWithReceipt struct {
	ExecutionOutcome ExecutionOutcomeWithIdView `json:"execution_outcome"`
	Receipt          ReceiptView                `json:"receipt"`
}

type ExecutionOutcomeWithIdView struct {
	BlockHash hash.CryptoHash      `json:"block_hash"`
	ID        hash.CryptoHash      `json:"id"`
	Outcome   ExecutionOutcomeView `json:"outcome"`
	Proof     MerklePath           `json:"proof"`
}

type ExecutionOutcomeView struct {
	ExecutorID  types.AccountID          `json:"executor_id"`
	GasBurnt    types.Gas                `json:"gas_burnt"`
	Logs        []string                 `json:"logs"`
	Metadata    Metadata                 `json:"metadata"`
	ReceiptIDs  []hash.CryptoHash        `json:"receipt_ids"`
	Status      client.TransactionStatus `json:"status"`
	TokensBurnt string                   `json:"tokens_burnt"` // "242953087248000000000"
}

type MerklePathItem struct {
	Hash      hash.CryptoHash `json:"hash"`
	Direction string          `json:"direction"`
}

type MerklePath = []MerklePathItem

type IndexerExecutionOutcomeWithOptionalReceipt struct {
	ExecutionOutcome ExecutionOutcomeWithIdView `json:"execution_outcome"`
	Receipt          *client.ReceiptView        `json:"receipt"`
}

type StateChangesView []StateChangeWithCauseView

type StateChangeWithCauseView struct {
	Type   TypeOfStateChange    `json:"type"`
	Cause  StateChangeCauseView `json:"cause"`
	Change StateChangeView      `json:"change"`
	// Value  StateChangeValueView `json:"value"`
}

type StateChangeCauseView struct {
	ReceiptHash string `json:"receipt_hash"`
	Type        string `json:"type"`
}

type StateChangeView struct {
	AccountId     types.AccountID `json:"account_id"`
	Amount        string          `json:"amount"`
	CodeHash      string          `json:"code_hash"`
	Locked        string          `json:"locked"`
	StoragePaidAt int64           `json:"storage_paid_at"`
	StorageUsage  int64           `json:"storage_usage"`
	CodeBase64    string          `json:"code_base_64"`
}

type AccessKey struct {
	Nonce      *big.Int
	Permission string
}

// type StateChangeValueView json.RawMessage

type (
	TypeOfStateChange string
)

'''
'''--- mapprotocol/params.go ---
package mapprotocol

import (
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/msg"
)

const (
	MethodVerifyProofData        = "verifyProofData"
	MethodUpdateBlockHeader      = "updateBlockHeader"
	MethodVerifiableHeaderRange  = "verifiableHeaderRange"
	MethodOfHeaderHeight         = "headerHeight"
	MethodOfTransferIn           = "transferIn"
	MethodOfDepositIn            = "depositIn"
	MethodOfSwapIn               = "swapIn"
	MethodOfOrderList            = "orderList"
	MethodOfIsUsedEvent          = "is_used_event"
	MethodOfGetBytes             = "getBytes"
	MethodOfGetFinalBytes        = "getFinalBytes"
	MethodOfGetHeadersBytes      = "getHeadersBytes"
	MethodOfGetBlockHeadersBytes = "getBlockHeaderBytes"
	MethodOfGetUpdatesBytes      = "getUpdateBytes"
	MethodUpdateLightClient      = "updateLightClient"
	MethodClientState            = "clientState"
	MethodClientStateAnalysis    = "clientStateAnalysis"
	MethodOfState                = "state"
	MethodOfNearestPivot         = "nearestPivot"
	MethodOFinalizedState        = "finalizedState"
	MethodOfVerifyReceiptProof   = "verifyReceiptProof"
	MethodOfOrderStatus          = "getOrderStatus"
	MethodOfPropose              = "propose"
	MethodOfVerifyAndStore       = "swapInVerify"
	MethodOfSwapInVerified       = "swapInVerified"
	EventOfSwapInVerified        = "mapSwapInVerified"
)

const (
	NearVerifyRange  = "get_verifiable_header_range"
	NearHeaderHeight = "get_header_height"
)

const (
	EpochOfMap          = 50000
	EpochOfBsc          = 200
	HeaderCountOfBsc    = 12
	HeaderCountOfMatic  = 16
	HeaderCountOfPlaton = 430
	EpochOfKlaytn       = 3600
	HeaderOneCount      = 1
	HeaderCountOfBttc   = 64
)

var (
	Big0 = big.NewInt(0)
)

var (
	HashOfDepositIn = common.HexToHash("0xb7100086a8e13ebae772a0f09b07046e389a6b036406d22b86f2d2e5b860a8d9")
	HashOfSwapIn    = common.HexToHash("0xca1cf8cebf88499429cca8f87cbca15ab8dafd06702259a5344ddce89ef3f3a5")
	NearOfDepositIn = "150bd848adaf4e3e699dcac82d75f111c078ce893375373593cc1b9208998377"
	NearOfSwapIn    = "ca1cf8cebf88499429cca8f87cbca15ab8dafd06702259a5344ddce89ef3f3a5"
)

var (
	Mcs, _         = abi.JSON(strings.NewReader(McsAbi))
	Bsc, _         = abi.JSON(strings.NewReader(BscAbiJson))
	Conflux, _     = abi.JSON(strings.NewReader(ConfluxAbiJson))
	Klaytn, _      = abi.JSON(strings.NewReader(KlaytnAbiJson))
	Near, _        = abi.JSON(strings.NewReader(NearAbiJson))
	LightManger, _ = abi.JSON(strings.NewReader(LightMangerAbi))
	Map2Other, _   = abi.JSON(strings.NewReader(Map2OtherAbi))
	Height, _      = abi.JSON(strings.NewReader(HeightAbiJson))
	Verify, _      = abi.JSON(strings.NewReader(VerifiableHeaderRangeAbiJson))
	Matic, _       = abi.JSON(strings.NewReader(MaticAbiJson))
	Eth2, _        = abi.JSON(strings.NewReader(Eth2AbiJson))
	Platon, _      = abi.JSON(strings.NewReader(PlatonAbiJson))
	Other, _       = abi.JSON(strings.NewReader(otherAbi))
	Bttc, _        = abi.JSON(strings.NewReader(bttcAbi))
	OracleAbi, _   = abi.JSON(strings.NewReader(OracleAbiJson))
	ProofAbi, _    = abi.JSON(strings.NewReader(ProofAbiJson))
)

type Role string

var (
	RoleOfMaintainer Role = "maintainer"
	RoleOfMessenger  Role = "messenger"
	RoleOfOracle     Role = "oracle"
)

var (
	OnlineChaId = map[msg.ChainId]string{}
)

var (
	ConfirmsOfMatic             = big.NewInt(10)
	HeaderLenOfBttc       int64 = 10
	HeaderLengthOfEth2          = 20
	HeaderLengthOfConflux       = 20
)

'''
'''--- mapprotocol/types.go ---
package mapprotocol

import (
	"context"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/light"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/mapprotocol/atlas/consensus/istanbul/validator"
	"github.com/mapprotocol/atlas/core/types"
	"github.com/mapprotocol/atlas/helper/bls"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

var (
	receiptStatusFailedRLP     = []byte{}
	receiptStatusSuccessfulRLP = []byte{0x01}
)

type G2 struct {
	Xr *big.Int
	Xi *big.Int
	Yr *big.Int
	Yi *big.Int
}

type BlockHeader struct {
	ParentHash  []byte
	Coinbase    common.Address
	Root        []byte
	TxHash      []byte
	ReceiptHash []byte
	Bloom       []byte
	Number      *big.Int
	GasLimit    *big.Int
	GasUsed     *big.Int
	Time        *big.Int
	ExtraData   []byte
	MixDigest   []byte
	Nonce       []byte
	BaseFee     *big.Int
}

type TxLog struct {
	Addr   common.Address
	Topics [][]byte
	Data   []byte
}

type TxReceipt struct {
	ReceiptType       *big.Int
	PostStateOrStatus []byte
	CumulativeGasUsed *big.Int
	Bloom             []byte
	Logs              []TxLog
}

type ReceiptProof struct {
	Header   *BlockHeader
	AggPk    *G2
	Receipt  *TxReceipt
	KeyIndex []byte
	Proof    [][]byte
}

type NewMapReceiptProof struct {
	Header       *BlockHeader
	AggPk        *G2
	KeyIndex     []byte
	Proof        [][]byte
	Ist          IstanbulExtra
	TxReceiptRlp TxReceiptRlp
}

type IstanbulExtra struct {
	// Validators are the validators that have been added in the block
	Validators []common.Address
	// AddedPubKey are the BLS public keys for the validators added in the block
	AddedPubKey [][]byte
	// AddedG1PubKey are the BLS public keys for the validators added in the block
	AddedG1PubKey [][]byte
	// RemoveList is a bitmap having an active bit for each removed validator in the block
	RemoveList *big.Int
	// Seal is an ECDSA signature by the proposer
	Seal []byte
	// AggregatedSeal contains the aggregated BLS signature created via IBFT consensus.
	AggregatedSeal IstanbulAggregatedSeal
	// ParentAggregatedSeal contains and aggregated BLS signature for the previous block.
	ParentAggregatedSeal IstanbulAggregatedSeal
}

type IstanbulAggregatedSeal struct {
	Bitmap    *big.Int
	Signature []byte
	Round     *big.Int
}

func ConvertIstanbulExtra(istanbulExtra *types.IstanbulExtra) *IstanbulExtra {
	addedPubKey := make([][]byte, 0, len(istanbulExtra.AddedValidatorsPublicKeys))
	for _, avpk := range istanbulExtra.AddedValidatorsPublicKeys {
		data := make([]byte, 0, len(avpk))
		for _, v := range avpk {
			data = append(data, v)
		}
		addedPubKey = append(addedPubKey, data)
	}
	addedValidatorsG1PublicKeys := make([][]byte, 0, len(istanbulExtra.AddedValidatorsG1PublicKeys))
	for _, avgpk := range istanbulExtra.AddedValidatorsG1PublicKeys {
		data := make([]byte, 0, len(avgpk))
		for _, v := range avgpk {
			data = append(data, v)
		}
		addedValidatorsG1PublicKeys = append(addedValidatorsG1PublicKeys, data)
	}

	return &IstanbulExtra{
		Validators:    istanbulExtra.AddedValidators,
		AddedPubKey:   addedPubKey,
		AddedG1PubKey: addedValidatorsG1PublicKeys,
		RemoveList:    istanbulExtra.RemovedValidators,
		Seal:          istanbulExtra.Seal,
		AggregatedSeal: IstanbulAggregatedSeal{
			Bitmap:    istanbulExtra.AggregatedSeal.Bitmap,
			Signature: istanbulExtra.AggregatedSeal.Signature,
			Round:     istanbulExtra.AggregatedSeal.Round,
		},
		ParentAggregatedSeal: IstanbulAggregatedSeal{
			Bitmap:    istanbulExtra.ParentAggregatedSeal.Bitmap,
			Signature: istanbulExtra.ParentAggregatedSeal.Signature,
			Round:     istanbulExtra.ParentAggregatedSeal.Round,
		},
	}
}

type TxReceiptRlp struct {
	ReceiptType *big.Int
	ReceiptRlp  []byte
}

type MapTxReceipt struct {
	PostStateOrStatus []byte
	CumulativeGasUsed *big.Int
	Bloom             []byte
	Logs              []TxLog
}

type NewReceiptProof struct {
	Router   common.Address
	Coin     common.Address
	SrcChain *big.Int
	DstChain *big.Int
	TxProve  []byte
}

type TxProve struct {
	Receipt     *ethtypes.Receipt
	Prove       light.NodeList
	BlockNumber uint64
	TxIndex     uint
}

func ConvertHeader(header *types.Header) *BlockHeader {
	h := &BlockHeader{
		ParentHash:  header.ParentHash[:],
		Coinbase:    header.Coinbase,
		Root:        header.Root[:],
		TxHash:      header.TxHash[:],
		ReceiptHash: header.ReceiptHash[:],
		Bloom:       header.Bloom[:],
		Number:      header.Number,
		GasLimit:    new(big.Int).SetUint64(header.GasLimit),
		GasUsed:     new(big.Int).SetUint64(header.GasUsed),
		Time:        new(big.Int).SetUint64(header.Time),
		ExtraData:   header.Extra,
		MixDigest:   header.MixDigest[:],
		Nonce:       header.Nonce[:],
		BaseFee:     header.BaseFee,
	}
	return h
}

func GetAggPK(cli *ethclient.Client, number *big.Int, extra []byte) (*G2, *types.IstanbulExtra, []byte, error) {
	var istanbulExtra *types.IstanbulExtra
	if err := rlp.DecodeBytes(extra[32:], &istanbulExtra); err != nil {
		return nil, nil, nil, err
	}

	snapshot, err := cli.GetSnapshot(context.Background(), number)
	if err != nil {
		return nil, nil, nil, err
	}

	validators := validator.MapValidatorsToDataWithBLSKeyCache(snapshot.ValSet.List())
	publicKeys := make([]bls.SerializedPublicKey, 0)
	for i, v := range validators {
		if istanbulExtra.AggregatedSeal.Bitmap.Bit(i) == 1 {
			publicKeys = append(publicKeys, v.BLSPublicKey)
		}
	}

	var pks []*bls.PublicKey
	for _, v := range publicKeys {
		pk, err := bls.UnmarshalPk(v[:])
		if err != nil {
			return nil, nil, nil, err
		}
		pks = append(pks, pk)
	}

	aggPKBytes := bls.AggregatePK(pks).Marshal()
	return &G2{
		Xi: new(big.Int).SetBytes(aggPKBytes[:32]),
		Xr: new(big.Int).SetBytes(aggPKBytes[32:64]),
		Yi: new(big.Int).SetBytes(aggPKBytes[64:96]),
		Yr: new(big.Int).SetBytes(aggPKBytes[96:128]),
	}, istanbulExtra, aggPKBytes, nil
}

func GetTxReceipt(receipt *ethtypes.Receipt) (*TxReceipt, error) {
	logs := make([]TxLog, 0, len(receipt.Logs))
	for _, lg := range receipt.Logs {
		topics := make([][]byte, len(lg.Topics))
		for i := range lg.Topics {
			topics[i] = lg.Topics[i][:]
		}
		logs = append(logs, TxLog{
			Addr:   lg.Address,
			Topics: topics,
			Data:   lg.Data,
		})
	}

	return &TxReceipt{
		ReceiptType:       new(big.Int).SetUint64(uint64(receipt.Type)),
		PostStateOrStatus: StatusEncoding(receipt),
		CumulativeGasUsed: new(big.Int).SetUint64(receipt.CumulativeGasUsed),
		Bloom:             receipt.Bloom[:],
		Logs:              logs,
	}, nil
}

func StatusEncoding(r *ethtypes.Receipt) []byte {
	if len(r.PostState) == 0 {
		if r.Status == types.ReceiptStatusFailed {
			return receiptStatusFailedRLP
		}
		return receiptStatusSuccessfulRLP
	}
	return r.PostState
}

type NearNeedHeader struct {
	ParentHash  common.Hash      `json:"parentHash"       gencodec:"required"`
	Coinbase    common.Address   `json:"coinbase"            gencodec:"required"`
	Root        common.Hash      `json:"root"         gencodec:"required"`
	TxHash      common.Hash      `json:"txHash" gencodec:"required"`
	ReceiptHash common.Hash      `json:"receiptHash"     gencodec:"required"`
	Bloom       types.Bloom      `json:"bloom"        gencodec:"required"`
	Number      *hexutil.Big     `json:"number"           gencodec:"required"`
	GasLimit    hexutil.Uint64   `json:"gasLimit"         gencodec:"required"`
	GasUsed     hexutil.Uint64   `json:"gasUsed"          gencodec:"required"`
	Time        hexutil.Uint64   `json:"time"        gencodec:"required"`
	Extra       hexutil.Bytes    `json:"extra"        gencodec:"required"`
	MixDigest   common.Hash      `json:"mixDigest"`
	Nonce       types.BlockNonce `json:"nonce"`
	BaseFee     *hexutil.Big     `json:"baseFee" rlp:"optional"`
	Hash        common.Hash      `json:"hash"`
}

func ConvertNearNeedHeader(h *types.Header) *NearNeedHeader {
	var enc NearNeedHeader
	enc.ParentHash = h.ParentHash
	enc.Coinbase = h.Coinbase
	enc.Root = h.Root
	enc.TxHash = h.TxHash
	enc.ReceiptHash = h.ReceiptHash
	enc.Bloom = h.Bloom
	enc.Number = (*hexutil.Big)(h.Number)
	enc.GasLimit = hexutil.Uint64(h.GasLimit)
	enc.GasUsed = hexutil.Uint64(h.GasUsed)
	enc.Time = hexutil.Uint64(h.Time)
	enc.Extra = h.Extra
	enc.MixDigest = h.MixDigest
	enc.Nonce = h.Nonce
	enc.BaseFee = (*hexutil.Big)(h.BaseFee)
	enc.Hash = h.Hash()
	return &enc
}

type NearReceiptProof struct {
	BlockHeaderLite  BlockHeaderLite    `json:"block_header_lite"`
	BlockProof       []BlockProof       `json:"block_proof"`
	OutcomeProof     OutcomeProof       `json:"outcome_proof"`
	OutcomeRootProof []OutcomeRootProof `json:"outcome_root_proof"`
}

type InnerLite struct {
	BlockMerkleRoot  string `json:"block_merkle_root"`
	EpochID          string `json:"epoch_id"`
	Height           int    `json:"height"`
	NextBpHash       string `json:"next_bp_hash"`
	NextEpochID      string `json:"next_epoch_id"`
	OutcomeRoot      string `json:"outcome_root"`
	PrevStateRoot    string `json:"prev_state_root"`
	Timestamp        int64  `json:"timestamp"`
	TimestampNanosec string `json:"timestamp_nanosec"`
}

type BlockHeaderLite struct {
	InnerLite     InnerLite `json:"inner_lite"`
	InnerRestHash string    `json:"inner_rest_hash"`
	PrevBlockHash string    `json:"prev_block_hash"`
}

type BlockProof struct {
	Direction string `json:"direction"`
	Hash      string `json:"hash"`
}

type GasProfile struct {
	Cost         string `json:"cost"`
	CostCategory string `json:"cost_category"`
	GasUsed      string `json:"gas_used"`
}

type Metadata struct {
	GasProfile []GasProfile `json:"gas_profile"`
	Version    int          `json:"version"`
}

type Status struct {
	SuccessValue string `json:"SuccessValue"`
}

type Outcome struct {
	ExecutorID  string        `json:"executor_id"`
	GasBurnt    int64         `json:"gas_burnt"`
	Logs        []interface{} `json:"logs"`
	Metadata    Metadata      `json:"metadata"`
	ReceiptIds  []string      `json:"receipt_ids"`
	Status      Status        `json:"status"`
	TokensBurnt string        `json:"tokens_burnt"`
}

type Proof struct {
	Direction string `json:"direction"`
	Hash      string `json:"hash"`
}

type OutcomeProof struct {
	BlockHash string  `json:"block_hash"`
	ID        string  `json:"id"`
	Outcome   Outcome `json:"outcome"`
	Proof     []Proof `json:"proof"`
}

type OutcomeRootProof struct {
	Direction string `json:"direction"`
	Hash      string `json:"hash"`
}

'''
'''--- msg/message.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package msg

type ChainId uint64
type TransferType string

var (
	SyncToMap        TransferType = "SyncToMap"
	SwapWithProof    TransferType = "SwapWithProof"
	SyncFromMap      TransferType = "SyncFromMap"
	SwapWithMapProof TransferType = "SwapWithMapProof"
	SwapWithMerlin   TransferType = "SwapWithMerlin"
)

// Message is used as a generic format to communicate between chains
type Message struct {
	Idx         int
	Source      ChainId         // Source where message was initiated
	Destination ChainId         // Destination chain of message
	Type        TransferType    // type of bridge transfer
	Payload     []interface{}   // data associated with event sequence
	DoneCh      chan<- struct{} // notify message is handled
}

func NewSyncToMap(fromChainID, toChainID ChainId, payloads []interface{}, ch chan<- struct{}) Message {
	return Message{
		Source:      fromChainID,
		Destination: toChainID,
		Type:        SyncToMap,
		Payload:     payloads,
		DoneCh:      ch,
	}
}

func NewSwapWithProof(fromChainID, toChainID ChainId, payloads []interface{}, ch chan<- struct{}) Message {
	return Message{
		Source:      fromChainID,
		Destination: toChainID,
		Type:        SwapWithProof,
		Payload:     payloads,
		DoneCh:      ch,
	}
}

func NewSyncFromMap(mapChainID, toChainID ChainId, payloads []interface{}, ch chan<- struct{}) Message {
	return Message{
		Source:      mapChainID,
		Destination: toChainID,
		Type:        SyncFromMap,
		Payload:     payloads,
		DoneCh:      ch,
	}
}

func NewSwapWithMapProof(fromChainID, toChainID ChainId, payloads []interface{}, ch chan<- struct{}) Message {
	return Message{
		Source:      fromChainID,
		Destination: toChainID,
		Type:        SwapWithMapProof,
		Payload:     payloads,
		DoneCh:      ch,
	}
}

func NewSwapWithMerlin(fromChainID, toChainID ChainId, payloads []interface{}, ch chan<- struct{}) Message {
	return Message{
		Source:      fromChainID,
		Destination: toChainID,
		Type:        SwapWithMerlin,
		Payload:     payloads,
		DoneCh:      ch,
	}
}

'''
'''--- near-lake-s3/Cargo.toml ---
[package]
name = "near-lake-s3"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
futures = "0.3.5"
#tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.36"
tracing-subscriber = "0.3.15"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
dotenv = "0.15.0"
anyhow = "1.0"
once_cell = { version = "^1" }
tokio = { version = "1.19.2", features = ["rt-multi-thread", "macros"] }
redis = {version = "0.21.5", features = ["connection-manager", "tokio-comp"]}
tracing-appender = "0.2.2"

near-lake-framework = "0.7.1"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- near-lake-s3/README.md ---
# near-lake-s3
near-lake-s3 is used to sync the certain blocks from AWS S3 buckets to redis server. The block must contain transactions/receipts related to specified account.

## How to build?

```shell
cargo build --release
```

The binary file "near-lake-s3" will be generated in ./target/release.

## How to Run

### AWS S3 Credentials

In order to be able to get objects from the AWS S3 bucket you need to provide the AWS credentials.

AWS default profile configuration with aws configure looks similar to the following:

`~/.aws/credentials`
```
[default]
aws_access_key_id=
aws_secret_access_key=
```

[AWS docs: Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)

### Env Config

You can copy env.example to .env, modify it and put it in the same directory with near-lake-s3 (or it's parent directory).

maybe you can install the [redis](https://redis.io/docs/getting-started/installation/) for the following configuration.

```
// Get the start block height from cache if true, if no record is found, use START_BLOCK_HEIGHT
START_BLOCK_HEIGHT_FROM_CACHE=true
START_BLOCK_HEIGHT=10000

// The URL of the redis
REDIS_URL="redis://127.0.0.1:6379"
// Redis list name where the block will push to
PUB_LIST="blocks"

// The account name to watch
MCS="mcs.testnet"

// True for NEAR tesnet, false for NEAR mainnet
TEST=true

// Log file
LOG_FILE="./near-lake.log"

// Log level
LOG_LEVEL="INFO"
```

### Run
```shell
./target/release/near-lake-s3
```
'''
'''--- near-lake-s3/src/config.rs ---
use near_lake_framework::{LakeConfig, LakeConfigBuilder};
use std::env;
use std::mem::MaybeUninit;
use std::sync::{Mutex, MutexGuard};
use once_cell::sync::Lazy;
use crate::pusher::redis::RedisPusher;

pub const INDEXER: &str = "map-near-indexer-s3";
pub const REDIS: &str = "redis";
pub static PROJECT_CONFIG: Lazy<Env> = Lazy::new(init_env_config);
static mut REDIS_PUSHER: MaybeUninit<Mutex<RedisPusher>> = MaybeUninit::uninit();
static BLOCK_HEIGHT: &str = "block_height";

pub struct Env {
    pub(crate) start_block_height_from_cache: bool,
    pub(crate) start_block_height: u64,
    pub(crate) redis_url: String,
    pub(crate) pub_list: String,
    pub(crate) accounts: Vec<String>,
    pub(crate) parse_tx_hash: bool,
    pub(crate) test: bool,
    pub(crate) log_file: String,
    pub(crate) log_level: String,
}

pub async fn init_lake_config() -> LakeConfig {
    let mut current_height = PROJECT_CONFIG.start_block_height;
    if PROJECT_CONFIG.start_block_height_from_cache {
        if let Some(height) = get_synced_block_height().await {
            current_height = height + 1;
        }
    }

    tracing::info!(target: INDEXER, "start stream from block {}", current_height);
    if PROJECT_CONFIG.test {
        LakeConfigBuilder::default()
            .testnet()
            .start_block_height(current_height)
            .build()
            .expect("failed to start block height")
    } else {
        LakeConfigBuilder::default()
            .mainnet()
            .start_block_height(current_height)
            .build()
            .expect("failed to start block height")
    }
}

pub fn init_env_config() -> Env {
    for (key, value) in env::vars() {
        println!("{}: {}", key, value);
    }
    let env = Env {
        start_block_height_from_cache: env::var("START_BLOCK_HEIGHT_FROM_CACHE")
            .unwrap()
            .parse::<bool>()
            .unwrap(),
        start_block_height: env::var("START_BLOCK_HEIGHT")
            .unwrap()
            .parse::<u64>()
            .unwrap(),
        redis_url: env::var("REDIS_URL").unwrap(),
        pub_list: env::var("PUB_LIST").unwrap(),
        accounts: env::var("ACCOUNTS")
            .unwrap()
            .split(",")
            .into_iter()
            .map(|s| s.trim().to_string())
            .collect(),
        parse_tx_hash: env::var("PARSE_TX_HASH")
            .unwrap_or_else(|_| "false".to_string())
            .parse::<bool>()
            .unwrap(),
        test: env::var("TEST")
            .unwrap_or_else(|_| "true".to_string())
            .parse::<bool>()
            .unwrap(),
        log_file: env::var("LOG_FILE").unwrap(),
        log_level: env::var("LOG_LEVEL")
            .unwrap_or_else(|_| "info".to_string())
    };

    println!("test: {:?}", env.test);
    println!("log_level: {:?}", env.log_level);
    println!("parse_tx_hash: {:?}", env.parse_tx_hash);

    env
}

pub async fn init_redis_pusher() {
    // Make it
    let pusher = RedisPusher::new(&PROJECT_CONFIG.redis_url, &PROJECT_CONFIG.pub_list)
        .await.expect("New redis pusher fail");
    // Store it to the static var, i.e. initialize it
    unsafe {
        REDIS_PUSHER.write(Mutex::new(pusher));
    }
}

pub fn redis_publisher() -> MutexGuard<'static, RedisPusher> {
    unsafe {

        // Now we give out a shared reference to the data, which is safe to use
        // concurrently.
        REDIS_PUSHER.assume_init_ref().lock().unwrap()
    }
}

pub async fn get_synced_block_height() -> Option<u64> {
    let value = redis_publisher().get(BLOCK_HEIGHT).await;
    if value.is_some() {
        let height: u64 = serde_json::from_str(value.unwrap().as_str()).unwrap();
        Some(height)
    } else {
        None
    }
}

pub async fn update_synced_block_height(height: u64) {
    redis_publisher().set(BLOCK_HEIGHT, serde_json::to_string(&height).unwrap()).await;
}

'''
'''--- near-lake-s3/src/indexer/mod.rs ---
pub mod stream;

'''
'''--- near-lake-s3/src/indexer/stream.rs ---
use std::collections::HashMap;
use std::process::id;
use crate::config::{init_lake_config, PROJECT_CONFIG, update_synced_block_height, redis_publisher, INDEXER, REDIS};
use futures::StreamExt;
use serde_json::json;
use near_lake_framework::near_indexer_primitives::views::{ExecutionOutcomeWithIdView, ExecutionStatusView};

pub async fn indexer_stream_from_s3() {
    let config = init_lake_config().await;

    let (_, stream) = near_lake_framework::streamer(config);

    let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
        .map(handle_streamer_message)
        .buffer_unordered(1usize);

    while let Some(_handle_message) = handlers.next().await {}
}

pub async fn handle_streamer_message(
    streamer_message: near_lake_framework::near_indexer_primitives::StreamerMessage,
) {
    tracing::info!("Block height {}", streamer_message.block.header.height);

    let mut publish = false;
    let mut receipt_id2tx_id: HashMap<String, String> = HashMap::new();

    'outer: for shard in &streamer_message.shards {
        for tx_res in &shard.receipt_execution_outcomes {
            if is_valid_receipt(&tx_res.execution_outcome) {
                publish = true;

                let tx_id_opt = redis_publisher().get(tx_res.execution_outcome.id.to_string().as_str()).await;
                if let Some(tx_id) = tx_id_opt {
                    for receipt_id in &tx_res.execution_outcome.outcome.receipt_ids {
                        receipt_id2tx_id.insert(receipt_id.to_string(), tx_id.clone());
                    }
                }
            }
        }
    }

    for shard in &streamer_message.shards {
        if let Some(chunk) = &shard.chunk {
            for tx in &chunk.transactions {
                if PROJECT_CONFIG.accounts.contains(&tx.transaction.receiver_id.to_string()) {
                    if let ExecutionStatusView::SuccessReceiptId(successReceiptId) = tx.outcome.execution_outcome.outcome.status {
                        receipt_id2tx_id.insert(successReceiptId.to_string(), tx.transaction.hash.to_string());
                    }
                }
            }
        }
    }

    for (receipt_id, tx_id) in receipt_id2tx_id {
        redis_publisher().set(receipt_id.clone().as_str(), tx_id.clone()).await;
        tracing::info!(
            target: INDEXER,
            "Save Receipt ID {} / TX ID {} on block {}",
            receipt_id,
            tx_id,
            streamer_message.block.header.height
            );
    }

    if publish {
        let json = json!(streamer_message).to_string();
        redis_publisher().lpush(json).await;
        update_synced_block_height(streamer_message.block.header.height).await;

        tracing::info!(
            target: INDEXER,
            "Save {} / shards {}",
            streamer_message.block.header.height,
            streamer_message.shards.len()
        );
    } else {
        if streamer_message.block.header.height % 100 == 0 {
            update_synced_block_height(streamer_message.block.header.height).await;
            tracing::info!(
                target: REDIS,
                "Update synced block height {}",
                streamer_message.block.header.height
            )
        }
    }
}

pub fn is_valid_receipt(execution_outcome: &ExecutionOutcomeWithIdView) -> bool {
    match &execution_outcome.outcome.status {
        ExecutionStatusView::Unknown => return false,
        _ => ()
    }

    PROJECT_CONFIG.accounts.contains(&execution_outcome.outcome.executor_id.to_string())
}

'''
'''--- near-lake-s3/src/main.rs ---
use std::path::PathBuf;
use std::str::FromStr;
use anyhow::Result;
use dotenv::dotenv;
use tracing::Level;
use tracing_appender::rolling::RollingFileAppender;
use crate::config::{init_redis_pusher, PROJECT_CONFIG};
use crate::indexer::stream::indexer_stream_from_s3;

pub mod indexer;
pub mod pusher;
pub mod config;

#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    dotenv().ok();

    let path = PathBuf::from_str(&PROJECT_CONFIG.log_file).unwrap();
    let file_appender : RollingFileAppender  = tracing_appender::rolling::daily(path.parent().unwrap(), path.file_name().unwrap());
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    tracing_subscriber::fmt()
        .with_ansi(false)
        .with_max_level(Level::from_str(&PROJECT_CONFIG.log_level).unwrap())
        .with_writer(non_blocking.clone())
        .init();
    tracing::info!(".tracing is initialized");

    init_redis_pusher().await;
    tracing::info!(".redis pusher is initialized");

    indexer_stream_from_s3().await;

    Ok(())
}
'''
'''--- near-lake-s3/src/pusher/mod.rs ---
pub mod redis;

'''
'''--- near-lake-s3/src/pusher/redis.rs ---
use std::thread::sleep;
use anyhow::Result;
use std::time::Duration;
use redis::{Client, AsyncCommands};
use redis::aio::ConnectionManager;

pub struct RedisPusher {
    pub(crate) url: String,
    pub(crate) list_key: String,
    pub(crate) conn: ConnectionManager,
}

impl RedisPusher {
    pub async fn new(url: &String, list_key: &String) -> Result<Self> {
        let client = Client::open(url.clone())?;

        Ok(Self {
            url: url.clone(),
            list_key: list_key.clone(),
            conn: client.get_tokio_connection_manager().await?
        })
    }

    pub async fn lpush(&mut self, msg: String) {
        loop {
            let result = self.conn.lpush::<&str, &String, i32>(&self.list_key, &msg).await;
            if result.is_ok() {
                break;
            } else {
                tracing::warn!("push msg {} to list {} failed with error {}, retry...", msg, &self.list_key, result.err().unwrap());
                sleep(Duration::from_secs(3))
            }
        }
    }

    pub async fn set(&mut self, key: &str, value: String) {
        loop {
            let result = self.conn.set::<&str, &String, String>(key, &value).await;
            if result.is_ok() {
                break;
            } else {
                tracing::warn!("set key {} to value {} failed with error {}, retry...", key, value, result.err().unwrap());
                sleep(Duration::from_secs(3))
            }
        }
    }

    pub async fn get(&mut self, key: &str) -> Option<String> {
        loop {
            let result = self.conn.get::<&str, String>(key).await;
            if result.is_ok() {
                return Some(result.unwrap());
            } else {
                if let Ok(ret)  = self.conn.exists::<&str, i32>(key).await {
                    tracing::info!(" check if key {} exists: {}...", key, ret);
                    if ret == 0 {
                        return None;
                    }
                }
                tracing::warn!("get value of key {} failed with error {}, retry...", key, result.err().unwrap());
                sleep(Duration::from_secs(3))
            }
        }
    }
}
'''
'''--- pkg/abi/abi.go ---
package abi

import (
	"github.com/ethereum/go-ethereum/accounts/abi"
	"strings"
)

type Abi struct {
	bridgeAbi abi.ABI
}

func New(abiStr string) (*Abi, error) {
	a, err := abi.JSON(strings.NewReader(abiStr))
	if err != nil {
		return nil, err
	}

	return &Abi{bridgeAbi: a}, nil
}

func (a *Abi) PackInput(abiMethod string, params ...interface{}) ([]byte, error) {
	input, err := a.bridgeAbi.Pack(abiMethod, params...)
	if err != nil {
		return nil, err
	}
	return input, nil
}

func (a *Abi) UnpackValues(method string, data []byte) ([]interface{}, error) {
	return a.bridgeAbi.Events[method].Inputs.UnpackValues(data)
}

func (a *Abi) UnpackOutput(method string, ret interface{}, output []byte) error {
	outputs := a.bridgeAbi.Methods[method].Outputs
	unpack, err := outputs.Unpack(output)
	if err != nil {
		return err
	}

	if err = outputs.Copy(ret, unpack); err != nil {
		return err
	}
	return nil
}

'''
'''--- pkg/blockstore/blockstore.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package blockstore

import (
	"fmt"
	"io/ioutil"
	"math/big"
	"os"
	"path/filepath"

	"github.com/mapprotocol/compass/mapprotocol"
	"github.com/mapprotocol/compass/msg"
)

const PathPostfix = ".compass/blockstore"

type Blockstorer interface {
	StoreBlock(*big.Int) error
}

var _ Blockstorer = &EmptyStore{}
var _ Blockstorer = &Blockstore{}

// Dummy store for testing only
type EmptyStore struct{}

func (s *EmptyStore) StoreBlock(_ *big.Int) error { return nil }

// Blockstore implements Blockstorer.
type Blockstore struct {
	path     string // Path excluding filename
	fullPath string
	chain    msg.ChainId
	relayer  string
}

func NewBlockstore(path string, chain msg.ChainId, relayer string, role mapprotocol.Role) (*Blockstore, error) {
	fileName := getFileName(chain, relayer, role)
	if path == "" {
		def, err := getDefaultPath()
		if err != nil {
			return nil, err
		}
		path = def
	}
	return &Blockstore{
		path:     path,
		fullPath: filepath.Join(path, fileName),
		chain:    chain,
		relayer:  relayer,
	}, nil
}

// StoreBlock writes the block number to disk.
func (b *Blockstore) StoreBlock(block *big.Int) error {
	// Create dir if it does not exist
	if _, err := os.Stat(b.path); os.IsNotExist(err) {
		errr := os.MkdirAll(b.path, os.ModePerm)
		if errr != nil {
			return errr
		}
	}

	// Write bytes to file
	data := []byte(block.String())
	err := ioutil.WriteFile(b.fullPath, data, 0600)
	if err != nil {
		return err
	}
	return nil
}

// TryLoadLatestBlock will attempt to load the latest block for the chain/relayer pair, returning 0 if not found.
// Passing an empty string for path will cause it to use the home directory.
func (b *Blockstore) TryLoadLatestBlock() (*big.Int, error) {
	// If it exists, load and return
	exists, err := fileExists(b.fullPath)
	if err != nil {
		return nil, err
	}
	if exists {
		dat, err := ioutil.ReadFile(b.fullPath)
		if err != nil {
			return nil, err
		}
		block, _ := big.NewInt(0).SetString(string(dat), 10)
		return block, nil
	}
	// Otherwise just return 0
	return big.NewInt(0), nil
}

func getFileName(chain msg.ChainId, relayer string, role mapprotocol.Role) string {
	return fmt.Sprintf("%s-%d-%s.block", relayer, chain, role)
}

// getHomePath returns the home directory joined with PathPostfix
func getDefaultPath() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	return filepath.Join(home, PathPostfix), nil
}

func fileExists(fileName string) (bool, error) {
	_, err := os.Stat(fileName)
	if os.IsNotExist(err) {
		return false, nil
	} else if err != nil {
		return false, err
	}
	return true, nil
}

'''
'''--- pkg/blockstore/blockstore_test.go ---
// Copyright 2021 Compass Systems
// SPDX-License-Identifier: LGPL-3.0-only

package blockstore

import (
	"github.com/mapprotocol/compass/internal/constant"
	"io/ioutil"
	"math/big"
	"os"
	"testing"

	"github.com/mapprotocol/compass/mapprotocol"

	"github.com/mapprotocol/compass/msg"
)

func TestSaveAndLoad(t *testing.T) {
	dir, err := ioutil.TempDir(os.TempDir(), "blockstore")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(dir)

	chain := msg.ChainId(10)

	bs, err := NewBlockstore(dir, chain, constant.ZeroAddress.String(), mapprotocol.RoleOfMaintainer)
	if err != nil {
		t.Fatal(err)
	}
	// Load non-existent dir/file
	block, err := bs.TryLoadLatestBlock()
	if err != nil {
		t.Fatal(err)
	}

	if block.Uint64() != uint64(0) {
		t.Fatalf("Expected: %d got: %d", 0, block.Uint64())
	}

	// Save block number
	block = big.NewInt(999)
	err = bs.StoreBlock(block)
	if err != nil {
		t.Fatal(err)
	}

	// Load block number
	latest, err := bs.TryLoadLatestBlock()
	if err != nil {
		t.Fatal(err)
	}

	if block.Uint64() != latest.Uint64() {
		t.Fatalf("Expected: %d got: %d", block.Uint64(), latest.Uint64())
	}

	// Save block number again
	block = big.NewInt(1234)
	err = bs.StoreBlock(block)
	if err != nil {
		t.Fatal(err)
	}

	// Load block number
	latest, err = bs.TryLoadLatestBlock()
	if err != nil {
		t.Fatal(err)
	}

	if block.Uint64() != latest.Uint64() {
		t.Fatalf("Expected: %d got: %d", block.Uint64(), latest.Uint64())
	}
}

'''
'''--- pkg/contract/constrct.go ---
package contract

import (
	"context"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/compass/internal/constant"
	"github.com/mapprotocol/compass/pkg/abi"
	"github.com/mapprotocol/compass/pkg/ethclient"
)

type Connection interface {
	Client() *ethclient.Client
}

type Call struct {
	abi  *abi.Abi
	toC  []common.Address
	conn Connection
}

func New(conn Connection, addr []common.Address, abi *abi.Abi) *Call {
	return &Call{
		conn: conn,
		toC:  addr,
		abi:  abi,
	}
}

func (c *Call) Call(method string, ret interface{}, idx int, params ...interface{}) error {
	input, err := c.abi.PackInput(method, params...)
	if err != nil {
		return err
	}

	outPut, err := c.conn.Client().CallContract(context.Background(),
		ethereum.CallMsg{
			From: constant.ZeroAddress,
			To:   &c.toC[idx],
			Data: input,
		},
		nil,
	)
	if err != nil {
		return err
	}

	return c.abi.UnpackOutput(method, ret, outPut)
}

'''
'''--- pkg/etcd/client.go ---
package etcd

import (
	"context"
	"time"

	clientv3 "go.etcd.io/etcd/client/v3"
)

var (
	cli *clientv3.Client
)

func Init(endpoint string) error {
	if endpoint == "" {
		return nil
	}
	client, err := clientv3.New(clientv3.Config{
		Endpoints:   []string{endpoint},
		DialTimeout: 5 * time.Second,
	})
	if err != nil {
		return err
	}
	cli = client

	return nil
}

func Put(ctx context.Context, key, value string) error {
	if cli == nil {
		return nil
	}
	_, err := cli.Put(ctx, key, value)
	if err != nil {
		return err
	}
	return nil
}

func Delete(ctx context.Context, key string) error {
	if cli == nil {
		return nil
	}
	_, err := cli.Delete(ctx, key)
	if err != nil {
		return err
	}
	return nil
}

'''
'''--- pkg/ethclient/block.go ---
package ethclient

type Block struct {
	BaseFeePerGas   string `json:"baseFeePerGas"`
	Difficulty      string `json:"difficulty"`
	ExtraData       string `json:"extraData"`
	GasLimit        string `json:"gasLimit"`
	GasUsed         string `json:"gasUsed"`
	Hash            string `json:"hash"`
	L1BlockNumber   string `json:"l1BlockNumber"`
	LogsBloom       string `json:"logsBloom"`
	Miner           string `json:"miner"`
	MixHash         string `json:"mixHash"`
	Nonce           string `json:"nonce"`
	Number          string `json:"number"`
	ParentHash      string `json:"parentHash"`
	ReceiptsRoot    string `json:"receiptsRoot"`
	SendCount       string `json:"sendCount"`
	SendRoot        string `json:"sendRoot"`
	Sha3Uncles      string `json:"sha3Uncles"`
	Size            string `json:"size"`
	StateRoot       string `json:"stateRoot"`
	Timestamp       string `json:"timestamp"`
	TotalDifficulty string `json:"totalDifficulty"`
	Transactions    []struct {
		BlockHash            string        `json:"blockHash"`
		BlockNumber          string        `json:"blockNumber"`
		From                 string        `json:"from"`
		Gas                  string        `json:"gas"`
		GasPrice             string        `json:"gasPrice"`
		Hash                 string        `json:"hash"`
		Input                string        `json:"input"`
		Nonce                string        `json:"nonce"`
		To                   string        `json:"to"`
		TransactionIndex     string        `json:"transactionIndex"`
		Value                string        `json:"value"`
		Type                 string        `json:"type"`
		ChainID              string        `json:"chainId"`
		MaxFeePerGas         string        `json:"maxFeePerGas,omitempty"`
		MaxPriorityFeePerGas string        `json:"maxPriorityFeePerGas,omitempty"`
		AccessList           []interface{} `json:"accessList,omitempty"`
		YParity              string        `json:"yParity,omitempty"`
	} `json:"transactions"`
	TransactionsRoot string        `json:"transactionsRoot"`
	Uncles           []interface{} `json:"uncles"`
}

'''
'''--- pkg/ethclient/ethclient.go ---
package ethclient

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mapprotocol/compass/pkg/platon"
	"math/big"
	"net/http"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rpc"
)

// Client defines typed wrappers for the Ethereum RPC API.
type Client struct {
	c   *rpc.Client
	url string
}

// Dial connects a client to the given URL.
func Dial(rawurl string) (*Client, error) {
	return DialContext(context.Background(), rawurl)
}

func DialContext(ctx context.Context, rawurl string) (*Client, error) {
	c, err := rpc.DialContext(ctx, rawurl)
	if err != nil {
		return nil, err
	}
	return NewClient(c, rawurl), nil
}

// NewClient creates a client that uses the given RPC client.
func NewClient(c *rpc.Client, url string) *Client {
	return &Client{c, url}
}

func (ec *Client) Close() {
	ec.c.Close()
}

// Blockchain Access

// ChainId retrieves the current chain ID for transaction replay protection.
func (ec *Client) ChainID(ctx context.Context) (*big.Int, error) {
	var result hexutil.Big
	err := ec.c.CallContext(ctx, &result, "eth_chainId")
	if err != nil {
		return nil, err
	}
	return (*big.Int)(&result), err
}

// BlockByHash returns the given full block.
//
// Note that loading full blocks requires two requests. Use HeaderByHash
// if you don't need all transactions or uncle headers.
func (ec *Client) BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error) {
	return ec.getBlock(ctx, "eth_getBlockByHash", hash, true)
}

// BlockByNumber returns a block from the current canonical chain. If number is nil, the
// latest known block is returned.
//
// Note that loading full blocks requires two requests. Use HeaderByNumber
// if you don't need all transactions or uncle headers.
func (ec *Client) BlockByNumber(ctx context.Context, number *big.Int) (*types.Block, error) {
	return ec.getBlock(ctx, "eth_getBlockByNumber", toBlockNumArg(number), true)
}

// BlockNumber returns the most recent block number
func (ec *Client) BlockNumber(ctx context.Context) (uint64, error) {
	var result hexutil.Uint64
	err := ec.c.CallContext(ctx, &result, "eth_blockNumber")
	return uint64(result), err
}

type rpcBlock struct {
	Hash         common.Hash      `json:"hash"`
	Transactions []rpcTransaction `json:"transactions"`
	UncleHashes  []common.Hash    `json:"uncles"`
}

func (ec *Client) getBlock(ctx context.Context, method string, args ...interface{}) (*types.Block, error) {
	var raw json.RawMessage
	err := ec.c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}
	// Decode header and transactions.
	var head *types.Header
	var body rpcBlock
	if err := json.Unmarshal(raw, &head); err != nil {
		return nil, err
	}
	if err := json.Unmarshal(raw, &body); err != nil {
		return nil, err
	}
	// Quick-verify transaction and uncle lists. This mostly helps with debugging the server.
	if head.UncleHash == types.EmptyUncleHash && len(body.UncleHashes) > 0 {
		return nil, fmt.Errorf("server returned non-empty uncle list but block header indicates no uncles")
	}
	if head.UncleHash != types.EmptyUncleHash && len(body.UncleHashes) == 0 {
		return nil, fmt.Errorf("server returned empty uncle list but block header indicates uncles")
	}
	if head.TxHash == types.EmptyRootHash && len(body.Transactions) > 0 {
		return nil, fmt.Errorf("server returned non-empty transaction list but block header indicates no transactions")
	}
	if head.TxHash != types.EmptyRootHash && len(body.Transactions) == 0 {
		return nil, fmt.Errorf("server returned empty transaction list but block header indicates transactions")
	}
	// Load uncles because they are not included in the block response.
	var uncles []*types.Header
	if len(body.UncleHashes) > 0 {
		uncles = make([]*types.Header, len(body.UncleHashes))
		reqs := make([]rpc.BatchElem, len(body.UncleHashes))
		for i := range reqs {
			reqs[i] = rpc.BatchElem{
				Method: "eth_getUncleByBlockHashAndIndex",
				Args:   []interface{}{body.Hash, hexutil.EncodeUint64(uint64(i))},
				Result: &uncles[i],
			}
		}
		if err := ec.c.BatchCallContext(ctx, reqs); err != nil {
			return nil, err
		}
		for i := range reqs {
			if reqs[i].Error != nil {
				return nil, reqs[i].Error
			}
			if uncles[i] == nil {
				return nil, fmt.Errorf("got null header for uncle %d of block %x", i, body.Hash[:])
			}
		}
	}
	// Fill the sender cache of transactions in the block.
	txs := make([]*types.Transaction, len(body.Transactions))
	for i, tx := range body.Transactions {
		if tx.From != nil {
			setSenderFromServer(tx.tx, *tx.From, body.Hash)
		}
		txs[i] = tx.tx
	}
	return types.NewBlockWithHeader(head).WithBody(txs, uncles), nil
}

// HeaderByHash returns the block header with the given hash.
func (ec *Client) HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error) {
	var head *types.Header
	err := ec.c.CallContext(ctx, &head, "eth_getBlockByHash", hash, false)
	if err == nil && head == nil {
		err = ethereum.NotFound
	}
	return head, err
}

// HeaderByNumber returns a block header from the current canonical chain. If number is
// nil, the latest known header is returned.
func (ec *Client) HeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error) {
	var head *types.Header
	err := ec.c.CallContext(ctx, &head, "eth_getBlockByNumber", toBlockNumArg(number), false)
	if err == nil && head == nil {
		err = ethereum.NotFound
	}
	return head, err
}

type rpcTransaction struct {
	tx *types.Transaction
	txExtraInfo
}

type txExtraInfo struct {
	BlockNumber *string         `json:"blockNumber,omitempty"`
	BlockHash   *common.Hash    `json:"blockHash,omitempty"`
	From        *common.Address `json:"from,omitempty"`
}

func (tx *rpcTransaction) UnmarshalJSON(msg []byte) error {
	if err := json.Unmarshal(msg, &tx.tx); err != nil {
		return err
	}
	return json.Unmarshal(msg, &tx.txExtraInfo)
}

// TransactionByHash returns the transaction with the given hash.
func (ec *Client) TransactionByHash(ctx context.Context, hash common.Hash) (tx *types.Transaction, isPending bool, err error) {
	var json *rpcTransaction
	err = ec.c.CallContext(ctx, &json, "eth_getTransactionByHash", hash)
	if err != nil {
		return nil, false, err
	} else if json == nil {
		return nil, false, ethereum.NotFound
	} else if _, r, _ := json.tx.RawSignatureValues(); r == nil {
		return nil, false, fmt.Errorf("server returned transaction without signature")
	}
	if json.From != nil && json.BlockHash != nil {
		setSenderFromServer(json.tx, *json.From, *json.BlockHash)
	}
	return json.tx, json.BlockNumber == nil, nil
}

// TransactionSender returns the sender address of the given transaction. The transaction
// must be known to the remote node and included in the blockchain at the given block and
// index. The sender is the one derived by the protocol at the time of inclusion.
//
// There is a fast-path for transactions retrieved by TransactionByHash and
// TransactionInBlock. Getting their sender address can be done without an RPC interaction.
func (ec *Client) TransactionSender(ctx context.Context, tx *types.Transaction, block common.Hash, index uint) (common.Address, error) {
	// Try to load the address from the cache.
	sender, err := types.Sender(&senderFromServer{blockhash: block}, tx)
	if err == nil {
		return sender, nil
	}
	var meta struct {
		Hash common.Hash
		From common.Address
	}
	if err = ec.c.CallContext(ctx, &meta, "eth_getTransactionByBlockHashAndIndex", block, hexutil.Uint64(index)); err != nil {
		return common.Address{}, err
	}
	if meta.Hash == (common.Hash{}) || meta.Hash != tx.Hash() {
		return common.Address{}, errors.New("wrong inclusion block/index")
	}
	return meta.From, nil
}

// TransactionCount returns the total number of transactions in the given block.
func (ec *Client) TransactionCount(ctx context.Context, blockHash common.Hash) (uint, error) {
	var num hexutil.Uint
	err := ec.c.CallContext(ctx, &num, "eth_getBlockTransactionCountByHash", blockHash)
	return uint(num), err
}

// TransactionInBlock returns a single transaction at index in the given block.
func (ec *Client) TransactionInBlock(ctx context.Context, blockHash common.Hash, index uint) (*types.Transaction, error) {
	var json *rpcTransaction
	err := ec.c.CallContext(ctx, &json, "eth_getTransactionByBlockHashAndIndex", blockHash, hexutil.Uint64(index))
	if err != nil {
		return nil, err
	}
	if json == nil {
		return nil, ethereum.NotFound
	} else if _, r, _ := json.tx.RawSignatureValues(); r == nil {
		return nil, fmt.Errorf("server returned transaction without signature")
	}
	if json.From != nil && json.BlockHash != nil {
		setSenderFromServer(json.tx, *json.From, *json.BlockHash)
	}
	return json.tx, err
}

// TransactionReceipt returns the receipt of a transaction by transaction hash.
// Note that the receipt is not available for pending transactions.
func (ec *Client) TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
	var r *types.Receipt
	err := ec.c.CallContext(ctx, &r, "eth_getTransactionReceipt", txHash)
	if err == nil {
		if r == nil {
			return nil, ethereum.NotFound
		}
	}
	return r, err
}

type rpcProgress struct {
	StartingBlock hexutil.Uint64
	CurrentBlock  hexutil.Uint64
	HighestBlock  hexutil.Uint64
	PulledStates  hexutil.Uint64
	KnownStates   hexutil.Uint64
}

// SyncProgress retrieves the current progress of the sync algorithm. If there's
// no sync currently running, it returns nil.
func (ec *Client) SyncProgress(ctx context.Context) (*ethereum.SyncProgress, error) {
	var raw json.RawMessage
	if err := ec.c.CallContext(ctx, &raw, "eth_syncing"); err != nil {
		return nil, err
	}
	// Handle the possible response types
	var syncing bool
	if err := json.Unmarshal(raw, &syncing); err == nil {
		return nil, nil // Not syncing (always false)
	}
	var progress *rpcProgress
	if err := json.Unmarshal(raw, &progress); err != nil {
		return nil, err
	}
	return &ethereum.SyncProgress{
		StartingBlock: uint64(progress.StartingBlock),
		CurrentBlock:  uint64(progress.CurrentBlock),
		HighestBlock:  uint64(progress.HighestBlock),
		PulledStates:  uint64(progress.PulledStates),
		KnownStates:   uint64(progress.KnownStates),
	}, nil
}

// SubscribeNewHead subscribes to notifications about the current blockchain head
// on the given channel.
func (ec *Client) SubscribeNewHead(ctx context.Context, ch chan<- *types.Header) (ethereum.Subscription, error) {
	return ec.c.EthSubscribe(ctx, ch, "newHeads")
}

// State Access

// NetworkID returns the network ID (also known as the chain ID) for this chain.
func (ec *Client) NetworkID(ctx context.Context) (*big.Int, error) {
	version := new(big.Int)
	var ver string
	if err := ec.c.CallContext(ctx, &ver, "net_version"); err != nil {
		return nil, err
	}
	if _, ok := version.SetString(ver, 10); !ok {
		return nil, fmt.Errorf("invalid net_version result %q", ver)
	}
	return version, nil
}

// BalanceAt returns the wei balance of the given account.
// The block number can be nil, in which case the balance is taken from the latest known block.
func (ec *Client) BalanceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error) {
	var result hexutil.Big
	err := ec.c.CallContext(ctx, &result, "eth_getBalance", account, toBlockNumArg(blockNumber))
	return (*big.Int)(&result), err
}

// StorageAt returns the value of key in the contract storage of the given account.
// The block number can be nil, in which case the value is taken from the latest known block.
func (ec *Client) StorageAt(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error) {
	var result hexutil.Bytes
	err := ec.c.CallContext(ctx, &result, "eth_getStorageAt", account, key, toBlockNumArg(blockNumber))
	return result, err
}

// CodeAt returns the contract code of the given account.
// The block number can be nil, in which case the code is taken from the latest known block.
func (ec *Client) CodeAt(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error) {
	var result hexutil.Bytes
	err := ec.c.CallContext(ctx, &result, "eth_getCode", account, toBlockNumArg(blockNumber))
	return result, err
}

// NonceAt returns the account nonce of the given account.
// The block number can be nil, in which case the nonce is taken from the latest known block.
func (ec *Client) NonceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (uint64, error) {
	var result hexutil.Uint64
	err := ec.c.CallContext(ctx, &result, "eth_getTransactionCount", account, toBlockNumArg(blockNumber))
	return uint64(result), err
}

// Filters

// FilterLogs executes a filter query.
func (ec *Client) FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
	var result []types.Log
	arg, err := toFilterArg(q)
	if err != nil {
		return nil, err
	}
	err = ec.c.CallContext(ctx, &result, "eth_getLogs", arg)
	return result, err
}

// SubscribeFilterLogs subscribes to the results of a streaming filter query.
func (ec *Client) SubscribeFilterLogs(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) (ethereum.Subscription, error) {
	arg, err := toFilterArg(q)
	if err != nil {
		return nil, err
	}
	return ec.c.EthSubscribe(ctx, ch, "logs", arg)
}

func toFilterArg(q ethereum.FilterQuery) (interface{}, error) {
	arg := map[string]interface{}{
		"address": q.Addresses,
		"topics":  q.Topics,
	}
	if q.BlockHash != nil {
		arg["blockHash"] = *q.BlockHash
		if q.FromBlock != nil || q.ToBlock != nil {
			return nil, fmt.Errorf("cannot specify both BlockHash and FromBlock/ToBlock")
		}
	} else {
		if q.FromBlock == nil {
			arg["fromBlock"] = "0x0"
		} else {
			arg["fromBlock"] = toBlockNumArg(q.FromBlock)
		}
		arg["toBlock"] = toBlockNumArg(q.ToBlock)
	}
	return arg, nil
}

// Pending State

// PendingBalanceAt returns the wei balance of the given account in the pending state.
func (ec *Client) PendingBalanceAt(ctx context.Context, account common.Address) (*big.Int, error) {
	var result hexutil.Big
	err := ec.c.CallContext(ctx, &result, "eth_getBalance", account, "pending")
	return (*big.Int)(&result), err
}

// PendingStorageAt returns the value of key in the contract storage of the given account in the pending state.
func (ec *Client) PendingStorageAt(ctx context.Context, account common.Address, key common.Hash) ([]byte, error) {
	var result hexutil.Bytes
	err := ec.c.CallContext(ctx, &result, "eth_getStorageAt", account, key, "pending")
	return result, err
}

// PendingCodeAt returns the contract code of the given account in the pending state.
func (ec *Client) PendingCodeAt(ctx context.Context, account common.Address) ([]byte, error) {
	var result hexutil.Bytes
	err := ec.c.CallContext(ctx, &result, "eth_getCode", account, "pending")
	return result, err
}

// PendingNonceAt returns the account nonce of the given account in the pending state.
// This is the nonce that should be used for the next transaction.
func (ec *Client) PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) {
	var result hexutil.Uint64
	err := ec.c.CallContext(ctx, &result, "eth_getTransactionCount", account, "pending")
	return uint64(result), err
}

// PendingTransactionCount returns the total number of transactions in the pending state.
func (ec *Client) PendingTransactionCount(ctx context.Context) (uint, error) {
	var num hexutil.Uint
	err := ec.c.CallContext(ctx, &num, "eth_getBlockTransactionCountByNumber", "pending")
	return uint(num), err
}

// Contract Calling

// CallContract executes a message call transaction, which is directly executed in the VM
// of the node, but never mined into the blockchain.
//
// blockNumber selects the block height at which the call runs. It can be nil, in which
// case the code is taken from the latest known block. Note that state from very old
// blocks might not be available.
func (ec *Client) CallContract(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error) {
	var hex hexutil.Bytes
	err := ec.c.CallContext(ctx, &hex, "eth_call", toCallArg(msg), toBlockNumArg(blockNumber))
	if err != nil {
		return nil, err
	}
	return hex, nil
}

// PendingCallContract executes a message call transaction using the EVM.
// The state seen by the contract call is the pending state.
func (ec *Client) PendingCallContract(ctx context.Context, msg ethereum.CallMsg) ([]byte, error) {
	var hex hexutil.Bytes
	err := ec.c.CallContext(ctx, &hex, "eth_call", toCallArg(msg), "pending")
	if err != nil {
		return nil, err
	}
	return hex, nil
}

// SuggestGasPrice retrieves the currently suggested gas price to allow a timely
// execution of a transaction.
func (ec *Client) SuggestGasPrice(ctx context.Context) (*big.Int, error) {
	var hex hexutil.Big
	if err := ec.c.CallContext(ctx, &hex, "eth_gasPrice"); err != nil {
		return nil, err
	}
	return (*big.Int)(&hex), nil
}

// SuggestGasTipCap retrieves the currently suggested gas tip cap after 1559 to
// allow a timely execution of a transaction.
func (ec *Client) SuggestGasTipCap(ctx context.Context) (*big.Int, error) {
	var hex hexutil.Big
	if err := ec.c.CallContext(ctx, &hex, "eth_maxPriorityFeePerGas"); err != nil {
		return nil, err
	}
	return (*big.Int)(&hex), nil
}

// EstimateGas tries to estimate the gas needed to execute a specific transaction based on
// the current pending state of the backend blockchain. There is no guarantee that this is
// the true gas limit requirement as other transactions may be added or removed by miners,
// but it should provide a basis for setting a reasonable default.
func (ec *Client) EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error) {
	var hex hexutil.Uint64
	err := ec.c.CallContext(ctx, &hex, "eth_estimateGas", toCallArg(msg))
	if err != nil {
		return 0, err
	}
	return uint64(hex), nil
}

// SendTransaction injects a signed transaction into the pending pool for execution.
//
// If the transaction was a contract creation use the TransactionReceipt method to get the
// contract address after the transaction has been mined.
func (ec *Client) SendTransaction(ctx context.Context, tx *types.Transaction) error {
	data, err := tx.MarshalBinary()
	if err != nil {
		return err
	}
	return ec.c.CallContext(ctx, nil, "eth_sendRawTransaction", hexutil.Encode(data))
}

func toBlockNumArg(number *big.Int) string {
	if number == nil {
		return "latest"
	}
	pending := big.NewInt(-1)
	if number.Cmp(pending) == 0 {
		return "pending"
	}
	return hexutil.EncodeBig(number)
}

func toCallArg(msg ethereum.CallMsg) interface{} {
	arg := map[string]interface{}{
		"from": msg.From,
		"to":   msg.To,
	}
	if len(msg.Data) > 0 {
		arg["data"] = hexutil.Bytes(msg.Data)
	}
	if msg.Value != nil {
		arg["value"] = (*hexutil.Big)(msg.Value)
	}
	if msg.Gas != 0 {
		arg["gas"] = hexutil.Uint64(msg.Gas)
	}
	if msg.GasPrice != nil {
		arg["gasPrice"] = (*hexutil.Big)(msg.GasPrice)
	}
	return arg
}

// platon

func (ec *Client) PlatonGetValidatorByNumber(ctx context.Context, number *big.Int) ([]Validator, error) {
	var resp string
	err := ec.c.CallContext(ctx, &resp, "debug_getValidatorByBlockNumber", number)
	if err == nil && resp == "" {
		err = ethereum.NotFound
	}
	var ret []Validator
	err = json.Unmarshal([]byte(resp), &ret)
	if err != nil {
		return nil, err
	}
	return ret, err
}

func (ec *Client) PlatonGetBlockQuorumCertByHash(ctx context.Context, hash []common.Hash) ([]QuorumCert, error) {
	var ret []QuorumCert
	err := ec.c.CallContext(ctx, &ret, "platon_getBlockQuorumCertByHash", hash)
	if err == nil && ret == nil {
		err = ethereum.NotFound
	}
	return ret, err
}

type Validator struct {
	Address   string
	NodeId    string
	BlsPubKey string
}

type QuorumCert struct {
	Epoch        int64  `json:"epoch"`
	ViewNumber   int64  `json:"viewNumber"`
	BlockHash    string `json:"blockHash"`
	BlockIndex   int64  `json:"blockIndex"`
	BlockNumber  int64  `json:"blockNumber"`
	Signature    string `json:"signature"`
	ValidatorSet string `json:"validatorSet"`
}

type Header struct {
	types.Header
	WithdrawalsHash string `json:"withdrawalsRoot" rlp:"optional"`
}

type jsonrpcMessage struct {
	Version string          `json:"jsonrpc,omitempty"`
	ID      json.RawMessage `json:"id,omitempty"`
	Method  string          `json:"method,omitempty"`
	Params  json.RawMessage `json:"params,omitempty"`
	Result  json.RawMessage `json:"result,omitempty"`
}

// EthLatestHeaderByNumber returns a block header from the current canonical chain. If number is
// nil, the latest known header is returned.
func (ec *Client) EthLatestHeaderByNumber(endpoint string, number *big.Int) (*Header, error) {
	s := fmt.Sprintf("{\"jsonrpc\": \"2.0\",\"method\": \"eth_getBlockByNumber\",\"params\": [\"%s\",true],\"id\": 1\n}", toBlockNumArg(number))
	body := strings.NewReader(s)
	resp, err := http.Post(endpoint, "application/json", body)
	if err != nil {
		return nil, err
	}

	var respmsg jsonrpcMessage
	if err := json.NewDecoder(resp.Body).Decode(&respmsg); err != nil {
		return nil, err
	}

	data := make([]byte, 0, len(respmsg.Result))
	for _, res := range respmsg.Result {
		data = append(data, res)
	}
	var head Header
	err = json.Unmarshal(data, &head)
	if err != nil {
		return nil, err
	}

	type Tmp struct {
		WithdrawalsHash string `json:"withdrawalsRoot" rlp:"optional"`
	}
	var tmp Tmp
	err = json.Unmarshal(data, &tmp)
	if err != nil {
		return nil, err
	}

	head.WithdrawalsHash = tmp.WithdrawalsHash
	return &head, err
}

func (ec *Client) PlatonGetBlockByNumber(ctx context.Context, number *big.Int) (*platon.Header, error) {
	var head *platon.Header
	err := ec.c.CallContext(ctx, &head, "eth_getBlockByNumber", toBlockNumArg(number), false)
	if err == nil && head == nil {
		err = ethereum.NotFound
	}
	return head, err
}

type OpReceipt struct {
	DepositNonce          string `json:"depositNonce,omitempty"`
	DepositReceiptVersion string `json:"depositReceiptVersion,omitempty"`
}

func (ec *Client) OpReceipt(ctx context.Context, txHash common.Hash) (*OpReceipt, error) {
	s := fmt.Sprintf("{\"jsonrpc\": \"2.0\",\"method\": \"eth_getTransactionReceipt\",\"params\": [\"%s\"],\"id\": 1\n}", txHash.Hex())
	body := strings.NewReader(s)
	resp, err := http.Post(ec.url, "application/json", body)
	if err != nil {
		return nil, err
	}

	var respmsg jsonrpcMessage
	if err := json.NewDecoder(resp.Body).Decode(&respmsg); err != nil {
		return nil, err
	}

	data := make([]byte, 0, len(respmsg.Result))
	for _, res := range respmsg.Result {
		data = append(data, res)
	}
	var ret *OpReceipt
	err = json.Unmarshal(data, &ret)
	if err != nil {
		return nil, err
	}

	return ret, err
}

'''
'''--- pkg/ethclient/map_signer.go ---
// Copyright 2017 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package ethclient

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/atlas/core/types"
)

// mapSenderFromServer is a types.Signer that remembers the sender address returned by the RPC
// server. It is stored in the transaction's sender address cache to avoid an additional
// request in TransactionSender.
type mapSenderFromServer struct {
	addr      common.Address
	blockhash common.Hash
}

func setMAPSenderFromServer(tx *types.Transaction, addr common.Address, block common.Hash) {
	// Use types.Sender for side-effect to store our signer into the cache.
	types.Sender(&mapSenderFromServer{addr, block}, tx)
}

func (s *mapSenderFromServer) Equal(other types.Signer) bool {
	os, ok := other.(*mapSenderFromServer)
	return ok && os.blockhash == s.blockhash
}

func (s *mapSenderFromServer) Sender(tx *types.Transaction) (common.Address, error) {
	if s.blockhash == (common.Hash{}) {
		return common.Address{}, errNotCached
	}
	return s.addr, nil
}

func (s *mapSenderFromServer) ChainID() *big.Int {
	panic("can't sign with senderFromServer")
}
func (s *mapSenderFromServer) Hash(tx *types.Transaction) common.Hash {
	panic("can't sign with senderFromServer")
}
func (s *mapSenderFromServer) SignatureValues(tx *types.Transaction, sig []byte) (R, S, V *big.Int, err error) {
	panic("can't sign with senderFromServer")
}

'''
'''--- pkg/ethclient/mapclient.go ---
package ethclient

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/mapprotocol/atlas/helper/bls"
	"math/big"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/mapprotocol/atlas/consensus/istanbul/backend"
	"github.com/mapprotocol/atlas/core/types"
)

type rpcMAPBlock struct {
	Hash           common.Hash         `json:"hash"`
	Transactions   []rpcMAPTransaction `json:"transactions"`
	Randomness     *types.Randomness   `json:"randomness"`
	EpochSnarkData *EpochSnarkData     `json:"epochSnarkData"`
}

type EpochSnarkData struct {
	Bitmap    string
	Signature string
}

type rpcMAPTransaction struct {
	tx *types.Transaction
	txExtraInfo
}

func (tx *rpcMAPTransaction) UnmarshalJSON(msg []byte) error {
	if err := json.Unmarshal(msg, &tx.tx); err != nil {
		return err
	}
	return json.Unmarshal(msg, &tx.txExtraInfo)
}

func (ec *Client) getMAPBlock(ctx context.Context, method string, args ...interface{}) (*Block, error) {
	var raw json.RawMessage
	err := ec.c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}
	// Decode header and transactions.
	var head *types.Header
	var body Block
	if err := json.Unmarshal(raw, &head); err != nil {
		return nil, err
	}
	if err := json.Unmarshal(raw, &body); err != nil {
		return nil, err
	}
	if head.TxHash == types.EmptyRootHash && len(body.Transactions) > 0 {
		return nil, fmt.Errorf("server returned non-empty transaction list but block header indicates no transactions")
	}
	if head.TxHash != types.EmptyRootHash && len(body.Transactions) == 0 {
		return nil, fmt.Errorf("server returned empty transaction list but block header indicates transactions")
	}
	return &body, nil
}

func (ec *Client) getTronBlock(ctx context.Context, method string, args ...interface{}) (*Block, error) {
	var raw json.RawMessage
	err := ec.c.CallContext(ctx, &raw, method, args...)
	if err != nil {
		return nil, err
	} else if len(raw) == 0 {
		return nil, ethereum.NotFound
	}
	// Decode header and transactions.
	var body Block
	if err := json.Unmarshal(raw, &body); err != nil {
		return nil, err
	}
	if common.HexToHash(body.TransactionsRoot) == types.EmptyRootHash && len(body.Transactions) > 0 {
		return nil, fmt.Errorf("server returned non-empty transaction list but block header indicates no transactions")
	}
	if common.HexToHash(body.TransactionsRoot) != types.EmptyRootHash && len(body.Transactions) == 0 {
		return nil, fmt.Errorf("server returned empty transaction list but block header indicates transactions")
	}
	return &body, nil
}

// MAPBlockByHash returns the given full block.
//
// Note that loading full blocks requires two requests. Use HeaderByHash
// if you don't need all transactions or uncle headers.
func (ec *Client) MAPBlockByHash(ctx context.Context, hash common.Hash) (*Block, error) {
	return ec.getMAPBlock(ctx, "eth_getBlockByHash", hash, true)
}

// MAPBlockByNumber returns a block from the current canonical chain. If number is nil, the
// latest known block is returned.
//
// Note that loading full blocks requires two requests. Use HeaderByNumber
// if you don't need all transactions or uncle headers.
func (ec *Client) MAPBlockByNumber(ctx context.Context, number *big.Int) (*Block, error) {
	return ec.getMAPBlock(ctx, "eth_getBlockByNumber", toBlockNumArg(number), true)
}

func (ec *Client) TronBlockByNumber(ctx context.Context, number *big.Int) (*Block, error) {
	return ec.getTronBlock(ctx, "eth_getBlockByNumber", toBlockNumArg(number), true)
}

// MAPHeaderByNumber returns a block header from the current canonical chain. If number is
// nil, the latest known header is returned.
func (ec *Client) MAPHeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error) {
	var head *types.Header
	err := ec.c.CallContext(ctx, &head, "eth_getBlockByNumber", toBlockNumArg(number), false)
	if err == nil && head == nil {
		err = ethereum.NotFound
	}
	return head, err
}

func (ec *Client) GetSnapshot(ctx context.Context, number *big.Int) (*backend.Snapshot, error) {
	var snap *backend.Snapshot
	err := ec.c.CallContext(ctx, &snap, "istanbul_getSnapshot", toBlockNumArg(number))
	if err != nil {
		return nil, err
	}
	return snap, err
}

func (ec *Client) GetValidatorsBLSPublicKeys(ctx context.Context, number *big.Int) ([]bls.SerializedPublicKey, error) {
	var snap []bls.SerializedPublicKey
	err := ec.c.CallContext(ctx, &snap, "istanbul_getValidatorsBLSPublicKeys", toBlockNumArg(number))
	if err != nil {
		return nil, err
	}
	return snap, err
}

'''
'''--- pkg/ethclient/signer.go ---
// Copyright 2017 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package ethclient

import (
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

// senderFromServer is a types.Signer that remembers the sender address returned by the RPC
// server. It is stored in the transaction's sender address cache to avoid an additional
// request in TransactionSender.
type senderFromServer struct {
	addr      common.Address
	blockhash common.Hash
}

var errNotCached = errors.New("sender not cached")

func setSenderFromServer(tx *types.Transaction, addr common.Address, block common.Hash) {
	// Use types.Sender for side-effect to store our signer into the cache.
	types.Sender(&senderFromServer{addr, block}, tx)
}

func (s *senderFromServer) Equal(other types.Signer) bool {
	os, ok := other.(*senderFromServer)
	return ok && os.blockhash == s.blockhash
}

func (s *senderFromServer) Sender(tx *types.Transaction) (common.Address, error) {
	if s.blockhash == (common.Hash{}) {
		return common.Address{}, errNotCached
	}
	return s.addr, nil
}

func (s *senderFromServer) ChainID() *big.Int {
	panic("can't sign with senderFromServer")
}
func (s *senderFromServer) Hash(tx *types.Transaction) common.Hash {
	panic("can't sign with senderFromServer")
}
func (s *senderFromServer) SignatureValues(tx *types.Transaction, sig []byte) (R, S, V *big.Int, err error) {
	panic("can't sign with senderFromServer")
}

'''
'''--- pkg/platon/block.go ---
package platon

import (
	"encoding/binary"
	"encoding/json"
	"errors"
	"math/big"
	"sync"
	"sync/atomic"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rlp"
	"golang.org/x/crypto/sha3"
)

// BlockNonce is an 81-byte vrf proof containing random numbers
// Used to verify the block when receiving the block
type BlockNonce [81]byte

// EncodeNonce converts the given byte to a block nonce.
func EncodeNonce(v []byte) BlockNonce {
	var n BlockNonce
	copy(n[:], v)
	return n
}

func (n BlockNonce) Bytes() []byte {
	return n[:]
}

// MarshalText encodes n as a hex string with 0x prefix.
func (n BlockNonce) MarshalText() ([]byte, error) {
	return hexutil.Bytes(n[:]).MarshalText()
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (n *BlockNonce) UnmarshalText(input []byte) error {
	return hexutil.UnmarshalFixedText("BlockNonce", input, n[:])
}

func (n *BlockNonce) ETHBlockNonce() ETHBlockNonce {
	var a ETHBlockNonce
	for i := 0; i < len(a); i++ {
		a[i] = n[i]
	}
	return a
}

// A ETHBlockNonce is a 64-bit hash which proves (combined with the
// mix-hash) that a sufficient amount of computation has been carried
// out on a block.
type ETHBlockNonce [8]byte

// EncodeETHNonce converts the given integer to a block nonce.
func EncodeETHNonce(i uint64) ETHBlockNonce {
	var n ETHBlockNonce
	binary.BigEndian.PutUint64(n[:], i)
	return n
}

// Header represents a block header in the Ethereum blockchain.
type Header struct {
	ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
	Coinbase    common.Address `json:"miner"            gencodec:"required"`
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
	Number      *big.Int       `json:"number"           gencodec:"required"`
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
	Time        uint64         `json:"timestamp"        gencodec:"required"`
	Extra       []byte         `json:"extraData"        gencodec:"required"`
	Nonce       BlockNonce     `json:"nonce"            gencodec:"required"`
	// caches
	sealHash  atomic.Value `json:"-" rlp:"-"`
	hash      atomic.Value `json:"-" rlp:"-"`
	publicKey atomic.Value `json:"-" rlp:"-"`
}

// Hash returns the block hash of the header, which is simply the keccak256 hash of its
// RLP encoding.
func (h *Header) Hash() common.Hash {
	return rlpHash(h)
}

// hasherPool holds Keccak hashers.
var hasherPool = sync.Pool{
	New: func() interface{} {
		return sha3.NewLegacyKeccak256()
	},
}

func rlpHash(x interface{}) (h common.Hash) {
	sha := hasherPool.Get().(crypto.KeccakState)
	defer hasherPool.Put(sha)
	sha.Reset()
	rlp.Encode(sha, x)
	sha.Read(h[:])
	return h
}

// MarshalJSON marshals as JSON.
func (h Header) MarshalJSON() ([]byte, error) {
	type Header struct {
		ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
		Coinbase    common.Address `json:"miner"            gencodec:"required"`
		Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
		TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
		ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
		Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
		Number      *big.Int       `json:"number"           gencodec:"required"`
		GasLimit    hexutil.Uint64 `json:"gasLimit"         gencodec:"required"`
		GasUsed     hexutil.Uint64 `json:"gasUsed"          gencodec:"required"`
		Time        hexutil.Uint64 `json:"timestamp"        gencodec:"required"`
		Extra       hexutil.Bytes  `json:"extraData"        gencodec:"required"`
		Nonce       BlockNonce     `json:"nonce"            gencodec:"required"`
		Hash        common.Hash    `json:"hash"`
	}
	var enc Header
	enc.ParentHash = h.ParentHash
	enc.Coinbase = h.Coinbase
	enc.Root = h.Root
	enc.TxHash = h.TxHash
	enc.ReceiptHash = h.ReceiptHash
	enc.Bloom = h.Bloom
	enc.Number = h.Number
	enc.GasLimit = hexutil.Uint64(h.GasLimit)
	enc.GasUsed = hexutil.Uint64(h.GasUsed)
	enc.Time = hexutil.Uint64(h.Time)
	enc.Extra = h.Extra
	enc.Nonce = h.Nonce
	enc.Hash = h.Hash()
	return Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (h *Header) UnmarshalJSON(input []byte) error {
	type Header struct {
		ParentHash  *common.Hash    `json:"parentHash"       gencodec:"required"`
		Coinbase    *common.Address `json:"miner"            gencodec:"required"`
		Root        *common.Hash    `json:"stateRoot"        gencodec:"required"`
		TxHash      *common.Hash    `json:"transactionsRoot" gencodec:"required"`
		ReceiptHash *common.Hash    `json:"receiptsRoot"     gencodec:"required"`
		Bloom       *Bloom          `json:"logsBloom"        gencodec:"required"`
		Number      *hexutil.Big    `json:"number"           gencodec:"required"`
		GasLimit    *hexutil.Uint64 `json:"gasLimit"         gencodec:"required"`
		GasUsed     *hexutil.Uint64 `json:"gasUsed"          gencodec:"required"`
		Time        *hexutil.Uint64 `json:"timestamp"        gencodec:"required"`
		Extra       *hexutil.Bytes  `json:"extraData"        gencodec:"required"`
		Nonce       *BlockNonce     `json:"nonce"            gencodec:"required"`
	}
	var dec Header
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.ParentHash == nil {
		return errors.New("missing required field 'parentHash' for Header")
	}
	h.ParentHash = *dec.ParentHash
	if dec.Coinbase == nil {
		return errors.New("missing required field 'miner' for Header")
	}
	h.Coinbase = *dec.Coinbase
	if dec.Root == nil {
		return errors.New("missing required field 'stateRoot' for Header")
	}
	h.Root = *dec.Root
	if dec.TxHash == nil {
		return errors.New("missing required field 'transactionsRoot' for Header")
	}
	h.TxHash = *dec.TxHash
	if dec.ReceiptHash == nil {
		return errors.New("missing required field 'receiptsRoot' for Header")
	}
	h.ReceiptHash = *dec.ReceiptHash
	if dec.Bloom == nil {
		return errors.New("missing required field 'logsBloom' for Header")
	}
	h.Bloom = *dec.Bloom
	if dec.Number == nil {
		return errors.New("missing required field 'number' for Header")
	}
	h.Number = (*big.Int)(dec.Number)
	if dec.GasLimit == nil {
		return errors.New("missing required field 'gasLimit' for Header")
	}
	h.GasLimit = uint64(*dec.GasLimit)
	if dec.GasUsed == nil {
		return errors.New("missing required field 'gasUsed' for Header")
	}
	h.GasUsed = uint64(*dec.GasUsed)
	if dec.Time == nil {
		return errors.New("missing required field 'timestamp' for Header")
	}
	h.Time = uint64(*dec.Time)
	if dec.Extra == nil {
		return errors.New("missing required field 'extraData' for Header")
	}
	h.Extra = *dec.Extra
	if dec.Nonce == nil {
		return errors.New("missing required field 'nonce' for Header")
	}
	h.Nonce = *dec.Nonce
	return nil
}

'''
'''--- pkg/platon/bloom.go ---
package platon

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
)

const (
	// BloomByteLength represents the number of bytes used in a header log bloom.
	BloomByteLength = 256

	// BloomBitLength represents the number of bits used in a header log bloom.
	BloomBitLength = 8 * BloomByteLength
)

// Bloom represents a 2048 bit bloom filter.
type Bloom [BloomByteLength]byte

// SetBytes sets the content of b to the given bytes.
// It panics if d is not of suitable size.
func (b *Bloom) SetBytes(d []byte) {
	if len(b) < len(d) {
		panic(fmt.Sprintf("bloom bytes too big %d %d", len(b), len(d)))
	}
	copy(b[BloomByteLength-len(d):], d)
}

// Add adds d to the filter. Future calls of Test(d) will return true.
func (b *Bloom) Add(d []byte) {
	b.add(d, make([]byte, 6))
}

// add is internal version of Add, which takes a scratch buffer for reuse (needs to be at least 6 bytes)
func (b *Bloom) add(d []byte, buf []byte) {
	i1, v1, i2, v2, i3, v3 := bloomValues(d, buf)
	b[i1] |= v1
	b[i2] |= v2
	b[i3] |= v3
}

// Big converts b to a big integer.
// Note: Converting a bloom filter to a big.Int and then calling GetBytes
// does not return the same bytes, since big.Int will trim leading zeroes
func (b Bloom) Big() *big.Int {
	return new(big.Int).SetBytes(b[:])
}

// Bytes returns the backing byte slice of the bloom
func (b Bloom) Bytes() []byte {
	return b[:]
}

// Test checks if the given topic is present in the bloom filter
func (b Bloom) Test(topic []byte) bool {
	i1, v1, i2, v2, i3, v3 := bloomValues(topic, make([]byte, 6))
	return v1 == v1&b[i1] &&
		v2 == v2&b[i2] &&
		v3 == v3&b[i3]
}

// MarshalText encodes b as a hex string with 0x prefix.
func (b Bloom) MarshalText() ([]byte, error) {
	return hexutil.Bytes(b[:]).MarshalText()
}

// UnmarshalText b as a hex string with 0x prefix.
func (b *Bloom) UnmarshalText(input []byte) error {
	return hexutil.UnmarshalFixedText("Bloom", input, b[:])
}

// bloomValues returns the bytes (index-value pairs) to set for the given data
func bloomValues(data []byte, hashbuf []byte) (uint, byte, uint, byte, uint, byte) {
	sha := hasherPool.Get().(crypto.KeccakState)
	sha.Reset()
	sha.Write(data)
	sha.Read(hashbuf)
	hasherPool.Put(sha)
	// The actual bits to flip
	v1 := byte(1 << (hashbuf[1] & 0x7))
	v2 := byte(1 << (hashbuf[3] & 0x7))
	v3 := byte(1 << (hashbuf[5] & 0x7))
	// The indices for the bytes to OR in
	i1 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf)&0x7ff)>>3) - 1
	i2 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf[2:])&0x7ff)>>3) - 1
	i3 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf[4:])&0x7ff)>>3) - 1

	return i1, v1, i2, v2, i3, v3
}

'''
'''--- pkg/platon/decode.go ---
package platon

import (
	"encoding"
	"encoding/base64"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf16"
	"unicode/utf8"
)

// Unmarshal parses the JSON-encoded data and stores the result
// in the value pointed to by v. If v is nil or not a pointer,
// Unmarshal returns an InvalidUnmarshalError.
//
// Unmarshal uses the inverse of the encodings that
// Marshal uses, allocating maps, slices, and pointers as necessary,
// with the following additional rules:
//
// To unmarshal JSON into a pointer, Unmarshal first handles the case of
// the JSON being the JSON literal null. In that case, Unmarshal sets
// the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
// the value pointed at by the pointer. If the pointer is nil, Unmarshal
// allocates a new value for it to point to.
//
// To unmarshal JSON into a value implementing the Unmarshaler interface,
// Unmarshal calls that value's UnmarshalJSON method, including
// when the input is a JSON null.
// Otherwise, if the value implements encoding.TextUnmarshaler
// and the input is a JSON quoted string, Unmarshal calls that value's
// UnmarshalText method with the unquoted form of the string.
//
// To unmarshal JSON into a struct, Unmarshal matches incoming object
// keys to the keys used by Marshal (either the struct field name or its tag),
// preferring an exact match but also accepting a case-insensitive match. By
// default, object keys which don't have a corresponding struct field are
// ignored (see Decoder.DisallowUnknownFields for an alternative).
//
// To unmarshal JSON into an interface value,
// Unmarshal stores one of these in the interface value:
//
//	bool, for JSON booleans
//	float64, for JSON numbers
//	string, for JSON strings
//	[]interface{}, for JSON arrays
//	map[string]interface{}, for JSON objects
//	nil for JSON null
//
// To unmarshal a JSON array into a slice, Unmarshal resets the slice length
// to zero and then appends each element to the slice.
// As a special case, to unmarshal an empty JSON array into a slice,
// Unmarshal replaces the slice with a new empty slice.
//
// To unmarshal a JSON array into a Go array, Unmarshal decodes
// JSON array elements into corresponding Go array elements.
// If the Go array is smaller than the JSON array,
// the additional JSON array elements are discarded.
// If the JSON array is smaller than the Go array,
// the additional Go array elements are set to zero values.
//
// To unmarshal a JSON object into a map, Unmarshal first establishes a map to
// use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
// reuses the existing map, keeping existing entries. Unmarshal then stores
// key-value pairs from the JSON object into the map. The map's key type must
// either be any string type, an integer, implement json.Unmarshaler, or
// implement encoding.TextUnmarshaler.
//
// If a JSON value is not appropriate for a given target type,
// or if a JSON number overflows the target type, Unmarshal
// skips that field and completes the unmarshaling as best it can.
// If no more serious errors are encountered, Unmarshal returns
// an UnmarshalTypeError describing the earliest such error. In any
// case, it's not guaranteed that all the remaining fields following
// the problematic one will be unmarshaled into the target object.
//
// The JSON null value unmarshals into an interface, map, pointer, or slice
// by setting that Go value to nil. Because null is often used in JSON to mean
// ``not present,'' unmarshaling a JSON null into any other Go type has no effect
// on the value and produces no error.
//
// When unmarshaling quoted strings, invalid UTF-8 or
// invalid UTF-16 surrogate pairs are not treated as an error.
// Instead, they are replaced by the Unicode replacement
// character U+FFFD.
//
func Unmarshal(data []byte, v interface{}) error {
	// Check for well-formedness.
	// Avoids filling out half a data structure
	// before discovering a JSON syntax error.
	var d decodeState
	err := checkValid(data, &d.scan)
	if err != nil {
		return err
	}

	d.init(data)
	return d.unmarshal(v)
}

// Unmarshaler is the interface implemented by types
// that can unmarshal a JSON description of themselves.
// The input can be assumed to be a valid encoding of
// a JSON value. UnmarshalJSON must copy the JSON data
// if it wishes to retain the data after returning.
//
// By convention, to approximate the behavior of Unmarshal itself,
// Unmarshalers implement UnmarshalJSON([]byte("null")) as a no-op.
type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}

// An UnmarshalTypeError describes a JSON value that was
// not appropriate for a value of a specific Go type.
type UnmarshalTypeError struct {
	Value  string       // description of JSON value - "bool", "array", "number -5"
	Type   reflect.Type // type of Go value it could not be assigned to
	Offset int64        // error occurred after reading Offset bytes
	Struct string       // name of the struct type containing the field
	Field  string       // the full path from root node to the field
}

func (e *UnmarshalTypeError) Error() string {
	if e.Struct != "" || e.Field != "" {
		return "json: cannot unmarshal " + e.Value + " into Go struct field " + e.Struct + "." + e.Field + " of type " + e.Type.String()
	}
	return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String()
}

// An UnmarshalFieldError describes a JSON object key that
// led to an unexported (and therefore unwritable) struct field.
//
// Deprecated: No longer used; kept for compatibility.
type UnmarshalFieldError struct {
	Key   string
	Type  reflect.Type
	Field reflect.StructField
}

func (e *UnmarshalFieldError) Error() string {
	return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String()
}

// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
// (The argument to Unmarshal must be a non-nil pointer.)
type InvalidUnmarshalError struct {
	Type reflect.Type
}

func (e *InvalidUnmarshalError) Error() string {
	if e.Type == nil {
		return "json: Unmarshal(nil)"
	}

	if e.Type.Kind() != reflect.Ptr {
		return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
	}
	return "json: Unmarshal(nil " + e.Type.String() + ")"
}

func (d *decodeState) unmarshal(v interface{}) error {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Ptr || rv.IsNil() {
		return &InvalidUnmarshalError{reflect.TypeOf(v)}
	}

	d.scan.reset()
	d.scanWhile(scanSkipSpace)
	// We decode rv not rv.Elem because the Unmarshaler interface
	// test must be applied at the top level of the value.
	err := d.value(rv)
	if err != nil {
		return d.addErrorContext(err)
	}
	return d.savedError
}

// A Number represents a JSON number literal.
type Number string

// String returns the literal text of the number.
func (n Number) String() string { return string(n) }

// Float64 returns the number as a float64.
func (n Number) Float64() (float64, error) {
	return strconv.ParseFloat(string(n), 64)
}

// Int64 returns the number as an int64.
func (n Number) Int64() (int64, error) {
	return strconv.ParseInt(string(n), 10, 64)
}

// decodeState represents the state while decoding a JSON value.
type decodeState struct {
	data         []byte
	off          int // next read offset in data
	opcode       int // last read result
	scan         scanner
	errorContext struct { // provides context for type errors
		Struct     reflect.Type
		FieldStack []string
	}
	savedError            error
	useNumber             bool
	disallowUnknownFields bool
}

// readIndex returns the position of the last byte read.
func (d *decodeState) readIndex() int {
	return d.off - 1
}

// phasePanicMsg is used as a panic message when we end up with something that
// shouldn't happen. It can indicate a bug in the JSON decoder, or that
// something is editing the data slice while the decoder executes.
const phasePanicMsg = "JSON decoder out of sync - data changing underfoot?"

func (d *decodeState) init(data []byte) *decodeState {
	d.data = data
	d.off = 0
	d.savedError = nil
	d.errorContext.Struct = nil

	// Reuse the allocated space for the FieldStack slice.
	d.errorContext.FieldStack = d.errorContext.FieldStack[:0]
	return d
}

// saveError saves the first err it is called with,
// for reporting at the end of the unmarshal.
func (d *decodeState) saveError(err error) {
	if d.savedError == nil {
		d.savedError = d.addErrorContext(err)
	}
}

// addErrorContext returns a new error enhanced with information from d.errorContext
func (d *decodeState) addErrorContext(err error) error {
	if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {
		switch err := err.(type) {
		case *UnmarshalTypeError:
			err.Struct = d.errorContext.Struct.Name()
			err.Field = strings.Join(d.errorContext.FieldStack, ".")
			return err
		}
	}
	return err
}

// skip scans to the end of what was started.
func (d *decodeState) skip() {
	s, data, i := &d.scan, d.data, d.off
	depth := len(s.parseState)
	for {
		op := s.step(s, data[i])
		i++
		if len(s.parseState) < depth {
			d.off = i
			d.opcode = op
			return
		}
	}
}

// scanNext processes the byte at d.data[d.off].
func (d *decodeState) scanNext() {
	if d.off < len(d.data) {
		d.opcode = d.scan.step(&d.scan, d.data[d.off])
		d.off++
	} else {
		d.opcode = d.scan.eof()
		d.off = len(d.data) + 1 // mark processed EOF with len+1
	}
}

// scanWhile processes bytes in d.data[d.off:] until it
// receives a scan code not equal to op.
func (d *decodeState) scanWhile(op int) {
	s, data, i := &d.scan, d.data, d.off
	for i < len(data) {
		newOp := s.step(s, data[i])
		i++
		if newOp != op {
			d.opcode = newOp
			d.off = i
			return
		}
	}

	d.off = len(data) + 1 // mark processed EOF with len+1
	d.opcode = d.scan.eof()
}

// rescanLiteral is similar to scanWhile(scanContinue), but it specialises the
// common case where we're decoding a literal. The decoder scans the input
// twice, once for syntax errors and to check the length of the value, and the
// second to perform the decoding.
//
// Only in the second step do we use decodeState to tokenize literals, so we
// know there aren't any syntax errors. We can take advantage of that knowledge,
// and scan a literal's bytes much more quickly.
func (d *decodeState) rescanLiteral() {
	data, i := d.data, d.off
Switch:
	switch data[i-1] {
	case '"': // string
		for ; i < len(data); i++ {
			switch data[i] {
			case '\\':
				i++ // escaped char
			case '"':
				i++ // tokenize the closing quote too
				break Switch
			}
		}
	case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-': // number
		for ; i < len(data); i++ {
			switch data[i] {
			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
				'.', 'e', 'E', '+', '-':
			default:
				break Switch
			}
		}
	case 't': // true
		i += len("rue")
	case 'f': // false
		i += len("alse")
	case 'n': // null
		i += len("ull")
	}
	if i < len(data) {
		d.opcode = stateEndValue(&d.scan, data[i])
	} else {
		d.opcode = scanEnd
	}
	d.off = i + 1
}

// value consumes a JSON value from d.data[d.off-1:], decoding into v, and
// reads the following byte ahead. If v is invalid, the value is discarded.
// The first byte of the value has been read already.
func (d *decodeState) value(v reflect.Value) error {
	switch d.opcode {
	default:
		panic(phasePanicMsg)

	case scanBeginArray:
		if v.IsValid() {
			if err := d.array(v); err != nil {
				return err
			}
		} else {
			d.skip()
		}
		d.scanNext()

	case scanBeginObject:
		if v.IsValid() {
			if err := d.object(v); err != nil {
				return err
			}
		} else {
			d.skip()
		}
		d.scanNext()

	case scanBeginLiteral:
		// All bytes inside literal return scanContinue op code.
		start := d.readIndex()
		d.rescanLiteral()

		if v.IsValid() {
			if err := d.literalStore(d.data[start:d.readIndex()], v, false); err != nil {
				return err
			}
		}
	}
	return nil
}

type unquotedValue struct{}

// valueQuoted is like value but decodes a
// quoted string literal or literal null into an interface value.
// If it finds anything other than a quoted string literal or null,
// valueQuoted returns unquotedValue{}.
func (d *decodeState) valueQuoted() interface{} {
	switch d.opcode {
	default:
		panic(phasePanicMsg)

	case scanBeginArray, scanBeginObject:
		d.skip()
		d.scanNext()

	case scanBeginLiteral:
		v := d.literalInterface()
		switch v.(type) {
		case nil, string:
			return v
		}
	}
	return unquotedValue{}
}

// indirect walks down v allocating pointers as needed,
// until it gets to a non-pointer.
// If it encounters an Unmarshaler, indirect stops and returns that.
// If decodingNull is true, indirect stops at the first settable pointer so it
// can be set to nil.
func indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
	// Issue #24153 indicates that it is generally not a guaranteed property
	// that you may round-trip a reflect.Value by calling Value.Addr().Elem()
	// and expect the value to still be settable for values derived from
	// unexported embedded struct fields.
	//
	// The logic below effectively does this when it first addresses the value
	// (to satisfy possible pointer methods) and continues to dereference
	// subsequent pointers as necessary.
	//
	// After the first round-trip, we set v back to the original value to
	// preserve the original RW flags contained in reflect.Value.
	v0 := v
	haveAddr := false

	// If v is a named type and is addressable,
	// start with its address, so that if the type has pointer methods,
	// we find them.
	if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
		haveAddr = true
		v = v.Addr()
	}
	for {
		// Load value from interface, but only if the result will be
		// usefully addressable.
		if v.Kind() == reflect.Interface && !v.IsNil() {
			e := v.Elem()
			if e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {
				haveAddr = false
				v = e
				continue
			}
		}

		if v.Kind() != reflect.Ptr {
			break
		}

		if decodingNull && v.CanSet() {
			break
		}

		// Prevent infinite loop if v is an interface pointing to its own address:
		//     var v interface{}
		//     v = &v
		if v.Elem().Kind() == reflect.Interface && v.Elem().Elem() == v {
			v = v.Elem()
			break
		}
		if v.IsNil() {
			v.Set(reflect.New(v.Type().Elem()))
		}
		if v.Type().NumMethod() > 0 && v.CanInterface() {
			if u, ok := v.Interface().(Unmarshaler); ok {
				return u, nil, reflect.Value{}
			}
			if !decodingNull {
				if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
					return nil, u, reflect.Value{}
				}
			}
		}

		if haveAddr {
			v = v0 // restore original value after round-trip Value.Addr().Elem()
			haveAddr = false
		} else {
			v = v.Elem()
		}
	}
	return nil, nil, v
}

// array consumes an array from d.data[d.off-1:], decoding into v.
// The first byte of the array ('[') has been read already.
func (d *decodeState) array(v reflect.Value) error {
	// Check for unmarshaler.
	u, ut, pv := indirect(v, false)
	if u != nil {
		start := d.readIndex()
		d.skip()
		return u.UnmarshalJSON(d.data[start:d.off])
	}
	if ut != nil {
		d.saveError(&UnmarshalTypeError{Value: "array", Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	}
	v = pv

	// Check type of target.
	switch v.Kind() {
	case reflect.Interface:
		if v.NumMethod() == 0 {
			// Decoding into nil interface? Switch to non-reflect code.
			ai := d.arrayInterface()
			v.Set(reflect.ValueOf(ai))
			return nil
		}
		// Otherwise it's invalid.
		fallthrough
	default:
		d.saveError(&UnmarshalTypeError{Value: "array", Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	case reflect.Array, reflect.Slice:
		break
	}

	i := 0
	for {
		// Look ahead for ] - can only happen on first iteration.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndArray {
			break
		}

		// Get element of array, growing if necessary.
		if v.Kind() == reflect.Slice {
			// Grow slice if necessary
			if i >= v.Cap() {
				newcap := v.Cap() + v.Cap()/2
				if newcap < 4 {
					newcap = 4
				}
				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
				reflect.Copy(newv, v)
				v.Set(newv)
			}
			if i >= v.Len() {
				v.SetLen(i + 1)
			}
		}

		if i < v.Len() {
			// Decode into element.
			if err := d.value(v.Index(i)); err != nil {
				return err
			}
		} else {
			// Ran out of fixed array: skip.
			if err := d.value(reflect.Value{}); err != nil {
				return err
			}
		}
		i++

		// Next token must be , or ].
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndArray {
			break
		}
		if d.opcode != scanArrayValue {
			panic(phasePanicMsg)
		}
	}

	if i < v.Len() {
		if v.Kind() == reflect.Array {
			// Array. Zero the rest.
			z := reflect.Zero(v.Type().Elem())
			for ; i < v.Len(); i++ {
				v.Index(i).Set(z)
			}
		} else {
			v.SetLen(i)
		}
	}
	if i == 0 && v.Kind() == reflect.Slice {
		v.Set(reflect.MakeSlice(v.Type(), 0, 0))
	}
	return nil
}

var nullLiteral = []byte("null")
var textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()

// object consumes an object from d.data[d.off-1:], decoding into v.
// The first byte ('{') of the object has been read already.
func (d *decodeState) object(v reflect.Value) error {
	// Check for unmarshaler.
	u, ut, pv := indirect(v, false)
	if u != nil {
		start := d.readIndex()
		d.skip()
		return u.UnmarshalJSON(d.data[start:d.off])
	}
	if ut != nil {
		d.saveError(&UnmarshalTypeError{Value: "object", Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	}
	v = pv
	t := v.Type()

	// Decoding into nil interface? Switch to non-reflect code.
	if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
		oi := d.objectInterface()
		v.Set(reflect.ValueOf(oi))
		return nil
	}

	var fields structFields

	// Check type of target:
	//   struct or
	//   map[T1]T2 where T1 is string, an integer type,
	//             or an encoding.TextUnmarshaler
	switch v.Kind() {
	case reflect.Map:
		// Map key must either have string kind, have an integer kind,
		// or be an encoding.TextUnmarshaler.
		switch t.Key().Kind() {
		case reflect.String,
			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		default:
			if !reflect.PtrTo(t.Key()).Implements(textUnmarshalerType) {
				d.saveError(&UnmarshalTypeError{Value: "object", Type: t, Offset: int64(d.off)})
				d.skip()
				return nil
			}
		}
		if v.IsNil() {
			v.Set(reflect.MakeMap(t))
		}
	case reflect.Struct:
		fields = cachedTypeFields(t)
		// ok
	default:
		d.saveError(&UnmarshalTypeError{Value: "object", Type: t, Offset: int64(d.off)})
		d.skip()
		return nil
	}

	var mapElem reflect.Value
	origErrorContext := d.errorContext

	for {
		// Read opening " of string key or closing }.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndObject {
			// closing } - can only happen on first iteration.
			break
		}
		if d.opcode != scanBeginLiteral {
			panic(phasePanicMsg)
		}

		// Read key.
		start := d.readIndex()
		d.rescanLiteral()
		item := d.data[start:d.readIndex()]
		key, ok := unquoteBytes(item)
		if !ok {
			panic(phasePanicMsg)
		}

		// Figure out field corresponding to key.
		var subv reflect.Value
		destring := false // whether the value is wrapped in a string to be decoded first

		if v.Kind() == reflect.Map {
			elemType := t.Elem()
			if !mapElem.IsValid() {
				mapElem = reflect.New(elemType).Elem()
			} else {
				mapElem.Set(reflect.Zero(elemType))
			}
			subv = mapElem
		} else {
			var f *field
			if i, ok := fields.nameIndex[string(key)]; ok {
				// Found an exact name match.
				f = &fields.list[i]
			} else {
				// Fall back to the expensive case-insensitive
				// linear search.
				for i := range fields.list {
					ff := &fields.list[i]
					if ff.equalFold(ff.nameBytes, key) {
						f = ff
						break
					}
				}
			}
			if f != nil {
				subv = v
				destring = f.quoted
				for _, i := range f.index {
					if subv.Kind() == reflect.Ptr {
						if subv.IsNil() {
							// If a struct embeds a pointer to an unexported type,
							// it is not possible to set a newly allocated value
							// since the field is unexported.
							//
							// See https://golang.org/issue/21357
							if !subv.CanSet() {
								d.saveError(fmt.Errorf("json: cannot set embedded pointer to unexported struct: %v", subv.Type().Elem()))
								// Invalidate subv to ensure d.value(subv) skips over
								// the JSON value without assigning it to subv.
								subv = reflect.Value{}
								destring = false
								break
							}
							subv.Set(reflect.New(subv.Type().Elem()))
						}
						subv = subv.Elem()
					}
					subv = subv.Field(i)
				}
				d.errorContext.FieldStack = append(d.errorContext.FieldStack, f.name)
				d.errorContext.Struct = t
			} else if d.disallowUnknownFields {
				d.saveError(fmt.Errorf("json: unknown field %q", key))
			}
		}

		// Read : before value.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode != scanObjectKey {
			panic(phasePanicMsg)
		}
		d.scanWhile(scanSkipSpace)

		if destring {
			switch qv := d.valueQuoted().(type) {
			case nil:
				if err := d.literalStore(nullLiteral, subv, false); err != nil {
					return err
				}
			case string:
				if err := d.literalStore([]byte(qv), subv, true); err != nil {
					return err
				}
			default:
				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v", subv.Type()))
			}
		} else {
			if err := d.value(subv); err != nil {
				return err
			}
		}

		// Write value back to map;
		// if using struct, subv points into struct already.
		if v.Kind() == reflect.Map {
			kt := t.Key()
			var kv reflect.Value
			switch {
			case reflect.PtrTo(kt).Implements(textUnmarshalerType):
				kv = reflect.New(kt)
				if err := d.literalStore(item, kv, true); err != nil {
					return err
				}
				kv = kv.Elem()
			case kt.Kind() == reflect.String:
				kv = reflect.ValueOf(key).Convert(kt)
			default:
				switch kt.Kind() {
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
					s := string(key)
					n, err := strconv.ParseInt(s, 10, 64)
					if err != nil || reflect.Zero(kt).OverflowInt(n) {
						d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: kt, Offset: int64(start + 1)})
						break
					}
					kv = reflect.ValueOf(n).Convert(kt)
				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
					s := string(key)
					n, err := strconv.ParseUint(s, 10, 64)
					if err != nil || reflect.Zero(kt).OverflowUint(n) {
						d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: kt, Offset: int64(start + 1)})
						break
					}
					kv = reflect.ValueOf(n).Convert(kt)
				default:
					panic("json: Unexpected key type") // should never occur
				}
			}
			if kv.IsValid() {
				v.SetMapIndex(kv, subv)
			}
		}

		// Next token must be , or }.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		// Reset errorContext to its original state.
		// Keep the same underlying array for FieldStack, to reuse the
		// space and avoid unnecessary allocs.
		d.errorContext.FieldStack = d.errorContext.FieldStack[:len(origErrorContext.FieldStack)]
		d.errorContext.Struct = origErrorContext.Struct
		if d.opcode == scanEndObject {
			break
		}
		if d.opcode != scanObjectValue {
			panic(phasePanicMsg)
		}
	}
	return nil
}

// convertNumber converts the number literal s to a float64 or a Number
// depending on the setting of d.useNumber.
func (d *decodeState) convertNumber(s string) (interface{}, error) {
	if d.useNumber {
		return Number(s), nil
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return nil, &UnmarshalTypeError{Value: "number " + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)}
	}
	return f, nil
}

var numberType = reflect.TypeOf(Number(""))

// literalStore decodes a literal stored in item into v.
//
// fromQuoted indicates whether this literal came from unwrapping a
// string from the ",string" struct tag option. this is used only to
// produce more helpful error messages.
func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) error {
	// Check for unmarshaler.
	if len(item) == 0 {
		//Empty string given
		d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
		return nil
	}
	isNull := item[0] == 'n' // null
	u, ut, pv := indirect(v, isNull)
	if u != nil {
		return u.UnmarshalJSON(item)
	}
	if ut != nil {
		if item[0] != '"' {
			if fromQuoted {
				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
				return nil
			}
			val := "number"
			switch item[0] {
			case 'n':
				val = "null"
			case 't', 'f':
				val = "bool"
			}
			d.saveError(&UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})
			return nil
		}
		s, ok := unquoteBytes(item)
		if !ok {
			if fromQuoted {
				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
			}
			panic(phasePanicMsg)
		}
		return ut.UnmarshalText(s)
	}

	v = pv

	switch c := item[0]; c {
	case 'n': // null
		// The main parser checks that only true and false can reach here,
		// but if this was a quoted string input, it could be anything.
		if fromQuoted && string(item) != "null" {
			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
			break
		}
		switch v.Kind() {
		case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
			v.Set(reflect.Zero(v.Type()))
			// otherwise, ignore null for primitives/string
		}
	case 't', 'f': // true, false
		value := item[0] == 't'
		// The main parser checks that only true and false can reach here,
		// but if this was a quoted string input, it could be anything.
		if fromQuoted && string(item) != "true" && string(item) != "false" {
			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
			break
		}
		switch v.Kind() {
		default:
			if fromQuoted {
				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
			} else {
				d.saveError(&UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
			}
		case reflect.Bool:
			v.SetBool(value)
		case reflect.Interface:
			if v.NumMethod() == 0 {
				v.Set(reflect.ValueOf(value))
			} else {
				d.saveError(&UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
			}
		}

	case '"': // string
		s, ok := unquoteBytes(item)
		if !ok {
			if fromQuoted {
				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
			}
			panic(phasePanicMsg)
		}
		switch v.Kind() {
		default:
			d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
		case reflect.Slice:
			if v.Type().Elem().Kind() != reflect.Uint8 {
				d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
			n, err := base64.StdEncoding.Decode(b, s)
			if err != nil {
				d.saveError(err)
				break
			}
			v.SetBytes(b[:n])
		case reflect.String:
			if v.Type() == numberType && !isValidNumber(string(s)) {
				return fmt.Errorf("json: invalid number literal, trying to unmarshal %q into Number", item)
			}
			v.SetString(string(s))
		case reflect.Interface:
			if v.NumMethod() == 0 {
				v.Set(reflect.ValueOf(string(s)))
			} else {
				d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
			}
		}

	default: // number
		if c != '-' && (c < '0' || c > '9') {
			if fromQuoted {
				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
			}
			panic(phasePanicMsg)
		}
		s := string(item)
		switch v.Kind() {
		default:
			if v.Kind() == reflect.String && v.Type() == numberType {
				// s must be a valid number, because it's
				// already been tokenized.
				v.SetString(s)
				break
			}
			if fromQuoted {
				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
			}
			d.saveError(&UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
		case reflect.Interface:
			n, err := d.convertNumber(s)
			if err != nil {
				d.saveError(err)
				break
			}
			if v.NumMethod() != 0 {
				d.saveError(&UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.Set(reflect.ValueOf(n))

		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			n, err := strconv.ParseInt(s, 10, 64)
			if err != nil || v.OverflowInt(n) {
				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetInt(n)

		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			n, err := strconv.ParseUint(s, 10, 64)
			if err != nil || v.OverflowUint(n) {
				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetUint(n)

		case reflect.Float32, reflect.Float64:
			n, err := strconv.ParseFloat(s, v.Type().Bits())
			if err != nil || v.OverflowFloat(n) {
				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetFloat(n)
		}
	}
	return nil
}

// The xxxInterface routines build up a value to be stored
// in an empty interface. They are not strictly necessary,
// but they avoid the weight of reflection in this common case.

// valueInterface is like value but returns interface{}
func (d *decodeState) valueInterface() (val interface{}) {
	switch d.opcode {
	default:
		panic(phasePanicMsg)
	case scanBeginArray:
		val = d.arrayInterface()
		d.scanNext()
	case scanBeginObject:
		val = d.objectInterface()
		d.scanNext()
	case scanBeginLiteral:
		val = d.literalInterface()
	}
	return
}

// arrayInterface is like array but returns []interface{}.
func (d *decodeState) arrayInterface() []interface{} {
	var v = make([]interface{}, 0)
	for {
		// Look ahead for ] - can only happen on first iteration.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndArray {
			break
		}

		v = append(v, d.valueInterface())

		// Next token must be , or ].
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndArray {
			break
		}
		if d.opcode != scanArrayValue {
			panic(phasePanicMsg)
		}
	}
	return v
}

// objectInterface is like object but returns map[string]interface{}.
func (d *decodeState) objectInterface() map[string]interface{} {
	m := make(map[string]interface{})
	for {
		// Read opening " of string key or closing }.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndObject {
			// closing } - can only happen on first iteration.
			break
		}
		if d.opcode != scanBeginLiteral {
			panic(phasePanicMsg)
		}

		// Read string key.
		start := d.readIndex()
		d.rescanLiteral()
		item := d.data[start:d.readIndex()]
		key, ok := unquote(item)
		if !ok {
			panic(phasePanicMsg)
		}

		// Read : before value.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode != scanObjectKey {
			panic(phasePanicMsg)
		}
		d.scanWhile(scanSkipSpace)

		// Read value.
		m[key] = d.valueInterface()

		// Next token must be , or }.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndObject {
			break
		}
		if d.opcode != scanObjectValue {
			panic(phasePanicMsg)
		}
	}
	return m
}

// literalInterface consumes and returns a literal from d.data[d.off-1:] and
// it reads the following byte ahead. The first byte of the literal has been
// read already (that's how the caller knows it's a literal).
func (d *decodeState) literalInterface() interface{} {
	// All bytes inside literal return scanContinue op code.
	start := d.readIndex()
	d.rescanLiteral()

	item := d.data[start:d.readIndex()]

	switch c := item[0]; c {
	case 'n': // null
		return nil

	case 't', 'f': // true, false
		return c == 't'

	case '"': // string
		s, ok := unquote(item)
		if !ok {
			panic(phasePanicMsg)
		}
		return s

	default: // number
		if c != '-' && (c < '0' || c > '9') {
			panic(phasePanicMsg)
		}
		n, err := d.convertNumber(string(item))
		if err != nil {
			d.saveError(err)
		}
		return n
	}
}

// getu4 decodes \uXXXX from the beginning of s, returning the hex value,
// or it returns -1.
func getu4(s []byte) rune {
	if len(s) < 6 || s[0] != '\\' || s[1] != 'u' {
		return -1
	}
	var r rune
	for _, c := range s[2:6] {
		switch {
		case '0' <= c && c <= '9':
			c = c - '0'
		case 'a' <= c && c <= 'f':
			c = c - 'a' + 10
		case 'A' <= c && c <= 'F':
			c = c - 'A' + 10
		default:
			return -1
		}
		r = r*16 + rune(c)
	}
	return r
}

// unquote converts a quoted JSON string literal s into an actual string t.
// The rules are different than for Go, so cannot use strconv.Unquote.
func unquote(s []byte) (t string, ok bool) {
	s, ok = unquoteBytes(s)
	t = string(s)
	return
}

func unquoteBytes(s []byte) (t []byte, ok bool) {
	if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
		return
	}
	s = s[1 : len(s)-1]

	// Check for unusual characters. If there are none,
	// then no unquoting is needed, so return a slice of the
	// original bytes.
	r := 0
	for r < len(s) {
		c := s[r]
		if c == '\\' || c == '"' || c < ' ' {
			break
		}
		if c < utf8.RuneSelf {
			r++
			continue
		}
		rr, size := utf8.DecodeRune(s[r:])
		if rr == utf8.RuneError && size == 1 {
			break
		}
		r += size
	}
	if r == len(s) {
		return s, true
	}

	b := make([]byte, len(s)+2*utf8.UTFMax)
	w := copy(b, s[0:r])
	for r < len(s) {
		// Out of room? Can only happen if s is full of
		// malformed UTF-8 and we're replacing each
		// byte with RuneError.
		if w >= len(b)-2*utf8.UTFMax {
			nb := make([]byte, (len(b)+utf8.UTFMax)*2)
			copy(nb, b[0:w])
			b = nb
		}
		switch c := s[r]; {
		case c == '\\':
			r++
			if r >= len(s) {
				return
			}
			switch s[r] {
			default:
				return
			case '"', '\\', '/', '\'':
				b[w] = s[r]
				r++
				w++
			case 'b':
				b[w] = '\b'
				r++
				w++
			case 'f':
				b[w] = '\f'
				r++
				w++
			case 'n':
				b[w] = '\n'
				r++
				w++
			case 'r':
				b[w] = '\r'
				r++
				w++
			case 't':
				b[w] = '\t'
				r++
				w++
			case 'u':
				r--
				rr := getu4(s[r:])
				if rr < 0 {
					return
				}
				r += 6
				if utf16.IsSurrogate(rr) {
					rr1 := getu4(s[r:])
					if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
						// A valid pair; consume.
						r += 6
						w += utf8.EncodeRune(b[w:], dec)
						break
					}
					// Invalid surrogate; fall back to replacement rune.
					rr = unicode.ReplacementChar
				}
				w += utf8.EncodeRune(b[w:], rr)
			}

		// Quote, control characters are invalid.
		case c == '"', c < ' ':
			return

		// ASCII
		case c < utf8.RuneSelf:
			b[w] = c
			r++
			w++

		// Coerce to well-formed UTF-8.
		default:
			rr, size := utf8.DecodeRune(s[r:])
			r += size
			w += utf8.EncodeRune(b[w:], rr)
		}
	}
	return b[0:w], true
}

'''
'''--- pkg/platon/encode.go ---
package platon

import (
	"bytes"
	"encoding"
	"encoding/base64"
	"fmt"
	"math"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"
)

// Marshal returns the JSON encoding of v.
//
// Marshal traverses the value v recursively.
// If an encountered value implements the Marshaler interface
// and is not a nil pointer, Marshal calls its MarshalJSON method
// to produce JSON. If no MarshalJSON method is present but the
// value implements encoding.TextMarshaler instead, Marshal calls
// its MarshalText method and encodes the result as a JSON string.
// The nil pointer exception is not strictly necessary
// but mimics a similar, necessary exception in the behavior of
// UnmarshalJSON.
//
// Otherwise, Marshal uses the following type-dependent default encodings:
//
// Boolean values encode as JSON booleans.
//
// Floating point, integer, and Number values encode as JSON numbers.
//
// String values encode as JSON strings coerced to valid UTF-8,
// replacing invalid bytes with the Unicode replacement rune.
// So that the JSON will be safe to embed inside HTML <script> tags,
// the string is encoded using HTMLEscape,
// which replaces "<", ">", "&", U+2028, and U+2029 are escaped
// to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".
// This replacement can be disabled when using an Encoder,
// by calling SetEscapeHTML(false).
//
// Array and slice values encode as JSON arrays, except that
// []byte encodes as a base64-encoded string, and a nil slice
// encodes as the null JSON value.
//
// Struct values encode as JSON objects.
// Each exported struct field becomes a member of the object, using the
// field name as the object key, unless the field is omitted for one of the
// reasons given below.
//
// The encoding of each struct field can be customized by the format string
// stored under the "json" key in the struct field's tag.
// The format string gives the name of the field, possibly followed by a
// comma-separated list of options. The name may be empty in order to
// specify options without overriding the default field name.
//
// The "omitempty" option specifies that the field should be omitted
// from the encoding if the field has an empty value, defined as
// false, 0, a nil pointer, a nil interface value, and any empty array,
// slice, map, or string.
//
// As a special case, if the field tag is "-", the field is always omitted.
// Note that a field with name "-" can still be generated using the tag "-,".
//
// Examples of struct field tags and their meanings:
//
//   // Field appears in JSON as key "myName".
//   Field int `json:"myName"`
//
//   // Field appears in JSON as key "myName" and
//   // the field is omitted from the object if its value is empty,
//   // as defined above.
//   Field int `json:"myName,omitempty"`
//
//   // Field appears in JSON as key "Field" (the default), but
//   // the field is skipped if empty.
//   // Note the leading comma.
//   Field int `json:",omitempty"`
//
//   // Field is ignored by this package.
//   Field int `json:"-"`
//
//   // Field appears in JSON as key "-".
//   Field int `json:"-,"`
//
// The "string" option signals that a field is stored as JSON inside a
// JSON-encoded string. It applies only to fields of string, floating point,
// integer, or boolean types. This extra level of encoding is sometimes used
// when communicating with JavaScript programs:
//
//    Int64String int64 `json:",string"`
//
// The key name will be used if it's a non-empty string consisting of
// only Unicode letters, digits, and ASCII punctuation except quotation
// marks, backslash, and comma.
//
// Anonymous struct fields are usually marshaled as if their inner exported fields
// were fields in the outer struct, subject to the usual Go visibility rules amended
// as described in the next paragraph.
// An anonymous struct field with a name given in its JSON tag is treated as
// having that name, rather than being anonymous.
// An anonymous struct field of interface type is treated the same as having
// that type as its name, rather than being anonymous.
//
// The Go visibility rules for struct fields are amended for JSON when
// deciding which field to marshal or unmarshal. If there are
// multiple fields at the same level, and that level is the least
// nested (and would therefore be the nesting level selected by the
// usual Go rules), the following extra rules apply:
//
// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
// even if there are multiple untagged fields that would otherwise conflict.
//
// 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
//
// 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
//
// Handling of anonymous struct fields is new in Go 1.1.
// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
// an anonymous struct field in both current and earlier versions, give the field
// a JSON tag of "-".
//
// Map values encode as JSON objects. The map's key type must either be a
// string, an integer type, or implement encoding.TextMarshaler. The map keys
// are sorted and used as JSON object keys by applying the following rules,
// subject to the UTF-8 coercion described for string values above:
//   - keys of any string type are used directly
//   - encoding.TextMarshalers are marshaled
//   - integer keys are converted to strings
//
// Pointer values encode as the value pointed to.
// A nil pointer encodes as the null JSON value.
//
// Interface values encode as the value contained in the interface.
// A nil interface value encodes as the null JSON value.
//
// Channel, complex, and function values cannot be encoded in JSON.
// Attempting to encode such a value causes Marshal to return
// an UnsupportedTypeError.
//
// JSON cannot represent cyclic data structures and Marshal does not
// handle them. Passing cyclic structures to Marshal will result in
// an error.
//
func Marshal(v interface{}) ([]byte, error) {
	e := newEncodeState()

	err := e.marshal(v, encOpts{escapeHTML: true})
	if err != nil {
		return nil, err
	}
	buf := append([]byte(nil), e.Bytes()...)

	encodeStatePool.Put(e)

	return buf, nil
}

// MarshalIndent is like Marshal but applies Indent to format the output.
// Each JSON element in the output will begin on a new line beginning with prefix
// followed by one or more copies of indent according to the indentation nesting.
func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {
	b, err := Marshal(v)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = Indent(&buf, b, prefix, indent)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
// characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
// so that the JSON will be safe to embed inside HTML <script> tags.
// For historical reasons, web browsers don't honor standard HTML
// escaping within <script> tags, so an alternative JSON encoding must
// be used.
func HTMLEscape(dst *bytes.Buffer, src []byte) {
	// The characters can only appear in string literals,
	// so just scan the string one byte at a time.
	start := 0
	for i, c := range src {
		if c == '<' || c == '>' || c == '&' {
			if start < i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u00`)
			dst.WriteByte(hex[c>>4])
			dst.WriteByte(hex[c&0xF])
			start = i + 1
		}
		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
			if start < i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u202`)
			dst.WriteByte(hex[src[i+2]&0xF])
			start = i + 3
		}
	}
	if start < len(src) {
		dst.Write(src[start:])
	}
}

// Marshaler is the interface implemented by types that
// can marshal themselves into valid JSON.
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}

// Marshaler2 is the interface implemented by types that
// can marshal themselves into valid JSON.
type Marshaler2 interface {
	MarshalJSON2() ([]byte, error)
}

// An UnsupportedTypeError is returned by Marshal when attempting
// to encode an unsupported value type.
type UnsupportedTypeError struct {
	Type reflect.Type
}

func (e *UnsupportedTypeError) Error() string {
	return "json: unsupported type: " + e.Type.String()
}

// An UnsupportedValueError is returned by Marshal when attempting
// to encode an unsupported value.
type UnsupportedValueError struct {
	Value reflect.Value
	Str   string
}

func (e *UnsupportedValueError) Error() string {
	return "json: unsupported value: " + e.Str
}

// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when
// attempting to encode a string value with invalid UTF-8 sequences.
// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by
// replacing invalid bytes with the Unicode replacement rune U+FFFD.
//
// Deprecated: No longer used; kept for compatibility.
type InvalidUTF8Error struct {
	S string // the whole string value that caused the error
}

func (e *InvalidUTF8Error) Error() string {
	return "json: invalid UTF-8 in string: " + strconv.Quote(e.S)
}

// A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.
type MarshalerError struct {
	Type       reflect.Type
	Err        error
	sourceFunc string
}

func (e *MarshalerError) Error() string {
	srcFunc := e.sourceFunc
	if srcFunc == "" {
		srcFunc = "MarshalJSON"
	}
	return "json: error calling " + srcFunc +
		" for type " + e.Type.String() +
		": " + e.Err.Error()
}

// Unwrap returns the underlying error.
func (e *MarshalerError) Unwrap() error { return e.Err }

var hex = "0123456789abcdef"

// An encodeState encodes JSON into a bytes.Buffer.
type encodeState struct {
	bytes.Buffer // accumulated output
	scratch      [64]byte

	// Keep track of what pointers we've seen in the current recursive call
	// path, to avoid cycles that could lead to a stack overflow. Only do
	// the relatively expensive map operations if ptrLevel is larger than
	// startDetectingCyclesAfter, so that we skip the work if we're within a
	// reasonable amount of nested pointers deep.
	ptrLevel uint
	ptrSeen  map[interface{}]struct{}
}

const startDetectingCyclesAfter = 1000

var encodeStatePool sync.Pool

func newEncodeState() *encodeState {
	if v := encodeStatePool.Get(); v != nil {
		e := v.(*encodeState)
		e.Reset()
		if len(e.ptrSeen) > 0 {
			panic("ptrEncoder.encode should have emptied ptrSeen via defers")
		}
		e.ptrLevel = 0
		return e
	}
	return &encodeState{ptrSeen: make(map[interface{}]struct{})}
}

// jsonError is an error wrapper type for internal use only.
// Panics with errors are wrapped in jsonError so that the top-level recover
// can distinguish intentional panics from this package.
type jsonError struct{ error }

func (e *encodeState) marshal(v interface{}, opts encOpts) (err error) {
	defer func() {
		if r := recover(); r != nil {
			if je, ok := r.(jsonError); ok {
				err = je.error
			} else {
				panic(r)
			}
		}
	}()
	e.reflectValue(reflect.ValueOf(v), opts)
	return nil
}

// error aborts the encoding by panicking with err wrapped in jsonError.
func (e *encodeState) error(err error) {
	panic(jsonError{err})
}

func isEmptyValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	}
	return false
}

func (e *encodeState) reflectValue(v reflect.Value, opts encOpts) {
	valueEncoder(v)(e, v, opts)
}

type encOpts struct {
	// quoted causes primitive fields to be encoded inside JSON strings.
	quoted bool
	// escapeHTML causes '<', '>', and '&' to be escaped in JSON strings.
	escapeHTML bool
}

type encoderFunc func(e *encodeState, v reflect.Value, opts encOpts)

var encoderCache sync.Map // map[reflect.Type]encoderFunc

func valueEncoder(v reflect.Value) encoderFunc {
	if !v.IsValid() {
		return invalidValueEncoder
	}
	return typeEncoder(v.Type())
}

func typeEncoder(t reflect.Type) encoderFunc {
	if fi, ok := encoderCache.Load(t); ok {
		return fi.(encoderFunc)
	}

	// To deal with recursive types, populate the map with an
	// indirect func before we build it. This type waits on the
	// real func (f) to be ready and then calls it. This indirect
	// func is only used for recursive types.
	var (
		wg sync.WaitGroup
		f  encoderFunc
	)
	wg.Add(1)
	fi, loaded := encoderCache.LoadOrStore(t, encoderFunc(func(e *encodeState, v reflect.Value, opts encOpts) {
		wg.Wait()
		f(e, v, opts)
	}))
	if loaded {
		return fi.(encoderFunc)
	}

	// Compute the real encoder and replace the indirect func with it.
	f = newTypeEncoder(t, true)
	wg.Done()
	encoderCache.Store(t, f)
	return f
}

// TextMarshaler2 is the interface implemented by types that
// can marshal themselves into valid JSON.
type TextMarshaler2 interface {
	MarshalText2() ([]byte, error)
}

var (
	marshalerType = reflect.TypeOf((*Marshaler)(nil)).Elem()
	//marshaler2Type     = reflect.TypeOf((*Marshaler2)(nil)).Elem()
	textMarshaler2Type = reflect.TypeOf((*TextMarshaler2)(nil)).Elem()
	textMarshalerType  = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
)

// newTypeEncoder constructs an encoderFunc for a type.
// The returned encoder only checks CanAddr when allowAddr is true.
func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
	// If we have a non-pointer value whose type implements
	// Marshaler with a value receiver, then we're better off taking
	// the address of the value - otherwise we end up with an
	// allocation as we cast the value to an interface.

	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(marshalerType) {
		return newCondAddrEncoder(addrMarshalerEncoder2, newTypeEncoder(t, false))
	}
	if t.Implements(marshalerType) {
		return marshalerEncoder2
	}

	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(textMarshaler2Type) {
		return newCondAddrEncoder(addrTextMarshalerEncoder2, newTypeEncoder(t, false))
	}
	if t.Implements(textMarshaler2Type) {
		return textMarshalerEncoder2
	}

	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(marshalerType) {
		return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
	}
	if t.Implements(marshalerType) {
		return marshalerEncoder
	}
	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(textMarshalerType) {
		return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))
	}
	if t.Implements(textMarshalerType) {
		return textMarshalerEncoder
	}

	switch t.Kind() {
	case reflect.Bool:
		return boolEncoder
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return intEncoder
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return uintEncoder
	case reflect.Float32:
		return float32Encoder
	case reflect.Float64:
		return float64Encoder
	case reflect.String:
		return stringEncoder
	case reflect.Interface:
		return interfaceEncoder
	case reflect.Struct:
		return newStructEncoder(t)
	case reflect.Map:
		return newMapEncoder(t)
	case reflect.Slice:
		return newSliceEncoder(t)
	case reflect.Array:
		return newArrayEncoder(t)
	case reflect.Ptr:
		return newPtrEncoder(t)
	default:
		return unsupportedTypeEncoder
	}
}

func invalidValueEncoder(e *encodeState, v reflect.Value, _ encOpts) {
	e.WriteString("null")
}

func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Ptr && v.IsNil() {
		e.WriteString("null")
		return
	}
	m, ok := v.Interface().(Marshaler)
	if !ok {
		e.WriteString("null")
		return
	}
	b, err := m.MarshalJSON()
	if err == nil {
		// copy JSON into buffer, checking validity.
		err = compact(&e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalJSON"})
	}
}

func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString("null")
		return
	}
	m := va.Interface().(Marshaler)
	b, err := m.MarshalJSON()
	if err == nil {
		err = compact(&e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalJSON"})
	}
}

func marshalerEncoder2(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Ptr && v.IsNil() {
		e.WriteString("null")
		return
	}
	m, ok := v.Interface().(Marshaler)
	if !ok {
		e.WriteString("null")
		return
	}
	b, err := m.MarshalJSON()
	if err == nil {
		// copy JSON into buffer, checking validity.
		err = compact(&e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalJSON2"})
	}
}

func addrMarshalerEncoder2(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString("null")
		return
	}
	m := va.Interface().(Marshaler2)
	b, err := m.MarshalJSON2()
	if err == nil {
		err = compact(&e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalJSON2"})
	}
}

func textMarshalerEncoder2(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Ptr && v.IsNil() {
		e.WriteString("null")
		return
	}
	m, ok := v.Interface().(TextMarshaler2)
	if !ok {
		e.WriteString("null")
		return
	}
	b, err := m.MarshalText2()
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalText2"})
	}
	e.stringBytes(b, opts.escapeHTML)
}

func addrTextMarshalerEncoder2(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString("null")
		return
	}
	m := va.Interface().(TextMarshaler2)
	b, err := m.MarshalText2()
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalText2"})
	}
	e.stringBytes(b, opts.escapeHTML)
}

func textMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Ptr && v.IsNil() {
		e.WriteString("null")
		return
	}
	m, ok := v.Interface().(encoding.TextMarshaler)
	if !ok {
		e.WriteString("null")
		return
	}
	b, err := m.MarshalText()
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalText"})
	}
	e.stringBytes(b, opts.escapeHTML)
}

func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString("null")
		return
	}
	m := va.Interface().(encoding.TextMarshaler)
	b, err := m.MarshalText()
	if err != nil {
		e.error(&MarshalerError{v.Type(), err, "MarshalText"})
	}
	e.stringBytes(b, opts.escapeHTML)
}

func boolEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if opts.quoted {
		e.WriteByte('"')
	}
	if v.Bool() {
		e.WriteString("true")
	} else {
		e.WriteString("false")
	}
	if opts.quoted {
		e.WriteByte('"')
	}
}

func intEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
	if opts.quoted {
		e.WriteByte('"')
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte('"')
	}
}

func uintEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
	if opts.quoted {
		e.WriteByte('"')
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte('"')
	}
}

type floatEncoder int // number of bits

func (bits floatEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	f := v.Float()
	if math.IsInf(f, 0) || math.IsNaN(f) {
		e.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})
	}

	// Convert as if by ES6 number to string conversion.
	// This matches most other JSON generators.
	// See golang.org/issue/6384 and golang.org/issue/14135.
	// Like fmt %g, but the exponent cutoffs are different
	// and exponents themselves are not padded to two digits.
	b := e.scratch[:0]
	abs := math.Abs(f)
	fmt := byte('f')
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if bits == 64 && (abs < 1e-6 || abs >= 1e21) || bits == 32 && (float32(abs) < 1e-6 || float32(abs) >= 1e21) {
			fmt = 'e'
		}
	}
	b = strconv.AppendFloat(b, f, fmt, -1, int(bits))
	if fmt == 'e' {
		// clean up e-09 to e-9
		n := len(b)
		if n >= 4 && b[n-4] == 'e' && b[n-3] == '-' && b[n-2] == '0' {
			b[n-2] = b[n-1]
			b = b[:n-1]
		}
	}

	if opts.quoted {
		e.WriteByte('"')
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte('"')
	}
}

var (
	float32Encoder = (floatEncoder(32)).encode
	float64Encoder = (floatEncoder(64)).encode
)

func stringEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Type() == numberType {
		numStr := v.String()
		// In Go1.5 the empty string encodes to "0", while this is not a valid number literal
		// we keep compatibility so check validity after this.
		if numStr == "" {
			numStr = "0" // Number's zero-val
		}
		if !isValidNumber(numStr) {
			e.error(fmt.Errorf("json: invalid number literal %q", numStr))
		}
		if opts.quoted {
			e.WriteByte('"')
		}
		e.WriteString(numStr)
		if opts.quoted {
			e.WriteByte('"')
		}
		return
	}
	if opts.quoted {
		e2 := newEncodeState()
		// Since we encode the string twice, we only need to escape HTML
		// the first time.
		e2.string(v.String(), opts.escapeHTML)
		e.stringBytes(e2.Bytes(), false)
		encodeStatePool.Put(e2)
	} else {
		e.string(v.String(), opts.escapeHTML)
	}
}

// isValidNumber reports whether s is a valid JSON number literal.
func isValidNumber(s string) bool {
	// This function implements the JSON numbers grammar.
	// See https://tools.ietf.org/html/rfc7159#section-6
	// and https://www.json.org/img/number.png

	if s == "" {
		return false
	}

	// Optional -
	if s[0] == '-' {
		s = s[1:]
		if s == "" {
			return false
		}
	}

	// Digits
	switch {
	default:
		return false

	case s[0] == '0':
		s = s[1:]

	case '1' <= s[0] && s[0] <= '9':
		s = s[1:]
		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
			s = s[1:]
		}
	}

	// . followed by 1 or more digits.
	if len(s) >= 2 && s[0] == '.' && '0' <= s[1] && s[1] <= '9' {
		s = s[2:]
		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
			s = s[1:]
		}
	}

	// e or E followed by an optional - or + and
	// 1 or more digits.
	if len(s) >= 2 && (s[0] == 'e' || s[0] == 'E') {
		s = s[1:]
		if s[0] == '+' || s[0] == '-' {
			s = s[1:]
			if s == "" {
				return false
			}
		}
		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
			s = s[1:]
		}
	}

	// Make sure we are at the end.
	return s == ""
}

func interfaceEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString("null")
		return
	}
	e.reflectValue(v.Elem(), opts)
}

func unsupportedTypeEncoder(e *encodeState, v reflect.Value, _ encOpts) {
	e.error(&UnsupportedTypeError{v.Type()})
}

type structEncoder struct {
	fields structFields
}

type structFields struct {
	list      []field
	nameIndex map[string]int
}

func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	next := byte('{')
FieldLoop:
	for i := range se.fields.list {
		f := &se.fields.list[i]

		// Find the nested struct field by following f.index.
		fv := v
		for _, i := range f.index {
			if fv.Kind() == reflect.Ptr {
				if fv.IsNil() {
					continue FieldLoop
				}
				fv = fv.Elem()
			}
			fv = fv.Field(i)
		}

		if f.omitEmpty && isEmptyValue(fv) {
			continue
		}
		e.WriteByte(next)
		next = ','
		if opts.escapeHTML {
			e.WriteString(f.nameEscHTML)
		} else {
			e.WriteString(f.nameNonEsc)
		}
		opts.quoted = f.quoted
		f.encoder(e, fv, opts)
	}
	if next == '{' {
		e.WriteString("{}")
	} else {
		e.WriteByte('}')
	}
}

func newStructEncoder(t reflect.Type) encoderFunc {
	se := structEncoder{fields: cachedTypeFields(t)}
	return se.encode
}

type mapEncoder struct {
	elemEnc encoderFunc
}

func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString("null")
		return
	}
	if e.ptrLevel++; e.ptrLevel > startDetectingCyclesAfter {
		// We're a large number of nested ptrEncoder.encode calls deep;
		// start checking if we've run into a pointer cycle.
		ptr := v.Pointer()
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	e.WriteByte('{')

	// Extract and sort the keys.
	keys := v.MapKeys()
	sv := make([]reflectWithString, len(keys))
	for i, v := range keys {
		sv[i].v = v
		if err := sv[i].resolve(); err != nil {
			e.error(fmt.Errorf("json: encoding error for type %q: %q", v.Type().String(), err.Error()))
		}
	}
	sort.Slice(sv, func(i, j int) bool { return sv[i].s < sv[j].s })

	for i, kv := range sv {
		if i > 0 {
			e.WriteByte(',')
		}
		e.string(kv.s, opts.escapeHTML)
		e.WriteByte(':')
		me.elemEnc(e, v.MapIndex(kv.v), opts)
	}
	e.WriteByte('}')
	e.ptrLevel--
}

func newMapEncoder(t reflect.Type) encoderFunc {
	switch t.Key().Kind() {
	case reflect.String,
		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
	default:
		if !t.Key().Implements(textMarshalerType) {
			return unsupportedTypeEncoder
		}
	}
	me := mapEncoder{typeEncoder(t.Elem())}
	return me.encode
}

func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts) {
	if v.IsNil() {
		e.WriteString("null")
		return
	}
	s := v.Bytes()
	e.WriteByte('"')
	encodedLen := base64.StdEncoding.EncodedLen(len(s))
	if encodedLen <= len(e.scratch) {
		// If the encoded bytes fit in e.scratch, avoid an extra
		// allocation and use the cheaper Encoding.Encode.
		dst := e.scratch[:encodedLen]
		base64.StdEncoding.Encode(dst, s)
		e.Write(dst)
	} else if encodedLen <= 1024 {
		// The encoded bytes are short enough to allocate for, and
		// Encoding.Encode is still cheaper.
		dst := make([]byte, encodedLen)
		base64.StdEncoding.Encode(dst, s)
		e.Write(dst)
	} else {
		// The encoded bytes are too long to cheaply allocate, and
		// Encoding.Encode is no longer noticeably cheaper.
		enc := base64.NewEncoder(base64.StdEncoding, e)
		enc.Write(s)
		enc.Close()
	}
	e.WriteByte('"')
}

// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.
type sliceEncoder struct {
	arrayEnc encoderFunc
}

func (se sliceEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString("null")
		return
	}
	if e.ptrLevel++; e.ptrLevel > startDetectingCyclesAfter {
		// We're a large number of nested ptrEncoder.encode calls deep;
		// start checking if we've run into a pointer cycle.
		// Here we use a struct to memorize the pointer to the first element of the slice
		// and its length.
		ptr := struct {
			ptr uintptr
			len int
		}{v.Pointer(), v.Len()}
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	se.arrayEnc(e, v, opts)
	e.ptrLevel--
}

func newSliceEncoder(t reflect.Type) encoderFunc {
	// Byte slices get special treatment; arrays don't.
	if t.Elem().Kind() == reflect.Uint8 {
		p := reflect.PtrTo(t.Elem())
		if !p.Implements(marshalerType) && !p.Implements(textMarshalerType) {
			return encodeByteSlice
		}
	}
	enc := sliceEncoder{newArrayEncoder(t)}
	return enc.encode
}

type arrayEncoder struct {
	elemEnc encoderFunc
}

func (ae arrayEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	e.WriteByte('[')
	n := v.Len()
	for i := 0; i < n; i++ {
		if i > 0 {
			e.WriteByte(',')
		}
		ae.elemEnc(e, v.Index(i), opts)
	}
	e.WriteByte(']')
}

func newArrayEncoder(t reflect.Type) encoderFunc {
	enc := arrayEncoder{typeEncoder(t.Elem())}
	return enc.encode
}

type ptrEncoder struct {
	elemEnc encoderFunc
}

func (pe ptrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString("null")
		return
	}
	if e.ptrLevel++; e.ptrLevel > startDetectingCyclesAfter {
		// We're a large number of nested ptrEncoder.encode calls deep;
		// start checking if we've run into a pointer cycle.
		ptr := v.Interface()
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&UnsupportedValueError{v, fmt.Sprintf("encountered a cycle via %s", v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	pe.elemEnc(e, v.Elem(), opts)
	e.ptrLevel--
}

func newPtrEncoder(t reflect.Type) encoderFunc {
	enc := ptrEncoder{typeEncoder(t.Elem())}
	return enc.encode
}

type condAddrEncoder struct {
	canAddrEnc, elseEnc encoderFunc
}

func (ce condAddrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.CanAddr() {
		ce.canAddrEnc(e, v, opts)
	} else {
		ce.elseEnc(e, v, opts)
	}
}

// newCondAddrEncoder returns an encoder that checks whether its value
// CanAddr and delegates to canAddrEnc if so, else to elseEnc.
func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {
	enc := condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}
	return enc.encode
}

func isValidTag(s string) bool {
	if s == "" {
		return false
	}
	for _, c := range s {
		switch {
		case strings.ContainsRune("!#$%&()*+-./:;<=>?@[]^_{|}~ ", c):
			// Backslash and quote chars are reserved, but
			// otherwise any punctuation chars are allowed
			// in a tag name.
		case !unicode.IsLetter(c) && !unicode.IsDigit(c):
			return false
		}
	}
	return true
}

func typeByIndex(t reflect.Type, index []int) reflect.Type {
	for _, i := range index {
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}
		t = t.Field(i).Type
	}
	return t
}

type reflectWithString struct {
	v reflect.Value
	s string
}

func (w *reflectWithString) resolve() error {
	if w.v.Kind() == reflect.String {
		w.s = w.v.String()
		return nil
	}
	if tm, ok := w.v.Interface().(encoding.TextMarshaler); ok {
		if w.v.Kind() == reflect.Ptr && w.v.IsNil() {
			return nil
		}
		buf, err := tm.MarshalText()
		w.s = string(buf)
		return err
	}
	switch w.v.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		w.s = strconv.FormatInt(w.v.Int(), 10)
		return nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		w.s = strconv.FormatUint(w.v.Uint(), 10)
		return nil
	}
	panic("unexpected map key type")
}

// NOTE: keep in sync with stringBytes below.
func (e *encodeState) string(s string, escapeHTML bool) {
	e.WriteByte('"')
	start := 0
	for i := 0; i < len(s); {
		if b := s[i]; b < utf8.RuneSelf {
			if htmlSafeSet[b] || (!escapeHTML && safeSet[b]) {
				i++
				continue
			}
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteByte('\\')
			switch b {
			case '\\', '"':
				e.WriteByte(b)
			case '\n':
				e.WriteByte('n')
			case '\r':
				e.WriteByte('r')
			case '\t':
				e.WriteByte('t')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(hex[b>>4])
				e.WriteByte(hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		c, size := utf8.DecodeRuneInString(s[i:])
		if c == utf8.RuneError && size == 1 {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i += size
			start = i
			continue
		}
		// U+2028 is LINE SEPARATOR.
		// U+2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don't work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == '\u2028' || c == '\u2029' {
			if start < i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(hex[c&0xF])
			i += size
			start = i
			continue
		}
		i += size
	}
	if start < len(s) {
		e.WriteString(s[start:])
	}
	e.WriteByte('"')
}

// NOTE: keep in sync with string above.
func (e *encodeState) stringBytes(s []byte, escapeHTML bool) {
	e.WriteByte('"')
	start := 0
	for i := 0; i < len(s); {
		if b := s[i]; b < utf8.RuneSelf {
			if htmlSafeSet[b] || (!escapeHTML && safeSet[b]) {
				i++
				continue
			}
			if start < i {
				e.Write(s[start:i])
			}
			e.WriteByte('\\')
			switch b {
			case '\\', '"':
				e.WriteByte(b)
			case '\n':
				e.WriteByte('n')
			case '\r':
				e.WriteByte('r')
			case '\t':
				e.WriteByte('t')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(hex[b>>4])
				e.WriteByte(hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		c, size := utf8.DecodeRune(s[i:])
		if c == utf8.RuneError && size == 1 {
			if start < i {
				e.Write(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i += size
			start = i
			continue
		}
		// U+2028 is LINE SEPARATOR.
		// U+2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don't work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == '\u2028' || c == '\u2029' {
			if start < i {
				e.Write(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(hex[c&0xF])
			i += size
			start = i
			continue
		}
		i += size
	}
	if start < len(s) {
		e.Write(s[start:])
	}
	e.WriteByte('"')
}

// A field represents a single field found in a struct.
type field struct {
	name      string
	nameBytes []byte                 // []byte(name)
	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent

	nameNonEsc  string // `"` + name + `":`
	nameEscHTML string // `"` + HTMLEscape(name) + `":`

	tag       bool
	index     []int
	typ       reflect.Type
	omitEmpty bool
	quoted    bool

	encoder encoderFunc
}

// byIndex sorts field by index sequence.
type byIndex []field

func (x byIndex) Len() int { return len(x) }

func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }

func (x byIndex) Less(i, j int) bool {
	for k, xik := range x[i].index {
		if k >= len(x[j].index) {
			return false
		}
		if xik != x[j].index[k] {
			return xik < x[j].index[k]
		}
	}
	return len(x[i].index) < len(x[j].index)
}

// typeFields returns a list of fields that JSON should recognize for the given type.
// The algorithm is breadth-first search over the set of structs to include - the top struct
// and then any reachable anonymous structs.
func typeFields(t reflect.Type) structFields {
	// Anonymous fields to explore at the current level and the next.
	current := []field{}
	next := []field{{typ: t}}

	// Count of queued names for current level and the next.
	var count, nextCount map[reflect.Type]int

	// Types already visited at an earlier level.
	visited := map[reflect.Type]bool{}

	// Fields found.
	var fields []field

	// Buffer to run HTMLEscape on field names.
	var nameEscBuf bytes.Buffer

	for len(next) > 0 {
		current, next = next, current[:0]
		count, nextCount = nextCount, map[reflect.Type]int{}

		for _, f := range current {
			if visited[f.typ] {
				continue
			}
			visited[f.typ] = true

			// Scan f.typ for fields to include.
			for i := 0; i < f.typ.NumField(); i++ {
				sf := f.typ.Field(i)
				isUnexported := sf.PkgPath != ""
				if sf.Anonymous {
					t := sf.Type
					if t.Kind() == reflect.Ptr {
						t = t.Elem()
					}
					if isUnexported && t.Kind() != reflect.Struct {
						// Ignore embedded fields of unexported non-struct types.
						continue
					}
					// Do not ignore embedded fields of unexported struct types
					// since they may have exported fields.
				} else if isUnexported {
					// Ignore unexported non-embedded fields.
					continue
				}
				tag := sf.Tag.Get("json")
				if tag == "-" {
					continue
				}
				name, opts := parseTag(tag)
				if !isValidTag(name) {
					name = ""
				}
				index := make([]int, len(f.index)+1)
				copy(index, f.index)
				index[len(f.index)] = i

				ft := sf.Type
				if ft.Name() == "" && ft.Kind() == reflect.Ptr {
					// Follow pointer.
					ft = ft.Elem()
				}

				// Only strings, floats, integers, and booleans can be quoted.
				quoted := false
				if opts.Contains("string") {
					switch ft.Kind() {
					case reflect.Bool,
						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
						reflect.Float32, reflect.Float64,
						reflect.String:
						quoted = true
					}
				}

				// Record found field and index sequence.
				if name != "" || !sf.Anonymous || ft.Kind() != reflect.Struct {
					tagged := name != ""
					if name == "" {
						name = sf.Name
					}
					field := field{
						name:      name,
						tag:       tagged,
						index:     index,
						typ:       ft,
						omitEmpty: opts.Contains("omitempty"),
						quoted:    quoted,
					}
					field.nameBytes = []byte(field.name)
					field.equalFold = foldFunc(field.nameBytes)

					// Build nameEscHTML and nameNonEsc ahead of time.
					nameEscBuf.Reset()
					nameEscBuf.WriteString(`"`)
					HTMLEscape(&nameEscBuf, field.nameBytes)
					nameEscBuf.WriteString(`":`)
					field.nameEscHTML = nameEscBuf.String()
					field.nameNonEsc = `"` + field.name + `":`

					fields = append(fields, field)
					if count[f.typ] > 1 {
						// If there were multiple instances, add a second,
						// so that the annihilation code will see a duplicate.
						// It only cares about the distinction between 1 or 2,
						// so don't bother generating any more copies.
						fields = append(fields, fields[len(fields)-1])
					}
					continue
				}

				// Record new anonymous struct to explore in next round.
				nextCount[ft]++
				if nextCount[ft] == 1 {
					next = append(next, field{name: ft.Name(), index: index, typ: ft})
				}
			}
		}
	}

	sort.Slice(fields, func(i, j int) bool {
		x := fields
		// sort field by name, breaking ties with depth, then
		// breaking ties with "name came from json tag", then
		// breaking ties with index sequence.
		if x[i].name != x[j].name {
			return x[i].name < x[j].name
		}
		if len(x[i].index) != len(x[j].index) {
			return len(x[i].index) < len(x[j].index)
		}
		if x[i].tag != x[j].tag {
			return x[i].tag
		}
		return byIndex(x).Less(i, j)
	})

	// Delete all fields that are hidden by the Go rules for embedded fields,
	// except that fields with JSON tags are promoted.

	// The fields are sorted in primary order of name, secondary order
	// of field index length. Loop over names; for each name, delete
	// hidden fields by choosing the one dominant field that survives.
	out := fields[:0]
	for advance, i := 0, 0; i < len(fields); i += advance {
		// One iteration per name.
		// Find the sequence of fields with the name of this first field.
		fi := fields[i]
		name := fi.name
		for advance = 1; i+advance < len(fields); advance++ {
			fj := fields[i+advance]
			if fj.name != name {
				break
			}
		}
		if advance == 1 { // Only one field with this name
			out = append(out, fi)
			continue
		}
		dominant, ok := dominantField(fields[i : i+advance])
		if ok {
			out = append(out, dominant)
		}
	}

	fields = out
	sort.Sort(byIndex(fields))

	for i := range fields {
		f := &fields[i]
		f.encoder = typeEncoder(typeByIndex(t, f.index))
	}
	nameIndex := make(map[string]int, len(fields))
	for i, field := range fields {
		nameIndex[field.name] = i
	}
	return structFields{fields, nameIndex}
}

// dominantField looks through the fields, all of which are known to
// have the same name, to find the single field that dominates the
// others using Go's embedding rules, modified by the presence of
// JSON tags. If there are multiple top-level fields, the boolean
// will be false: This condition is an error in Go and we skip all
// the fields.
func dominantField(fields []field) (field, bool) {
	// The fields are sorted in increasing index-length order, then by presence of tag.
	// That means that the first field is the dominant one. We need only check
	// for error cases: two fields at top level, either both tagged or neither tagged.
	if len(fields) > 1 && len(fields[0].index) == len(fields[1].index) && fields[0].tag == fields[1].tag {
		return field{}, false
	}
	return fields[0], true
}

var fieldCache sync.Map // map[reflect.Type]structFields

// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
func cachedTypeFields(t reflect.Type) structFields {
	if f, ok := fieldCache.Load(t); ok {
		return f.(structFields)
	}
	f, _ := fieldCache.LoadOrStore(t, typeFields(t))
	return f.(structFields)
}

'''
'''--- pkg/platon/fold.go ---
package platon

import (
	"bytes"
	"unicode/utf8"
)

const (
	caseMask     = ^byte(0x20) // Mask to ignore case in ASCII.
	kelvin       = '\u212a'
	smallLongEss = '\u017f'
)

// foldFunc returns one of four different case folding equivalence
// functions, from most general (and slow) to fastest:
//
// 1) bytes.EqualFold, if the key s contains any non-ASCII UTF-8
// 2) equalFoldRight, if s contains special folding ASCII ('k', 'K', 's', 'S')
// 3) asciiEqualFold, no special, but includes non-letters (including _)
// 4) simpleLetterEqualFold, no specials, no non-letters.
//
// The letters S and K are special because they map to 3 runes, not just 2:
//  * S maps to s and to U+017F 'ſ' Latin small letter long s
//  * k maps to K and to U+212A 'K' Kelvin sign
// See https://play.golang.org/p/tTxjOc0OGo
//
// The returned function is specialized for matching against s and
// should only be given s. It's not curried for performance reasons.
func foldFunc(s []byte) func(s, t []byte) bool {
	nonLetter := false
	special := false // special letter
	for _, b := range s {
		if b >= utf8.RuneSelf {
			return bytes.EqualFold
		}
		upper := b & caseMask
		if upper < 'A' || upper > 'Z' {
			nonLetter = true
		} else if upper == 'K' || upper == 'S' {
			// See above for why these letters are special.
			special = true
		}
	}
	if special {
		return equalFoldRight
	}
	if nonLetter {
		return asciiEqualFold
	}
	return simpleLetterEqualFold
}

// equalFoldRight is a specialization of bytes.EqualFold when s is
// known to be all ASCII (including punctuation), but contains an 's',
// 'S', 'k', or 'K', requiring a Unicode fold on the bytes in t.
// See comments on foldFunc.
func equalFoldRight(s, t []byte) bool {
	for _, sb := range s {
		if len(t) == 0 {
			return false
		}
		tb := t[0]
		if tb < utf8.RuneSelf {
			if sb != tb {
				sbUpper := sb & caseMask
				if 'A' <= sbUpper && sbUpper <= 'Z' {
					if sbUpper != tb&caseMask {
						return false
					}
				} else {
					return false
				}
			}
			t = t[1:]
			continue
		}
		// sb is ASCII and t is not. t must be either kelvin
		// sign or long s; sb must be s, S, k, or K.
		tr, size := utf8.DecodeRune(t)
		switch sb {
		case 's', 'S':
			if tr != smallLongEss {
				return false
			}
		case 'k', 'K':
			if tr != kelvin {
				return false
			}
		default:
			return false
		}
		t = t[size:]

	}
	if len(t) > 0 {
		return false
	}
	return true
}

// asciiEqualFold is a specialization of bytes.EqualFold for use when
// s is all ASCII (but may contain non-letters) and contains no
// special-folding letters.
// See comments on foldFunc.
func asciiEqualFold(s, t []byte) bool {
	if len(s) != len(t) {
		return false
	}
	for i, sb := range s {
		tb := t[i]
		if sb == tb {
			continue
		}
		if ('a' <= sb && sb <= 'z') || ('A' <= sb && sb <= 'Z') {
			if sb&caseMask != tb&caseMask {
				return false
			}
		} else {
			return false
		}
	}
	return true
}

// simpleLetterEqualFold is a specialization of bytes.EqualFold for
// use when s is all ASCII letters (no underscores, etc) and also
// doesn't contain 'k', 'K', 's', or 'S'.
// See comments on foldFunc.
func simpleLetterEqualFold(s, t []byte) bool {
	if len(s) != len(t) {
		return false
	}
	for i, b := range s {
		if b&caseMask != t[i]&caseMask {
			return false
		}
	}
	return true
}

'''
'''--- pkg/platon/ident.go ---
package platon

import (
	"bytes"
)

// Compact appends to dst the JSON-encoded src with
// insignificant space characters elided.
func Compact(dst *bytes.Buffer, src []byte) error {
	return compact(dst, src, false)
}

func compact(dst *bytes.Buffer, src []byte, escape bool) error {
	origLen := dst.Len()
	scan := newScanner()
	defer freeScanner(scan)
	start := 0
	for i, c := range src {
		if escape && (c == '<' || c == '>' || c == '&') {
			if start < i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u00`)
			dst.WriteByte(hex[c>>4])
			dst.WriteByte(hex[c&0xF])
			start = i + 1
		}
		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
		if escape && c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
			if start < i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u202`)
			dst.WriteByte(hex[src[i+2]&0xF])
			start = i + 3
		}
		v := scan.step(scan, c)
		if v >= scanSkipSpace {
			if v == scanError {
				break
			}
			if start < i {
				dst.Write(src[start:i])
			}
			start = i + 1
		}
	}
	if scan.eof() == scanError {
		dst.Truncate(origLen)
		return scan.err
	}
	if start < len(src) {
		dst.Write(src[start:])
	}
	return nil
}

func newline(dst *bytes.Buffer, prefix, indent string, depth int) {
	dst.WriteByte('\n')
	dst.WriteString(prefix)
	for i := 0; i < depth; i++ {
		dst.WriteString(indent)
	}
}

// Indent appends to dst an indented form of the JSON-encoded src.
// Each element in a JSON object or array begins on a new,
// indented line beginning with prefix followed by one or more
// copies of indent according to the indentation nesting.
// The data appended to dst does not begin with the prefix nor
// any indentation, to make it easier to embed inside other formatted JSON data.
// Although leading space characters (space, tab, carriage return, newline)
// at the beginning of src are dropped, trailing space characters
// at the end of src are preserved and copied to dst.
// For example, if src has no trailing spaces, neither will dst;
// if src ends in a trailing newline, so will dst.
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {
	origLen := dst.Len()
	scan := newScanner()
	defer freeScanner(scan)
	needIndent := false
	depth := 0
	for _, c := range src {
		scan.bytes++
		v := scan.step(scan, c)
		if v == scanSkipSpace {
			continue
		}
		if v == scanError {
			break
		}
		if needIndent && v != scanEndObject && v != scanEndArray {
			needIndent = false
			depth++
			newline(dst, prefix, indent, depth)
		}

		// Emit semantically uninteresting bytes
		// (in particular, punctuation in strings) unmodified.
		if v == scanContinue {
			dst.WriteByte(c)
			continue
		}

		// Add spacing around real punctuation.
		switch c {
		case '{', '[':
			// delay indent so that empty object and array are formatted as {} and [].
			needIndent = true
			dst.WriteByte(c)

		case ',':
			dst.WriteByte(c)
			newline(dst, prefix, indent, depth)

		case ':':
			dst.WriteByte(c)
			dst.WriteByte(' ')

		case '}', ']':
			if needIndent {
				// suppress indent in empty object/array
				needIndent = false
			} else {
				depth--
				newline(dst, prefix, indent, depth)
			}
			dst.WriteByte(c)

		default:
			dst.WriteByte(c)
		}
	}
	if scan.eof() == scanError {
		dst.Truncate(origLen)
		return scan.err
	}
	return nil
}

'''
'''--- pkg/platon/scanner.go ---
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package platon

// JSON value parser state machine.
// Just about at the limit of what is reasonable to write by hand.
// Some parts are a bit tedious, but overall it nicely factors out the
// otherwise common code from the multiple scanning functions
// in this package (Compact, Indent, checkValid, etc).
//
// This file starts with two simple examples using the scanner
// before diving into the scanner itself.

import (
	"strconv"
	"sync"
)

// Valid reports whether data is a valid JSON encoding.
func Valid(data []byte) bool {
	scan := newScanner()
	defer freeScanner(scan)
	return checkValid(data, scan) == nil
}

// checkValid verifies that data is valid JSON-encoded data.
// scan is passed in for use by checkValid to avoid an allocation.
func checkValid(data []byte, scan *scanner) error {
	scan.reset()
	for _, c := range data {
		scan.bytes++
		if scan.step(scan, c) == scanError {
			return scan.err
		}
	}
	if scan.eof() == scanError {
		return scan.err
	}
	return nil
}

// A SyntaxError is a description of a JSON syntax error.
type SyntaxError struct {
	msg    string // description of error
	Offset int64  // error occurred after reading Offset bytes
}

func (e *SyntaxError) Error() string { return e.msg }

// A scanner is a JSON scanning state machine.
// Callers call scan.reset and then pass bytes in one at a time
// by calling scan.step(&scan, c) for each byte.
// The return value, referred to as an opcode, tells the
// caller about significant parsing events like beginning
// and ending literals, objects, and arrays, so that the
// caller can follow along if it wishes.
// The return value scanEnd indicates that a single top-level
// JSON value has been completed, *before* the byte that
// just got passed in.  (The indication must be delayed in order
// to recognize the end of numbers: is 123 a whole value or
// the beginning of 12345e+6?).
type scanner struct {
	// The step is a func to be called to execute the next transition.
	// Also tried using an integer constant and a single func
	// with a switch, but using the func directly was 10% faster
	// on a 64-bit Mac Mini, and it's nicer to read.
	step func(*scanner, byte) int

	// Reached end of top-level value.
	endTop bool

	// Stack of what we're in the middle of - array values, object keys, object values.
	parseState []int

	// Error that happened, if any.
	err error

	// total bytes consumed, updated by decoder.Decode (and deliberately
	// not set to zero by scan.reset)
	bytes int64
}

var scannerPool = sync.Pool{
	New: func() interface{} {
		return &scanner{}
	},
}

func newScanner() *scanner {
	scan := scannerPool.Get().(*scanner)
	// scan.reset by design doesn't set bytes to zero
	scan.bytes = 0
	scan.reset()
	return scan
}

func freeScanner(scan *scanner) {
	// Avoid hanging on to too much memory in extreme cases.
	if len(scan.parseState) > 1024 {
		scan.parseState = nil
	}
	scannerPool.Put(scan)
}

// These values are returned by the state transition functions
// assigned to scanner.state and the method scanner.eof.
// They give details about the current state of the scan that
// callers might be interested to know about.
// It is okay to ignore the return value of any particular
// call to scanner.state: if one call returns scanError,
// every subsequent call will return scanError too.
const (
	// Continue.
	scanContinue     = iota // uninteresting byte
	scanBeginLiteral        // end implied by next result != scanContinue
	scanBeginObject         // begin object
	scanObjectKey           // just finished object key (string)
	scanObjectValue         // just finished non-last object value
	scanEndObject           // end object (implies scanObjectValue if possible)
	scanBeginArray          // begin array
	scanArrayValue          // just finished array value
	scanEndArray            // end array (implies scanArrayValue if possible)
	scanSkipSpace           // space byte; can skip; known to be last "continue" result

	// Stop.
	scanEnd   // top-level value ended *before* this byte; known to be first "stop" result
	scanError // hit an error, scanner.err.
)

// These values are stored in the parseState stack.
// They give the current state of a composite value
// being scanned. If the parser is inside a nested value
// the parseState describes the nested state, outermost at entry 0.
const (
	parseObjectKey   = iota // parsing object key (before colon)
	parseObjectValue        // parsing object value (after colon)
	parseArrayValue         // parsing array value
)

// This limits the max nesting depth to prevent stack overflow.
// This is permitted by https://tools.ietf.org/html/rfc7159#section-9
const maxNestingDepth = 10000

// reset prepares the scanner for use.
// It must be called before calling s.step.
func (s *scanner) reset() {
	s.step = stateBeginValue
	s.parseState = s.parseState[0:0]
	s.err = nil
	s.endTop = false
}

// eof tells the scanner that the end of input has been reached.
// It returns a scan status just as s.step does.
func (s *scanner) eof() int {
	if s.err != nil {
		return scanError
	}
	if s.endTop {
		return scanEnd
	}
	s.step(s, ' ')
	if s.endTop {
		return scanEnd
	}
	if s.err == nil {
		s.err = &SyntaxError{"unexpected end of JSON input", s.bytes}
	}
	return scanError
}

// pushParseState pushes a new parse state p onto the parse stack.
// an error state is returned if maxNestingDepth was exceeded, otherwise successState is returned.
func (s *scanner) pushParseState(c byte, newParseState int, successState int) int {
	s.parseState = append(s.parseState, newParseState)
	if len(s.parseState) <= maxNestingDepth {
		return successState
	}
	return s.error(c, "exceeded max depth")
}

// popParseState pops a parse state (already obtained) off the stack
// and updates s.step accordingly.
func (s *scanner) popParseState() {
	n := len(s.parseState) - 1
	s.parseState = s.parseState[0:n]
	if n == 0 {
		s.step = stateEndTop
		s.endTop = true
	} else {
		s.step = stateEndValue
	}
}

func isSpace(c byte) bool {
	return c <= ' ' && (c == ' ' || c == '\t' || c == '\r' || c == '\n')
}

// stateBeginValueOrEmpty is the state after reading `[`.
func stateBeginValueOrEmpty(s *scanner, c byte) int {
	if isSpace(c) {
		return scanSkipSpace
	}
	if c == ']' {
		return stateEndValue(s, c)
	}
	return stateBeginValue(s, c)
}

// stateBeginValue is the state at the beginning of the input.
func stateBeginValue(s *scanner, c byte) int {
	if isSpace(c) {
		return scanSkipSpace
	}
	switch c {
	case '{':
		s.step = stateBeginStringOrEmpty
		return s.pushParseState(c, parseObjectKey, scanBeginObject)
	case '[':
		s.step = stateBeginValueOrEmpty
		return s.pushParseState(c, parseArrayValue, scanBeginArray)
	case '"':
		s.step = stateInString
		return scanBeginLiteral
	case '-':
		s.step = stateNeg
		return scanBeginLiteral
	case '0': // beginning of 0.123
		s.step = state0
		return scanBeginLiteral
	case 't': // beginning of true
		s.step = stateT
		return scanBeginLiteral
	case 'f': // beginning of false
		s.step = stateF
		return scanBeginLiteral
	case 'n': // beginning of null
		s.step = stateN
		return scanBeginLiteral
	}
	if '1' <= c && c <= '9' { // beginning of 1234.5
		s.step = state1
		return scanBeginLiteral
	}
	return s.error(c, "looking for beginning of value")
}

// stateBeginStringOrEmpty is the state after reading `{`.
func stateBeginStringOrEmpty(s *scanner, c byte) int {
	if isSpace(c) {
		return scanSkipSpace
	}
	if c == '}' {
		n := len(s.parseState)
		s.parseState[n-1] = parseObjectValue
		return stateEndValue(s, c)
	}
	return stateBeginString(s, c)
}

// stateBeginString is the state after reading `{"key": value,`.
func stateBeginString(s *scanner, c byte) int {
	if isSpace(c) {
		return scanSkipSpace
	}
	if c == '"' {
		s.step = stateInString
		return scanBeginLiteral
	}
	return s.error(c, "looking for beginning of object key string")
}

// stateEndValue is the state after completing a value,
// such as after reading `{}` or `true` or `["x"`.
func stateEndValue(s *scanner, c byte) int {
	n := len(s.parseState)
	if n == 0 {
		// Completed top-level before the current byte.
		s.step = stateEndTop
		s.endTop = true
		return stateEndTop(s, c)
	}
	if isSpace(c) {
		s.step = stateEndValue
		return scanSkipSpace
	}
	ps := s.parseState[n-1]
	switch ps {
	case parseObjectKey:
		if c == ':' {
			s.parseState[n-1] = parseObjectValue
			s.step = stateBeginValue
			return scanObjectKey
		}
		return s.error(c, "after object key")
	case parseObjectValue:
		if c == ',' {
			s.parseState[n-1] = parseObjectKey
			s.step = stateBeginString
			return scanObjectValue
		}
		if c == '}' {
			s.popParseState()
			return scanEndObject
		}
		return s.error(c, "after object key:value pair")
	case parseArrayValue:
		if c == ',' {
			s.step = stateBeginValue
			return scanArrayValue
		}
		if c == ']' {
			s.popParseState()
			return scanEndArray
		}
		return s.error(c, "after array element")
	}
	return s.error(c, "")
}

// stateEndTop is the state after finishing the top-level value,
// such as after reading `{}` or `[1,2,3]`.
// Only space characters should be seen now.
func stateEndTop(s *scanner, c byte) int {
	if !isSpace(c) {
		// Complain about non-space byte on next call.
		s.error(c, "after top-level value")
	}
	return scanEnd
}

// stateInString is the state after reading `"`.
func stateInString(s *scanner, c byte) int {
	if c == '"' {
		s.step = stateEndValue
		return scanContinue
	}
	if c == '\\' {
		s.step = stateInStringEsc
		return scanContinue
	}
	if c < 0x20 {
		return s.error(c, "in string literal")
	}
	return scanContinue
}

// stateInStringEsc is the state after reading `"\` during a quoted string.
func stateInStringEsc(s *scanner, c byte) int {
	switch c {
	case 'b', 'f', 'n', 'r', 't', '\\', '/', '"':
		s.step = stateInString
		return scanContinue
	case 'u':
		s.step = stateInStringEscU
		return scanContinue
	}
	return s.error(c, "in string escape code")
}

// stateInStringEscU is the state after reading `"\u` during a quoted string.
func stateInStringEscU(s *scanner, c byte) int {
	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
		s.step = stateInStringEscU1
		return scanContinue
	}
	// numbers
	return s.error(c, "in \\u hexadecimal character escape")
}

// stateInStringEscU1 is the state after reading `"\u1` during a quoted string.
func stateInStringEscU1(s *scanner, c byte) int {
	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
		s.step = stateInStringEscU12
		return scanContinue
	}
	// numbers
	return s.error(c, "in \\u hexadecimal character escape")
}

// stateInStringEscU12 is the state after reading `"\u12` during a quoted string.
func stateInStringEscU12(s *scanner, c byte) int {
	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
		s.step = stateInStringEscU123
		return scanContinue
	}
	// numbers
	return s.error(c, "in \\u hexadecimal character escape")
}

// stateInStringEscU123 is the state after reading `"\u123` during a quoted string.
func stateInStringEscU123(s *scanner, c byte) int {
	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
		s.step = stateInString
		return scanContinue
	}
	// numbers
	return s.error(c, "in \\u hexadecimal character escape")
}

// stateNeg is the state after reading `-` during a number.
func stateNeg(s *scanner, c byte) int {
	if c == '0' {
		s.step = state0
		return scanContinue
	}
	if '1' <= c && c <= '9' {
		s.step = state1
		return scanContinue
	}
	return s.error(c, "in numeric literal")
}

// state1 is the state after reading a non-zero integer during a number,
// such as after reading `1` or `100` but not `0`.
func state1(s *scanner, c byte) int {
	if '0' <= c && c <= '9' {
		s.step = state1
		return scanContinue
	}
	return state0(s, c)
}

// state0 is the state after reading `0` during a number.
func state0(s *scanner, c byte) int {
	if c == '.' {
		s.step = stateDot
		return scanContinue
	}
	if c == 'e' || c == 'E' {
		s.step = stateE
		return scanContinue
	}
	return stateEndValue(s, c)
}

// stateDot is the state after reading the integer and decimal point in a number,
// such as after reading `1.`.
func stateDot(s *scanner, c byte) int {
	if '0' <= c && c <= '9' {
		s.step = stateDot0
		return scanContinue
	}
	return s.error(c, "after decimal point in numeric literal")
}

// stateDot0 is the state after reading the integer, decimal point, and subsequent
// digits of a number, such as after reading `3.14`.
func stateDot0(s *scanner, c byte) int {
	if '0' <= c && c <= '9' {
		return scanContinue
	}
	if c == 'e' || c == 'E' {
		s.step = stateE
		return scanContinue
	}
	return stateEndValue(s, c)
}

// stateE is the state after reading the mantissa and e in a number,
// such as after reading `314e` or `0.314e`.
func stateE(s *scanner, c byte) int {
	if c == '+' || c == '-' {
		s.step = stateESign
		return scanContinue
	}
	return stateESign(s, c)
}

// stateESign is the state after reading the mantissa, e, and sign in a number,
// such as after reading `314e-` or `0.314e+`.
func stateESign(s *scanner, c byte) int {
	if '0' <= c && c <= '9' {
		s.step = stateE0
		return scanContinue
	}
	return s.error(c, "in exponent of numeric literal")
}

// stateE0 is the state after reading the mantissa, e, optional sign,
// and at least one digit of the exponent in a number,
// such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
func stateE0(s *scanner, c byte) int {
	if '0' <= c && c <= '9' {
		return scanContinue
	}
	return stateEndValue(s, c)
}

// stateT is the state after reading `t`.
func stateT(s *scanner, c byte) int {
	if c == 'r' {
		s.step = stateTr
		return scanContinue
	}
	return s.error(c, "in literal true (expecting 'r')")
}

// stateTr is the state after reading `tr`.
func stateTr(s *scanner, c byte) int {
	if c == 'u' {
		s.step = stateTru
		return scanContinue
	}
	return s.error(c, "in literal true (expecting 'u')")
}

// stateTru is the state after reading `tru`.
func stateTru(s *scanner, c byte) int {
	if c == 'e' {
		s.step = stateEndValue
		return scanContinue
	}
	return s.error(c, "in literal true (expecting 'e')")
}

// stateF is the state after reading `f`.
func stateF(s *scanner, c byte) int {
	if c == 'a' {
		s.step = stateFa
		return scanContinue
	}
	return s.error(c, "in literal false (expecting 'a')")
}

// stateFa is the state after reading `fa`.
func stateFa(s *scanner, c byte) int {
	if c == 'l' {
		s.step = stateFal
		return scanContinue
	}
	return s.error(c, "in literal false (expecting 'l')")
}

// stateFal is the state after reading `fal`.
func stateFal(s *scanner, c byte) int {
	if c == 's' {
		s.step = stateFals
		return scanContinue
	}
	return s.error(c, "in literal false (expecting 's')")
}

// stateFals is the state after reading `fals`.
func stateFals(s *scanner, c byte) int {
	if c == 'e' {
		s.step = stateEndValue
		return scanContinue
	}
	return s.error(c, "in literal false (expecting 'e')")
}

// stateN is the state after reading `n`.
func stateN(s *scanner, c byte) int {
	if c == 'u' {
		s.step = stateNu
		return scanContinue
	}
	return s.error(c, "in literal null (expecting 'u')")
}

// stateNu is the state after reading `nu`.
func stateNu(s *scanner, c byte) int {
	if c == 'l' {
		s.step = stateNul
		return scanContinue
	}
	return s.error(c, "in literal null (expecting 'l')")
}

// stateNul is the state after reading `nul`.
func stateNul(s *scanner, c byte) int {
	if c == 'l' {
		s.step = stateEndValue
		return scanContinue
	}
	return s.error(c, "in literal null (expecting 'l')")
}

// stateError is the state after reaching a syntax error,
// such as after reading `[1}` or `5.1.2`.
func stateError(s *scanner, c byte) int {
	return scanError
}

// error records an error and switches to the error state.
func (s *scanner) error(c byte, context string) int {
	s.step = stateError
	s.err = &SyntaxError{"invalid character " + quoteChar(c) + " " + context, s.bytes}
	return scanError
}

// quoteChar formats c as a quoted character literal
func quoteChar(c byte) string {
	// special cases - different from quoted strings
	if c == '\'' {
		return `'\''`
	}
	if c == '"' {
		return `'"'`
	}

	// use quoted string with different quotation marks
	s := strconv.Quote(string(c))
	return "'" + s[1:len(s)-1] + "'"
}

'''
'''--- pkg/platon/stream.go ---
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package platon

import (
	"bytes"
	"errors"
	"io"
)

// A Decoder reads and decodes JSON values from an input stream.
type Decoder struct {
	r       io.Reader
	buf     []byte
	d       decodeState
	scanp   int   // start of unread data in buf
	scanned int64 // amount of data already scanned
	scan    scanner
	err     error

	tokenState int
	tokenStack []int
}

// NewDecoder returns a new decoder that reads from r.
//
// The decoder introduces its own buffering and may
// read data from r beyond the JSON values requested.
func NewDecoder(r io.Reader) *Decoder {
	return &Decoder{r: r}
}

// UseNumber causes the Decoder to unmarshal a number into an interface{} as a
// Number instead of as a float64.
func (dec *Decoder) UseNumber() { dec.d.useNumber = true }

// DisallowUnknownFields causes the Decoder to return an error when the destination
// is a struct and the input contains object keys which do not match any
// non-ignored, exported fields in the destination.
func (dec *Decoder) DisallowUnknownFields() { dec.d.disallowUnknownFields = true }

// Decode reads the next JSON-encoded value from its
// input and stores it in the value pointed to by v.
//
// See the documentation for Unmarshal for details about
// the conversion of JSON into a Go value.
func (dec *Decoder) Decode(v interface{}) error {
	if dec.err != nil {
		return dec.err
	}

	if err := dec.tokenPrepareForDecode(); err != nil {
		return err
	}

	if !dec.tokenValueAllowed() {
		return &SyntaxError{msg: "not at beginning of value", Offset: dec.InputOffset()}
	}

	// Read whole value into buffer.
	n, err := dec.readValue()
	if err != nil {
		return err
	}
	dec.d.init(dec.buf[dec.scanp : dec.scanp+n])
	dec.scanp += n

	// Don't save err from unmarshal into dec.err:
	// the connection is still usable since we read a complete JSON
	// object from it before the error happened.
	err = dec.d.unmarshal(v)

	// fixup token streaming state
	dec.tokenValueEnd()

	return err
}

// Buffered returns a reader of the data remaining in the Decoder's
// buffer. The reader is valid until the next call to Decode.
func (dec *Decoder) Buffered() io.Reader {
	return bytes.NewReader(dec.buf[dec.scanp:])
}

// readValue reads a JSON value into dec.buf.
// It returns the length of the encoding.
func (dec *Decoder) readValue() (int, error) {
	dec.scan.reset()

	scanp := dec.scanp
	var err error
Input:
	// help the compiler see that scanp is never negative, so it can remove
	// some bounds checks below.
	for scanp >= 0 {

		// Look in the buffer for a new value.
		for ; scanp < len(dec.buf); scanp++ {
			c := dec.buf[scanp]
			dec.scan.bytes++
			switch dec.scan.step(&dec.scan, c) {
			case scanEnd:
				// scanEnd is delayed one byte so we decrement
				// the scanner bytes count by 1 to ensure that
				// this value is correct in the next call of Decode.
				dec.scan.bytes--
				break Input
			case scanEndObject, scanEndArray:
				// scanEnd is delayed one byte.
				// We might block trying to get that byte from src,
				// so instead invent a space byte.
				if stateEndValue(&dec.scan, ' ') == scanEnd {
					scanp++
					break Input
				}
			case scanError:
				dec.err = dec.scan.err
				return 0, dec.scan.err
			}
		}

		// Did the last read have an error?
		// Delayed until now to allow buffer scan.
		if err != nil {
			if err == io.EOF {
				if dec.scan.step(&dec.scan, ' ') == scanEnd {
					break Input
				}
				if nonSpace(dec.buf) {
					err = io.ErrUnexpectedEOF
				}
			}
			dec.err = err
			return 0, err
		}

		n := scanp - dec.scanp
		err = dec.refill()
		scanp = dec.scanp + n
	}
	return scanp - dec.scanp, nil
}

func (dec *Decoder) refill() error {
	// Make room to read more into the buffer.
	// First slide down data already consumed.
	if dec.scanp > 0 {
		dec.scanned += int64(dec.scanp)
		n := copy(dec.buf, dec.buf[dec.scanp:])
		dec.buf = dec.buf[:n]
		dec.scanp = 0
	}

	// Grow buffer if not large enough.
	const minRead = 512
	if cap(dec.buf)-len(dec.buf) < minRead {
		newBuf := make([]byte, len(dec.buf), 2*cap(dec.buf)+minRead)
		copy(newBuf, dec.buf)
		dec.buf = newBuf
	}

	// Read. Delay error for next iteration (after scan).
	n, err := dec.r.Read(dec.buf[len(dec.buf):cap(dec.buf)])
	dec.buf = dec.buf[0 : len(dec.buf)+n]

	return err
}

func nonSpace(b []byte) bool {
	for _, c := range b {
		if !isSpace(c) {
			return true
		}
	}
	return false
}

// An Encoder writes JSON values to an output stream.
type Encoder struct {
	w          io.Writer
	err        error
	escapeHTML bool

	indentBuf    *bytes.Buffer
	indentPrefix string
	indentValue  string
}

// NewEncoder returns a new encoder that writes to w.
func NewEncoder(w io.Writer) *Encoder {
	return &Encoder{w: w, escapeHTML: true}
}

// Encode writes the JSON encoding of v to the stream,
// followed by a newline character.
//
// See the documentation for Marshal for details about the
// conversion of Go values to JSON.
func (enc *Encoder) Encode(v interface{}) error {
	if enc.err != nil {
		return enc.err
	}
	e := newEncodeState()
	err := e.marshal(v, encOpts{escapeHTML: enc.escapeHTML})
	if err != nil {
		return err
	}

	// Terminate each value with a newline.
	// This makes the output look a little nicer
	// when debugging, and some kind of space
	// is required if the encoded value was a number,
	// so that the reader knows there aren't more
	// digits coming.
	e.WriteByte('\n')

	b := e.Bytes()
	if enc.indentPrefix != "" || enc.indentValue != "" {
		if enc.indentBuf == nil {
			enc.indentBuf = new(bytes.Buffer)
		}
		enc.indentBuf.Reset()
		err = Indent(enc.indentBuf, b, enc.indentPrefix, enc.indentValue)
		if err != nil {
			return err
		}
		b = enc.indentBuf.Bytes()
	}
	if _, err = enc.w.Write(b); err != nil {
		enc.err = err
	}
	encodeStatePool.Put(e)
	return err
}

// SetIndent instructs the encoder to format each subsequent encoded
// value as if indented by the package-level function Indent(dst, src, prefix, indent).
// Calling SetIndent("", "") disables indentation.
func (enc *Encoder) SetIndent(prefix, indent string) {
	enc.indentPrefix = prefix
	enc.indentValue = indent
}

// SetEscapeHTML specifies whether problematic HTML characters
// should be escaped inside JSON quoted strings.
// The default behavior is to escape &, <, and > to \u0026, \u003c, and \u003e
// to avoid certain safety problems that can arise when embedding JSON in HTML.
//
// In non-HTML settings where the escaping interferes with the readability
// of the output, SetEscapeHTML(false) disables this behavior.
func (enc *Encoder) SetEscapeHTML(on bool) {
	enc.escapeHTML = on
}

// RawMessage is a raw encoded JSON value.
// It implements Marshaler and Unmarshaler and can
// be used to delay JSON decoding or precompute a JSON encoding.
type RawMessage []byte

// MarshalJSON returns m as the JSON encoding of m.
func (m RawMessage) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	return m, nil
}

// UnmarshalJSON sets *m to a copy of data.
func (m *RawMessage) UnmarshalJSON(data []byte) error {
	if m == nil {
		return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")
	}
	*m = append((*m)[0:0], data...)
	return nil
}

var _ Marshaler = (*RawMessage)(nil)
var _ Unmarshaler = (*RawMessage)(nil)

// A Token holds a value of one of these types:
//
//	Delim, for the four JSON delimiters [ ] { }
//	bool, for JSON booleans
//	float64, for JSON numbers
//	Number, for JSON numbers
//	string, for JSON string literals
//	nil, for JSON null
//
type Token interface{}

const (
	tokenTopValue = iota
	tokenArrayStart
	tokenArrayValue
	tokenArrayComma
	tokenObjectStart
	tokenObjectKey
	tokenObjectColon
	tokenObjectValue
	tokenObjectComma
)

// advance tokenstate from a separator state to a value state
func (dec *Decoder) tokenPrepareForDecode() error {
	// Note: Not calling peek before switch, to avoid
	// putting peek into the standard Decode path.
	// peek is only called when using the Token API.
	switch dec.tokenState {
	case tokenArrayComma:
		c, err := dec.peek()
		if err != nil {
			return err
		}
		if c != ',' {
			return &SyntaxError{"expected comma after array element", dec.InputOffset()}
		}
		dec.scanp++
		dec.tokenState = tokenArrayValue
	case tokenObjectColon:
		c, err := dec.peek()
		if err != nil {
			return err
		}
		if c != ':' {
			return &SyntaxError{"expected colon after object key", dec.InputOffset()}
		}
		dec.scanp++
		dec.tokenState = tokenObjectValue
	}
	return nil
}

func (dec *Decoder) tokenValueAllowed() bool {
	switch dec.tokenState {
	case tokenTopValue, tokenArrayStart, tokenArrayValue, tokenObjectValue:
		return true
	}
	return false
}

func (dec *Decoder) tokenValueEnd() {
	switch dec.tokenState {
	case tokenArrayStart, tokenArrayValue:
		dec.tokenState = tokenArrayComma
	case tokenObjectValue:
		dec.tokenState = tokenObjectComma
	}
}

// A Delim is a JSON array or object delimiter, one of [ ] { or }.
type Delim rune

func (d Delim) String() string {
	return string(d)
}

// Token returns the next JSON token in the input stream.
// At the end of the input stream, Token returns nil, io.EOF.
//
// Token guarantees that the delimiters [ ] { } it returns are
// properly nested and matched: if Token encounters an unexpected
// delimiter in the input, it will return an error.
//
// The input stream consists of basic JSON values—bool, string,
// number, and null—along with delimiters [ ] { } of type Delim
// to mark the start and end of arrays and objects.
// Commas and colons are elided.
func (dec *Decoder) Token() (Token, error) {
	for {
		c, err := dec.peek()
		if err != nil {
			return nil, err
		}
		switch c {
		case '[':
			if !dec.tokenValueAllowed() {
				return dec.tokenError(c)
			}
			dec.scanp++
			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
			dec.tokenState = tokenArrayStart
			return Delim('['), nil

		case ']':
			if dec.tokenState != tokenArrayStart && dec.tokenState != tokenArrayComma {
				return dec.tokenError(c)
			}
			dec.scanp++
			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
			dec.tokenValueEnd()
			return Delim(']'), nil

		case '{':
			if !dec.tokenValueAllowed() {
				return dec.tokenError(c)
			}
			dec.scanp++
			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
			dec.tokenState = tokenObjectStart
			return Delim('{'), nil

		case '}':
			if dec.tokenState != tokenObjectStart && dec.tokenState != tokenObjectComma {
				return dec.tokenError(c)
			}
			dec.scanp++
			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
			dec.tokenValueEnd()
			return Delim('}'), nil

		case ':':
			if dec.tokenState != tokenObjectColon {
				return dec.tokenError(c)
			}
			dec.scanp++
			dec.tokenState = tokenObjectValue
			continue

		case ',':
			if dec.tokenState == tokenArrayComma {
				dec.scanp++
				dec.tokenState = tokenArrayValue
				continue
			}
			if dec.tokenState == tokenObjectComma {
				dec.scanp++
				dec.tokenState = tokenObjectKey
				continue
			}
			return dec.tokenError(c)

		case '"':
			if dec.tokenState == tokenObjectStart || dec.tokenState == tokenObjectKey {
				var x string
				old := dec.tokenState
				dec.tokenState = tokenTopValue
				err := dec.Decode(&x)
				dec.tokenState = old
				if err != nil {
					return nil, err
				}
				dec.tokenState = tokenObjectColon
				return x, nil
			}
			fallthrough

		default:
			if !dec.tokenValueAllowed() {
				return dec.tokenError(c)
			}
			var x interface{}
			if err := dec.Decode(&x); err != nil {
				return nil, err
			}
			return x, nil
		}
	}
}

func (dec *Decoder) tokenError(c byte) (Token, error) {
	var context string
	switch dec.tokenState {
	case tokenTopValue:
		context = " looking for beginning of value"
	case tokenArrayStart, tokenArrayValue, tokenObjectValue:
		context = " looking for beginning of value"
	case tokenArrayComma:
		context = " after array element"
	case tokenObjectKey:
		context = " looking for beginning of object key string"
	case tokenObjectColon:
		context = " after object key"
	case tokenObjectComma:
		context = " after object key:value pair"
	}
	return nil, &SyntaxError{"invalid character " + quoteChar(c) + context, dec.InputOffset()}
}

// More reports whether there is another element in the
// current array or object being parsed.
func (dec *Decoder) More() bool {
	c, err := dec.peek()
	return err == nil && c != ']' && c != '}'
}

func (dec *Decoder) peek() (byte, error) {
	var err error
	for {
		for i := dec.scanp; i < len(dec.buf); i++ {
			c := dec.buf[i]
			if isSpace(c) {
				continue
			}
			dec.scanp = i
			return c, nil
		}
		// buffer has been scanned, now report any error
		if err != nil {
			return 0, err
		}
		err = dec.refill()
	}
}

// InputOffset returns the input stream byte offset of the current decoder position.
// The offset gives the location of the end of the most recently returned token
// and the beginning of the next token.
func (dec *Decoder) InputOffset() int64 {
	return dec.scanned + int64(dec.scanp)
}

'''
'''--- pkg/platon/tables.go ---
package platon

import "unicode/utf8"

// safeSet holds the value true if the ASCII character with the given array
// position can be represented inside a JSON string without any further
// escaping.
//
// All values are true except for the ASCII control characters (0-31), the
// double quote ("), and the backslash character ("\").
var safeSet = [utf8.RuneSelf]bool{
	' ':      true,
	'!':      true,
	'"':      false,
	'#':      true,
	'$':      true,
	'%':      true,
	'&':      true,
	'\'':     true,
	'(':      true,
	')':      true,
	'*':      true,
	'+':      true,
	',':      true,
	'-':      true,
	'.':      true,
	'/':      true,
	'0':      true,
	'1':      true,
	'2':      true,
	'3':      true,
	'4':      true,
	'5':      true,
	'6':      true,
	'7':      true,
	'8':      true,
	'9':      true,
	':':      true,
	';':      true,
	'<':      true,
	'=':      true,
	'>':      true,
	'?':      true,
	'@':      true,
	'A':      true,
	'B':      true,
	'C':      true,
	'D':      true,
	'E':      true,
	'F':      true,
	'G':      true,
	'H':      true,
	'I':      true,
	'J':      true,
	'K':      true,
	'L':      true,
	'M':      true,
	'N':      true,
	'O':      true,
	'P':      true,
	'Q':      true,
	'R':      true,
	'S':      true,
	'T':      true,
	'U':      true,
	'V':      true,
	'W':      true,
	'X':      true,
	'Y':      true,
	'Z':      true,
	'[':      true,
	'\\':     false,
	']':      true,
	'^':      true,
	'_':      true,
	'`':      true,
	'a':      true,
	'b':      true,
	'c':      true,
	'd':      true,
	'e':      true,
	'f':      true,
	'g':      true,
	'h':      true,
	'i':      true,
	'j':      true,
	'k':      true,
	'l':      true,
	'm':      true,
	'n':      true,
	'o':      true,
	'p':      true,
	'q':      true,
	'r':      true,
	's':      true,
	't':      true,
	'u':      true,
	'v':      true,
	'w':      true,
	'x':      true,
	'y':      true,
	'z':      true,
	'{':      true,
	'|':      true,
	'}':      true,
	'~':      true,
	'\u007f': true,
}

// htmlSafeSet holds the value true if the ASCII character with the given
// array position can be safely represented inside a JSON string, embedded
// inside of HTML <script> tags, without any additional escaping.
//
// All values are true except for the ASCII control characters (0-31), the
// double quote ("), the backslash character ("\"), HTML opening and closing
// tags ("<" and ">"), and the ampersand ("&").
var htmlSafeSet = [utf8.RuneSelf]bool{
	' ':      true,
	'!':      true,
	'"':      false,
	'#':      true,
	'$':      true,
	'%':      true,
	'&':      false,
	'\'':     true,
	'(':      true,
	')':      true,
	'*':      true,
	'+':      true,
	',':      true,
	'-':      true,
	'.':      true,
	'/':      true,
	'0':      true,
	'1':      true,
	'2':      true,
	'3':      true,
	'4':      true,
	'5':      true,
	'6':      true,
	'7':      true,
	'8':      true,
	'9':      true,
	':':      true,
	';':      true,
	'<':      false,
	'=':      true,
	'>':      false,
	'?':      true,
	'@':      true,
	'A':      true,
	'B':      true,
	'C':      true,
	'D':      true,
	'E':      true,
	'F':      true,
	'G':      true,
	'H':      true,
	'I':      true,
	'J':      true,
	'K':      true,
	'L':      true,
	'M':      true,
	'N':      true,
	'O':      true,
	'P':      true,
	'Q':      true,
	'R':      true,
	'S':      true,
	'T':      true,
	'U':      true,
	'V':      true,
	'W':      true,
	'X':      true,
	'Y':      true,
	'Z':      true,
	'[':      true,
	'\\':     false,
	']':      true,
	'^':      true,
	'_':      true,
	'`':      true,
	'a':      true,
	'b':      true,
	'c':      true,
	'd':      true,
	'e':      true,
	'f':      true,
	'g':      true,
	'h':      true,
	'i':      true,
	'j':      true,
	'k':      true,
	'l':      true,
	'm':      true,
	'n':      true,
	'o':      true,
	'p':      true,
	'q':      true,
	'r':      true,
	's':      true,
	't':      true,
	'u':      true,
	'v':      true,
	'w':      true,
	'x':      true,
	'y':      true,
	'z':      true,
	'{':      true,
	'|':      true,
	'}':      true,
	'~':      true,
	'\u007f': true,
}

'''
'''--- pkg/platon/tags.go ---
package platon

import (
	"strings"
)

// tagOptions is the string following a comma in a struct field's "json"
// tag, or the empty string. It does not include the leading comma.
type tagOptions string

// parseTag splits a struct field's json tag into its name and
// comma-separated options.
func parseTag(tag string) (string, tagOptions) {
	if idx := strings.Index(tag, ","); idx != -1 {
		return tag[:idx], tagOptions(tag[idx+1:])
	}
	return tag, tagOptions("")
}

// Contains reports whether a comma-separated list of options
// contains a particular substr flag. substr must be surrounded by a
// string boundary or commas.
func (o tagOptions) Contains(optionName string) bool {
	if len(o) == 0 {
		return false
	}
	s := string(o)
	for s != "" {
		var next string
		i := strings.Index(s, ",")
		if i >= 0 {
			s, next = s[:i], s[i+1:]
		}
		if s == optionName {
			return true
		}
		s = next
	}
	return false
}

'''
'''--- pkg/redis/redis.go ---
package redis

import (
	"sync"

	"github.com/go-redis/redis/v8"
)

var (
	ListKey     = "near_messsage_log"
	redisClient *redis.Client
	once        = &sync.Once{}
)

func Init(url string) {
	if url == "" {
		panic("messenger redisUrl is empty")
	}
	once.Do(func() {
		opt, err := redis.ParseURL(url)
		if err != nil {
			panic(err)
		}
		rdb := redis.NewClient(opt)
		redisClient = rdb
	})
}

func GetClient() *redis.Client {
	return redisClient
}

'''
'''--- pkg/util/alarm.go ---
package util

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/ethereum/go-ethereum/log"
)

var (
	prefix, hooksUrl = "", ""
	monitor          = make(map[string]int64)
)

func Init(env, hooks string) {
	prefix = env
	hooksUrl = hooks
}

func Alarm(ctx context.Context, msg string) {
	if hooksUrl == "" {
		log.Info("hooks is empty")
		return
	}
	if v, ok := monitor[msg]; ok {
		if time.Now().Unix()-v < 300 { // ignore same alarm in five minute
			return
		}
	}
	monitor[msg] = time.Now().Unix()
	body, err := json.Marshal(map[string]interface{}{
		"text": fmt.Sprintf("%s %s", prefix, msg),
	})
	if err != nil {
		return
	}
	req, err := http.NewRequestWithContext(ctx, "POST", hooksUrl, ioutil.NopCloser(bytes.NewReader(body)))
	if err != nil {
		return
	}
	req.Header.Set("Content-type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Warn("read resp failed", "err", err)
		return
	}
	log.Info("send alarm message", "resp", string(data))
}

'''
'''--- pkg/util/bytes.go ---
package util

import (
	"encoding/hex"
	"math/bits"
	"strings"

	"github.com/ethereum/go-ethereum/common"
)

func Key2Hex(str []byte, proofLength int) []byte {
	ret := make([]byte, 0)
	for _, b := range str {
		ret = append(ret, b/16)
		ret = append(ret, b%16)
	}
	return ret
}

// FromHexString returns a byte array given a hex string
func FromHexString(data string) []byte {
	data = strings.TrimPrefix(data, "0x")
	if len(data)%2 == 1 {
		// Odd number of characters; even it up
		data = "0" + data
	}
	ret, err := hex.DecodeString(data)
	if err != nil {
		panic(err)
	}
	return ret
}

type Bitvector512 []byte

const bitvector512ByteSize = 64
const bitvector512BitSize = bitvector512ByteSize * 8

func NewBitvector512(data []byte) Bitvector512 {
	if len(data) != bitvector512ByteSize {
		return nil
	}
	byteArray := make([]byte, 0, bitvector512ByteSize)
	byteArray = append(byteArray, data...)
	return byteArray[:]
}

// Len returns the number of bits in the bitvector.
func (b Bitvector512) Len() uint64 {
	return bitvector512BitSize
}

// Count returns the number of 1s in the bitvector.
func (b Bitvector512) Count() uint64 {
	if len(b) == 0 {
		return 0
	}
	c := 0
	for i, bt := range b {
		if i >= bitvector512ByteSize {
			break
		}
		c += bits.OnesCount8(bt)
	}
	return uint64(c)
}

func HashToByte(h common.Hash) []byte {
	ret := make([]byte, 0, len(h))
	for _, b := range h {
		ret = append(ret, b)
	}
	return ret
}

'''
'''--- tests/update_near_header_map_test.go ---
package tests

import (
	"github.com/lbtsm/gotron-sdk/pkg/client"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"testing"
)

func Test_grpc(t *testing.T) {
	conn := client.NewGrpcClient("grpc.trongrid.io:50051")
	err := conn.Start(grpc.WithInsecure())
	require.Nil(t, err)

	// `[{"bytes32":"1eee75d90926c3470877c4da9c21d52c6e762225fec1386f7a526bf3f1ce440e"}]`
	tx, err := conn.TriggerConstantContract("TNoZuAuL83PSh8TG4W92AvLqkA4E2dKSNm",
		"TYMpgB8Q9vSoGtkyE3hXsvUrpte3KCDGj6",
		"orderList(bytes32)", `[{"bytes32":"[30 238 117 217 9 38 195 71 8 119 196 218 156 33 213 44 110 118 34 37 254 193 56 111 122 82 107 243 241 206 68 14]"}]`)
	t.Log("err", err)
	t.Log("tx", tx.ConstantResult[0])
}

'''