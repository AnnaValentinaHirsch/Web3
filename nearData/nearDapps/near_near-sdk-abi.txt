*GitHub Repository "near/near-sdk-abi"*

'''--- .github/workflows/test.yml ---
name: test

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  msrv-check:
    runs-on: ${{ matrix.platform }}
    strategy:
      fail-fast: false
      matrix:
        platform: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Get MSRV
        run: |
          RUST_MSRV="$(cat near-sdk-abi/Cargo.toml | sed -n 's/rust-version *= *"\(.*\)"/\1/p')"
          echo "RUST_MSRV=$RUST_MSRV" >> $GITHUB_ENV

      - name: "Install ${{ env.RUST_MSRV }} toolchain (MSRV)"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ env.RUST_MSRV }}

      - name: Cargo check
        run: cargo check -p near-sdk-abi

  tests:
    runs-on: ${{ matrix.platform }}
    strategy:
      fail-fast: false
      matrix:
        platform: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Install `wasm32-unknown-unknown`
        run: rustup target add wasm32-unknown-unknown

      - name: Run tests
        run: cargo test --workspace --verbose

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Check Formatting
        run: cargo fmt -p near-sdk-abi -p near-sdk-abi-macros -p near-sdk-abi-impl -- --check

      - name: Check Clippy
        run: cargo clippy -p near-sdk-abi -p near-sdk-abi-macros -p near-sdk-abi-impl --tests -- -Dclippy::all

  audit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Install Audit Tool
        run: cargo install cargo-audit

      - name: Run Audit Tool
        run: cargo audit --ignore RUSTSEC-2020-0071
'''
'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.0] - 2023-01-04

> Release Page: <https://github.com/near/near-sdk-abi/releases/tag/v0.1.0>

[unreleased]: https://github.com/near/near-sdk-abi/releases/tag/v0.1.0...HEAD
[0.1.0]: https://github.com/near/near-sdk-abi/releases/tag/v0.1.0
'''
'''--- Cargo.toml ---
[workspace]
members = [
    "near-sdk-abi",
    "near-sdk-abi-impl",
    "near-sdk-abi-macros",
    "examples/*"
]

'''
'''--- README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-sdk-abi</code></h1>

  <p>
    <strong>Utility library for making typesafe cross-contract calls with <a href="https://github.com/near/near-sdk-rs">near-sdk-rs</a> smart contracts</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-sdk-abi/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-sdk-abi/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/v/near-sdk-abi.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/d/near-sdk-abi.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a cross-contract binding in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-macro) example for a standalone smart contract using macro API to make a cross-contract call.

To generate a trait named `ContractName` with ext interface named `ext_name` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
near_abi_ext! { mod ext_name trait ContractName for "path/to/abi.json" }
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-generation) example for a standalone project using generation API to make a cross-contract call.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the contract trait in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_sdk_abi::Generator::new("path/to/out/dir".into())
        .file(near_sdk_abi::AbiFile::new("path/to/abi.json"))
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```rust
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- examples/delegator-generation/Cargo.toml ---
[package]
name = "delegator-generation"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "4.1.0", features = ["abi"] }
near-sdk-abi = { path = "../../near-sdk-abi" }
serde = "1.0"

[dev-dependencies]
anyhow = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.7.0"

[build-dependencies]
anyhow = "1.0"
near-sdk-abi = { path = "../../near-sdk-abi" }

'''
'''--- examples/delegator-generation/build.rs ---
use near_sdk_abi::{AbiFile, Generator};

fn main() -> anyhow::Result<()> {
    Generator::new("gen".into())
        .file(AbiFile::new("src/adder.json"))
        .generate()?;
    Ok(())
}

'''
'''--- examples/delegator-generation/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "$(dirname $0)"

cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/delegator.wasm ./res/

'''
'''--- examples/delegator-generation/src/adder.json ---
{
  "schema_version": "0.3.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}
'''
'''--- examples/delegator-generation/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;

#[path = "../gen/adder.rs"]
mod adder;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Delegator {}

#[near_bindgen]
impl Delegator {
    pub fn delegate(
        &self,
        a1: u32,
        a2: u32,
        b1: u32,
        b2: u32,
        adder_account_id: near_sdk::AccountId,
    ) -> near_sdk::Promise {
        adder::ext_abi::ext(adder_account_id)
            .add(vec![a1.into(), a2.into()], vec![b1.into(), b2.into()])
    }
}

'''
'''--- examples/delegator-generation/tests/workspaces.rs ---
use workspaces::{Contract, DevNetwork, Worker};

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<(Contract, Contract)> {
    let adder = worker
        .dev_deploy(&include_bytes!("../res/adder.wasm").to_vec())
        .await?;
    let delegator = worker
        .dev_deploy(&include_bytes!("../res/delegator_generation.wasm").to_vec())
        .await?;
    Ok((adder, delegator))
}

#[tokio::test]
async fn test_delegate() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (adder, delegator) = init(&worker).await?;

    let res = delegator
        .call("delegate")
        .args_json((1u32, 2u32, 3u32, 4u32, adder.as_account().id()))
        .transact()
        .await?;
    assert_eq!(res.json::<(u32, u32)>()?, (4, 6));

    Ok(())
}

'''
'''--- examples/delegator-macro/Cargo.toml ---
[package]
name = "delegator-macro"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "4.1.0", features = ["abi"] }
near-sdk-abi = { path = "../../near-sdk-abi" }
serde = "1.0"

[dev-dependencies]
anyhow = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.7.0"

'''
'''--- examples/delegator-macro/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "$(dirname $0)"

cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/delegator.wasm ./res/

'''
'''--- examples/delegator-macro/src/adder.json ---
{
  "schema_version": "0.3.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}
'''
'''--- examples/delegator-macro/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;
use near_sdk_abi::near_abi_ext;

near_abi_ext! { mod ext_adder trait Adder for "src/adder.json" }

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Delegator {}

#[near_bindgen]
impl Delegator {
    pub fn delegate(
        &self,
        a1: u32,
        a2: u32,
        b1: u32,
        b2: u32,
        adder_account_id: near_sdk::AccountId,
    ) -> near_sdk::Promise {
        ext_adder::ext(adder_account_id).add(vec![a1.into(), a2.into()], vec![b1.into(), b2.into()])
    }
}

'''
'''--- examples/delegator-macro/tests/workspaces.rs ---
use workspaces::{Contract, DevNetwork, Worker};

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<(Contract, Contract)> {
    let adder = worker
        .dev_deploy(&include_bytes!("../res/adder.wasm").to_vec())
        .await?;
    let delegator = worker
        .dev_deploy(&include_bytes!("../res/delegator_macro.wasm").to_vec())
        .await?;
    Ok((adder, delegator))
}

#[tokio::test]
async fn test_delegate() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (adder, delegator) = init(&worker).await?;

    let res = delegator
        .call("delegate")
        .args_json((1u32, 2u32, 3u32, 4u32, adder.as_account().id()))
        .transact()
        .await?;
    assert_eq!(res.json::<(u32, u32)>()?, (4, 6));

    Ok(())
}

'''
'''--- near-sdk-abi-impl/Cargo.toml ---
[package]
name = "near-sdk-abi-impl"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-sdk-abi"
description = """
Utility library for making typesafe cross-contract calls in NEAR SDK smart contracts.
"""

[dependencies]
proc-macro2 = "1.0"
near_schemafy_lib = "0.7"
schemars = "0.8"
serde_json = "1.0"
syn = "1.0"
quote = "1.0"

near-abi = "0.3.0"
'''
'''--- near-sdk-abi-impl/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-sdk-abi</code></h1>

  <p>
    <strong>Utility library for making typesafe cross-contract calls with <a href="https://github.com/near/near-sdk-rs">near-sdk-rs</a> smart contracts</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-sdk-abi/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-sdk-abi/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/v/near-sdk-abi.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/d/near-sdk-abi.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a cross-contract binding in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-macro) example for a standalone smart contract using macro API to make a cross-contract call.

To generate a trait named `ContractName` with ext interface named `ext_name` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
near_abi_ext! { mod ext_name trait ContractName for "path/to/abi.json" }
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-generation) example for a standalone project using generation API to make a cross-contract call.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the contract trait in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_sdk_abi::Generator::new("path/to/out/dir".into())
        .file(near_sdk_abi::AbiFile::new("path/to/abi.json"))
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```rust
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-sdk-abi-impl/src/lib.rs ---
use near_abi::{AbiParameters, AbiRoot, AbiType};
use near_schemafy_lib::{Expander, Generator};
use quote::{format_ident, quote};
use std::path::{Path, PathBuf};

pub fn generate_ext(
    near_abi: AbiRoot,
    contract_name: proc_macro2::Ident,
    mod_name: Option<proc_macro2::Ident>,
) -> proc_macro2::TokenStream {
    let schema_json = serde_json::to_string(&near_abi.body.root_schema).unwrap();

    let generator = Generator::builder().with_input_json(&schema_json).build();
    let (mut token_stream, schema) = generator.generate_with_schema();
    let mut expander = Expander::new(None, "", &schema);

    let methods = near_abi
        .body
        .functions
        .iter()
        .map(|m| {
            let name = format_ident!("{}", m.name);
            let result_type = m
                .result
                .clone()
                .map(|r_param| {
                    let r_type = match &r_param {
                        AbiType::Json { type_schema } => {
                            expand_subschema(&mut expander, type_schema)
                        }
                        AbiType::Borsh { type_schema: _ } => {
                            panic!("Borsh is currently unsupported")
                        }
                    };
                    quote! { -> #r_type }
                })
                .unwrap_or_else(|| quote! {});
            let args = match &m.params {
                AbiParameters::Json { args } => args
                    .iter()
                    .map(|arg| {
                        let arg_type = expand_subschema(&mut expander, &arg.type_schema);
                        let arg_name = format_ident!("{}", &arg.name);
                        quote! { #arg_name: #arg_type }
                    })
                    .collect::<Vec<_>>(),
                AbiParameters::Borsh { args: _ } => panic!("Borsh is currently unsupported"),
            };
            quote! { fn #name(&self, #(#args),*) #result_type; }
        })
        .collect::<Vec<_>>();

    let ext_contract = mod_name.map_or_else(
        || quote! { #[near_sdk::ext_contract] },
        |n| quote! { #[near_sdk::ext_contract(#n)] },
    );

    token_stream.extend(quote! {
        #ext_contract
        pub trait #contract_name {
            #(#methods)*
        }
    });

    token_stream
}

pub fn read_abi(abi_path: impl AsRef<Path>) -> AbiRoot {
    let abi_path = if abi_path.as_ref().is_relative() {
        let crate_root = get_crate_root().unwrap();
        crate_root.join(&abi_path)
    } else {
        PathBuf::from(abi_path.as_ref())
    };

    let abi_json = std::fs::read_to_string(&abi_path)
        .unwrap_or_else(|err| panic!("Unable to read `{}`: {}", abi_path.to_string_lossy(), err));

    serde_json::from_str::<AbiRoot>(&abi_json).unwrap_or_else(|err| {
        panic!(
            "Cannot parse `{}` as ABI: {}",
            abi_path.to_string_lossy(),
            err
        )
    })
}

pub fn get_crate_root() -> std::io::Result<PathBuf> {
    if let Ok(path) = std::env::var("CARGO_MANIFEST_DIR") {
        return Ok(PathBuf::from(path));
    }

    let current_dir = std::env::current_dir()?;

    for p in current_dir.ancestors() {
        if std::fs::read_dir(p)?
            .into_iter()
            .filter_map(Result::ok)
            .any(|p| p.file_name().eq("Cargo.toml"))
        {
            return Ok(PathBuf::from(p));
        }
    }

    Ok(current_dir)
}

fn schemars_schema_to_schemafy(schema: &schemars::schema::Schema) -> near_schemafy_lib::Schema {
    let schema_json = serde_json::to_string(&schema).unwrap();
    serde_json::from_str(&schema_json).unwrap_or_else(|err| {
        panic!(
            "Could not convert schemars schema to schemafy model: {}",
            err
        )
    })
}

fn expand_subschema(expander: &mut Expander, schema: &schemars::schema::Schema) -> syn::Ident {
    let schemafy_schema = schemars_schema_to_schemafy(schema);
    format_ident!("{}", expander.expand_type_from_schema(&schemafy_schema).typ)
}

'''
'''--- near-sdk-abi-macros/Cargo.toml ---
[package]
name = "near-sdk-abi-macros"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-sdk-abi"
description = """
Utility library for making typesafe cross-contract calls in NEAR SDK smart contracts.
"""

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1.0"
syn = "1.0"
quote = "1.0"

near-sdk-abi-impl = { path = "../near-sdk-abi-impl", version = "0.1" }
'''
'''--- near-sdk-abi-macros/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-sdk-abi</code></h1>

  <p>
    <strong>Utility library for making typesafe cross-contract calls with <a href="https://github.com/near/near-sdk-rs">near-sdk-rs</a> smart contracts</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-sdk-abi/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-sdk-abi/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/v/near-sdk-abi.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/d/near-sdk-abi.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a cross-contract binding in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-macro) example for a standalone smart contract using macro API to make a cross-contract call.

To generate a trait named `ContractName` with ext interface named `ext_name` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
near_abi_ext! { mod ext_name trait ContractName for "path/to/abi.json" }
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-generation) example for a standalone project using generation API to make a cross-contract call.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the contract trait in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_sdk_abi::Generator::new("path/to/out/dir".into())
        .file(near_sdk_abi::AbiFile::new("path/to/abi.json"))
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```rust
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-sdk-abi-macros/src/lib.rs ---
use near_sdk_abi_impl::{generate_ext, read_abi};
use std::path::PathBuf;

#[proc_macro]
pub fn near_abi_ext(tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let abi_def = syn::parse_macro_input!(tokens as AbiDef);
    let near_abi = read_abi(PathBuf::from(&abi_def.path.value()));

    generate_ext(near_abi, abi_def.trait_name, Some(abi_def.mod_name)).into()
}

struct AbiDef {
    /// Resulting mod name.
    mod_name: syn::Ident,
    /// Resulting ext contract trait name.
    trait_name: syn::Ident,
    /// Path to the ABI file.
    path: syn::LitStr,
}

impl syn::parse::Parse for AbiDef {
    fn parse(input: syn::parse::ParseStream<'_>) -> syn::Result<Self> {
        input.parse::<syn::Token![mod]>()?;
        let mod_name = input.parse::<syn::Ident>()?;
        input.parse::<syn::Token![trait]>()?;
        let trait_name = input.parse::<syn::Ident>()?;
        input.parse::<syn::Token![for]>()?;
        let path = input.parse()?;
        Ok(AbiDef {
            mod_name,
            trait_name,
            path,
        })
    }
}

'''
'''--- near-sdk-abi/Cargo.toml ---
[package]
name = "near-sdk-abi"
version = "0.1.0"
edition = "2021"
rust-version = "1.56.0"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-sdk-abi"
description = """
Utility library for making typesafe cross-contract calls in NEAR SDK smart contracts.
"""

[dependencies]
anyhow = "1.0"
convert_case = "0.5"
prettyplease = "0.1"
syn = "1.0"
quote = "1.0"

near-abi = "0.3.0"
near-sdk-abi-impl = { path = "../near-sdk-abi-impl", version = "0.1" }
near-sdk-abi-macros = { path = "../near-sdk-abi-macros", version = "0.1" }
'''
'''--- near-sdk-abi/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-sdk-abi</code></h1>

  <p>
    <strong>Utility library for making typesafe cross-contract calls with <a href="https://github.com/near/near-sdk-rs">near-sdk-rs</a> smart contracts</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-sdk-abi/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-sdk-abi/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/v/near-sdk-abi.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-sdk-abi"><img src="https://img.shields.io/crates/d/near-sdk-abi.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a cross-contract binding in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-macro) example for a standalone smart contract using macro API to make a cross-contract call.

To generate a trait named `ContractName` with ext interface named `ext_name` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
near_abi_ext! { mod ext_name trait ContractName for "path/to/abi.json" }
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-sdk-abi/tree/main/examples/delegator-generation) example for a standalone project using generation API to make a cross-contract call.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the contract trait in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_sdk_abi::Generator::new("path/to/out/dir".into())
        .file(near_sdk_abi::AbiFile::new("path/to/abi.json"))
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```rust
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have an `ext_account_id: near_sdk::AccountId` representing the contract account id, you can make a cross-contract call like this:

```rust
let promise = ext_adder::ext(ext_account_id).my_method_name(arg1, arg2);
```

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-sdk-abi/src/lib.rs ---
use anyhow::{anyhow, Result};
use convert_case::{Case, Casing};
use near_sdk_abi_impl::{generate_ext, read_abi};
use quote::{format_ident, quote};
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::{env, fs};

pub use near_sdk_abi_macros::near_abi_ext;

pub struct AbiFile {
    /// Path to the ABI JSON file.
    pub path: PathBuf,
    /// Contract name to be used for the resulting trait name.
    /// If missing will try to pull the name from ABI metadata and use `Ext<ContractName>`.
    pub contract_name: Option<String>,
    /// mod name to be used for the resulting ext mod.
    /// If missing will be derived by applying snake case to the contract name, e.g. ext_status_message.
    pub mod_name: Option<String>,
}

impl AbiFile {
    pub fn new(path: impl Into<PathBuf>) -> Self {
        AbiFile {
            path: path.into(),
            contract_name: None,
            mod_name: None,
        }
    }
}

/// Configuration options for ABI code generation.
#[derive(Default)]
pub struct Generator {
    out_dir: Option<PathBuf>,
    abis: Vec<AbiFile>,
}

impl Generator {
    pub fn new(out_dir: PathBuf) -> Self {
        Generator {
            out_dir: Some(out_dir),
            abis: vec![],
        }
    }

    pub fn file(mut self, abi_file: AbiFile) -> Self {
        self.abis.push(abi_file);
        self
    }

    pub fn generate(self) -> Result<()> {
        let target: PathBuf = self.out_dir.map(Ok).unwrap_or_else(|| {
            env::var_os("OUT_DIR")
                .ok_or_else(|| anyhow!("OUT_DIR environment variable is not set"))
                .map(Into::into)
        })?;
        fs::create_dir_all(&target)?;

        for AbiFile {
            path,
            contract_name,
            mod_name,
        } in self.abis
        {
            let abi_path_no_ext = path.with_extension("");
            let abi_filename = abi_path_no_ext
                .file_name()
                .ok_or_else(|| anyhow!("{:?} is not a valid ABI path", path.display()))?;
            let rust_path = target.join(abi_filename).with_extension("rs");

            let near_abi = read_abi(&path);

            let contract_name = contract_name
                .as_ref()
                .map(|n| format_ident!("{}", n))
                .or_else(|| {
                    near_abi
                        .metadata
                        .name
                        .clone()
                        .map(|n| format_ident!("Ext{}", n.to_case(Case::UpperCamel)))
                })
                .ok_or_else(|| {
                    anyhow!(
                        "ABI file '{}' does not contain a contract name. Please supply the name via `file_with_name`.",
                        path.display()
                    )
                })?;

            let token_stream = generate_ext(
                near_abi,
                contract_name,
                mod_name.map(|n| format_ident!("{}", n)),
            );
            let token_stream = quote! {
                #![allow(unused_imports)]
                use serde::{Deserialize, Serialize};
                #token_stream
            };
            let syntax_tree = syn::parse_file(&token_stream.to_string()).unwrap();
            let formatted = prettyplease::unparse(&syntax_tree);

            let mut rust_file = File::create(rust_path)?;
            write!(rust_file, "{}", formatted)?;
        }

        Ok(())
    }
}

'''
'''--- res/adder.json ---
{
  "schema_version": "0.3.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}
'''