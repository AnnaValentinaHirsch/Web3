*GitHub Repository "hedward/drop_it_hot"*

'''--- .vscode/settings.json ---
{
    "cSpell.words": [
        "unscalable"
    ]
}
'''
'''--- Cargo.toml ---
# [package]
# name = "cross-contract-calls"
# version = "0.0.0"
# authors = ["Near Inc <hello@nearprotocol.com>"]
# edition = "2018"

[workspace]
members = [
  "contract"
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
<p align="center">
  <img src="assets/claimed-linkdrop.png" alt="Logo" style="width: 35%; height: 35%">
  <br />
</p>

<div align="center">
  <h1>
  NEAR Linkdrop Proxy
  </h1>
  The hub for creating linkdrops containing $NEAR and one of: NFTs, and FTs or an arbitrary function called upon claim
</div>

<div align="center">
<br />

[![made by BenKurrek](https://img.shields.io/badge/made%20by-BenKurrek-ff1414.svg?style=flat-square)](https://github.com/BenKurrek)
[![made by mattlockyer](https://img.shields.io/badge/made%20by-MattLockyer-ff1414.svg?style=flat-square)](https://github.com/mattlockyer)

</div>

<details open="open">
<summary>Table of Contents</summary>

- [About](#about)
- [How it Works](#how-it-works)
  - [NFTs](#nft-linkdrops)
  - [Fungible Tokens](#fungible-token-linkdrops)
  - [Function Calls](#function-calls)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Quickstart](#quickstart)  
- [Contributing](#contributing)
- [Acknowledgements](#acknowledgements)

</details>

---

# About

<table>
<tr>
<td>

The NEAR linkdrop proxy contract was initially created as a way to handle the hardcoded minimum 1 $NEAR fee for creating linkdrops using the [regular linkdrop contract](https://github.com/near/near-linkdrop/blob/f24f2608e1558db773f2408a28849d330abb3881/src/lib.rs#L18). If users wanted to create linkdrops, they needed to attach a **minimum** of 1 $NEAR. This made it costly and unscalable for projects that wanted to mass create linkdrops for an easy onboarding experience to NEAR.

The proxy contract has a highly optimized fee structure that can be broken down below. Every linkdrop's fees are made up of: 
- Actual linkdrop balance sent to the claimed account (**minimum 0.00284 $NEAR**).
- Access key allowance (**0.02 $NEAR**).
- Storage for creating access key (**0.001 $NEAR**).
- Storage cost for storing information on the proxy contract (**dynamically calculated** but **~0.0015 $NEAR** for a basic linkdrop).

This means that at an absolute **minimum**, you can create a linkdrop for **~0.02534 $NEAR** making it **97.466% cheaper** than the alternate solution. 

In addition, some of this upfront fee **will be refunded** to the funder once the account is created, making it even cheaper. The access key allowance and all storage will be refunded (minus the burnt GAS) once the linkdrop is claimed which makes the true cost of creating a linkdrop roughly `(0.02534 - (0.02 + 0.001 + 0.0015 - 0.01) = 0.01384 $NEAR` which is **~98.616% cheaper**. 

> **NOTE:** any excess $NEAR attached to the call when creating the linkdrop will be automatically refunded to the funder

Key features of the **Linkdrop Proxy Contract**:

- **Batch creation** of linkdrops within the contract.
- Ability to specify a **highly customizable function** to be called when the linkdrop is claimed.
- Ability to pre-load the linkdrop with an **NFT** from **any** NEP-171 compatible smart contract.
- Ability to pre-load the linkdrop with **fungible tokens** from **any** NEP-141 compatible smart contract.
- Extremely **low required deposits** when compared with traditional approaches
- **Customizable balance** that the linkdrop will contain.

</td>
</tr>
</table>

## Built With

- [near-sdk-rs](https://github.com/near/near-sdk-rs)
- [near-api-js](https://github.com/near/near-api-js)

# How it Works

Once the contract is deployed, you can either batch create linkdrops, or you can create them one-by-one. With each basic linkdrop, you have the option to either pre-load them with an NFT, or a fungible token.

For some background as to how the linkdrop proxy contract works on NEAR: 

*The funder that has an account and some $NEAR:* 
- creates a keypair locally `(pubKey1, privKey1)`. The blockchain doesn't know of this key's existence yet since it's all local for now.
- calls `send` on the proxy contract and passes in the `pubKey1` as an argument as well as the desired `balance` for the linkdrop.
    - The contract will map the `pubKey1` to the desired `balance` for the linkdrop.
    - The contract will then add the `pubKey1` as a **function call access key** with the ability to call `claim` and `create_account_and_claim`. This means that anyone with the `privKey1` that was created locally, can claim this linkdrop. 
- Funder will then create a link to send to someone that contains this `privKey1`. The link follows the following format: 
```
    wallet.testnet.near.org/linkdrop/{fundingContractAccountId}/{linkdropKeyPairSecretKey}?redirectUrl={redirectUrl}
```
* `fundingContractAccountId`: The contract accountId that was used to send the funds.
* `linkdropKeyPairSecretKey`: The corresponding secret key to the public key sent to the contract.
* `redirectUrl`: The url that wallet will redirect to after funds are successfully claimed to an existing account. The URL is sent the accountId used to claim the funds as a query param.

*The receiver of the link that is claiming the linkdrop:* 
- Receives the link which includes `privKey1` and sends them to the NEAR wallet.
- Wallet creates a new keypair `(pubKey2, privKey2)` locally. The blockchain doesn't know of this key's existence yet since it's all local for now.
- Receiver will then choose an account ID such as `new_account.near`. 
- Wallet will then use the `privKey1` which has access to call `claim` and `create_account_and_claim` in order to call `create_account_and_claim` on the proxy contract.
    - It will pass in `pubKey2` which will be used to create a full access key for the new account.
- The proxy contract will create the new account and transfer the funds to it alongside any NFT or fungible tokens pre-loaded.

To view information account data information for a given key, you can call the following view function: 

```bash
near view YOUR_LINKDROP_PROXY_CONTRACT get_key_information '{"key": "ed25519:7jszQk7sfbdQy8NHM1EfJi9r3ncyvKa4ZoKU7uk9PbqR"}'
```

Example response:
<p>

```bash
[
  {
    funder_id: 'benjiman.testnet',
    balance: '2840000000000000000000',
    storage_used: '1320000000000000000000',
    cb_id: null,
    cb_data_sent: true
  },
  null,
  null,
  null
]
```
</p>

This will return the Account Data followed by Fungible Token Data, NFT Data, and then Function Call Data. If any of the above don't exist, null is returned in its place.

Below are some flowcharts for creating single linkdrops and batch creating multiple linkdrops.

<p align="center">
  <img src="flowcharts/creating-single-linkdrops.png" style="width: 65%; height: 65%" alt="Logo">
  <br />
  <img src="flowcharts/creating-multiple-linkdrops.png" style="width: 65%; height: 65%" alt="Logo">
</p>

## NFT Linkdrops

With the proxy contract, users can pre-load a linkdrop with **only one** NFT due to GAS constraints. In order to pre-load the NFT, you must:
- create a linkdrop either through `send` or `send_multiple` and specify the NFTData for the NFT that will be pre-loaded onto the linkdrop. The NFT Data struct can be seen below.

```rust
pub struct NFTData {
    pub nft_sender: String,
    pub nft_contract: String,
    pub nft_token_id: String,
}
```

An example of creating an NFT linkdrop can be seen:

```bash
near call linkdrop-proxy.testnet send '{"public_key": "ed25519:2EVN4CVLu5oH18YFoxGyeVkg1c7MaDb9aDrhkaWPqjd7", "balance": "2840000000000000000000", "nft_data": {"nft_sender": "benjiman.testnet", "nft_contract": "nft.examples.testnet", "nft_token_id": "token1"}}' --accountId "benjiman.testnet" --amount 1
```

- Once the regular linkdrop has been created with the specified NFT Data, execute the `nft_transfer_call` funtion on the NFT contract and you *must* pass in `pubKey1` (the public key of the keypair created locally and passed into the `send` function) into the `msg` parameter. If the linkdrop is claimed before activation, it will act as a regular linkdrop with no NFT. 

```bash
near call nft.examples.testnet nft_transfer_call '{"token_id": "token1", "receiver_id": "linkdrop-proxy.testnet", "msg": "ed25519:4iwBf6eAXZ4bcN6TWPikSqu3UJ2HUwF8wNNkGZrgDYqE"}' --accountId "benjiman.testnet" --depositYocto 1
```

> **NOTE:** you must send the NFT after the linkdrop has been created. You cannot send an NFT with a public key that isn't on the contract yet. The NFT must match exactly what was specified in the NFT data when creating the linkdrop.

<p align="center">
  <img src="flowcharts/adding-nfts-and-fts-to-linkdrops.png" style="width: 65%; height: 65%" alt="Logo">
</p>

Once the NFT is sent to the contract, it will be registered and you can view the current information about any key using the `get_key_information` function. Upon claiming, the NFT will be transferred from the contract to the newly created account (or existing account) along with the balance of the linkdrop. If any part of the linkdrop claiming process is unsuccessful, **both** the NFT and the $NEAR will be refunded to the funder and token sender respectively.

> **NOTE:** If the NFT fails to transfer from the contract back to the token sender due to a refund for any reason, the NFT will remain on the proxy contract.

If the linkdrop is successfully claimed, the funder will be refunded for everything **except** the burnt GAS and linkdrop balance. This results in the actual linkdrop cost being extremely low (burnt GAS + initial balance).

<p align="center">
  <img src="flowcharts/claiming-nft-linkdrops-with-new-accounts.png" style="width: 65%; height: 65%" alt="Logo">
</p>

## Fungible Token Linkdrops

With the proxy contract, users can pre-load a linkdrop with **only one** type of fungible token due to GAS constraints. The number of fungible tokens, however, is not limited. You could load 1 TEAM token, or a million TEAM tokens. You cannot, however, load 10 TEAM tokens and 50 MIKE tokens at the same time.

Due to the nature of how fungible token contracts handle storage, the user is responsible for attaching enough $NEAR to cover the registration fee. As mentioned in the [About](#about) section, this amount is dynamically calculated before the linkdrop is created in the `send` or `send_multiple` functions. The process for creating fungible token linkdrops is very similar to the NFT linkdrops:

- create a linkdrop either through `send` or `send_multiple` and specify the FTData for the Fungible Tokens that will be pre-loaded onto the linkdrop. The FT Data struct can be seen below.

```rust
pub struct FTData {
    pub ft_contract: String,
    pub ft_sender: String,
    pub ft_balance: U128, // String
    pub ft_storage: Option<U128>, // String
}
```

An example of creating an FT linkdrop can be seen:

```bash
near call linkdrop-proxy.testnet send '{"public_key": "ed25519:2EVN4CVLu5oH18YFoxGyeVkg1c7MaDb9aDrhkaWPqjd7", "balance": "2840000000000000000000", "ft_data": {"ft_sender": "benjiman.testnet", "ft_contract": "ft.benjiman.testnet", "ft_balance": "25"}}' --accountId "benjiman.testnet" --amount 1
```

Once the regular linkdrop is created with the fungible token data, you can the send the fungible tokens to activate the linkdrop. If the linkdrop is claimed before activation, it will act as a regular linkdrop with no FTs.

<p align="center">
  <img src="flowcharts/adding-nfts-and-fts-to-linkdrops.png" style="width: 65%; height: 65%" alt="Logo">
</p>

Once the regular linkdrop is created with the fungible token data, you can the send the fungible tokens to activate the linkdrop. If the linkdrop is claimed before activation, it will act as a regular linkdrop with no FTs.

- execute the `ft_transfer_call` function on the FT contract and you *must* pass in `pubKey1` (the public key of the keypair created locally and passed into the `send` function) into the `msg` parameter. An example of this can be: 

```bash
near call FT_CONTRACT.testnet ft_transfer_call '{"receiver_id": "linkdrop-proxy.testnet", "amount": "25", "msg": "ed25519:4iwBf6eAXZ4bcN6TWPikSqu3UJ2HUwF8wNNkGZrgDYqE"}' --accountId "benjiman.testnet" --depositYocto 1
```

> **NOTE:** you must send the FT after the linkdrop has been created. You cannot send FTs with a public key that isn't on the contract yet. You are also responsible for registering the proxy contract for the given fungible token contract if it isn't registered already.

Once the fungible tokens are sent to the contract, they will be registered and you can view the current information about any key using the `get_key_information` function. Upon claiming, the proxy contract will register the newly created account (or existing account) on the fungible token contract using the storage you depositted in the `send` function. After this is complete, the fungible tokens will be transferred from the contract to the claimed account along with the balance of the linkdrop. If any part of the linkdrop claiming process is unsuccessful, **both** the fungible tokens and the $NEAR will be refunded to the funder and token sender respectively.

> **NOTE:** If the FT fails to transfer from the contract back to the token sender due to a refund for any reason, the fungible tokens will remain on the proxy contract.

If the linkdrop is successfully claimed, the funder will be refunded for everything **except** the burnt GAS, linkdrop balance, and fungible token storage.

<p align="center">
  <img src="flowcharts/claiming-ft-linkdrops-with-new-accounts.png"  style="width: 65%; height: 65%" alt="Logo">
  <br />
</p>

## Function Calls

With the proxy contract, users can specify a function that will be called when the linkdrop is claimed. This function call is highly customizable including:
- Any method on any contract
- Any deposit to attach to the call
- Whether or not the refund that normally goes to the funder should be sent along with the deposit
- Specifying a specific field for the claiming account to be called with.

Let's look at an example to see the power of the proxy contract. If a user wants to be able to lazy mint an NFT to the newly created account (that is unknown at the time of creating the linkdrop) but the mint function takes a parameter `receiver_id` and a deposit of 1 $NEAR, you could specify these parameters. The struct that must be passed in when creating a function call linkdrop is below.

```rust
pub struct FCData {
    // Contract that will be called
    pub receiver: String,
    // Method to call on receiver contract
    pub method: String,
    // Arguments to pass in (stringified JSON)
    pub args: String,
    // Amount of yoctoNEAR to attach along with the call
    pub deposit: U128,
    // Should the refund that normally goes to the funder be attached alongside the deposit?
    pub refund_to_deposit: Option<bool>,
    // Specifies what field the claiming account should go in when calling the function
    pub claimed_account_field: Option<String>,
}
```

If there was a different NFT contract where the parameter was `nft_contract_id` instead, that is also possible. You can specify the exact field that the claiming account ID should be passed into. An example flow of creating a function call linkdrop is below.

- create a linkdrop either through `send` or `send_multiple` and specify the FC (function call) data for the function that will be called upon claim

```bash
near call linkdrop-proxy.testnet send '{"public_key": "ed25519:2EVN4CVLu5oH18YFoxGyeVkg1c7MaDb9aDrhkaWPqjd7", "balance": "2840000000000000000000", "fc_data": {"receiver": "nft.examples.testnet", "method": "nft_mint", "args": "{\"token_id\":\"ed25519:Db3ALuBMU2ruMNroZfwFC5ZGMXK3bRX12UjRAbH19LZL\",\"token_metadata\":{\"title\":\"My Linkdrop Called This Function!\",\"description\":\"Linkdrop NFT that was lazy minted when the linkdrop was claimed\",\"media\":\"https://bafybeicek3skoaae4p5chsutjzytls5dmnj5fbz6iqsd2uej334sy46oge.ipfs.nftstorage.link/\",\"media_hash\":null,\"copies\":10000,\"issued_at\":null,\"expires_at\":null,\"starts_at\":null,\"updated_at\":null,\"extra\":null,\"reference\":null,\"reference_hash\":null}}", "deposit": "1000000000000000000000000", "refund_to_deposit": true, "claimed_account_field": "receiver_id" }}' --accountId "benjiman.testnet" --amount 1
```

This will create a linkdrop for `0.00284 $NEAR` and specify that once the linkdrop is claimed, the method `nft_mint` should be called on the contract `nft.examples.testnet` with a set of arguments that are stringified JSON. In addition, an **extra field called receiver_id** should be **added to the args** and the claiming account ID will be set for that field in the arguments.

> **NOTE:** you must attach enough $NEAR to cover the attached deposit. If the linkdrop claim fails, your $NEAR will be refunded and the function call will NOT execute.

<p align="center">
  <img src="flowcharts/claiming-function-call-linkdrops-with-new-accounts.png" style="width: 65%; height: 65%" alt="Logo">
</p>

# Getting Started

## Prerequisites

In order to successfully use this contract, you should have the following installed on your machine: 

- [NEAR account](https://docs.near.org/docs/develop/basics/create-account)
- [rust toolchain](https://docs.near.org/docs/develop/contracts/rust/intro#installing-the-rust-toolchain)
- [NEAR CLI](https://docs.near.org/docs/tools/near-cli#setup)

If you want to run the deploy scripts, you'll need:
- [Node JS](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

## Quickstart

The project comes with several useful scripts in order to test and view functionalities for creating linkdrops. Each script can be set to either batch create linkdrops or create them one by one:

- [simple.js](deploy/simple.js) creating linkdrops preloaded with just $NEAR
- [nft.js](deploy/nft.js) creating linkdrops preloaded with $NEAR and an NFT
- [ft.js](deploy/ft.js) creating linkdrops preloaded with $NEAR and fungible tokens.
- [function-call.js](deploy/funtion-call.js) creating linkdrops preloaded with $NEAR and fungible tokens.

In addition, there is a test script that will create a function call recursive linkdrop that keeps calling the contract to create a new linkdrop once the old one is claimed. To test it out, visit the [recursive-fc.js](deploy/recursive-fc.js) script.

The first step is to compile the contract to WebAssembly by running:

```
yarn build-contract
```
This will create the directory `out/main.wasm` where you can then deploy the contract using:

```
near deploy --wasmFile out/main.wasm --accountId YOUR_CONTRACT_ID.testnet
```

> **NOTE:** you must replace `YOUR_CONTRACT_ID.testnet` with the actual NEAR account ID you'll be using.

Once deployed, you need to initialize the contract with the external linkdrop contract you want to interact with. In most cases, this will be `near` or `testnet` since you'll want to create sub-accounts of `.testnet` (i.e `benjiman.testnet`).

```
near call YOUR_CONTRACT_ID.testnet new '{"linkdrop_contract": "testnet", "owner_id": "YOUR_CONTRACT_ID.testnet"}' --accountId YOUR_CONTRACT_ID.testnet
```

You're now ready to create custom linkdrops! You can either interact with the contract directly using the CLI or use one of the pre-deployed scripts.

## Using the CLI
After the contract is deployed, you have a couple options for creating linkdrops: 

- Creating single linkdrops.
- Creating multiple linkdrops at a time.

This will cover creating single linkdrops, however, the only differences between `send` and `send_multiple` are outlined in the [how it works](#how-it-works) flowchart section. 

- Start by creating a keypair locally (you can use near-api-js to do this as seen in the deploy scripts).
- Call the `send` function and pass in the `public_key`, `balance`. If creating a FT, NFT, or FC linkdrop, you must specify the struct as well. This is outlined in the respective sections.  

```bash
near call YOUR_CONTRACT_ID.testnet send '{"public_key": "ed25519:4iwBf6eAXZ4bcN6TWPikSqu3UJ2HUwF8wNNkGZrgDYqE", "balance": "10000000000000000000000"}' --deposit 1 --accountId "benjiman.testnet"
```

Once the function is successful, you can create the link and click it to claim the linkdrop:
```
    wallet.testnet.near.org/linkdrop/{YOUR_CONTRACT_ID.testnet}/{privKey1}
```

## Using the pre-deployed scripts

If you'd like to use some of the deploy scripts found in the `deploy` folder, those can help automate the process. 
<br />

### Simple Linkdrops with No NFTs or FTs

If you'd like to create a simple linkdrop with no pre-loaded NFTs or FTs, first specify the following environment variables:

```bash
export LINKDROP_PROXY_CONTRACT_ID="INSERT_HERE"
export FUNDING_ACCOUNT_ID="INSERT_HERE"
export LINKDROP_NEAR_AMOUNT="INSERT_HERE"
export SEND_MULTIPLE="false"
```

This will set the proxy contract that you wish to create linkdrops on, the account ID of the funding address (person creating the linkdrops and sending the funds), the actual $NEAR amount that the linkdrop will contain and whether or not to batch create linkdrops. By default, if the batch option is true, it will create 5 linkdrops. 

It is recommended to simply run a `dev-deploy` and use the dev contract ID to test these scripts. Once this is finished, run the following script:

```
node deploy/simple.js
```

Once the script has finished executing, a link to the wallet should appear in your console similar to: 

```bash
https://wallet.testnet.near.org/linkdrop/dev-1652794689263-24159113353222/4YULUt1hqv4s96Z8K83VoPnWqXK9vjfYb5QsBrv793aZ2jucBiLP35YWJq9rPGziRpDM35HEUftUtpP1WLzFocqJ
```

Once you've clicked the link, you can either fund an existing account with the linkdrop balance, or you can create a new account and fund it that way.
<br />

### Linkdrops with NFTs

If you'd like to create a linkdrop with a pre-loaded NFT, first specify the following environment variables:

```bash
export LINKDROP_PROXY_CONTRACT_ID="INSERT_HERE"
export FUNDING_ACCOUNT_ID="INSERT_HERE"
export LINKDROP_NEAR_AMOUNT="INSERT_HERE"
export SEND_MULTIPLE="false"
```

If you ran the script now, it would mint a predefined NFT on the contract `nft.examples.testnet`. If you wish to change the NFT contract or the metadata for the token, simply open the `deploy/nft.js` script and change the following lines:

```js
/*
	Hard coding NFT contract and metadata. Change this if you want.
*/
let NFT_CONTRACT_ID = "nft.examples.testnet";
const METADATA = {
	"title": "Linkdropped Go Team NFT",
	"description": "Testing Linkdrop NFT Go Team Token",
	"media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
	"media_hash": null,
	"copies": 10000,
	"issued_at": null,
	"expires_at": null,
	"starts_at": null,
	"updated_at": null,
	"extra": null,
	"reference": null,
	"reference_hash": null
};
```

Once you've either changed the NFT info or you're happy with minting a Go Team NFT on the example NFT contract, run the NFT script:

```
node deploy/nft.js
```

Once the script has finished executing, a link to the wallet should appear in your console similar to: 

```bash
https://wallet.testnet.near.org/linkdrop/dev-1652794689263-24159113353222/4YULUt1hqv4s96Z8K83VoPnWqXK9vjfYb5QsBrv793aZ2jucBiLP35YWJq9rPGziRpDM35HEUftUtpP1WLzFocqJ
```

Once you've clicked the link, you can either fund an existing account with the linkdrop balance, or you can create a new account and fund it that way. When this is finished, navigate to your collectibles tab and you should see an NFT similar to:

<p align="center">
  <img src="assets/claimed-nft.png"  style="width: 65%; height: 65%" alt="Logo">
  <br />
</p>

## Linkdrops with FTs

If you'd like to create a linkdrop with some pre-loaded FTs, you'll need to first specify the following environment variables:

```bash
export LINKDROP_PROXY_CONTRACT_ID="INSERT_HERE"
export FUNDING_ACCOUNT_ID="INSERT_HERE"
export LINKDROP_NEAR_AMOUNT="INSERT_HERE"
export SEND_MULTIPLE="false"
```

In addition, you need to specify the FT contract ID you'd like to pre-load the linkdrop with.

```bash
export FT_CONTRACT_ID="INSERT_HERE"
```
> **NOTE:** the FT script will pay for the proxy contract's storage but the funding account ID must be in possession of at least 25 FTs or else the script will panic.

Once this is finished, run the FT script.

```
node deploy/ft.js
```

Once the script has finished executing, a link to the wallet should appear in your console similar to: 

```bash
https://wallet.testnet.near.org/linkdrop/dev-1652794689263-24159113353222/4YULUt1hqv4s96Z8K83VoPnWqXK9vjfYb5QsBrv793aZ2jucBiLP35YWJq9rPGziRpDM35HEUftUtpP1WLzFocqJ
```

Once you've clicked the link, you can either fund an existing account with the linkdrop balance, or you can create a new account and fund it that way. When this is finished, you should see your fungible tokens:

<p align="center">
  <img src="assets/claimed-ft.png"  style="width: 65%; height: 65%" alt="Logo">
</p>

### Linkdrops with Function Calls

If you'd like to create a linkdrop whereby a function will be called upon claiming, first specify the following environment variables.

```bash
export LINKDROP_PROXY_CONTRACT_ID="INSERT_HERE"
export FUNDING_ACCOUNT_ID="INSERT_HERE"
export LINKDROP_NEAR_AMOUNT="INSERT_HERE"
export SEND_MULTIPLE="false"
```

This script will lazy mint an NFT once the linkdrop is claimed. Feel free to edit the logic in the script if you'd like to call a different function.

```
node deploy/function-call.js
```

Once the script has finished executing, a link to the wallet should appear in your console similar to: 

```bash
https://wallet.testnet.near.org/linkdrop/dev-1652794689263-24159113353222/4YULUt1hqv4s96Z8K83VoPnWqXK9vjfYb5QsBrv793aZ2jucBiLP35YWJq9rPGziRpDM35HEUftUtpP1WLzFocqJ
```

Once you've clicked the link, you can either fund an existing account with the linkdrop balance, or you can create a new account and fund it that way. When this is finished, navigate to your collectibles tab and you should see an NFT similar to:

<p align="center">
  <img src="assets/claimed-fc-nft.png"  style="width: 45%; height: 45%" alt="Logo">
  <br />
</p>

# Contributing

First off, thanks for taking the time to contribute! Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**.

Please try to create bug reports that are:

- _Reproducible._ Include steps to reproduce the problem.
- _Specific._ Include as much detail as possible: which version, what environment, etc.
- _Unique._ Do not duplicate existing opened issues.
- _Scoped to a Single Bug._ One bug per report.

Please adhere to this project's [code of conduct](docs/CODE_OF_CONDUCT.md).

You can use [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli) to check for common markdown style inconsistency.

# License

This project is licensed under the **GPL License**.

# Acknowledgements

Thanks for these awesome resources that were used during the development of the **Linkdrop Proxy Contract**:

- <https://github.com/dec0dOS/amazing-github-template>
- <https://github.com/near/near-linkdrop>
- <https://github.com/near/near-wallet/blob/master/packages/frontend/docs/Linkdrop.md>

'''
'''--- assets/CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project maintainer using any of the private contact addresses. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4, available at <https://www.contributor-covenant.org/version/1/4/code-of-conduct.html>

For answers to common questions about this code of conduct, see <https://www.contributor-covenant.org/faq>

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./out
cp target/wasm32-unknown-unknown/release/*.wasm ./out/main.wasm

'''
'''--- contract/Cargo.toml ---
[package]
name = "linkdrop-proxy"
version = "1.0.0"
authors = ["Ben Kurrek <bkurrek@uwaterloo.ca>, Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
'''
'''--- contract/src/internals/ext_traits.rs ---
use crate::*;

/// external and self callbacks
#[ext_contract(ext_linkdrop)]
trait ExtLinkdrop {
    fn create_account(&mut self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise;
}

/// NFT contract
#[ext_contract(ext_nft_contract)]
trait ExtNFTContract {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
    );
}

/// FT contract
#[ext_contract(ext_ft_contract)]
trait ExtFTContract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;
}

#[ext_contract(ext_self)]
trait ExtThis {
    /// self callback for simple linkdrops with no FTs, NFTs, or FCs.
    fn on_claim_simple(
        &mut self,
        // Account ID that sent the funds for the linkdrop
        funder_id: AccountId,
        // Balance contained within the linkdrop
        balance: U128,
        // How much storage was used up for the linkdrop
        storage_used: U128,
    ) -> bool;

    /// self callback for FT linkdrop
    fn on_claim_ft(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was used to store linkdrop info
        storage_used: U128,
        // Who sent the FTs?
        ft_sender: AccountId,
        // Where are the FTs stored
        ft_contract: AccountId,
        // How many FTs should we send
        ft_balance: U128,
        // How much storage does it cost to register the new account
        ft_storage: U128,
    ) -> bool;

    /// self callback for a linkdrop loaded with an NFT
    fn on_claim_nft(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was used to store linkdrop info
        storage_used: U128,
        // Sender of the NFT
        nft_sender: AccountId,
        // Contract where the NFT is stored
        nft_contract: AccountId,
        // Token ID for the NFT
        token_id: String,
    ) -> bool;

    /// self callback checks if account was created successfully or not. If yes, refunds excess storage, sends NFTs, FTs etc..
    fn on_claim_fc(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was used to store linkdrop info
        storage_used: U128,
        // Receiver of the function call
        receiver: AccountId,
        // Method to call on the contract
        method: String,
        // What args to pass in
        args: String,
        // What deposit should we attach
        deposit: U128,
        // Should the refund be sent to the funder or attached to the deposit
        add_refund_to_deposit: Option<bool>,
        // Should we add the account ID as part of the args and what key should it live in
        claimed_account_field: Option<String>,
    ) -> bool;

    fn nft_resolve_transfer(
        &mut self,
        token_id: String,
        token_sender: AccountId,
        token_contract: AccountId,
    );

    fn resolve_storage_check(
        &mut self,
        public_keys: Vec<PublicKey>,
        funder_id: AccountId,
        balance: U128,
        required_storage: U128,
        cb_ids: Vec<u64>,
    );
}

'''
'''--- contract/src/internals/helpers.rs ---
use crate::*;

const GAS_PER_CCC: Gas = Gas(5_000_000_000_000); // 5 TGas
const RECEIPT_GAS_COST: Gas = Gas(2_500_000_000_000); // 2.5 TGas

/// Used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &String) -> CryptoHash {
    env::sha256_array(account_id.as_bytes())
}

impl DropZone {
    /// Used to calculate the base allowance needed given attached GAS
    pub(crate) fn calculate_base_allowance(&self, attached_gas: Gas) -> u128 {
        // Get the number of CCCs you can make with the attached GAS
        let calls_with_gas = (attached_gas.0 / GAS_PER_CCC.0) as f32;
        // Get the constant used to pessimistically calculate the required allowance
        let pow_outcome = 1.03_f32.powf(calls_with_gas);

        // Get the required GAS based on the calculated constant
        let required_allowance = ((attached_gas.0 + RECEIPT_GAS_COST.0) as f32 * pow_outcome
            + RECEIPT_GAS_COST.0 as f32) as u128
            * self.yocto_per_gas;
        near_sdk::log!(
            "{} calls with {} attached GAS. Pow outcome: {}. Required Allowance: {}",
            calls_with_gas,
            attached_gas.0,
            pow_outcome,
            required_allowance
        );

        required_allowance
    }

    /// Add a drop ID to the set of drops a funder has
    pub(crate) fn internal_add_drop_to_funder(&mut self, account_id: &AccountId, drop_id: &DropId) {
        //get the set of drops for the given account
        let mut drop_set = self.drop_ids_for_funder.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any drops, we create a new unordered set
            UnorderedSet::new(StorageKey::DropIdsForFunderInner {
                //we get a new unique prefix for the collection
                account_id_hash: hash_account_id(&account_id.to_string()),
            })
        });

        //we insert the drop ID into the set
        drop_set.insert(drop_id);

        //we insert that set for the given account ID.
        self.drop_ids_for_funder.insert(account_id, &drop_set);
    }

    //remove a drop ID for a funder (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_drop_for_funder(
        &mut self,
        account_id: &AccountId,
        drop_id: &DropId,
    ) {
        //we get the set of drop IDs that the funder has
        let mut drop_set = self
            .drop_ids_for_funder
            .get(account_id)
            //if there is no set of drops for the owner, we panic with the following message:
            .expect("No Drops found for the funder");

        //we remove the the drop ID from  the set of drops
        drop_set.remove(drop_id);

        //if the set is now empty, we remove the funder from the drop_ids_for_funder collection
        if drop_set.is_empty() {
            self.drop_ids_for_funder.remove(account_id);
        } else {
            //if the key set is not empty, we simply insert it back for the funder ID.
            self.drop_ids_for_funder.insert(account_id, &drop_set);
        }
    }

    /// Internal function for executing the callback code either straight up or using `.then` for a passed in promise
    pub(crate) fn internal_execute(
        &mut self,
        drop_data: Drop,
        drop_id: DropId,
        cur_claims_for_key: u64,
        account_id: AccountId,
        storage_freed: u128,
        token_id: Option<String>,
        storage_for_longest: Option<u128>,
        promise: Option<Promise>,
    ) {
        macro_rules! resolve_promise_or_call {
            ( $func:ident ( $($call:tt)* ) ) => {
                if let Some(promise) = promise {
                    promise.then(
                        // Call on_claim_fc with all unspent GAS + min gas for on claim. No attached deposit.
                        Self::ext(env::current_account_id())
                        .with_static_gas(MIN_GAS_FOR_ON_CLAIM)
                        .$func(
                            $($call)*
                            // Executing the function and treating it like a callback.
                            false,
                        )
                    );
                } else {
                    // We're not dealing with a promise so we simply execute the function.
                    self.$func(
                        $($call)*
                        // Executing the function and treating it NOT like a callback.
                        true,
                    );
                }
            }
        }
        // Determine what callback we should use depending on the drop type
        match drop_data.drop_type {
            DropType::FC(data) => {
                // If we're dealing with a promise, execute the callback
                resolve_promise_or_call!(on_claim_fc(
                    // Account ID that claimed the linkdrop
                    account_id,
                    // Account ID that funded the linkdrop
                    drop_data.funder_id,
                    // Balance associated with the linkdrop
                    drop_data.balance,
                    // How much storage was freed when the key was claimed
                    storage_freed,
                    // FC Data
                    data,
                    // Drop ID
                    drop_id,
                    // Current number of claims left on the key before decrementing
                    cur_claims_for_key,
                    // Maximum number of claims
                    drop_data.drop_config.max_claims_per_key,
                ));
            }
            DropType::NFT(data) => {
                resolve_promise_or_call!(on_claim_nft(
                    // Account ID that claimed the linkdrop
                    account_id,
                    // Account ID that funded the linkdrop
                    drop_data.funder_id,
                    // Balance associated with the linkdrop
                    drop_data.balance,
                    // How much storage was freed when the key was claimed
                    storage_freed,
                    // How much storage was prepaid to cover the longest token ID being inserted.
                    storage_for_longest.expect("no storage for longest token Id found"),
                    // Sender of the NFT
                    data.nft_sender,
                    // Contract where the NFT is stored
                    data.nft_contract,
                    // Token ID for the NFT
                    token_id.expect("no token ID found"),
                ));
            }
            DropType::FT(data) => {
                resolve_promise_or_call!(on_claim_ft(
                    // Account ID that claimed the linkdrop
                    account_id,
                    // Account ID that funded the linkdrop
                    drop_data.funder_id,
                    // Balance associated with the linkdrop
                    drop_data.balance,
                    // How much storage was freed when the key was claimed
                    storage_freed,
                    // FT Data to be used
                    data,
                ));
            }
            DropType::Simple => {
                promise.unwrap().then(
                    // Call on_claim_simple with all unspent GAS + min gas for on claim. No attached deposit.
                    Self::ext(env::current_account_id())
                        .with_static_gas(MIN_GAS_FOR_ON_CLAIM)
                        .on_claim_simple(
                            // Account ID that funded the linkdrop
                            drop_data.funder_id,
                            // Balance associated with the linkdrop
                            drop_data.balance,
                            // How much storage was freed when the key was claimed
                            storage_freed,
                        ),
                );
            }
        };
    }
}

'''
'''--- contract/src/internals/mod.rs ---
pub mod ext_traits;
pub mod helpers;
pub mod owner;
pub mod storage;

pub use ext_traits::*;
pub(crate) use helpers::*;
pub use owner::*;
pub use storage::*;

'''
'''--- contract/src/internals/owner.rs ---
use crate::*;

#[near_bindgen]
impl DropZone {
    /// Set the desired linkdrop contract to interact with
    pub fn set_contract(&mut self, linkdrop_contract: AccountId) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "predecessor != owner"
        );
        self.linkdrop_contract = linkdrop_contract;
    }

    /// Set the desired linkdrop contract to interact with
    pub fn set_gas_price(&mut self, yocto_per_gas: u128) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "predecessor != owner"
        );
        self.yocto_per_gas = yocto_per_gas;
    }

    /// Withdraw the fees collected to the passed in Account Id
    pub fn withdraw_fees(&mut self, withdraw_to: AccountId) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "predecessor != owner"
        );
        let amount = self.fees_collected;
        self.fees_collected = 0;

        Promise::new(withdraw_to)
            .transfer(amount)
            .then(Self::ext(env::current_account_id()).on_withdraw_fees(amount))
    }

    /// Callback for withdrawing fees on the contract
    #[private]
    pub fn on_withdraw_fees(&mut self, fees_collected: u128) -> bool {
        let result = promise_result_as_success();

        // If something went wrong, set the fees collected again
        if result.is_none() {
            self.fees_collected += fees_collected;
            return false;
        }

        true
    }
}

'''
'''--- contract/src/internals/storage.rs ---
use crate::*;

#[near_bindgen]
impl DropZone {
    // Allows users to add to their balance. This is to prepay and cover drop costs
    #[payable]
    pub fn add_to_balance(&mut self) {
        // Get the deposit value which is how much the user wants to add to their storage
        let deposit = env::attached_deposit();

        // Get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let mut balance: u128 = self
            .user_balances
            .get(&env::predecessor_account_id())
            .unwrap_or(0);
        // Add the deposit to their balance
        balance += deposit;
        // Insert the balance back into the map for that account ID
        self.user_balances
            .insert(&env::predecessor_account_id(), &balance);
    }

    // Allows users to withdraw their balance
    #[payable]
    pub fn withdraw_from_balance(&mut self) {
        // the account to withdraw storage to is always the predecessor
        let owner_id = env::predecessor_account_id();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let amount = self.user_balances.remove(&owner_id).unwrap_or(0);

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }
    }

    // Return the current balance for a given account
    pub fn get_user_balance(&self, account_id: AccountId) -> U128 {
        U128(self.user_balances.get(&account_id).unwrap_or(0))
    }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{
    env, ext_contract, near_bindgen, promise_result_as_success, require, AccountId, Balance,
    BorshStorageKey, CryptoHash, Gas, PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
    PublicKey,
};

/*
    minimum amount of storage required to store an access key on the contract
    1_330_000_000_000_000_000_000 Simple linkdrop: 0.00133 $NEAR
    2_420_000_000_000_000_000_000 NFT Linkdrop: 0.00242 $NEAR
*/
const ACCESS_KEY_STORAGE: u128 = 1_000_000_000_000_000_000_000; // 0.001 N

/*
    minimum amount of NEAR that a new account (with longest possible name) must have when created
    If this is less, it will throw a lack balance for state error (assuming you have the same account ID length)
*/
const NEW_ACCOUNT_BASE: u128 = 2_840_000_000_000_000_000_000; // 0.00284 N

/// Indicates there are no deposit for a callback for better readability.
const NO_DEPOSIT: u128 = 0;

/*
    GAS Constants (outlines the minimum to attach. Any unspent GAS will be added according to the weights)
*/
const MIN_GAS_FOR_ON_CLAIM: Gas = Gas(55_000_000_000_000); // 55 TGas

// NFTs
const MIN_GAS_FOR_SIMPLE_NFT_TRANSFER: Gas = Gas(10_000_000_000_000); // 10 TGas
const MIN_GAS_FOR_RESOLVE_TRANSFER: Gas =
    Gas(15_000_000_000_000 + MIN_GAS_FOR_SIMPLE_NFT_TRANSFER.0); // 15 TGas + 10 TGas = 25 TGas

// FTs
// Actual amount of GAS to attach when querying the storage balance bounds. No unspent GAS will be attached on top of this (weight of 0)
const GAS_FOR_STORAGE_BALANCE_BOUNDS: Gas = Gas(10_000_000_000_000); // 10 TGas
const MIN_GAS_FOR_RESOLVE_STORAGE_CHECK: Gas = Gas(25_000_000_000_000); // 25 TGas
const MIN_GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000); // 5 TGas
const MIN_GAS_FOR_STORAGE_DEPOSIT: Gas = Gas(5_000_000_000_000); // 5 TGas
const MIN_GAS_FOR_RESOLVE_BATCH: Gas =
    Gas(13_000_000_000_000 + MIN_GAS_FOR_FT_TRANSFER.0 + MIN_GAS_FOR_STORAGE_DEPOSIT.0); // 13 TGas + 5 TGas + 5 TGas = 23 TGas

// Specifies the GAS being attached from the wallet site
const ATTACHED_GAS_FROM_WALLET: Gas = Gas(100_000_000_000_000); // 100 TGas

// Specifies the amount of GAS to attach on top of the FC Gas if executing a regular function call in claim
const GAS_OFFSET_IF_FC_EXECUTE: Gas = Gas(20_000_000_000_000); // 20 TGas

// Actual amount of GAS to attach when creating a new account. No unspent GAS will be attached on top of this (weight of 0)
const GAS_FOR_CREATE_ACCOUNT: Gas = Gas(28_000_000_000_000); // 28 TGas

/// Both methods callable by the function call access key
const ACCESS_KEY_BOTH_METHOD_NAMES: &str = "claim,create_account_and_claim";

/// Only the claim method is callable by the access key
const ACCESS_KEY_CLAIM_METHOD_NAME: &str = "claim";

/*
    FEES
*/
const DROP_CREATION_FEE: u128 = 1_000_000_000_000_000_000_000_000; // 0.1 N
const KEY_ADDITION_FEE: u128 = 5_000_000_000_000_000_000_000; // 0.005 N

const GAS_FOR_PANIC_OFFSET: Gas = Gas(10_000_000_000_000); // 10 TGas

mod internals;
mod stage1;
mod stage2;
mod stage3;
mod views;

use internals::*;
use stage1::*;
use stage2::*;

pub(crate) fn yocto_to_near(yocto: u128) -> f64 {
    //10^20 yoctoNEAR (1 NEAR would be 10_000). This is to give a precision of 4 decimal places.
    let formatted_near = yocto / 100_000_000_000_000_000_000;
    let near = formatted_near as f64 / 10_000_f64;

    near
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    DropIdForPk,
    DropsForId,
    DropIdsForFunder,
    DropIdsForFunderInner { account_id_hash: CryptoHash },
    PksForDrop { account_id_hash: CryptoHash },
    TokenIdsForDrop { account_id_hash: CryptoHash },
    UserBalances,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct DropZone {
    pub owner_id: AccountId,
    // Which contract is the actual linkdrop deployed to (i.e `testnet` or `near`)
    pub linkdrop_contract: AccountId,

    // Map each key to a nonce rather than repeating each drop data in memory
    pub drop_id_for_pk: UnorderedMap<PublicKey, DropId>,
    // Map the nonce to a specific drop
    pub drop_for_id: LookupMap<DropId, Drop>,
    // Keep track of the drop ids for each funder for pagination
    pub drop_ids_for_funder: LookupMap<AccountId, UnorderedSet<DropId>>,

    // Fees taken by the contract. One is for creating a drop, the other is for each key in the drop.
    pub drop_fee: u128,
    pub key_fee: u128,
    pub fees_collected: u128,

    // keep track of the balances for each user. This is to prepay for drop creations
    pub user_balances: LookupMap<AccountId, Balance>,

    // Keep track of a nonce used for the drop IDs
    pub nonce: DropId,

    // Keep track of the price of 1 GAS per 1 yocto
    pub yocto_per_gas: u128,
}

#[near_bindgen]
impl DropZone {
    /// Initialize contract and pass in the desired deployed linkdrop contract (i.e testnet or near)
    #[init]
    pub fn new(linkdrop_contract: AccountId, owner_id: AccountId) -> Self {
        Self {
            owner_id,
            linkdrop_contract,
            drop_id_for_pk: UnorderedMap::new(StorageKey::DropIdForPk),
            drop_for_id: LookupMap::new(StorageKey::DropsForId),
            drop_ids_for_funder: LookupMap::new(StorageKey::DropIdsForFunder),
            user_balances: LookupMap::new(StorageKey::UserBalances),
            nonce: 0,
            /*
                FEES
            */
            drop_fee: DROP_CREATION_FEE,
            key_fee: KEY_ADDITION_FEE,
            fees_collected: 0,
            yocto_per_gas: 100_000_000,
        }
    }
}

'''
'''--- contract/src/stage1/delete.rs ---
use std::convert::TryInto;

use near_sdk::GasWeight;

use crate::*;

#[near_bindgen]
impl DropZone {
    /*
        User can pass in a vector of public keys or a drop ID.
        If a drop ID is passed in, it will auto delete up to limit.
        If limit is not specified, auto assume 100 keys from the drop.
        All keys must be from the same drop ID.

        All keys must be unregistered (NFTs / FTs refunded) for the drop.
    */
    pub fn delete_keys(
        &mut self,
        drop_id: DropId,
        public_keys: Option<Vec<PublicKey>>,
        limit: Option<u8>,
    ) {
        // Measure initial storage before doing any operations
        let initial_storage = env::storage_usage();

        // get the drop object
        let mut drop = self.drop_for_id.remove(&drop_id).expect("No drop found");
        let funder_id = drop.funder_id.clone();
        let drop_type = &drop.drop_type;
        require!(
            funder_id == env::predecessor_account_id(),
            "only drop funder can delete keys"
        );

        // Get optional costs
        let mut nft_optional_costs_per_key = 0;
        let mut ft_optional_costs_per_claim = 0;

        // ensure that there are no FTs or NFTs left to be refunded
        match drop_type {
            DropType::NFT(data) => {
                require!(
                    drop.num_claims_registered == 0,
                    "NFTs must be refunded before keys are deleted"
                );

                nft_optional_costs_per_key = data.storage_for_longest * env::storage_byte_cost();
            }
            DropType::FT(data) => {
                require!(
                    drop.num_claims_registered == 0,
                    "FTs must be refunded before keys are deleted"
                );

                ft_optional_costs_per_claim = data.ft_storage.0;
            }
            _ => {}
        };

        // Keep track of the total refund amount
        let total_refund_amount;
        // Default the keys to use to be the public keys or an empty vector. We'll populate it if no PKs are passed in.
        let keys_to_delete;
        let mut total_allowance_left = 0;

        // Get the total number of claims and none FCs across all keys being deleted
        let mut total_num_claims_left = 0;
        let mut total_num_none_fcs = 0;
        let mut total_deposit_value = 0;
        // If the user passed in public keys, loop through and remove them from the drop
        if let Some(keys) = public_keys {
            // Set the keys to delete equal to the keys passed in
            keys_to_delete = keys;

            let len = keys_to_delete.len() as u128;
            require!(
                len <= limit.unwrap_or(100) as u128,
                "cannot delete more than 100 keys at a time"
            );
            near_sdk::log!("Removing {} keys from the drop", len);

            // Loop through and remove keys
            for key in &keys_to_delete {
                // Unlink key to drop ID
                self.drop_id_for_pk.remove(key);
                // Attempt to remove the public key. panic if it didn't exist
                let key_usage = drop.pks.remove(key).expect("public key must be in drop");
                total_num_claims_left += key_usage.num_uses;

                // If the drop is FC, we need to loop through method data for the remaining number of
                // Claims and get the deposits left along with the total number of None FCs
                if let DropType::FC(data) = &drop.drop_type {
                    let num_fcs = data.method_data.len() as u64;

                    // If there's one FC specified and more than 1 claim per key, that FC is to be used
                    // For all the claims. In this case, we need to tally all the deposits for each claim.
                    if drop.drop_config.max_claims_per_key > 1 && num_fcs == 1 {
                        let deposit = data
                            .method_data
                            .iter()
                            .next()
                            .unwrap()
                            .clone()
                            .expect("cannot have a single none function call")
                            .deposit
                            .0;
                        total_deposit_value += key_usage.num_uses as u128 * deposit;

                    // In the case where either there's 1 claim per key or the number of FCs is not 1,
                    // We can simply loop through and manually get this data
                    } else {
                        // We need to loop through the remaining methods. This means we should skip and start at the
                        // MAX - keys left
                        let starting_index =
                            (drop.drop_config.max_claims_per_key - key_usage.num_uses) as usize;
                        for method in data.method_data.iter().skip(starting_index) {
                            total_num_none_fcs += method.is_none() as u64;
                            total_deposit_value += method.clone().map(|m| m.deposit.0).unwrap_or(0);
                        }
                    }
                }

                // Increment the allowance left by whatever is left on the key
                total_allowance_left += key_usage.allowance;
            }

            // If the drop has no keys, remove it from the funder. Otherwise, insert it back with the updated keys.
            if drop.pks.len() == 0 {
                near_sdk::log!("Drop empty. Removing from funder");
                self.internal_remove_drop_for_funder(&funder_id, &drop_id);
            } else {
                near_sdk::log!("Drop non empty. Adding back. Len: {}", drop.pks.len());
                self.drop_for_id.insert(&drop_id, &drop);
            }

            // Calculate the storage being freed. initial - final should be >= 0 since final should be smaller than initial.
            let final_storage = env::storage_usage();
            let total_storage_freed =
                Balance::from(initial_storage - final_storage) * env::storage_byte_cost();
            near_sdk::log!(
                "Storage freed: {} bytes: {}",
                yocto_to_near(total_storage_freed),
                total_storage_freed
            );

            /*
                Required deposit consists of:
                - TOTAL Storage freed
                - Total access key allowance for EACH key
                - Access key storage for EACH key
                - Balance for each key * (number of claims - claims with None for FC Data)

                Optional:
                - total FC deposits
                - storage for longest token ID for each key
                - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
            */
            total_refund_amount = total_storage_freed
                + drop.balance.0 * (total_num_claims_left - total_num_none_fcs) as u128
                + ft_optional_costs_per_claim * total_num_claims_left as u128
                + total_deposit_value
                + total_allowance_left
                + (ACCESS_KEY_STORAGE + nft_optional_costs_per_key) * len;

            near_sdk::log!(
                "Total refund: {}
                storage freed: {}
                drop balance: {}
                FT costs per claim: {}
                total deposit value: {}
                total allowance left: {}
                access key storage: {}
                nft optional costs per key: {}
                total num claims left: {}
                total num none FCs {}
                len: {}",
                yocto_to_near(total_refund_amount),
                yocto_to_near(total_storage_freed),
                yocto_to_near(drop.balance.0),
                yocto_to_near(ft_optional_costs_per_claim),
                yocto_to_near(total_deposit_value),
                yocto_to_near(total_allowance_left),
                yocto_to_near(ACCESS_KEY_STORAGE),
                yocto_to_near(nft_optional_costs_per_key),
                total_num_claims_left,
                total_num_none_fcs,
                len
            );
        } else {
            // If no PKs were passed in, attempt to remove limit or 100 keys at a time
            keys_to_delete = drop.pks.keys().take(limit.unwrap_or(100).into()).collect();

            let len = keys_to_delete.len() as u128;
            near_sdk::log!("Removing {} keys from the drop", len);

            // Loop through and remove keys
            for key in &keys_to_delete {
                // Unlink key to drop ID
                self.drop_id_for_pk.remove(key);
                // Attempt to remove the public key. panic if it didn't exist
                let key_usage = drop.pks.remove(key).expect("public key must be in drop");
                total_num_claims_left += key_usage.num_uses;

                // If the drop is FC, we need to loop through method data for the remaining number of
                // Claims and get the deposits left along with the total number of None FCs
                if let DropType::FC(data) = &drop.drop_type {
                    let num_fcs = data.method_data.len() as u64;

                    // If there's one FC specified and more than 1 claim per key, that FC is to be used
                    // For all the claims. In this case, we need to tally all the deposits for each claim.
                    if drop.drop_config.max_claims_per_key > 1 && num_fcs == 1 {
                        let deposit = data
                            .method_data
                            .iter()
                            .next()
                            .unwrap()
                            .clone()
                            .expect("cannot have a single none function call")
                            .deposit
                            .0;
                        total_deposit_value += key_usage.num_uses as u128 * deposit;

                    // In the case where either there's 1 claim per key or the number of FCs is not 1,
                    // We can simply loop through and manually get this data
                    } else {
                        // We need to loop through the remaining methods. This means we should skip and start at the
                        // MAX - keys left
                        let starting_index =
                            (drop.drop_config.max_claims_per_key - key_usage.num_uses) as usize;
                        for method in data.method_data.iter().skip(starting_index) {
                            total_num_none_fcs += method.is_none() as u64;
                            total_deposit_value += method.clone().map(|m| m.deposit.0).unwrap_or(0);
                        }
                    }
                }

                // Increment the allowance left by whatever is left on the key
                total_allowance_left += key_usage.allowance;
            }

            // If the drop has no keys, remove it from the funder. Otherwise, insert it back with the updated keys.
            if drop.pks.len() == 0 {
                near_sdk::log!("Drop empty. Removing from funder");
                self.internal_remove_drop_for_funder(&funder_id, &drop_id);
            } else {
                near_sdk::log!("Drop non empty. Adding back. Len: {}", drop.pks.len());
                self.drop_for_id.insert(&drop_id, &drop);
            }

            // Calculate the storage being freed. initial - final should be >= 0 since final should be smaller than initial.
            let final_storage = env::storage_usage();
            let total_storage_freed =
                Balance::from(initial_storage - final_storage) * env::storage_byte_cost();
            near_sdk::log!(
                "Storage freed: {} bytes: {}",
                yocto_to_near(total_storage_freed),
                total_storage_freed
            );

            /*
                Required deposit consists of:
                - TOTAL Storage freed
                - Total access key allowance for EACH key
                - Access key storage for EACH key
                - Balance for each key * (number of claims - claims with None for FC Data)

                Optional:
                - total FC deposits
                - storage for longest token ID for each key
                - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
            */
            total_refund_amount = total_storage_freed
                + drop.balance.0 * (total_num_claims_left - total_num_none_fcs) as u128
                + ft_optional_costs_per_claim * total_num_claims_left as u128
                + total_deposit_value
                + total_allowance_left
                + (ACCESS_KEY_STORAGE + nft_optional_costs_per_key) * len;

            near_sdk::log!(
                "Total refund: {}
                storage freed: {}
                drop balance: {}
                FT costs per claim: {}
                total deposit value: {}
                total allowance left: {}
                access key storage: {}
                nft optional costs per key: {}
                total num claims left: {}
                total num none FCs {}
                len: {}",
                yocto_to_near(total_refund_amount),
                yocto_to_near(total_storage_freed),
                yocto_to_near(drop.balance.0),
                yocto_to_near(ft_optional_costs_per_claim),
                yocto_to_near(total_deposit_value),
                yocto_to_near(total_allowance_left),
                yocto_to_near(ACCESS_KEY_STORAGE),
                yocto_to_near(nft_optional_costs_per_key),
                total_num_claims_left,
                total_num_none_fcs,
                len
            );
        }

        // Refund the user
        let mut cur_balance = self.user_balances.get(&funder_id).unwrap_or(0);
        near_sdk::log!(
            "Refunding user {} old balance: {}. Total allowance left: {}",
            yocto_to_near(total_refund_amount),
            yocto_to_near(cur_balance),
            yocto_to_near(total_allowance_left)
        );
        cur_balance += total_refund_amount;
        self.user_balances.insert(&funder_id, &cur_balance);

        // Loop through and delete keys
        for key in &keys_to_delete {
            // Create the batch promise
            let promise = env::promise_batch_create(&env::current_account_id());

            env::promise_batch_action_delete_key(promise, &key);

            env::promise_return(promise);
        }
    }

    /*
        Refund NFTs or FTs for a drop. User can optionally pass in a number of assets to
        refund. If not, it will try to refund all assets.
    */
    pub fn refund_assets(&mut self, drop_id: DropId, assets_to_refund: Option<u64>) {
        // get the drop object
        let mut drop = self.drop_for_id.get(&drop_id).expect("No drop found");
        let funder_id = drop.funder_id.clone();
        require!(
            funder_id == env::predecessor_account_id(),
            "only drop funder can delete keys"
        );

        // Get the number of claims registered for the drop.
        let claims_registered = drop.num_claims_registered;
        require!(claims_registered > 0, "no claims left to unregister");

        // Get the claims to refund. If not specified, this is the number of claims currently registered.
        let num_to_refund = assets_to_refund.unwrap_or(claims_registered);
        require!(
            num_to_refund <= claims_registered,
            "can only refund less than or equal to the amount of keys registered"
        );

        // Decrement the drop's keys registered temporarily. If the transfer is unsuccessful, revert in callback.
        drop.num_claims_registered -= num_to_refund;
        self.drop_for_id.insert(&drop_id, &drop);

        match drop.drop_type {
            DropType::NFT(data) => {
                /*
                    NFTs need to be batched together. Loop through and transfer all NFTs.
                    Keys registered will be decremented and the token IDs will be removed
                    in the callback if everything is successful. If anything fails, the
                    keys registered will be added back in the callback for the drop.
                */
                let nft_batch_index = env::promise_batch_create(&data.nft_contract);
                let token_ids: Vec<String> = data
                    .token_ids
                    .iter()
                    .take(num_to_refund.try_into().unwrap())
                    .collect();
                require!(
                    token_ids.len() as u64 == num_to_refund,
                    "not enough token IDs"
                );

                // TODO: delete token IDs from unordered set as mentioned in this discussion: https://github.com/mattlockyer/linkdrop/pull/6#discussion_r913345144
                // Loop through each token ID and add a transfer to the batch
                for token_id in token_ids.clone() {
                    // Send the NFTs back to the sender
                    // Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call
                    env::promise_batch_action_function_call_weight(
                        nft_batch_index,
                        "nft_transfer",
                        json!({ "receiver_id": data.nft_sender, "token_id": token_id, "memo": "Refund" }).to_string().as_bytes(),
                        1,
                        MIN_GAS_FOR_SIMPLE_NFT_TRANSFER,
                        GasWeight(1)
                    );
                }

                // Create the second batch promise to execute after the nft_batch_index batch is finished executing.
                // It will execute on the current account ID (this contract)
                let batch_ft_resolve_promise_id =
                    env::promise_batch_then(nft_batch_index, &env::current_account_id());

                // Execute a function call as part of the resolved promise index created in promise_batch_then
                // Callback after all NFTs were refunded
                // Call the function with the min GAS and then attach 10/(10 + num_to_refund) of the unspent GAS to the call
                env::promise_batch_action_function_call_weight(
                    batch_ft_resolve_promise_id,
                    "nft_resolve_refund",
                    json!({ "drop_id": U128(drop_id), "token_ids": token_ids })
                        .to_string()
                        .as_bytes(),
                    NO_DEPOSIT,
                    MIN_GAS_FOR_RESOLVE_BATCH,
                    GasWeight(10),
                );
            }
            DropType::FT(data) => {
                // All FTs can be refunded at once. Funder responsible for registering themselves
                ext_ft_contract::ext(data.ft_contract)
                    // Call ft transfer with 1 yoctoNEAR. 1/2 unspent GAS will be added on top
                    .with_attached_deposit(1)
                    .ft_transfer(
                        data.ft_sender,
                        U128(data.ft_balance.0 * num_to_refund as u128),
                        None,
                    )
                    // We then resolve the promise and call nft_resolve_transfer on our own contract
                    .then(
                        // Call resolve refund with the min GAS and no deposit. 1/2 unspent GAS will be added on top
                        Self::ext(env::current_account_id())
                            .ft_resolve_refund(drop_id, num_to_refund),
                    )
                    .as_return();
            }
            _ => env::panic_str("can only refund assets for FT and NFT drops"),
        };
    }
}

'''
'''--- contract/src/stage1/drops.rs ---
use crate::*;
use near_sdk::{require, Balance};

pub type DropId = u128;

#[derive(BorshSerialize, BorshDeserialize)]
pub enum DropType {
    Simple,
    NFT(NFTData),
    FT(FTData),
    FC(FCData),
}

/// Keep track of different configuration options for each key in a drop
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct KeyUsage {
    // How many usages this key has. Once 0 is reached, the key is deleted
    pub num_uses: u64,

    // When was the last time the key was used
    pub last_used: u64,

    // How much allowance does the key have left. When the key is deleted, this is refunded to the funder's balance.
    pub allowance: u128,
}

/// Keep track of different configuration options for each key in a drop
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct DropConfig {
    // How many claims can each key have
    pub max_claims_per_key: u64,

    // Minimum block timestamp that keys can be used. If None, keys can be used immediately
    // Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub start_timestamp: Option<u64>,

    // How often can a key be used
    pub usage_interval: Option<u64>,

    // If regular claim is called and no account is created, should the balance be refunded to the funder
    pub refund_if_claim: Option<bool>,

    // Can the access key only call the claim method? Default to both method callable
    pub only_call_claim: Option<bool>,
}

// Drop Metadata should be a string which can be JSON or anything the users want.
pub type DropMetadata = String;

/// Keep track of specific data related to an access key. This allows us to optionally refund funders later.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Drop {
    // Funder of this specific drop
    pub funder_id: AccountId,
    // Set of public keys associated with this drop mapped to their usages
    pub pks: UnorderedMap<PublicKey, KeyUsage>,

    // Balance for all keys of this drop. Can be 0 if specified.
    pub balance: U128,

    // How many claims
    pub num_claims_registered: u64,

    // Ensure this drop can only be used when the function has the required gas to attach
    pub required_gas_attached: Gas,

    // Every drop must have a type
    pub drop_type: DropType,

    // The drop as a whole can have a config as well
    pub drop_config: DropConfig,

    // Metadata for the drop
    pub drop_metadata: Option<DropMetadata>,
}

#[near_bindgen]
impl DropZone {
    /*
        user has created a bunch of keypairs and passed in the public keys and attached some deposit.
        this will store the account data and allow that keys to call claim and create_account_and_claim
        on this contract.

        The balance is the amount of $NEAR the sender wants each linkdrop to contain.
    */
    #[payable]
    pub fn create_drop(
        &mut self,
        public_keys: Vec<PublicKey>,
        balance: U128,
        drop_config: DropConfig,
        drop_metadata: Option<DropMetadata>,
        ft_data: Option<FTDataConfig>,
        nft_data: Option<NFTDataConfig>,
        fc_data: Option<FCData>,
    ) -> DropId {
        // Ensure the user has only specified one type of callback data
        let num_cbs_specified =
            ft_data.is_some() as u8 + nft_data.is_some() as u8 + fc_data.is_some() as u8;
        require!(
            num_cbs_specified <= 1,
            "You cannot specify more than one callback data"
        );

        // Warn if the balance for each drop is less than the minimum
        if balance.0 < NEW_ACCOUNT_BASE {
            near_sdk::log!(
                "Warning: Balance is less than absolute minimum for creating an account: {}",
                NEW_ACCOUNT_BASE
            );
        }

        // Funder is the predecessor
        let funder_id = env::predecessor_account_id();
        let len = public_keys.len() as u128;
        let drop_id = self.nonce;
        // Get the number of claims per key to dictate what key usage data we should put in the map
        let num_claims_per_key = drop_config.max_claims_per_key;
        require!(
            num_claims_per_key > 0,
            "cannot have less than 1 claim per key"
        );

        // Get the current balance of the funder.
        let mut current_user_balance = self
            .user_balances
            .get(&funder_id)
            .expect("No user balance found");
        near_sdk::log!("Cur User balance {}", yocto_to_near(current_user_balance));

        // Pessimistically measure storage
        let initial_storage = env::storage_usage();
        let mut key_map: UnorderedMap<PublicKey, KeyUsage> =
            UnorderedMap::new(StorageKey::PksForDrop {
                // We get a new unique prefix for the collection
                account_id_hash: hash_account_id(&format!("{}{}", self.nonce, funder_id)),
            });

        // Decide what methods the access keys can call
        let mut access_key_method_names = ACCESS_KEY_BOTH_METHOD_NAMES;
        if drop_config.only_call_claim.unwrap_or(false) {
            access_key_method_names = ACCESS_KEY_CLAIM_METHOD_NAME;
        }

        // Default the gas to attach to be the gas from the wallet. This will be used to calculate allowances.
        let mut gas_to_attach = ATTACHED_GAS_FROM_WALLET;
        // Depending on the FC Data, set the Gas to attach and the access key method names
        if let Some(gas) = fc_data
            .clone()
            .and_then(|d| d.config.and_then(|c| c.gas_if_claim_only))
        {
            require!(
                balance.0 == 0,
                "cannot specify gas to attach and have a balance in the linkdrop"
            );
            require!(
                gas <= ATTACHED_GAS_FROM_WALLET - GAS_OFFSET_IF_FC_EXECUTE,
                &format!(
                    "cannot attach more than {:?} GAS.",
                    ATTACHED_GAS_FROM_WALLET - GAS_OFFSET_IF_FC_EXECUTE
                )
            );
            gas_to_attach = gas + GAS_OFFSET_IF_FC_EXECUTE;
            access_key_method_names = ACCESS_KEY_CLAIM_METHOD_NAME;
        }

        // Calculate the base allowance to attach
        let calculated_base_allowance = self.calculate_base_allowance(gas_to_attach);
        // The actual allowance is the base * number of claims per key since each claim can potentially use the max pessimistic GAS.
        let actual_allowance = calculated_base_allowance * num_claims_per_key as u128;

        // Loop through and add each drop ID to the public keys. Also populate the key set.
        for pk in &public_keys {
            key_map.insert(
                pk,
                &KeyUsage {
                    num_uses: num_claims_per_key,
                    last_used: 0, // Set to 0 since this will make the key always claimable.
                    allowance: actual_allowance,
                },
            );
            require!(
                self.drop_id_for_pk.insert(pk, &drop_id).is_none(),
                "Keys cannot belong to another drop"
            );
        }

        // Add this drop ID to the funder's set of drops
        self.internal_add_drop_to_funder(&env::predecessor_account_id(), &drop_id);

        // Create drop object
        let mut drop = Drop {
            funder_id: env::predecessor_account_id(),
            balance,
            pks: key_map,
            drop_type: DropType::Simple, // Default to simple but will overwrite if not
            drop_config: drop_config.clone(),
            num_claims_registered: num_claims_per_key * len as u64,
            required_gas_attached: gas_to_attach,
            drop_metadata,
        };

        // For NFT drops, measure the storage for adding the longest token ID
        let mut storage_per_longest = 0;
        // Keep track of the total deposit required for the FC data (depending on None and Some cases)
        let mut deposit_required_for_fc_deposits = 0;
        // Keep track of the number of none FCs so we don't charge the user
        let mut num_none_fcs = 0;
        // If NFT data was provided, we need to build the set of token IDs and cast the config to actual NFT data
        if let Some(data) = nft_data {
            let NFTDataConfig {
                nft_sender,
                nft_contract,
                longest_token_id,
            } = data;

            // Create the token ID set and insert the longest token ID
            let token_ids = UnorderedSet::new(StorageKey::TokenIdsForDrop {
                //we get a new unique prefix for the collection
                account_id_hash: hash_account_id(&format!("nft-{}{}", self.nonce, funder_id)),
            });

            // Create the NFT data
            let actual_nft_data = NFTData {
                nft_sender,
                nft_contract,
                longest_token_id: longest_token_id.clone(),
                storage_for_longest: u128::MAX,
                token_ids,
            };

            // The number of claims is 0 until NFTs are sent to the contract
            drop.num_claims_registered = 0;
            drop.drop_type = DropType::NFT(actual_nft_data);

            // Add the drop with the empty token IDs
            self.drop_for_id.insert(&drop_id, &drop);

            // Measure how much storage it costs to insert the 1 longest token ID
            let initial_nft_storage_one = env::storage_usage();
            // Now that the drop has been added, insert the longest token ID and measure storage
            if let DropType::NFT(data) = &mut drop.drop_type {
                data.token_ids.insert(&longest_token_id);
            }

            // Add drop with the longest possible token ID and max storage
            self.drop_for_id.insert(&drop_id, &drop);
            let final_nft_storage_one = env::storage_usage();
            near_sdk::log!(
                "i1: {} f1: {}",
                initial_nft_storage_one,
                final_nft_storage_one
            );

            // Measure the storage per single longest token ID
            storage_per_longest = Balance::from(final_nft_storage_one - initial_nft_storage_one);
            near_sdk::log!(
                "TOKENS BEFORE {:?}",
                self.get_token_ids_for_drop(self.nonce, None, None)
            );

            // Clear the token IDs so it's an empty set and put the storage in the drop's nft data
            if let DropType::NFT(data) = &mut drop.drop_type {
                data.token_ids.clear();
                data.storage_for_longest = storage_per_longest;
            }

            self.drop_for_id.insert(&drop_id, &drop);
        } else if let Some(data) = ft_data.clone() {
            // If FT Data was provided, we need to cast the FT Config to actual FT data and insert into the drop type
            let FTDataConfig {
                ft_sender,
                ft_contract,
                ft_balance,
            } = data;

            // Create the NFT data
            let actual_ft_data = FTData {
                ft_contract,
                ft_sender,
                ft_balance,
                ft_storage: U128(u128::MAX),
            };

            // The number of claims is 0 until FTs are sent to the contract
            drop.num_claims_registered = 0;
            drop.drop_type = DropType::FT(actual_ft_data);

            // Add the drop with the empty token IDs
            self.drop_for_id.insert(&drop_id, &drop);
        } else if let Some(data) = fc_data.clone() {
            drop.drop_type = DropType::FC(data.clone());

            // Ensure proper method data is passed in
            let num_fcs = data.clone().method_data.len() as u64;
            // If there's 1 claim, there should be 1 method defined
            if num_claims_per_key == 1 {
                require!(
                    num_fcs == 1,
                    "Cannot have more FCs than the number of claims per key"
                );
            // If there's more than 1 method defined, the number of methods should equal the number of claims per key
            } else if num_fcs > 1 {
                require!(
                    num_fcs == num_claims_per_key,
                    "Number of FCs must match number of claims per key if more than 1 is specified"
                );
            }

            // If there's one FC specified and more than 1 claim per key, that FC is to be used
            // For all the claims. In this case, we need to tally all the deposits for each claim.
            if num_claims_per_key > 1 && num_fcs == 1 {
                let deposit = data
                    .method_data
                    .iter()
                    .next()
                    .unwrap()
                    .clone()
                    .expect("cannot have a single none function call")
                    .deposit
                    .0;
                deposit_required_for_fc_deposits = num_claims_per_key as u128 * deposit;

            // In the case where either there's 1 claim per key or the number of FCs is not 1,
            // We can simply loop through and manually get this data
            } else {
                for method in data.method_data {
                    num_none_fcs += method.is_some() as u64;
                    deposit_required_for_fc_deposits += method.map(|m| m.deposit.0).unwrap_or(0);
                }
            }

            // Add the drop with the empty token IDs
            self.drop_for_id.insert(&drop_id, &drop);
        } else {
            // In simple case, we just insert the drop with whatever it was initialized with.
            self.drop_for_id.insert(&drop_id, &drop);
        }

        // Calculate the storage being used for the entire drop
        let final_storage = env::storage_usage();
        let total_required_storage = (Balance::from(final_storage - initial_storage)
            + storage_per_longest)
            * env::storage_byte_cost();
        near_sdk::log!("Total required storage Yocto {}", total_required_storage);

        // Increment the drop ID nonce
        self.nonce += 1;

        /*
            Required deposit consists of:
            - Fees
            - TOTAL Storage
            - Total access key allowance for EACH key
            - Access key storage for EACH key
            - Balance for each key * (number of claims - claims with None for FC Data)

            Optional:
            - FC deposit for each key * num Some(data) claims
            - storage for longest token ID for each key
            - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
        */
        let required_deposit = self.drop_fee
            + total_required_storage
            + (self.key_fee
                + actual_allowance
                + ACCESS_KEY_STORAGE
                + balance.0 * (num_claims_per_key - num_none_fcs) as u128
                + storage_per_longest * env::storage_byte_cost()
                + deposit_required_for_fc_deposits)
                * len;
        near_sdk::log!(
            "Current balance: {}, 
            Required Deposit: {}, 
            Drop Fee: {}, 
            Total Required Storage: {}, 
            Key Fee: {}, 
            ACCESS_KEY_ALLOWANCE: {}, 
            ACCESS_KEY_STORAGE: {},
            Linkdrop Balance: {}, 
            Storage for longest token ID (if applicable): {},
            total function call deposits (if applicable): {},
            Num claims per key: {}
            Num none FCs: {},
            length: {}
            GAS to attach: {}",
            yocto_to_near(current_user_balance),
            yocto_to_near(required_deposit),
            yocto_to_near(self.drop_fee),
            yocto_to_near(total_required_storage),
            yocto_to_near(self.key_fee),
            yocto_to_near(actual_allowance),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(balance.0),
            yocto_to_near(storage_per_longest * env::storage_byte_cost()),
            yocto_to_near(deposit_required_for_fc_deposits),
            num_claims_per_key,
            num_none_fcs,
            len,
            gas_to_attach.0
        );

        /*
            Ensure the attached deposit can cover:
        */
        require!(
            current_user_balance >= required_deposit,
            "Not enough deposit"
        );
        // Decrement the user's balance by the required deposit and insert back into the map
        current_user_balance -= required_deposit;
        self.user_balances.insert(&funder_id, &current_user_balance);
        near_sdk::log!("New user balance {}", yocto_to_near(current_user_balance));

        // Increment our fees earned
        self.fees_collected += self.drop_fee + self.key_fee * len;
        near_sdk::log!(
            "Fees collected {}",
            yocto_to_near(self.drop_fee + self.key_fee * len)
        );

        let current_account_id = env::current_account_id();

        /*
            Only add the access keys if it's not a FT drop. If it is,
            keys will be added in the FT resolver
        */
        if ft_data.is_none() {
            // Create a new promise batch to create all the access keys
            let promise = env::promise_batch_create(&current_account_id);

            // Loop through each public key and create the access keys
            for pk in public_keys.clone() {
                // Must assert in the loop so no access keys are made?
                env::promise_batch_action_add_key_with_function_call(
                    promise,
                    &pk,
                    0,
                    actual_allowance,
                    &current_account_id,
                    access_key_method_names,
                );
            }

            env::promise_return(promise);
        } else {
            /*
                Get the storage required by the FT contract and ensure the user has attached enough
                deposit to cover the storage and perform refunds if they overpayed.
            */

            ext_ft_contract::ext(ft_data.unwrap().ft_contract)
                // Call storage balance bounds with exactly this amount of GAS. No unspent GAS will be added on top.
                .with_static_gas(GAS_FOR_STORAGE_BALANCE_BOUNDS)
                .with_unused_gas_weight(0)
                .storage_balance_bounds()
                .then(
                    Self::ext(current_account_id)
                        // Resolve the promise with the min GAS. All unspent GAS will be added to this call.
                        .with_static_gas(MIN_GAS_FOR_RESOLVE_STORAGE_CHECK)
                        .resolve_storage_check(public_keys, drop_id, required_deposit),
                );
        }

        drop_id
    }

    /*
        Allows users to add to an existing drop.
        Only the funder can call this method
    */
    #[payable]
    pub fn add_to_drop(&mut self, public_keys: Vec<PublicKey>, drop_id: DropId) -> DropId {
        let mut drop = self
            .drop_for_id
            .get(&drop_id)
            .expect("no drop found for ID");
        let drop_config = &drop.drop_config;
        let funder = &drop.funder_id;

        require!(
            funder == &env::predecessor_account_id(),
            "only funder can add to drops"
        );

        let len = public_keys.len() as u128;

        /*
            Add data to storage
        */
        // Pessimistically measure storage
        let initial_storage = env::storage_usage();

        // Get the number of claims per key
        let num_claims_per_key = drop_config.max_claims_per_key;

        // get the existing key set and add new PKs
        let mut exiting_key_map = drop.pks;

        // Calculate the base allowance to attach
        let calculated_base_allowance = self.calculate_base_allowance(drop.required_gas_attached);
        // The actual allowance is the base * number of claims per key since each claim can potentially use the max pessimistic GAS.
        let actual_allowance = calculated_base_allowance * num_claims_per_key as u128;
        // Loop through and add each drop ID to the public keys. Also populate the key set.
        for pk in public_keys.clone() {
            exiting_key_map.insert(
                &pk,
                &KeyUsage {
                    num_uses: num_claims_per_key,
                    last_used: 0, // Set to 0 since this will make the key always claimable.
                    allowance: actual_allowance,
                },
            );
            require!(
                self.drop_id_for_pk.insert(&pk, &drop_id).is_none(),
                "Keys cannot belong to another drop"
            );
        }

        // Set the drop's PKs to the newly populated set
        drop.pks = exiting_key_map;

        // Decide what methods the access keys can call
        let mut access_key_method_names = ACCESS_KEY_BOTH_METHOD_NAMES;
        if drop_config.only_call_claim.unwrap_or(false) {
            access_key_method_names = ACCESS_KEY_CLAIM_METHOD_NAME;
        }

        // Increment the claims registered if drop is FC or Simple
        match &drop.drop_type {
            DropType::FC(data) => {
                drop.num_claims_registered += num_claims_per_key * len as u64;

                // If GAS is specified, set the GAS to attach for allowance calculations
                if let Some(_) = data.config.clone().and_then(|c| c.gas_if_claim_only) {
                    access_key_method_names = ACCESS_KEY_CLAIM_METHOD_NAME;
                }
            }
            DropType::Simple => {
                drop.num_claims_registered += num_claims_per_key * len as u64;
            }
            _ => {}
        };

        // Add the drop back in for the drop ID
        self.drop_for_id.insert(&drop_id, &drop);

        // Get the current balance of the funder.
        let mut current_user_balance = self
            .user_balances
            .get(&funder)
            .expect("No user balance found");
        near_sdk::log!("Cur user balance {}", yocto_to_near(current_user_balance));

        // Get the required deposit for all the FCs
        let mut deposit_required_for_fc_deposits = 0;
        // Get the number of none FCs in FCData (if there are any)
        let mut num_none_fcs = 0;
        if let DropType::FC(data) = &drop.drop_type {
            let num_fcs = data.method_data.len() as u64;

            // If there's one FC specified and more than 1 claim per key, that FC is to be used
            // For all the claims. In this case, we need to tally all the deposits for each claim.
            if num_claims_per_key > 1 && num_fcs == 1 {
                let deposit = data
                    .method_data
                    .iter()
                    .next()
                    .unwrap()
                    .clone()
                    .expect("cannot have a single none function call")
                    .deposit
                    .0;
                deposit_required_for_fc_deposits = num_claims_per_key as u128 * deposit;

            // In the case where either there's 1 claim per key or the number of FCs is not 1,
            // We can simply loop through and manually get this data
            } else {
                for method in data.method_data.clone() {
                    num_none_fcs += method.is_some() as u64;
                    deposit_required_for_fc_deposits += method.map(|m| m.deposit.0).unwrap_or(0);
                }
            }
        }

        // Get optional costs
        let mut nft_optional_costs_per_key = 0;
        let mut ft_optional_costs_per_claim = 0;
        match drop.drop_type {
            DropType::NFT(data) => {
                nft_optional_costs_per_key = data.storage_for_longest * env::storage_byte_cost()
            }
            DropType::FT(data) => ft_optional_costs_per_claim = data.ft_storage.0,
            _ => {}
        };

        // Calculate the storage being used for the entire drop
        let final_storage = env::storage_usage();
        let total_required_storage =
            Balance::from(final_storage - initial_storage) * env::storage_byte_cost();
        near_sdk::log!("Total required storage Yocto {}", total_required_storage);

        /*
            Required deposit consists of:
            - Fees
            - TOTAL Storage
            - Total access key allowance for EACH key
            - Access key storage for EACH key
            - Balance for each key * (number of claims - claims with None for FC Data)

            Optional:
            - FC deposit for each key * num Some(data) claims
            - storage for longest token ID for each key
            - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
        */
        let required_deposit = total_required_storage
            + (self.key_fee
                + actual_allowance
                + ACCESS_KEY_STORAGE
                + drop.balance.0 * (num_claims_per_key - num_none_fcs) as u128
                + nft_optional_costs_per_key
                + deposit_required_for_fc_deposits
                + ft_optional_costs_per_claim * num_claims_per_key as u128)
                * len;

        near_sdk::log!(
            "Current balance: {}, 
            Required Deposit: {},  
            Total Required Storage: {}, 
            Key Fee: {}, 
            ACCESS_KEY_ALLOWANCE: {}, 
            ACCESS_KEY_STORAGE: {},
            Linkdrop Balance: {}, 
            NFT Optional costs per key: {},
            total function call deposits per key: {},
            FT Optional costs per claim: {},
            Num claims per key: {}
            Num none FCs: {},
            length: {}",
            yocto_to_near(current_user_balance),
            yocto_to_near(required_deposit),
            yocto_to_near(total_required_storage),
            yocto_to_near(self.key_fee),
            yocto_to_near(actual_allowance),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(drop.balance.0),
            yocto_to_near(nft_optional_costs_per_key),
            yocto_to_near(deposit_required_for_fc_deposits),
            yocto_to_near(ft_optional_costs_per_claim),
            num_claims_per_key,
            num_none_fcs,
            len,
        );
        /*
            Ensure the attached deposit can cover:
        */
        require!(
            current_user_balance >= required_deposit,
            "Not enough deposit"
        );
        // Decrement the user's balance by the required deposit and insert back into the map
        current_user_balance -= required_deposit;
        self.user_balances.insert(&funder, &current_user_balance);
        near_sdk::log!("New user balance {}", yocto_to_near(current_user_balance));

        // Increment our fees earned
        self.fees_collected += self.key_fee * len;
        near_sdk::log!("Fees collected {}", yocto_to_near(self.key_fee * len));

        // Create a new promise batch to create all the access keys
        let current_account_id = env::current_account_id();
        let promise = env::promise_batch_create(&current_account_id);

        // Loop through each public key and create the access keys
        for pk in public_keys.clone() {
            // Must assert in the loop so no access keys are made?
            env::promise_batch_action_add_key_with_function_call(
                promise,
                &pk,
                0,
                actual_allowance,
                &current_account_id,
                access_key_method_names,
            );
        }

        env::promise_return(promise);

        drop_id
    }
}

'''
'''--- contract/src/stage1/function_call.rs ---
use near_sdk::GasWeight;

use crate::*;

/// Keep track of info for the method to be called
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MethodData {
    // Contract that will be called
    pub receiver: AccountId,
    // Method to call on receiver contract
    pub method: String,
    // Arguments to pass in (stringified JSON)
    pub args: String,
    // Amount of yoctoNEAR to attach along with the call
    pub deposit: U128,
}

/// Keep track of optional configurations for the FC data
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FCConfig {
    // Should the refund that normally goes to the funder be attached alongside the deposit?
    // If Some(true), refund will go to the deposit. Else, it will be refunded to the funder.
    pub refund_to_deposit: Option<bool>,

    // Specifies what field the claiming account should go in when calling the function
    // If None, this isn't attached to the args
    pub claimed_account_field: Option<String>,

    // Specifies where or not the drop ID should be added as a param to the function call
    // If Some(true), attach drop ID to args. Else, don't attach.
    pub attach_drop_id: Option<bool>,

    // How much GAS should be attached to the function call if it's a straight execute. Cannot be greater than ATTACHED_GAS_FROM_WALLET - GAS_OFFSET_IF_FC_EXECUTE (90 TGas).
    // This makes it so the keys can only call `claim`
    pub gas_if_claim_only: Option<Gas>,
}

/// Keep track of nft data
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FCData {
    // Vector of optional method data. If None, no method is called.
    // Drops with more than 1 claim can call different functions each time if Some.
    // If only 1 method is passed in for multiple claims, that method is used for every claim.
    pub method_data: Vec<Option<MethodData>>,

    // Config for the FC data. If None, all default values are used.
    pub config: Option<FCConfig>,
}

#[near_bindgen]
impl DropZone {
    // Internal method for transfer NFTs.
    pub(crate) fn internal_fc_execute(
        &mut self,
        method_data: &MethodData,
        fc_config: Option<FCConfig>,
        amount_to_refund: u128,
        account_id: AccountId,
        drop_id: DropId,
    ) {
        /*
            Function Calls
        */
        let mut final_args = method_data.args.clone();

        // Add the account ID that claimed the linkdrop as part of the args to the function call in the key specified by the user
        if let Some(account_field) = fc_config.clone().and_then(|c| c.claimed_account_field) {
            final_args.insert_str(
                final_args.len() - 1,
                &format!(",\"{}\":\"{}\"", account_field, account_id),
            );
            near_sdk::log!(
                "Adding claimed account ID to specified field: {:?} in args: {:?}",
                account_field,
                method_data.args
            );
        }

        // Add the account ID that claimed the linkdrop as part of the args to the function call in the key specified by the user
        if let Some(should_attach) = fc_config.clone().and_then(|c| c.attach_drop_id) {
            if should_attach {
                final_args.insert_str(
                    final_args.len() - 1,
                    &format!(",\"drop_id\":\"{}\"", drop_id),
                );
                near_sdk::log!("Adding drop ID to args {:?}", drop_id,);
            }
        }

        near_sdk::log!(
            "Attaching Total: {:?} Deposit: {:?} Should Refund?: {:?} Amount To Refund: {:?} With args: {:?}", 
            yocto_to_near(method_data.deposit.0 + if fc_config.clone().and_then(|c| c.refund_to_deposit).unwrap_or(false) {amount_to_refund} else {0}),
            yocto_to_near(method_data.deposit.0), fc_config.clone().and_then(|c| c.refund_to_deposit).unwrap_or(false), yocto_to_near(amount_to_refund),
            final_args
        );

        // Call function with the min GAS and deposit. all unspent GAS will be added on top
        Promise::new(method_data.receiver.clone()).function_call_weight(
            method_data.method.clone(),
            final_args.as_bytes().to_vec(),
            // The claim is successful so attach the amount to refund to the deposit instead of refunding the funder.
            method_data.deposit.0
                + if fc_config
                    .clone()
                    .and_then(|c| c.refund_to_deposit)
                    .unwrap_or(false)
                {
                    amount_to_refund
                } else {
                    0
                },
            fc_config
                .and_then(|c| c.gas_if_claim_only)
                .unwrap_or(Gas(0)),
            GasWeight(1),
        );
    }
}

'''
'''--- contract/src/stage1/mod.rs ---
mod delete;
mod drops;
pub mod function_call;

pub use drops::*;
pub use function_call::*;

'''
'''--- contract/src/stage2/ft.rs ---
use crate::*;
use near_sdk::GasWeight;

/// Keep track fungible token data for an access key. This is stored on the contract
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FTData {
    pub ft_contract: AccountId,
    pub ft_sender: AccountId,
    pub ft_balance: U128,
    pub ft_storage: U128,
}

/// FT Data to be passed in by the user
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FTDataConfig {
    pub ft_contract: AccountId,
    pub ft_sender: AccountId,
    pub ft_balance: U128,
}

// Returned from the storage balance bounds cross contract call on the FT contract
#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

#[near_bindgen]
impl DropZone {
    /// Allows users to attach fungible tokens to the Linkdrops. Must have storage recorded by this point. You can only attach one set of FTs or NFT at a time.
    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: U128,
    ) -> PromiseOrValue<U128> {
        let contract_id = env::predecessor_account_id();

        let mut drop = self.drop_for_id.get(&msg.0).expect("No drop found for ID");
        if let DropType::FT(ft_data) = &drop.drop_type {
            require!(
                amount.0 % ft_data.ft_balance.0 == 0,
                "amount must be a multiple of the drop balance"
            );
            require!(
                ft_data.ft_contract == contract_id && ft_data.ft_sender == sender_id,
                "FT data must match what was sent"
            );

            // Get the number of claims to register with the amount that is sent.
            let claims_to_register = (amount.0 / ft_data.ft_balance.0) as u64;
            drop.num_claims_registered += claims_to_register;
            near_sdk::log!("New claims registered {}", claims_to_register);

            // Ensure that the keys to register can't exceed the number of keys in the drop.
            if drop.num_claims_registered > drop.pks.len() * drop.drop_config.max_claims_per_key {
                near_sdk::log!("Too many FTs sent. Contract is keeping the rest.");
                drop.num_claims_registered = drop.pks.len() * drop.drop_config.max_claims_per_key;
            }

            // Insert the drop with the updated data
            self.drop_for_id.insert(&msg.0, &drop);

            // Everything went well and we don't need to return any tokens (if they over-sent, we keep it)
            PromiseOrValue::Value(U128(0))
        } else {
            env::panic_str("drop type isn't FT");
        }
    }

    #[private]
    /// Self callback checks if fungible tokens were successfully transferred to the new account. If yes, do nothing. If no, refund original sender
    pub fn ft_resolve_batch(
        &mut self,
        amount: U128,
        token_sender: AccountId,
        token_contract: AccountId,
    ) -> bool {
        let mut used_gas = env::used_gas();
        let mut prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of resolve transfer used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );
        let transfer_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        used_gas = env::used_gas();
        prepaid_gas = env::prepaid_gas();
        near_sdk::log!(
            "Before refunding token sender in resolve transfer: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        if transfer_succeeded {
            return true;
        }
        // Create a new batch promise to pay storage and refund the FTs to the original sender
        let batch_ft_promise_id = env::promise_batch_create(&token_contract);

        // Send the fungible tokens (after the storage deposit is finished since these run sequentially)
        // Call the function with the min GAS and then attach 1/2 of the unspent GAS to the call
        env::promise_batch_action_function_call_weight(
            batch_ft_promise_id,
            "storage_deposit",
            json!({ "account_id": token_sender }).to_string().as_bytes(),
            amount.0,
            MIN_GAS_FOR_STORAGE_DEPOSIT,
            GasWeight(1),
        );

        // Send the fungible tokens (after the storage deposit is finished since these run sequentially)
        // Call the function with the min GAS and then attach 1/2 of the unspent GAS to the call
        env::promise_batch_action_function_call_weight(
            batch_ft_promise_id,
            "ft_transfer",
            json!({ "receiver_id": token_sender, "amount": amount, "memo": "Refunding Linkdropped FT Tokens" }).to_string().as_bytes(),
            1,
            MIN_GAS_FOR_FT_TRANSFER,
            GasWeight(1)
        );

        // Return the result of the batch as the return of the function
        env::promise_return(batch_ft_promise_id);

        false
    }

    #[private]
    /// Self callback checks if fungible tokens were successfully refunded. If yes, set keys registered to 0.
    pub fn ft_resolve_refund(&mut self, drop_id: DropId, num_to_refund: u64) -> bool {
        let transfer_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        // Everything went well so we return true since the keys registered have already been decremented
        if transfer_succeeded {
            near_sdk::log!(
                "Successfully refunded FTs for drop ID {}. {} keys unregistered. Returning true.",
                drop_id,
                num_to_refund
            );
            return true;
        }

        // Transfer failed so we need to increment the claims registered and return false
        let mut drop = self.drop_for_id.get(&drop_id).expect("no drop for ID");
        drop.num_claims_registered += num_to_refund;
        self.drop_for_id.insert(&drop_id, &drop);

        near_sdk::log!("Unsuccessful refund for drop ID {}. {} keys added back as registered. Returning false.", drop_id, num_to_refund);
        false
    }

    #[payable]
    #[private]
    /// self callback gets the storage balance bounds and inserts that into account data for each public key passed in
    pub fn resolve_storage_check(
        &mut self,
        public_keys: Vec<PublicKey>,
        drop_id: DropId,
        required_deposit: u128,
    ) -> bool {
        // Check promise result.
        let result = promise_result_as_success();
        let pub_keys_len = public_keys.len() as u128;

        // If things went wrong, we need to delete the data and refund the user.
        if result.is_none() {
            // Refund the funder any excess $NEAR
            near_sdk::log!(
                "Unsuccessful query to get storage. Refunding funder's balance: {}",
                yocto_to_near(required_deposit)
            );
            // Remove the drop
            let mut drop = self.drop_for_id.remove(&drop_id).expect("drop not found");
            // Clear the map
            drop.pks.clear();
            let funder_id = drop.funder_id.clone();

            // Remove the drop ID from the funder's list
            self.internal_remove_drop_for_funder(&drop.funder_id, &drop_id);

            // Loop through the keys and remove the public keys' mapping
            for pk in public_keys {
                self.drop_id_for_pk.remove(&pk.clone());
            }

            // Refund the user's balance for the required deposit
            let mut user_balance = self.user_balances.get(&funder_id).unwrap();
            user_balance += required_deposit;
            self.user_balances.insert(&funder_id, &user_balance);

            return false;
        }

        // Try to get the storage balance bounds from the result of the promise
        if let Ok(StorageBalanceBounds { min, max: _ }) =
            near_sdk::serde_json::from_slice::<StorageBalanceBounds>(&result.unwrap())
        {
            let mut drop = self.drop_for_id.get(&drop_id).unwrap();
            let funder_id = drop.funder_id.clone();

            // Get the current user balance ad ensure that they have the extra $NEAR for covering the FT storage
            let mut cur_user_balance = self.user_balances.get(&funder_id).unwrap();
            let extra_storage_required =
                min.0 * drop.drop_config.max_claims_per_key as u128 * pub_keys_len;

            // Ensure the user's current balance can cover the extra storage required
            if cur_user_balance < extra_storage_required {
                near_sdk::log!("Not enough balance to cover FT storage for each key and their claims. Refunding funder's balance: {}", yocto_to_near(required_deposit));
                // Remove the drop
                self.drop_for_id.remove(&drop_id).unwrap();
                // Clear the map
                drop.pks.clear();

                // Remove the drop ID from the funder's list
                self.internal_remove_drop_for_funder(&drop.funder_id, &drop_id);

                // Loop through the keys and remove the keys from the drop and remove the drop ID for the key
                for pk in public_keys {
                    self.drop_id_for_pk.remove(&pk.clone());
                }

                // Refund the user's balance for the required deposit
                cur_user_balance += required_deposit;
                self.user_balances.insert(&funder_id, &cur_user_balance);

                return false;
            }

            // Update the FT data to include the storage and insert the drop back with the updated FT data
            if let DropType::FT(mut ft_data) = drop.drop_type {
                ft_data.ft_storage = min;
                drop.drop_type = DropType::FT(ft_data);

                self.drop_for_id.insert(&drop_id, &drop);

                // Decrement the user's balance by the extra required and insert back into the map
                cur_user_balance -= extra_storage_required;
                self.user_balances.insert(&funder_id, &cur_user_balance);

                // Create the keys for the contract
                let promise = env::promise_batch_create(&env::current_account_id());

                // Decide what methods the access keys can call
                let mut access_key_method_names = ACCESS_KEY_BOTH_METHOD_NAMES;
                if drop.drop_config.only_call_claim.unwrap_or(false) {
                    access_key_method_names = ACCESS_KEY_CLAIM_METHOD_NAME;
                }

                // Get the number of claims per key
                let num_claims_per_key = drop.drop_config.max_claims_per_key;
                // Calculate the base allowance to attach
                let calculated_base_allowance =
                    self.calculate_base_allowance(drop.required_gas_attached);
                // The actual allowance is the base * number of claims per key since each claim can potentially use the max pessimistic GAS.
                let actual_allowance = calculated_base_allowance * num_claims_per_key as u128;

                // Loop through each public key and create the access keys
                for pk in public_keys.clone() {
                    env::promise_batch_action_add_key_with_function_call(
                        promise,
                        &pk,
                        0,
                        actual_allowance,
                        &env::current_account_id(),
                        access_key_method_names,
                    );
                }

                env::promise_return(promise);

                // Everything went well and we return true
                return true;
            } else {
                false
            }
        } else {
            // Refund the funder any excess $NEAR
            near_sdk::log!(
                "Unsuccessful query to get storage. Refunding funder's balance: {}",
                yocto_to_near(required_deposit)
            );
            // Remove the drop
            let mut drop = self.drop_for_id.remove(&drop_id).expect("drop not found");
            // Clear the map
            drop.pks.clear();
            let funder_id = drop.funder_id.clone();

            // Remove the drop ID from the funder's list
            self.internal_remove_drop_for_funder(&drop.funder_id, &drop_id);

            // Loop through the keys and remove the public keys' mapping
            for pk in public_keys {
                self.drop_id_for_pk.remove(&pk.clone());
            }

            // Refund the user's balance for the required deposit
            let mut user_balance = self.user_balances.get(&funder_id).unwrap();
            user_balance += required_deposit;
            self.user_balances.insert(&funder_id, &user_balance);

            return false;
        }
    }

    // Internal method for transfer FTs. Whether the claim was successful or not is passed in
    pub(crate) fn internal_ft_transfer(
        &mut self,
        claim_succeeded: bool,
        ft_data: FTData,
        account_id: AccountId,
    ) {
        /*
            Fungible Tokens.
            - Only send the FTs if the sender ended up sending the contract the tokens.
        */
        // Only send the fungible tokens to the new account if the claim was successful. We return the FTs if it wasn't successful in the else case.
        if claim_succeeded {
            // Create a new batch promise to pay storage and transfer FTs to the new account ID
            let batch_ft_promise_id = env::promise_batch_create(&ft_data.ft_contract);

            // Pay the required storage as outlined in the AccountData. This will run first and then we send the fungible tokens
            // Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call
            env::promise_batch_action_function_call_weight(
                batch_ft_promise_id,
                "storage_deposit",
                json!({ "account_id": account_id }).to_string().as_bytes(),
                ft_data.ft_storage.0,
                MIN_GAS_FOR_STORAGE_DEPOSIT,
                GasWeight(1),
            );

            // Send the fungible tokens (after the storage deposit is finished since these run sequentially)
            // Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call
            env::promise_batch_action_function_call_weight(
                batch_ft_promise_id,
                "ft_transfer",
                json!({ "receiver_id": account_id, "amount": ft_data.ft_balance, "memo": "Linkdropped FT Tokens" }).to_string().as_bytes(),
                1,
                MIN_GAS_FOR_FT_TRANSFER,
                GasWeight(1)
            );

            // Create the second batch promise to execute after the batch_ft_promise_id batch is finished executing.
            // It will execute on the current account ID (this contract)
            let batch_ft_resolve_promise_id =
                env::promise_batch_then(batch_ft_promise_id, &env::current_account_id());

            // Execute a function call as part of the resolved promise index created in promise_batch_then
            // Callback after both the storage was deposited and the fungible tokens were sent
            // Call the function with the min GAS and then attach 3/5 of the unspent GAS to the call
            env::promise_batch_action_function_call_weight(
                batch_ft_resolve_promise_id,
                "ft_resolve_batch",
                json!({ "amount": ft_data.ft_balance, "token_sender": ft_data.ft_sender, "token_contract": ft_data.ft_contract }).to_string().as_bytes(),
                NO_DEPOSIT,
                MIN_GAS_FOR_RESOLVE_BATCH,
                GasWeight(3)
            );
        } else {
            // Create a new batch promise to pay storage and refund the FTs to the original sender
            let batch_ft_promise_id = env::promise_batch_create(&ft_data.ft_contract);

            // Send the fungible tokens (after the storage deposit is finished since these run sequentially)
            // Call the function with the min GAS and then attach 1/2 of the unspent GAS to the call
            env::promise_batch_action_function_call_weight(
                batch_ft_promise_id,
                "storage_deposit",
                json!({ "account_id": ft_data.ft_sender })
                    .to_string()
                    .as_bytes(),
                ft_data.ft_storage.0,
                MIN_GAS_FOR_STORAGE_DEPOSIT,
                GasWeight(1),
            );

            // Send the fungible tokens (after the storage deposit is finished since these run sequentially)
            // Call the function with the min GAS and then attach 1/2 of the unspent GAS to the call
            env::promise_batch_action_function_call_weight(
                batch_ft_promise_id,
                "ft_transfer",
                json!({ "receiver_id": ft_data.ft_sender, "amount": ft_data.ft_balance, "memo": "Linkdropped FT Tokens" }).to_string().as_bytes(),
                1,
                MIN_GAS_FOR_FT_TRANSFER,
                GasWeight(1)
            );

            // Return the result of the batch as the return of the function
            env::promise_return(batch_ft_promise_id);
        }
    }
}

'''
'''--- contract/src/stage2/mod.rs ---
pub mod ft;
pub mod nft;

pub use ft::*;
pub use nft::*;

'''
'''--- contract/src/stage2/nft.rs ---
use crate::*;

/// Keep track of nft data. This is stored on the contract
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NFTData {
    pub nft_sender: AccountId,
    pub nft_contract: AccountId,
    pub longest_token_id: String,
    pub storage_for_longest: Balance,
    pub token_ids: UnorderedSet<String>,
}

/// Keep track of nft data. This is passed in by the user
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTDataConfig {
    pub nft_sender: AccountId,
    pub nft_contract: AccountId,
    pub longest_token_id: String,
}

#[near_bindgen]
impl DropZone {
    pub fn nft_on_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        msg: U128,
    ) -> PromiseOrValue<bool> {
        let contract_id = env::predecessor_account_id();

        let mut drop = self.drop_for_id.get(&msg.0).expect("No drop found for ID");
        if let DropType::NFT(mut nft_data) = drop.drop_type {
            let mut token_ids = nft_data.token_ids;

            require!(
                nft_data.nft_sender == sender_id && nft_data.nft_contract == contract_id,
                "NFT data must match what was sent"
            );
            require!(
                token_id.len() <= nft_data.longest_token_id.len(),
                "token ID must be less than largest token specified"
            );

            require!(
                token_ids.insert(&token_id) == true,
                "token ID already registered"
            );

            // Re-insert the token IDs into the NFT Data struct
            nft_data.token_ids = token_ids;

            // Increment the claims registered
            drop.num_claims_registered += 1;
            near_sdk::log!("drop.num_claims_registered {}", drop.num_claims_registered);

            // Ensure that the keys to register can't exceed the number of keys in the drop.
            if drop.num_claims_registered > drop.pks.len() * drop.drop_config.max_claims_per_key {
                near_sdk::log!("Too many NFTs sent. Contract is keeping the rest.");
                drop.num_claims_registered = drop.pks.len() * drop.drop_config.max_claims_per_key;
            }

            // Add the nft data back with the updated set
            drop.drop_type = DropType::NFT(nft_data);

            // Insert the drop with the updated data
            self.drop_for_id.insert(&msg.0, &drop);

            // Everything went well and we don't need to return the token.
            PromiseOrValue::Value(false);
        }
        {
            env::panic_str("drop type isn't NFT");
        }
    }

    #[private]
    /// self callback checks if NFT was successfully transferred to the new account. If yes, do nothing. If no, refund original sender
    pub fn nft_resolve_refund(&mut self, drop_id: U128, token_ids: Vec<String>) -> bool {
        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of resolve refund used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );
        let transfer_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        // If not successful, the length of the token IDs needs to be added back to the drop.
        if !transfer_succeeded {
            let mut drop = self.drop_for_id.get(&drop_id.0).unwrap();
            drop.num_claims_registered += token_ids.len() as u64;
            self.drop_for_id.insert(&drop_id.0, &drop);

            near_sdk::log!(
                "Transfer failed. Adding {} back to drop's keys registered",
                token_ids.len() as u64
            );

            return false;
        }

        // Loop through and remove each token ID from the drop's NFT data token IDs
        let mut drop = self.drop_for_id.get(&drop_id.0).unwrap();
        if let DropType::NFT(mut nft_data) = drop.drop_type {
            let mut ids = nft_data.token_ids;

            for id in token_ids {
                near_sdk::log!("Removing {}. Present: {}", id, ids.remove(&id));
            }

            nft_data.token_ids = ids;
            drop.drop_type = DropType::NFT(nft_data);

            return true;
        };
        false
    }

    #[private]
    /// self callback checks if NFT was successfully transferred to the new account. If yes, do nothing. If no, refund original sender
    pub fn nft_resolve_transfer(
        &mut self,
        token_id: String,
        token_sender: AccountId,
        token_contract: AccountId,
    ) -> bool {
        let mut used_gas = env::used_gas();
        let mut prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of resolve transfer used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );
        let transfer_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        used_gas = env::used_gas();
        prepaid_gas = env::prepaid_gas();
        near_sdk::log!(
            "Before refunding token sender in resolve transfer: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // If not successful, the balance is added to the amount to refund since it was never transferred.
        if !transfer_succeeded {
            near_sdk::log!("Attempt to transfer the new account was unsuccessful. Sending the NFT to the original sender.");
            ext_nft_contract::ext(token_contract)
                // Call nft transfer with the min GAS and 1 yoctoNEAR. all unspent GAS will be added on top
                .with_static_gas(MIN_GAS_FOR_SIMPLE_NFT_TRANSFER)
                .with_attached_deposit(1)
                .nft_transfer(
                    token_sender,
                    token_id,
                    None,
                    Some("Linkdropped NFT Refund".to_string()),
                );
        }

        transfer_succeeded
    }

    // Internal method for transfer NFTs. Whether the claim was successful or not is passed in
    pub(crate) fn internal_nft_transfer(
        &mut self,
        claim_succeeded: bool,
        nft_contract: AccountId,
        token_id: String,
        nft_sender: AccountId,
        account_id: AccountId,
    ) {
        /*
            Non Fungible Tokens
        */
        // Only send the NFT to the new account if the claim was successful. We return the NFT if it wasn't successful in the else case.
        if claim_succeeded {
            // CCC to the NFT contract to transfer the token to the new account. If this is unsuccessful, we transfer to the original token sender in the callback.
            ext_nft_contract::ext(nft_contract.clone())
                // Call nft transfer with the min GAS and 1 yoctoNEAR. 1/2 unspent GAS will be added on top
                .with_static_gas(MIN_GAS_FOR_SIMPLE_NFT_TRANSFER)
                .with_attached_deposit(1)
                .nft_transfer(
                    account_id.clone(),
                    token_id.clone(),
                    None,
                    Some("Linkdropped NFT".to_string()),
                )
                // We then resolve the promise and call nft_resolve_transfer on our own contract
                .then(
                    // Call resolve transfer with the min GAS and no deposit. 1/2 unspent GAS will be added on top
                    Self::ext(env::current_account_id())
                        .with_static_gas(MIN_GAS_FOR_RESOLVE_TRANSFER)
                        .nft_resolve_transfer(token_id, nft_sender, nft_contract),
                );
        } else {
            // CCC to the NFT contract to transfer the token to the new account. If this is unsuccessful, we transfer to the original token sender in the callback.
            ext_nft_contract::ext(nft_contract)
                // Call nft transfer with the min GAS and 1 yoctoNEAR. all unspent GAS will be added on top
                .with_static_gas(MIN_GAS_FOR_SIMPLE_NFT_TRANSFER)
                .with_attached_deposit(1)
                .nft_transfer(
                    nft_sender,
                    token_id,
                    None,
                    Some("Linkdropped NFT".to_string()),
                );
        }
    }
}

'''
'''--- contract/src/stage3/claim.rs ---
use crate::*;

#[near_bindgen]
impl DropZone {
    /// Claim tokens for specific account that are attached to the public key this tx is signed with.
    pub fn claim(&mut self, account_id: AccountId) {
        // Delete the access key and remove / return drop data and optional token ID for nft drops. Also return the storage freed.
        let (
            drop_data_option,
            drop_id,
            storage_freed_option,
            token_id,
            storage_for_longest,
            should_continue,
            cur_claims_for_key,
        ) = self.process_claim();

        if drop_data_option.is_none() {
            near_sdk::log!("Invalid claim. Returning.");
            return;
        }

        if should_continue == false {
            near_sdk::log!("Empty function call. Returning.");
            return;
        }

        let drop_data = drop_data_option.unwrap();
        let storage_freed = storage_freed_option.unwrap();

        // Should we refund send back the $NEAR since an account isn't being created and just send the assets to the claiming account?
        let account_to_transfer = if drop_data.drop_config.refund_if_claim.unwrap_or(false) == true
        {
            drop_data.funder_id.clone()
        } else {
            account_id.clone()
        };

        let mut promise = None;
        // Only create a promise to transfer $NEAR if the drop's balance is > 0.
        if drop_data.balance.0 > 0 {
            // Send the account ID the desired balance.
            promise = Some(Promise::new(account_to_transfer).transfer(drop_data.balance.0));
        }

        // Execute the callback depending on the drop type. If the drop balance is 0, the promise will be none and the callback function will just straight up be executed instead of resolving the promise.
        self.internal_execute(
            drop_data,
            drop_id.unwrap(),
            cur_claims_for_key,
            account_id,
            storage_freed,
            token_id,
            storage_for_longest,
            promise,
        );

        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "End of regular claim function: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );
    }

    /// Create new account and and claim tokens to it.
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) {
        let (
            drop_data_option,
            drop_id,
            storage_freed_option,
            token_id,
            storage_for_longest,
            should_continue,
            cur_claims_for_key,
        ) = self.process_claim();

        if drop_data_option.is_none() {
            near_sdk::log!("Invalid claim. Returning.");
            return;
        }

        if should_continue == false {
            near_sdk::log!("Empty function call. Returning.");
            return;
        }

        let drop_data = drop_data_option.unwrap();
        let storage_freed = storage_freed_option.unwrap();

        // CCC to the linkdrop contract to create the account with the desired balance as the linkdrop amount
        let promise = ext_linkdrop::ext(self.linkdrop_contract.clone())
            // Attach the balance of the linkdrop along with the exact gas for create account. No unspent GAS is attached.
            .with_attached_deposit(drop_data.balance.0)
            .with_static_gas(GAS_FOR_CREATE_ACCOUNT)
            .with_unused_gas_weight(0)
            .create_account(new_account_id.clone(), new_public_key);

        // Execute the callback depending on the drop type. We'll pass in the promise to resolve
        self.internal_execute(
            drop_data,
            drop_id.unwrap(),
            cur_claims_for_key,
            new_account_id,
            storage_freed,
            token_id,
            storage_for_longest,
            Some(promise),
        );

        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "End of on CAAC function: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );
    }

    #[private]
    /// self callback for simple linkdrops with no FTs, NFTs, or FCs.
    pub fn on_claim_simple(
        &mut self,
        // Account ID that sent the funds for the linkdrop
        funder_id: AccountId,
        // Balance contained within the linkdrop
        balance: U128,
        // How much storage was freed when the key was claimed
        storage_used: Balance,
    ) -> bool {
        // Get the status of the cross contract call
        let claim_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Simple on claim used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // Default amount to refund to be everything except balance and burnt GAS since balance was sent to new account.
        let mut amount_to_refund = ACCESS_KEY_STORAGE + storage_used;

        near_sdk::log!(
            "Refund Amount: {}, 
            Access Key Storage: {}, 
            Storage Used: {}",
            yocto_to_near(amount_to_refund),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(storage_used)
        );

        // If not successful, the balance is added to the amount to refund since it was never transferred.
        if !claim_succeeded {
            near_sdk::log!(
                "Claim unsuccessful. Refunding linkdrop balance as well: {}",
                balance.0
            );
            amount_to_refund += balance.0
        }

        near_sdk::log!(
            "Refunding funder: {:?} For amount: {:?}",
            funder_id,
            yocto_to_near(amount_to_refund)
        );

        // Get the funder's balance and increment it by the amount to refund
        let mut cur_funder_balance = self
            .user_balances
            .get(&funder_id)
            .expect("No funder balance found");
        cur_funder_balance += amount_to_refund;
        self.user_balances.insert(&funder_id, &cur_funder_balance);

        claim_succeeded
    }

    #[private]
    /// self callback for FT linkdrop
    pub fn on_claim_ft(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was freed when the key was claimed
        storage_used: Balance,
        // FT Data for the drop
        ft_data: FTData,
        // Was this function invoked via an execute (no callback)
        execute: bool,
    ) -> bool {
        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();
        near_sdk::log!(
            "Beginning of on claim FT used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // Get the status of the cross contract call. If this function is invoked directly via an execute, default the claim succeeded to true
        let mut claim_succeeded = true;
        if !execute {
            claim_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));
        }
        near_sdk::log!("Has function been executed via CCC: {}", !execute);

        // Default amount to refund to be everything except balance and burnt GAS since balance was sent to new account.
        let mut amount_to_refund = ACCESS_KEY_STORAGE + storage_used;

        near_sdk::log!(
            "Refund Amount: {}, 
            Access Key Storage: {}, 
            Storage Used: {}",
            yocto_to_near(amount_to_refund),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(storage_used)
        );

        // If not successful, the balance is added to the amount to refund since it was never transferred.
        if !claim_succeeded {
            near_sdk::log!(
                "Claim unsuccessful. Refunding linkdrop balance as well: {}",
                balance.0
            );
            amount_to_refund += balance.0
        }

        near_sdk::log!(
            "Refunding funder: {:?} balance For amount: {:?}",
            funder_id,
            yocto_to_near(amount_to_refund)
        );
        // Get the funder's balance and increment it by the amount to refund
        let mut cur_funder_balance = self
            .user_balances
            .get(&funder_id)
            .expect("No funder balance found");
        cur_funder_balance += amount_to_refund;
        self.user_balances.insert(&funder_id, &cur_funder_balance);

        // Perform the FT transfer functionality
        self.internal_ft_transfer(claim_succeeded, ft_data, account_id);

        claim_succeeded
    }

    #[private]
    /// self callback for a linkdrop loaded with an NFT
    pub fn on_claim_nft(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was freed when the key was claimed
        storage_used: Balance,
        // How much storage was prepaid to cover the longest token ID being inserted.
        storage_for_longest: Balance,
        // Sender of the NFT
        nft_sender: AccountId,
        // Contract where the NFT is stored
        nft_contract: AccountId,
        // Token ID for the NFT
        token_id: String,
        // Was this function invoked via an execute (no callback)
        execute: bool,
    ) -> bool {
        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of on claim NFT used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // Get the status of the cross contract call. If this function is invoked directly via an execute, default the claim succeeded to true
        let mut claim_succeeded = true;
        if !execute {
            claim_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));
        }
        near_sdk::log!("Has function been executed via CCC: {}", !execute);

        // Default amount to refund to be everything except balance and burnt GAS since balance was sent to new account.
        // In addition, we refund them for the cost of storing the longest token ID now that a key has been claimed
        let mut amount_to_refund =
            ACCESS_KEY_STORAGE + storage_used + storage_for_longest * env::storage_byte_cost();

        near_sdk::log!(
            "Refund Amount: {}, 
            Access Key Storage: {}, 
            Storage Used: {}
            Storage for longest: {}",
            yocto_to_near(amount_to_refund),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(storage_used),
            yocto_to_near(storage_for_longest * env::storage_byte_cost())
        );

        // If not successful, the balance is added to the amount to refund since it was never transferred.
        if !claim_succeeded {
            near_sdk::log!(
                "Claim unsuccessful. Refunding linkdrop balance as well: {}",
                balance.0
            );
            amount_to_refund += balance.0
        }

        near_sdk::log!(
            "Refunding funder: {:?} balance For amount: {:?}",
            funder_id,
            yocto_to_near(amount_to_refund)
        );
        // Get the funder's balance and increment it by the amount to refund
        let mut cur_funder_balance = self
            .user_balances
            .get(&funder_id)
            .expect("No funder balance found");
        cur_funder_balance += amount_to_refund;
        self.user_balances.insert(&funder_id, &cur_funder_balance);

        // Transfer the NFT
        self.internal_nft_transfer(
            claim_succeeded,
            nft_contract,
            token_id,
            nft_sender,
            account_id,
        );
        claim_succeeded
    }

    #[private]
    /// self callback checks if account was created successfully or not. If yes, refunds excess storage, sends NFTs, FTs etc..
    pub fn on_claim_fc(
        &mut self,
        // Account ID that claimed the linkdrop
        account_id: AccountId,
        // Account ID that funded the linkdrop
        funder_id: AccountId,
        // Balance associated with the linkdrop
        balance: U128,
        // How much storage was freed when the key was claimed
        storage_used: Balance,
        // FC Data for the drop
        fc_data: FCData,
        // Drop ID for the specific drop
        drop_id: DropId,
        // How many uses the key had left before it was decremented
        cur_num_claims_left: u64,
        // How many uses the key had left before it was decremented
        max_claims_per_key: u64,
        // Was this function invoked via an execute (no callback)
        execute: bool,
    ) -> bool {
        let used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of on claim Function Call used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // Get the status of the cross contract call. If this function is invoked directly via an execute, default the claim succeeded to true
        let mut claim_succeeded = true;
        if !execute {
            claim_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));
        }
        near_sdk::log!("Has function been executed via CCC: {}", !execute);

        // Default amount to refund to be everything except balance and burnt GAS since balance was sent to new account.
        let mut amount_to_refund = ACCESS_KEY_STORAGE + storage_used;

        near_sdk::log!(
            "Refund Amount: {}, 
            Access Key Storage: {}, 
            Storage Used: {}",
            yocto_to_near(amount_to_refund),
            yocto_to_near(ACCESS_KEY_STORAGE),
            yocto_to_near(storage_used)
        );

        // The starting index is the max claims per key - the number of uses left. If the method data is of size 1, use that instead
        let cur_len = fc_data.method_data.len() as u16;
        let starting_index = if cur_len > 1 {
            (max_claims_per_key - cur_num_claims_left) as usize
        } else {
            0 as usize
        };
        let cur_method_data = fc_data
            .method_data
            .iter()
            .skip(starting_index)
            .next()
            .unwrap()
            .clone()
            .unwrap();

        // If not successful, the balance and deposit is added to the amount to refund since it was never transferred.
        if !claim_succeeded {
            near_sdk::log!(
                "Claim unsuccessful. Refunding linkdrop balance: {} and deposit: {}",
                balance.0,
                cur_method_data.deposit.0
            );
            amount_to_refund += balance.0 + cur_method_data.deposit.0
        }

        /*
            If the claim is not successful, we should always refund. The only case where we don't refund is
            if the claim was successful and the user specified that the refund should go into the
            deposit.

            0 0     Refund     !success  -> do refund
            0 1     Refund      success  -> do refund
            1 0     No Refund  !success  -> do refund
            1 1     No Refund   Success  -> don't do refund
        */
        if !claim_succeeded
            || (!fc_data
                .config
                .clone()
                .and_then(|c| c.refund_to_deposit)
                .unwrap_or(false)
                && claim_succeeded)
        {
            // Refunding
            near_sdk::log!(
                "Refunding funder: {:?} balance For amount: {:?}",
                funder_id,
                yocto_to_near(amount_to_refund)
            );
            // Get the funder's balance and increment it by the amount to refund
            let mut cur_funder_balance = self
                .user_balances
                .get(&funder_id)
                .expect("No funder balance found");
            cur_funder_balance += amount_to_refund;
            self.user_balances.insert(&funder_id, &cur_funder_balance);
        } else {
            near_sdk::log!(
                "Skipping the refund to funder: {:?} claim success: {:?} refund to deposit?: {:?}",
                funder_id,
                claim_succeeded,
                fc_data
                    .config
                    .clone()
                    .and_then(|c| c.refund_to_deposit)
                    .unwrap_or(false)
            );
        }

        self.internal_fc_execute(
            &cur_method_data,
            fc_data.config,
            amount_to_refund,
            account_id,
            drop_id,
        );
        claim_succeeded
    }

    /// Internal method for deleting the used key and removing / returning linkdrop data.
    /// If drop is none, simulate a panic.
    fn process_claim(
        &mut self,
    ) -> (
        // Drop containing all data
        Option<Drop>,
        // Drop ID for the drop
        Option<DropId>,
        // How much storage was freed
        Option<Balance>,
        // Next token ID to claim
        Option<String>,
        // Storage for the longest token ID
        Option<Balance>,
        // Should we return and not do anything once the drop is claimed (if FC data is none)
        bool,
        // Current number of uses before decrementing
        u64,
    ) {
        let mut used_gas = env::used_gas();
        let prepaid_gas = env::prepaid_gas();

        near_sdk::log!(
            "Beginning of process claim used gas: {:?} prepaid gas: {:?}",
            used_gas.0,
            prepaid_gas.0
        );

        // Pessimistically measure storage
        let initial_storage = env::storage_usage();
        // Ensure only the current contract is calling the method using the access key
        // Panic doesn't affect allowance
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "predecessor != current"
        );

        // Get the PK of the signer which should be the contract's function call access key
        let signer_pk = env::signer_account_pk();

        // By default, every key should have a drop ID. If we need to remove the key, remove later.
        // Panic doesn't affect allowance
        let drop_id = self
            .drop_id_for_pk
            .get(&signer_pk)
            .expect("No drop ID found for PK");
        // Remove the drop. If the drop shouldn't be removed, we re-insert later.
        // Panic doesn't affect allowance
        let mut drop = self.drop_for_id.remove(&drop_id).expect("drop not found");
        // Remove the pk from the drop's set and check for key usage.
        // Panic doesn't affect allowance
        let mut key_usage = drop.pks.remove(&signer_pk).unwrap();
        // Keep track of the current number of uses so that it can be used to index into FCData Method Data
        let current_num_uses = key_usage.num_uses;
        // Ensure there's enough claims left for the key to be used. (this *should* only happen in NFT or FT cases)
        if drop.num_claims_registered < 1 || prepaid_gas != drop.required_gas_attached {
            used_gas = env::used_gas();

            let amount_to_decrement =
                (used_gas.0 + GAS_FOR_PANIC_OFFSET.0) as u128 * self.yocto_per_gas;
            if drop.num_claims_registered < 1 {
                near_sdk::log!("Not enough claims left for the drop. Decrementing allowance by {}. Used GAS: {}", amount_to_decrement, used_gas.0);
            } else {
                near_sdk::log!("Prepaid GAS different than what is specified in the drop: {}. Decrementing allowance by {}. Used GAS: {}", drop.required_gas_attached.0, amount_to_decrement, used_gas.0);
            }

            key_usage.allowance -= amount_to_decrement;
            near_sdk::log!("Allowance is now {}", key_usage.allowance);
            drop.pks.insert(&signer_pk, &key_usage);
            self.drop_for_id.insert(&drop_id, &drop);
            return (None, None, None, None, None, false, 0);
        }

        // Ensure enough time has passed if a start timestamp was specified in the config.
        let current_timestamp = env::block_timestamp();
        let desired_timestamp = drop
            .drop_config
            .start_timestamp
            .unwrap_or(current_timestamp);

        if current_timestamp < desired_timestamp {
            used_gas = env::used_gas();

            let amount_to_decrement =
                (used_gas.0 + GAS_FOR_PANIC_OFFSET.0) as u128 * self.yocto_per_gas;
            near_sdk::log!("Drop isn't claimable until {}. Current timestamp is {}. Decrementing allowance by {}. Used GAS: {}", desired_timestamp, current_timestamp, amount_to_decrement, used_gas.0);

            key_usage.allowance -= amount_to_decrement;
            near_sdk::log!("Allowance is now {}", key_usage.allowance);
            drop.pks.insert(&signer_pk, &key_usage);
            self.drop_for_id.insert(&drop_id, &drop);
            return (None, None, None, None, None, false, 0);
        }

        /*
            If it's an NFT drop get the token ID and remove it from the set. Also set the storage for longest
            If it's an FC drop, get the next method data and check if it's none (to skip transfer of funds)
        */
        // Default the token ID to none and return / remove the next token ID if it's an NFT drop
        let mut token_id = None;
        // Default the storage for longest to be none and return the actual value if it's an NFT drop
        let mut storage_for_longest = None;
        // Default the should continue variable to true. If the next FC method is None, we set it to false
        let mut should_continue = true;
        match &mut drop.drop_type {
            DropType::NFT(data) => {
                token_id = data.token_ids.iter().next();
                data.token_ids.remove(token_id.as_ref().unwrap());
                storage_for_longest = Some(data.storage_for_longest);
            }
            DropType::FC(data) => {
                // The starting index is the max claims per key - the number of uses left. If the method data is of size 1, use that instead
                let cur_len = data.method_data.len() as u16;
                let starting_index = if cur_len > 1 {
                    (drop.drop_config.max_claims_per_key - key_usage.num_uses) as usize
                } else {
                    0 as usize
                };

                should_continue = data
                    .method_data
                    .iter()
                    .skip(starting_index)
                    .next()
                    .unwrap()
                    .is_some();
            }
            _ => {}
        };

        // Default the should delete variable to true. If there's a case where it shouldn't, change the bool.
        let mut should_delete = true;
        near_sdk::log!(
            "Key usage last used: {:?} Num uses: {:?} (before)",
            key_usage.last_used,
            key_usage.num_uses
        );

        // Ensure the key is within the interval if specified
        if let Some(interval) = drop.drop_config.usage_interval {
            near_sdk::log!(
                "Current timestamp {} last used: {} subs: {} interval: {}",
                current_timestamp,
                key_usage.last_used,
                current_timestamp - key_usage.last_used,
                interval
            );

            if (current_timestamp - key_usage.last_used) < interval
                || key_usage.allowance < prepaid_gas.0 as u128 * self.yocto_per_gas
            {
                used_gas = env::used_gas();

                let amount_to_decrement =
                    (used_gas.0 + GAS_FOR_PANIC_OFFSET.0) as u128 * self.yocto_per_gas;
                if (current_timestamp - key_usage.last_used) < interval {
                    near_sdk::log!("Not enough time has passed since the key was last used. Decrementing allowance by {}. Used GAS: {}", amount_to_decrement, used_gas.0);
                } else {
                    near_sdk::log!("Not enough allowance on the key {}. Decrementing allowance by {} Used GAS: {}", key_usage.allowance, amount_to_decrement, used_gas.0);
                }

                key_usage.allowance -= amount_to_decrement;
                near_sdk::log!("Allowance is now {}", key_usage.allowance);
                drop.pks.insert(&signer_pk, &key_usage);
                self.drop_for_id.insert(&drop_id, &drop);
                return (None, None, None, None, None, false, 0);
            }

            near_sdk::log!("Enough time has passed for key to be used. Setting last used to current timestamp {}", current_timestamp);
            key_usage.last_used = current_timestamp;
        }

        // No uses left! The key should be deleted
        if key_usage.num_uses == 1 {
            near_sdk::log!("Key has no uses left. It will be deleted");
            self.drop_id_for_pk.remove(&signer_pk);
        } else {
            key_usage.num_uses -= 1;
            key_usage.allowance -= drop.required_gas_attached.0 as u128 * self.yocto_per_gas;
            near_sdk::log!(
                "Key has {} uses left. Decrementing allowance by {}. Allowance left: {}",
                key_usage.num_uses,
                drop.required_gas_attached.0 as u128 * self.yocto_per_gas,
                key_usage.allowance
            );

            drop.pks.insert(&signer_pk, &key_usage);
            should_delete = false;
        }

        drop.num_claims_registered -= 1;

        // If there are keys still left in the drop, add the drop back in with updated data
        if !drop.pks.is_empty() {
            // Add drop back with the updated data.
            self.drop_for_id.insert(&drop_id, &drop);
        } else {
            // Remove the drop ID from the funder's list if the drop is now empty
            self.internal_remove_drop_for_funder(&drop.funder_id, &drop_id);
        }

        // Calculate the storage being freed. initial - final should be >= 0 since final should be smaller than initial.
        let final_storage = env::storage_usage();
        let total_storage_freed =
            Balance::from(initial_storage - final_storage) * env::storage_byte_cost();

        if should_delete {
            // Amount to refund is the current allowance less the current execution's max GAS
            let amount_to_refund =
                key_usage.allowance - drop.required_gas_attached.0 as u128 * self.yocto_per_gas;
            near_sdk::log!(
                "Key being deleted. Allowance Currently: {}. Will refund: {}",
                key_usage.allowance,
                amount_to_refund
            );
            // Get the funder's balance and increment it by the amount to refund
            let mut cur_funder_balance = self
                .user_balances
                .get(&drop.funder_id)
                .expect("No funder balance found");
            cur_funder_balance += amount_to_refund;
            self.user_balances
                .insert(&drop.funder_id, &cur_funder_balance);

            // Delete the key
            Promise::new(env::current_account_id()).delete_key(signer_pk);
        }

        // Return the drop and optional token ID with how much storage was freed
        (
            Some(drop),
            Some(drop_id),
            Some(total_storage_freed),
            token_id,
            storage_for_longest,
            should_continue,
            current_num_uses,
        )
    }
}

'''
'''--- contract/src/stage3/mod.rs ---
pub mod claim;

pub use claim::*;

'''
'''--- contract/src/views.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum JsonDropType {
    Simple,
    NFT(JsonNFTData),
    FT(FTData),
    FC(FCData),
}

/// Struct to return in views to query for drop info
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonDrop {
    // Drop ID for this drop
    pub drop_id: DropId,
    // Funder of this specific drop
    pub funder_id: AccountId,

    // Balance for all keys of this drop. Can be 0 if specified.
    pub balance: U128,

    // Every drop must have a type
    pub drop_type: JsonDropType,

    // The drop as a whole can have a config as well
    pub drop_config: DropConfig,

    // Metadata for the drop
    pub drop_metadata: Option<DropMetadata>,

    // How many claims
    pub num_claims_registered: u64,

    // Ensure this drop can only be used when the function has the required gas to attach
    pub required_gas_attached: Gas,
}

/// Keep track of nft data
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonNFTData {
    pub nft_sender: AccountId,
    pub nft_contract: AccountId,
    pub longest_token_id: String,
    pub storage_for_longest: U128,
}

/// Struct to return in views to query for specific data related to an access key.
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonKeyInfo {
    // Drop ID for the specific drop
    pub drop_id: DropId,
    pub pk: PublicKey,
    pub key_usage: KeyUsage,
    // Funder of this specific drop
    pub funder_id: AccountId,
    // Balance for all linkdrops of this drop
    pub balance: U128,

    // Every drop must have a type
    pub drop_type: JsonDropType,

    // The drop as a whole can have a config as well
    pub drop_config: DropConfig,
}

#[near_bindgen]
impl DropZone {
    /// Returns the balance associated with given key. This is used by the NEAR wallet to display the amount of the linkdrop
    pub fn get_key_balance(&self, key: PublicKey) -> U128 {
        let drop_id = self
            .drop_id_for_pk
            .get(&key)
            .expect("no drop ID found for key");
        let drop = self
            .drop_for_id
            .get(&drop_id)
            .expect("no drop found for drop ID");
        (drop.balance.0).into()
    }

    /*
        CUSTOM
    */
    /// Query for the total supply of keys on the contract
    pub fn key_total_supply(&self) -> U128 {
        //return the length of the data_for_pk set
        U128(self.drop_id_for_pk.len() as u128)
    }

    /// Paginate through all active keys on the contract and return a vector of key info.
    pub fn get_keys(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonKeyInfo> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each key using an iterator
        self.drop_id_for_pk
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the public key which are strings into Drops
            .map(|pk| self.get_key_information(pk.clone()))
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    /// Returns the JsonKeyInfo corresponding to a specific key
    pub fn get_key_information(&self, key: PublicKey) -> JsonKeyInfo {
        let drop_id = self
            .drop_id_for_pk
            .get(&key)
            .expect("no drop ID found for key");
        let drop = self
            .drop_for_id
            .get(&drop_id)
            .expect("no drop found for drop ID");
        let key_usage = drop.pks.get(&key).unwrap();

        let drop_type: JsonDropType = match drop.drop_type {
            DropType::FC(data) => JsonDropType::FC(data),
            DropType::NFT(data) => JsonDropType::NFT(JsonNFTData {
                nft_contract: data.nft_contract,
                nft_sender: data.nft_sender,
                longest_token_id: data.longest_token_id,
                storage_for_longest: U128(data.storage_for_longest),
            }),
            DropType::FT(data) => JsonDropType::FT(data),
            _simple => JsonDropType::Simple,
        };

        JsonKeyInfo {
            key_usage,
            drop_type,
            drop_config: drop.drop_config,
            drop_id,
            pk: key,
            funder_id: drop.funder_id,
            balance: drop.balance,
        }
    }

    /// Returns the JsonDrop corresponding to a drop ID
    pub fn get_drop_information(&self, drop_id: DropId) -> JsonDrop {
        let drop = self
            .drop_for_id
            .get(&drop_id)
            .expect("no drop found for drop ID");

        let drop_type: JsonDropType = match drop.drop_type {
            DropType::FC(data) => JsonDropType::FC(data),
            DropType::NFT(data) => JsonDropType::NFT(JsonNFTData {
                nft_contract: data.nft_contract,
                nft_sender: data.nft_sender,
                longest_token_id: data.longest_token_id,
                storage_for_longest: U128(data.storage_for_longest),
            }),
            DropType::FT(data) => JsonDropType::FT(data),
            _simple => JsonDropType::Simple,
        };

        JsonDrop {
            drop_id,
            funder_id: drop.funder_id,
            balance: drop.balance,
            drop_type,
            drop_config: drop.drop_config,
            num_claims_registered: drop.num_claims_registered,
            required_gas_attached: drop.required_gas_attached,
            drop_metadata: drop.drop_metadata,
        }
    }

    /// Returns the total supply of active keys for a given drop
    pub fn key_supply_for_drop(&self, drop_id: DropId) -> u64 {
        // Get the drop object and return the length
        self.drop_for_id
            .get(&drop_id)
            .expect("no drop found")
            .pks
            .len()
    }

    /// Paginate through keys in a specific drop
    pub fn get_keys_for_drop(
        &self,
        drop_id: DropId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonKeyInfo> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each key using an iterator
        self.drop_for_id
            .get(&drop_id)
            .expect("No drop for given ID")
            .pks
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the public key which are strings into Drops
            .map(|pk| self.get_key_information(pk.clone()))
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    /// Returns the total supply of active keys for a given funder
    pub fn key_supply_for_funder(&self, account_id: AccountId) -> u64 {
        //get the set of drops for the passed in funder
        let drops_for_owner = self.drop_ids_for_funder.get(&account_id);
        near_sdk::log!("Drops: {:?}", drops_for_owner);

        //if there is some set of drops, we'll iterate through and collect all the keys
        if let Some(drops_for_owner) = drops_for_owner {
            let mut supply = 0;
            for id in drops_for_owner.iter() {
                near_sdk::log!("ID: {:?}", id);
                supply += self.drop_for_id.get(&id).unwrap().pks.len();
            }

            supply
        } else {
            //if there isn't a set of keys for the passed in account ID, we'll return 0
            0
        }
    }

    /// Returns the total supply of active drops for a given funder
    pub fn drop_supply_for_funder(&self, account_id: AccountId) -> u64 {
        //get the set of drops for the passed in funder
        let drops_for_owner = self.drop_ids_for_funder.get(&account_id);

        //if there is some set of drops, we'll return the length
        if let Some(drops_for_owner) = drops_for_owner {
            drops_for_owner.len()
        } else {
            //if there isn't a set of keys for the passed in account ID, we'll return 0
            0
        }
    }

    /// Return a vector of drop information for a funder
    pub fn drops_for_funder(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonDrop> {
        // Iterate through each drop ID and push JsonDrop to a vector
        let drop_ids = self.drop_ids_for_funder.get(&account_id);

        // If there are IDs, iterate and create the vector of JsonDrops otherwise return empty array.s
        if let Some(ids) = drop_ids {
            // Where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
            let start = u128::from(from_index.unwrap_or(U128(0)));

            ids.iter()
                // Skip to the index we specified in the start variable
                .skip(start as usize)
                // Take the first "limit" elements in the vector. If we didn't specify a limit, use 50
                .take(limit.unwrap_or(50) as usize)
                // Convert each ID into a JsonDrop
                .map(|id| self.get_drop_information(id))
                // Collect all JsonDrops into a vector and return it
                .collect()
        } else {
            return vec![];
        }
    }

    /// Returns if the current token ID lives in the NFT drop
    pub fn drop_contains_token_id(&self, drop_id: DropId, token_id: String) -> bool {
        let drop = self.drop_for_id.get(&drop_id).expect("no drop found");
        if let DropType::NFT(nft_data) = drop.drop_type {
            nft_data.token_ids.contains(&token_id)
        } else {
            false
        }
    }

    /// Paginate through token IDs in a drop
    pub fn get_token_ids_for_drop(
        &self,
        drop_id: DropId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<String> {
        let drop = self.drop_for_id.get(&drop_id).expect("no drop found");
        if let DropType::NFT(nft_data) = drop.drop_type {
            let token_ids = nft_data.token_ids;

            // Where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
            let start = u128::from(from_index.unwrap_or(U128(0)));

            // Iterate through each token ID using an iterator
            token_ids
                .iter()
                //skip to the index we specified in the start variable
                .skip(start as usize)
                //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
                .take(limit.unwrap_or(50) as usize)
                //since we turned the keys into an iterator, we need to turn it back into a vector to return
                .collect()
        } else {
            return vec![];
        }
    }

    /// Returns the current nonce on the contract
    pub fn get_nonce(&self) -> u128 {
        self.nonce
    }

    /// Returns how many fees the contract has collected
    pub fn get_fees_collected(&self) -> U128 {
        U128(self.fees_collected)
    }
}

'''
'''--- deploy/ft/ft-add.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;
let FT_CONTRACT_ID = "ft.examples.benjiman.testnet";

let OFFSET = 0.1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	let dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	dropId -= 1;
	
	console.log('dropId: ', dropId);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_drop', 
			{
				public_keys: pubKeys,
				drop_id: dropId
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		console.log(`Transferring ${25 * NUM_KEYS} FTs from ${FUNDING_ACCOUNT_ID} to ${LINKDROP_PROXY_CONTRACT_ID}`);
		await fundingAccount.functionCall(
			FT_CONTRACT_ID, 
			'ft_transfer_call', 
			{
				receiver_id: LINKDROP_PROXY_CONTRACT_ID,
				amount: (25 * NUM_KEYS).toString(),
				msg: dropId.toString(),
			}, 
			"300000000000000", 
			'1'
		);
	} catch(e) {
		console.log('error sending FTs: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);

		await writeFile(path.resolve(__dirname, `views-add.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let curPksBuff = await readFile(path.resolve(__dirname, `pks.json`));
	let curPks = JSON.parse(curPksBuff);
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));

}

start();
'''
'''--- deploy/ft/ft-create.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;
let FT_CONTRACT_ID = "ft.examples.benjiman.testnet";

let OFFSET = 0.1;
let DROP_FEE = 1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

let drop_metadata = {
	title: "This is a title",
	description: "This is a description"
}

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const contractAccount = await near.account(LINKDROP_PROXY_CONTRACT_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	console.log(`initializing contract for account ${LINKDROP_PROXY_CONTRACT_ID}`);
	try {
		await contractAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'new', 
			{
				linkdrop_contract: "testnet",
				owner_id: LINKDROP_PROXY_CONTRACT_ID
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	const dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key + DROP_FEE).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let ft_data = {};
		ft_data["ft_contract"] = FT_CONTRACT_ID;
		ft_data["ft_sender"] = FUNDING_ACCOUNT_ID;
		ft_data["ft_balance"] = "25";
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'create_drop', 
			{
				public_keys: pubKeys,
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				ft_data,
				drop_config,
				drop_metadata: JSON.stringify(drop_metadata)
			}, 
			"300000000000000"
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		console.log(`Paying for FT storage on contract: ${FT_CONTRACT_ID} for the proxy contract ID`);
		await fundingAccount.functionCall(
			FT_CONTRACT_ID, 
			'storage_deposit', 
			{
				account_id: LINKDROP_PROXY_CONTRACT_ID,
			}, 
			"300000000000000", 
			parseNearAmount('1')
		);
		console.log(`Transferring ${25 * NUM_KEYS} FTs from ${FUNDING_ACCOUNT_ID} to ${LINKDROP_PROXY_CONTRACT_ID}`);
		await fundingAccount.functionCall(
			FT_CONTRACT_ID, 
			'ft_transfer_call', 
			{
				receiver_id: LINKDROP_PROXY_CONTRACT_ID,
				amount: (25 * NUM_KEYS).toString(),
				msg: dropId.toString(),
			}, 
			"300000000000000", 
			'1'
		);
	} catch(e) {
		console.log('error sending FTs: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);
		;
		await writeFile(path.resolve(__dirname, `views-create.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}
	
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/function-call/fc-add.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

let NFT_CONTRACT_ID = "nft.examples.testnet";
const METADATA = {
	"title": "Linkdropped Go Team NFT",
	"description": "Testing Linkdrop NFT Go Team Token",
	"media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
	"media_hash": null,
	"copies": 10000,
	"issued_at": null,
	"expires_at": null,
	"starts_at": null,
	"updated_at": null,
	"extra": null,
	"reference": null,
	"reference_hash": null
};

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	let dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	dropId -= 1;
	
	console.log('dropId: ', dropId);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET + 1) * pubKeys.length * drop_config.max_claims_per_key).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_drop', 
			{
				public_keys: pubKeys,
				drop_id: dropId
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		console.log(`minting NFT with token ID ${pubKeys[0]} on contract ${NFT_CONTRACT_ID} with receiver: ${FUNDING_ACCOUNT_ID}`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_mint', 
			{
				token_id: pubKeys[0],
				receiver_id: FUNDING_ACCOUNT_ID,
				metadata: METADATA,
			}, 
			"300000000000000", 
			parseNearAmount('1')
		);

		console.log(`transferring NFT to linkdrop proxy contract with nft_transfer_call`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_transfer_call', 
			{
				token_id: pubKeys[0],
				receiver_id: LINKDROP_PROXY_CONTRACT_ID,
				msg: dropId.toString(),
			}, 
			"300000000000000", 
			'1'
		);
	} catch(e) {
		console.log('error sending FTs: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);

		await writeFile(path.resolve(__dirname, `views-add.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let curPksBuff = await readFile(path.resolve(__dirname, `pks.json`));
	let curPks = JSON.parse(curPksBuff);
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));

}

start();
'''
'''--- deploy/function-call/fc-create.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let DROP_FEE = 1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

let drop_metadata = {
	title: "This is a title",
	description: "This is a description"
}

/*
	Hard coding NFT contract and metadata. Change this if you want.
*/
let NFT_CONTRACT_ID = "nft.examples.testnet";
const METADATA = {
	"title": "Linkdropped Go Team NFT",
	"description": "Testing Linkdrop NFT Go Team Token",
	"media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
	"media_hash": null,
	"copies": 10000,
	"issued_at": null,
	"expires_at": null,
	"starts_at": null,
	"updated_at": null,
	"extra": null,
	"reference": null,
	"reference_hash": null
};

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const contractAccount = await near.account(LINKDROP_PROXY_CONTRACT_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	console.log(`initializing contract for account ${LINKDROP_PROXY_CONTRACT_ID}`);
	try {
		await contractAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'new', 
			{
				linkdrop_contract: "testnet",
				owner_id: LINKDROP_PROXY_CONTRACT_ID
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	const dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET + 1) * pubKeys.length * drop_config.max_claims_per_key + DROP_FEE).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let fc_data = {
			method_data: [null, {
				receiver: "nft.examples.testnet",
				method: "nft_mint",
				args: JSON.stringify({
					token_id: pubKeys[0],
					metadata: METADATA,
				}),
				deposit: parseNearAmount("1")
			}],
			config: {
				refund_to_deposit: true,
				claimed_account_field: "receiver_id",
				// How much GAS should be attached to the function call. Cannot be greater than ATTACHED_GAS_FROM_WALLET - GAS_OFFSET_IF_FC_EXECUTE (90 TGas).
				gas_if_claim_only: "80000000000000",
				attach_drop_id: true
			}
		}

		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'create_drop', 
			{
				public_keys: pubKeys,
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				fc_data,
				drop_config,
				drop_metadata: JSON.stringify(drop_metadata)
			}, 
			"300000000000000"
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);
		;
		await writeFile(path.resolve(__dirname, `views-create.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}
	
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/nft/nft-add.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

let NFT_CONTRACT_ID = "nft.examples.testnet";
const METADATA = {
	"title": "Linkdropped Go Team NFT",
	"description": "Testing Linkdrop NFT Go Team Token",
	"media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
	"media_hash": null,
	"copies": 10000,
	"issued_at": null,
	"expires_at": null,
	"starts_at": null,
	"updated_at": null,
	"extra": null,
	"reference": null,
	"reference_hash": null
};

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	let keyPairs = [];
	let pubKeys = [];
	let viewData = {};

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	let dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	dropId -= 1;
	
	console.log('dropId: ', dropId);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_drop', 
			{
				public_keys: pubKeys,
				drop_id: dropId
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		console.log(`minting NFT with token ID ${pubKeys[0]} on contract ${NFT_CONTRACT_ID} with receiver: ${FUNDING_ACCOUNT_ID}`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_mint', 
			{
				token_id: pubKeys[0],
				receiver_id: FUNDING_ACCOUNT_ID,
				metadata: METADATA,
			}, 
			"300000000000000", 
			parseNearAmount('1')
		);

		console.log(`transferring NFT to linkdrop proxy contract with nft_transfer_call`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_transfer_call', 
			{
				token_id: pubKeys[0],
				receiver_id: LINKDROP_PROXY_CONTRACT_ID,
				msg: dropId.toString(),
			}, 
			"300000000000000", 
			'1'
		);
	} catch(e) {
		console.log('error sending FTs: ', e);
	}

	try {
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);

		const tokens = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_token_ids_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.token_ids_for_drop_after = tokens; 
		console.log('tokens after: ', tokens);

		await writeFile(path.resolve(__dirname, `views-add.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let curPksBuff = await readFile(path.resolve(__dirname, `pks.json`));
	let curPks = JSON.parse(curPksBuff);
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));

}

start();
'''
'''--- deploy/nft/nft-create.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let DROP_FEE = 1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

let drop_metadata = {
	title: "This is a title",
	description: "This is a description"
}

/*
	Hard coding NFT contract and metadata. Change this if you want.
*/
let NFT_CONTRACT_ID = "nft.examples.testnet";
const METADATA = {
	"title": "Linkdropped Go Team NFT",
	"description": "Testing Linkdrop NFT Go Team Token",
	"media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
	"media_hash": null,
	"copies": 10000,
	"issued_at": null,
	"expires_at": null,
	"starts_at": null,
	"updated_at": null,
	"extra": null,
	"reference": null,
	"reference_hash": null
};

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const contractAccount = await near.account(LINKDROP_PROXY_CONTRACT_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	console.log(`initializing contract for account ${LINKDROP_PROXY_CONTRACT_ID}`);
	try {
		await contractAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'new', 
			{
				linkdrop_contract: "testnet",
				owner_id: LINKDROP_PROXY_CONTRACT_ID
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let keyPairs = [];
	let pubKeys = [];
	let viewData = {};

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	const dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key + DROP_FEE).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let nft_data = {};
		nft_data["nft_contract"] = NFT_CONTRACT_ID;
		nft_data["nft_sender"] = FUNDING_ACCOUNT_ID;
		nft_data["longest_token_id"] = pubKeys[0];

		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'create_drop', 
			{
				public_keys: pubKeys,
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				nft_data,
				drop_config,
				drop_metadata: JSON.stringify(drop_metadata)
			}, 
			"300000000000000"
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		const tokens = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_token_ids_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.token_ids_for_drop_before = tokens; 
		console.log('tokens: ', tokens);
	} catch(e) {
		console.log("Error getting tokens: ", e);
	}

	try {
		console.log(`minting NFT with token ID ${pubKeys[0]} on contract ${NFT_CONTRACT_ID} with receiver: ${FUNDING_ACCOUNT_ID}`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_mint', 
			{
				token_id: pubKeys[0],
				receiver_id: FUNDING_ACCOUNT_ID,
				metadata: METADATA,
			}, 
			"300000000000000", 
			parseNearAmount('1')
		);

		console.log(`transferring NFT to linkdrop proxy contract with nft_transfer_call`);
		await fundingAccount.functionCall(
			NFT_CONTRACT_ID, 
			'nft_transfer_call', 
			{
				token_id: pubKeys[0],
				receiver_id: LINKDROP_PROXY_CONTRACT_ID,
				msg: dropId.toString(),
			}, 
			"300000000000000", 
			'1'
		);
	} catch(e) {
		console.log('error sending FTs: ', e);
	}

	try {
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);

		const tokens = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_token_ids_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.token_ids_for_drop_after = tokens; 
		console.log('tokens after: ', tokens);

		await writeFile(path.resolve(__dirname, `views-create.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}
	
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/recursive-fc.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.LINKDROP_PROXY_CONTRACT_ID;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let STORAGE = 0.038;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID || !FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify proxy contract ID, funding account ID and linkdrop $NEAR amount";
	}

	const contractAccount = await near.account(LINKDROP_PROXY_CONTRACT_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	console.log(`initializing contract for account ${LINKDROP_PROXY_CONTRACT_ID}`);
	try {
		await contractAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'new', 
			{
				linkdrop_contract: "testnet",
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let keyPairs = [];
	let pubKeys = [];
	console.log("Creating keypairs");
	for(var i = 0; i < 5; i++) {
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	console.log(`sending ${LINKDROP_NEAR_AMOUNT} $NEAR as ${FUNDING_ACCOUNT_ID}`);
	try {
		let fc_data_base = {};
		let argsBase = JSON.stringify({
			public_key:  keyPairs[0].publicKey.toString(),
			balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
		});
		fc_data_base["receiver"] = LINKDROP_PROXY_CONTRACT_ID;
		fc_data_base["method"] = "send";
		fc_data_base["args"] = argsBase;
		fc_data_base["deposit"] = parseNearAmount((parseFloat(LINKDROP_NEAR_AMOUNT) + OFFSET + STORAGE).toString());
		console.log("Base case deposit: ", (parseFloat(LINKDROP_NEAR_AMOUNT) + OFFSET + STORAGE).toString());
		
		let argsArray = [];
		argsArray.push(fc_data_base);
		console.log('argsArray: ', argsArray);

		let fc_data_final = {};
		for(var i = 1; i < keyPairs.length-1; i++) {
			let args = JSON.stringify({
				public_key:  keyPairs[i].publicKey.toString(),
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				fc_data: argsArray[i - 1],
			});
            
			fc_data_final["receiver"] = LINKDROP_PROXY_CONTRACT_ID;
			fc_data_final["method"] = "send";
			fc_data_final["args"] = args;
			fc_data_final["deposit"] = parseNearAmount(((parseFloat(LINKDROP_NEAR_AMOUNT) + OFFSET + STORAGE) * (i+1)).toString());
			console.log("deposit for iter: ", i, " : ", ((parseFloat(LINKDROP_NEAR_AMOUNT) + OFFSET + STORAGE)) * (i+1).toString());
            
			//console.log('fc_data_final: ', fc_data_final);
			console.log('args Length: ', args.length);

			argsArray.push(fc_data_final);
		}
        
		console.log('fc_data_final: ', fc_data_final);
		
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'send', 
			{
				public_key: keyPairs[keyPairs.length - 1].publicKey.toString(),
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				fc_data: fc_data_final,
			}, 
			"300000000000000", 
			parseNearAmount(((parseFloat(LINKDROP_NEAR_AMOUNT) + OFFSET + STORAGE) * (keyPairs.length)).toString())
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}
    
	for(var i = 0; i < keyPairs.length; i++) {
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}
}

start();
'''
'''--- deploy/simple/simple-add.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	// usage_interval: 6e11, // 10 minutes
	refund_if_claim: false,
	only_call_claim: false
}

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	let dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	dropId -= 1;
	
	console.log('dropId: ', dropId);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_drop', 
			{
				public_keys: pubKeys,
				drop_id: dropId
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);

		await writeFile(path.resolve(__dirname, `views-add.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let curPksBuff = await readFile(path.resolve(__dirname, `pks.json`));
	let curPks = JSON.parse(curPksBuff);
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/simple/simple-create.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
  
let LINKDROP_PROXY_CONTRACT_ID = process.env.CONTRACT_NAME;
let FUNDING_ACCOUNT_ID = process.env.FUNDING_ACCOUNT_ID;
let LINKDROP_NEAR_AMOUNT = process.env.LINKDROP_NEAR_AMOUNT;

let OFFSET = 0.1;
let DROP_FEE = 1;
let KEY_FEE = 0.005;
let NUM_KEYS = 1;

let NETWORK_ID = "testnet";
let near;
let config;
let keyStore;

let drop_config = {
	max_claims_per_key: 2,

	start_timestamp: 0,
	usage_interval: 1e10, // 10 seconds
	refund_if_claim: false,
	only_call_claim: false
}

let drop_metadata = {
	title: "This is a title",
	description: "This is a description"
}

// set up near
const initiateNear = async () => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	config = {
		networkId: NETWORK_ID,
		keyStore,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		explorerUrl: "https://explorer.testnet.near.org",
	};

	near = await connect(config);
};

async function start() {
	//deployed linkdrop proxy contract
	await initiateNear();

	if(!LINKDROP_PROXY_CONTRACT_ID) {
		const dev_account = await readFile(`neardev/dev-account`);
		LINKDROP_PROXY_CONTRACT_ID = dev_account.toString();
	}

	console.log('LINKDROP_PROXY_CONTRACT_ID: ', LINKDROP_PROXY_CONTRACT_ID);
	console.log('FUNDING_ACCOUNT_ID: ', FUNDING_ACCOUNT_ID);
	console.log('LINKDROP_NEAR_AMOUNT: ', LINKDROP_NEAR_AMOUNT);

	if(!FUNDING_ACCOUNT_ID || !LINKDROP_NEAR_AMOUNT) {
		throw "must specify funding account and linkdrop near amount";
	}

	const contractAccount = await near.account(LINKDROP_PROXY_CONTRACT_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	console.log(`initializing contract for account ${LINKDROP_PROXY_CONTRACT_ID}`);
	try {
		await contractAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'new', 
			{
				linkdrop_contract: "testnet",
				owner_id: LINKDROP_PROXY_CONTRACT_ID
			}, 
			"300000000000000", 
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	let keyPairs = [];
	let pubKeys = [];

	console.log("BATCH Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		console.log('i: ', i);
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log("Finished.");

	const dropId = await fundingAccount.viewFunction(
		LINKDROP_PROXY_CONTRACT_ID, 
		'get_nonce',
	);

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'add_to_balance', 
			{},
			"300000000000000", 
			parseNearAmount(
				((parseFloat(LINKDROP_NEAR_AMOUNT) + KEY_FEE + OFFSET) * pubKeys.length * drop_config.max_claims_per_key + DROP_FEE).toString()
			)
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		await fundingAccount.functionCall(
			LINKDROP_PROXY_CONTRACT_ID, 
			'create_drop', 
			{
				public_keys: pubKeys,
				balance: parseNearAmount(LINKDROP_NEAR_AMOUNT),
				drop_config,
				drop_metadata: JSON.stringify(drop_metadata)
			}, 
			"300000000000000"
		);
	} catch(e) {
		console.log('error initializing contract: ', e);
	}

	try {
		let viewData = {};
		const totalSupply = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_total_supply', 
		);
		viewData.key_total_supply = totalSupply; 
		console.log('totalSupply: ', totalSupply);

		const getKeys = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys'
		);
		viewData.get_keys = getKeys; 
		console.log('getKeys: ', getKeys);

		const keyInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_key_information',
			{
				key: pubKeys[0]
			}
		);
		viewData.get_key_information = keyInfo; 
		console.log('keyInfo: ', keyInfo);

		const dropInfo = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_drop_information',
			{
				drop_id: dropId
			}
		);
		viewData.get_drop_information = dropInfo; 
		console.log('dropInfo: ', dropInfo);

		const keysForDrop = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'get_keys_for_drop',
			{
				drop_id: dropId
			}
		);
		viewData.get_keys_for_drop = keysForDrop; 
		console.log('keysForDrop: ', keysForDrop);

		const keySupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'key_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.key_supply_for_funder = keySupplyForFunder; 
		console.log('keySupplyForFunder: ', keySupplyForFunder);

		const dropSupplyForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drop_supply_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drop_supply_for_funder = dropSupplyForFunder; 
		console.log('dropSupplyForFunder: ', dropSupplyForFunder);

		const dropsForFunder = await fundingAccount.viewFunction(
			LINKDROP_PROXY_CONTRACT_ID, 
			'drops_for_funder',
			{
				account_id: FUNDING_ACCOUNT_ID
			}
		);
		viewData.drops_for_funder = dropsForFunder; 
		console.log('dropsForFunder: ', dropsForFunder);
		;
		await writeFile(path.resolve(__dirname, `views-create.json`), JSON.stringify(viewData));
	} catch(e) {
		console.log('error initializing contract: ', e);
	}
	
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		curPks[keyPairs[i].publicKey.toString()] = `https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`;
		console.log(`https://wallet.testnet.near.org/linkdrop/${LINKDROP_PROXY_CONTRACT_ID}/${keyPairs[i].secretKey}`);
		console.log("Pub Key: ", keyPairs[i].publicKey.toString());
	}

	console.log('curPks: ', curPks)
	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- package-lock.json ---
{
	"name": "near-proxy-linkdrop-contract",
	"version": "1.0.0",
	"lockfileVersion": 2,
	"requires": true,
	"packages": {
		"": {
			"name": "near-proxy-linkdrop-contract",
			"version": "1.0.0",
			"license": "MIT",
			"dependencies": {
				"mocha": "^9.0.1"
			},
			"devDependencies": {
				"acquit": "^1.2.1",
				"acquit-markdown": "^0.1.0",
				"eslint": "^7.29.0",
				"near-api-js": "^0.44.2",
				"node-fetch": "^2.6.1"
			}
		},
		"node_modules/@babel/code-frame": {
			"version": "7.12.11",
			"resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz",
			"integrity": "sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==",
			"dev": true,
			"dependencies": {
				"@babel/highlight": "^7.10.4"
			}
		},
		"node_modules/@babel/helper-validator-identifier": {
			"version": "7.14.5",
			"resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.14.5.tgz",
			"integrity": "sha512-5lsetuxCLilmVGyiLEfoHBRX8UCFD+1m2x3Rj97WrW3V7H3u4RWRXA4evMjImCsin2J2YT0QaVDGf+z8ondbAg==",
			"dev": true,
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/highlight": {
			"version": "7.14.5",
			"resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.14.5.tgz",
			"integrity": "sha512-qf9u2WFWVV0MppaL877j2dBtQIDgmidgjGk5VIMw3OadXvYaXn66U1BFlH2t4+t3i+8PhedppRv+i40ABzd+gg==",
			"dev": true,
			"dependencies": {
				"@babel/helper-validator-identifier": "^7.14.5",
				"chalk": "^2.0.0",
				"js-tokens": "^4.0.0"
			},
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/highlight/node_modules/ansi-styles": {
			"version": "3.2.1",
			"resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
			"integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
			"dev": true,
			"dependencies": {
				"color-convert": "^1.9.0"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/@babel/highlight/node_modules/chalk": {
			"version": "2.4.2",
			"resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
			"integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
			"dev": true,
			"dependencies": {
				"ansi-styles": "^3.2.1",
				"escape-string-regexp": "^1.0.5",
				"supports-color": "^5.3.0"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/@babel/highlight/node_modules/color-convert": {
			"version": "1.9.3",
			"resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
			"integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
			"dev": true,
			"dependencies": {
				"color-name": "1.1.3"
			}
		},
		"node_modules/@babel/highlight/node_modules/color-name": {
			"version": "1.1.3",
			"resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
			"integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
			"dev": true
		},
		"node_modules/@babel/highlight/node_modules/escape-string-regexp": {
			"version": "1.0.5",
			"resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
			"integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
			"dev": true,
			"engines": {
				"node": ">=0.8.0"
			}
		},
		"node_modules/@babel/highlight/node_modules/has-flag": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
			"integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
			"dev": true,
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/@babel/highlight/node_modules/supports-color": {
			"version": "5.5.0",
			"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
			"integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
			"dev": true,
			"dependencies": {
				"has-flag": "^3.0.0"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/@eslint/eslintrc": {
			"version": "0.4.2",
			"resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.2.tgz",
			"integrity": "sha512-8nmGq/4ycLpIwzvhI4tNDmQztZ8sp+hI7cyG8i1nQDhkAbRzHpXPidRAHlNvCZQpJTKw5ItIpMw9RSToGF00mg==",
			"dev": true,
			"dependencies": {
				"ajv": "^6.12.4",
				"debug": "^4.1.1",
				"espree": "^7.3.0",
				"globals": "^13.9.0",
				"ignore": "^4.0.6",
				"import-fresh": "^3.2.1",
				"js-yaml": "^3.13.1",
				"minimatch": "^3.0.4",
				"strip-json-comments": "^3.1.1"
			},
			"engines": {
				"node": "^10.12.0 || >=12.0.0"
			}
		},
		"node_modules/@ungap/promise-all-settled": {
			"version": "1.1.2",
			"resolved": "https://registry.npmjs.org/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz",
			"integrity": "sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q=="
		},
		"node_modules/acorn": {
			"version": "7.4.1",
			"resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
			"integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
			"dev": true,
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/acorn-jsx": {
			"version": "5.3.1",
			"resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.1.tgz",
			"integrity": "sha512-K0Ptm/47OKfQRpNQ2J/oIN/3QYiK6FwW+eJbILhsdxh2WTLdl+30o8aGdTbm5JbffpFFAg/g+zi1E+jvJha5ng==",
			"dev": true,
			"peerDependencies": {
				"acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
			}
		},
		"node_modules/acquit": {
			"version": "1.2.1",
			"resolved": "https://registry.npmjs.org/acquit/-/acquit-1.2.1.tgz",
			"integrity": "sha512-xPBt/p7b0Y5yBj4UTeB5JoxmVAb9LaGWhzr1Bzgt81/yFZ5suPph93b/DcgrZ30ywRrsKz5jXbr8dBzYIoPoQw==",
			"dev": true,
			"dependencies": {
				"esprima": "4.0.0",
				"marked": "0.7.x"
			}
		},
		"node_modules/acquit-markdown": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/acquit-markdown/-/acquit-markdown-0.1.0.tgz",
			"integrity": "sha512-mCtIZ2IrEhF/FDPt+KTpdGSFaWtQV6fr0OYg27fR4iKuIWsk2P0c8U2R4AWCH96BNOBh0cNEo35YKqtzQwoOGQ==",
			"dev": true,
			"dependencies": {
				"commander": "2.13.0"
			},
			"bin": {
				"acquit-markdown": "bin/acquit-markdown.js"
			},
			"peerDependencies": {
				"acquit": ">=0.4.0"
			}
		},
		"node_modules/ajv": {
			"version": "6.12.6",
			"resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
			"integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
			"dev": true,
			"dependencies": {
				"fast-deep-equal": "^3.1.1",
				"fast-json-stable-stringify": "^2.0.0",
				"json-schema-traverse": "^0.4.1",
				"uri-js": "^4.2.2"
			},
			"funding": {
				"type": "github",
				"url": "https://github.com/sponsors/epoberezkin"
			}
		},
		"node_modules/ansi-colors": {
			"version": "4.1.1",
			"resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
			"integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/ansi-regex": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
			"integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/ansi-styles": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
			"integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
			"dependencies": {
				"color-convert": "^2.0.1"
			},
			"engines": {
				"node": ">=8"
			},
			"funding": {
				"url": "https://github.com/chalk/ansi-styles?sponsor=1"
			}
		},
		"node_modules/anymatch": {
			"version": "3.1.2",
			"resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.2.tgz",
			"integrity": "sha512-P43ePfOAIupkguHUycrc4qJ9kz8ZiuOUijaETwX7THt0Y/GNK7v0aa8rY816xWjZ7rJdA5XdMcpVFTKMq+RvWg==",
			"dependencies": {
				"normalize-path": "^3.0.0",
				"picomatch": "^2.0.4"
			},
			"engines": {
				"node": ">= 8"
			}
		},
		"node_modules/argparse": {
			"version": "1.0.10",
			"resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
			"integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
			"dev": true,
			"dependencies": {
				"sprintf-js": "~1.0.2"
			}
		},
		"node_modules/astral-regex": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
			"integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
			"dev": true,
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/balanced-match": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
			"integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="
		},
		"node_modules/base-x": {
			"version": "3.0.8",
			"resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.8.tgz",
			"integrity": "sha512-Rl/1AWP4J/zRrk54hhlxH4drNxPJXYUaKffODVI53/dAsV4t9fBxyxYKAVPU1XBHxYwOWP9h9H0hM2MVw4YfJA==",
			"dev": true,
			"dependencies": {
				"safe-buffer": "^5.0.1"
			}
		},
		"node_modules/binary-extensions": {
			"version": "2.2.0",
			"resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
			"integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/bn.js": {
			"version": "5.2.0",
			"resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
			"integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw==",
			"dev": true
		},
		"node_modules/borsh": {
			"version": "0.6.0",
			"resolved": "https://registry.npmjs.org/borsh/-/borsh-0.6.0.tgz",
			"integrity": "sha512-sl5k89ViqsThXQpYa9XDtz1sBl3l1lI313cFUY1HKr+wvMILnb+58xpkqTNrYbelh99dY7K8usxoCusQmqix9Q==",
			"dev": true,
			"dependencies": {
				"bn.js": "^5.2.0",
				"bs58": "^4.0.0",
				"text-encoding-utf-8": "^1.0.2"
			}
		},
		"node_modules/brace-expansion": {
			"version": "1.1.11",
			"resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
			"integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
			"dependencies": {
				"balanced-match": "^1.0.0",
				"concat-map": "0.0.1"
			}
		},
		"node_modules/braces": {
			"version": "3.0.2",
			"resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
			"integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
			"dependencies": {
				"fill-range": "^7.0.1"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/browser-stdout": {
			"version": "1.3.1",
			"resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
			"integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw=="
		},
		"node_modules/bs58": {
			"version": "4.0.1",
			"resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
			"integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
			"dev": true,
			"dependencies": {
				"base-x": "^3.0.2"
			}
		},
		"node_modules/callsites": {
			"version": "3.1.0",
			"resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
			"integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
			"dev": true,
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/camelcase": {
			"version": "6.2.0",
			"resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.2.0.tgz",
			"integrity": "sha512-c7wVvbw3f37nuobQNtgsgG9POC9qMbNuMQmTCqZv23b6MIz0fcYpBiOlv9gEN/hdLdnZTDQhg6e9Dq5M1vKvfg==",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/capability": {
			"version": "0.2.5",
			"resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
			"integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE=",
			"dev": true
		},
		"node_modules/chalk": {
			"version": "4.1.1",
			"resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
			"integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
			"dependencies": {
				"ansi-styles": "^4.1.0",
				"supports-color": "^7.1.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/chalk?sponsor=1"
			}
		},
		"node_modules/chokidar": {
			"version": "3.5.1",
			"resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.1.tgz",
			"integrity": "sha512-9+s+Od+W0VJJzawDma/gvBNQqkTiqYTWLuZoyAsivsI4AaWTCzHG06/TMjsf1cYe9Cb97UCEhjz7HvnPk2p/tw==",
			"dependencies": {
				"anymatch": "~3.1.1",
				"braces": "~3.0.2",
				"glob-parent": "~5.1.0",
				"is-binary-path": "~2.1.0",
				"is-glob": "~4.0.1",
				"normalize-path": "~3.0.0",
				"readdirp": "~3.5.0"
			},
			"engines": {
				"node": ">= 8.10.0"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.1"
			}
		},
		"node_modules/cliui": {
			"version": "7.0.4",
			"resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
			"integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
			"dependencies": {
				"string-width": "^4.2.0",
				"strip-ansi": "^6.0.0",
				"wrap-ansi": "^7.0.0"
			}
		},
		"node_modules/color-convert": {
			"version": "2.0.1",
			"resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
			"integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
			"dependencies": {
				"color-name": "~1.1.4"
			},
			"engines": {
				"node": ">=7.0.0"
			}
		},
		"node_modules/color-name": {
			"version": "1.1.4",
			"resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
			"integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="
		},
		"node_modules/commander": {
			"version": "2.13.0",
			"resolved": "https://registry.npmjs.org/commander/-/commander-2.13.0.tgz",
			"integrity": "sha512-MVuS359B+YzaWqjCL/c+22gfryv+mCBPHAv3zyVI2GN8EY6IRP8VwtasXn8jyyhvvq84R4ImN1OKRtcbIasjYA==",
			"dev": true
		},
		"node_modules/concat-map": {
			"version": "0.0.1",
			"resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
			"integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="
		},
		"node_modules/cross-spawn": {
			"version": "7.0.3",
			"resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
			"integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
			"dev": true,
			"dependencies": {
				"path-key": "^3.1.0",
				"shebang-command": "^2.0.0",
				"which": "^2.0.1"
			},
			"engines": {
				"node": ">= 8"
			}
		},
		"node_modules/debug": {
			"version": "4.3.1",
			"resolved": "https://registry.npmjs.org/debug/-/debug-4.3.1.tgz",
			"integrity": "sha512-doEwdvm4PCeK4K3RQN2ZC2BYUBaxwLARCqZmMjtF8a51J2Rb0xpVloFRnCODwqjpwnAoao4pelN8l3RJdv3gRQ==",
			"dependencies": {
				"ms": "2.1.2"
			},
			"engines": {
				"node": ">=6.0"
			},
			"peerDependenciesMeta": {
				"supports-color": {
					"optional": true
				}
			}
		},
		"node_modules/decamelize": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
			"integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/deep-is": {
			"version": "0.1.3",
			"resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
			"integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
			"dev": true
		},
		"node_modules/depd": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
			"integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
			"dev": true,
			"engines": {
				"node": ">= 0.8"
			}
		},
		"node_modules/diff": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
			"integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
			"engines": {
				"node": ">=0.3.1"
			}
		},
		"node_modules/doctrine": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
			"integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
			"dev": true,
			"dependencies": {
				"esutils": "^2.0.2"
			},
			"engines": {
				"node": ">=6.0.0"
			}
		},
		"node_modules/emoji-regex": {
			"version": "8.0.0",
			"resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
			"integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A=="
		},
		"node_modules/enquirer": {
			"version": "2.3.6",
			"resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz",
			"integrity": "sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==",
			"dev": true,
			"dependencies": {
				"ansi-colors": "^4.1.1"
			},
			"engines": {
				"node": ">=8.6"
			}
		},
		"node_modules/error-polyfill": {
			"version": "0.1.3",
			"resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
			"integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
			"dev": true,
			"dependencies": {
				"capability": "^0.2.5",
				"o3": "^1.0.3",
				"u3": "^0.1.1"
			}
		},
		"node_modules/escalade": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
			"integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/escape-string-regexp": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
			"integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/eslint": {
			"version": "7.29.0",
			"resolved": "https://registry.npmjs.org/eslint/-/eslint-7.29.0.tgz",
			"integrity": "sha512-82G/JToB9qIy/ArBzIWG9xvvwL3R86AlCjtGw+A29OMZDqhTybz/MByORSukGxeI+YPCR4coYyITKk8BFH9nDA==",
			"dev": true,
			"dependencies": {
				"@babel/code-frame": "7.12.11",
				"@eslint/eslintrc": "^0.4.2",
				"ajv": "^6.10.0",
				"chalk": "^4.0.0",
				"cross-spawn": "^7.0.2",
				"debug": "^4.0.1",
				"doctrine": "^3.0.0",
				"enquirer": "^2.3.5",
				"escape-string-regexp": "^4.0.0",
				"eslint-scope": "^5.1.1",
				"eslint-utils": "^2.1.0",
				"eslint-visitor-keys": "^2.0.0",
				"espree": "^7.3.1",
				"esquery": "^1.4.0",
				"esutils": "^2.0.2",
				"fast-deep-equal": "^3.1.3",
				"file-entry-cache": "^6.0.1",
				"functional-red-black-tree": "^1.0.1",
				"glob-parent": "^5.1.2",
				"globals": "^13.6.0",
				"ignore": "^4.0.6",
				"import-fresh": "^3.0.0",
				"imurmurhash": "^0.1.4",
				"is-glob": "^4.0.0",
				"js-yaml": "^3.13.1",
				"json-stable-stringify-without-jsonify": "^1.0.1",
				"levn": "^0.4.1",
				"lodash.merge": "^4.6.2",
				"minimatch": "^3.0.4",
				"natural-compare": "^1.4.0",
				"optionator": "^0.9.1",
				"progress": "^2.0.0",
				"regexpp": "^3.1.0",
				"semver": "^7.2.1",
				"strip-ansi": "^6.0.0",
				"strip-json-comments": "^3.1.0",
				"table": "^6.0.9",
				"text-table": "^0.2.0",
				"v8-compile-cache": "^2.0.3"
			},
			"bin": {
				"eslint": "bin/eslint.js"
			},
			"engines": {
				"node": "^10.12.0 || >=12.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/eslint"
			}
		},
		"node_modules/eslint-scope": {
			"version": "5.1.1",
			"resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
			"integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
			"dev": true,
			"dependencies": {
				"esrecurse": "^4.3.0",
				"estraverse": "^4.1.1"
			},
			"engines": {
				"node": ">=8.0.0"
			}
		},
		"node_modules/eslint-utils": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
			"integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
			"dev": true,
			"dependencies": {
				"eslint-visitor-keys": "^1.1.0"
			},
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"url": "https://github.com/sponsors/mysticatea"
			}
		},
		"node_modules/eslint-utils/node_modules/eslint-visitor-keys": {
			"version": "1.3.0",
			"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
			"integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
			"dev": true,
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/eslint-visitor-keys": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz",
			"integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==",
			"dev": true,
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/espree": {
			"version": "7.3.1",
			"resolved": "https://registry.npmjs.org/espree/-/espree-7.3.1.tgz",
			"integrity": "sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==",
			"dev": true,
			"dependencies": {
				"acorn": "^7.4.0",
				"acorn-jsx": "^5.3.1",
				"eslint-visitor-keys": "^1.3.0"
			},
			"engines": {
				"node": "^10.12.0 || >=12.0.0"
			}
		},
		"node_modules/espree/node_modules/eslint-visitor-keys": {
			"version": "1.3.0",
			"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
			"integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
			"dev": true,
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/esprima": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.0.tgz",
			"integrity": "sha512-oftTcaMu/EGrEIu904mWteKIv8vMuOgGYo7EhVJJN00R/EED9DCua/xxHRdYnKtcECzVg7xOWhflvJMnqcFZjw==",
			"dev": true,
			"bin": {
				"esparse": "bin/esparse.js",
				"esvalidate": "bin/esvalidate.js"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/esquery": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz",
			"integrity": "sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==",
			"dev": true,
			"dependencies": {
				"estraverse": "^5.1.0"
			},
			"engines": {
				"node": ">=0.10"
			}
		},
		"node_modules/esquery/node_modules/estraverse": {
			"version": "5.2.0",
			"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
			"integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
			"dev": true,
			"engines": {
				"node": ">=4.0"
			}
		},
		"node_modules/esrecurse": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
			"integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
			"dev": true,
			"dependencies": {
				"estraverse": "^5.2.0"
			},
			"engines": {
				"node": ">=4.0"
			}
		},
		"node_modules/esrecurse/node_modules/estraverse": {
			"version": "5.2.0",
			"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
			"integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
			"dev": true,
			"engines": {
				"node": ">=4.0"
			}
		},
		"node_modules/estraverse": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
			"integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
			"dev": true,
			"engines": {
				"node": ">=4.0"
			}
		},
		"node_modules/esutils": {
			"version": "2.0.3",
			"resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
			"integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
			"dev": true,
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/fast-deep-equal": {
			"version": "3.1.3",
			"resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
			"integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
			"dev": true
		},
		"node_modules/fast-json-stable-stringify": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
			"integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
			"dev": true
		},
		"node_modules/fast-levenshtein": {
			"version": "2.0.6",
			"resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
			"integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
			"dev": true
		},
		"node_modules/file-entry-cache": {
			"version": "6.0.1",
			"resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
			"integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
			"dev": true,
			"dependencies": {
				"flat-cache": "^3.0.4"
			},
			"engines": {
				"node": "^10.12.0 || >=12.0.0"
			}
		},
		"node_modules/fill-range": {
			"version": "7.0.1",
			"resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
			"integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
			"dependencies": {
				"to-regex-range": "^5.0.1"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/find-up": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
			"integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
			"dependencies": {
				"locate-path": "^6.0.0",
				"path-exists": "^4.0.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/flat": {
			"version": "5.0.2",
			"resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
			"integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
			"bin": {
				"flat": "cli.js"
			}
		},
		"node_modules/flat-cache": {
			"version": "3.0.4",
			"resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
			"integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
			"dev": true,
			"dependencies": {
				"flatted": "^3.1.0",
				"rimraf": "^3.0.2"
			},
			"engines": {
				"node": "^10.12.0 || >=12.0.0"
			}
		},
		"node_modules/flatted": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/flatted/-/flatted-3.1.1.tgz",
			"integrity": "sha512-zAoAQiudy+r5SvnSw3KJy5os/oRJYHzrzja/tBDqrZtNhUw8bt6y8OBzMWcjWr+8liV8Eb6yOhw8WZ7VFZ5ZzA==",
			"dev": true
		},
		"node_modules/fs.realpath": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
			"integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8="
		},
		"node_modules/fsevents": {
			"version": "2.3.2",
			"resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
			"integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
			"hasInstallScript": true,
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/functional-red-black-tree": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
			"integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
			"dev": true
		},
		"node_modules/get-caller-file": {
			"version": "2.0.5",
			"resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
			"integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
			"engines": {
				"node": "6.* || 8.* || >= 10.*"
			}
		},
		"node_modules/glob": {
			"version": "7.1.7",
			"resolved": "https://registry.npmjs.org/glob/-/glob-7.1.7.tgz",
			"integrity": "sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==",
			"dependencies": {
				"fs.realpath": "^1.0.0",
				"inflight": "^1.0.4",
				"inherits": "2",
				"minimatch": "^3.0.4",
				"once": "^1.3.0",
				"path-is-absolute": "^1.0.0"
			},
			"engines": {
				"node": "*"
			},
			"funding": {
				"url": "https://github.com/sponsors/isaacs"
			}
		},
		"node_modules/glob-parent": {
			"version": "5.1.2",
			"resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
			"integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
			"dependencies": {
				"is-glob": "^4.0.1"
			},
			"engines": {
				"node": ">= 6"
			}
		},
		"node_modules/globals": {
			"version": "13.9.0",
			"resolved": "https://registry.npmjs.org/globals/-/globals-13.9.0.tgz",
			"integrity": "sha512-74/FduwI/JaIrr1H8e71UbDE+5x7pIPs1C2rrwC52SszOo043CsWOZEMW7o2Y58xwm9b+0RBKDxY5n2sUpEFxA==",
			"dev": true,
			"dependencies": {
				"type-fest": "^0.20.2"
			},
			"engines": {
				"node": ">=8"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/growl": {
			"version": "1.10.5",
			"resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
			"integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==",
			"engines": {
				"node": ">=4.x"
			}
		},
		"node_modules/has-flag": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
			"integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/he": {
			"version": "1.2.0",
			"resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
			"integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
			"bin": {
				"he": "bin/he"
			}
		},
		"node_modules/http-errors": {
			"version": "1.8.0",
			"resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.0.tgz",
			"integrity": "sha512-4I8r0C5JDhT5VkvI47QktDW75rNlGVsUf/8hzjCC/wkWI/jdTRmBb9aI7erSG82r1bjKY3F6k28WnsVxB1C73A==",
			"dev": true,
			"dependencies": {
				"depd": "~1.1.2",
				"inherits": "2.0.4",
				"setprototypeof": "1.2.0",
				"statuses": ">= 1.5.0 < 2",
				"toidentifier": "1.0.0"
			},
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/http-errors/node_modules/depd": {
			"version": "1.1.2",
			"resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
			"integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
			"dev": true,
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/ignore": {
			"version": "4.0.6",
			"resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
			"integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
			"dev": true,
			"engines": {
				"node": ">= 4"
			}
		},
		"node_modules/import-fresh": {
			"version": "3.3.0",
			"resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
			"integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
			"dev": true,
			"dependencies": {
				"parent-module": "^1.0.0",
				"resolve-from": "^4.0.0"
			},
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/imurmurhash": {
			"version": "0.1.4",
			"resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
			"integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
			"dev": true,
			"engines": {
				"node": ">=0.8.19"
			}
		},
		"node_modules/inflight": {
			"version": "1.0.6",
			"resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
			"integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
			"dependencies": {
				"once": "^1.3.0",
				"wrappy": "1"
			}
		},
		"node_modules/inherits": {
			"version": "2.0.4",
			"resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
			"integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
		},
		"node_modules/is-binary-path": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
			"integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
			"dependencies": {
				"binary-extensions": "^2.0.0"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/is-extglob": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
			"integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/is-fullwidth-code-point": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
			"integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/is-glob": {
			"version": "4.0.1",
			"resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
			"integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
			"dependencies": {
				"is-extglob": "^2.1.1"
			},
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/is-number": {
			"version": "7.0.0",
			"resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
			"integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
			"engines": {
				"node": ">=0.12.0"
			}
		},
		"node_modules/is-plain-obj": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
			"integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/is-unicode-supported": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
			"integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/isexe": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
			"integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA="
		},
		"node_modules/js-sha256": {
			"version": "0.9.0",
			"resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
			"integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA==",
			"dev": true
		},
		"node_modules/js-tokens": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
			"integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
			"dev": true
		},
		"node_modules/js-yaml": {
			"version": "3.14.1",
			"resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
			"integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
			"dev": true,
			"dependencies": {
				"argparse": "^1.0.7",
				"esprima": "^4.0.0"
			},
			"bin": {
				"js-yaml": "bin/js-yaml.js"
			}
		},
		"node_modules/json-schema-traverse": {
			"version": "0.4.1",
			"resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
			"integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
			"dev": true
		},
		"node_modules/json-stable-stringify-without-jsonify": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
			"integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
			"dev": true
		},
		"node_modules/levn": {
			"version": "0.4.1",
			"resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
			"integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
			"dev": true,
			"dependencies": {
				"prelude-ls": "^1.2.1",
				"type-check": "~0.4.0"
			},
			"engines": {
				"node": ">= 0.8.0"
			}
		},
		"node_modules/locate-path": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
			"integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
			"dependencies": {
				"p-locate": "^5.0.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/lodash.clonedeep": {
			"version": "4.5.0",
			"resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
			"integrity": "sha1-4j8/nE+Pvd6HJSnBBxhXoIblzO8=",
			"dev": true
		},
		"node_modules/lodash.merge": {
			"version": "4.6.2",
			"resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
			"integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
			"dev": true
		},
		"node_modules/lodash.truncate": {
			"version": "4.4.2",
			"resolved": "https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz",
			"integrity": "sha1-WjUNoLERO4N+z//VgSy+WNbq4ZM=",
			"dev": true
		},
		"node_modules/log-symbols": {
			"version": "4.1.0",
			"resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
			"integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
			"dependencies": {
				"chalk": "^4.1.0",
				"is-unicode-supported": "^0.1.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/lru-cache": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
			"integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
			"dev": true,
			"dependencies": {
				"yallist": "^4.0.0"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/marked": {
			"version": "0.7.0",
			"resolved": "https://registry.npmjs.org/marked/-/marked-0.7.0.tgz",
			"integrity": "sha512-c+yYdCZJQrsRjTPhUx7VKkApw9bwDkNbHUKo1ovgcfDjb2kc8rLuRbIFyXL5WOEUwzSSKo3IXpph2K6DqB/KZg==",
			"dev": true,
			"bin": {
				"marked": "bin/marked"
			},
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/minimatch": {
			"version": "3.0.4",
			"resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
			"integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
			"dependencies": {
				"brace-expansion": "^1.1.7"
			},
			"engines": {
				"node": "*"
			}
		},
		"node_modules/mocha": {
			"version": "9.0.1",
			"resolved": "https://registry.npmjs.org/mocha/-/mocha-9.0.1.tgz",
			"integrity": "sha512-9zwsavlRO+5csZu6iRtl3GHImAbhERoDsZwdRkdJ/bE+eVplmoxNKE901ZJ9LdSchYBjSCPbjKc5XvcAri2ylw==",
			"dependencies": {
				"@ungap/promise-all-settled": "1.1.2",
				"ansi-colors": "4.1.1",
				"browser-stdout": "1.3.1",
				"chokidar": "3.5.1",
				"debug": "4.3.1",
				"diff": "5.0.0",
				"escape-string-regexp": "4.0.0",
				"find-up": "5.0.0",
				"glob": "7.1.7",
				"growl": "1.10.5",
				"he": "1.2.0",
				"js-yaml": "4.1.0",
				"log-symbols": "4.1.0",
				"minimatch": "3.0.4",
				"ms": "2.1.3",
				"nanoid": "3.1.23",
				"serialize-javascript": "5.0.1",
				"strip-json-comments": "3.1.1",
				"supports-color": "8.1.1",
				"which": "2.0.2",
				"wide-align": "1.1.3",
				"workerpool": "6.1.4",
				"yargs": "16.2.0",
				"yargs-parser": "20.2.4",
				"yargs-unparser": "2.0.0"
			},
			"bin": {
				"_mocha": "bin/_mocha",
				"mocha": "bin/mocha"
			},
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/mochajs"
			}
		},
		"node_modules/mocha/node_modules/argparse": {
			"version": "2.0.1",
			"resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
			"integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q=="
		},
		"node_modules/mocha/node_modules/js-yaml": {
			"version": "4.1.0",
			"resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
			"integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
			"dependencies": {
				"argparse": "^2.0.1"
			},
			"bin": {
				"js-yaml": "bin/js-yaml.js"
			}
		},
		"node_modules/mocha/node_modules/ms": {
			"version": "2.1.3",
			"resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
			"integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
		},
		"node_modules/mocha/node_modules/supports-color": {
			"version": "8.1.1",
			"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
			"integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
			"dependencies": {
				"has-flag": "^4.0.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/supports-color?sponsor=1"
			}
		},
		"node_modules/ms": {
			"version": "2.1.2",
			"resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
			"integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
		},
		"node_modules/mustache": {
			"version": "4.2.0",
			"resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
			"integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
			"dev": true,
			"bin": {
				"mustache": "bin/mustache"
			}
		},
		"node_modules/nanoid": {
			"version": "3.1.23",
			"resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.1.23.tgz",
			"integrity": "sha512-FiB0kzdP0FFVGDKlRLEQ1BgDzU87dy5NnzjeW9YZNt+/c3+q82EQDUwniSAUxp/F0gFNI1ZhKU1FqYsMuqZVnw==",
			"bin": {
				"nanoid": "bin/nanoid.cjs"
			},
			"engines": {
				"node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
			}
		},
		"node_modules/natural-compare": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
			"integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
			"dev": true
		},
		"node_modules/near-api-js": {
			"version": "0.44.2",
			"resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.44.2.tgz",
			"integrity": "sha512-eMnc4V+geggapEUa3nU2p8HSHn/njtloI4P2mceHQWO8vDE1NGpnAw8FuTBrLmXSgIv9m6oocgFc9t3VNf5zwg==",
			"dev": true,
			"dependencies": {
				"bn.js": "5.2.0",
				"borsh": "^0.6.0",
				"bs58": "^4.0.0",
				"depd": "^2.0.0",
				"error-polyfill": "^0.1.3",
				"http-errors": "^1.7.2",
				"js-sha256": "^0.9.0",
				"mustache": "^4.0.0",
				"node-fetch": "^2.6.1",
				"text-encoding-utf-8": "^1.0.2",
				"tweetnacl": "^1.0.1"
			}
		},
		"node_modules/node-fetch": {
			"version": "2.6.1",
			"resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.1.tgz",
			"integrity": "sha512-V4aYg89jEoVRxRb2fJdAg8FHvI7cEyYdVAh94HH0UIK8oJxUfkjlDQN9RbMx+bEjP7+ggMiFRprSti032Oipxw==",
			"dev": true,
			"engines": {
				"node": "4.x || >=6.0.0"
			}
		},
		"node_modules/normalize-path": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
			"integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/o3": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
			"integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
			"dev": true,
			"dependencies": {
				"capability": "^0.2.5"
			}
		},
		"node_modules/once": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
			"integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
			"dependencies": {
				"wrappy": "1"
			}
		},
		"node_modules/optionator": {
			"version": "0.9.1",
			"resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
			"integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
			"dev": true,
			"dependencies": {
				"deep-is": "^0.1.3",
				"fast-levenshtein": "^2.0.6",
				"levn": "^0.4.1",
				"prelude-ls": "^1.2.1",
				"type-check": "^0.4.0",
				"word-wrap": "^1.2.3"
			},
			"engines": {
				"node": ">= 0.8.0"
			}
		},
		"node_modules/p-limit": {
			"version": "3.1.0",
			"resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
			"integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
			"dependencies": {
				"yocto-queue": "^0.1.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/p-locate": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
			"integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
			"dependencies": {
				"p-limit": "^3.0.2"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/parent-module": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
			"integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
			"dev": true,
			"dependencies": {
				"callsites": "^3.0.0"
			},
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/path-exists": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
			"integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/path-is-absolute": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
			"integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/path-key": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
			"integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
			"dev": true,
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/picomatch": {
			"version": "2.3.0",
			"resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.0.tgz",
			"integrity": "sha512-lY1Q/PiJGC2zOv/z391WOTD+Z02bCgsFfvxoXXf6h7kv9o+WmsmzYqrAwY63sNgOxE4xEdq0WyUnXfKeBrSvYw==",
			"engines": {
				"node": ">=8.6"
			},
			"funding": {
				"url": "https://github.com/sponsors/jonschlinkert"
			}
		},
		"node_modules/prelude-ls": {
			"version": "1.2.1",
			"resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
			"integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
			"dev": true,
			"engines": {
				"node": ">= 0.8.0"
			}
		},
		"node_modules/progress": {
			"version": "2.0.3",
			"resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
			"integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
			"dev": true,
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/punycode": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
			"integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
			"dev": true,
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/randombytes": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
			"integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
			"dependencies": {
				"safe-buffer": "^5.1.0"
			}
		},
		"node_modules/readdirp": {
			"version": "3.5.0",
			"resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.5.0.tgz",
			"integrity": "sha512-cMhu7c/8rdhkHXWsY+osBhfSy0JikwpHK/5+imo+LpeasTF8ouErHrlYkwT0++njiyuDvc7OFY5T3ukvZ8qmFQ==",
			"dependencies": {
				"picomatch": "^2.2.1"
			},
			"engines": {
				"node": ">=8.10.0"
			}
		},
		"node_modules/regexpp": {
			"version": "3.2.0",
			"resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz",
			"integrity": "sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==",
			"dev": true,
			"engines": {
				"node": ">=8"
			},
			"funding": {
				"url": "https://github.com/sponsors/mysticatea"
			}
		},
		"node_modules/require-directory": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
			"integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/require-from-string": {
			"version": "2.0.2",
			"resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
			"integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
			"dev": true,
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/resolve-from": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
			"integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
			"dev": true,
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/rimraf": {
			"version": "3.0.2",
			"resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
			"integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
			"dev": true,
			"dependencies": {
				"glob": "^7.1.3"
			},
			"bin": {
				"rimraf": "bin.js"
			},
			"funding": {
				"url": "https://github.com/sponsors/isaacs"
			}
		},
		"node_modules/safe-buffer": {
			"version": "5.2.1",
			"resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
			"integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
			"funding": [
				{
					"type": "github",
					"url": "https://github.com/sponsors/feross"
				},
				{
					"type": "patreon",
					"url": "https://www.patreon.com/feross"
				},
				{
					"type": "consulting",
					"url": "https://feross.org/support"
				}
			]
		},
		"node_modules/semver": {
			"version": "7.3.5",
			"resolved": "https://registry.npmjs.org/semver/-/semver-7.3.5.tgz",
			"integrity": "sha512-PoeGJYh8HK4BTO/a9Tf6ZG3veo/A7ZVsYrSA6J8ny9nb3B1VrpkuN+z9OE5wfE5p6H4LchYZsegiQgbJD94ZFQ==",
			"dev": true,
			"dependencies": {
				"lru-cache": "^6.0.0"
			},
			"bin": {
				"semver": "bin/semver.js"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/serialize-javascript": {
			"version": "5.0.1",
			"resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-5.0.1.tgz",
			"integrity": "sha512-SaaNal9imEO737H2c05Og0/8LUXG7EnsZyMa8MzkmuHoELfT6txuj0cMqRj6zfPKnmQ1yasR4PCJc8x+M4JSPA==",
			"dependencies": {
				"randombytes": "^2.1.0"
			}
		},
		"node_modules/setprototypeof": {
			"version": "1.2.0",
			"resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
			"integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
			"dev": true
		},
		"node_modules/shebang-command": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
			"integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
			"dev": true,
			"dependencies": {
				"shebang-regex": "^3.0.0"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/shebang-regex": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
			"integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
			"dev": true,
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/slice-ansi": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
			"integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
			"dev": true,
			"dependencies": {
				"ansi-styles": "^4.0.0",
				"astral-regex": "^2.0.0",
				"is-fullwidth-code-point": "^3.0.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/slice-ansi?sponsor=1"
			}
		},
		"node_modules/sprintf-js": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
			"integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
			"dev": true
		},
		"node_modules/statuses": {
			"version": "1.5.0",
			"resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
			"integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
			"dev": true,
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/string-width": {
			"version": "4.2.2",
			"resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz",
			"integrity": "sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==",
			"dependencies": {
				"emoji-regex": "^8.0.0",
				"is-fullwidth-code-point": "^3.0.0",
				"strip-ansi": "^6.0.0"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/strip-ansi": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
			"integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
			"dependencies": {
				"ansi-regex": "^5.0.0"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/strip-json-comments": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
			"integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
			"engines": {
				"node": ">=8"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/supports-color": {
			"version": "7.2.0",
			"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
			"integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
			"dependencies": {
				"has-flag": "^4.0.0"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/table": {
			"version": "6.7.1",
			"resolved": "https://registry.npmjs.org/table/-/table-6.7.1.tgz",
			"integrity": "sha512-ZGum47Yi6KOOFDE8m223td53ath2enHcYLgOCjGr5ngu8bdIARQk6mN/wRMv4yMRcHnCSnHbCEha4sobQx5yWg==",
			"dev": true,
			"dependencies": {
				"ajv": "^8.0.1",
				"lodash.clonedeep": "^4.5.0",
				"lodash.truncate": "^4.4.2",
				"slice-ansi": "^4.0.0",
				"string-width": "^4.2.0",
				"strip-ansi": "^6.0.0"
			},
			"engines": {
				"node": ">=10.0.0"
			}
		},
		"node_modules/table/node_modules/ajv": {
			"version": "8.6.0",
			"resolved": "https://registry.npmjs.org/ajv/-/ajv-8.6.0.tgz",
			"integrity": "sha512-cnUG4NSBiM4YFBxgZIj/In3/6KX+rQ2l2YPRVcvAMQGWEPKuXoPIhxzwqh31jA3IPbI4qEOp/5ILI4ynioXsGQ==",
			"dev": true,
			"dependencies": {
				"fast-deep-equal": "^3.1.1",
				"json-schema-traverse": "^1.0.0",
				"require-from-string": "^2.0.2",
				"uri-js": "^4.2.2"
			},
			"funding": {
				"type": "github",
				"url": "https://github.com/sponsors/epoberezkin"
			}
		},
		"node_modules/table/node_modules/json-schema-traverse": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
			"integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
			"dev": true
		},
		"node_modules/text-encoding-utf-8": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
			"integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg==",
			"dev": true
		},
		"node_modules/text-table": {
			"version": "0.2.0",
			"resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
			"integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
			"dev": true
		},
		"node_modules/to-regex-range": {
			"version": "5.0.1",
			"resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
			"integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
			"dependencies": {
				"is-number": "^7.0.0"
			},
			"engines": {
				"node": ">=8.0"
			}
		},
		"node_modules/toidentifier": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.0.tgz",
			"integrity": "sha512-yaOH/Pk/VEhBWWTlhI+qXxDFXlejDGcQipMlyxda9nthulaxLZUNcUqFxokp0vcYnvteJln5FNQDRrxj3YcbVw==",
			"dev": true,
			"engines": {
				"node": ">=0.6"
			}
		},
		"node_modules/tweetnacl": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
			"integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==",
			"dev": true
		},
		"node_modules/type-check": {
			"version": "0.4.0",
			"resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
			"integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
			"dev": true,
			"dependencies": {
				"prelude-ls": "^1.2.1"
			},
			"engines": {
				"node": ">= 0.8.0"
			}
		},
		"node_modules/type-fest": {
			"version": "0.20.2",
			"resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
			"integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
			"dev": true,
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/u3": {
			"version": "0.1.1",
			"resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
			"integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w==",
			"dev": true
		},
		"node_modules/uri-js": {
			"version": "4.4.1",
			"resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
			"integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
			"dev": true,
			"dependencies": {
				"punycode": "^2.1.0"
			}
		},
		"node_modules/v8-compile-cache": {
			"version": "2.3.0",
			"resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz",
			"integrity": "sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==",
			"dev": true
		},
		"node_modules/which": {
			"version": "2.0.2",
			"resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
			"integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
			"dependencies": {
				"isexe": "^2.0.0"
			},
			"bin": {
				"node-which": "bin/node-which"
			},
			"engines": {
				"node": ">= 8"
			}
		},
		"node_modules/wide-align": {
			"version": "1.1.3",
			"resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.3.tgz",
			"integrity": "sha512-QGkOQc8XL6Bt5PwnsExKBPuMKBxnGxWWW3fU55Xt4feHozMUhdUMaBCk290qpm/wG5u/RSKzwdAC4i51YigihA==",
			"dependencies": {
				"string-width": "^1.0.2 || 2"
			}
		},
		"node_modules/wide-align/node_modules/ansi-regex": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
			"integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/wide-align/node_modules/is-fullwidth-code-point": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
			"integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/wide-align/node_modules/string-width": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
			"integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
			"dependencies": {
				"is-fullwidth-code-point": "^2.0.0",
				"strip-ansi": "^4.0.0"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/wide-align/node_modules/strip-ansi": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
			"integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
			"dependencies": {
				"ansi-regex": "^3.0.0"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/word-wrap": {
			"version": "1.2.3",
			"resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
			"integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
			"dev": true,
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/workerpool": {
			"version": "6.1.4",
			"resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.1.4.tgz",
			"integrity": "sha512-jGWPzsUqzkow8HoAvqaPWTUPCrlPJaJ5tY8Iz7n1uCz3tTp6s3CDG0FF1NsX42WNlkRSW6Mr+CDZGnNoSsKa7g=="
		},
		"node_modules/wrap-ansi": {
			"version": "7.0.0",
			"resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
			"integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
			"dependencies": {
				"ansi-styles": "^4.0.0",
				"string-width": "^4.1.0",
				"strip-ansi": "^6.0.0"
			},
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/wrap-ansi?sponsor=1"
			}
		},
		"node_modules/wrappy": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
			"integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8="
		},
		"node_modules/y18n": {
			"version": "5.0.8",
			"resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
			"integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/yallist": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
			"integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
			"dev": true
		},
		"node_modules/yargs": {
			"version": "16.2.0",
			"resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
			"integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
			"dependencies": {
				"cliui": "^7.0.2",
				"escalade": "^3.1.1",
				"get-caller-file": "^2.0.5",
				"require-directory": "^2.1.1",
				"string-width": "^4.2.0",
				"y18n": "^5.0.5",
				"yargs-parser": "^20.2.2"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/yargs-parser": {
			"version": "20.2.4",
			"resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
			"integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==",
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/yargs-unparser": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
			"integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
			"dependencies": {
				"camelcase": "^6.0.0",
				"decamelize": "^4.0.0",
				"flat": "^5.0.2",
				"is-plain-obj": "^2.1.0"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/yocto-queue": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
			"integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		}
	},
	"dependencies": {
		"@babel/code-frame": {
			"version": "7.12.11",
			"resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz",
			"integrity": "sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==",
			"dev": true,
			"requires": {
				"@babel/highlight": "^7.10.4"
			}
		},
		"@babel/helper-validator-identifier": {
			"version": "7.14.5",
			"resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.14.5.tgz",
			"integrity": "sha512-5lsetuxCLilmVGyiLEfoHBRX8UCFD+1m2x3Rj97WrW3V7H3u4RWRXA4evMjImCsin2J2YT0QaVDGf+z8ondbAg==",
			"dev": true
		},
		"@babel/highlight": {
			"version": "7.14.5",
			"resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.14.5.tgz",
			"integrity": "sha512-qf9u2WFWVV0MppaL877j2dBtQIDgmidgjGk5VIMw3OadXvYaXn66U1BFlH2t4+t3i+8PhedppRv+i40ABzd+gg==",
			"dev": true,
			"requires": {
				"@babel/helper-validator-identifier": "^7.14.5",
				"chalk": "^2.0.0",
				"js-tokens": "^4.0.0"
			},
			"dependencies": {
				"ansi-styles": {
					"version": "3.2.1",
					"resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
					"integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
					"dev": true,
					"requires": {
						"color-convert": "^1.9.0"
					}
				},
				"chalk": {
					"version": "2.4.2",
					"resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
					"integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
					"dev": true,
					"requires": {
						"ansi-styles": "^3.2.1",
						"escape-string-regexp": "^1.0.5",
						"supports-color": "^5.3.0"
					}
				},
				"color-convert": {
					"version": "1.9.3",
					"resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
					"integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
					"dev": true,
					"requires": {
						"color-name": "1.1.3"
					}
				},
				"color-name": {
					"version": "1.1.3",
					"resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
					"integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
					"dev": true
				},
				"escape-string-regexp": {
					"version": "1.0.5",
					"resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
					"integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
					"dev": true
				},
				"has-flag": {
					"version": "3.0.0",
					"resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
					"integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
					"dev": true
				},
				"supports-color": {
					"version": "5.5.0",
					"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
					"integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
					"dev": true,
					"requires": {
						"has-flag": "^3.0.0"
					}
				}
			}
		},
		"@eslint/eslintrc": {
			"version": "0.4.2",
			"resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.2.tgz",
			"integrity": "sha512-8nmGq/4ycLpIwzvhI4tNDmQztZ8sp+hI7cyG8i1nQDhkAbRzHpXPidRAHlNvCZQpJTKw5ItIpMw9RSToGF00mg==",
			"dev": true,
			"requires": {
				"ajv": "^6.12.4",
				"debug": "^4.1.1",
				"espree": "^7.3.0",
				"globals": "^13.9.0",
				"ignore": "^4.0.6",
				"import-fresh": "^3.2.1",
				"js-yaml": "^3.13.1",
				"minimatch": "^3.0.4",
				"strip-json-comments": "^3.1.1"
			}
		},
		"@ungap/promise-all-settled": {
			"version": "1.1.2",
			"resolved": "https://registry.npmjs.org/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz",
			"integrity": "sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q=="
		},
		"acorn": {
			"version": "7.4.1",
			"resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
			"integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
			"dev": true
		},
		"acorn-jsx": {
			"version": "5.3.1",
			"resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.1.tgz",
			"integrity": "sha512-K0Ptm/47OKfQRpNQ2J/oIN/3QYiK6FwW+eJbILhsdxh2WTLdl+30o8aGdTbm5JbffpFFAg/g+zi1E+jvJha5ng==",
			"dev": true,
			"requires": {}
		},
		"acquit": {
			"version": "1.2.1",
			"resolved": "https://registry.npmjs.org/acquit/-/acquit-1.2.1.tgz",
			"integrity": "sha512-xPBt/p7b0Y5yBj4UTeB5JoxmVAb9LaGWhzr1Bzgt81/yFZ5suPph93b/DcgrZ30ywRrsKz5jXbr8dBzYIoPoQw==",
			"dev": true,
			"requires": {
				"esprima": "4.0.0",
				"marked": "0.7.x"
			}
		},
		"acquit-markdown": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/acquit-markdown/-/acquit-markdown-0.1.0.tgz",
			"integrity": "sha512-mCtIZ2IrEhF/FDPt+KTpdGSFaWtQV6fr0OYg27fR4iKuIWsk2P0c8U2R4AWCH96BNOBh0cNEo35YKqtzQwoOGQ==",
			"dev": true,
			"requires": {
				"commander": "2.13.0"
			}
		},
		"ajv": {
			"version": "6.12.6",
			"resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
			"integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
			"dev": true,
			"requires": {
				"fast-deep-equal": "^3.1.1",
				"fast-json-stable-stringify": "^2.0.0",
				"json-schema-traverse": "^0.4.1",
				"uri-js": "^4.2.2"
			}
		},
		"ansi-colors": {
			"version": "4.1.1",
			"resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
			"integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA=="
		},
		"ansi-regex": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
			"integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg=="
		},
		"ansi-styles": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
			"integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
			"requires": {
				"color-convert": "^2.0.1"
			}
		},
		"anymatch": {
			"version": "3.1.2",
			"resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.2.tgz",
			"integrity": "sha512-P43ePfOAIupkguHUycrc4qJ9kz8ZiuOUijaETwX7THt0Y/GNK7v0aa8rY816xWjZ7rJdA5XdMcpVFTKMq+RvWg==",
			"requires": {
				"normalize-path": "^3.0.0",
				"picomatch": "^2.0.4"
			}
		},
		"argparse": {
			"version": "1.0.10",
			"resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
			"integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
			"dev": true,
			"requires": {
				"sprintf-js": "~1.0.2"
			}
		},
		"astral-regex": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
			"integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
			"dev": true
		},
		"balanced-match": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
			"integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw=="
		},
		"base-x": {
			"version": "3.0.8",
			"resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.8.tgz",
			"integrity": "sha512-Rl/1AWP4J/zRrk54hhlxH4drNxPJXYUaKffODVI53/dAsV4t9fBxyxYKAVPU1XBHxYwOWP9h9H0hM2MVw4YfJA==",
			"dev": true,
			"requires": {
				"safe-buffer": "^5.0.1"
			}
		},
		"binary-extensions": {
			"version": "2.2.0",
			"resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
			"integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA=="
		},
		"bn.js": {
			"version": "5.2.0",
			"resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
			"integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw==",
			"dev": true
		},
		"borsh": {
			"version": "0.6.0",
			"resolved": "https://registry.npmjs.org/borsh/-/borsh-0.6.0.tgz",
			"integrity": "sha512-sl5k89ViqsThXQpYa9XDtz1sBl3l1lI313cFUY1HKr+wvMILnb+58xpkqTNrYbelh99dY7K8usxoCusQmqix9Q==",
			"dev": true,
			"requires": {
				"bn.js": "^5.2.0",
				"bs58": "^4.0.0",
				"text-encoding-utf-8": "^1.0.2"
			}
		},
		"brace-expansion": {
			"version": "1.1.11",
			"resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
			"integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
			"requires": {
				"balanced-match": "^1.0.0",
				"concat-map": "0.0.1"
			}
		},
		"braces": {
			"version": "3.0.2",
			"resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
			"integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
			"requires": {
				"fill-range": "^7.0.1"
			}
		},
		"browser-stdout": {
			"version": "1.3.1",
			"resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
			"integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw=="
		},
		"bs58": {
			"version": "4.0.1",
			"resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
			"integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
			"dev": true,
			"requires": {
				"base-x": "^3.0.2"
			}
		},
		"callsites": {
			"version": "3.1.0",
			"resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
			"integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
			"dev": true
		},
		"camelcase": {
			"version": "6.2.0",
			"resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.2.0.tgz",
			"integrity": "sha512-c7wVvbw3f37nuobQNtgsgG9POC9qMbNuMQmTCqZv23b6MIz0fcYpBiOlv9gEN/hdLdnZTDQhg6e9Dq5M1vKvfg=="
		},
		"capability": {
			"version": "0.2.5",
			"resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
			"integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE=",
			"dev": true
		},
		"chalk": {
			"version": "4.1.1",
			"resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
			"integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
			"requires": {
				"ansi-styles": "^4.1.0",
				"supports-color": "^7.1.0"
			}
		},
		"chokidar": {
			"version": "3.5.1",
			"resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.1.tgz",
			"integrity": "sha512-9+s+Od+W0VJJzawDma/gvBNQqkTiqYTWLuZoyAsivsI4AaWTCzHG06/TMjsf1cYe9Cb97UCEhjz7HvnPk2p/tw==",
			"requires": {
				"anymatch": "~3.1.1",
				"braces": "~3.0.2",
				"fsevents": "~2.3.1",
				"glob-parent": "~5.1.0",
				"is-binary-path": "~2.1.0",
				"is-glob": "~4.0.1",
				"normalize-path": "~3.0.0",
				"readdirp": "~3.5.0"
			}
		},
		"cliui": {
			"version": "7.0.4",
			"resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
			"integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
			"requires": {
				"string-width": "^4.2.0",
				"strip-ansi": "^6.0.0",
				"wrap-ansi": "^7.0.0"
			}
		},
		"color-convert": {
			"version": "2.0.1",
			"resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
			"integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
			"requires": {
				"color-name": "~1.1.4"
			}
		},
		"color-name": {
			"version": "1.1.4",
			"resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
			"integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="
		},
		"commander": {
			"version": "2.13.0",
			"resolved": "https://registry.npmjs.org/commander/-/commander-2.13.0.tgz",
			"integrity": "sha512-MVuS359B+YzaWqjCL/c+22gfryv+mCBPHAv3zyVI2GN8EY6IRP8VwtasXn8jyyhvvq84R4ImN1OKRtcbIasjYA==",
			"dev": true
		},
		"concat-map": {
			"version": "0.0.1",
			"resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
			"integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="
		},
		"cross-spawn": {
			"version": "7.0.3",
			"resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
			"integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
			"dev": true,
			"requires": {
				"path-key": "^3.1.0",
				"shebang-command": "^2.0.0",
				"which": "^2.0.1"
			}
		},
		"debug": {
			"version": "4.3.1",
			"resolved": "https://registry.npmjs.org/debug/-/debug-4.3.1.tgz",
			"integrity": "sha512-doEwdvm4PCeK4K3RQN2ZC2BYUBaxwLARCqZmMjtF8a51J2Rb0xpVloFRnCODwqjpwnAoao4pelN8l3RJdv3gRQ==",
			"requires": {
				"ms": "2.1.2"
			}
		},
		"decamelize": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
			"integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ=="
		},
		"deep-is": {
			"version": "0.1.3",
			"resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
			"integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
			"dev": true
		},
		"depd": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
			"integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
			"dev": true
		},
		"diff": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
			"integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w=="
		},
		"doctrine": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
			"integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
			"dev": true,
			"requires": {
				"esutils": "^2.0.2"
			}
		},
		"emoji-regex": {
			"version": "8.0.0",
			"resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
			"integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A=="
		},
		"enquirer": {
			"version": "2.3.6",
			"resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz",
			"integrity": "sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==",
			"dev": true,
			"requires": {
				"ansi-colors": "^4.1.1"
			}
		},
		"error-polyfill": {
			"version": "0.1.3",
			"resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
			"integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
			"dev": true,
			"requires": {
				"capability": "^0.2.5",
				"o3": "^1.0.3",
				"u3": "^0.1.1"
			}
		},
		"escalade": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
			"integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw=="
		},
		"escape-string-regexp": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
			"integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA=="
		},
		"eslint": {
			"version": "7.29.0",
			"resolved": "https://registry.npmjs.org/eslint/-/eslint-7.29.0.tgz",
			"integrity": "sha512-82G/JToB9qIy/ArBzIWG9xvvwL3R86AlCjtGw+A29OMZDqhTybz/MByORSukGxeI+YPCR4coYyITKk8BFH9nDA==",
			"dev": true,
			"requires": {
				"@babel/code-frame": "7.12.11",
				"@eslint/eslintrc": "^0.4.2",
				"ajv": "^6.10.0",
				"chalk": "^4.0.0",
				"cross-spawn": "^7.0.2",
				"debug": "^4.0.1",
				"doctrine": "^3.0.0",
				"enquirer": "^2.3.5",
				"escape-string-regexp": "^4.0.0",
				"eslint-scope": "^5.1.1",
				"eslint-utils": "^2.1.0",
				"eslint-visitor-keys": "^2.0.0",
				"espree": "^7.3.1",
				"esquery": "^1.4.0",
				"esutils": "^2.0.2",
				"fast-deep-equal": "^3.1.3",
				"file-entry-cache": "^6.0.1",
				"functional-red-black-tree": "^1.0.1",
				"glob-parent": "^5.1.2",
				"globals": "^13.6.0",
				"ignore": "^4.0.6",
				"import-fresh": "^3.0.0",
				"imurmurhash": "^0.1.4",
				"is-glob": "^4.0.0",
				"js-yaml": "^3.13.1",
				"json-stable-stringify-without-jsonify": "^1.0.1",
				"levn": "^0.4.1",
				"lodash.merge": "^4.6.2",
				"minimatch": "^3.0.4",
				"natural-compare": "^1.4.0",
				"optionator": "^0.9.1",
				"progress": "^2.0.0",
				"regexpp": "^3.1.0",
				"semver": "^7.2.1",
				"strip-ansi": "^6.0.0",
				"strip-json-comments": "^3.1.0",
				"table": "^6.0.9",
				"text-table": "^0.2.0",
				"v8-compile-cache": "^2.0.3"
			}
		},
		"eslint-scope": {
			"version": "5.1.1",
			"resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
			"integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
			"dev": true,
			"requires": {
				"esrecurse": "^4.3.0",
				"estraverse": "^4.1.1"
			}
		},
		"eslint-utils": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
			"integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
			"dev": true,
			"requires": {
				"eslint-visitor-keys": "^1.1.0"
			},
			"dependencies": {
				"eslint-visitor-keys": {
					"version": "1.3.0",
					"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
					"integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
					"dev": true
				}
			}
		},
		"eslint-visitor-keys": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz",
			"integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==",
			"dev": true
		},
		"espree": {
			"version": "7.3.1",
			"resolved": "https://registry.npmjs.org/espree/-/espree-7.3.1.tgz",
			"integrity": "sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==",
			"dev": true,
			"requires": {
				"acorn": "^7.4.0",
				"acorn-jsx": "^5.3.1",
				"eslint-visitor-keys": "^1.3.0"
			},
			"dependencies": {
				"eslint-visitor-keys": {
					"version": "1.3.0",
					"resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
					"integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
					"dev": true
				}
			}
		},
		"esprima": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.0.tgz",
			"integrity": "sha512-oftTcaMu/EGrEIu904mWteKIv8vMuOgGYo7EhVJJN00R/EED9DCua/xxHRdYnKtcECzVg7xOWhflvJMnqcFZjw==",
			"dev": true
		},
		"esquery": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz",
			"integrity": "sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==",
			"dev": true,
			"requires": {
				"estraverse": "^5.1.0"
			},
			"dependencies": {
				"estraverse": {
					"version": "5.2.0",
					"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
					"integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
					"dev": true
				}
			}
		},
		"esrecurse": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
			"integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
			"dev": true,
			"requires": {
				"estraverse": "^5.2.0"
			},
			"dependencies": {
				"estraverse": {
					"version": "5.2.0",
					"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
					"integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
					"dev": true
				}
			}
		},
		"estraverse": {
			"version": "4.3.0",
			"resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
			"integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
			"dev": true
		},
		"esutils": {
			"version": "2.0.3",
			"resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
			"integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
			"dev": true
		},
		"fast-deep-equal": {
			"version": "3.1.3",
			"resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
			"integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
			"dev": true
		},
		"fast-json-stable-stringify": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
			"integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
			"dev": true
		},
		"fast-levenshtein": {
			"version": "2.0.6",
			"resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
			"integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
			"dev": true
		},
		"file-entry-cache": {
			"version": "6.0.1",
			"resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
			"integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
			"dev": true,
			"requires": {
				"flat-cache": "^3.0.4"
			}
		},
		"fill-range": {
			"version": "7.0.1",
			"resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
			"integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
			"requires": {
				"to-regex-range": "^5.0.1"
			}
		},
		"find-up": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
			"integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
			"requires": {
				"locate-path": "^6.0.0",
				"path-exists": "^4.0.0"
			}
		},
		"flat": {
			"version": "5.0.2",
			"resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
			"integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ=="
		},
		"flat-cache": {
			"version": "3.0.4",
			"resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
			"integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
			"dev": true,
			"requires": {
				"flatted": "^3.1.0",
				"rimraf": "^3.0.2"
			}
		},
		"flatted": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/flatted/-/flatted-3.1.1.tgz",
			"integrity": "sha512-zAoAQiudy+r5SvnSw3KJy5os/oRJYHzrzja/tBDqrZtNhUw8bt6y8OBzMWcjWr+8liV8Eb6yOhw8WZ7VFZ5ZzA==",
			"dev": true
		},
		"fs.realpath": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
			"integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8="
		},
		"fsevents": {
			"version": "2.3.2",
			"resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
			"integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
			"optional": true
		},
		"functional-red-black-tree": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
			"integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
			"dev": true
		},
		"get-caller-file": {
			"version": "2.0.5",
			"resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
			"integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg=="
		},
		"glob": {
			"version": "7.1.7",
			"resolved": "https://registry.npmjs.org/glob/-/glob-7.1.7.tgz",
			"integrity": "sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==",
			"requires": {
				"fs.realpath": "^1.0.0",
				"inflight": "^1.0.4",
				"inherits": "2",
				"minimatch": "^3.0.4",
				"once": "^1.3.0",
				"path-is-absolute": "^1.0.0"
			}
		},
		"glob-parent": {
			"version": "5.1.2",
			"resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
			"integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
			"requires": {
				"is-glob": "^4.0.1"
			}
		},
		"globals": {
			"version": "13.9.0",
			"resolved": "https://registry.npmjs.org/globals/-/globals-13.9.0.tgz",
			"integrity": "sha512-74/FduwI/JaIrr1H8e71UbDE+5x7pIPs1C2rrwC52SszOo043CsWOZEMW7o2Y58xwm9b+0RBKDxY5n2sUpEFxA==",
			"dev": true,
			"requires": {
				"type-fest": "^0.20.2"
			}
		},
		"growl": {
			"version": "1.10.5",
			"resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
			"integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA=="
		},
		"has-flag": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
			"integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ=="
		},
		"he": {
			"version": "1.2.0",
			"resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
			"integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw=="
		},
		"http-errors": {
			"version": "1.8.0",
			"resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.0.tgz",
			"integrity": "sha512-4I8r0C5JDhT5VkvI47QktDW75rNlGVsUf/8hzjCC/wkWI/jdTRmBb9aI7erSG82r1bjKY3F6k28WnsVxB1C73A==",
			"dev": true,
			"requires": {
				"depd": "~1.1.2",
				"inherits": "2.0.4",
				"setprototypeof": "1.2.0",
				"statuses": ">= 1.5.0 < 2",
				"toidentifier": "1.0.0"
			},
			"dependencies": {
				"depd": {
					"version": "1.1.2",
					"resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
					"integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
					"dev": true
				}
			}
		},
		"ignore": {
			"version": "4.0.6",
			"resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
			"integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
			"dev": true
		},
		"import-fresh": {
			"version": "3.3.0",
			"resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
			"integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
			"dev": true,
			"requires": {
				"parent-module": "^1.0.0",
				"resolve-from": "^4.0.0"
			}
		},
		"imurmurhash": {
			"version": "0.1.4",
			"resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
			"integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
			"dev": true
		},
		"inflight": {
			"version": "1.0.6",
			"resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
			"integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
			"requires": {
				"once": "^1.3.0",
				"wrappy": "1"
			}
		},
		"inherits": {
			"version": "2.0.4",
			"resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
			"integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
		},
		"is-binary-path": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
			"integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
			"requires": {
				"binary-extensions": "^2.0.0"
			}
		},
		"is-extglob": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
			"integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI="
		},
		"is-fullwidth-code-point": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
			"integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg=="
		},
		"is-glob": {
			"version": "4.0.1",
			"resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
			"integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
			"requires": {
				"is-extglob": "^2.1.1"
			}
		},
		"is-number": {
			"version": "7.0.0",
			"resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
			"integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng=="
		},
		"is-plain-obj": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
			"integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA=="
		},
		"is-unicode-supported": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
			"integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw=="
		},
		"isexe": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
			"integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA="
		},
		"js-sha256": {
			"version": "0.9.0",
			"resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
			"integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA==",
			"dev": true
		},
		"js-tokens": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
			"integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
			"dev": true
		},
		"js-yaml": {
			"version": "3.14.1",
			"resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
			"integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
			"dev": true,
			"requires": {
				"argparse": "^1.0.7",
				"esprima": "^4.0.0"
			}
		},
		"json-schema-traverse": {
			"version": "0.4.1",
			"resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
			"integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
			"dev": true
		},
		"json-stable-stringify-without-jsonify": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
			"integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
			"dev": true
		},
		"levn": {
			"version": "0.4.1",
			"resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
			"integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
			"dev": true,
			"requires": {
				"prelude-ls": "^1.2.1",
				"type-check": "~0.4.0"
			}
		},
		"locate-path": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
			"integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
			"requires": {
				"p-locate": "^5.0.0"
			}
		},
		"lodash.clonedeep": {
			"version": "4.5.0",
			"resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
			"integrity": "sha1-4j8/nE+Pvd6HJSnBBxhXoIblzO8=",
			"dev": true
		},
		"lodash.merge": {
			"version": "4.6.2",
			"resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
			"integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
			"dev": true
		},
		"lodash.truncate": {
			"version": "4.4.2",
			"resolved": "https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz",
			"integrity": "sha1-WjUNoLERO4N+z//VgSy+WNbq4ZM=",
			"dev": true
		},
		"log-symbols": {
			"version": "4.1.0",
			"resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
			"integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
			"requires": {
				"chalk": "^4.1.0",
				"is-unicode-supported": "^0.1.0"
			}
		},
		"lru-cache": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
			"integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
			"dev": true,
			"requires": {
				"yallist": "^4.0.0"
			}
		},
		"marked": {
			"version": "0.7.0",
			"resolved": "https://registry.npmjs.org/marked/-/marked-0.7.0.tgz",
			"integrity": "sha512-c+yYdCZJQrsRjTPhUx7VKkApw9bwDkNbHUKo1ovgcfDjb2kc8rLuRbIFyXL5WOEUwzSSKo3IXpph2K6DqB/KZg==",
			"dev": true
		},
		"minimatch": {
			"version": "3.0.4",
			"resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
			"integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
			"requires": {
				"brace-expansion": "^1.1.7"
			}
		},
		"mocha": {
			"version": "9.0.1",
			"resolved": "https://registry.npmjs.org/mocha/-/mocha-9.0.1.tgz",
			"integrity": "sha512-9zwsavlRO+5csZu6iRtl3GHImAbhERoDsZwdRkdJ/bE+eVplmoxNKE901ZJ9LdSchYBjSCPbjKc5XvcAri2ylw==",
			"requires": {
				"@ungap/promise-all-settled": "1.1.2",
				"ansi-colors": "4.1.1",
				"browser-stdout": "1.3.1",
				"chokidar": "3.5.1",
				"debug": "4.3.1",
				"diff": "5.0.0",
				"escape-string-regexp": "4.0.0",
				"find-up": "5.0.0",
				"glob": "7.1.7",
				"growl": "1.10.5",
				"he": "1.2.0",
				"js-yaml": "4.1.0",
				"log-symbols": "4.1.0",
				"minimatch": "3.0.4",
				"ms": "2.1.3",
				"nanoid": "3.1.23",
				"serialize-javascript": "5.0.1",
				"strip-json-comments": "3.1.1",
				"supports-color": "8.1.1",
				"which": "2.0.2",
				"wide-align": "1.1.3",
				"workerpool": "6.1.4",
				"yargs": "16.2.0",
				"yargs-parser": "20.2.4",
				"yargs-unparser": "2.0.0"
			},
			"dependencies": {
				"argparse": {
					"version": "2.0.1",
					"resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
					"integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q=="
				},
				"js-yaml": {
					"version": "4.1.0",
					"resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
					"integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
					"requires": {
						"argparse": "^2.0.1"
					}
				},
				"ms": {
					"version": "2.1.3",
					"resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
					"integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
				},
				"supports-color": {
					"version": "8.1.1",
					"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
					"integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
					"requires": {
						"has-flag": "^4.0.0"
					}
				}
			}
		},
		"ms": {
			"version": "2.1.2",
			"resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
			"integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
		},
		"mustache": {
			"version": "4.2.0",
			"resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
			"integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
			"dev": true
		},
		"nanoid": {
			"version": "3.1.23",
			"resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.1.23.tgz",
			"integrity": "sha512-FiB0kzdP0FFVGDKlRLEQ1BgDzU87dy5NnzjeW9YZNt+/c3+q82EQDUwniSAUxp/F0gFNI1ZhKU1FqYsMuqZVnw=="
		},
		"natural-compare": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
			"integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
			"dev": true
		},
		"near-api-js": {
			"version": "0.44.2",
			"resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.44.2.tgz",
			"integrity": "sha512-eMnc4V+geggapEUa3nU2p8HSHn/njtloI4P2mceHQWO8vDE1NGpnAw8FuTBrLmXSgIv9m6oocgFc9t3VNf5zwg==",
			"dev": true,
			"requires": {
				"bn.js": "5.2.0",
				"borsh": "^0.6.0",
				"bs58": "^4.0.0",
				"depd": "^2.0.0",
				"error-polyfill": "^0.1.3",
				"http-errors": "^1.7.2",
				"js-sha256": "^0.9.0",
				"mustache": "^4.0.0",
				"node-fetch": "^2.6.1",
				"text-encoding-utf-8": "^1.0.2",
				"tweetnacl": "^1.0.1"
			}
		},
		"node-fetch": {
			"version": "2.6.1",
			"resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.1.tgz",
			"integrity": "sha512-V4aYg89jEoVRxRb2fJdAg8FHvI7cEyYdVAh94HH0UIK8oJxUfkjlDQN9RbMx+bEjP7+ggMiFRprSti032Oipxw==",
			"dev": true
		},
		"normalize-path": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
			"integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA=="
		},
		"o3": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
			"integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
			"dev": true,
			"requires": {
				"capability": "^0.2.5"
			}
		},
		"once": {
			"version": "1.4.0",
			"resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
			"integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
			"requires": {
				"wrappy": "1"
			}
		},
		"optionator": {
			"version": "0.9.1",
			"resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
			"integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
			"dev": true,
			"requires": {
				"deep-is": "^0.1.3",
				"fast-levenshtein": "^2.0.6",
				"levn": "^0.4.1",
				"prelude-ls": "^1.2.1",
				"type-check": "^0.4.0",
				"word-wrap": "^1.2.3"
			}
		},
		"p-limit": {
			"version": "3.1.0",
			"resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
			"integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
			"requires": {
				"yocto-queue": "^0.1.0"
			}
		},
		"p-locate": {
			"version": "5.0.0",
			"resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
			"integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
			"requires": {
				"p-limit": "^3.0.2"
			}
		},
		"parent-module": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
			"integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
			"dev": true,
			"requires": {
				"callsites": "^3.0.0"
			}
		},
		"path-exists": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
			"integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w=="
		},
		"path-is-absolute": {
			"version": "1.0.1",
			"resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
			"integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18="
		},
		"path-key": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
			"integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
			"dev": true
		},
		"picomatch": {
			"version": "2.3.0",
			"resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.0.tgz",
			"integrity": "sha512-lY1Q/PiJGC2zOv/z391WOTD+Z02bCgsFfvxoXXf6h7kv9o+WmsmzYqrAwY63sNgOxE4xEdq0WyUnXfKeBrSvYw=="
		},
		"prelude-ls": {
			"version": "1.2.1",
			"resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
			"integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
			"dev": true
		},
		"progress": {
			"version": "2.0.3",
			"resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
			"integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
			"dev": true
		},
		"punycode": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
			"integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
			"dev": true
		},
		"randombytes": {
			"version": "2.1.0",
			"resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
			"integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
			"requires": {
				"safe-buffer": "^5.1.0"
			}
		},
		"readdirp": {
			"version": "3.5.0",
			"resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.5.0.tgz",
			"integrity": "sha512-cMhu7c/8rdhkHXWsY+osBhfSy0JikwpHK/5+imo+LpeasTF8ouErHrlYkwT0++njiyuDvc7OFY5T3ukvZ8qmFQ==",
			"requires": {
				"picomatch": "^2.2.1"
			}
		},
		"regexpp": {
			"version": "3.2.0",
			"resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz",
			"integrity": "sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==",
			"dev": true
		},
		"require-directory": {
			"version": "2.1.1",
			"resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
			"integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I="
		},
		"require-from-string": {
			"version": "2.0.2",
			"resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
			"integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
			"dev": true
		},
		"resolve-from": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
			"integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
			"dev": true
		},
		"rimraf": {
			"version": "3.0.2",
			"resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
			"integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
			"dev": true,
			"requires": {
				"glob": "^7.1.3"
			}
		},
		"safe-buffer": {
			"version": "5.2.1",
			"resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
			"integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
		},
		"semver": {
			"version": "7.3.5",
			"resolved": "https://registry.npmjs.org/semver/-/semver-7.3.5.tgz",
			"integrity": "sha512-PoeGJYh8HK4BTO/a9Tf6ZG3veo/A7ZVsYrSA6J8ny9nb3B1VrpkuN+z9OE5wfE5p6H4LchYZsegiQgbJD94ZFQ==",
			"dev": true,
			"requires": {
				"lru-cache": "^6.0.0"
			}
		},
		"serialize-javascript": {
			"version": "5.0.1",
			"resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-5.0.1.tgz",
			"integrity": "sha512-SaaNal9imEO737H2c05Og0/8LUXG7EnsZyMa8MzkmuHoELfT6txuj0cMqRj6zfPKnmQ1yasR4PCJc8x+M4JSPA==",
			"requires": {
				"randombytes": "^2.1.0"
			}
		},
		"setprototypeof": {
			"version": "1.2.0",
			"resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
			"integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
			"dev": true
		},
		"shebang-command": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
			"integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
			"dev": true,
			"requires": {
				"shebang-regex": "^3.0.0"
			}
		},
		"shebang-regex": {
			"version": "3.0.0",
			"resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
			"integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
			"dev": true
		},
		"slice-ansi": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
			"integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
			"dev": true,
			"requires": {
				"ansi-styles": "^4.0.0",
				"astral-regex": "^2.0.0",
				"is-fullwidth-code-point": "^3.0.0"
			}
		},
		"sprintf-js": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
			"integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
			"dev": true
		},
		"statuses": {
			"version": "1.5.0",
			"resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
			"integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
			"dev": true
		},
		"string-width": {
			"version": "4.2.2",
			"resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz",
			"integrity": "sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==",
			"requires": {
				"emoji-regex": "^8.0.0",
				"is-fullwidth-code-point": "^3.0.0",
				"strip-ansi": "^6.0.0"
			}
		},
		"strip-ansi": {
			"version": "6.0.0",
			"resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
			"integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
			"requires": {
				"ansi-regex": "^5.0.0"
			}
		},
		"strip-json-comments": {
			"version": "3.1.1",
			"resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
			"integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig=="
		},
		"supports-color": {
			"version": "7.2.0",
			"resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
			"integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
			"requires": {
				"has-flag": "^4.0.0"
			}
		},
		"table": {
			"version": "6.7.1",
			"resolved": "https://registry.npmjs.org/table/-/table-6.7.1.tgz",
			"integrity": "sha512-ZGum47Yi6KOOFDE8m223td53ath2enHcYLgOCjGr5ngu8bdIARQk6mN/wRMv4yMRcHnCSnHbCEha4sobQx5yWg==",
			"dev": true,
			"requires": {
				"ajv": "^8.0.1",
				"lodash.clonedeep": "^4.5.0",
				"lodash.truncate": "^4.4.2",
				"slice-ansi": "^4.0.0",
				"string-width": "^4.2.0",
				"strip-ansi": "^6.0.0"
			},
			"dependencies": {
				"ajv": {
					"version": "8.6.0",
					"resolved": "https://registry.npmjs.org/ajv/-/ajv-8.6.0.tgz",
					"integrity": "sha512-cnUG4NSBiM4YFBxgZIj/In3/6KX+rQ2l2YPRVcvAMQGWEPKuXoPIhxzwqh31jA3IPbI4qEOp/5ILI4ynioXsGQ==",
					"dev": true,
					"requires": {
						"fast-deep-equal": "^3.1.1",
						"json-schema-traverse": "^1.0.0",
						"require-from-string": "^2.0.2",
						"uri-js": "^4.2.2"
					}
				},
				"json-schema-traverse": {
					"version": "1.0.0",
					"resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
					"integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
					"dev": true
				}
			}
		},
		"text-encoding-utf-8": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
			"integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg==",
			"dev": true
		},
		"text-table": {
			"version": "0.2.0",
			"resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
			"integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
			"dev": true
		},
		"to-regex-range": {
			"version": "5.0.1",
			"resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
			"integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
			"requires": {
				"is-number": "^7.0.0"
			}
		},
		"toidentifier": {
			"version": "1.0.0",
			"resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.0.tgz",
			"integrity": "sha512-yaOH/Pk/VEhBWWTlhI+qXxDFXlejDGcQipMlyxda9nthulaxLZUNcUqFxokp0vcYnvteJln5FNQDRrxj3YcbVw==",
			"dev": true
		},
		"tweetnacl": {
			"version": "1.0.3",
			"resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
			"integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==",
			"dev": true
		},
		"type-check": {
			"version": "0.4.0",
			"resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
			"integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
			"dev": true,
			"requires": {
				"prelude-ls": "^1.2.1"
			}
		},
		"type-fest": {
			"version": "0.20.2",
			"resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
			"integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
			"dev": true
		},
		"u3": {
			"version": "0.1.1",
			"resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
			"integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w==",
			"dev": true
		},
		"uri-js": {
			"version": "4.4.1",
			"resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
			"integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
			"dev": true,
			"requires": {
				"punycode": "^2.1.0"
			}
		},
		"v8-compile-cache": {
			"version": "2.3.0",
			"resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz",
			"integrity": "sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==",
			"dev": true
		},
		"which": {
			"version": "2.0.2",
			"resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
			"integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
			"requires": {
				"isexe": "^2.0.0"
			}
		},
		"wide-align": {
			"version": "1.1.3",
			"resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.3.tgz",
			"integrity": "sha512-QGkOQc8XL6Bt5PwnsExKBPuMKBxnGxWWW3fU55Xt4feHozMUhdUMaBCk290qpm/wG5u/RSKzwdAC4i51YigihA==",
			"requires": {
				"string-width": "^1.0.2 || 2"
			},
			"dependencies": {
				"ansi-regex": {
					"version": "3.0.0",
					"resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
					"integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
				},
				"is-fullwidth-code-point": {
					"version": "2.0.0",
					"resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
					"integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
				},
				"string-width": {
					"version": "2.1.1",
					"resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
					"integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
					"requires": {
						"is-fullwidth-code-point": "^2.0.0",
						"strip-ansi": "^4.0.0"
					}
				},
				"strip-ansi": {
					"version": "4.0.0",
					"resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
					"integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
					"requires": {
						"ansi-regex": "^3.0.0"
					}
				}
			}
		},
		"word-wrap": {
			"version": "1.2.3",
			"resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
			"integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
			"dev": true
		},
		"workerpool": {
			"version": "6.1.4",
			"resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.1.4.tgz",
			"integrity": "sha512-jGWPzsUqzkow8HoAvqaPWTUPCrlPJaJ5tY8Iz7n1uCz3tTp6s3CDG0FF1NsX42WNlkRSW6Mr+CDZGnNoSsKa7g=="
		},
		"wrap-ansi": {
			"version": "7.0.0",
			"resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
			"integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
			"requires": {
				"ansi-styles": "^4.0.0",
				"string-width": "^4.1.0",
				"strip-ansi": "^6.0.0"
			}
		},
		"wrappy": {
			"version": "1.0.2",
			"resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
			"integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8="
		},
		"y18n": {
			"version": "5.0.8",
			"resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
			"integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA=="
		},
		"yallist": {
			"version": "4.0.0",
			"resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
			"integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
			"dev": true
		},
		"yargs": {
			"version": "16.2.0",
			"resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
			"integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
			"requires": {
				"cliui": "^7.0.2",
				"escalade": "^3.1.1",
				"get-caller-file": "^2.0.5",
				"require-directory": "^2.1.1",
				"string-width": "^4.2.0",
				"y18n": "^5.0.5",
				"yargs-parser": "^20.2.2"
			}
		},
		"yargs-parser": {
			"version": "20.2.4",
			"resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
			"integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA=="
		},
		"yargs-unparser": {
			"version": "2.0.0",
			"resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
			"integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
			"requires": {
				"camelcase": "^6.0.0",
				"decamelize": "^4.0.0",
				"flat": "^5.0.2",
				"is-plain-obj": "^2.1.0"
			}
		},
		"yocto-queue": {
			"version": "0.1.0",
			"resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
			"integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q=="
		}
	}
}

'''
'''--- package.json ---
{
	"name": "near-proxy-linkdrop-contract",
	"version": "1.0.0",
	"license": "MIT",
	"author": "Ben Kurrek, Matt Lockyer",
	"scripts": {
		"deploy": "yarn dev-deploy",
			"dev-deploy": "yarn build-contract && rm -rf neardev && (near dev-deploy || exit 0)",
				"build-contract": "./build.sh",
		"deploy-all": "yarn deploy && yarn simple && yarn ft && yarn nft && yarn fc",
			"deploy-simple": "yarn deploy && yarn simple",
				"simple": "yarn simple-create && yarn simple-add",
					"simple-create": "node deploy/simple/simple-create",
					"simple-add": "node deploy/simple/simple-add",
			"deploy-ft": "yarn deploy && yarn ft",
				"ft": "yarn ft-create && yarn ft-add",
					"ft-create": "node deploy/ft/ft-create",
					"ft-add": "node deploy/ft/ft-add",
			"deploy-nft": "yarn deploy && yarn nft",
				"nft": "yarn nft-create && yarn nft-add",
					"nft-create": "node deploy/nft/nft-create",
					"nft-add": "node deploy/nft/nft-add",
			"deploy-fc": "yarn deploy && yarn fc",
				"fc": "yarn fc-create && yarn fc-add",
					"fc-create": "node deploy/function-call/fc-create",
					"fc-add": "node deploy/function-call/fc-add"
	},
	"dependencies": {},
	"devDependencies": {
		"near-api-js": "^0.44.2"
	}
}
'''