*GitHub Repository "mikedotexe/near-evm-relayer"*

'''--- README.md ---
Relayer for NEAR EVM
===

This repository is for a simple web server that will take incoming requests that are signed using [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and route them properly to the NEAR EVM contract.

    npm i
    node index.js

'''
'''--- eip-712-helpers.js ---
// Taken largely from:
// https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.js
// Thank you @PaulRBerg

const ethUtil = require('ethereumjs-util');
const abi = require('ethereumjs-abi');

// Recursively finds all the dependencies of a type
function dependencies(types, primaryType, found = []) {
    if (found.includes(primaryType)) {
        return found;
    }
    if (types[primaryType] === undefined) {
        return found;
    }
    found.push(primaryType);
    for (let field of types[primaryType]) {
        for (let dep of dependencies(field.type, found)) {
            if (!found.includes(dep)) {
                found.push(dep);
            }
        }
    }
    return found;
}

function encodeType(typedData, primaryType) {
    const types = typedData.types;
    // Get dependencies primary first, then alphabetical
    let deps = dependencies(types, primaryType);
    deps = deps.filter(t => t !== primaryType);
    deps = [primaryType].concat(deps.sort());

    // Format as a string with fields
    let result = '';
    for (let type of deps) {
        result += `${type}(${types[type].map(({ name, type }) => `${type} ${name}`).join(',')})`;
    }
    return result;
}

function typeHash(typedData, primaryType) {
    return ethUtil.keccak256(Buffer.from(encodeType(typedData, primaryType)));
}

function encodeData(typedData, primaryType, data) {
    const types = typedData.types;
    let encTypes = [];
    let encValues = [];

    // Add typehash
    encTypes.push('bytes32');
    encValues.push(typeHash(typedData, primaryType));

    // Add field contents
    for (let field of types[primaryType]) {
        let value = data[field.name];
        if (field.type === 'string' || field.type === 'bytes') {
            encTypes.push('bytes32');
            value = ethUtil.keccak256(Buffer.from(value));
            encValues.push(value);
        } else if (types[field.type] !== undefined) {
            encTypes.push('bytes32');
            value = ethUtil.keccak256(encodeData(typedData, field.type, value));
            encValues.push(value);
        } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw 'TODO: Arrays currently unimplemented in encodeData';
        } else {
            encTypes.push(field.type);
            encValues.push(value);
        }
    }

    return abi.rawEncode(encTypes, encValues);
}

function structHash(typedData, primaryType, data) {
    return ethUtil.keccak256(encodeData(typedData, primaryType, data));
}

const signHash = function(typedData) {
    /*
      bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01", DOMAIN_SEPARATOR,
            hash(req)
        ));
     */
    return ethUtil.keccak256(
        Buffer.concat([
            Buffer.from('1901', 'hex'),
            structHash(typedData, 'EIP712Domain', typedData.domain),
            structHash(typedData, typedData.primaryType, typedData.message),
        ]),
    );
};

module.exports = { signHash };

'''
'''--- index.js ---
const express = require('express');
const cors = require('cors');
const { NearProvider, utils } = require('near-web3-provider');
const nearAPI = require('near-api-js');
const { ecrecover, isValidSignature, pubToAddress, bufferToHex } = require('ethereumjs-util');
const { signHash } = require('./eip-712-helpers');
const web3 = require('web3');
// demonstration of using compiled wasm
const { add_wasm_by_example_to_string } = require('./rust/pkg/near_relayer_utils');

const app = express();
const port = 3000;

let bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// demonstration of using compiled wasm
const runWasm = async () => {
  const helloString = add_wasm_by_example_to_string("Hello from ");
  console.log(helloString);
};
runWasm();

const NEAR_LOCAL_ACCOUNT_ID = 'relayer.test.near';
const NEAR_LOCAL_NETWORK_ID = 'default';
const NEAR_LOCAL_URL = 'http://34.82.212.1:3030';
// const NEAR_EXPLORER_URL = 'https://explorer.testnet.near.org';
const NEAR_LOCAL_EVM = 'evm';

const nearConfig = {
  networkId: NEAR_LOCAL_NETWORK_ID,
  nodeUrl: NEAR_LOCAL_URL,
  contractName: NEAR_LOCAL_ACCOUNT_ID,
  walletUrl: '',
  helperUrl: ''
};

let keyStore;
let near;
let nearAccount;

// keystore
const createNearKeystoreObj = async () => {
  let privateKey = '5oN3D5kCwCwFjeGGQesEmBeR12puYxrYP12yBsEm8sdNsjaogXk9aKrUWrDBxyvaNNj75ySRd6c3GXT8nyY33CSo';
  const ks = new nearAPI.keyStores.InMemoryKeyStore();
  const keyPair = nearAPI.KeyPair.fromString(privateKey)
  await ks.setKey('default', 'relayer.test.near', keyPair);
  return ks;
}
const getNearKeyStore = async () => {
  return keyStore || await createNearKeystoreObj();
}

// near
const createNearObj = async () => {
  const ks = await getNearKeyStore();
  // TODO: probably remove deps here
  return await nearAPI.connect(Object.assign({ deps: { ks }, keyStore: ks }, nearConfig))
}
const getNear = async () => {
  return near || await createNearObj();
}

// account
const createNearAccountObj = async () => {
  const n = await getNear();
  if (n) {
    return await n.account(NEAR_LOCAL_ACCOUNT_ID);
  } else {
    console.error('Could not get NEAR object'); // need this?
  }
}
const getNearAccount = async () => {
  return nearAccount || await createNearAccountObj();
}

function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
}

app.use(cors())

app.post('/', async function(req, res){
  console.log('req.body', req.body);

  // get caller
  const typedData = req.body.data;
  if (!isJson(typedData)) {
    throw new Error('POST body\'s data is not valid JSON');
  }
  const jsonTypedData = JSON.parse(typedData);
  console.log('jsonTypedData', jsonTypedData);
  const hash = signHash(jsonTypedData);
  const signature = {
    v: req.body.signature.v,
    r: Buffer.from(req.body.signature.r.substr(2), 'hex'),
    s: Buffer.from(req.body.signature.s.substr(2), 'hex')
  }
  console.log('signature', signature);
  if (!isValidSignature(signature.v, signature.r, signature.s)) {
    throw new Error('Received invalid signature.');
  }
  const publicKey = ecrecover(hash, signature.v, signature.r, signature.s);
  const addrBuf = pubToAddress(publicKey);
  const recoveredAddress = bufferToHex(addrBuf);
  console.log('recovered Ethereum address', recoveredAddress);

  const account = await getNearAccount();
  console.log(`Current NEAR account ${account.accountId} becomes…`);
  const accountEvmAddress = utils.nearAccountToEvmAddress(account.accountId);
  console.log('accountEvmAddress', accountEvmAddress);

  // Why doesn't this work?
  // console.log('Getting nonce for that account…');

  // hardcoded for counter.test.near
  // we can try doing super simple calls/view like "increment" and "get_num" respectively
  // const counterEvmAddress = '0xe45c4034a989e1a4ce9207e312f71e783e019eb9';
  // const counterAddressArg = Buffer.from(counterEvmAddress.substr(2), 'hex');

  // remove the '0x' and hex encode
  // account's evm address turned into expected 20 bytes
  // See "AddressArg" in nearcore/runtime/near-evm-runner/src/lib.rs
  // const addressArg = Buffer.from(accountEvmAddress.substr(2), 'hex');

  // In another Rust project Borsh serialized this:
  /*
  ViewCallArgs{
      sender: [60, 58, 79, 182, 43, 188, 16, 177, 146, 235, 112, 195, 121, 111, 0, 161, 24, 150, 86, 28],
      address: [60, 58, 79, 182, 43, 188, 16, 177, 146, 235, 112, 195, 121, 111, 0, 161, 24, 150, 86, 28],
      amount: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      args: vec![],
  };
   */
  // where the arrays are a mixture of using Node repl and dtool's h2a
  // I honestly think we may need to include Borsh macros in the nearcore repo?

  // try {
  //   let nonceResult = await account.viewFunction(
  //     NEAR_LOCAL_EVM,
  //     'get_nonce',
  //     {
  //       args: [228, 92, 64, 52, 169, 137, 225, 164, 206, 146, 7, 227, 18, 247, 30, 120, 62, 1, 158, 185]
  //     },
  //   );
  //   console.log('nonceResult', nonceResult);
  // } catch (e) {
  //   console.error(e.message);
  //   throw e;
  // }

  // Figure out RLP encoded thing or whatever is needed, bytes-wise
  // in nearcore/runtime/near-evm-runner/src/lib.rs ("evm-precompile" branch)

  // await account.functionCall(
  //   NEAR_LOCAL_EVM,
  //   'meta_call_function', // or just "meta_call"?
  //   {
  //     symbol: tokenSearch,
  //     spec_id: "ZDJjOWY5MjE4N2YyNGVjMDk1N2NmNTAyMGMwN2FmZGE="
  //   },
  //   '300000000000000'
  // )

  res.sendStatus(200);
})

app.listen(port, () => {
  console.log(`NEAR EVM relay started at http://localhost:${port}`);
})

'''
'''--- package.json ---
{
  "name": "evm-relayer",
  "version": "0.0.1",
  "description": "Relayer for metatransactions and other transactions going to the NEAR EVM",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "blockchain",
    "nearprotocol",
    "ethereum",
    "relayer"
  ],
  "author": "Mike Purvis",
  "license": "MIT",
  "dependencies": {
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "ethereumjs-abi": "^0.6.8",
    "ethereumjs-util": "^7.0.5",
    "express": "^4.17.1",
    "install": "^0.13.0",
    "near-api-js": "^0.30.0",
    "near-web3-provider": "near/near-web3-provider#precompile",
    "npm": "^6.14.8",
    "web3": "^1.2.11",
    "web3-eth-personal": "^1.3.0"
  },
  "devDependencies": {
    "@babel/core": "^7.11.6",
    "@babel/node": "^7.10.5",
    "@babel/preset-env": "^7.11.5"
  }
}

'''
'''--- rust/Cargo.toml ---
[package]
name = "near-relayer-utils"
description = "Rust utilities used by the NodeJS relayer for the NEAR EVM"
version = "0.0.1"
license = "Apache-2.0"
repository = ""
authors = ["Mike Purvis <mike@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2.68"
parity-bytes = "0.1.2"
libsecp256k1 = "0.3.5"
ethereum-types = "0.9.2" # "0.6.0"
keccak-hash = "0.5.1"

[package.metadata.wasm-pack.profile.release]
wasm-opt = false

'''
'''--- rust/README.md ---
NEAR EVM Relayer Utils
===

This directory (`/rust`) contains a Rust project that may be used by NodeJS.

Usage:

    cargo install wasm-pack
    wasm-pack build --target nodejs

'''
'''--- rust/src/lib.rs ---
// The wasm-pack uses wasm-bindgen to build and generate JavaScript binding file.
// Import the wasm-bindgen crate.
use wasm_bindgen::prelude::*;
use ethereum_types::{H256};
use parity_bytes::BytesRef;
use keccak_hash::keccak256;
use std::{
  cmp::{min}
};

// Our function to concatenate the string "Wasm by Example"
// to the input string. We are using .into(), to convert
// the rust types of str to a String.
#[wasm_bindgen]
pub fn add_wasm_by_example_to_string(input_string: String) -> String {
  let result = format!("{} {}", input_string, "Wasm by Example");
  return result.into();
}

#[wasm_bindgen]
pub fn test() -> String {
  let mut bytes = vec![];
  let mut output = BytesRef::Flexible(&mut bytes);
  let mike = EcRecover{};
  // mike.execute()
  "hi".to_string()
}

/** the following is copied from ethcore/src/builtin.rs **/

// Copyright 2015-2019 Parity Technologies (UK) Ltd.
// This file is part of Parity Ethereum.

// Parity Ethereum is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Ethereum is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Ethereum.  If not, see <http://www.gnu.org/licenses/>.

/// Execution error.
#[derive(Debug)]
pub struct Error(pub &'static str);

// impl From<&'static str> for Error {
//   fn from(val: &'static str) -> Self {
//     Error(val)
//   }
// }
//
// impl Into<vm::Error> for Error {
//   fn into(self) -> ::vm::Error {
//     vm::Error::BuiltIn(self.0)
//   }
// }

#[derive(Debug)]
struct EcRecover;

impl EcRecover {
  fn execute(&self, i: &[u8], output: &mut BytesRef) -> Result<(), Error> {
    let len = min(i.len(), 128);

    let mut input = [0; 128];
    input[..len].copy_from_slice(&i[..len]);

    let hash = secp256k1::Message::parse(&H256::from_slice(&input[0..32]).0);
    let v = &input[32..64];
    let r = &input[64..96];
    let s = &input[96..128];

    let bit = match v[31] {
      27..=30 => v[31] - 27,
      _ => { return Ok(()); },
    };

    let mut sig = [0u8; 64];
    sig[..32].copy_from_slice(&r);
    sig[32..].copy_from_slice(&s);
    let s = secp256k1::Signature::parse(&sig);

    if let Ok(rec_id) = secp256k1::RecoveryId::parse(bit) {
      if let Ok(p) = secp256k1::recover(&hash, &s, &rec_id) {
        // recover returns the 65-byte key, but addresses come from the raw 64-byte key
        // let r = keccak256(&mut p.serialize()[1..]);
        let r = &mut p.serialize()[1..];
        keccak256(r);
        output.write(0, &[0; 12]);
        // TODO why
        output.write(12, &r[12..]);
      }
    }

    Ok(())
  }
}

'''