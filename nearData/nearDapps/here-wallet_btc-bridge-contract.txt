*GitHub Repository "here-wallet/btc-bridge-contract"*

'''--- README.md ---
BTC Bridge contract
=====

## How to use bridge

как получить NEAR за BTC
0. Init accounts
```
NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near storage_deposit '{}' --gas 150000000000000 --deposit 0.1  --accountId bridge.mydev.near 

NEAR_ENV=mainnet near call v1.orderbook.near storage_deposit '{}' --gas 242794783120800 --deposit 0.01  --accountId mydev.near

NEAR_ENV=mainnet near call wrap.near near_deposit '{}'  --deposit 0.01  --gas 242794783120800 --accountId mydev.near
```
1. create a transfer request with a random `request_id` of 8 characters
```bash
NEAR_ENV=mainnet near call  bridge.mydev.near  create_request '{"request_id":"fh9032gh905", "btc_amount": "10000"}' --accountId mydev.near  --gas 242794783120800
```
2. Every 3s we check the requests 
```
NEAR_ENV=mainnet near view bridge.mydev.near get_request '{"request_id":"fh9032gh905"}'
```
3. as soon as `target_btc_address` comes in the response, show it
4. regularly check your balance in btc with the command
```
NEAR_ENV=mainnet near view 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near ft_balance_of '{"account_id":"mydev.near"}'  
```
5. balance is positive - it means bitcoin came, now you need to sell it to get NEAR
```
NEAR_ENV=mainnet near call a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near ft_transfer_call '{"receiver_id": "v1.orderbook.near", "amount": "1", "msg": "{market_id: \"2UmzUXYpaZg4vXfFVmD7r8mYUYkKEF19xpjLw7ygDUwp\", side: \"Buy\", amount_in: \"10\", min_amount_out: \"1\"}"}' --accountId mydev.near --depositYocto 1 --gas 300000000000000

```

6. Greate! We've got the nir, only it's a wrapped. Let's unwrapped him
```
NEAR_ENV=mainnet near call wrap.near near_withdraw '{"amount":"1000"}'  --depositYocto 1 --gas 242794783120800 --accountId mydev.near
```

-------

Mainnet contract ID: `bridge.mydev.near`

'''
'''--- contract/Cargo.toml ---
[package]
name = "here_btc_bridge"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"
serde = "1.0.36"
log = "0.4.16"
serde_json = "1.0"

# [dev-dependencies]
# near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, PanicOnDefault, Promise, PromiseOrValue,
    PromiseResult,
};
use serde::{Deserialize, Serialize};

macro_rules! owner {
    // using a ty token type for macthing datatypes passed to maccro
    ($self:expr) => {
        assert_eq!(
            $self.owner_id,
            env::predecessor_account_id(),
            "Avilible only for owner"
        );
    };
}

static WBTC_CONTRACT_ID: &str = "2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near";
static HOUR: u64 = 3_600_000_000_000;
static MIN_BTC_AMOUN: u128 = 1000; // ~ 3 USD
static MAX_BTC_AMOUN: u128 = 1000000; // ~ 300 USD

static FT_TRANSFER_GAS: u64 = 25_000_000_000_000;
static CALLBACK_GAS: u64 = 25_000_000_000_000;
static TRANSACTION_COMISSION: u128 = 10_000_000_000_000_000_000_000;

#[ext_contract(ext_sp)]
pub trait WrappedBTC {
    fn ft_transfer(
        &self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> U128;
}

#[ext_contract(ext_self)]
pub trait MyContract {
    fn send_wbtc_callback(&self, request_id: String);
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct SwapRequest {
    account_id: AccountId,
    target_btc_address: Option<String>,
    btc_amount: u128,
    deposit: u128,
    active_before_time: u64,
}

#[derive(Serialize, Deserialize)]
pub struct SwapRequestOut {
    target_btc_address: Option<String>,
    btc_amount: U128,
    active_before_time: u64,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
    available_btc_amount: u128,
    requests: UnorderedMap<String, SwapRequest>, // account id: (apy, last pay ts, min_balance)
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id: owner_id,
            available_btc_amount: 0,
            requests: UnorderedMap::new(b"a".to_vec()),
        }
    }

    pub fn change_owner(&mut self, new_owner_id: ValidAccountId) {
        owner!(self);
        self.owner_id = new_owner_id.into();
        env::log("Owner changed".as_bytes());
    }

    pub fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            env::predecessor_account_id(),
            WBTC_CONTRACT_ID,
            "This is not wBTC contract"
        );

        self.available_btc_amount += amount.0;
        env::log(format!("Add {} wBTC from {}: {}", amount.0, sender_id, msg).as_bytes());
        PromiseOrValue::Value(U128(0))
    }

    // #[payable]
    pub fn create_request(&mut self, request_id: String, btc_amount: U128) {
        assert!(
            btc_amount.0 >= MIN_BTC_AMOUN,
            "Min transaction is 0.001 BTC"
        );

        // assert!(
        //     env::attached_deposit() >= btc_amount.0 * 30_000_000_000_000_000_000, // 5% from target btc amount
        //     "Not enought balance to create account, deposit shoud be more then 3% of requested balance"
        // );

        assert!(btc_amount.0 <= MAX_BTC_AMOUN, "Max transaction is 0.01 BTC");

        if let Some(new_balance) = self.available_btc_amount.checked_sub(btc_amount.0) {
            self.available_btc_amount = new_balance;
        } else {
            env::panic("The account doesn't have enough balance".as_bytes());
        }
        assert!(
            self.requests.get(&request_id).is_none(),
            "Request with this ID alreasy exist"
        );

        self.requests.insert(
            &request_id,
            &SwapRequest {
                account_id: env::predecessor_account_id(),
                btc_amount: btc_amount.0,
                active_before_time: 0,
                deposit: env::attached_deposit() - TRANSACTION_COMISSION,
                target_btc_address: None,
            },
        );
    }

    pub fn get_requests(&self) -> Vec<(String, SwapRequestOut)> {
        let mut resp: Vec<(String, SwapRequestOut)> = Vec::new();
        for el in self.requests.to_vec() {
            resp.push((
                el.0,
                SwapRequestOut {
                    target_btc_address: el.1.target_btc_address,
                    btc_amount: U128(el.1.btc_amount),
                    active_before_time: el.1.active_before_time,
                },
            ));
        }
        resp
    }

    pub fn get_request(&self, request_id: String) -> Option<SwapRequestOut> {
        let resp = self.requests.get(&request_id);
        if resp.is_none(){
            None
        }
        else{
            let sr = resp.unwrap();
            Some(SwapRequestOut {
                target_btc_address: sr.target_btc_address,
                btc_amount: U128(sr.btc_amount),
                active_before_time: sr.active_before_time,
            })
        }
    }

    pub fn available_btc(&self) -> U128 {
        U128(self.available_btc_amount)
    }

    pub fn activate_request(&mut self, request_id: String, target_btc_address: String) {
        owner!(self);
        let mut bid = self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic("Request not found".as_bytes()));
        assert!(
            bid.target_btc_address.is_none(),
            "Request already activeted"
        );
        bid.target_btc_address = Some(target_btc_address);
        bid.active_before_time = env::block_timestamp() + HOUR;
        self.requests.insert(&request_id, &bid);
    }

    pub fn complete_request(&mut self, request_id: String) -> Promise {
        owner!(self);
        let bid = self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic("Request not found".as_bytes()));

        let account_id = bid.account_id.clone();

        ext_sp::ft_transfer(
            bid.account_id,
            U128(bid.btc_amount),
            None,
            "".to_string(),
            &WBTC_CONTRACT_ID,
            1,
            FT_TRANSFER_GAS,
        )
        .then(ext_self::send_wbtc_callback(
            request_id,
            &env::current_account_id(),
            0,
            CALLBACK_GAS,
        ))
        .then(Promise::new(account_id).transfer(bid.deposit))
    }

    pub fn close_request(&mut self, request_id: String) {
        let bid = self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic("Request not found".as_bytes()));

        if self.owner_id == env::predecessor_account_id() {
            assert!(
                bid.active_before_time < env::block_timestamp(),
                "U cant close request before {}",
                bid.active_before_time
            );
        } else {
            assert!(
                env::predecessor_account_id() == bid.account_id,
                "U cant close not ur request {}",
                bid.active_before_time
            );
        }

        self.requests.remove(&request_id);
        self.available_btc_amount += bid.btc_amount;
    }

    #[private]
    pub fn send_wbtc_callback(&mut self, request_id: String) {
        assert_eq!(env::promise_results_count(), 1, "This is a callback method");

        // handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => env::panic("oops!".as_bytes()),
            PromiseResult::Successful(_result) => {
                self.requests.remove(&request_id);
            }
        }
    }
}

'''
'''--- scripts/buy nwrap.sh ---
NEAR_ENV=mainnet near call wrap.near near_deposit '{}'  --deposit 10  --gas 242794783120800 --accountId mydev.near
NEAR_ENV=mainnet near call wrap.near near_withdraw '{"amount":"1000"}'  --depositYocto 1 --gas 242794783120800 --accountId mydev.near

NEAR_ENV=mainnet near call wrap.near ft_transfer_call '{"receiver_id":"v2.ref-finance.near", "amount": "10000000000000000000000000", "msg": "{\"force\":0,\"actions\":[{\"pool_id\":974,\"token_in\":\"wrap.near\",\"token_out\":\"2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near\",\"amount_in\":\"1000000000000000000000000\",\"min_amount_out\":\"0\"}]}" }'  --gas 242794783120800  --depositYocto 1 --accountId mydev.near

NEAR_ENV=mainnet near view v2.ref-finance.near get_pool '{"pool_id":974}' 

NEAR_ENV=mainnet near call v2.ref-finance.near swap '{"actions":[{"pool_id": 974, "token_in":"wrap.near", "token_out": "2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near", "min_amount_out": "0", "amount_in": "1000000000000000000000000"}]}' --gas 242794783120800 --accountId mydev.near

NEAR_ENV=mainnet near call v2.ref-finance.near register_tokens '{"token_ids":["wrap.near", "2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near"]}' --gas 242794783120800  --depositYocto 1 --accountId mydev.near

    NEAR_ENV=mainnet near call v2.ref-finance.near storage_deposit '{}' --gas 242794783120800 --deposit 0.01  --accountId mydev.near 

NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near storage_deposit '{}' --gas 242794783120800 --deposit 0.01  --accountId mydev.near 

-----

near call ${AID}  new '{"owner_id":"petr4.testnet"}' --accountId petr4.testnet  --gas 242794783120800 

near call ${AID}  create_request '{"request_id":"12", "btc_amount": "100000"}' --accountId petr4.testnet  --gas 242794783120800 
near call ${AID}  activate_request '{"request_id":"12", "target_btc_adress": "8gd89gf89289f8g289"}' --accountId petr4.testnet  --gas 242794783120800 
near call ${AID}  close_request '{"request_id":"12"}' --accountId petr4.testnet  --gas 242794783120800 
near view ${AID}  get_requests '{}'

bridge.mydev.near
NEAR_ENV=mainnet near depoly bridge.mydev.near 
NEAR_ENV=mainnet near view bridge.mydev.near available_btc ''
NEAR_ENV=mainnet near view bridge.mydev.near get_requests ''
NEAR_ENV=mainnet near view bridge.mydev.near get_request '{"request_id":"fh9032gh905"}'
NEAR_ENV=mainnet near call  bridge.mydev.near  new '{"owner_id":"mydev.near"}' --accountId mydev.near  --gas 242794783120800 

NEAR_ENV=mainnet near call  bridge.mydev.near  create_request '{"request_id":"fh9032gh905", "btc_amount": "10000"}' --accountId mydev.near  --gas 242794783120800 
NEAR_ENV=mainnet near call  bridge.mydev.near  activate_request '{"request_id":"1", "target_btc_address": "bc1q7gx8stgvhejcc7ppwfndarthtegqkhca0d8zwm"}' --accountId mydev.near  --gas 242794783120800 

NEAR_ENV=mainnet near call  bridge.mydev.near  complete_request '{"request_id":"1"}' --accountId mydev.near  --gas 242794783120800 
NEAR_ENV=mainnet near call  bridge.mydev.near  close_request '{"request_id":"1"}' --accountId mydev.near  --gas 242794783120800 

NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near ft_transfer_call '{"receiver_id":"bridge.mydev.near", "amount": "6903", "msg": "" }'  --gas 242794783120800  --depositYocto 1 --accountId mydev.near
NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near ft_transfer_call '{"receiver_id":"bridge.mydev.near", "amount": "27775", "msg": "" }'  --gas 242794783120800  --depositYocto 1 --accountId bridge.mydev.near
NEAR_ENV=mainnet near view 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near ft_balance_of '{"account_id":"bridge.mydev.near"}'  
NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near storage_deposit '{}' --gas 150000000000000 --deposit 0.1  --accountId bridge.mydev.near 

NEAR_ENV=mainnet near call 2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near ft_transfer_call '{"receiver_id":"v2.ref-finance.near", "amount": "10000", "msg": "{\"force\":0,\"actions\":[{\"pool_id\":974,\"token_in\":\"2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near\",\"token_out\":\"wrap.near\",\"amount_in\":\"10000\",\"min_amount_out\":\"0\"}]}" }'  --gas 242794783120800  --depositYocto 1 --accountId mydev.near

'''