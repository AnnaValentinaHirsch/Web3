*GitHub Repository "Meta-Pool/liquid-staking-contract"*

'''--- .vscode/launch.json ---
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'metapool'",
            "cargo": {
                "args": [
                    "+nightly",
                    "test"
                ],
                /*"filter": {
                    "name": "meta-pool",
                    "kind": "lib"
                }
                */
            },
            "cwd": "${workspaceFolder}"
        },
        {
            "name": "Debug Simulation Tests",
            "type": "lldb",
            "request": "launch",
            "args": [],
            "env": {"CARGO_MANIFEST_DIR":"${workspaceFolder}/metapool"},
            "program": "target/debug/deps/sim-165a134e5a65691f",
            "cwd": "${workspaceFolder}",
            "stopOnEntry": false,
            "sourceLanguages": [
              "rust"
            ]
        },
        {
            "name": "Run Simulation Tests",
            "type": "lldb",
            "request": "launch",
            "args": [],
            "program": "target/debug/deps/tests-78512ce406ce79d4",
            "cwd": "${workspaceFolder}",
            "stopOnEntry": false,
            "sourceLanguages": [
              "rust"
            ]
        }
    ]
}
'''
'''--- .vscode/settings.json ---
{
    "cSpell.words": [
        "accum",
        "accums",
        "bindgen",
        "borsh",
        "cdylib",
        "cliconfig",
        "codegen",
        "cpath",
        "Csvg",
        "do_rebal_usntk",
        "evenodd",
        "ftmd",
        "funtok",
        "gspru",
        "ITUC",
        "lockupy",
        "metapool",
        "metas",
        "metastaking",
        "MILLI",
        "mult",
        "multifuntok",
        "nanos",
        "nslp",
        "nspl",
        "ntoy",
        "poolv",
        "quickcheck",
        "rebal",
        "rebalance",
        "rebalances",
        "rebalancing",
        "restake",
        "restaked",
        "restaking",
        "rlib",
        "rustc",
        "Seedable",
        "shld",
        "simtest",
        "stak",
        "staker",
        "stakers",
        "stnear",
        "TGAS",
        "unregister",
        "unstake",
        "UNSTAKE",
        "unstaked",
        "unstakers",
        "unstakes",
        "unstaking",
        "unstk",
        "usntk",
        "vloan",
        "WITHD",
        "yocto",
        "yoctos",
        "ytof",
        "yton"
    ]
}
'''
'''--- .vscode/tasks.json ---
{
	"version": "2.0.0",

	"tasks": [

		{
			"label": "build WASM",
			"type": "shell",
			"command": "bash build.sh",
			"problemMatcher": [
				"$rustc"
			],
			"group": {
				"kind": "build",
				"isDefault": true,
			},
		},

		{
			"label": "only cargo test -- --nocapture",
			"type": "shell",
			"command": "clear && cargo +nightly test",
			"problemMatcher": [
				"$rustc"
			],
		},

		{
			"type": "shell",
			"label": "simulation test",
			"command": "clear && cd metapool && bash test.sh",
			"problemMatcher": [
				"$rustc"
			],
			"group": {
				"kind": "test",
				"isDefault": true,
			},
			"dependsOn":["build WASM"]
		}
	]
}

'''
'''--- CHANGELOG.md ---
### Change Log

#### `2.0.5` - 2023-08-05

- FIX: Generate less logs (avoid ExecutionError: "The number of logs will exceed the limit 100")

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "metapool",
    "test-core-staking-pool",
    "test-get-epoch-contract",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[patch.crates-io]
parity-secp256k1 = { git = 'https://github.com/paritytech/rust-secp256k1.git' }

'''
'''--- LICENSE.md ---
Copyright Metapool.app 2020. All rights reserved.
 
You acknowledge and agree that Narwallets.com own all legal right, title and interest in and to the work, software, application, source code, documentation and any other documents in this repository (collectively, the “Program”), including any intellectual property rights which subsist in the Program (whether those rights happen to be registered or not, and wherever in the world those rights may exist), whether in source code or any other form.
 
Subject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy, modify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise attempt to extract the source code of, the Program or any part thereof, except that you may contribute to this repository.
 
You are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify, merge, combine with another program or create derivative works of the Program (such resulting program, collectively, the “Resulting Program”) solely for Non-Commercial Use as long as you:
 1. give prominent notice (“Notice”) with each copy of the Resulting Program that the Program is used in the Resulting Program and that the Program is the copyright of Narwallets.com; and
 2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith, combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial Use restriction set forth herein.
 3. Keep intact the developers' fee distribution mechanism directed to the NEAR account `developers.near`
 
“Non-Commercial Use” means each use as described in clauses (1)-(3) below, as reasonably determined by Narwallets.com in its sole discretion: 
 1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each case without any anticipated commercial application;
 2. use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization or government institution; or
 3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally do not exceed 500 at any time.
 
You will not use any trade mark, service mark, trade name, logo of Narwallets or any other company or organization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks, names or logos.
 
If you have any questions, comments or interest in pursuing any other use cases, please reach out to us at hello@narwallets.com

For commercial use you can obtain a commercial license from us. The general terms of the commercial license are to ensure you mantain a fair developers' fee mechanism on your commercial use of the software.

'''
'''--- README.md ---
# Meta Pool DAO
# NEAR Blockchain Implementation

## Overview
What is Meta-Pool and other non-Technical Documentation

* [Meta Pool Docs](https://docs.metapool.app)

## Audits
* [BlockSec Audit v1.1, March 1th, 2022](https://www.metapool.app/MetaPool_BlockSec_Audit_signed_v1.1.pdf)
* [BlockSec Audit, staking wNEAR with Meta Pool on Aurora, March 20th, 2022](https://370551154-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MkhZe3MGAhTcvTLTzJF-887967055%2Fuploads%2FXE1zBF4pyaWCoR1zlKwW%2Fmain_signed.pdf?alt=media&token=5068e60d-2905-4d4f-a1cb-9d5fa4c607a3)

## Technical Documentation
* [Technical Notes](https://narwallets.github.io/meta-pool/technical-notes)

* [NEAR Live Contract Review (video)](https://www.youtube.com/watch?v=4gB-6yoas74)
### Repositories 

This is the Smart Contract repository. The Web App UI is at https://github.com/Narwallets/metastaking-webapp

### Change Log

#### `2.0.0` - Dec 2022

- Added active rebalance, to supoprt vote.metapool.app

#### `1.2.1` - May 2022

- NEAR gas computation will change, fix gas computation on dao upgrade instruction

#### `1.2.0` - March 2022

- All audit recommendations implemented
- set all staking pools weights in a single call

#### `1.1.0` - Dec 2021
- new fn Realize_meta_massive to auto farm $META

#### `1.0.0` - Apr 2021

- Full functionality
- Simplified user flow 
- Desk check testing https://github.com/Narwallets/sc-desk-check-parser

#### `0.1.0` - Nov 2020

- Initial version based on core-contracts/lockup and core-contracts/staking-pool
- Deposit, withdraw
- Distributed stake/unstake
- NEAR/stNEAR liquidity pool, Add/Remove liquidity
- META Minting with rewards

### TO DO & Help needed

#### Smart Contract  
 - [x] Deposit/withdraw
 - [x] Buy stNEAR/Stake
 - [x] Sell stNEAR/immediate unstake
 - [x] Classic unstake-wait-finish-unstake
 - [x] User trip-meter, measure rewards
 - [x] distribute staking/unstaking
 - [x] retrieve unstaked and ready
 - [x] NEAR/stNEAR Liquidity Pool, Add/Remove liquidity
 - [x] clearing mechanism on stake to restore liquidity in the NSLP
 - [x] act as a NEP-xxx MULTI-FUN-TOK (multi-token contract). Implement for NEAR, stNEAR and META
 - [ ] Dividends-pool stNEAR/META
 - [x] Staking-loans to whitelisted validators
 - [ ] Emergency Staking (from the nslp) to whitelisted validators

#### Test
 - [x] Simulation tests
 - [x] Fuzzy Testing

#### Staking pool list
 - [x] List selected staking pools, getting weight, staked & unstaked
 - [x] add a staking pool, set weight

#### Governing
 - [x] Mint and distribute META with rewards
 - [x] Phase II - Governing DAO

#### Infrastructure
- [x] External cron to call distribute()
- [x] compute remaining epoch time
- [x] whitelist pools before adding them

#### Expansions

- [x] USDNEAR MVP: Create a collateral-based stablecoin similar to Compound's DAI, using NEAR & stNEAR as collateral

## Testing

All tests are are performed in a separate project with an ad-hoc fuzzy test for metapool.

The test generates random operations. We have a list of "invariants" the contract must satisfy to guarantee the internal accounting is consistent. We use a seeded random generator to create "operations" against the metapool (deposit, liquid-unstake, delayed-unstake, add-liquidity, remove-liquidity, compute-rewards, retrieve-funds-from-pools, rebalance) in any order and amount. After each successful operation we check the contract invariants again. This is our way to tests unprepared operations combinations and make sure the internal accounting remains consistent

The tests are located in the folder metapool/test

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --package metapool --target wasm32-unknown-unknown --release
#RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
mkdir -p res
cp -u target/wasm32-unknown-unknown/release/metapool.wasm res/
# cp -u target/wasm32-unknown-unknown/release/staking_pool.wasm res/
# cp -u target/wasm32-unknown-unknown/release/get_epoch_contract.wasm res/

'''
'''--- docs/_config.yml ---
theme: jekyll-theme-cayman
title: NEAR Meta Staking Pool
description: Diversified Stake, StNEAR, Immediate Unstake, AMM, META

'''
'''--- docs/beta-test.md ---
# GREAT NEWS!!!

## Welcome to the beta-test launch of META-POOL, one of the first BIG DAOs on NEAR!

The beta test period on TESTNET is starting, and we need a lot of help from the guilds and the NEAR community.

### What's the meta-staking-pool?

See [here](https://narwallets.github.io/meta-pool/)

### What can I do?

#### Testing

* Ask for support, join us at [Narwallet's Discord](https://discord.gg/a7db8FaQCZ)
* Test the Web App, report bugs at Narwallet's discord channels.
* Found a bug in the Web App you might want to solve yourself? create an issue here [github.com/Narwallets/webapp-meta-pool/issues](https://github.com/Narwallets/webapp-meta-pool/issues)
* If you track a bug into the contract, report it here [github.com/Narwallets/meta-pool/issues](https://github.com/Narwallets/meta-pool/issues)

#### Ideas & Design

* A great idea for the launch?  A new integration? Tell us on [Narwallet's Discord](https://discord.com/invite/tG4XJzRtdQ)
* More than one UI design, might be popular

#### Economics

* Help define Tokenomics for META

#### Coding

* Squash bugs with PRs, on any of the repos
* Start designing and or coding the Governance-Contract
* Propose and add new features

### Will contributors be rewarded?

Yes, $META (The governance token) will be awarded to collaborators. Your $META will be awarded after Meta-Staking mainnet implementation.

### What will be the value of a META on mainnet?

It's not clear now. It depend son the final tokenomics, on the amount of staking the meta-pool attracts, and the future $META demand.

### How do I participate on the birth of the first BIG DAO on NEAR?

1. You need to install latest/beta Narwallet chrome-extension wallet in **developer mode**. [Instructions here](https://github.com/Narwallets/beta-testing/blob/main/README.md)
2. [Create an account on testnet](https://wallet.testnet.near.org)
3. You can get testnet NEAR tokens here [here](https://near-examples.github.io/token-printer/)
4. Open the wallet, choose "testnet" as network and import the account into the wallet
5. Go to [www.narwallets.com/dapp/testnet/meta](http://www.narwallets.com/dapp/testnet/meta)
6. Open the wallet, select your testnet account and click "connect to web site"
7. Operate the Dapp, stake, sell stNEAR, add liquidity, find and squash bugs, help make it better and prettier, get rewards!

### Where are the repos

*  Web App: [github.com/Narwallets/webapp-meta-pool](https://github.com/Narwallets/webapp-meta-pool)
*  Smart Contract (rust): [github.com/Narwallets/meta-pool](https://github.com/Narwallets/meta-pool)

### Where is beta-test app hosted?

Here: [www.narwallets.com/dapp/testnet/meta](http://www.narwallets.com/dapp/testnet/meta)

'''
'''--- docs/index.md ---
# Meta Staking Pool

## Overview

This contract provides the following value items for the NEAR community:

#### Helps stakers avoid putting all eggs in one basket
 This contract acts as a staking-pool that distributes it's delegated funds to several validators. By delegating to this contract, you greatly reduce the risk of getting no-rewards due to validator outages and you contribute to decentralization and censorship-resistance. Besides staking rewards, while staking you will receive $META  tokens. (Automatic Farming) 

#### Provides Liquid Unstaking
This contract allows users to skip the unstaking waiting period by providing a liquidity pool for *liquid unstaking*. This simplifies NEAR staking, making staking and unstaking simple and immediate.

#### Tokenizes Stake
This contract **tokenizes, liberates your stake** while keeping it generating staking rewards. It allows you to use it to operate on markets or to [use it as collateral](https://github.com/luciotato/usdnear-stable).

#### Contributes to decentralization for the NEAR network
 This contract helps decentralization by distributing its delegated funds to several validators. This contract implements the stake-pool interface, so if you own a lockup-contract with considerable funds, you can greatly contribute to the decentralization and censorship-resistance of the network and reduce your risk at the same time. Funds will be automatically distributed between several validators ensuring increased decentralization and continuous rewards.

#### Creates a Liquidity Pool and fees for Liquidity Providers
This contract includes a liquidity pool and the opportunity for liquidity providers to earn fees. The liquidity pool is a stNEAR->NEAR swap pool, providing the *Liquid Unstake* functionality and generating fees for the Liquidity Providers.

#### Automatic Farming
This contract integrates two NEP-141 tokens: stNEAR, *staked-NEAR* and $META, the project token. $METAs are farmed automatically. If you use the liquid unstake function, you'll receive $META; if you stake, you'll get $META with your staking rewards; if you are a Liquidity Provider, you'll get $META with your fees. There's also a $META multiplier: *early liquidity providers will receive more $META than late adopters*. 

At launch time and for a limited period, the multipliers are:
* 5x: Liquid unstakers get 5 $META per each NEAR they pay in fees
* 10x: Stakers get 10 $META per each NEAR they receive from staking rewards
* 50x: Liquidity Providers get 50 $META per each NEAR fee generated

#### Validator Loans: a safety-net to avoid losing validators on the seat-price cliff 
This contract will allow struggling validators to keep a seat and keep validating in case of sudden rises in seat price. There will be staking-loans available for whitelisted validators and also emergencies stakes from the liquidity pool. Pools requiring staking will have to pay x-epoch rewards in advance. Fees paid will be distributed as rewards between the stNEAR holders and/or the Liquidity providers.

## Liquid Unstake

Users wanting to unstake skipping the waiting period can do so in the *stNEAR->NEAR Liquidity Pool*.

In the Liquidity Pool:
 * Users providing liquidity can earn fees on each sell
 * Users wanting to unstake without the waiting period can do so for a fee.

The *stNEAR->NEAR Liquidity Pool* is a one-sided Liquidity pool. Liquidity providers add only NEAR to the liquidity pool. The pool allows other users to perform "Liquid Unstakes". During a "Liquid Unstake" users send stNEAR and receive NEAR from the liquidity pool, minus a fee. The fee represents how much users value skipping the 39-52hs waiting period to receive their funds. The fee varies with the amount of NEAR in the Liquidity Pool, but the curve is capped at the extremes. Initially, discount fees are in the range 3%-0.3%, but the curve parameters can be adjusted by DAO governance.

![example-fee-curve](images/example-fee-curve.png)

## stNEAR Tokens

This contract tokenizes your stake, allowing users to use their staked near as a NEP-141 TOKEN, called **stNEAR**.

stNEARs represent staked NEAR. **The amount of stNEAR you hold is automatically incremented each epoch when staking rewards are paid**. 

## Trip-meter 

This contract also includes a trip-meter functionality, so you can precisely measure staking rewards received, regardless of stake and unstake movements you can make. 
The rewards trip-meter will show you the exact amount of your staking rewards without being affected by staking and unstaking movements in your account.

## Standard staking-pool and Lockup-Contract accounts

This contract also acts as a standard staking-pool, so users can perform classical stakes and classical unstakes.

By implementing the standard-staking-pool trait, **lockup-contract accounts** can delegate funds here, gaining risk reduction and greatly contributing to NEAR decentralization. Note: Lockup contracts can *only* perform classic stake/unstake so Lockup contracts *can not* access the liquidity pool or buy/sell stNEAR.

## Technical details

The contract pools all users' funds and keeps a balanced distribution of those funds in a list of whitelisted, low-fee, high-uptime validators.

Staking and unstaking distribution is done by periodically calling `distribute_staking()/distribute_unstaking()`, so actual staking and unstaking are delayed. 

The contract includes a swap pool called the Liquidity-Pool. When users perform a liquid-unstake, the swap some of their stNEAR for NEAR in the liquidity pool, providing a fee to Liquidity Providers. Liquidity Providers indirectly get the stNEAR+fee and deliver NEAR. No stake/unstake is performed in that process.

### Guarantees

- The users can not lose tokens or block contract operations by using methods under staking section.
- Users owning stNEARs will accrue rewards on each epoch, except in the extreme unlikely case that ALL validators go offline during that epoch.

## Use Cases

#### Definitions:

stNEAR: one stNEAR represents one staked NEAR. A stNEAR is a virtual token computed from the user’s share in the total staked funds. By staking in the Meta-pool a user mints stNEAR, by unstaking, stNEARs are burned. When staking rewards are paid, new stNEARs are minted and distributed.

--- To STAKE is to mint stNEARs ---

--- To UNSTAKE is to burn stNEAR ---

There are two ways to unstake: (from more convenient to less convenient)

1. Liquid Unstake: You unstake by swapping stNEAR->NEAR in the Liquidity Pool. Since you’re unstaking without waiting 39-54hs (you’re passing the wait penalty to other users) you pay a small fee. The fee is the value of not-waiting 39-54hs. Example: You liquid-unstake 100 stNEAR for 99.8 NEAR, and you get your NEAR immediately without waiting 39-54hs. Note: Liquid unstakers receive NEAR *and* $META rewards in the operation.

2. Delayed Unstake. You burn stNEAR tokens and get unstaked-near. The contract unstakes your NEAR from the staking-pools. You don’t pay a fee, but you must wait 4-8 epochs to withdraw those funds to your account. Your funds remain unstated in the staking-pool for 3 to 8 epochs (39-104hs) before you can withdraw. E.g. you unstake 100 stNEAR, and you get 100 unstaked-near, 4 days later you can withdraw your unstaked-near to your own near account.

These operations are reflected in the UI in two steps that the user must complete with 39-104hs between them: [Delayed-Unstake::start] and [Delayed-Unstake::withdraw]. The UI informs the user the waiting period before confirmation, and also the remaining hours during the wait period.

**Liquidity Pool**

In order to provide Liquid Unstake a Liquidity Pool is maintained by the contract:

* The unstaker enters the amount of stNEAR they want to unstake and the contract replies with the amount of NEAR & $META they will receive, normally with a fee between 0.3% and 3% depending on the available liquidity and the fee curve parameters.

## Treasury
Part of the LP fees go to the DAO Treasury. Treasury funds are always stNEARs and used for:

* DAO Maintenance
* DAO Expansion
* $META holders dividends

## Governance

(When Phase II - DAO Governance is implemented)

$META holders can vote on:
* Diversification: Validator distribution list, and how much stake to distribute to each one.
* Fee curve parameters for the NEAR/stNEAR Liquidity Pool (min fee, max fee, liquidity target)
* How to use treasury funds for DAO expansion
* Operational costs fee
* Maintenance funds redirection
* Pay rewards to $META holders
* Approve validator stake-loans
* Set $META mint reward multiplier for:
  * Liquid unstakers (default 1 $META per each discounted NEAR)
  * Stakers (default 5 $META per each stNEAR of staking reward)
  * LP-providers (default 20 $META per each stNEAR fee received)

### Phase III Proposals (future)
Create a Dividends-pool as a stNEAR/$META liquidity pool allowing $META owners to burn $META to obtain stNEAR. This pool sets a base-price for $META tokens. When users vote to add stNEAR to the dividends-pool, $META base-price is incremented. Users can also vote to remove stNEAR from the dividends-pool back to the treasury, lowering the $META base price.

Users get $META tokens minted for them when:
* They do Liquid Unstakes (immediate unstaking) (default 1x multiplier)
* They receive rewards for holding stNEAR (default 5x multiplier)
* They receive fees as Liquidity Providers (default 20x multiplier)

$META governance tokens are minted and distributed to:
* users paying liquid unstaking fees
* users holding stNEAR 
* users providing liquidity.

## Operational costs

Periodic calls to `distribute_staking()/distribute_unstaking()/withdraw_from_a_pool()` are required for this contract operation. These calls consume considerable amounts of gas that is paid by the operator account. To fund this operational cost, a operator's fee percentage (0.3% by default) is taken from rewards distributions. It can be adjusted by DAO governance.

## Maintenance

The contract has a configurable parameter `dev_maintenance_amount`, initially 400 stNEAR, to be transferred monthly to the account `developers.near`. By DAO governance, this value can be increased and up to 50% can be redirected to other maintainers and contributors.

## User stories:
### Alice 

Alice wants to stake her NEAR with low risk, and also help the community by promoting decentralization and censorship-resistance for the network.

Alice stakes 750,000 NEAR in the meta-pool. Her 750,000 NEAR are distributed between the staking-pools by an automatic distribution mechanism to keep the validators balanced. She gets 750,000 stNEAR tokens. 

She starts earning staking rewards on her stNEAR, she can track precisely her rewards. She will also get $META tokens on each reward distribution.
By having stNEAR she has tokenized her stake, she can participate in other markets, and also she can Liquid-Unstake some of her stNEAR skipping the waiting period if the need arises.

### Bob 

Bob already has staked in the meta-pool. He holds 10,000 stNEAR earning staking rewards. 

Bob needs to unstake 5,000 NEAR to use in an emergency. He can’t wait 4 days to get his NEAR. 

Bob Liquid-Unstakes 5,050 stNEAR and he gets 5,000 NEAR plus 250 $META (He's paying a 1% fee to get his NEAR immediately).
Bob gets NEARs in his account. Bob can use his NEAR immediately.

### Carol 

Carol is an investor. She wants to provide liquidity for the Liquid-Unstake function for a short period, earning swap fees.
Carol deposits 7,000 NEAR in the Liquidity Pool, she is the first in the pool, so she gets 7,000 shares of the Liquidity Pool.

Bob swaps 5,050 stNEAR for 5,000 NEAR and 250 $META. He pays a 1% fee to get the NEAR immediately. The Liquidity Pool delivers 5,000 NEAR to Bob and acquires 5,050 stNEAR from Bob. The new value of the Liquidity Pool is 7,050 NEAR (2,000 NEAR + 5,050 stNEAR), 

Carol share value has increased and now she owns some stNEAR via the Liquidity Pool. Carol burns all her shares and retrieves 2,000 NEAR and 5,050 stNEAR into her account. Carol has now 7,050 NEAR. Carol earned 0.7% in a few epochs.
Had her normally staked 7,000 NEAR, she would have earned only 0.1% in the same period.

### Dave

Dave is a Liquidity Provider. He wants to provide continuous liquidity for the Liquidity Pool, in order to earn a fee on each operation.

Being a Liquidity Provider can bring-in more earnings than just staking, while helping the community at the same time by providing liquid unstaking for other users.

Dave enters 100,000 NEAR to the Liquidity Pool, he gets shares of the Liquidity Pool. 

Eve swaps 50,500 stNEAR for 50,000 NEAR. She pays a 1% fee price to get her NEAR immediately.

The Liquidity Pool delivers 50,000 NEAR to Eve and acquires 50,500 stNEAR from Eve.
The Liquidity Pool has a low amount of NEAR now. During the epoch the liquidity pool uses an internal clearing mechanism to acquire NEAR by selling stNEAR and restore liquidity automatically. After several operations, the liq-pool will have liquidity restored at 100,500 NEAR.

As the Liquidity Pool operates, the NEAR amount grows, so do Dave’s share value. With each operation $META tokens are also minted for Liquidity Providers, so Dave and the other providers get $META tokens besides the fees.

-------------------------

## Future Expansions

* USDNEAR: Create a collateral-based stable coin similar to Compound's DAI, using stNEAR as collateral

-------------------------

## Technical Information, Change Log & TO-DO

See the [smart contract github repository README](https://github.com/Narwallets/meta-pool)

'''
'''--- docs/technical-notes.md ---
## Operator Functions

There are 3 "heartbeat()" functions:

### 1. distribute_staking()

```
    /// operator method -------------------------------------------------
    /// distribute_staking(). Do staking in batches of at most 100Kn
    /// returns "true" if the operator needs to call this fn again
    pub fn distribute_staking(&mut self) -> bool 
```

This fn does staking if needed, according to staking-pool weight (% of the pool)

This fns should be called preferably before the epoch ends. Leaving NEAR unstaked is beneficial for the NSLP clearing
so this function should not be called when not necessary.

Once called, if distribute_staking() returns "true", the operator should call it again until it returns "false"

###  2. distribute_unstaking()

```
    // Operator method, but open to anyone
    /// distribute_unstaking(). Do unstaking 
    /// returns "true" if needs to be called again
    pub fn distribute_unstaking(&mut self) -> bool 
```

This fn does unstaking if needed, according to staking-pool weight (% of the pool)

This should be called only at the beginning of each epoch, to maximize rewards received from the pools (from the previous epoch).

Once called, if the fn returns "true", the operator should call it again until it returns "false"

###  3. distribute_rewards()
```
    //------------------------------------------------------------------------
    //-- COMPUTE AND DISTRIBUTE STAKING REWARDS for a specific staking-pool --
    //------------------------------------------------------------------------
    // Operator method, but open to anyone. Should be called once per epoch per sp, after sp rewards distribution (ping)
    /// Retrieves total balance from the staking pool and remembers it internally.
    /// computes and distributes rewards
    /// this fn queries the staking pool (makes a cross-contract call)
    pub fn distribute_rewards(&mut self, sp_inx_i32: i32) -> void 
```

###  4. pub fn retrieve_funds_from_a_staking_pool(&mut self, inx:u16)

```
    // Operator method, but open to anyone
    //----------------------------------------------------------------------
    //  RETRIEVE FUNDS FROM ONE OF THE POOLS ONCE THE WAITING PERIOD HAS ELAPSED
    //----------------------------------------------------------------------
    /// launches a withdraw call
    /// returns the amount withdrawn
    pub fn retrieve_funds_from_a_pool(&mut self, inx:u16) -> Promise -> u128 {

        //Note: In order to make fund-recovering independent from the operator
        //this fn is open to be called by anyone
```

This fn performs withdraw from a specific pool, in order to have the funds available when the user requests them

This should be called at the beginning of each epoch. The operator should call `get_staking_pool_list()`
and process the list calling `retrieve_funds_from_a_pool` for each pool needing retrieve and with can_retrieve=true

'''
'''--- docs/tokenomics.md ---
# $META Tokenomics

The $META token ensures there is a clear alignment of incentives between users, token holders, stakers, the developers and the broad community, so that meta-pool can continue to grow in a sustainable and productive manner for the benefit of all the NEAR community. It is therefore crucial that the $META token have strong fundamental value accrual structures in place which build value over time.

## Overview:

Max Supply 1,000,000,000

Emission Period: 2 years

Weekly Emission Reduction: -4% (dynamic)

Early Adopters % of Supply: 5%, 50m

Founders % of Supply: 25%, 250m

Founder Lockup: Lockup over 2 years with linear release.

Treasury % of Supply: 20%, 200m

Community & Ecosystem % of Supply: 50%, 500m (Stakers, Liquidity Providers, Users)

Token Type: NEP-141

### Principles:

* Community reward emissions are split between Stakers, Liquidity Providers, and Users. The rewards multipliers may change over time to reach target Weekly Emission Reduction.
* 70% of fees on Liquid Unstakes go to Liquidity Providers, 25% to the Treasury, and 5% to operator & developers.
* 80% of fees on Stake Loans go to Stakers, 15% to the Treasury, and 5% to operator & developers.
* $META tokens will become the governance tokens on Phase II
* The Treasury should be sustainable and have enough supply to pay for top talent.
* 2 year emission schedule with 4% weekly reduction. Early risk takers rewarded and new supply entering circulation reduces over time and helps build long term value given static or growing buyback demand. 

### Buyback and burn:

1. The DAO can vote to use treasury funds on $META buyback and burning. The meta-pool will provide a buyback swap pool fueled by treasury's stNEAR fees.
1. The meta-pool will charge fees for services with 70% of fees going to stakers, 25% to treasury and 5% to operator & developers.

### Value Accrual
It is essential to the success of the project that the meta-pool actually generates revenue and adds value to the token. Therefore there are several value accrual mechanisms for the token itself which will further generate interest and incentives in a positive feedback loop. The below is a list of value accrual mechanics that will be implemented on the meta-pool platform:

**Transaction fees**: The most basic and simple value accrual is the fee the contract takes on on certain interactions (Liquid Unstaking, Rewards Distribution, Stake Loans). The majority of this fee revenue goes to Stakers and Liquidity Providers, with the remaining being sent to the treasury.

**Buyback and distribute**: The core value accrual mechanic is buyback of $META tokens from revenue generated by transaction fees in the protocol. This gives a native APY for staking the $META token and aligns incentives of token holders with the success of the meta-pool.

**Reducing supply emission rate**: Supply emissions should reduce over time without any large cliffs  The optimal scenario is a gradual reduction in new emissions over time. For the meta-pool, this emission reduction target will be 4% weekly of the community and ecosystem reserve. With a steady or increasing demand and a falling emission rate there reaches an inflection point where buybacks volume is greater than new emissions creating NET positive buy pressure on the $META token.

**Staking Loans**: A core part of the meta-pool is being an lender of stake to struggling validators about to fall from the seat-price cliff. The objective is to preserve decentralization and damp seat-price increases. Fees collected for these services will flow back to Stakers and $META holders via the treasury.

**Lockups**: Incentivizing users to take coins off the market is one way to reduce potential sell pressure and ensure given flat or growing demand that there is NET positive buy pressure. The meta-pool intends to implement lockup LP pools where tokens will be locked for a specified amount of time and be able to share in a higher rate of emissions or staking revenue compared with staking pools which allow immediate withdrawal.

### Governance:
The meta-pool will initially implement a Sputnik V2 DAO with a council integrated by the core team, early adopters, members from the NEAR Team and the NEAR Foundation. The DAO will guide the direction of the project allowing upgrades while keeping the funds safe. There will be no governance functions on launch, on phase II the DAO will evolve into a community based decision process, involving $META token holders in the decision making process once the $META token is established.

### Conclusion:
This is the initial token mechanics for the $META token and may be subject to change. The meta-pool DAO objectives will be focused on value accrual for the platform with our core principle being that the meta-pool should be the platform the majority uses to Tokenize their stake while helping decentralization for the NEAR community. 
## $META Token Launch Mechanics - Initial Distribution

May 25th 19:00 UTC — A $META/NEAR fixed-price pool will be deployed on ref.finance 

This pool will be tradable immediately, Initial liquidity will be 10,000 NEAR and 1,000,000 $META tokens at a fixed price of 0.01 NEAR. 

If the pool is emptied, a new sell-only, fixed price pool will be established with initial liquidity 100,000 NEAR and 4,000,000 $META tokens at a linear-increasing price of 0.02-0.04 NEAR. 

If the pool is emptied, a third, sell-only, fixed price pool will be established with initial liquidity 400,000 NEAR and 8,000,000 $META tokens at a linear-increasing price of 0.05-0.09 NEAR. 

One month after launch, liquidity will be provided for the NEAR/$META pair swap pool on ref.finance to guarantee liquidity for a free token trade.

We believe this is the ‘fairest’ launch mechanic that is simple and open to everyone. No caps, no limits, no lists, just a simple launch via AMMs like most DeFi projects for the last year. Coins available for everyone.

<small>*Note: This document and the mechanism is heavily inspired by the STEP Token launch mechanics*</small>
'''
'''--- metapool/Cargo.toml ---
[package]
edition = "2018"
name = "metapool"
version = "1.2.1"
authors = ["Metapool.app <hello@metapool.app>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = { version = "0.9.5", default-features = false }

'''
'''--- metapool/src/account.rs ---
use crate::*;
use near_sdk::log;

pub use crate::types::*;
pub use crate::utils::*;

// -----------------
// User Account Data
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// This amount increments with deposits and decrements with for_staking
    /// increments with complete_unstake and decrements with user withdrawals from the contract
    /// withdrawals from the pools can include rewards
    /// since staking is delayed and in batches it only eventually matches env::balance()
    /// total = available + staked + unstaked
    /// Note: In the simplified user-UI, the basic-user always does deposit-and-stake and sell/unstake that goes directly to their wallet
    /// so the only users of this field are lockup-contracts and advanced-users when they perform "Classic Unstakes"
    pub available: u128,

    /// The amount of st_near (stake shares) of the total staked balance in the pool(s) this user owns.
    /// When someone stakes, share-price is computed and shares are "sold" to the user so he only owns what he's staking and no rewards yet
    /// When a user request a transfer to other user, shares from the origin are moved to shares of the destination
    /// The share_price can be computed as total_for_staking/total_stake_shares
    /// stNEAR price = total_for_staking/total_stake_shares
    pub stake_shares: u128, //st_near this account owns

    /// Incremented when the user asks for Delayed-Unstaking. The amount of unstaked near in the pools
    pub unstaked: u128,

    /// The epoch height when the unstaked will be available
    /// The funds will be locked for -AT LEAST- NUM_EPOCHS_TO_UNLOCK epochs
    pub unstaked_requested_unlock_epoch: EpochHeight,

    //-- META (now mpDAO) INCENTIVES (Disabled on 2023-05)
    // realized META, can be used to transfer META from one user to another
    // Total META = realized_meta + staking_meter.mul_rewards(valued_stake_shares) + lp_meter.mul_rewards(valued_lp_shares)
    // Every time the user operates on STAKE/UNSTAKE: we realize meta: realized_meta += staking_meter.mul_rewards(valued_staked_shares)
    // Every time the user operates on ADD.LIQ/REM.LIQ.: we realize meta: realized_meta += lp_meter.mul_rewards(valued_lp_shares)
    // if the user calls farm_meta() we perform both
    pub realized_meta: u128, // deprecated
    ///Staking rewards meter (to mint stNEAR for the user)
    pub staking_meter: RewardMeter,
    ///LP fee gains meter (to mint meta for the user)
    pub lp_meter: RewardMeter, // deprecated

    //-- STATISTICAL DATA --
    // User's statistical data
    // This is the user-controlled staking rewards meter, it works as a car's "trip meter". The user can reset them to zero.
    // to compute trip_rewards we start from current_stnear, undo unstakes, undo stakes and finally subtract trip_start_stnear
    // trip_rewards = current_stnear + trip_accum_unstakes - trip_accum_stakes - trip_start_stnear;
    /// trip_start: (timestamp in milliseconds) this field is set at account creation, so it will start metering rewards
    pub trip_start: Timestamp,

    /// OBSOLETE - How much stnear the user had at "trip_start".
    pub trip_start_stnear: u128,
    // how much stnear the staked since trip start (minus unstaked)
    pub trip_accum_stakes: u128,
    // how much the user unstaked since trip start (zeroed if there was stake)
    pub trip_accum_unstakes: u128,

    ///NS liquidity pool shares, if the user is a liquidity provider
    pub nslp_shares: u128,
}

/// User account on this contract
impl Default for Account {
    fn default() -> Self {
        Self {
            available: 0,
            stake_shares: 0,
            unstaked: 0,
            unstaked_requested_unlock_epoch: 0,
            //meta & reward-meters
            realized_meta: 0,
            staking_meter: RewardMeter::default(),
            lp_meter: RewardMeter::default(),
            //trip-meter fields
            trip_start: env::block_timestamp() / 1_000_000, //converted from nanoseconds to milliseconds
            trip_start_stnear: 0,
            trip_accum_stakes: 0,
            trip_accum_unstakes: 0,
            //NS liquidity pool
            nslp_shares: 0,
        }
    }
}
impl Account {

    /// if the account can be closed and storage deposit returned
    pub fn can_be_closed(&self) -> bool {
        self.available == 0
        && self.unstaked == 0
        && self.stake_shares == 0
        && self.nslp_shares == 0
    }

    #[inline]
    pub fn valued_nslp_shares(&self, main: &MetaPool, nslp_account: &Account) -> u128 {
        main.amount_from_nslp_shares(self.nslp_shares, &nslp_account)
    }

    //----------------
    // add st_nears, considering it as "a stake" for trip-meter purposes
    pub fn add_st_near(&mut self, st_near_amount: u128, main: &MetaPool) {
        self.add_stake_shares(
            st_near_amount,
            main.amount_from_stake_shares(st_near_amount),
        )
    }
    pub fn add_stake_shares(&mut self, num_shares: u128, near_amount: u128) {
        self.stake_shares += num_shares;

        // to buy stnear is to stake
        self.trip_accum_stakes += near_amount;

        self.staking_meter.stake(near_amount);
    }

    // remove st_near considering is "an unstake" for trip-meter purposes
    pub fn sub_st_near(&mut self, st_near_amount: u128, main: &MetaPool) {
        self.sub_stake_shares(
            st_near_amount,
            main.amount_from_stake_shares(st_near_amount),
        )
    }
    pub fn sub_stake_shares(&mut self, num_shares: u128, near_amount: u128) {
        assert!(
            self.stake_shares >= num_shares,
            "sub_stake_shares self.stake_shares {} < num_shares {}",
            self.stake_shares,
            num_shares
        );
        self.stake_shares -= num_shares;

        // to sell stnear is to unstake
        self.trip_accum_unstakes += near_amount;
        if self.trip_accum_unstakes < self.trip_accum_stakes {
            //keep just the delta
            self.trip_accum_stakes -= self.trip_accum_unstakes;
            self.trip_accum_unstakes = 0;
        }

        self.staking_meter.unstake(near_amount);
    }

    /// user method
    /// completes unstake action by moving from acc.unstaked & main.retrieved_for_unstaked_claims -> acc.available & main.total_available
    pub fn in_memory_try_finish_unstaking(
        &mut self,
        account_id: &str,
        amount: u128,
        main: &mut MetaPool,
    ) -> u128 {
        assert!(
            amount <= self.unstaked,
            "Not enough unstaked balance {}",
            self.unstaked
        );

        let epoch = env::epoch_height();
        assert!( epoch >= self.unstaked_requested_unlock_epoch,
            "The unstaked balance is not yet available due to unstaking delay. You need to wait at least {} epochs"
            , self.unstaked_requested_unlock_epoch - epoch);

        // in the account, moves from unstaked to available
        self.unstaked -= amount; //Zeroes, claimed
        self.available += amount;
        //check the heart beat has really moved the funds
        assert!(
            main.retrieved_for_unstake_claims >= amount,
            "Funds are not yet available due to unstaking delay. Epoch:{}",
            env::epoch_height()
        );
        // in the contract, move from reserve_for_unstaked_claims to total_available
        main.retrieved_for_unstake_claims -= amount;
        assert!(main.total_unstake_claims >= amount, "ITUC");
        main.total_unstake_claims -= amount;
        main.total_available += amount;

        event!(
            r#"{{"event":"D-WITHD","account_id":"{}","amount":"{}"}}"#,
            account_id,
            amount
        );

        log!("{} unstaked moved to available", amount);

        return amount;
    }

    pub(crate) fn take_from_available(
        &mut self,
        account_id: &String,
        amount_requested: u128,
        main: &mut MetaPool,
    ) -> u128 {
        let to_withdraw:u128 =
        // if the amount is close to user's total, remove user's total
        // to: a) do not leave less than ONE_MILLI_NEAR in the account, b) Allow some yoctos of rounding, e.g. remove(100) removes 99.999993 without panicking
        // Audit Note: Do not do this for .lockup accounts because the lockup contract relies on precise amounts
        if is_lockup_account(account_id) || !is_close(amount_requested, self.available) { 
            // exact amount
            amount_requested
        }
        else {
            // is close, allow for rounding simplification
            self.available
        };

        assert!(
            self.available >= to_withdraw,
            "Not enough available balance {} for the requested amount",
            self.available
        );
        self.available -= to_withdraw;

        assert!(main.total_available >= to_withdraw, "i_s_Inconsistency");
        main.total_available -= to_withdraw;

        return to_withdraw;
    }
}

'''
'''--- metapool/src/distribute.rs ---
use crate::*;
use near_sdk::{log, near_bindgen, Promise};

#[near_bindgen]
impl MetaPool {
    //----------------------------------
    // Heartbeat & Talking to the pools
    // ---------------------------------

    //-----------------------------
    // DISTRIBUTE
    //-----------------------------

    /// operator method -------------------------------------------------
    /// distribute_staking(). Do staking in batches of at most 100Kn
    /// returns "true" if the operator needs to call this fn again
    pub fn distribute_staking(&mut self) -> bool {
        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone

        self.assert_not_busy();

        //do we need to stake?
        if self.total_for_staking <= self.total_actually_staked {
            log!("no staking needed");
            return false;
        }
        // here self.total_for_staking > self.total_actually_staked
        // do clearing
        self.internal_end_of_epoch_clearing();
        // here, if we have epoch_stake_orders, then we need to stake
        if self.epoch_stake_orders == 0  { 
            // that delta is from some manual-unstake
            log!("self.epoch_stake_orders == 0");
            return false;
        }

        //-------------------------------------
        //compute amount to stake
        //-------------------------------------
        // Note: there could be minor yocto corrections after sync_unstake, altering total_actually_staked, consider that
        // epoch_stake_orders are NEAR that were deposited by users, stNEAR minted, and are available in the contract for staking or to reserve (see epoch_unstake_orders)
        // epoch_unstake_orders are stNEAR that was burned, users started delayed-unstake, and so NEAR must be unstaked from the pools...
        // ... or some NEAR from epoch_stake_orders might remain as reserve, to avoid senseless stake + unstake
        // but in any case, does not make sense to stake more than delta: total_for_staking - total_actually_staked
        let total_amount_to_stake = std::cmp::min(
            self.epoch_stake_orders,
            self.total_for_staking - self.total_actually_staked,
        );
        if total_amount_to_stake < MIN_STAKE_AMOUNT {
            log!("amount too low {}", total_amount_to_stake);
            return false;
        }
        // find pool
        // the resulting "amount_to_stake" could be less than total_amount_to_stake, if the pool does not need that much
        let (sp_inx, stake_required) = self.get_staking_pool_requiring_stake();
        log!(
            "total_amount_to_stake:{} get_staking_pool_requiring_stake=>{},{}",
            total_amount_to_stake,
            sp_inx,
            stake_required
        );
        // schedule promise to stake
        let amount_to_stake = std::cmp::min(total_amount_to_stake, stake_required);
        self.launch_direct_stake(sp_inx, amount_to_stake);
        return amount_to_stake < total_amount_to_stake; //did some staking (promises scheduled), call again?
    }

    // prev fn continues here
    /// internal launch direct stake on a pool
    /// **schedules promises** to stake 
    /// Note: if the sp has some sizable unstake pending, the fn will re-stake the unstaked-and-waiting-amount
    /// that amount can be lower than the amount requested to stake
    fn launch_direct_stake(&mut self, sp_inx:usize, mut amount_to_stake:u128) {

        if amount_to_stake > 0 {
            //most unbalanced pool found & available

            self.contract_busy = true;
            let sp = &mut self.staking_pools[sp_inx];
            sp.busy_lock = true;

            //case 1. pool has unstaked amount (we could be at the unstaking delay waiting period)
            //NOTE: The amount to stake can't be so low as a few yoctos because the staking-pool
            // will panic with : "panicked at 'The calculated number of \"stake\" shares received for staking should be positive', src/internal.rs:79:9"
            // that's because after division, if the amount is a few yoctos, the amount for shares is 0
            if sp.unstaked >= TEN_NEAR {
                //at least 10 NEAR
                //pool has a sizable unstaked amount
                if sp.unstaked < amount_to_stake {
                    //re-stake the unstaked
                    amount_to_stake = sp.unstaked;
                }

                //schedule async stake to re-stake in the pool
                ext_staking_pool::stake(
                    amount_to_stake.into(),
                    &sp.account_id,
                    NO_DEPOSIT,
                    gas::staking_pool::STAKE,
                )
                .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                    sp_inx,
                    amount_to_stake,
                    false,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
                ));
            } else {
                //here the sp has no sizable unstaked balance, we must deposit_and_stake on the sp from our balance

                // NOTE: This contract holds also the liquidity pool for fast unstake may be too optimistic, why not compute the storage explicitly and add
                //    a safety margin on top of that. That's because the account state may
                //    potentially exceed the 35N (or 3.5M right now). But I guess it can happen
                //    only at the beginning of metapool before the liquidity is provided.
                assert!(
                    env::account_balance() - MIN_BALANCE_FOR_STORAGE >= amount_to_stake,
                    "env::account_balance()-MIN_BALANCE_FOR_STORAGE < amount_to_stake"
                );

                //schedule async stake or deposit_and_stake on that pool
                ext_staking_pool::deposit_and_stake(
                    &sp.account_id,
                    amount_to_stake.into(), //attached amount
                    gas::staking_pool::DEPOSIT_AND_STAKE,
                )
                .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                    sp_inx,
                    amount_to_stake,
                    true,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
                ));
            }
        }

        //Here we did some staking (the promises are scheduled for exec after this fn completes)
        self.total_actually_staked += amount_to_stake; //preventively consider the amount staked (undoes if async fails)
        self.epoch_stake_orders -= amount_to_stake; //preventively reduce stake orders
    }

    //prev fn continues here
    /// Called after amount is staked into a staking-pool
    /// This method needs to update staking pool status.
    #[private]
    pub fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        included_deposit: bool,
    ) -> bool {
        let sp = &mut self.staking_pools[sp_inx];
        let sp_account_id = sp.account_id.clone();

        //WARN: This is a callback after-cross-contract-call method
        //busy locks must be saved false in the state, this method SHOULD NOT PANIC
        sp.busy_lock = false;
        self.contract_busy = false;

        let stake_succeeded = is_promise_success();

        let result: &str;
        if stake_succeeded {
            // STAKED OK
            result = "succeeded";
            // move into staked
            sp.staked += amount;
            // update accums based on the source of the funds
            let event: &str;
            if included_deposit {
                // we sent NEAR from the contract into the staking-pool
                event = "dist.stak"; //stake in the pools (including transfer)
                self.contract_account_balance -= amount; // we took from contract balance (transfer)
            } else {
                // stake the unstaked in the pool, no-transfer
                event = "dist.stak.nt"; //not deposited first, so staked funds came from unstaked funds already in the staking-pool
                sp.unstaked -= amount; //we've now less unstaked in this sp
                self.total_unstaked_and_waiting -= amount; // contract total of all unstaked & waiting, now there's less there.
                                                           // We kept the NEAR in the contract and took from unstaked_and_waiting
                                                           // ... unstaked_and_waiting was in their way to be converted in retrieved_for_unstake_claims
                self.consider_retrieved_for_unstake_claims(amount); // so this is a special case: the NEAR to stake was taken from total_unstaked_and_waiting,
                                                             // so we compensate and take the NEAR in the contract and consider it reserved for_unstake_claims
            }
            //log event
            event!(
                r#"{{"event":"{}","sp":"{}","amount":"{}"}}"#,
                event,
                sp_account_id,
                amount
            );
        } else {
            //STAKE FAILED
            result = "has failed";
            self.total_actually_staked -= amount; //undo preventive action considering the amount staked
            self.epoch_stake_orders += amount; //undo preventively reduce stake orders
        }
        log!("Staking of {} at @{} {}", amount, sp_account_id, result);

        return stake_succeeded;
    }

    // execute stake on sp[inx] by amount
    // used by operator if a validator requires stake to keep a seat
    // Note: this fn stakes from current epochs_stake_orders,
    // consider that the scheduled promise-to-stake/restake can fail
    pub fn manual_stake(&mut self, inx: u16, amount: U128String) {
        self.assert_operator_or_owner();
        self.assert_not_busy();

        assert!(self.epoch_stake_orders > MIN_STAKE_AMOUNT,
            "self.epoch_stake_orders too low {}", 
            self.epoch_stake_orders
        );
        assert!(amount.0 <= self.epoch_stake_orders,
            "self.epoch_stake_orders is {} you cant manual stake {}", 
            self.epoch_stake_orders, amount.0
        );

        let sp_inx = inx as usize;
        assert!(sp_inx < self.staking_pools.len(), "invalid index");
        let sp = &self.staking_pools[sp_inx];
        assert!(!sp.busy_lock, "sp busy");
        // schedule promise to direct stake
        self.launch_direct_stake(sp_inx, amount.0);
        // Note: if the pool has some sizable unstake pending, the fn will re-stake the unstaked-and-waiting-amount
        // that amount can be lower than the amount requested to stake
    }

    /// Start a forced rebalance unstake of ALL extra for a pool
    /// used by operator when a validator goes offline, to not wait and unstake immediately even over the max-rebalance-cap
    /// the stake of the sp is adjusted to weight, if weight==0, the sp is fully unstaked
    pub fn force_rebalance_unstake(&mut self, inx: u16) {
        self.perform_rebalance(inx, self.total_for_staking);
    }

    /// Start a rebalance unstake of PARTIAL extra for a pool (capped by max_unstake_for_rebalance)
    /// used by operator when a validator to rebalance low performers
    /// the stake of the sp is adjusted limited by extra and max-rebalance-unstake
    pub fn rebalance_unstake_sp(&mut self, inx: u16) {
        let max_unstake_for_rebalance = self.max_unstake_for_rebalance();
        assert!(self.unstaked_for_rebalance + MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT < max_unstake_for_rebalance, 
            "max unstake for rebalance already reached");
        let unstake_rebalance_left = max_unstake_for_rebalance - self.unstaked_for_rebalance;
        self.perform_rebalance(inx, unstake_rebalance_left);
    }

    // internal common process for the prev 2 pub fns
    fn perform_rebalance(&mut self, inx: u16, cap: u128) {
        self.assert_operator_or_owner();
        self.assert_not_busy();
        let sp_inx = inx as usize;
        assert!(sp_inx < self.staking_pools.len(), "invalid index");
        let sp = &self.staking_pools[sp_inx];
        assert!(!sp.busy_lock, "sp busy");
        // can not unstake while unstake pending (if it was done on previous epochs) 
        // because it will extend the waiting period
        assert!(
            sp.unstaked == 0 || sp.unstk_req_epoch_height == env::epoch_height(),
            "can not force rebalance-unstake while unstake pending. sp.unstake={}, sp.unstk_req_epoch_height={}, env::epoch_height()={}",
            sp.unstaked, sp.unstk_req_epoch_height, env::epoch_height()
        );
        // limit for rebalance_unstaking is the should_have of the pool
        let should_have = apply_pct(sp.weight_basis_points, self.total_for_staking);
        // if staked, (unstaked in this epoch or unstaked==0) and extra
        assert!(sp.staked > should_have, 
            "the sp has not extra stake. assigned weight_bp:{}, stake:{}",sp.weight_basis_points, sp.staked
        );
        // has extra, can be unstaked, start rebalance
        let extra = sp.staked - should_have;
        // check for cap to unstake 
        let to_unstake_for_rebal = std::cmp::min(extra, cap);

        // Next call affects:
        // total_actually_staked, sp.stake & sp.unstake and total_unstaked_and_waiting, 
        // but it DOES NOT not affect reserve_for_unstake_claims and also DOES NOT change total_for_stake
        // this means that eventually we will retrieve from the pools, more than required for reserve_for_unstake_claims
        // at that point, the extra amount is set for restake (see fn retrieve_funds_from_a_pool), completing the rebalance
        self.perform_unstake(sp_inx, 0, to_unstake_for_rebal); // unstake for rebalance
    }

    /// Start a rebalance unstake if needed, returns true if you should call again
    /// it calls get_staking_pool_requiring_unstake(), to get an index and amount
    /// used by operator when periodically rebalancing the pool 
    /// The amount to unstake is added to unstaked_for_rebalance.
    /// When these funds are finally withdrawn, 4 epochs from now, the extra NEAR received 
    /// (any amount reserved exceeding total_unstake_claims) will be added to epoch_stake_orders, thus completing the rebalance
    /// Note: It could happen that some users perform delayed-unstake during those epochs, that amount will be preserved in the contract,...
    /// ... because total_unstake_claims has priority over rebalance.
    pub fn do_rebalance_unstake(&mut self) -> bool {
        self.assert_operator_or_owner();

        // check for max x% unstaked
        let max_unstake_for_rebalance = self.max_unstake_for_rebalance() ;

        if self.unstaked_for_rebalance < max_unstake_for_rebalance {

            let unstake_rebalance_left = max_unstake_for_rebalance - self.unstaked_for_rebalance;

            if unstake_rebalance_left >= MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT {
            
                let gspru = self.internal_get_staking_pool_requiring_unstake();
                log!(
                    r#"{{"event":"do_rebal_usntk", "extra":{}, "sp_inx":{}, "totExtra":{}, "unblocked":{}, "with_stake":{}}}"#,
                    gspru.extra/NEAR, gspru.sp_inx, gspru.total_extra/NEAR, gspru.count_unblocked, gspru.count_with_stake
                );
                // continue only if at least 40% of the pools with stake are "unblocked", i.e. not already waiting for unstake-period and so ready for more unstakes.
                // and if amount left for rebalance (total_extra) is more than already unstaked_for_rebalance
                // and if selected sp assigned=0 OR what's to rebalance is at least 0.05% of TFS (if there's some unbalance worth solving)
                if gspru.count_unblocked as u64 >= gspru.count_with_stake as u64 * 40 / 100 && 
                    ( self.staking_pools[gspru.sp_inx as usize].weight_basis_points == 0 || 
                        gspru.total_extra - self.unstaked_for_rebalance > self.total_for_staking / 2000 )
                {
                    let to_unstake_for_rebal = std::cmp::min(gspru.extra, unstake_rebalance_left);
                    // Next call affects:
                    // total_actually_staked, sp.stake & sp.unstake and total_unstaked_and_waiting, 
                    // but it DOES NOT not affect reserve_for_unstake_claims and also DOES NOT change total_for_stake
                    // this means that eventually we will retrieve from the pools, more than required for reserve_for_unstake_claims
                    // at that point, the extra amount is set for restake (see fn retrieve_funds_from_a_pool), completing the rebalance
                    self.perform_unstake(gspru.sp_inx as usize, 0, to_unstake_for_rebal); // unstake for rebalance
                    
                    return unstake_rebalance_left - to_unstake_for_rebal >= MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT; // call again?
                }
            }
        }
        false // default return
    }

    // Operator method, but open to anyone
    /// distribute_unstaking(). Do unstaking
    /// returns "true" if needs to be called again
    pub fn distribute_unstaking(&mut self) -> bool {
        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone

        self.assert_not_busy();
        // clearing first
        self.internal_end_of_epoch_clearing();
        // after clearing, epoch_unstake_orders is the amount to unstake
        // check if the amount justifies tx-fee / can be unstaked really
        // TODO: It's better to move `10 * TGAS as u128` since it's incorrect to compare GAS to NEAR.
        //    GAS has a gas_price, and if gas price goes higher, then the comparison might be out of
        //    date. Since the operator is paying for all gas, it's probably fine to execute anyway.
        if self.epoch_unstake_orders <= 10 * TGAS as u128 {
            return false;
        }

        let mut unstake_from_orders = self.epoch_unstake_orders;
        let mut unstake_from_rebalance = 0;

        // resulting "amount_to_unstake" can be lower than total_to_unstake, according to conditions in get_staking_pool_requiring_unstake 
        let gspru = self.internal_get_staking_pool_requiring_unstake();

        log!(
            r#"{{"event":"sp_has_extra","sp":"{}","amount":"{}"}}"#,
            gspru.sp_inx,
            gspru.extra
        );

        if gspru.extra > 0 {
            if gspru.extra <= self.epoch_unstake_orders {
                unstake_from_orders = gspru.extra // no more than what the pool has extra
            }
            else { // more extra in the sp that the amount ordered
                // check if we can seize this opportunity to also unstake for rebalance
                let max_unstake_for_rebalance = self.max_unstake_for_rebalance();
                if self.unstaked_for_rebalance < max_unstake_for_rebalance {
                    let cap_to_extra_unstake_for_rebalance = max_unstake_for_rebalance - self.unstaked_for_rebalance;
                    if cap_to_extra_unstake_for_rebalance > 1*NEAR {
                        unstake_from_rebalance = std::cmp::min(cap_to_extra_unstake_for_rebalance, gspru.extra - unstake_from_orders);
                    }
                }
            }
        }

        if unstake_from_orders + unstake_from_rebalance > 10 * TGAS as u128 {
            // only if the amount justifies tx-fee
            // most unbalanced pool found & available
            // continue with generating the promise for async cross-contract call to unstake
            self.perform_unstake(gspru.sp_inx as usize, unstake_from_orders, unstake_from_rebalance);
            return self.epoch_unstake_orders > 0; // if needs to be called again
        } else {
            return false;
        }
    }

    // two prev fns continue here
    // execute unstake on sp[inx] by amount
    // if is_rebalance then it does no consider this unstake originated in epoch_unstake_orders
    fn perform_unstake(&mut self, 
        sp_inx: usize, 
        amount_from_unstake_orders: u128, 
        amount_from_rebalance: u128,
    )
    {
        let total_amount = amount_from_unstake_orders + amount_from_rebalance;
        if total_amount == 0 {
            return;
        }
        self.assert_not_busy();

        assert!(self.total_actually_staked >= total_amount, "IUN");
        assert!(sp_inx < self.staking_pools.len(), "invalid index");
        let sp = &mut self.staking_pools[sp_inx];
        assert!(!sp.busy_lock,"sp is busy");
        assert!(
            sp.staked >= total_amount,
            "only {} staked can not unstake {}",
            sp.staked,
            total_amount,
        );
        
        self.contract_busy = true;
        sp.busy_lock = true;

        // preventively consider the amount un-staked (undoes if promise fails)
        self.total_actually_staked -= total_amount;
        self.epoch_unstake_orders -= amount_from_unstake_orders; // preventively consider the unstake_order fulfilled

        //launch async to un-stake from the pool
        ext_staking_pool::unstake(
            total_amount.into(),
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::UNSTAKE,
        )
        .then(ext_self_owner::on_staking_pool_unstake(
            sp_inx,
            amount_from_unstake_orders.into(),
            amount_from_rebalance.into(),
            //extra async call args
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_UNSTAKE,
        ));
    }
    /// The prev fn continues here
    /// Called after the given amount was unstaked at the staking pool contract.
    /// This method needs to update staking pool status.
    #[private]
    pub fn on_staking_pool_unstake(&mut self, 
        sp_inx: usize, 
        amount_from_unstake_orders: U128String, 
        amount_from_rebalance: U128String, 
    ) 
    {
        let sp = &mut self.staking_pools[sp_inx];
        let total_amount = amount_from_unstake_orders.0 + amount_from_rebalance.0;

        let unstake_succeeded = is_promise_success();

        let result: &str;
        if unstake_succeeded {
            result = "succeeded";
            sp.staked -= total_amount;
            sp.unstaked += total_amount;
            sp.unstk_req_epoch_height = env::epoch_height();
            self.total_unstaked_and_waiting += total_amount; // contract total unstaked_and_waiting
            self.unstaked_for_rebalance += amount_from_rebalance.0; // total unstaked_and_waiting for rebalance
            event!(
                r#"{{"event":"unstk","sp":"{}","amount_fuo":"{}","amount_fr":"{}" }}"#,
                sp.account_id,
                amount_from_unstake_orders.0,
                amount_from_rebalance.0
            );
        } else {
            result = "has failed";
            self.total_actually_staked += total_amount; //undo preventive action considering the amount unstaked
            self.epoch_unstake_orders += amount_from_unstake_orders.0; // undo preventive action considering the order fulfilled
        }

        log!("Unstaking of {} at @{} {}", total_amount, sp.account_id, result);

        //WARN: This is a callback after-cross-contract-call method
        //busy locks must be saved false in the state, this method SHOULD NOT PANIC
        sp.busy_lock = false;
        self.contract_busy = false;
    }

    //utility to set contract busy flag manually by operator.
    #[payable]
    pub fn set_busy(&mut self, value: bool) {
        assert_one_yocto();
        self.assert_operator_or_owner();
        assert!(self.contract_busy != value,"contract_busy is already {}",value);
        self.contract_busy = value;
    }
    //operator manual set sp.busy_lock
    #[payable]
    pub fn sp_busy(&mut self, sp_inx: u16, value: bool) {
        assert_one_yocto();
        self.assert_operator_or_owner();

        let inx = sp_inx as usize;
        assert!(inx < self.staking_pools.len());

        let sp = &mut self.staking_pools[inx];
        assert!(sp.busy_lock != value,"sp[{}].busy_lock is already {}",inx,value);
        sp.busy_lock = value;
    }

    //-- check If extra balance has accumulated (30% of tx fees by near-protocol)
    pub fn extra_balance_accumulated(&self) -> U128String {
        return env::account_balance()
            .saturating_sub(self.contract_account_balance)
            .into();
    }

    //-- If extra balance has accumulated (30% of tx fees by near-protocol)
    // transfer to self.operator_account_id
    pub fn transfer_extra_balance_accumulated(&mut self) -> U128String {
        let extra_balance = self.extra_balance_accumulated().0;
        if extra_balance >= ONE_NEAR {
            //only if there's more than one near, and left 10 cents (consider transfer fees)
            Promise::new(self.operator_account_id.clone()).transfer(extra_balance - 10 * NEAR_CENT);
            return extra_balance.into();
        }
        return 0.into();
    }

    //-------------------------
    /// sync_unstaked_balance: should be called before `retrieve_funds_from_a_pool`
    /// when you unstake, core-contracts/staking-pool does some share calculation *rounding*, so the real unstaked amount is not exactly
    /// the same amount requested (a minor, few yoctoNEARS difference)
    /// this fn syncs sp.unstaked with the real, current unstaked amount informed by the sp
    pub fn sync_unstaked_balance(&mut self, sp_inx: u16) -> Promise {
        // Note: We avoid locking the contract here (busy_flag), to close the possibility of someone spamming this method
        //  to prevent operator from issuing a command. Assuming there will be a way to front-run a transaction, it can
        //    block the contract. We do not lock the pool and the contract at all, but if the callback
        //    is called at the moment when the pool or the contract is locked, the result is ignored.

        let inx = sp_inx as usize;
        assert!(inx < self.staking_pools.len());

        self.assert_not_busy();
        let sp = &mut self.staking_pools[inx];
        assert!(!sp.busy_lock, "sp is busy");

        // SUGGESTION: Maybe better to call `get_account` to get information about `staked` and
        //    `unstaked` balance at the same time. Sometimes the staking pool may throw yoctoNEAR
        //    for rounding errors. So in case this pool may accidentally get 1 yocto and then
        //    overflow when subtracting staked from unstaked or vise-versa.

        //query our current unstaked amount
        return ext_staking_pool::get_account_unstaked_balance(
            env::current_account_id(),
            //promise params
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
        )
        .then(ext_self_owner::on_get_sp_unstaked_balance(
            inx,
            //promise params
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_GET_SP_UNSTAKED_BALANCE,
        ));
    }

    /// prev fn continues here - sync_unstaked_balance
    //------------------------------
    #[private]
    pub fn on_get_sp_unstaked_balance(
        &mut self,
        sp_inx: usize,
        #[callback] unstaked_balance: U128String,
    ) {
        // NOTE: be careful on `#[callback]` here. If the pool view call fails for some
        //    reason this call will not be entered, because #[callback] fails for failed_promises
        //    So *never* add a pair of lock/unlock if the callback uses #[callback] params
        //    because the entire contract will be locked until the owner calls make non-busy.
        //    E.g. if owner makes a mistake adding a new pool and adds an invalid pool.

        //we enter here after asking the staking-pool how much do we have *unstaked*
        //unstaked_balance: U128String contains the answer from the staking-pool

        let sp = &mut self.staking_pools[sp_inx];

        // real unstaked amount for this pool
        let real_unstaked_balance: u128 = unstaked_balance.0;

        log!(
            "inx:{} sp:{} old_unstaked_balance:{} new_unstaked_balance:{}",
            sp_inx,
            sp.account_id,
            sp.unstaked,
            real_unstaked_balance
        );
        // we're not locking at the start, so we check there's no in-flight transaction if we need to
        // adjust the unstaked in a few yoctos
        if real_unstaked_balance != sp.unstaked && (self.contract_busy || sp.busy_lock) {
            // do not proceed to update if another operation is in mid-flight
            panic!("cant not update unstaked, contract or sp is busy, another operation is in mid-flight");
        }

        if real_unstaked_balance > sp.unstaked {
            //positive difference
            let difference = real_unstaked_balance - sp.unstaked;
            log!("positive difference {}", difference);
            sp.unstaked = real_unstaked_balance;
            sp.staked = sp.staked.saturating_sub(difference); //the difference was in "our" record of "staked"
        } else if real_unstaked_balance < sp.unstaked {
            //negative difference
            let difference = sp.unstaked - real_unstaked_balance;
            log!("negative difference {}", difference);
            sp.unstaked = real_unstaked_balance;
            sp.staked += difference; //the difference was in "our" record of "staked"
        }
    }

    //------------------------------------------------------------------------
    //-- COMPUTE AND DISTRIBUTE STAKING REWARDS for a specific staking-pool --
    //------------------------------------------------------------------------
    // Operator method, but open to anyone. Should be called once per epoch per sp, after sp rewards distribution (ping)
    /// Ask total balance from the staking pool and remembers it internally.
    /// Also computes and distributes rewards for operator and stakers
    /// this fn queries the staking pool (makes a cross-contract call)
    pub fn distribute_rewards(&mut self, sp_inx: u16) {
        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone
        //self.assert_operator_or_owner();

        self.assert_not_busy();

        let inx = sp_inx as usize;
        assert!(inx < self.staking_pools.len());

        let sp = &mut self.staking_pools[inx];
        assert!(!sp.busy_lock, "sp is busy");

        let epoch_height = env::epoch_height();

        if sp.staked == 0 && sp.unstaked == 0 {
            return;
        }

        if sp.last_asked_rewards_epoch_height == epoch_height {
            return;
        }

        log!(
            "Fetching total balance from the staking pool @{}",
            sp.account_id
        );

        self.contract_busy = true;
        sp.busy_lock = true;

        //query our current balance (includes staked+unstaked+staking rewards)
        ext_staking_pool::get_account_total_balance(
            env::current_account_id(),
            //promise params
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
        )
        .then(ext_self_owner::on_get_sp_total_balance(
            inx,
            //promise params
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_GET_SP_TOTAL_BALANCE,
        ));
    }

    /// prev fn continues here
    /*
    Note: what does the tag #[callback] applied to a fn in parameter do?
    #[callback] parses the previous promise's result into the param
        Check out https://nomicon.io/RuntimeSpec/Components/BindingsSpec/PromisesAPI.html
        1. check promise_results_count() == 1
        2  check the execution status of the first promise and write the result into the register using promise_result(0, register_id) == 1
            Let's say that you used register_id == 0
        3. read register using register_len and read_register into Wasm memory
        4. parse the data using: let total_balance: WrappedBalance = serde_json::from_slice(&buf).unwrap();

    it has be last argument? can you add another argument for the on_xxx callback ?
    before that
    for example:
        /// Called after the request to get the current total balance from the staking pool.
        pub fn on_get_account_total_balance(&mut self, staking_pool_account: AccountId, #[callback] total_balance: WrappedBalance) {
            assert_self();
            self.set_staking_pool_status(TransactionStatus::Idle);
            ...
        and in the call
            ext_staking_pool::get_account_total_balance(
                env::current_account_id(),
                staking_pool_account_id,
                NO_DEPOSIT,
                gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
            )
            .then(ext_self_owner::on_get_account_total_balance(
                staking_pool_account_id,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_GET_ACCOUNT_TOTAL_BALANCE,
            ))

    #[callback] marked-arguments are parsed in order. The position within arguments are not important, but the order is.
    If you have 2 arguments marked as #[callback] then you need to expect 2 promise results joined with promise_and
    */
    #[private]
    pub fn on_get_sp_total_balance(
        &mut self,
        sp_inx: usize,
        #[callback] total_balance: U128String,
    ) {
        //we enter here after asking the staking-pool how much do we have staked (plus rewards)
        //total_balance: U128String contains the answer from the staking-pool

        //new_total_balance has the new staked amount for this pool
        let new_total_balance: u128;
        let sp = &mut self.staking_pools[sp_inx];

        //WARN: This is a callback after-cross-contract-call method
        //busy locks must be saved false in the state, this method SHOULD NOT PANIC
        sp.busy_lock = false;
        self.contract_busy = false;

        sp.last_asked_rewards_epoch_height = env::epoch_height();

        //total_balance informed is staking-pool.staked + staking-pool.unstaked
        new_total_balance = total_balance.0;

        let rewards: u128;
        if new_total_balance < sp.total_balance() {
            log!(
                "INCONSISTENCY @{} says new_total_balance < our info sp.total_balance()",
                sp.account_id
            );
            rewards = 0;
        } else {
            //compute rewards, as new balance minus old balance
            rewards = new_total_balance - sp.total_balance();
        }

        log!(
            "sp:{} old_balance:{} new_balance:{} rewards:{} unstaked:{}",
            sp.account_id,
            sp.total_balance(),
            new_total_balance,
            rewards,
            sp.unstaked
        );

        //updated accumulated_staked_rewards value for the contract
        self.accumulated_staked_rewards += rewards;
        //updated new "staked" value for this pool
        sp.staked = new_total_balance - sp.unstaked;

        if rewards > 0 {
            //add to total_for_staking & total_actually_staked, increasing share value for all stNEAR holders
            self.total_actually_staked += rewards;
            self.total_for_staking += rewards;

            // mint extra stNEAR representing fees for operator & developers
            // The fee the operator takes from rewards (0.5%)
            let operator_fee = apply_pct(self.operator_rewards_fee_basis_points, rewards);
            let operator_fee_shares = self.stake_shares_from_amount(operator_fee);
            // The fee the contract authors take from rewards (0.2%)
            let developers_fee = apply_pct(DEVELOPERS_REWARDS_FEE_BASIS_POINTS, rewards);
            let developers_fee_shares = self.stake_shares_from_amount(developers_fee);
            // Now add the newly minted shares. The fee is taken by making share price increase slightly smaller
            self.add_extra_minted_shares(self.operator_account_id.clone(), operator_fee_shares);
            self.add_extra_minted_shares(DEVELOPERS_ACCOUNT_ID.into(), developers_fee_shares);

        }
    }

    //----------------------------------------------------------------------
    // Operator method, but open to anyone
    //----------------------------------------------------------------------
    /// finds a pool with the unstake delay completed and some unstake ready for retrieve
    /// Returns `sp_index` or:
    /// -1 if there are funds ready to retrieve but the pool is busy
    /// -2 if there are funds unstaked, but not ready in this epoch
    /// -3 if there are no unstaked funds
    pub fn get_staking_pool_requiring_retrieve(&self) -> i32 {
        let mut not_found_result_code: i32 = -3;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            if sp.unstaked > 0 {
                if not_found_result_code == -3 {
                    not_found_result_code = -2
                };
                if sp.wait_period_ended() {
                    if not_found_result_code == -2 {
                        not_found_result_code = -1
                    };
                    if !sp.busy_lock {
                        // if this pool has unstaked and the waiting period has ended
                        return sp_inx as i32;
                    }
                }
            }
        }
        return not_found_result_code;
    }

    // Operator method, but open to anyone
    //----------------------------------------------------------------------
    //  WITHDRAW FROM ONE OF THE POOLS ONCE THE WAITING PERIOD HAS ELAPSED
    //----------------------------------------------------------------------
    /// launches a withdrawal call
    /// returns the amount withdrawn
    /// you MUST call get_staking_pool_requiring_retrieve() first, to obtain a valid inx
    /// and you MUST call sync_unstaked_balance(inx) before this, to get the exact amount to the yocto stored in sp.unstaked
    pub fn retrieve_funds_from_a_pool(&mut self, inx: u16) -> Promise {
        //Note: In order to make fund-recovering independent from the operator
        //this fn is open to be called by anyone

        assert!(inx < self.staking_pools.len() as u16, "invalid index");

        self.assert_not_busy();

        let sp = &mut self.staking_pools[inx as usize];
        assert!(!sp.busy_lock, "sp is busy");
        assert!(sp.unstaked > 0, "sp unstaked == 0");
        if !sp.wait_period_ended() {
            panic!(
                "unstaking-delay ends at {}, now is {}",
                sp.unstk_req_epoch_height + NUM_EPOCHS_TO_UNLOCK,
                env::epoch_height()
            );
        }

        // if we're here, the pool is not busy, and we unstaked and the waiting period has elapsed

        self.contract_busy = true;
        sp.busy_lock = true;

        //return promise
        return ext_staking_pool::withdraw_all(
            //promise params:
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::WITHDRAW,
        )
        .then(ext_self_owner::on_retrieve_from_staking_pool(
            inx,
            //promise params:
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_WITHDRAW,
        ));
    }
    //prev fn continues here
    /// This method needs to update staking pool busyLock
    #[private]
    pub fn on_retrieve_from_staking_pool(&mut self, inx: u16) -> U128String {

        let sp = &mut self.staking_pools[inx as usize];
        let sp_account_id = sp.account_id.clone();
        let amount = sp.unstaked; // we retrieved all

        //WARN: This is a callback after-cross-contract-call method
        //busy locks must be saved false in the state, this method SHOULD NOT PANIC
        sp.busy_lock = false;
        self.contract_busy = false;

        let retrieve_succeeded = is_promise_success();

        let result: &str;
        let retrieved_amount: u128;
        if retrieve_succeeded {
            result = "succeeded";
            retrieved_amount = amount;
            sp.unstaked -= amount; // is no longer in the pool as "unstaked"
            self.total_unstaked_and_waiting = // contract total_unstaked_and_waiting decremented...
                self.total_unstaked_and_waiting.saturating_sub(amount); // ... because is no longer waiting
            self.contract_account_balance += amount; // the amount is now in the contract balance
            //log event
            event!(
                r#"{{"event":"retrieve","sp":"{}","amount":"{}"}}"#,
                sp_account_id,
                amount
            );
            // the amount retrieved should be considered "retrieved_for_unstake_claims" until the user calls withdraw_unstaked
            self.consider_retrieved_for_unstake_claims(amount);

        } else {
            result = "has failed";
            retrieved_amount = 0;
        }
        log!(
            "The withdrawal of {} from @{} {}",
            amount,
            sp_account_id,
            result
        );

        return retrieved_amount.into();
    }

    // Operator method, but open to anyone. No need to be called, is auto called before distribute stake/unstake
    //----------------------------------------------------------------------
    // End of Epoch clearing of STAKE_ORDERS vs UNSTAKE_ORDERS
    //----------------------------------------------------------------------
    // At the end of the epoch, only the delta between stake & unstake orders needs to be actually staked
    // if there are more in the stake orders than the unstake orders, some NEAR will not be sent to the pools
    // e.g. stake-orders: 1200, unstake-orders:1000 => net: stake 200 and keep 1000 to fulfill unstake claims after 4 epochs.
    // if there was more in the unstake orders than in the stake orders, a real unstake was initiated with one or more pools,
    // the rest should also be kept to fulfill unstake claims after 4 epochs.
    // e.g. stake-orders: 700, unstake-orders:1000 => net: start-unstake 300 and keep 700 to fulfill unstake claims after 4 epochs
    // if the delta is 0, there's no real stake-unstake, but the amount should be kept to fulfill unstake claims after 4 epochs
    // e.g. stake-orders: 500, unstake-orders:500 => net: 0 so keep 500 to fulfill unstake claims after 4 epochs.
    //
    pub fn end_of_epoch_clearing(&mut self) {
        self.internal_end_of_epoch_clearing() 
    }

    /// compute max cap for the unstakes-for-rebalance
    /// default unstake_for_rebalance_cap_bp = 100, so max_unstake_for_rebalance = 1%
    fn max_unstake_for_rebalance(&self) -> u128 {
        apply_pct(self.unstake_for_rebalance_cap_bp, self.total_for_staking)
    }

}

'''
'''--- metapool/src/empty_nep_145.rs ---
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, near_bindgen};

use crate::*;

// --------------------------------------------------------------------------
// Storage Management
// --------------------------------------------------------------------------
pub const STORAGE_COST_YOCTOS: u128 = ONE_NEAR / 100_000 * 125;
// storage is fixed, if the account is registered, STORAGE_COST_YOCTOS was received, 
// when the account is unregistered, STORAGE_COST_YOCTOS are returned 

#[near_bindgen]
impl MetaPool {
    // `registration_only` doesn't affect the implementation for vanilla fungible token.
    #[allow(unused_variables)]
    #[payable]
    pub fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // get account_id
        let account_id:String = if account_id.is_some() {account_id.unwrap().into()} else {env::predecessor_account_id()};
        let opt_account = self.accounts.get(&account_id);
        // if account already exists, no more yoctos required
        let required = if opt_account.is_some() {
            0
        } 
        else {
            // create empty account, require the yoctos
            self.accounts.insert(&account_id, &Account::default());
            STORAGE_COST_YOCTOS
        };
        assert!(env::attached_deposit() >= required, "not enough attached for storage");
        // if user sent more than required, return it, keep only required
        if env::attached_deposit() > required {
            Promise::new(env::predecessor_account_id()).transfer(env::attached_deposit() - required);
        }
        // return current balance state
        StorageBalance {
            total: U128::from(STORAGE_COST_YOCTOS),
            available: U128::from(0),
        }
    }

    /// storage cost is fixed, excess amount is always 0, no storage_withdraw possible 
    #[allow(unused_variables)]
    pub fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        panic!("storage excess amount is 0");
    }

    #[allow(unused_variables)]
    #[payable]
    pub fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        if let Some(account) = self.accounts.get(&env::predecessor_account_id()) {
            // account exists
            if !account.can_be_closed() {
                panic!("cannot close account with balance in stNEAR or LP-NEAR-stNEAR");
            }
            // remove account, make sure something is removed
            assert!(
                self.accounts.remove(&env::predecessor_account_id()).is_some()
                ,"INCONSISTENCY - account does not exists now"
            );
            // return storage yoctos
            Promise::new(env::predecessor_account_id()).transfer(STORAGE_COST_YOCTOS);
        };
        true
    }

    // max & min total storage balance
    pub fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128::from(STORAGE_COST_YOCTOS),
            max: Some(U128::from(STORAGE_COST_YOCTOS))
        }
    }

    pub fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        if self.account_exists(&account_id.into()) {
            // if account exists
            Some(StorageBalance {
                total: U128::from(STORAGE_COST_YOCTOS),
                available: U128::from(0),
            })
        }
        else { 
            None
        }
    }
}

'''
'''--- metapool/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;

use near_sdk::env;
use near_sdk::serde_json;
use near_sdk::AccountId;

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::panic(b"serde-json"))
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        env::log(self.to_json_event_string().as_bytes());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

/// Data to log for an FT burn event. To log this event, call [`.emit()`](FtBurn::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtBurn<'a> {
    pub owner_id: &'a AccountId,
    pub amount: U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtBurn<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT burn event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtBurn`] represents the data of each burn.
    pub fn emit_many<'a>(data: &'a [FtBurn<'a>]) {
        new_141_v1(Nep141EventKind::FtBurn(data)).emit()
    }
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
    FtBurn(&'a [FtBurn<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}

'''
'''--- metapool/src/fungible_token_standard.rs ---
use near_contract_standards::fungible_token::{
    core::FungibleTokenCore,
    metadata::{FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC},
    resolver::FungibleTokenResolver,
};

use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, Gas, PromiseOrValue
};

use crate::*;

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

const GAS_FOR_FT_TRANSFER_CALL: Gas = 30_000_000_000_000;
const GAS_FOR_RESOLVE_TRANSFER: Gas = 11_000_000_000_000;
const FIVE_TGAS: Gas = 5_000_000_000_000;
const ONE_TGAS: Gas = 1_000_000_000_000;

const NO_DEPOSIT: Balance = 0;

fn ft_metadata_default() -> FungibleTokenMetadata {
    FungibleTokenMetadata {
        spec: FT_METADATA_SPEC.to_string(),
        name: "Staked NEAR".to_string(),
        symbol: "STNEAR".to_string(),
        icon: Some(r#"data:image/svg+xml,%3csvg width='96' height='96' viewBox='0 0 96 96' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='96' height='96' rx='48' fill='white'/%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M48.0006 20L41.2575 26.7431L48.0006 33.4862L54.7437 26.7431L48.0006 20ZM37.281 30.7188L30.7144 37.2853L47.9998 54.5707L65.2851 37.2853L58.7186 30.7188L47.9998 41.4376L37.281 30.7188ZM26.7384 41.261L19.9953 48.0041L47.9995 76.0083L76.0037 48.0041L69.2606 41.2611L47.9995 62.5221L26.7384 41.261Z' fill='%23231B51'/%3e%3c/svg%3e"#.into()),
        reference: Some("https://metapool.app".into()), 
        reference_hash: None,
        decimals: 24,
    }
}
fn ft_metadata_init_lazy_container() -> LazyOption<FungibleTokenMetadata> {
    let metadata: LazyOption<FungibleTokenMetadata>;
    metadata = LazyOption::new(b"ftmd".to_vec(), None);
    return metadata;
}

#[near_bindgen]
impl FungibleTokenCore for MetaPool {
    //NEP-141 for default token STNEAR, ft_transfer
    /// Transfer `amount` of tokens from the caller of the contract (`predecessor_id`) to a contract at `receiver_id`.
    /// Requirements:
    /// * receiver_id must be a contract and must respond to `ft_on_transfer(&mut self, sender_id: AccountId, amount: U128String, _msg: String ) -> PromiseOrValue<U128>`
    /// * if receiver_id is not a contract or `ft_on_transfer` fails, the transfer is rolled-back
    #[payable]
    fn ft_transfer(
        &mut self,
        receiver_id: ValidAccountId, // ValidAccountId does not adds gas consumption
        amount: U128,
        #[allow(unused)] memo: Option<String>,
    ) {
        assert_one_yocto();
        //log!("env::storage_byte_cost {}",env::storage_byte_cost());
        //log!("env::storage_usage {}",env::storage_usage());
        self.internal_st_near_transfer(
            &env::predecessor_account_id(),
            &receiver_id.into(),
            amount.0,
            memo.as_deref(),
        );
        //log!("env::storage_usage {}",env::storage_usage());
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        #[allow(unused)] memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_one_yocto();
        assert!(
            env::prepaid_gas() > GAS_FOR_FT_TRANSFER_CALL + GAS_FOR_RESOLVE_TRANSFER + FIVE_TGAS,
            "gas required {}",
            GAS_FOR_FT_TRANSFER_CALL + GAS_FOR_RESOLVE_TRANSFER + FIVE_TGAS
        );

        let receiver_id: String = receiver_id.into();
        self.internal_st_near_transfer(
            &env::predecessor_account_id(),
            &receiver_id,
            amount.0,
            memo.as_deref(),
        );

        //TODO add a busy lock to avoid the sender-acc to be deleted
        //while this txn is executing
        //self.busy = true;

        ext_ft_receiver::ft_on_transfer(
            env::predecessor_account_id(),
            amount,
            msg,
            //promise params:
            &receiver_id, //contract
            NO_DEPOSIT,   //attached native NEAR amount
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL - GAS_FOR_RESOLVE_TRANSFER - ONE_TGAS, // set almost all remaining gas for ft_on_transfer
        )
        .then(ext_self::ft_resolve_transfer(
            env::predecessor_account_id(),
            receiver_id,
            amount,
            //promise params:
            &env::current_account_id(), //contract
            NO_DEPOSIT,                 //attached native NEAR amount
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()
    }

    //stNEAR total supply
    fn ft_total_supply(&self) -> U128 {
        self.total_stake_shares.into()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        if let Some(acc) = self.accounts.get(&account_id.into()) {
            acc.stake_shares.into()
        }
        else {
            0.into()
        }
    }
}

#[near_bindgen]
impl FungibleTokenResolver for MetaPool {
    /// Returns the amount of burned tokens in a corner case when the sender
    /// has deleted (unregistered) their account while the `ft_transfer_call` was still in flight.
    /// Returns (Used token amount, Burned token amount)
    #[private]
    fn ft_resolve_transfer(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> U128 {
        let sender_id: AccountId = sender_id.into();
        let (used_amount, burned_amount) =
            self.int_ft_resolve_transfer(&sender_id, receiver_id, amount);
        if burned_amount > 0 {
            log!("{} tokens burned", burned_amount);
        }
        return used_amount.into();
    }
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for MetaPool {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        let metadata = ft_metadata_init_lazy_container();
        //load from storage or return default
        return metadata.get().unwrap_or(ft_metadata_default());
    }
}

#[near_bindgen]
impl MetaPool {
    pub fn ft_metadata_set(&self, data: FungibleTokenMetadata) {
        self.assert_owner_calling();
        let mut metadata = ft_metadata_init_lazy_container();
        metadata.set(&data); //save into storage
    }
}

'''
'''--- metapool/src/gas.rs ---
pub const TGAS: u64 = 1_000_000_000_000;
pub const BASE_GAS: u64 = 25 * TGAS;

pub mod whitelist {
    /// Gas attached to the promise to check whether the given staking pool Account ID is
    /// whitelisted.
    /// Requires BASE (no external calls).
    pub const IS_WHITELISTED: u64 = super::BASE_GAS;
}

pub mod staking_pool {
    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + BASE potentially re-stake.
    pub const DEPOSIT: u64 = super::BASE_GAS * 2;

    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + 2 * BASE for staking call.
    pub const DEPOSIT_AND_STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to withdraw call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for transferring amount to us and potentially re-stake.
    pub const WITHDRAW: u64 = super::BASE_GAS * 3;

    /// Gas attached to stake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake all call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE_ALL: u64 = super::BASE_GAS * 3;

    /// The amount of gas required to get the current staked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_STAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get current unstaked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_UNSTAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get the current total balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_TOTAL_BALANCE: u64 = super::BASE_GAS;
}

pub mod transfer_poll {
    /// Gas attached to the promise to check whether transfers were enabled on the transfer poll
    /// contract.
    /// Requires BASE (no external calls).
    pub const GET_RESULT: u64 = super::BASE_GAS;
}

pub mod owner_callbacks {
    /// Gas attached to the inner callback for processing whitelist check results.
    /// Requires BASE for local execution.
    pub const ON_WHITELIST_IS_WHITELISTED: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit and stake call to
    /// the staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT_AND_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the withdraw call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_WITHDRAW: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the stake call to the
    /// staking pool.
    pub const ON_STAKING_POOL_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_UNSTAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake all call to the
    /// staking pool.
    /// Requires BASE for local updates.
    //pub const ON_STAKING_POOL_UNSTAKE_ALL: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the checking result for
    /// transfer voting call to the voting contract.
    /// Requires BASE for local updates.
    pub const ON_VOTING_GET_RESULT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the call to get the current total balance from the staking pool.
    pub const ON_GET_SP_TOTAL_BALANCE: u64 = super::BASE_GAS * 5; //because distributes realized rewards to author and owner

    /// Gas attached to the inner callback for sync_unstaked_balance to get precise unstaked balance from the staking pool.
    pub const ON_GET_SP_UNSTAKED_BALANCE: u64 = super::BASE_GAS; // just update unstaked amount (yocto differences)

    /// Gas attached to the inner callback for processing result of the call to get the current
    /// unstaked balance from the staking pool.
    /// The callback might proceed with withdrawing this amount.
    /// Requires BASE for local updates + gas for withdraw + gas for another callback.
    pub const ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW_BY_OWNER: u64 =
        super::BASE_GAS + super::staking_pool::WITHDRAW + ON_STAKING_POOL_WITHDRAW;
}

'''
'''--- metapool/src/internal.rs ---
pub use crate::types::*;
pub use crate::utils::*;
use crate::{empty_nep_145::STORAGE_COST_YOCTOS, *};
use near_sdk::{
    json_types::{ValidAccountId, U128},
    log, AccountId, Balance, Promise, PromiseResult,
};

const UNSTAKED_YOCTOS_TO_IGNORE: u128 = 100;

pub struct GSPRUResult {
    pub sp_inx: u16,
    pub extra: u128,
    pub count_unblocked: u16,
    pub count_with_stake: u16,
    pub total_extra: u128,
}

/****************************/
/* general Internal methods */
/****************************/
impl MetaPool {
    /// Asserts that the method was called by the owner.
    pub fn assert_owner_calling(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_account_id,
            "Can only be called by the owner"
        )
    }
    pub fn assert_operator_or_owner(&self) {
        assert!(
            &env::predecessor_account_id() == &self.owner_account_id
                || &env::predecessor_account_id() == &self.operator_account_id,
            "Can only be called by the operator or the owner"
        );
    }

    pub fn assert_not_busy(&self) {
        assert!(!self.contract_busy, "Contract is busy. Try again later");
    }

    pub fn assert_min_deposit_amount(&self, amount: u128) {
        assert!(
            amount >= self.min_deposit_amount,
            "minimum deposit amount is {}",
            self.min_deposit_amount
        );
    }
}

/***************************************/
/* Internal methods staking-pool trait */
/***************************************/
impl MetaPool {
    pub(crate) fn internal_deposit(&mut self, account_id: &String) -> u128 {
        self.assert_min_deposit_amount(env::attached_deposit());
        self.internal_deposit_attached_near_into(account_id)
    }

    // adds env::attached_deposit() to account.available
    // if it is a new account, takes STORAGE_COST_YOCTOS as storage_deposit
    pub(crate) fn internal_deposit_attached_near_into(&mut self, account_id: &String) -> u128 {
        let opt_account = self.accounts.get(&account_id);
        let amount = if opt_account.is_none() {
            // account does not exists
            // take some yoctos as storage deposit - the user can recover that amount when closing the account
            log!(
                "new account, {} yoctos used for storage_deposit",
                STORAGE_COST_YOCTOS
            );
            assert!(
                env::attached_deposit() > STORAGE_COST_YOCTOS,
                "deposit too low"
            );
            env::attached_deposit() - STORAGE_COST_YOCTOS
        } else {
            // account already exists, use full amount
            env::attached_deposit()
        };
        let mut account = opt_account.unwrap_or_default();

        account.available += amount;
        self.total_available += amount;
        self.contract_account_balance += amount;

        self.internal_update_account(&account_id, &account);

        log!(
            "{} deposited into @{}'s account. New available balance is {}",
            amount,
            account_id,
            account.available
        );
        amount
    }

    //------------------------------
    // MIMIC staking-pool, if there are unstaked, it must be free to withdraw
    pub(crate) fn internal_withdraw_use_unstaked(
        &mut self,
        account_id: &String,
        requested_amount: u128,
    ) -> Promise {
        let mut account = self.internal_get_account(&account_id);

        //MIMIC staking-pool, move 1st form unstaked->available, it must be free to withdraw
        account.in_memory_try_finish_unstaking(&account_id, requested_amount, self);

        // NOTE: While ability to withdraw close to all available helps, it prevents lockup contracts from using this in a replacement to a staking pool,
        // because the lockup contracts relies on exact precise amount being withdrawn.
        let amount = account.take_from_available(account_id, requested_amount, self);

        //commented: Remove min_account_balance requirements, increase liq-pool target to cover all storage requirements
        //2 reasons: a) NEAR storage was cut by 10x  b) in the simplified flow, users do not keep "available" balance
        // assert!( !acc.is_empty() || acc.available >= self.min_account_balance,
        //     "The min balance for an open account is {} NEAR. You need to close the account to remove all funds",
        //     self.min_account_balance/NEAR);

        self.internal_update_account(&account_id, &account);
        //transfer to user native near account
        self.native_transfer(account_id, amount)
    }
    pub(crate) fn native_transfer(&mut self, account_id: &String, amount: u128) -> Promise {
        //transfer to user native near account
        self.contract_account_balance -= amount;
        Promise::new(account_id.clone()).transfer(amount)
    }

    //------------------------------
    /// takes from account.available and mints stNEAR for account_id
    /// actual stake in a staking-pool is made by the meta-pool-heartbeat before the end of the epoch
    /// account_id must be registered
    pub(crate) fn internal_stake_from_account(
        &mut self,
        account_id: &String,
        near_amount: Balance,
    ) -> u128 {
        self.assert_not_busy();

        assert!(
            near_amount >= self.min_deposit_amount.saturating_sub(STORAGE_COST_YOCTOS),
            "min deposit amount is {}",
            self.min_deposit_amount
        );

        let mut acc = self.internal_get_account(&account_id);

        // take from the account "available" balance
        // also subs self.total_available
        let amount = acc.take_from_available(&account_id, near_amount, self);

        // Calculate the number of st_near (stake shares) that the account will receive for staking the given amount.
        let num_shares = self.stake_shares_from_amount(amount);
        assert!(num_shares > 0);

        //add shares to user account
        acc.add_stake_shares(num_shares, amount);
        //contract totals
        self.total_stake_shares += num_shares;
        self.total_for_staking += amount;
        self.epoch_stake_orders += amount;

        //--SAVE ACCOUNT--
        self.internal_update_account(&account_id, &acc);

        //log event
        event!(
            r#"{{"event":"STAKE","account":"{}","amount":"{}"}}"#,
            account_id,
            amount
        );
        num_shares
    }

    //------------------------------
    /// delayed_unstake, amount_requested is in yoctoNEARs
    pub(crate) fn internal_unstake(&mut self, account_id: &String, amount_requested: u128) {
        self.assert_not_busy();

        let mut acc = self.internal_get_account(&account_id);

        // compute how much shares it will be
        let shares_from_requested = self.stake_shares_from_amount(amount_requested);

        let stake_shares_to_burn: u128 =
        // if the amount is close to user's total, remove user's total
        // to: a) do not leave less than 1/1000 NEAR in the account, b) Allow 10 yoctos of rounding, e.g. remove(100) removes 99.999993 without panicking
        if is_close(acc.stake_shares, shares_from_requested) {
            // allow for rounding simplification
            acc.stake_shares // close enough to all shares, burn all shares (avoid leaving "dust")
        } else {
            // use amount_requested
            shares_from_requested
        };
        self.internal_unstake_shares(account_id, &mut acc, stake_shares_to_burn);

        events::FtBurn {
            owner_id: &account_id,
            amount: stake_shares_to_burn.into(),
            memo: None
        }
        .emit();

    }

    pub(crate) fn internal_unstake_shares(
        &mut self,
        account_id: &String,
        acc: &mut Account,
        stake_shares_to_burn: u128,
    ) -> (u128, u64) {
        self.assert_not_busy();
        assert!(stake_shares_to_burn > 0 && stake_shares_to_burn <= acc.stake_shares);
        //remove acc stake shares
        let amount_to_unstake = self.amount_from_stake_shares(stake_shares_to_burn);
        acc.sub_stake_shares(stake_shares_to_burn, amount_to_unstake);
        //the amount is now "unstaked", i.e. the user has a claim to this amount, 4-8 epochs form now
        acc.unstaked += amount_to_unstake;
        acc.unstaked_requested_unlock_epoch =
            env::epoch_height() + self.internal_compute_current_unstaking_delay(amount_to_unstake); //when the unstake will be available
                                                                                                    //--contract totals
        self.epoch_unstake_orders += amount_to_unstake;
        self.total_unstake_claims += amount_to_unstake;
        self.total_stake_shares -= stake_shares_to_burn; //burn
        self.total_for_staking -= amount_to_unstake;

        //--SAVE ACCOUNT--
        self.internal_update_account(&account_id, acc);

        event!(
            r#"{{"event":"D-UNSTK","account_id":"{}","amount":"{}","shares":"{}"}}"#,
            account_id,
            amount_to_unstake,
            stake_shares_to_burn
        );

        log!(
            "@{} unstaked {}. Has now {} unstaked and {} stNEAR. Epoch:{}",
            account_id,
            amount_to_unstake,
            acc.unstaked,
            acc.stake_shares,
            env::epoch_height()
        );
        // return unstaked_requested_unlock_epoch
        (amount_to_unstake, acc.unstaked_requested_unlock_epoch)
    }

    //--------------------------------------------------
    /// adds liquidity from deposited amount
    /// account mus be registered previously
    pub(crate) fn internal_nslp_add_liquidity(
        &mut self,
        account_id: &String,
        amount_requested: u128,
    ) -> u16 {
        self.assert_not_busy();

        let mut acc = self.internal_get_account(&account_id);

        //take from the account "available" balance
        let amount = acc.take_from_available(account_id, amount_requested, self);

        //get NSLP account
        let mut nslp_account = self.internal_get_nslp_account();

        // Calculate the number of "nslp" shares the account will receive for adding the given amount of near liquidity
        let num_shares = self.nslp_shares_from_amount(amount, &nslp_account);
        assert!(num_shares > 0);

        //register added liquidity to compute rewards correctly
        acc.lp_meter.stake(amount);

        //update user account
        acc.nslp_shares += num_shares;
        //update NSLP account & main
        nslp_account.available += amount;
        self.total_available += amount;
        nslp_account.nslp_shares += num_shares; //total nslp shares

        //compute the % the user now owns of the Liquidity Pool (in basis points)
        let result_bp = proportional(10_000, acc.nslp_shares, nslp_account.nslp_shares) as u16;

        //--SAVE ACCOUNTS
        self.internal_update_account(&account_id, &acc);
        self.internal_save_nslp_account(&nslp_account);

        event!(
            r#"{{"event":"ADD.L","account_id":"{}","amount":"{}"}}"#,
            account_id,
            amount
        );

        return result_bp;
    }

    //--------------------------------------------------
    /// computes unstaking delay on current situation
    pub fn internal_compute_current_unstaking_delay(&self, amount: u128) -> u64 {
        let mut total_staked: u128 = 0;
        let mut normal_wait_staked_available: u128 = 0;
        for (_, sp) in self.staking_pools.iter().enumerate() {
            //if the pool has no unstaking in process
            total_staked += sp.staked;
            if !sp.busy_lock && sp.staked > 0 && sp.wait_period_ended() {
                normal_wait_staked_available += sp.staked;
                if normal_wait_staked_available > amount {
                    return NUM_EPOCHS_TO_UNLOCK;
                }
            }
        }
        if total_staked == 0 {
            //initial stake, nothing staked, someone delay-unstaking in contract epoch 0
            return NUM_EPOCHS_TO_UNLOCK;
        };
        //all pools are in unstaking-delay, it will take double the time
        return 2 * NUM_EPOCHS_TO_UNLOCK;
    }

    //--------------------------------
    // fees are extracted by minting a small amount of extra stNEAR
    // this fn MUST NOT PANIC (is called from a callback clearing busy flags)
    pub(crate) fn add_extra_minted_shares(&mut self, account_id: AccountId, num_shares: u128) {
        if num_shares > 0 {
            // used only for operator & DEVELOPERS_ACCOUNT
            // use accounts.unwrap_or_default to not panic and also
            // create account if needed (for tests and first usage after init)
            let account = &mut self.accounts.get(&account_id).unwrap_or_default();
            account.stake_shares += num_shares;
            self.internal_update_account(&account_id, &account);
            // Increasing the total amount of stake shares (reduces price)
            self.total_stake_shares += num_shares;
        }
    }

    /// Returns the number of stNEAR (stake shares) corresponding to the given near amount at current stNEAR price
    /// if the amount & the shares are incorporated, price remains the same
    pub(crate) fn stake_shares_from_amount(&self, amount: Balance) -> u128 {
        return shares_from_amount(amount, self.total_for_staking, self.total_stake_shares);
    }

    /// Returns the amount corresponding to the given number of stNEAR (stake shares).
    pub(crate) fn amount_from_stake_shares(&self, num_shares: u128) -> u128 {
        return amount_from_shares(num_shares, self.total_for_staking, self.total_stake_shares);
    }

    //-----------------------------
    // NSLP: NEAR/stNEAR Liquidity Pool
    //-----------------------------

    // NSLP shares are trickier to compute since the NSLP itself can have stNEAR
    pub(crate) fn nslp_shares_from_amount(&self, amount: u128, nslp_account: &Account) -> u128 {
        let total_pool_value: u128 =
            nslp_account.available + self.amount_from_stake_shares(nslp_account.stake_shares);
        return shares_from_amount(amount, total_pool_value, nslp_account.nslp_shares);
    }

    // NSLP shares are trickier to compute since the NSLP itself can have stNEAR
    pub(crate) fn amount_from_nslp_shares(&self, num_shares: u128, nslp_account: &Account) -> u128 {
        let total_pool_value: u128 =
            nslp_account.available + self.amount_from_stake_shares(nslp_account.stake_shares);
        return amount_from_shares(num_shares, total_pool_value, nslp_account.nslp_shares);
    }

    //----------------------------------
    // The LP acquires stNEAR providing the liquid-unstake service
    // The LP needs to remove stNEAR automatically, to recover liquidity and to keep a low fee
    // The LP can recover near by internal clearing.
    // returns true if it used internal clearing
    // ---------------------------------
    pub(crate) fn nslp_try_internal_clearing(&mut self, staked_amount: u128) -> bool {
        // the user has just staked staked_amount of NEAR, they got stNEAR already
        let mut nslp_account = self.internal_get_nslp_account();
        log!(
            "nslp internal clearing nslp_account.stake_shares {}",
            nslp_account.stake_shares
        );
        // should not happen
        assert!(
            self.epoch_stake_orders >= staked_amount,
            "ERR in nslp_try_internal_clearing"
        );

        if nslp_account.stake_shares > 0 {
            //how much stNEAR do the nslp has?
            let valued_stake_shares = self.amount_from_stake_shares(nslp_account.stake_shares);
            //how much can we liquidate?
            let (st_near_to_sell, near_value) = if staked_amount >= valued_stake_shares {
                (nslp_account.stake_shares, valued_stake_shares) //all of them
            } else {
                (self.stake_shares_from_amount(staked_amount), staked_amount) //the amount recently staked
            };

            log!("NSLP clearing {} {}", st_near_to_sell, near_value);
            //log event
            event!(
                r#"{{"event":"NSLP.clr","shares":"{}","amount":"{}"}}"#,
                st_near_to_sell,
                near_value
            );

            // users made a deposit+mint, and now we need to convert that into a 0-fee swap NEAR<->stNEAR
            // we take NEAR from the contract, but let the users keep their minted stNEAR
            // we also burn liq-pool's stNEAR compensating the mint,
            // so the users' "deposit+mint" gets converted to a "send NEAR to the liq-pool, get stNEAR"
            self.total_for_staking -= near_value; // nslp gets the NEAR
            self.epoch_stake_orders -= near_value; // (also reduce epoch stake orders, that was incremented by user stake action)
            nslp_account.available += near_value; // nslp has more available now
            self.total_available += near_value; // which must be reflected in contract totals

            nslp_account.sub_stake_shares(st_near_to_sell, near_value); //nslp delivers stNEAR in exchange for the NEAR
            self.total_stake_shares -= st_near_to_sell; //we burn them (but the users keep the ones we minted earlier)
                                                        //save nslp account
            self.internal_save_nslp_account(&nslp_account);

            return true;
        }
        return false;
    }

    /// computes swap_fee_basis_points for NEAR/stNEAR Swap based on NSLP Balance
    pub(crate) fn internal_get_discount_basis_points(
        &self,
        available_near: u128,
        nears_requested: u128,
    ) -> u16 {
        log!(
            "get_discount_basis_points available_near={}  max_nears_to_pay={}",
            available_near,
            nears_requested
        );

        if available_near <= nears_requested {
            return self.nslp_max_discount_basis_points;
        }
        //amount after the swap
        let near_after = available_near - nears_requested;
        if near_after >= self.nslp_liquidity_target {
            //still >= target
            return self.nslp_min_discount_basis_points;
        }

        //linear curve from max to min on target
        let range = self.nslp_max_discount_basis_points - self.nslp_min_discount_basis_points;
        //here 0<near_after<self.nslp_liquidity_target, so 0<proportional_bp<range
        let proportional_bp = proportional(range as u128, near_after, self.nslp_liquidity_target);

        return self.nslp_max_discount_basis_points - proportional_bp as u16;
    }

    /// NEAR/stNEAR SWAP functions
    /// return how much NEAR you can get by selling x stNEAR
    pub(crate) fn internal_get_near_amount_sell_stnear(
        &self,
        available_near: u128,
        st_near_to_sell: u128,
    ) -> u128 {
        //compute how many nears are the st_near valued at
        let nears_out = self.amount_from_stake_shares(st_near_to_sell);
        let swap_fee_basis_points =
            self.internal_get_discount_basis_points(available_near, nears_out);
        assert!(swap_fee_basis_points < 10000, "inconsistency d>1");
        let fee = apply_pct(swap_fee_basis_points, nears_out);
        return (nears_out - fee).into(); //when stNEAR is sold user pays a swap fee (the user skips the waiting period)

        // env::log(
        //     format!(
        //         "@{} withdrawing {}. New unstaked balance is {}",
        //         account_id, amount, account.unstaked
        //     )
        //     .as_bytes(),
        // );
    }

    /// Inner method to get the given account - IT MUST exists (has to be previously registered)
    pub(crate) fn internal_get_account(&self, account_id: &String) -> Account {
        let opt_account = self.accounts.get(account_id);
        if opt_account.is_none() {
            panic!("account {} is not registered", account_id)
        }
        opt_account.unwrap()
    }

    pub(crate) fn account_exists(&self, account_id: &String) -> bool {
        self.accounts.get(account_id).is_some()
    }

    /// Inner method to save the given account for a given account ID.
    pub(crate) fn internal_update_account(&mut self, account_id: &String, account: &Account) {
        self.accounts.insert(account_id, &account); //insert_or_update
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_nslp_account(&self) -> Account {
        self.accounts
            .get(&NSLP_INTERNAL_ACCOUNT.into())
            .unwrap_or_default()
    }
    pub(crate) fn internal_save_nslp_account(&mut self, nslp_account: &Account) {
        self.internal_update_account(&NSLP_INTERNAL_ACCOUNT.into(), &nslp_account);
    }

    /// finds a staking pool requiring some stake to get balanced
    /// WARN: (returns 0,0) if no pool requires staking/all are busy
    pub(crate) fn get_staking_pool_requiring_stake(&self) -> (usize, u128) {
        let mut selected_to_stake_amount: u128 = 0;
        let mut selected_sp_inx: usize = 0;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            // if the pool is not busy, and this pool can stake
            if !sp.busy_lock && sp.weight_basis_points > 0 {
                // if this pool has an unbalance requiring staking
                let should_have = apply_pct(sp.weight_basis_points, self.total_for_staking);
                // this pool requires staking?
                if should_have > sp.staked {
                    // how much?
                    let require_amount = should_have - sp.staked;
                    // is this the most unbalanced pool so far?
                    if require_amount > selected_to_stake_amount {
                        selected_to_stake_amount = require_amount;
                        selected_sp_inx = sp_inx;
                    }
                }
            }
        }

        return (selected_sp_inx, selected_to_stake_amount);
    }

    /// finds a staking pool requiring some unstake to get balanced
    /// WARN: returns (0,0) if no pool requires unstaking/all are busy
    pub(crate) fn internal_get_staking_pool_requiring_unstake(&self) -> GSPRUResult {
        let mut selected_sp_inx: usize = 0;
        let mut selected_extra_amount: u128 = 0;
        let mut total_extra: u128 = 0;
        let mut count_unblocked: u16 = 0;
        let mut count_with_stake: u16 = 0;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            // if the pool is not busy, has stake
            if !sp.busy_lock && sp.staked > 0 {
                // count how how many sps are unblocked, i.e. can receive an unstake request
                count_with_stake += 1;
                if sp.unstaked <= UNSTAKED_YOCTOS_TO_IGNORE {
                    // 100 yoctos
                    count_unblocked += 1
                };
                // check if this pool has an unbalance requiring un-staking
                let should_have = apply_pct(sp.weight_basis_points, self.total_for_staking);
                debug_log!(
                    r#"{{"event":"gtp.req.unstk shld:{} extra:{} unstk:{} w:{} {} {}","sp":"{}","amount":"{}"}}"#,
                    should_have / NEAR,
                    sp.staked.saturating_sub(should_have) / NEAR,
                    sp.unstaked / NEAR,
                    sp.weight_basis_points,
                    sp.unstk_req_epoch_height,
                    env::epoch_height(),
                    sp_inx,
                    sp.staked
                );
                // if not waiting, or wait started in this same epoch (no harm in unstaking more)
                // NOTE: Unstaking in the same epoch is only an issue, if you hit the last block of the epoch.
                //       In this case the receipt may be executed at the next epoch.
                // NOTE2: core-contracts/staking-pool is imprecise when unstaking, some times 1 to 10 yoctos remain in "unstaked"
                //        The bot should synchronize unstaked yoctos before calling this function.
                // We assume that if sp.unstaked>100 yoctos, a new unstake will cause that amount to be blocked
                if sp.unstaked <= UNSTAKED_YOCTOS_TO_IGNORE
                    || sp.unstk_req_epoch_height == env::epoch_height()
                {
                    // does this pool requires un-staking? (has too much staked?)
                    if sp.staked > should_have {
                        // how much?
                        let extra = sp.staked - should_have;
                        total_extra += extra;
                        // is this the most unbalanced pool so far?
                        if extra > selected_extra_amount {
                            selected_extra_amount = extra;
                            selected_sp_inx = sp_inx;
                        }
                    }
                }
            }
        }

        GSPRUResult {
            sp_inx: selected_sp_inx as u16,
            extra: selected_extra_amount,
            count_unblocked,
            count_with_stake,
            total_extra,
        }
    }

    pub fn internal_st_near_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: u128,
        memo: Option<&str>
    ) {
        assert_ne!(
            sender_id, receiver_id,
            "Sender and receiver should be different"
        );
        assert!(amount > 0, "The amount should be a positive number");
        let mut sender_acc = self.internal_get_account(&sender_id);
        let mut receiver_acc = self.internal_get_account(&receiver_id);
        assert!(
            amount <= sender_acc.stake_shares,
            "@{} not enough stNEAR balance {}",
            sender_id,
            sender_acc.stake_shares
        );

        let near_amount = self.amount_from_stake_shares(amount); //amount is in stNEAR(aka shares), let's compute how many nears that is - for acc.staking_meter
        sender_acc.sub_stake_shares(amount, near_amount);
        receiver_acc.add_stake_shares(amount, near_amount);

        self.internal_update_account(&sender_id, &sender_acc);
        self.internal_update_account(&receiver_id, &receiver_acc);

        events::FtTransfer {
            old_owner_id: &sender_id,
            new_owner_id: &receiver_id,
            amount: amount.into(),
            memo
        }
        .emit();
    }

    // ft_token, executed after ft_transfer_call,
    // resolves (maybe refunds)
    // TODO rename
    pub fn int_ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> (u128, u128) {
        let sender_id: AccountId = sender_id.into();
        let receiver_id: AccountId = receiver_id.into();
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let mut receiver_acc = self.accounts.get(&receiver_id).unwrap_or_default(); // avoid panics
            let receiver_balance = receiver_acc.stake_shares;
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                let near_amount = self.amount_from_stake_shares(refund_amount); //amount is in stNEAR(aka shares), let's compute how many nears that is
                receiver_acc.sub_stake_shares(refund_amount, near_amount);
                self.internal_update_account(&receiver_id, &receiver_acc);

                let mut sender_acc = self.accounts.get(&sender_id).unwrap_or_default(); // avoid panics
                sender_acc.add_stake_shares(refund_amount, near_amount);
                self.internal_update_account(&sender_id, &sender_acc);

                events::FtTransfer {
                    old_owner_id: &sender_id,
                    new_owner_id: &receiver_id,
                    amount: amount.into(),
                    memo: Some("refund")
                }
                .emit();
            
                log!(
                    "Refund {} from {} to {}",
                    refund_amount,
                    receiver_id,
                    sender_id
                );
                return (amount - refund_amount, 0);
            }
        }
        (amount, 0)
    }

    pub(crate) fn internal_end_of_epoch_clearing(&mut self) {
        self.assert_not_busy();
        // This method is called before any actual staking/unstaking.

        // if any one of the two is zero, we've a pure stake or pure unstake epoch, no clearing
        // just go and stake or unstake
        if self.epoch_stake_orders == 0 || self.epoch_unstake_orders == 0 {
            return;
        }

        // NOTE: `to_keep` can also be computed as `min(self.epoch_stake_orders, self.epoch_unstake_orders)`
        let to_keep = if self.epoch_stake_orders >= self.epoch_unstake_orders {
            // if more stake-orders than unstake-orders, we keep the NEAR corresponding to epoch_unstake_orders (delayed unstakes)
            // we keep it from now, so the users can withdraw in 4 epochs (clearing: no need to stake and then unstake)
            self.epoch_unstake_orders
        } else {
            // if more delayed-unstakes than stakes, we keep at least the stake-orders, the NEAR we have (clearing: no need to stake and then unstake)
            // and the rest (delta) will be unstakes before EOE
            self.epoch_stake_orders
        };

        // clear opposing orders
        self.epoch_stake_orders -= to_keep;
        self.epoch_unstake_orders -= to_keep;
        event!(r#"{{"event":"clr.ord","keep":"{}"}}"#, to_keep);

        // we will keep this NEAR (no need to go to the pools). We consider it reserved for unstake_claims, 4 epochs from now
        // or maybe some part could be put again in epoch_stake_orders to re-stake
        self.consider_retrieved_for_unstake_claims(to_keep);
    }

    /// if we have to add some funds to retrieved_for_unstake_claims
    /// this fn consider possible "extra" funds coming from rebalances and
    /// send those to epochs_stake_orders to be restaked
    pub(crate) fn consider_retrieved_for_unstake_claims(&mut self, amount: u128) {
        self.retrieved_for_unstake_claims += amount;

        // CONSIDER REBALANCE:
        // we retrieved funds and incremented "retrieved_for_unstake_claims"
        // BUT this retrieval could originate from a rebalance action,
        // so we check if we have more NEAR in the contract than the amount we need for total_unstake_claims,
        // and if we do, then put the extra NEAR to re-stake, thus completing the rebalance
        // Note: we're ignoring unstaked_and_waiting and current epoch_unstake_orders, because reserve_for_unstake_claims has priority
        if self.retrieved_for_unstake_claims > self.total_unstake_claims {
            // confirmed extra to rebalance
            let extra = self.retrieved_for_unstake_claims - self.total_unstake_claims;
            self.retrieved_for_unstake_claims -= extra; // remove extra from reserve
            self.epoch_stake_orders += extra; // put it in epoch_stake_orders, so the funds are re-staked before EOE
            self.unstaked_for_rebalance = self.unstaked_for_rebalance.saturating_sub(extra); // no longer waiting

            //log event
            event!(
                r#"{{"event":"rebalance","extra":"{}","retrieved_for_unstake_claims":"{}","total_unstake_claims":"{}","ufr":"{}"}}"#,
                extra,
                self.retrieved_for_unstake_claims,
                self.total_unstake_claims,
                self.unstaked_for_rebalance,
            );
        }
    }
}

'''
'''--- metapool/src/lib.rs ---
//! A smart contract that allows diversified staking, providing the stNEAR LST NEP-141 Token
//! this contract include parts of core-contracts/lockup-contract & core-contracts/staking-pool

/********************************/
/* CONTRACT Self Identification */
/********************************/
// [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
// see also pub fn get_contract_info
const CONTRACT_NAME: &str = "Metapool";
const CONTRACT_VERSION: &str = "2.0.0";
const DEFAULT_WEB_APP_URL: &str = "https://metapool.app";
const DEFAULT_AUDITOR_ACCOUNT_ID: &str = "auditors.near";
const SOURCE_URL: &str = "github.com/Meta-Pool/liquid-staking-contract";

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault, Promise};

//-- Sputnik DAO remote upgrade requires BLOCKCHAIN_INTERFACE low-level access
#[cfg(target_arch = "wasm32")]
use near_sdk::env::BLOCKCHAIN_INTERFACE;

pub mod gas;
pub mod types;
pub mod utils;
pub use crate::owner::*;
pub use crate::types::*;
pub use crate::utils::*;

pub mod account;
pub mod internal;
pub mod staking_pools;
pub use crate::account::*;
pub use crate::internal::*;
pub use crate::staking_pools::*;

pub mod distribute;
mod migrations;
pub mod owner;

pub mod reward_meter;
pub use reward_meter::*;

pub mod empty_nep_145;
pub mod fungible_token_standard;
pub mod events;

// setup_alloc adds a #[cfg(target_arch = "wasm32")] to the global allocator, which prevents the allocator
// from being used when the contract's main file is used in simulation testing.
near_sdk::setup_alloc!();

//self-callbacks
#[ext_contract(ext_self_owner)]
pub trait ExtMetaStakingPoolOwnerCallbacks {
    fn on_staking_pool_deposit(&mut self, amount: U128String) -> bool;

    fn on_retrieve_from_staking_pool(&mut self, inx: u16) -> bool;

    fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        included_deposit: bool,
    ) -> bool;

    fn on_staking_pool_unstake(
        &mut self,
        sp_inx: usize,
        amount_from_unstake_orders: U128String,
        amount_from_rebalance: U128String,
    ) -> bool;

    fn on_get_result_from_transfer_poll(&mut self, #[callback] poll_result: PollResult) -> bool;

    fn on_get_sp_total_balance(&mut self, sp_inx: usize, #[callback] total_balance: U128String);

    fn on_get_sp_unstaked_balance(
        &mut self,
        sp_inx: usize,
        #[callback] unstaked_balance: U128String,
    );

    fn after_minting_meta(self, account_id: AccountId, to_mint: U128String);
}

// #[ext_contract(meta_token_mint)]
// pub trait MetaToken {
//     fn mint(&mut self, account_id: AccountId, amount: U128String);
// }

//------------------------
//  Main Contract State --
//------------------------
// Note: Because this contract holds a large liquidity-pool, there are no `min_account_balance` required for accounts.
// Accounts are automatically removed (converted to default) where available & staked & shares & meta = 0. see: internal_update_account
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MetaPool {
    /// Owner's account ID (DAO)
    pub owner_account_id: AccountId,

    /// Avoid re-entry when async-calls are in-flight
    pub contract_busy: bool,

    /// no auto-staking. true while changing staking pools
    pub staking_paused: bool,

    /// What should be the contract_account_balance according to our internal accounting (if there's extra, it is 30% tx-fees)
    /// This amount increments with attachedNEAR calls (inflow) and decrements with deposit_and_stake calls (outflow)
    /// increments with retrieve_from_staking_pool (inflow) and decrements with user withdrawals from the contract (outflow)
    /// It should match env::balance()
    pub contract_account_balance: u128,

    /// Every time a user performs a delayed-unstake, stNEAR tokens are burned and the user gets a unstaked_claim that will
    /// be fulfilled 4 epochs from now. If there are someone else staking in the same epoch, both orders (stake & d-unstake) cancel each other
    /// (no need to go to the staking-pools) but the NEAR received for staking must be now reserved for the unstake-withdraw 4 epochs form now.
    /// This amount increments *during* end_of_epoch_clearing, *if* there are staking & unstaking orders that cancel each-other
    /// This amount also increments at retrieve_from_staking_pool, all retrieved NEAR after wait is considered at first reserved for unstake claims
    /// The funds here are *reserved* for the unstake-claims and can only be used to fulfill those claims
    /// This amount decrements at user's delayed-unstake-withdraw, when sending the NEAR to the user
    /// Related variables and Invariant:
    /// retrieved_for_unstake_claims = NEAR in the contract, retrieved in prev epochs (or result of clearing)
    /// unstaked_and_waiting = delay-unstaked in prev epochs, waiting, will become reserve
    /// epoch_unstake_orders = delay-unstaked in this epoch, may remain in the contract or start unstaking before EOE
    /// Invariant: retrieved_for_unstake_claims + unstaked_and_waiting + epoch_unstake_orders must be >= total_unstake_claims
    /// IF the sum is > (not ==), then it is implied that a rebalance is in progress, and the extra amount should be restaked
    /// NOTE: use always fn self.consider_retrieved_for_unstake_claims(amount) to increase this accumulator
    pub retrieved_for_unstake_claims: u128,

    /// This value is equivalent to sum(accounts.available)
    /// This amount increments with user's deposits_into_available and decrements when users stake_from_available
    /// increments with unstake_to_available and decrements with withdraw_from_available
    /// Note: in the current simplified UI user-flow of the meta-pool, only the NSLP & the treasury can have available balance
    /// the rest of the users move directly between their NEAR native accounts & the contract accounts, only briefly occupying acc.available
    pub total_available: u128,

    //-- ORDERS
    // this two amounts can cancel each other at end_of_epoch_clearing
    /// The total amount of "stake" orders in the current epoch, stNEAR has been minted, NEAR is in the contract, stake might be done before EOE
    /// at at end_of_epoch_clearing, (if there were a lot of unstake in the same epoch),
    /// it is possible that this amount remains in hte contract as reserve_for_unstake_claim
    pub epoch_stake_orders: u128,
    /// The total amount of "delayed-unstake" orders in the current epoch, stNEAR has been burned, unstake might be done before EOE
    /// at at end_of_epoch_clearing, (if there were also stake in the same epoch),
    /// it is possible that this amount remains in hte contract as reserve_for_unstake_claim
    pub epoch_unstake_orders: u128,
    /// Not used
    pub epoch_last_clearing: EpochHeight,

    /// The total amount of tokens selected for staking by the users
    /// not necessarily what's actually staked since staking can is done in batches
    /// Share price is computed using this number. share_price = total_for_staking/total_shares
    pub total_for_staking: u128,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // During distribute_staking(), If !staking_paused && total_for_staking<total_actually_staked, then the difference gets staked in the pools
    // During distribute_unstaking(), If total_actually_staked>total_for_staking, then the difference gets unstaked from the pools
    pub total_actually_staked: u128,

    /// how many "shares" were minted. Every time someone "stakes" he "buys pool shares" with the staked amount
    // the buy share price is computed so if she "sells" the shares on that moment she recovers the same near amount
    // staking produces rewards, rewards are added to total_for_staking so share_price will increase with rewards
    // share_price = total_for_staking/total_shares
    // when someone "unstakes" they "burns" X shares at current price to recoup Y near
    pub total_stake_shares: u128, //total stNEAR minted

    /// META (now mpDAO) is the governance token
    pub total_meta: u128, // deprecated 

    /// The total amount of tokens actually unstaked and in the waiting-delay (the tokens are in the staking pools)
    /// equivalent to sum(sp.unstaked)
    pub total_unstaked_and_waiting: u128,

    /// Every time a user performs a delayed-unstake, stNEAR tokens are burned and the user gets a unstaked_claim
    /// equal to sum(accounts.unstake). Every time a user delayed-unstakes, this amount is incremented
    /// when the funds are withdrawn to the user account, the amount is decremented.
    /// Related variables and Invariant:
    /// retrieved_for_unstake_claims = NEAR in the contract, retrieved in prev epochs (or result of clearing)
    /// unstaked_and_waiting = delay-unstaked in prev epochs, waiting, will become reserve
    /// epoch_unstake_orders = delay-unstaked in this epoch, may remain in the contract or start unstaking before EOE
    /// Invariant: retrieved_for_unstake_claims + unstaked_and_waiting + epoch_unstake_orders must be >= total_unstake_claims
    /// IF the sum is > (not ==), then it is implied that a rebalance is in progress, and the extra amount should be restaked
    pub total_unstake_claims: u128,

    /// the staking pools will add rewards to the staked amount on each epoch
    /// here we store the accumulated amount only for stats purposes. This amount can only grow
    pub accumulated_staked_rewards: u128,

    //user's accounts
    pub accounts: UnorderedMap<AccountId, Account>,

    //list of pools to diversify in
    pub staking_pools: Vec<StakingPoolInfo>,

    // validator loan request
    // action on audit suggestions, this field is not used. No need for this to be on the main contract
    pub loan_requests: LookupMap<AccountId, VLoanRequest>,

    //The next 3 values define the Liq.Provider fee curve
    // NEAR/stNEAR Liquidity pool fee curve params
    // We assume this pool is always UNBALANCED, there should be more NEAR than stNEAR 99% of the time
    ///NEAR/stNEAR Liquidity target. If the Liquidity reach this amount, the fee reaches nslp_min_discount_basis_points
    pub nslp_liquidity_target: u128, // 150_000*NEAR initially
    ///NEAR/stNEAR Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //5% initially
    ///NEAR/stNEAR Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.5% initially

    // (deprecated) The next 3 values define meta rewards multipliers. (10 => 1x, 20 => 2x, ...)
    // for each stNEAR paid staking reward, reward stNEAR holders with META. default:5x. reward META = rewards * (mult_pct*10) / 100
    pub staker_meta_mult_pct: u16, // deprecated
    // for each stNEAR paid as discount, reward stNEAR sellers with META. default:1x. reward META = discounted * (mult_pct*10) / 100
    pub stnear_sell_meta_mult_pct: u16, // deprecated
    // for each stNEAR paid as discount, reward LP providers  with META. default:20x. reward META = fee * (mult_pct*10) / 100
    pub lp_provider_meta_mult_pct: u16, // deprecated

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: u128,

    /// Operator account ID (who's in charge to call distribute_xx() on a periodic basis)
    pub operator_account_id: AccountId,
    /// operator_rewards_fee_basis_points. (0.2% default) 100 basis point => 1%. E.g.: owner_fee_basis_points=30 => 0.3% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// owner's cut on Liquid Unstake fee (3% default)
    pub operator_swap_cut_basis_points: u16,
    /// Treasury account ID (it will be controlled by a DAO on phase II)
    pub treasury_account_id: AccountId,
    /// treasury cut on Liquid Unstake (25% from the fees by default)
    pub treasury_swap_cut_basis_points: u16,

    // Configurable info for [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub web_app_url: Option<String>,
    pub auditor_account_id: Option<AccountId>,

    /// (deprecated) Where's the governance token contract
    pub meta_token_account_id: AccountId, // deprecated

    /// (deprecated) estimated & max meta rewards for each category
    pub est_meta_rewards_stakers: u128,
    pub est_meta_rewards_lu: u128, //liquid-unstakers
    pub est_meta_rewards_lp: u128, //liquidity-providers
    // max. when this amount is passed, corresponding multiplier is damped proportionally
    pub max_meta_rewards_stakers: u128,
    pub max_meta_rewards_lu: u128, //liquid-unstakers
    pub max_meta_rewards_lp: u128, //liquidity-providers

    /// up to 1% of the total pool can be unstaked for rebalance (no more than 1% to not affect APY)
    pub unstake_for_rebalance_cap_bp: u16, // default 100bp, meaning 1%
    /// when some unstake for rebalance is executed, this amount is increased
    /// when some extra is retrieved or recovered in EOE clearing, it is decremented
    /// represents the amount that's not staked because is in transit for rebalance.
    /// it could be in unstaked_and_waiting or in the contract & epoch_stake_orders
    pub unstaked_for_rebalance: u128,
}

#[near_bindgen]
impl MetaPool {
    /* NOTE
    This contract implements several traits

    1. core-contracts/staking-pool: this contract must be perceived as a staking-pool for the lockup-contract, wallets, and users.
        This means implementing: ping, deposit, deposit_and_stake, withdraw_all, withdraw, stake_all, stake, unstake_all, unstake
        and view methods: get_account_unstaked_balance, get_account_staked_balance, get_account_total_balance, is_account_unstaked_balance_available,
            get_total_staked_balance, get_owner_id, get_reward_fee_fraction, is_staking_paused, get_staking_key, get_account,
            get_number_of_accounts, get_accounts.

    2. meta-staking: these are the extensions to the standard staking pool (liquid stake/unstake)

    3. fungible token [NEP-141]: this contract is the NEP-141 contract for the stNEAR token

    */

    /// Initializes MetaPool contract.
    /// - `owner_account_id` - the account ID of the owner.  Only this account can call owner's methods on this contract.
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        treasury_account_id: AccountId,
        operator_account_id: AccountId,
        meta_token_account_id: AccountId,
    ) -> Self {
        let result = Self {
            owner_account_id,
            contract_busy: false,
            operator_account_id,
            treasury_account_id,
            contract_account_balance: 0,
            web_app_url: Some(String::from(DEFAULT_WEB_APP_URL)),
            auditor_account_id: Some(String::from(DEFAULT_AUDITOR_ACCOUNT_ID)),
            operator_rewards_fee_basis_points: DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS,
            operator_swap_cut_basis_points: DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS,
            treasury_swap_cut_basis_points: DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS,
            staking_paused: false,
            total_available: 0,
            total_for_staking: 0,
            total_actually_staked: 0,
            total_unstaked_and_waiting: 0,
            retrieved_for_unstake_claims: 0,
            total_unstake_claims: 0,
            epoch_stake_orders: 0,
            epoch_unstake_orders: 0,
            epoch_last_clearing: 0,
            accumulated_staked_rewards: 0,
            total_stake_shares: 0,
            total_meta: 0,
            accounts: UnorderedMap::new(b"A".to_vec()),
            loan_requests: LookupMap::new(b"L".to_vec()),
            nslp_liquidity_target: 10_000 * NEAR,
            nslp_max_discount_basis_points: 180, //1.8%
            nslp_min_discount_basis_points: 25,  //0.25%
            min_deposit_amount: 10 * NEAR,
            // (deprecated) for each stNEAR paid as discount, reward stNEAR sellers with META. initial 5x, default:1x. reward META = discounted * mult_pct / 100
            stnear_sell_meta_mult_pct: 50, //5x (deprecated)
            // (deprecated) for each stNEAR paid staking reward, reward stNEAR holders with META. initial 10x, default:5x. reward META = rewards * mult_pct / 100
            staker_meta_mult_pct: 5000, //500x (deprecated)
            // for each stNEAR paid as discount, reward LPs with META. initial 50x, default:20x. reward META = fee * mult_pct / 100
            lp_provider_meta_mult_pct: 200, //20x (deprecated)
            staking_pools: Vec::new(),
            meta_token_account_id,
            est_meta_rewards_stakers: 0, // (deprecated)
            est_meta_rewards_lu: 0, // (deprecated)
            est_meta_rewards_lp: 0, // (deprecated)
            max_meta_rewards_stakers: 1_000_000 * ONE_NEAR, // (deprecated)
            max_meta_rewards_lu: 50_000 * ONE_NEAR, // (deprecated)
            max_meta_rewards_lp: 100_000 * ONE_NEAR, // (deprecated)
            unstaked_for_rebalance: 0,
            unstake_for_rebalance_cap_bp: 100,
        };
        //all key accounts must be different
        result.assert_key_accounts_are_different();
        return result;
    }

    fn assert_key_accounts_are_different(&self) {
        //all accounts must be different
        assert!(self.owner_account_id != self.operator_account_id);
        assert!(self.owner_account_id != DEVELOPERS_ACCOUNT_ID);
        assert!(self.owner_account_id != self.treasury_account_id);
        assert!(self.operator_account_id != DEVELOPERS_ACCOUNT_ID);
        assert!(self.operator_account_id != self.treasury_account_id);
        assert!(self.treasury_account_id != DEVELOPERS_ACCOUNT_ID);
    }

    //------------------------------------
    // core-contracts/staking-pool trait
    //------------------------------------

    /// staking-pool's ping is moot here
    pub fn ping(&mut self) {}

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        //block "deposit" only, so all actions are thru the simplified user-flow, using deposit_and_stake
        panic!("please use deposit_and_stake");
        //self.internal_deposit();
    }

    /// Withdraws from "UNSTAKED" balance *TO MIMIC core-contracts/staking-pool* .- core-contracts/staking-pool only has "unstaked" to withdraw from
    pub fn withdraw(&mut self, amount: U128String) -> Promise {
        assert_not_lockup_account_calling();
        self.internal_withdraw_use_unstaked(&env::predecessor_account_id(), amount.0)
    }
    /// Withdraws ALL from from "UNSTAKED" balance *TO MIMIC core-contracts/staking-pool .- core-contracts/staking-pool only has "unstaked" to withdraw from
    pub fn withdraw_all(&mut self) -> Promise {
        assert_not_lockup_account_calling();
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw_use_unstaked(&account_id, account.unstaked)
    }

    /// user method - simplified flow
    /// completes delayed-unstake action by transferring from retrieved_from_the_pools to user's NEAR account
    /// equivalent to core-contracts/staking-pool.withdraw_all, used by metastaking webapp
    pub fn withdraw_unstaked(&mut self) -> Promise {
        assert_not_lockup_account_calling();
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw_use_unstaked(&account_id, account.unstaked)
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) -> U128String {
        assert_not_lockup_account_calling();
        let account_id = env::predecessor_account_id();
        let amount = self.internal_deposit(&account_id);
        let shares = self.internal_stake_from_account(&account_id, amount);
        //----------
        // check if the liquidity pool needs liquidity, and then use this opportunity to liquidate stnear in the LP by internal-clearing
        // the amount just deposited, might be swapped in the liquid-unstake pool
        self.nslp_try_internal_clearing(amount);
        events::FtMint {
            owner_id: &account_id,
            amount: shares.into(),
            memo: None
        }
        .emit();

        shares.into()
    }

    /// Stakes all "unstaked" balance from the inner account of the predecessor.
    /// we keep this to implement the staking-pool trait, but we don't support re-staking unstaked amounts
    pub fn stake_all(&mut self) {
        panic!("please use deposit_and_stake");
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// we keep this to implementing the staking-pool trait, but we don't support re-staking unstaked amounts
    #[allow(unused_variables)]
    pub fn stake(&mut self, amount: U128String) {
        panic!("please use deposit_and_stake");
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        assert_not_lockup_account_calling();
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let all_shares = account.stake_shares;
        self.internal_unstake_shares(&account_id, &mut account, all_shares);
    }

    /// Unstakes the given amount (in NEAR) from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    /// delayed_unstake, amount_requested is in yoctoNEARs
    pub fn unstake(&mut self, amount: U128String) {
        assert_not_lockup_account_calling();
        self.internal_unstake(&env::predecessor_account_id(), amount.0);
    }

    /*******************/
    /* lockup accounts */
    /*******************/
    /// Unstakes the exact amount of shares from a lockup account
    /// The new total unstaked balance will be available for withdrawal in x epochs.
    /// delayed_unstake, amount_requested is in stNEAR/shares
    /// return value is the amount of shares
    #[payable]
    pub fn stake_for_lockup(&mut self, lockup_account_id: String) -> U128String {
        assert_lockup_contract_calling();
        let amount = self.internal_deposit(&lockup_account_id);
        let shares = self.internal_stake_from_account(&lockup_account_id, amount);
        //----------
        // check if the liquidity pool needs liquidity, and then use this opportunity to liquidate stnear in the LP by internal-clearing
        // the amount just deposited, might be swapped in the liquid-unstake pool
        self.nslp_try_internal_clearing(amount);
        shares.into()
    }
    /// Unstakes the exact amount of shares from a lockup account
    /// The new total unstaked balance will be available for withdrawal in x epochs.
    /// delayed_unstake, amount_requested is in stNEAR/shares
    /// return value is the unstaked nears and the epoch when the NEARS will be available for withdraw
    pub fn unstake_from_lockup_shares(
        &mut self,
        lockup_account_id: String,
        shares: U128String,
    ) -> (U128String, U64String) {
        assert_lockup_contract_calling();
        let mut acc = self.internal_get_account(&lockup_account_id);
        let (nears, epoch) = self.internal_unstake_shares(&lockup_account_id, &mut acc, shares.0);
        (nears.into(), epoch.into())
    }

    pub fn withdraw_to_lockup(&mut self, lockup_account_id: String, amount: U128String) -> Promise {
        assert_lockup_contract_calling();
        self.internal_withdraw_use_unstaked(&lockup_account_id, amount.0)
    }

    /*****************************/
    /* staking-pool View methods */
    /*****************************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String {
        // note: get_account returns HumanReadableAccount - ok for unregistered accounts
        return self.get_account(account_id).unstaked_balance;
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128String {
        // note: get_account returns HumanReadableAccount - ok for unregistered accounts
        return self.get_account(account_id).staked_balance;
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.accounts.get(&account_id).unwrap_or_default();
        return (acc.available + self.amount_from_stake_shares(acc.stake_shares) + acc.unstaked)
            .into();
    }

    /// additional to staking-pool to satisfy generic deposit-NEP-standard
    /// returns the amount that can be withdrawn immediately
    pub fn get_account_available_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.accounts.get(&account_id).unwrap_or_default();
        return acc.available.into();
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        // note: get_account returns HumanReadableAccount - ok for unregistered accounts
        return self.get_account(account_id).can_withdraw;
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        return self.owner_account_id.clone();
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        return RewardFeeFraction {
            numerator: (self.operator_rewards_fee_basis_points
                + DEVELOPERS_REWARDS_FEE_BASIS_POINTS)
                .into(),
            denominator: 10_000,
        };
    }
    pub fn get_reward_fee_bp(&self) -> u16 {
        self.operator_rewards_fee_basis_points + DEVELOPERS_REWARDS_FEE_BASIS_POINTS
    }

    #[payable]
    pub fn set_reward_fee(&mut self, basis_points: u16) {
        self.assert_owner_calling();
        assert_one_yocto();
        assert!(env::attached_deposit() > 0);
        assert!(basis_points < 1000); // less than 10%
        self.operator_rewards_fee_basis_points =
            basis_points.saturating_sub(DEVELOPERS_REWARDS_FEE_BASIS_POINTS);
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        panic!("no specific staking key for the div-pool");
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        return self.staking_paused;
    }

    /// to implement the Staking-pool interface, get_account returns the same as the staking-pool returns
    /// full account info can be obtained by calling: pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult
    /// Returns human readable representation of the account for the given account ID.
    // note: get_account returns HumanReadableAccount - ok for unregistered accounts
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.accounts.get(&account_id).unwrap_or_default();
        return HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self.amount_from_stake_shares(account.stake_shares).into(),
            can_withdraw: env::epoch_height() >= account.unstaked_requested_unlock_epoch,
        };
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        return self.accounts.len();
    }

    /// Returns the list of accounts (staking-pool trait)
    // note: get_account returns HumanReadableAccount - ok for unregistered accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();
        return (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect();
    }

    //----------------------------------
    //----------------------------------
    // META-STAKING-POOL trait
    //----------------------------------
    //----------------------------------

    /// Returns the list of accounts with full data (div-pool trait)
    pub fn get_accounts_info(&self, from_index: u64, limit: u64) -> Vec<GetAccountInfoResult> {
        let keys = self.accounts.keys_as_vector();
        return (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account_info(keys.get(index).unwrap()))
            .collect();
    }

    //---------------------------
    // NSLP Methods
    //---------------------------

    /// user method - NEAR/stNEAR SWAP functions
    /// return how much NEAR you can get by selling x stNEAR
    pub fn get_near_amount_sell_stnear(&self, stnear_to_sell: U128String) -> U128String {
        let lp_account = self.internal_get_nslp_account();
        return self
            .internal_get_near_amount_sell_stnear(lp_account.available, stnear_to_sell.0)
            .into();
    }

    /// NEAR/stNEAR Liquidity Pool
    /// computes the discount_basis_points for NEAR/stNEAR Swap based on NSLP Balance
    /// If you want to sell x stNEAR
    pub fn nslp_get_discount_basis_points(&self, stnear_to_sell: U128String) -> u16 {
        let lp_account = self.internal_get_nslp_account();
        return self.internal_get_discount_basis_points(lp_account.available, stnear_to_sell.0);
    }

    /// user method
    /// swaps stNEAR->NEAR in the Liquidity Pool
    /// returns nears transferred
    //#[payable]
    pub fn liquid_unstake(
        &mut self,
        st_near_to_burn: U128String,
        min_expected_near: U128String,
    ) -> LiquidUnstakeResult {
        self.assert_not_busy();
        // Q: Why not? - R: liquid_unstake It's not as problematic as transfer, because it moves tokens between accounts of the same user
        // so let's remove the one_yocto_requirement, waiting for a better solution for the function-call keys NEP-141 problem
        //assert_one_yocto();

        let account_id = env::predecessor_account_id();
        let mut user_account = self.internal_get_account(&account_id);

        let stnear_owned = user_account.stake_shares;

        let st_near_to_sell:u128 =
        // if the amount is close to user's total, remove user's total
        // to: a) do not leave less than ONE_MILLI_NEAR in the account, b) Allow 10 yoctos of rounding, e.g. remove(100) removes 99.999993 without panicking
        if is_close(st_near_to_burn.0, stnear_owned) { // allow for rounding simplification
            stnear_owned
        }
        else  {
            st_near_to_burn.0
        };

        log!(
            "st_near owned:{}, to_sell:{}",
            user_account.stake_shares, st_near_to_sell
        );

        assert!(
            stnear_owned >= st_near_to_sell,
            "Not enough stNEAR. You own {}",
            stnear_owned
        );

        let mut nslp_account = self.internal_get_nslp_account();

        //compute how many nears are the st_near valued at
        let nears_out = self.amount_from_stake_shares(st_near_to_sell);
        let swap_fee_basis_points =
            self.internal_get_discount_basis_points(nslp_account.available, nears_out);
        assert!(swap_fee_basis_points < 10000, "inconsistency d>1");
        let fee = apply_pct(swap_fee_basis_points, nears_out);

        let near_to_receive = nears_out - fee;
        assert!(
            near_to_receive >= min_expected_near.0,
            "Price changed, your min amount {} is not satisfied {}. Try again",
            min_expected_near.0,
            near_to_receive
        );
        assert!(
            nslp_account.available >= near_to_receive,
            "Not enough liquidity in the liquidity pool"
        );

        //the NEAR for the user comes from the LP
        nslp_account.available -= near_to_receive;
        user_account.available += near_to_receive;

        // compute how many shares the swap fee represent
        let fee_in_st_near = self.stake_shares_from_amount(fee);

        // involved accounts
        assert!(
            &account_id != &self.treasury_account_id,
            "can't use treasury account"
        );
        let mut treasury_account = self
            .accounts
            .get(&self.treasury_account_id)
            .unwrap_or_default();
        assert!(
            &account_id != &self.operator_account_id,
            "can't use operator account"
        );
        let mut operator_account = self
            .accounts
            .get(&self.operator_account_id)
            .unwrap_or_default();
        assert!(
            &account_id != &DEVELOPERS_ACCOUNT_ID,
            "can't use developers account"
        );
        let mut developers_account = self
            .accounts
            .get(&DEVELOPERS_ACCOUNT_ID.into())
            .unwrap_or_default();

        // The treasury cut in stnear-shares (25% by default)
        let treasury_st_near_cut = apply_pct(self.treasury_swap_cut_basis_points, fee_in_st_near);
        treasury_account.add_st_near(treasury_st_near_cut, &self);

        // The cut that the contract owner (operator) takes. (3% of 1% normally)
        let operator_st_near_cut = apply_pct(self.operator_swap_cut_basis_points, fee_in_st_near);
        operator_account.add_st_near(operator_st_near_cut, &self);

        // The cut that the developers take. (2% of 1% normally)
        let developers_st_near_cut = apply_pct(DEVELOPERS_SWAP_CUT_BASIS_POINTS, fee_in_st_near);
        developers_account.add_st_near(developers_st_near_cut, &self);

        log!("treasury_st_near_cut:{} operator_st_near_cut:{} developers_st_near_cut:{} fee_in_st_near:{}",
            treasury_st_near_cut,operator_st_near_cut,developers_st_near_cut,fee_in_st_near);

        assert!(
            fee_in_st_near > treasury_st_near_cut + developers_st_near_cut + operator_st_near_cut
        );

        // The rest of the st_near sold goes into the liq-pool. Because it is a larger amount than NEARs removed, it will increase share value for all LP providers.
        // Adding value to the pool via adding more stNEAR value than the NEAR removed
        let st_near_to_liq_pool = st_near_to_sell
            - (treasury_st_near_cut + operator_st_near_cut + developers_st_near_cut);
        log!("nslp_account.add_st_near {}", st_near_to_liq_pool);
        // major part of stNEAR sold goes to the NSLP
        nslp_account.add_st_near(st_near_to_liq_pool, &self);

        //complete the transfer, remove stnear from the user (stnear was transferred to the LP & others)
        user_account.sub_st_near(st_near_to_sell, &self);

        //Save involved accounts
        self.internal_update_account(&self.treasury_account_id.clone(), &treasury_account);
        self.internal_update_account(&self.operator_account_id.clone(), &operator_account);
        self.internal_update_account(&DEVELOPERS_ACCOUNT_ID.into(), &developers_account);
        //Save nslp accounts
        self.internal_save_nslp_account(&nslp_account);

        //simplified user-flow
        //direct transfer to user (instead of leaving it in-contract as "available")
        let transfer_amount = user_account.take_from_available(&account_id, near_to_receive, self);
        self.native_transfer(&account_id, transfer_amount);

        //Save user account
        self.internal_update_account(&account_id, &user_account);

        log!(
            "@{} liquid-unstaked {} stNEAR, got {} NEAR",
            &account_id,
            st_near_to_sell,
            transfer_amount
        );
        event!(
            r#"{{"event":"LIQ.U","account_id":"{}","stnear":"{}","near":"{}"}}"#,
            &account_id,
            st_near_to_sell,
            transfer_amount
        );

        return LiquidUnstakeResult {
            near: transfer_amount.into(),
            fee: fee_in_st_near.into(),
            meta: 0.into(), // meta_to_seller.into(),
        };
    }

    /// add liquidity - payable
    #[payable]
    pub fn nslp_add_liquidity(&mut self) -> u16 {
        // TODO: Since this method doesn't guard the resulting liquidity, is it possible to put it
        //    into a front-run/end-run sandwich to capitalize on the transaction?
        let account_id = env::predecessor_account_id();
        let amount = self.internal_deposit(&account_id);
        return self.internal_nslp_add_liquidity(&account_id, amount);
    }

    /// remove liquidity from liquidity pool
    //#[payable]
    pub fn nslp_remove_liquidity(&mut self, amount: U128String) -> RemoveLiquidityResult {
        self.assert_not_busy();
        //assert_one_yocto();

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);
        let mut nslp_account = self.internal_get_nslp_account();

        //how much does this user owns
        let valued_actual_shares = acc.valued_nslp_shares(self, &nslp_account);

        let mut to_remove = amount.0;
        let nslp_shares_to_burn: u128;
        // if the amount is close to user's total, remove user's total
        // to: a) do not leave less than ONE_MILLI_NEAR in the account, b) Allow 10 yoctos of rounding, e.g. remove(100) removes 99.999993 without panicking
        if is_close(to_remove, valued_actual_shares) {
            // allow for rounding simplification
            to_remove = valued_actual_shares;
            nslp_shares_to_burn = acc.nslp_shares; // close enough to all shares, burn-it all (avoid leaving "dust")
        } else {
            assert!(
                valued_actual_shares >= to_remove,
                "Not enough share value {} to remove the requested amount from the pool",
                valued_actual_shares
            );
            // Calculate the number of "nslp" shares that the account will burn based on the amount requested
            nslp_shares_to_burn = self.nslp_shares_from_amount(to_remove, &nslp_account);
        }

        assert!(nslp_shares_to_burn > 0);

        //register removed liquidity to compute rewards correctly
        acc.lp_meter.unstake(to_remove);

        //compute proportionals stNEAR/NEAR
        //1st: stNEAR how much stNEAR from the Liq-Pool represents the ratio: nslp_shares_to_burn relative to total nslp_shares
        let st_near_to_remove_from_pool = proportional(
            nslp_account.stake_shares,
            nslp_shares_to_burn,
            nslp_account.nslp_shares,
        );
        //2nd: NEAR, by difference
        let near_value_of_st_near = self.amount_from_stake_shares(st_near_to_remove_from_pool);
        assert!(
            to_remove >= near_value_of_st_near,
            "inconsistency NTR<STR+UTR"
        );
        let near_to_remove = to_remove - near_value_of_st_near;

        //update user account
        //remove first from stNEAR in the pool, proportional to shares being burned
        //NOTE: To simplify user-operations, the LIQ.POOL DO NOT carry "unstaked". The NSLP self-balances only by internal-clearing on `deposit_and_stake`
        acc.available += near_to_remove;
        acc.add_st_near(st_near_to_remove_from_pool, &self); //add stnear to user acc
        acc.nslp_shares -= nslp_shares_to_burn; //shares this user burns
                                                //update NSLP account
        nslp_account.available -= near_to_remove;
        nslp_account.sub_st_near(st_near_to_remove_from_pool, &self); //remove stnear from the pool
        nslp_account.nslp_shares -= nslp_shares_to_burn; //burn from total nslp shares

        //simplify user-flow
        //direct transfer to user (instead of leaving it in-contract as "available")
        let transfer_amount = acc.take_from_available(&account_id, near_to_remove, self);
        self.native_transfer(&account_id, transfer_amount);

        //--SAVE ACCOUNTS
        self.internal_update_account(&account_id, &acc);
        self.internal_save_nslp_account(&nslp_account);

        event!(
            r#"{{"event":"REM.L","account_id":"{}","near":"{}","stnear":"{}"}}"#,
            account_id,
            transfer_amount,
            st_near_to_remove_from_pool
        );

        return RemoveLiquidityResult {
            near: transfer_amount.into(),
            st_near: st_near_to_remove_from_pool.into(),
        };
    }

    //----------------------------------
    // Use part of the NSLP to stake. This is the inverse operation of nslp_try_internal_clearing
    // can be used by the operator to increase epoch_stake_orders
    // to later direct stake in validators that are about to lose the seat
    // ---------------------------------
    #[payable]
    pub fn stake_from_nslp(&mut self, near_amount: U128String) {
        assert_one_yocto();
        self.assert_operator_or_owner();
        // check the amount
        let nslp_account = self.internal_get_nslp_account();
        let amount = near_amount.0;
        assert!(nslp_account.available > amount, "too much");
        assert!(
            nslp_account.available - amount > self.nslp_liquidity_target,
            "stake will leave NSLP below target"
        );
        // stake from nslp
        self.internal_stake_from_account(&NSLP_INTERNAL_ACCOUNT.to_string(), amount);
    }

    /// deprecated, kept for bin compat
    pub fn realize_meta(&mut self, account_id: String) {
        // this fn should not be called for the NSLP_INTERNAL_ACCOUNT
        assert!(account_id != NSLP_INTERNAL_ACCOUNT);
    }

    //------------------
    // HARVEST META (now mpDAO)
    //------------------
    #[payable]
    /// deprecated - kept for bin compat
    pub fn harvest_meta(&mut self) -> Promise {
        panic!("internal incentives have been deactivated. Use stNEAR in the ecosystem to get incentives");
    }

    //---------------------------------------------------------------------------
    /// Sputnik DAO remote-upgrade receiver
    /// can be called by a remote-upgrade proposal
    ///
    #[cfg(target_arch = "wasm32")]
    pub fn upgrade(self) {
        assert!(env::predecessor_account_id() == self.owner_account_id);
        //input is code:<Vec<u8> on REGISTER 0
        //log!("bytes.length {}", code.unwrap().len());
        assert!(
            env::prepaid_gas() > 150 * TGAS,
            "set 200TGAS or more for this transaction"
        );
        const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";
        //after upgrade we call *pub fn migrate()* on the NEW CODE
        let current_id = env::current_account_id().into_bytes();
        let migrate_method_name = "migrate".as_bytes().to_vec();
        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input (new contract code) into register 0
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);

                //prepare self-call promise
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);

                // 1st action, deploy/upgrade code (takes code from register 0)
                // Note: this "promise preparation" CONSUMES an important amount of gas
                // because at this point the WASM code is checked and "compiled"
                // total gas cost formula is: (2 * 184765750000 + contract_size_in_bytes * (6812999 + 64572944) + 2 * 108059500000)
                // https://github.com/Narwallets/meta-pool/issues/21
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);

                // 2nd action, schedule a call to "migrate()".
                // Will execute on the **new code**
                const GAS_FOR_THE_REST_OF_THIS_FUNCTION: u64 = 10 * TGAS;
                // at this point the gas for sending the code and "compiling" is already spent. Let's compute what's left for migration
                let gas_for_migration =
                    env::prepaid_gas() - env::used_gas() - GAS_FOR_THE_REST_OF_THIS_FUNCTION;
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        migrate_method_name.len() as _,
                        migrate_method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        gas_for_migration,
                    );
            });
        }
    }
}

'''
'''--- metapool/src/migrations.rs ---
//-----------------------------
//-----------------------------
//contract main state migration
//-----------------------------

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::{env, near_bindgen, AccountId, EpochHeight};

use crate::*;

//---------------------------------------------------
//  PREVIOUS Main Contract State for state migrations
//---------------------------------------------------
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct OldMetaPool {
    /// Owner's account ID (DAO)
    pub owner_account_id: AccountId,

    /// Avoid re-entry when async-calls are in-flight
    pub contract_busy: bool,

    /// no auto-staking. true while changing staking pools
    pub staking_paused: bool,

    /// What should be the contract_account_balance according to our internal accounting (if there's extra, it is 30% tx-fees)
    /// This amount increments with attachedNEAR calls (inflow) and decrements with deposit_and_stake calls (outflow)
    /// increments with retrieve_from_staking_pool (inflow) and decrements with user withdrawals from the contract (outflow)
    /// It should match env::balance()
    pub contract_account_balance: u128,

    /// Every time a user performs a delayed-unstake, stNEAR tokens are burned and the user gets a unstaked_claim that will
    /// be fulfilled 4 epochs from now. If there are someone else staking in the same epoch, both orders (stake & d-unstake) cancel each other
    /// (no need to go to the staking-pools) but the NEAR received for staking must be now reserved for the unstake-withdraw 4 epochs form now.
    /// This amount increments *during* end_of_epoch_clearing, *if* there are staking & unstaking orders that cancel each-other
    /// This amount also increments at retrieve_from_staking_pool, all retrieved NEAR after wait is considered at first reserved for unstake claims
    /// The funds here are *reserved* for the unstake-claims and can only be used to fulfill those claims
    /// This amount decrements at user's delayed-unstake-withdraw, when sending the NEAR to the user
    /// Related variables and Invariant:
    /// retrieved_for_unstake_claims = NEAR in the contract, retrieved in prev epochs (or result of clearing)
    /// unstaked_and_waiting = delay-unstaked in prev epochs, waiting, will become reserve
    /// epoch_unstake_orders = delay-unstaked in this epoch, may remain in the contract or start unstaking before EOE
    /// Invariant: retrieved_for_unstake_claims + unstaked_and_waiting + epoch_unstake_orders must be >= total_unstake_claims
    /// IF the sum is > (not ==), then it is implied that a rebalance is in progress, and the extra amount should be restaked
    /// NOTE: use always fn self.consider_retrieved_for_unstake_claims(amount) to increase this accumulator
    pub retrieved_for_unstake_claims: u128,

    /// This value is equivalent to sum(accounts.available)
    /// This amount increments with user's deposits_into_available and decrements when users stake_from_available
    /// increments with unstake_to_available and decrements with withdraw_from_available
    /// Note: in the current simplified UI user-flow of the meta-pool, only the NSLP & the treasury can have available balance
    /// the rest of the users move directly between their NEAR native accounts & the contract accounts, only briefly occupying acc.available
    pub total_available: u128,

    //-- ORDERS
    // this two amounts can cancel each other at end_of_epoch_clearing
    /// The total amount of "stake" orders in the current epoch, stNEAR has been minted, NEAR is in the contract, stake might be done before EOE
    /// at at end_of_epoch_clearing, (if there were a lot of unstake in the same epoch), 
    /// it is possible that this amount remains in hte contract as reserve_for_unstake_claim
    pub epoch_stake_orders: u128,
    /// The total amount of "delayed-unstake" orders in the current epoch, stNEAR has been burned, unstake might be done before EOE
    /// at at end_of_epoch_clearing, (if there were also stake in the same epoch), 
    /// it is possible that this amount remains in hte contract as reserve_for_unstake_claim
    pub epoch_unstake_orders: u128,
    /// Not used
    pub epoch_last_clearing: EpochHeight,

    /// The total amount of tokens selected for staking by the users
    /// not necessarily what's actually staked since staking can is done in batches
    /// Share price is computed using this number. share_price = total_for_staking/total_shares
    pub total_for_staking: u128,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // During distribute_staking(), If !staking_paused && total_for_staking<total_actually_staked, then the difference gets staked in the pools
    // During distribute_unstaking(), If total_actually_staked>total_for_staking, then the difference gets unstaked from the pools
    pub total_actually_staked: u128,

    /// how many "shares" were minted. Every time someone "stakes" he "buys pool shares" with the staked amount
    // the buy share price is computed so if she "sells" the shares on that moment she recovers the same near amount
    // staking produces rewards, rewards are added to total_for_staking so share_price will increase with rewards
    // share_price = total_for_staking/total_shares
    // when someone "unstakes" they "burns" X shares at current price to recoup Y near
    pub total_stake_shares: u128, //total stNEAR minted

    /// META is the governance token. Total meta minted by this contract
    pub total_meta: u128,

    /// The total amount of tokens actually unstaked and in the waiting-delay (the tokens are in the staking pools)
    /// equivalent to sum(sp.unstaked)
    pub total_unstaked_and_waiting: u128,

    /// Every time a user performs a delayed-unstake, stNEAR tokens are burned and the user gets a unstaked_claim 
    /// equal to sum(accounts.unstake). Every time a user delayed-unstakes, this amount is incremented
    /// when the funds are withdrawn to the user account, the amount is decremented.
    /// Related variables and Invariant:
    /// retrieved_for_unstake_claims = NEAR in the contract, retrieved in prev epochs (or result of clearing)
    /// unstaked_and_waiting = delay-unstaked in prev epochs, waiting, will become reserve
    /// epoch_unstake_orders = delay-unstaked in this epoch, may remain in the contract or start unstaking before EOE
    /// Invariant: retrieved_for_unstake_claims + unstaked_and_waiting + epoch_unstake_orders must be >= total_unstake_claims
    /// IF the sum is > (not ==), then it is implied that a rebalance is in progress, and the extra amount should be restaked
    pub total_unstake_claims: u128,

    /// the staking pools will add rewards to the staked amount on each epoch
    /// here we store the accumulated amount only for stats purposes. This amount can only grow
    pub accumulated_staked_rewards: u128,

    //user's accounts
    pub accounts: UnorderedMap<AccountId, Account>,

    //list of pools to diversify in
    pub staking_pools: Vec<StakingPoolInfo>,

    // validator loan request
    // action on audit suggestions, this field is not used. No need for this to be on the main contract
    pub loan_requests: LookupMap<AccountId, VLoanRequest>,

    //The next 3 values define the Liq.Provider fee curve
    // NEAR/stNEAR Liquidity pool fee curve params
    // We assume this pool is always UNBALANCED, there should be more NEAR than stNEAR 99% of the time
    ///NEAR/stNEAR Liquidity target. If the Liquidity reach this amount, the fee reaches nslp_min_discount_basis_points
    pub nslp_liquidity_target: u128, // 150_000*NEAR initially
    ///NEAR/stNEAR Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //5% initially
    ///NEAR/stNEAR Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.5% initially

    //The next 3 values define meta rewards multipliers. (10 => 1x, 20 => 2x, ...)
    ///for each stNEAR paid staking reward, reward stNEAR holders with META. default:5x. reward META = rewards * (mult_pct*10) / 100
    pub staker_meta_mult_pct: u16,
    ///for each stNEAR paid as discount, reward stNEAR sellers with META. default:1x. reward META = discounted * (mult_pct*10) / 100
    pub stnear_sell_meta_mult_pct: u16,
    ///for each stNEAR paid as discount, reward LP providers  with META. default:20x. reward META = fee * (mult_pct*10) / 100
    pub lp_provider_meta_mult_pct: u16,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: u128,

    /// Operator account ID (who's in charge to call distribute_xx() on a periodic basis)
    pub operator_account_id: AccountId,
    /// operator_rewards_fee_basis_points. (0.2% default) 100 basis point => 1%. E.g.: owner_fee_basis_points=30 => 0.3% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// owner's cut on Liquid Unstake fee (3% default)
    pub operator_swap_cut_basis_points: u16,
    /// Treasury account ID (it will be controlled by a DAO on phase II)
    pub treasury_account_id: AccountId,
    /// treasury cut on Liquid Unstake (25% from the fees by default)
    pub treasury_swap_cut_basis_points: u16,

    // Configurable info for [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub web_app_url: Option<String>,
    pub auditor_account_id: Option<AccountId>,

    /// Where's the NEP-141 $META token contract
    pub meta_token_account_id: AccountId,

    /// estimated & max meta rewards for each category
    pub est_meta_rewards_stakers: u128,
    pub est_meta_rewards_lu: u128, //liquid-unstakers
    pub est_meta_rewards_lp: u128, //liquidity-providers
    // max. when this amount is passed, corresponding multiplier is damped proportionally
    pub max_meta_rewards_stakers: u128,
    pub max_meta_rewards_lu: u128, //liquid-unstakers
    pub max_meta_rewards_lp: u128, //liquidity-providers

    /// up to 1% of the total pool can be unstaked for rebalance (no more than 1% to not affect APY)
    pub unstake_for_rebalance_cap_bp: u16, // default 100bp, meaning 1%
    /// when some unstake for rebalance is executed, this amount is increased 
    /// when some extra is retrieved or recovered in EOE clearing, it is decremented
    /// represents the amount that's not staked because is in transit for rebalance. 
    /// it could be in unstaked_and_waiting or in the contract & epoch_stake_orders
    pub unstaked_for_rebalance: u128,
}

use crate::MetaPool;
use crate::MetaPoolContract;

#[near_bindgen]
impl MetaPool {
    //-----------------
    //-- migration called after code upgrade
    ///  For next version upgrades, change this function.
    //-- executed after upgrade to NEW CODE
    //-----------------
    /// This fn WILL be called by this contract from `pub fn upgrade` (started from DAO)
    /// Originally a **NOOP implementation. KEEP IT if you haven't changed contract state.**
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    ///
    #[init(ignore_state)] //do not auto-load state before this function
    pub fn migrate() -> Self {
        // read state with OLD struct
        // uncomment when state migration is required on upgrade
        let old: OldMetaPool = env::state_read().expect("Old state doesn't exist");

        // can only be called by this same contract (it's called from fn upgrade())
        if !env::current_account_id().ends_with(".testnet") {
            assert_eq!(
                &env::predecessor_account_id(),
                &env::current_account_id(),
                "Can only be called by this contract"
            );
        }

        // Create the new contract state using the data from the old contract state.
        // returns this struct that gets stored as contract state
        return Self {
            owner_account_id: old.owner_account_id,
            contract_busy: false,
            staking_paused: old.staking_paused,
            contract_account_balance: old.contract_account_balance,
            retrieved_for_unstake_claims: old.retrieved_for_unstake_claims,
            total_available: old.total_available,

            //-- ORDERS
            epoch_stake_orders: old.epoch_stake_orders,
            epoch_unstake_orders: old.epoch_unstake_orders,
            epoch_last_clearing: old.epoch_last_clearing,

            total_for_staking: old.total_for_staking,
            total_actually_staked: old.total_actually_staked,
            total_stake_shares: old.total_stake_shares,
            total_meta: old.total_meta,
            total_unstaked_and_waiting: old.total_unstaked_and_waiting,

            total_unstake_claims: old.total_unstake_claims,

            accumulated_staked_rewards: old.accumulated_staked_rewards,

            accounts: old.accounts,

            staking_pools: old.staking_pools,

            loan_requests: old.loan_requests,

            nslp_liquidity_target: old.nslp_liquidity_target,
            nslp_max_discount_basis_points: old.nslp_max_discount_basis_points,
            nslp_min_discount_basis_points: old.nslp_min_discount_basis_points,

            staker_meta_mult_pct: old.staker_meta_mult_pct,
            stnear_sell_meta_mult_pct: old.stnear_sell_meta_mult_pct,
            lp_provider_meta_mult_pct: old.lp_provider_meta_mult_pct,

            operator_account_id: old.operator_account_id,
            operator_rewards_fee_basis_points: old.operator_rewards_fee_basis_points,
            operator_swap_cut_basis_points: old.operator_swap_cut_basis_points,

            treasury_account_id: old.treasury_account_id,
            treasury_swap_cut_basis_points: old.treasury_swap_cut_basis_points,

            // Configurable info for [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
            web_app_url: old.web_app_url,
            auditor_account_id: old.auditor_account_id,

            meta_token_account_id: old.meta_token_account_id,
            min_deposit_amount: old.min_deposit_amount,

            est_meta_rewards_stakers: old.est_meta_rewards_stakers,
            est_meta_rewards_lu: old.est_meta_rewards_lu,
            est_meta_rewards_lp: old.est_meta_rewards_lp,
            max_meta_rewards_stakers: old.max_meta_rewards_stakers,
            max_meta_rewards_lu: old.max_meta_rewards_lu,
            max_meta_rewards_lp: old.max_meta_rewards_lp,

            unstaked_for_rebalance: old.unstaked_for_rebalance, 
            unstake_for_rebalance_cap_bp: old.unstake_for_rebalance_cap_bp,
        };
    }
}

'''
'''--- metapool/src/owner.rs ---
use crate::*;
use near_sdk::{near_bindgen, serde::Serialize};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GSPRUResultJson {
    sp_inx:u16, 
    extra:U128String, 
    count_unblocked:u16,
    count_with_stake:u16,
    total_extra:U128String
}

#[near_bindgen]
impl MetaPool {
    // OWNER'S METHODS and other general view-methods

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_operator_or_owner();
        assert!(!self.staking_paused, "The staking is already paused");
        self.staking_paused = true;
    }
    /// unPauses pool staking.
    pub fn un_pause_staking(&mut self) {
        self.assert_operator_or_owner();
        assert!(self.staking_paused, "The staking is not paused");
        self.staking_paused = false;
    }

    //---------------------------------
    // staking-pools-list (SPL) management
    //---------------------------------

    // Note: this fn may run out of gas when there are more than 3800 pools registered (current amount is 57)
    // The limit is high, but in case it is needed, recommendation is to add from_index and end_index as parameters in this function
    /// get the current list of pools
    pub fn get_staking_pool_list(&self) -> Vec<StakingPoolJSONInfo> {
        let mut result = Vec::with_capacity(self.staking_pools.len());
        for inx in 0..self.staking_pools.len() {
            let elem = &self.staking_pools[inx];
            result.push(StakingPoolJSONInfo {
                inx: inx as u16,
                account_id: elem.account_id.clone(),
                weight_basis_points: elem.weight_basis_points,
                staked: elem.staked.into(),
                unstaked: elem.unstaked.into(),
                last_asked_rewards_epoch_height: elem.last_asked_rewards_epoch_height.into(),
                unstaked_requested_epoch_height: elem.unstk_req_epoch_height.into(),
                busy_lock: elem.busy_lock,
            })
        }
        return result;
    }

    ///remove staking pool from list *if it's empty*
    pub fn remove_staking_pool(&mut self, inx: u16) {
        self.assert_operator_or_owner();

        let sp = &self.staking_pools[inx as usize];
        if !sp.is_empty() {
            panic!("sp is not empty")
        }
        self.staking_pools.remove(inx as usize);
    }

    /// add a new staking pool, checking that it is not already in the list
    /// added with weight_basis_points = 0, to preserve sum(weights)=100%
    pub fn add_staking_pool(&mut self, account_id: AccountId) {
        self.assert_operator_or_owner();
        assert!(
            account_id.ends_with(".poolv1.near") 
                || account_id.ends_with(".pool.near") 
                || account_id.ends_with(".pool.f863973.m0") 
                || account_id.ends_with(".testnet"),
            "invalid staking-pool contract account {}", account_id);
        // assert that is not already in the list
        assert!(
            self.staking_pools.iter().find(|x| x.account_id==account_id).is_none(),
            "already in the list"
        );
        // not in list, add
        self.staking_pools
            .push(StakingPoolInfo::new(account_id, 0));
    }

    /// update existing staking pools list, field weight_basis_points
    /// sum(weight_basis_points) must be eq 100%
    /// can not add, remove or change order of staking pools
    #[payable]
    pub fn set_staking_pools(&mut self, list: Vec<StakingPoolArgItem>) {
        assert_one_yocto();
        self.assert_operator_or_owner();
        // make sure no additions or removals
        assert_eq!(list.len(),self.staking_pools.len());
        // process the list
        let mut total_weight = 0;
        for sp_inx in 0..list.len() {
            // assert same order
            assert_eq!(self.staking_pools[sp_inx].account_id, list[sp_inx].account_id);
            // get weight_basis_points to set
            let bp = list[sp_inx].weight_basis_points;
            // no staking pool can have 50% or more
            assert!(bp<5000);
            // if there's a change
            if self.staking_pools[sp_inx].weight_basis_points != bp {
                // check pool is not busy
                assert!(!self.staking_pools[sp_inx].busy_lock,"sp {} is busy",sp_inx);
                // set new value
                self.staking_pools[sp_inx].weight_basis_points = bp;
            }
            // keep totals
            total_weight += bp;
        }
        assert_eq!(total_weight,10000);
    }

    //--------------------------------------------------
    /// computes unstaking delay on current situation
    pub fn compute_current_unstaking_delay(&self, amount: U128String) -> u16 {
        return self.internal_compute_current_unstaking_delay(amount.0) as u16;
    }

    //---------------------------------
    // owner & operator accounts
    //---------------------------------

    pub fn get_operator_account_id(&self) -> AccountId {
        return self.operator_account_id.clone();
    }
    pub fn set_operator_account_id(&mut self, account_id: AccountId) {
        assert!(env::is_valid_account_id(account_id.as_bytes()));
        self.assert_owner_calling();
        self.operator_account_id = account_id;
        //all key accounts must be different
        self.assert_key_accounts_are_different();
    }
    pub fn get_treasury_account_id(&self) -> AccountId {
        return self.treasury_account_id.clone();
    }
    pub fn set_treasury_account_id(&mut self, account_id: AccountId) {
        assert!(env::is_valid_account_id(account_id.as_bytes()));
        self.assert_owner_calling();
        self.treasury_account_id = account_id;
        self.assert_key_accounts_are_different();
    }
    pub fn set_owner_id(&mut self, owner_id: AccountId) {
        assert!(env::is_valid_account_id(owner_id.as_bytes()));
        self.assert_owner_calling();
        self.owner_account_id = owner_id.into();
        self.assert_key_accounts_are_different();
    }

    /// The amount of tokens that were deposited to the staking pool.
    /// NOTE: The actual balance can be larger than this known deposit balance due to staking
    /// rewards acquired on the staking pool.
    /// To refresh the amount the owner can call `refresh_staking_pool_balance`.
    pub fn get_known_deposited_balance(&self) -> U128String {
        return self.total_actually_staked.into();
    }

    /// full account info
    /// Returns JSON representation of the account for the given account ID.
    pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult {
        let acc = self.accounts.get(&account_id).unwrap_or_default();
        let staked_near = self.amount_from_stake_shares(acc.stake_shares);
        // trip_rewards = current_stnear + trip_accum_unstakes - trip_accum_stakes - trip_start_stnear;
        // note: trip_start_stnear is OBSOLETE
        // let trip_rewards = (staked_near + acc.trip_accum_unstakes)
        //     .saturating_sub(acc.trip_accum_stakes + acc.trip_start_stnear);
        //Liquidity Pool share value
        let mut nslp_share_value: u128 = 0;
        let mut nslp_share_bp: u16 = 0;
        if acc.nslp_shares != 0 {
            let nslp_account = self.internal_get_nslp_account();
            nslp_share_value = acc.valued_nslp_shares(self, &nslp_account); //in NEAR
            nslp_share_bp = proportional(10_000, acc.nslp_shares, nslp_account.nslp_shares) as u16;
        }
        return GetAccountInfoResult {
            account_id,
            available: acc.available.into(),
            st_near: acc.stake_shares.into(),
            valued_st_near: staked_near.into(),
            realized_meta: 0.into(), // internal $META incentives have been disabled
            meta: acc.realized_meta.into(), // send here for reference - disabled, historic data
            unstaked: acc.unstaked.into(),
            unstaked_requested_unlock_epoch: acc.unstaked_requested_unlock_epoch.into(),
            unstake_full_epochs_wait_left: acc
                .unstaked_requested_unlock_epoch
                .saturating_sub(env::epoch_height())
                as u16,
            can_withdraw: (env::epoch_height() >= acc.unstaked_requested_unlock_epoch),
            total: (acc.available + staked_near + acc.unstaked).into(),
            // trip-meter
            trip_start: acc.trip_start.into(),
            trip_start_stnear: acc.trip_start_stnear.into(), // note: OBSOLETE/REPURPOSED
            trip_accum_stakes: (if acc.staking_meter.delta_staked >= 0 {
                acc.staking_meter.delta_staked as u128
            } else {
                0 as u128
            })
            .into(),
            trip_accum_unstakes: (if acc.staking_meter.delta_staked < 0 {
                -acc.staking_meter.delta_staked as u128
            } else {
                0 as u128
            })
            .into(),
            trip_rewards: (staked_near + acc.trip_accum_unstakes)
                .saturating_sub(acc.trip_accum_stakes)
                .into(), // extra-nears not related to stake/unstake or transfers

            nslp_shares: acc.nslp_shares.into(),
            nslp_share_value: nslp_share_value.into(),
            nslp_share_bp, //% owned as basis points
        };
    }

    /// NEP-129 get information about this contract
    /// returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub fn get_contract_info(&self) -> NEP129Response {
        return NEP129Response {
            dataVersion: 1,
            name: CONTRACT_NAME.into(),
            version: CONTRACT_VERSION.into(),
            source: SOURCE_URL.into(),
            standards: vec!["NEP-141".into(), "NEP-145".into(), "SP".into()], //SP=>core-contracts/Staking-pool
            webAppUrl: self.web_app_url.clone(),
            developersAccountId: DEVELOPERS_ACCOUNT_ID.into(),
            auditorAccountId: self.auditor_account_id.clone(),
        };
    }

    /// sets configurable contract info [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    // Note: params are not Option<String> so the user can not inadvertently set null to data by not including the argument
    pub fn set_contract_info(&mut self, web_app_url: String, auditor_account_id: String) {
        self.assert_owner_calling();
        self.web_app_url = if web_app_url.len() > 0 {
            Some(web_app_url)
        } else {
            None
        };
        self.auditor_account_id = if auditor_account_id.len() > 0 {
            Some(auditor_account_id)
        } else {
            None
        };
    }

    // simple fn to get st_near_price for use by cross-contract calls 
    pub fn get_st_near_price(&self) -> U128String {
        // get how many near one stNEAR is worth
        self.amount_from_stake_shares(ONE_E24).into()
    }

    /// get contract totals
    /// Returns JSON representation of the contract state
    pub fn get_contract_state(&self) -> GetContractStateResult {
        let nslp_account = self.internal_get_nslp_account();

        return GetContractStateResult {
            env_epoch_height: env::epoch_height().into(),
            contract_account_balance: self.contract_account_balance.into(),
            total_available: self.total_available.into(),
            total_for_staking: self.total_for_staking.into(),
            total_actually_staked: self.total_actually_staked.into(),
            epoch_stake_orders: self.epoch_stake_orders.into(),
            epoch_unstake_orders: self.epoch_unstake_orders.into(),
            total_unstaked_and_waiting: self.total_unstaked_and_waiting.into(),
            accumulated_staked_rewards: self.accumulated_staked_rewards.into(),
            total_unstake_claims: self.total_unstake_claims.into(),
            retrieved_for_unstake_claims: self.retrieved_for_unstake_claims.into(),
            reserve_for_unstake_claims: self.retrieved_for_unstake_claims.into(), // old name keep for backward compat
            total_stake_shares: self.total_stake_shares.into(), // stNEAR total supply
            st_near_price: self.amount_from_stake_shares(ONE_E24).into(), //how much nears are 1 stNEAR
            total_meta: self.total_meta.into(),
            accounts_count: self.accounts.len().into(),
            staking_pools_count: self.staking_pools.len() as u16,
            nslp_liquidity: nslp_account.available.into(),
            nslp_stnear_balance: nslp_account.stake_shares.into(), //how much stnear does the nslp have?
            nslp_target: self.nslp_liquidity_target.into(),
            nslp_share_price: self.amount_from_nslp_shares(ONE_E24, &nslp_account).into(), // price of one LP share (1e24 yocto_shares)
            nslp_total_shares: nslp_account.nslp_shares.into(), // total nspl shares. price = value/total_shares
            nslp_current_discount_basis_points: self
                .internal_get_discount_basis_points(nslp_account.available, TEN_NEAR),
            nslp_min_discount_basis_points: self.nslp_min_discount_basis_points,
            nslp_max_discount_basis_points: self.nslp_max_discount_basis_points,
            min_deposit_amount: self.min_deposit_amount.into(),
            est_meta_rewards_stakers: self.est_meta_rewards_stakers.into(),
            est_meta_rewards_lu: self.est_meta_rewards_lu.into(), //liquid-unstakers
            est_meta_rewards_lp: self.est_meta_rewards_lp.into(), //liquidity-providers
            max_meta_rewards_stakers: self.max_meta_rewards_stakers.into(),
            max_meta_rewards_lu: self.max_meta_rewards_lu.into(), //liquid-unstakers
            max_meta_rewards_lp: self.max_meta_rewards_lp.into(), //liquidity-providers
            unstaked_for_rebalance: self.unstaked_for_rebalance.into(), //floating for rebalance
        };
    }

    /// Returns JSON representation of contract parameters
    pub fn get_contract_params(&self) -> ContractParamsJSON {
        return ContractParamsJSON {
            nslp_liquidity_target: self.nslp_liquidity_target.into(),
            nslp_max_discount_basis_points: self.nslp_max_discount_basis_points,
            nslp_min_discount_basis_points: self.nslp_min_discount_basis_points,

            staker_meta_mult_pct: self.staker_meta_mult_pct,
            stnear_sell_meta_mult_pct: self.stnear_sell_meta_mult_pct,
            lp_provider_meta_mult_pct: self.lp_provider_meta_mult_pct,
            operator_rewards_fee_basis_points: self.operator_rewards_fee_basis_points,
            operator_swap_cut_basis_points: self.operator_swap_cut_basis_points,
            treasury_swap_cut_basis_points: self.treasury_swap_cut_basis_points,

            min_deposit_amount: self.min_deposit_amount.into(),
            min_stake_unstake_amount_movement: MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT.into(),
            unstake_for_rebalance_cap_bp: self.unstake_for_rebalance_cap_bp,
        };
    }

    /// Sets contract parameters
    pub fn set_contract_params(&mut self, params: ContractParamsJSON) {
        self.assert_operator_or_owner();
        assert!(params.nslp_max_discount_basis_points > params.nslp_min_discount_basis_points);

        self.nslp_liquidity_target = params.nslp_liquidity_target.0;
        self.nslp_max_discount_basis_points = params.nslp_max_discount_basis_points;
        self.nslp_min_discount_basis_points = params.nslp_min_discount_basis_points;

        self.staker_meta_mult_pct = params.staker_meta_mult_pct;
        self.stnear_sell_meta_mult_pct = params.stnear_sell_meta_mult_pct;
        self.lp_provider_meta_mult_pct = params.lp_provider_meta_mult_pct;
        self.operator_rewards_fee_basis_points = params.operator_rewards_fee_basis_points;
        self.operator_swap_cut_basis_points = params.operator_swap_cut_basis_points;
        self.treasury_swap_cut_basis_points = params.treasury_swap_cut_basis_points;

        self.min_deposit_amount = params.min_deposit_amount.0;
        assert!(params.unstake_for_rebalance_cap_bp<2000); // hard coded limit, no more than 20%
        self.unstake_for_rebalance_cap_bp = params.unstake_for_rebalance_cap_bp;
    }

    /// Sets contract parameters
    pub fn set_reward_multipliers(
        &mut self,
        stakers_pct: u16,
        lp_pct: u16,
        liquid_unstake_pct: u16,
    ) {
        self.assert_operator_or_owner();
        self.staker_meta_mult_pct = stakers_pct;
        self.stnear_sell_meta_mult_pct = liquid_unstake_pct;
        self.lp_provider_meta_mult_pct = lp_pct;
    }

    /// Sets contract parameters
    pub fn set_max_meta_rewards(&mut self, stakers: u32, lu: u32, lp: u32) {
        self.assert_operator_or_owner();
        self.max_meta_rewards_stakers = stakers as u128 * ONE_NEAR; //stakers
        self.max_meta_rewards_lu = lu as u128 * ONE_NEAR; //liquid-unstakers
        self.max_meta_rewards_lp = lp as u128 * ONE_NEAR; //liquidity-providers
    }

    /// get sp (staking-pool) info
    /// Returns JSON representation of sp recorded state
    pub fn get_sp_info(&self, inx: u16) -> StakingPoolJSONInfo {
        assert!((inx as usize) < self.staking_pools.len());
        let sp = &self.staking_pools[inx as usize];

        return StakingPoolJSONInfo {
            inx,
            account_id: sp.account_id.clone(),
            weight_basis_points: sp.weight_basis_points.clone(),
            staked: sp.staked.into(),
            unstaked: sp.unstaked.into(),
            unstaked_requested_epoch_height: sp.unstk_req_epoch_height.into(),
            last_asked_rewards_epoch_height: sp.last_asked_rewards_epoch_height.into(),
            busy_lock: sp.busy_lock,
        };
    }

    pub fn get_staking_pool_requiring_unstake(self) -> GSPRUResultJson 
    {
        let gspru = self.internal_get_staking_pool_requiring_unstake();
        GSPRUResultJson {
            sp_inx: gspru.sp_inx, 
            extra: gspru.extra.into(),
            count_unblocked: gspru.count_unblocked,
            count_with_stake: gspru.count_with_stake,
            total_extra: gspru.total_extra.into(),
        }
    }

}

'''
'''--- metapool/src/reward_meter.rs ---
use crate::*;

pub use crate::types::*;
pub use crate::utils::*;

// -----------------
// Reward meter utility
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct RewardMeter {
    ///added with staking
    ///subtracted on unstaking. WARN: Since unstaking can include rewards, delta_staked *CAN BECOME NEGATIVE*
    pub delta_staked: i128, //i128 changing this requires accounts migration
    pub last_multiplier_pct: u16, // (pct: 100 => x1, 200 => x2)
}

impl Default for RewardMeter {
    fn default() -> Self {
        Self {
            delta_staked: 0,
            last_multiplier_pct: 100,
        }
    }
}

impl RewardMeter {
    ///register a stake (to be able to compute rewards later)
    pub fn stake(&mut self, value: u128) {
        assert!(value <= std::i128::MAX as u128);
        self.delta_staked += value as i128;
    }
    ///register a unstake (to be able to compute rewards later)
    pub fn unstake(&mut self, value: u128) {
        assert!(value <= std::i128::MAX as u128);
        self.delta_staked -= value as i128;
    }

    #[inline]
    pub fn reset(&mut self, valued_shares: u128) {
        assert!(valued_shares <= std::i128::MAX as u128);
        self.delta_staked = valued_shares as i128; // reset meter to Zero difference
    }
}

'''
'''--- metapool/src/staking_pools.rs ---
use crate::*;

pub use crate::types::*;
pub use crate::utils::*;

// ------------------
// Staking Pools Data
// ------------------

//-------------------------
//--  STAKING POOL Info  --
//-------------------------
/// items in the Vec of staking pools
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct StakingPoolInfo {
    pub account_id: AccountId,

    //how much of the meta-pool must be staked in this pool
    //0=> do not stake, only unstake
    //100 => 1% , 250=>2.5%, etc. -- max: 10000=>100%
    pub weight_basis_points: u16,

    //if we've made an async call to this pool
    pub busy_lock: bool,

    //total staked here
    pub staked: u128,

    //total unstaked in this pool
    pub unstaked: u128,

    //set when the unstake command is passed to the pool
    //waiting period is until env::EpochHeight == unstaked_requested_epoch_height+NUM_EPOCHS_TO_UNLOCK
    //We might have to block users from unstaking if all the pools are in a waiting period
    pub unstk_req_epoch_height: EpochHeight, // = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK

    //EpochHeight where we asked the sp what were our staking rewards
    pub last_asked_rewards_epoch_height: EpochHeight,
}

impl StakingPoolInfo {
    pub fn is_empty(&self) -> bool {
        return self.busy_lock == false
            && self.weight_basis_points == 0
            && self.staked == 0
            && self.unstaked == 0;
    }
    pub fn new(account_id: AccountId, weight_basis_points: u16) -> Self {
        return Self {
            account_id,
            weight_basis_points,
            busy_lock: false,
            staked: 0,
            unstaked: 0,
            unstk_req_epoch_height: 0,
            last_asked_rewards_epoch_height: 0,
        };
    }
    pub fn total_balance(&self) -> u128 {
        self.staked + self.unstaked
    }

    // sometimes the core-contracts/stake-pool does not unstakes all, it leaves a few yoctos as "unstaked" 
    // so we trust the bot to retrieve all unstaked at the start of the epoch, and in orde to know
    // if a sp can be unstaked again, we just check that the last unstake waiting period is over
    pub fn wait_period_ended(&self) -> bool {
        let epoch_height = env::epoch_height();
        if self.unstk_req_epoch_height > epoch_height {
            //bad data at unstk_req_epoch_height or there was a hard-fork
            return true;
        }
        //true if we reached epoch_requested+NUM_EPOCHS_TO_UNLOCK
        return epoch_height >= self.unstk_req_epoch_height + NUM_EPOCHS_TO_UNLOCK;
    }
}

// -------------------
// Staking Pools Trait
// -------------------
#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128String;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128String);
    fn withdraw_all(&mut self);

    fn stake(&mut self, amount: U128String);

    fn unstake(&mut self, amount: U128String);

    fn unstake_all(&mut self);
}

'''
'''--- metapool/src/types.rs ---
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use uint::construct_uint;

//----------------------------------------
// CONSTANTS, types and interface structs
//----------------------------------------

// this contract token symbol
pub const STNEAR: &str = "stNEAR";

// internal pseudo-account (must be an invalid near-account-id)
pub const NSLP_INTERNAL_ACCOUNT: &str = "..NSLP..";

/// useful constants
pub const NO_DEPOSIT: u128 = 0;
pub const ONE_E24: u128 = 1_000_000_000_000_000_000_000_000;
pub const NEAR: u128 = ONE_E24;
pub const ONE_NEAR: u128 = NEAR;
pub const NEAR_CENT: u128 = NEAR / 100;
pub const ONE_MILLI_NEAR: u128 = NEAR / 1_000;
pub const ONE_MICRO_NEAR: u128 = NEAR / 1_000_000;
pub const TWO_NEAR: u128 = 2 * NEAR;
pub const FIVE_NEAR: u128 = 5 * NEAR;
pub const TEN_NEAR: u128 = 10 * NEAR;
pub const K_NEAR: u128 = 1_000 * NEAR;

///if there's less than MIN_MOVEMENT NEAR to stake/unstake, wait until there's more to justify the call & tx-fees
pub const MIN_STAKE_AMOUNT: u128 = ONE_NEAR;

pub const TGAS: u64 = 1_000_000_000_000;

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
/// If all staking-pools are unstaking, the user might have to wait 2*NUM_EPOCHS_TO_UNLOCK
pub const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4; //0 for testing in guild-net, 4 for mainnet & testnet;

/// The contract keeps at least 35 NEAR in the account to avoid being transferred out to cover
/// contract code storage and some internal state.
pub const MIN_BALANCE_FOR_STORAGE: u128 = 35_000_000_000_000_000_000_000_000;
/// if the remainder falls below this amount, rebalance is not performed
pub const MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT: u128 = TEN_NEAR;

//cut on swap fees
pub const DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS: u16 = 2500; // 25% swap fees go to Treasury
pub const DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS: u16 = 300; // 3% swap fees go to operator
                                                             //Fee on staking rewards
pub const DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS: u16 = 50; // 0.5% -- CANT BE HIGHER THAN 1000 / 10%

//Note: License forbids you to change the following 3 constants and/or the developer's distribution mechanism
pub const DEVELOPERS_ACCOUNT_ID: &str = "developers.near";
pub const DEVELOPERS_REWARDS_FEE_BASIS_POINTS: u16 = 20; // 0.2% from rewards
pub const DEVELOPERS_SWAP_CUT_BASIS_POINTS: u16 = 200; // 2% swap fees go to authors

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Raw type for duration in nanoseconds
pub type Duration = u64;
/// Raw type for timestamp in nanoseconds or Unix Ts in milliseconds
pub type Timestamp = u64;

/// Balance wrapped into a struct for JSON serialization as a string.
pub type U128String = U128;
pub type U64String = U64;

pub type EpochHeight = u64;

/// NEP-129 get information about this contract
/// returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[allow(non_snake_case)]
pub struct NEP129Response {
    pub dataVersion: u16,
    pub name: String,
    pub version: String,
    pub source: String,
    pub standards: Vec<String>,
    pub webAppUrl: Option<String>,
    pub developersAccountId: String,
    pub auditorAccountId: Option<String>,
}

/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

/// staking-pool trait
/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

/// Struct returned from get_account_info
/// div-pool full info
/// Represents account data as as JSON compatible struct
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GetAccountInfoResult {
    pub account_id: AccountId,

    /// The available balance that can be withdrawn
    pub available: U128,

    /// The amount of stNEAR owned (shares owned)
    pub st_near: U128,
    ///stNEAR owned valued in NEAR
    pub valued_st_near: U128, // st_near * stNEAR_price

    //META owned (including pending rewards)
    pub meta: U128,
    //realized META (without pending rewards)
    pub realized_meta: U128,

    /// The amount unstaked waiting for withdraw
    pub unstaked: U128,

    /// The epoch height when the unstaked will be available
    pub unstaked_requested_unlock_epoch: U64,
    /// How many epochs we still have to wait until unstaked_requested_unlock_epoch (epoch_unlock - env::epoch_height )
    pub unstake_full_epochs_wait_left: u16,
    ///if env::epoch_height()>=unstaked_requested_unlock_epoch
    pub can_withdraw: bool,
    /// total amount the user holds in this contract: account.available + account.staked + current_rewards + account.unstaked
    pub total: U128,

    //-- STATISTICAL DATA --
    // User's statistical data
    // These fields works as a car's "trip meter". The user can reset them to zero.
    /// trip_start: (unix timestamp) this field is set at account creation, so it will start metering rewards
    pub trip_start: U64,
    /// How many stnear the user had at "trip_start".
    pub trip_start_stnear: U128, // OBSOLETE
    /// how much the user staked since trip start. always incremented
    pub trip_accum_stakes: U128,
    /// how much the user unstaked since trip start. always incremented
    pub trip_accum_unstakes: U128,
    /// to compute trip_rewards we start from current_stnear, undo unstakes, undo stakes and finally subtract trip_start_stnear
    /// trip_rewards = current_stnear + trip_accum_unstakes - trip_accum_stakes - trip_start_stnear;
    /// trip_rewards = current_stnear + trip_accum_unstakes - trip_accum_stakes - trip_start_stnear;
    pub trip_rewards: U128,

    //Liquidity Pool
    pub nslp_shares: U128,
    pub nslp_share_value: U128,
    pub nslp_share_bp: u16, //basis points, % user owned
}

/// Struct returned from get_contract_state
/// div-pool state info
/// Represents contact state as as JSON compatible struct
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
/// check struct MetaPool for explanations on each field
pub struct GetContractStateResult {
    //current env::epoch_height() .- to check gainst unstake-delay end epoch
    pub env_epoch_height: U64,

    pub contract_account_balance: U128String,

    pub total_available: U128String,

    pub total_for_staking: U128String,

    pub total_actually_staked: U128String,

    pub epoch_stake_orders: U128String,
    pub epoch_unstake_orders: U128String,
    pub total_unstaked_and_waiting: U128String,

    pub total_stake_shares: U128String,

    pub st_near_price: U128String,

    pub total_unstake_claims: U128String,

    pub retrieved_for_unstake_claims: U128String, // new name
    pub reserve_for_unstake_claims: U128String, // old name, keep for backward comp

    pub total_meta: U128String,

    pub accumulated_staked_rewards: U128String,

    pub nslp_liquidity: U128String,
    pub nslp_target: U128String,
    pub nslp_stnear_balance: U128String,
    pub nslp_share_price: U128String,
    pub nslp_total_shares: U128String,

    pub nslp_current_discount_basis_points: u16,
    pub nslp_min_discount_basis_points: u16,
    pub nslp_max_discount_basis_points: u16,

    //how many accounts there are
    pub accounts_count: U64,

    //count of pools to diversify in
    pub staking_pools_count: u16,

    pub min_deposit_amount: U128String,

    pub est_meta_rewards_stakers: U128String, //stakers
    pub est_meta_rewards_lp: U128String,      //liquidity-providers
    pub est_meta_rewards_lu: U128String,      //liquid-unstakers
    pub max_meta_rewards_stakers: U128String, //stakers
    pub max_meta_rewards_lp: U128String,      //liquidity-providers
    pub max_meta_rewards_lu: U128String,      //liquid-unstakers

    pub unstaked_for_rebalance: U128String,
}

/// Struct returned from get_contract_params
/// div-pool parameters info
/// Represents contact parameters as JSON compatible struct
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractParamsJSON {
    ///NEAR/stNEAR Liquidity pool 1% fee target. If Liquidity=target, fee is 1%
    pub nslp_liquidity_target: U128String,
    ///NEAR/stNEAR Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //10%
    ///NEAR/stNEAR Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.1%

    //The next 3 values define meta rewards multipliers %. (100 => 1x, 200 => 2x, ...)
    ///for each stNEAR paid staking reward, reward stNEAR holders with g-stNEAR. default:5x. reward META = rewards * mult_pct / 100
    pub staker_meta_mult_pct: u16,
    ///for each stNEAR paid as discount, reward stNEAR sellers with g-stNEAR. default:1x. reward META = discounted * mult_pct / 100
    pub stnear_sell_meta_mult_pct: u16,
    ///for each stNEAR paid as discount, reward stNEAR sellers with g-stNEAR. default:20x. reward META = fee * mult_pct / 100
    pub lp_provider_meta_mult_pct: u16,

    /// operator_fee_basis_points. 100 basis point => 1%. E.g.: owner_fee_basis_points=50 => 0.5% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// operator_cut_basis_points.
    pub operator_swap_cut_basis_points: u16,
    /// treasury_cut_basis_points.
    pub treasury_swap_cut_basis_points: u16,
    pub min_deposit_amount: U128String,
    pub min_stake_unstake_amount_movement: U128String,

    pub unstake_for_rebalance_cap_bp: u16,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RemoveLiquidityResult {
    pub near: U128String,
    pub st_near: U128String,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LiquidUnstakeResult {
    pub near: U128String,
    pub fee: U128String,
    pub meta: U128String,
}

// get_staking_pool_list returns StakingPoolJSONInfo[]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolJSONInfo {
    pub inx: u16,
    pub account_id: String,
    pub weight_basis_points: u16,
    pub staked: U128String,
    pub unstaked: U128String,
    pub unstaked_requested_epoch_height: U64String,
    //EpochHeight where we asked the sp what were our staking rewards
    pub last_asked_rewards_epoch_height: U64String,
    pub busy_lock: bool,
}

/// struct used as parameter for set_staking_pools
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolArgItem {
    pub account_id: AccountId, 
    pub weight_basis_points: u16
} 

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct VLoanRequest {
    //total requested
    pub amount_requested: u128,
}

'''
'''--- metapool/src/utils.rs ---
pub use crate::types::*;
use near_sdk::{env, PromiseResult};

#[macro_export]
macro_rules! event {
    ($($arg:tt)*) => ({
        env::log(format!($($arg)*).as_bytes());
    });
}

#[macro_export]
#[cfg(debug_log)]
macro_rules! debug_log {
    ($($arg:tt)*) => ({
        env::log(format!($($arg)*).as_bytes());
    });
}
#[macro_export]
#[cfg(not (debug_log))]
macro_rules! debug_log {
    ($($arg:tt)*) => ({})
}

pub fn assert_min_balance(amount: u128) {
    assert!(amount > 0, "Amount should be positive");
    assert!(
        env::account_balance() >= MIN_BALANCE_FOR_STORAGE
            && env::account_balance() - MIN_BALANCE_FOR_STORAGE > amount,
        "The contract account balance can't go lower than MIN_BALANCE"
    );
}

pub fn assert_one_yocto() {
    assert!(
        env::attached_deposit() == 1,
        "the function requires 1 yocto attachment"
    );
}

pub fn assert_lockup_contract_calling() {
    assert!(
        env::predecessor_account_id() == "lockup-meta-pool.near"
        || env::predecessor_account_id() == "lockup.meta-v2.pool.testnet",
        "the function can only be operated by lockup-meta-pool.near"
    );
}

/// verify if it a lockup account
pub fn is_lockup_account(account_id: &String) -> bool{
    account_id.ends_with(".lockup.near") 
    || account_id.ends_with(".lockupy.testnet") 
}

/// assert it is not a lockup account
pub fn assert_not_lockup_account_calling() {
    assert!(!is_lockup_account(&env::predecessor_account_id()),"a .lockup.near account can not be used here");
}

pub fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

pub fn apply_pct(basis_points: u16, amount: u128) -> u128 {
    return (U256::from(basis_points) * U256::from(amount) / U256::from(10_000)).as_u128();
}
pub fn apply_multiplier(amount: u128, percentage: u16) -> u128 {
    return (U256::from(amount) * U256::from(percentage as u64 * 10_u64) / U256::from(100)).as_u128();
}

//-- SHARED COMPUTATIONS

/// returns amount * numerator/denominator
pub fn proportional(amount: u128, numerator: u128, denominator: u128) -> u128 {
    return (U256::from(amount) * U256::from(numerator) / U256::from(denominator)).as_u128();
}

/// Returns the number of shares corresponding to the given near amount at current share_price
/// if the amount & the shares are incorporated, price remains the same
//
// price = total_amount / total_shares
// Price is fixed
// (total_amount + amount) / (total_shares + num_shares) = total_amount / total_shares
// (total_amount + amount) * total_shares = total_amount * (total_shares + num_shares)
// amount * total_shares = total_amount * num_shares
// num_shares = amount * total_shares / total_amount
pub fn shares_from_amount(amount: u128, total_amount: u128, total_shares: u128) -> u128 {
    if total_shares == 0 {
        //first person getting shares
        return amount;
    }
    if amount == 0 || total_amount == 0 {
        return 0;
    }
    return proportional(total_shares, amount, total_amount);
}

/// Returns the amount corresponding to the given number of shares at current share_price
// price = total_amount / total_shares
// amount = num_shares * price
// amount = num_shares * total_amount / total_shares
pub fn amount_from_shares(num_shares: u128, total_amount: u128, total_shares: u128) -> u128 {
    if total_shares == 0 || num_shares == 0 {
        return 0;
    };
    return proportional(num_shares, total_amount, total_shares);
}

/// is_close returns true if total-0.001N < requested < total+0.001N
/// it is used to avoid leaving "dust" in the accounts and to manage rounding simplification for the users
/// e.g.: The user has 999999952342335499220000001 yN => 99.9999952342335499220000001 N
/// the UI shows 5 decimals rounded, so the UI shows "100 N". If the user chooses to liquid_unstake 100 N
/// the contract should take 100 N as meaning "all my tokens", and it will do because:
/// 99.9999952342335499220000001-0.001 < 100 < 99.9999952342335499220000001+0.001
#[inline]
pub fn is_close(requested: u128, total: u128) -> bool {
    requested >= total.saturating_sub(ONE_MILLI_NEAR) && requested <= total + ONE_MILLI_NEAR
}

'''
'''--- metapool/tests/sim/main.rs ---
mod sim_contract_state;
mod sim_setup;
mod sim_steps;
mod sim_utils;

//mod simulation_simple; //simple cases
//mod simulation_desk_check; //desk check
mod simulation_fuzzy; //fuzzy tests, check invariants after each step

'''
'''--- metapool/tests/sim/sim_contract_state.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::{Base58PublicKey, U128},
    serde::{Deserialize, Serialize},
    serde_json::json,
    serde_json::Value,
    *,
};
use near_sdk_sim::{
    account::AccessKey,
    call, deploy, init_simulator,
    near_crypto::{KeyType, SecretKey, Signer},
    to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
    STORAGE_AMOUNT,
};

use crate::sim_setup::*;
use crate::sim_utils::*;
use metapool::*;

///
/// https://docs.google.com/spreadsheets/d/1VYynsw2yOGIE_0bFdy4CabnI1fnTXDEEffDVbYZSq6Q/edit?usp=sharing
///
#[derive(Debug, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct State {
    pub epoch: u64,

    pub contract_account_balance: u128,
    pub retrieved_for_unstake_claims: u128,
    pub total_available: u128,

    pub epoch_stake_orders: u128,
    pub epoch_unstake_orders: u128,

    pub total_for_staking: u128,
    pub total_actually_staked: u128,
    pub to_stake_delta: i128,

    pub total_unstaked_and_waiting: u128,

    pub unstake_claims: u128,
    pub unstake_claims_available_long_term: u128, //how much we have to fulfill unstake claims

    pub staked_in_pools: u128,
    pub unstaked_in_pools: u128,
    pub total_in_pools: u128,

    pub unstaked_for_rebalance: u128,

    pub sps: Vec<Value>,
}

#[derive(Debug, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StateDiff {
    pub contract_account_balance: i128,
    pub retrieved_for_unstake_claims: i128,
    pub total_available: i128,

    pub epoch_stake_orders: i128,
    pub epoch_unstake_orders: i128,

    pub total_for_staking: i128,
    pub total_actually_staked: i128,
    pub to_stake_delta: i128,

    pub total_unstaked_and_waiting: i128,

    pub unstake_claims: i128,
    pub unstake_claims_available_long_term: i128, // how much we have to fulfill unstake claims long-term

    pub staked_in_pools: i128,
    pub unstaked_in_pools: i128,
    pub total_in_pools: i128,

    pub unstaked_for_rebalance: i128,
}
impl StateDiff {
    pub fn has_data(&self) -> bool {
        self.contract_account_balance != 0
            || self.retrieved_for_unstake_claims != 0
            || self.total_available != 0
            || self.epoch_stake_orders != 0
            || self.epoch_unstake_orders != 0
            || self.total_for_staking != 0
            || self.total_actually_staked != 0
            || self.to_stake_delta != 0
            || self.total_unstaked_and_waiting != 0
            || self.unstake_claims != 0
            || self.unstake_claims_available_long_term != 0
            || self.staked_in_pools != 0
            || self.unstaked_in_pools != 0
            || self.total_in_pools != 0
            || self.unstaked_for_rebalance != 0
    }
}

pub fn set_unstake_for_rebalance_cap_bp(bp:u16, sim:&Simulation){
    let metapool_contract = &sim.metapool;
    let mut contract_params = view!(metapool_contract.get_contract_params()).unwrap_json_value();
    contract_params["unstake_for_rebalance_cap_bp"] = bp.into();
    let mut args = json!({ "params":{} });
    args["params"] = contract_params;
    let res = sim.operator.call(
        sim.metapool.account_id(),
        "set_contract_params",
        args.to_string().as_bytes(),
        10*TGAS,
        0
    );
    print_logs(&res);
    if !res.is_ok() {
        //println!("res.is_ok()={} {:?}", &res.is_ok(), &res);
        print_exec_result(&res);
        panic!("set_unstake_for_rebalance_cap_bp failed")
    }
}

pub fn set_staking_pools_weight(weights_bp: Vec<u16>, sim:&Simulation){
    
    // set staking pools weight
    let mut pools:Vec<StakingPoolArgItem> = Vec::with_capacity(4);
    //---- prepare vector with test names
    for n in 0..=3 {
        let acc_id = &format!("sp{}.testnet", n);
        // prepare weight
        pools.push ( StakingPoolArgItem {
            account_id: acc_id.clone(),
            weight_basis_points: weights_bp[n]
        });
    }
    set_staking_pools(pools,&sim);
}
    
pub fn set_staking_pools(pools: Vec<StakingPoolArgItem>, sim:&Simulation){
    let metapool_contract = &sim.metapool;
    let res = call!(sim.operator,
        metapool_contract.set_staking_pools(pools),
        1,
        125 * TGAS
    );
    print_exec_result(&res);
    check_exec_result(&res);
}

pub fn build_state(sim: &Simulation) -> State {
    let metapool = &sim.metapool;
    let contract_state = view!(metapool.get_contract_state()).unwrap_json_value();

    let total_for_staking = as_u128(&contract_state["total_for_staking"]);
    let total_actually_staked = as_u128(&contract_state["total_actually_staked"]);

    let epoch_unstake_orders = as_u128(&contract_state["epoch_unstake_orders"]);

    let retrieved_for_unstake_claims = as_u128(&contract_state["retrieved_for_unstake_claims"]);
    let total_unstaked_and_waiting = as_u128(&contract_state["total_unstaked_and_waiting"]);

    let view_result = view!(metapool.get_staking_pool_list());
    let sps: Vec<Value> =
        near_sdk::serde_json::from_slice(&view_result.unwrap()).unwrap_or_default();

    let mut sum_staked: u128 = 0;
    let mut sum_unstaked: u128 = 0;
    for sp in &sps {
        sum_staked += as_u128(&sp["staked"]);
        sum_unstaked += as_u128(&sp["unstaked"]);
    }

    let to_stake_delta = total_for_staking as i128 - total_actually_staked as i128;

    let unstaked_for_rebalance =  as_u128(&contract_state["unstaked_for_rebalance"]);

    return State {
        epoch: as_u128(&contract_state["env_epoch_height"]) as u64,

        contract_account_balance: as_u128(&contract_state["contract_account_balance"]),
        retrieved_for_unstake_claims,
        total_available: as_u128(&contract_state["total_available"]),

        epoch_stake_orders: as_u128(&contract_state["epoch_stake_orders"]),
        epoch_unstake_orders,

        total_for_staking,
        total_actually_staked,
        to_stake_delta,

        total_unstaked_and_waiting,

        unstake_claims: as_u128(&contract_state["total_unstake_claims"]),
        unstake_claims_available_long_term: retrieved_for_unstake_claims
            + total_unstaked_and_waiting
            - unstaked_for_rebalance
            + epoch_unstake_orders , // recent delayed-unstake that will be converted to retrieved_for_unstake_claims or total_unstaked_and_waiting

        staked_in_pools: sum_staked,
        unstaked_in_pools: sum_unstaked,
        total_in_pools: sum_staked + sum_unstaked,

        unstaked_for_rebalance,

        sps,
    };
}

pub fn state_diff(pre: &State, post: &State) -> StateDiff {
    return StateDiff {
        contract_account_balance: post.contract_account_balance as i128
            - pre.contract_account_balance as i128,
        retrieved_for_unstake_claims: post.retrieved_for_unstake_claims as i128 - pre.retrieved_for_unstake_claims as i128,
        total_available: post.total_available as i128 - pre.total_available as i128,

        epoch_stake_orders: post.epoch_stake_orders as i128 - pre.epoch_stake_orders as i128,
        epoch_unstake_orders: post.epoch_unstake_orders as i128 - pre.epoch_unstake_orders as i128,

        total_for_staking: post.total_for_staking as i128 - pre.total_for_staking as i128,
        total_actually_staked: post.total_actually_staked as i128
            - pre.total_actually_staked as i128,
        to_stake_delta: post.to_stake_delta as i128 - pre.to_stake_delta as i128,

        total_unstaked_and_waiting: post.total_unstaked_and_waiting as i128
            - pre.total_unstaked_and_waiting as i128,

        unstake_claims: post.unstake_claims as i128 - pre.unstake_claims as i128,
        unstake_claims_available_long_term: post.unstake_claims_available_long_term as i128
            - pre.unstake_claims_available_long_term as i128, //how much we have to fulfill unstake claims

        staked_in_pools: post.staked_in_pools as i128 - pre.staked_in_pools as i128,
        unstaked_in_pools: post.unstaked_in_pools as i128 - pre.unstaked_in_pools as i128,
        total_in_pools: post.total_in_pools as i128 - pre.total_in_pools as i128,

        unstaked_for_rebalance: post.unstaked_for_rebalance as i128 - pre.unstaked_for_rebalance as i128,
    };
}

//-----------
impl State {
    pub fn test_invariants(&self) -> Result<u8, String> {
        // if rebalance_unstake was executed, TAS can be lower than TFS, *and the delta different than epoch_orders_delta*
        // rebalance_unstake works by waiting, retrieving, and then restaking if there's an extra over retrieved_for_unstake_claims
        if self.total_for_staking > self.total_actually_staked {
            // no invariant here because rebalance_unstake can cause this
        }
        else if self.total_for_staking < self.total_actually_staked {
            // this can only be caused by delayed-unstaked (reduces total_for_staking and adds to epoch_unstake_orders)
            let delta_stake = self.total_actually_staked - self.total_for_staking;
            if self.epoch_unstake_orders < self.epoch_stake_orders {
                return Err(
                    "(1) delta-stake<0 but self.epoch_stake_orders > self.epoch_unstake_orders".into(),
                );
            }
            let delta_orders = self.epoch_unstake_orders - self.epoch_stake_orders;
            // since the option is for TAS to be lower because rebalance_unstake, delta-TAS 
            // delta-TAS must be smaller or equal than delta-orders
            if !(delta_stake <= delta_orders) {
                return Err(
                    "(2) invariant delta_stake <= delta_orders, violated".into(),
                );
            }
        }

        if self.contract_account_balance
            != self.total_available + self.retrieved_for_unstake_claims + self.epoch_stake_orders
        {
            return Err(
                "CAB != self.total_available + self.retrieved_for_unstake_claims + self.epoch_stake_orders"
                    .into(),
            );
        }

        if self.unstake_claims != self.unstake_claims_available_long_term
        {
            return Err(
                "self.unstake_claims != self.unstake_claims_available_long_term"
                    .into(),
            );
        }

        if !(self.retrieved_for_unstake_claims <= self.unstake_claims)
        {
            println!("self.retrieved_for_unstake_claims {} should be <= self.unstake_claims {}. Rest is extra for rebalance",
                self.retrieved_for_unstake_claims, 
                self.unstake_claims
            );
            return Err(
                "self.retrieved_for_unstake_claims should be <= self.unstake_claims. Rest is extra for rebalance"
                    .into(),
            );
        }

        return Ok(0);
    }

    pub fn assert_rest_state(&self) {
        //we've just cleared orders
        assert_eq!(self.epoch_stake_orders, 0);
        assert_eq!(self.epoch_unstake_orders, 0);

        assert_eq!(self.total_for_staking, self.total_actually_staked);
        assert_eq!(self.total_for_staking, self.staked_in_pools);

        assert_eq!(self.total_unstaked_and_waiting, self.unstaked_in_pools);

        assert_eq!(
            self.unstake_claims,
            self.retrieved_for_unstake_claims + self.unstaked_in_pools
        );
    }
}

'''
'''--- metapool/tests/sim/sim_setup.rs ---
#![allow(unused_imports)]
#![allow(dead_code)]

use near_sdk_sim::{
    account::AccessKey,
    call, deploy, init_simulator,
    near_crypto::{KeyType, SecretKey, Signer},
    to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
    STORAGE_AMOUNT,
};

use near_sdk::serde_json::Value;

use crate::sim_utils::*;
use metapool::*;

pub const SP_INITIAL_BALANCE: u128 = 36 * NEAR;

// Load contracts' bytes.
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
  WASM_BYTES_META_POOL => "../res/metapool.wasm",
  //static ref WASM_BYTES_META_POOL: &'static [u8] = include_bytes!("../../res/metapool.wasm").as_ref();
  WASM_BYTES_SP => "../res/staking_pool.wasm",
  // static ref WASM_BYTES_SP: &'static [u8] = include_bytes!("../../res/staking_pool.wasm").as_ref();
  WASM_BYTES_GET_EPOCH => "../res/get_epoch_contract.wasm",
  // static ref WASM_BYTES_GET_EPOCH: &'static [u8] = include_bytes!("../../res/get_epoch_contract.wasm").as_ref();
}

/// Deploy the contract(s) and create some metapool accounts. Returns:
/// - The metapool Contract
/// - Root Account
/// - Testnet Account (utility suffix for building other addresses)
/// - A deployer account address
//Note: MetaPoolContract is a struct "magically" created by #[near_bindgen] (near_skd_rs~2.0.4)
/*
pub fn init_simulator_and_contract(
  initial_balance: u128,
  deploy_to: &str,
) -> (
  ContractAccount<MetaPoolContract>,
  UserAccount, // root
  UserAccount, // testnet suffix
  UserAccount, // deployer account
  UserAccount,
  UserAccount
) {
  // Root account has address: "root"
  let master_account = init_simulator(None);

  // Other accounts may be created from the root account
  // Note: address naming is fully expressive: we may create any suffix we desire, ie testnet, near, etc.
  // but only those two (.testnet, .near) will be used in practice.
  let testnet = master_account.create_user("testnet".to_string(), ntoy(1_000_000_000));

  // We need an account to deploy the contracts from. We may create sub accounts of "testnet" as follows:
  let owner = testnet.create_user(deploy_to.to_string(), ntoy(1_000_000));

  let treasury = testnet.create_user("treasury".to_string(), ntoy(1_000_000));
  let operator = testnet.create_user("operator".to_string(), ntoy(1_000_000));

  //-- NO MACROS
  // let metapool_contract = master_account.deploy(&WASM_BYTES_META_POOL, account_id: "metapool", STORAGE_AMOUNT);

  // metapool_contract.call(
  //   "metapool",
  //   "new",
  //   &json!({
  //       "owner_account_id": owner.account_id(),
  //       "treasury_account_id": treasury.account_id(),
  //       "operator_account_id": operator.account_id(),
  //   })
  //   .to_string()
  //   .into_bytes(),
  //   DEFAULT_GAS / 2,
  //   0, // attached deposit
  // )
  // .assert_success();
  //-- END NO MACROS

  let metapool_contract = deploy!(
      contract: MetaPoolContract,
      contract_id: "metapool",
      bytes: &WASM_BYTES_META_POOL,
      // User deploying the contract
      signer_account: owner,
      // MetaPool.new(
        //   owner_account_id: AccountId,
        //   treasury_account_id: AccountId,
        //   operator_account_id: AccountId,
      deposit:500*NEAR,
      gas:25*TGAS,
      init_method:new(owner.account_id(), treasury.account_id(), operator.account_id())
      );

  return (metapool_contract, master_account, testnet, owner, treasury, operator)
}
*/
fn sp_contract_name(n:usize) -> String {
    format!("sp{}.testnet", n)
}
//-----------------------
fn deploy_simulated_staking_pool(
    master_account: &UserAccount,
    deploy_to_acc_id: &str,
    owner_account_id: &str,
) -> UserAccount {
    let sp = master_account.deploy(&WASM_BYTES_SP, deploy_to_acc_id.into(), SP_INITIAL_BALANCE);
    let user_txn = master_account
  .create_transaction(sp.account_id())
  .function_call(
    "new".into(), 
    format!(r#"{{"owner_id":"{}", "stake_public_key":"Di8H4S8HSwSdwGABTGfKcxf1HaVzWSUKVH1mYQgwHCWb","reward_fee_fraction":{{"numerator":5,"denominator":100}}}}"#,
      owner_account_id
      ).into(),//arguments: Vec<u8>,
    50*TGAS, 0);
    let res = user_txn.submit();
    check_exec_result(&res);
    return sp;
}

const METAPOOL_CONTRACT_ID: &str = "metapool";
//-----------------------------
//-----------------------------
//-----------------------------
pub struct Simulation {
    pub metapool: ContractAccount<MetaPoolContract>,
    pub master_account: UserAccount, // root
    pub testnet: UserAccount,        // testnet suffix
    pub owner: UserAccount,          // deployer account
    pub treasury: UserAccount,
    pub operator: UserAccount,
    pub sp: Vec<UserAccount>,       //Staking pools
    pub get_epoch_acc: UserAccount, //contract to get env::epoch_height()
    pub weight_basis_points_vec: Vec<u16>,
}
impl Simulation {
    pub fn new() -> Self {
        // Root account has address: "root"
        let master_account = init_simulator(None);
        // Other accounts may be created from the root account
        // Note: address naming is fully expressive: we may create any suffix we desire, ie testnet, near, etc.
        // but only those two (.testnet, .near) will be used in practice.
        let testnet = master_account.create_user("testnet".into(), ntoy(1_000_000_000));
        // We need an account to deploy the contracts from. We may create sub accounts of "testnet" as follows:
        let owner = testnet.create_user("contract-owner".into(), ntoy(1_000_000));
        let treasury = testnet.create_user("treasury".into(), ntoy(1_000_000));
        let operator = testnet.create_user("operator".into(), ntoy(1_000_000));

        // NO MACROS -------------
        //create acc, deploy & init the main contract
        // let metapool_contract = master_account.deploy(&WASM_BYTES_META_POOL, account_id: "metapool", STORAGE_AMOUNT);

        // metapool_contract.call(
        //   "metapool",
        //   "new",
        //   &json!({
        //       "owner_account_id": owner.account_id(),
        //       "treasury_account_id": treasury.account_id(),
        //       "operator_account_id": operator.account_id(),
        //   })
        //   .to_string()
        //   .into_bytes(),
        //   DEFAULT_GAS / 2,
        //   0, // attached deposit
        // )
        // .assert_success();
        // END NO MACROS -------------

        //create acc, deploy & init the main contract
        let metapool = deploy!(
        contract: MetaPoolContract,
        contract_id: &METAPOOL_CONTRACT_ID,
        bytes: &WASM_BYTES_META_POOL,
        // User deploying the contract
        signer_account: &owner,
        // MetaPool.new(
          //   owner_account_id: AccountId,
          //   treasury_account_id: AccountId,
          //   operator_account_id: AccountId,
        deposit:500*NEAR,
        gas:25*TGAS,
        init_method:new(owner.account_id(), treasury.account_id(), operator.account_id(), "meta_token_contract_account".into())
        );

        // deploy all the staking pools and register with meta_pool
        let mut sp = Vec::with_capacity(4);
        let weights_vec: Vec<u8> = vec![15, 40, 25, 20];
        let mut weight_basis_points_vec: Vec<u16> = Vec::with_capacity(4);
        let mut pools:Vec<StakingPoolArgItem> = Vec::with_capacity(4);
        //----
        for n in 0..=3 {
            let acc_id = sp_contract_name(n);
            let sp_contract =
                deploy_simulated_staking_pool(&testnet, &acc_id[..], &owner.account_id());
            //call(&owner,&sp_contract,"pause_staking","{}",0,10*TGAS);
            sp.push(sp_contract);
            //-- register the staking pool in metapool
            let res = call!(
                owner,
                metapool.add_staking_pool(acc_id.clone()),
                gas = 25 * TGAS
            );
            check_exec_result(&res);
            // prepare weight
            let weight_bp = weights_vec[n] as u16 * 100;
            pools.push ( StakingPoolArgItem {
                account_id: acc_id.clone(),
                weight_basis_points: weight_bp
            });
            weight_basis_points_vec.push(weight_bp);
        }
        let res=call!(
            owner,
            metapool.set_staking_pools(pools),
            1,
            125 * TGAS
        );
        print_exec_result(&res);
        check_exec_result(&res);

        // test contract checks
        // should fail because sum(bp)!=10000
        {
            let mut invalid_pools:Vec<StakingPoolArgItem> = Vec::with_capacity(4);
            let weights_vec: Vec<u8> = vec![14, 40, 25, 20];
            for n in 0..=3 {
                // prepare weight
                let weight_bp = weights_vec[n] as u16 * 100;
                invalid_pools.push ( StakingPoolArgItem {
                    account_id: sp_contract_name(n),
                    weight_basis_points: weight_bp
                });
            }
            let res=call!(
                owner,
                metapool.set_staking_pools(invalid_pools),
                1,
                125 * TGAS
            );
            // should fail
            assert!(!res.is_ok(),"expected sum(bp)!=10000 check to be triggered");
        }
        // test add duplicated sp
        // should fail because already exists
        {
            let res = call!(
                owner,
                metapool.add_staking_pool(sp_contract_name(1)),
                gas = 25 * TGAS
            );
            // should fail
            assert!(!res.is_ok(),"expected sum(bp)!=10000 check to be triggered");
        }

        //deploy a contract to get the current epoch
        let get_epoch_acc = master_account.deploy(
            &WASM_BYTES_GET_EPOCH,
            String::from("get_epoch_acc"),
            SP_INITIAL_BALANCE,
        );
        master_account
            .create_transaction(get_epoch_acc.account_id())
            .function_call("new".into(), "{}".into(), 50 * TGAS, 0)
            .submit();

        return Self {
            metapool,

            master_account,

            testnet,
            owner,
            treasury,
            operator,

            sp,

            get_epoch_acc,
            weight_basis_points_vec,
        };
    }

    pub fn sp_staked(&self, n: usize) -> u128 {
        view_u128(
            &self.sp[n],
            "get_account_staked_balance",
            &format!(r#"{{"account_id":"{}"}}"#, METAPOOL_CONTRACT_ID),
        )
    }

    // pub fn sp_balance(&self, n:usize) -> u128 {
    //   if let Some(data) = self.sp[n].account() {
    //     data.amount+data.locked
    //   }
    //   else { 0 }
    //   //self.sp[n].amount()+self.sp[n].locked()
    // }

    pub fn show_sp_staked_balance(&self, n: usize) {
        //let total = self.sp_balance(n);
        //let data = self.sp[n].account().unwrap();
        //println!("{}",&format!(r#"{{"account_id":"{}"}}"#,&METAPOOL_CONTRACT_ID));
        println!("sp{} native acc {:?}", n, &self.sp[n].account().unwrap());
        let staked = view_u128(
            &self.sp[n],
            "get_account_staked_balance",
            &format!(r#"{{"account_id":"{}"}}"#, METAPOOL_CONTRACT_ID),
        );
        //println!("sp{} get_account_staked_balance:{}, data.amount:{}+data.locked:{}", n, yton(staked));//, data.amount, data.locked );
        println!("sp{} get_account_staked_balance:{}", n, yton(staked)); //, data.amount, data.locked );
    }

    pub fn show_sps_staked_balances(&self) {
        println!("--SPs balance");
        for n in 0..=3 {
            self.show_sp_staked_balance(n)
        }
        println!("--------------");
    }

    //----------------
    pub fn show_account_info(&self, acc: &str) -> Value {
        let metapool = &self.metapool;
        let result = view!(metapool.get_account_info(acc.into()));
        print_vec_u8(acc, &result.unwrap());
        //println!("Result: {:#?}", result.unwrap_json_value());
        return near_sdk::serde_json::from_str(std::str::from_utf8(&result.unwrap()).unwrap())
            .unwrap();
    }
}

'''
'''--- metapool/tests/sim/sim_steps.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::{Base58PublicKey, U128},
    serde::{Deserialize, Serialize},
    serde_json::json,
    serde_json::Value,
    *,
};
use near_sdk_sim::{
    account::AccessKey,
    call, deploy, init_simulator,
    near_crypto::{KeyType, SecretKey, Signer},
    to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
    STORAGE_AMOUNT,
};

use rand::{Rng, SeedableRng};
use rand_pcg::Pcg32;

//
// desk check aka algorithm test plan
//
// Mechanism:
// ---------
// for each step {
//   retrieve state
//   execute method
//   retrieve state
//   compute diffs
//   assert on diffs (according to method)
//   assert on invariants (general)
// }
//
// https://docs.google.com/spreadsheets/d/1VYynsw2yOGIE_0bFdy4CabnI1fnTXDEEffDVbYZSq6Q/edit?usp=sharing
//

use crate::sim_contract_state::*;
use crate::sim_setup::*;
use crate::sim_utils::*;
use metapool::*;

//-----------------
pub fn bot_end_of_epoch_clearing(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {
    let result = step_call(
        sim,
        &sim.operator,
        "end_of_epoch_clearing",
        json!({}),
        50 * TGAS,
        NO_DEPOSIT,
        start,
    );

    //after end_of_epoch_clearing check invariants
    if let Ok(res) = &result {
        if res.state.unstake_claims_available_long_term < res.state.unstake_claims {
            panic!(
                "unstake_claims_available_long_term {} < unstake_claims {}",
                res.state.unstake_claims_available_long_term, res.state.unstake_claims
            )
        }
        if res.state.epoch_stake_orders != 0 && res.state.epoch_unstake_orders != 0 {
            //at least on (or both) must be 0 after end_of_epoch_clearing
            panic!(
                "after end_of_epoch_clearing epoch_stake_orders {} epoch_unstake_orders {}",
                res.state.epoch_stake_orders, res.state.epoch_unstake_orders
            )
        }
    }

    return result;
}

//-----------------
pub fn bot_distributes(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {
    let mut state = start.clone();

    let metapool = &sim.metapool;

    // END_OF_EPOCH Task 1: check if there is the need to stake
    let mut more_work: bool = state.total_for_staking > state.total_actually_staked;
    println!("--bot_distributes TFS:{} TAS:{}, {}, {}", state.total_for_staking/NEAR , state.total_actually_staked/NEAR, more_work, state.epoch_unstake_orders);
    while more_work {
        println!("--CALL metapool.distribute_staking");
        match step_call(
            sim,
            &sim.operator,
            "distribute_staking",
            json!({}),
            150 * TGAS,
            NO_DEPOSIT,
            &state,
        ) {
            Err(x) => return Err(x),
            Ok(data) => {
                state = data.state;
                more_work = data.res.unwrap().unwrap_json();
                println!("--result {}", more_work);
                if let Err(err) = state.test_invariants() {
                    panic!("invariant check {}", err);
                    //return Err(err)
                }
            }
        }
    }

    // END_OF_EPOCH Task 1: check if there is the need to unstake
    more_work = state.epoch_unstake_orders > 0;
    while more_work {
        println!("--CALL metapool.distribute_unstaking");
        match step_call(
            sim,
            &sim.operator,
            "distribute_unstaking",
            json!({}),
            150 * TGAS,
            NO_DEPOSIT,
            &state,
        ) {
            Err(x) => return Err(x),
            Ok(data) => {
                state = data.state;
                more_work = data.res.unwrap().unwrap_json();
                println!("--result {}", more_work);
                if let Err(err) = state.test_invariants() {
                    panic!("invariant check {}", err);
                    //return Err(err)
                }
            }
        }
    }

    let diff = state_diff(&start, &state);
    return Ok(StateAndDiff {
        state,
        diff,
        res: None,
    });
}

pub fn apply_pct(basis_points: u16, amount: u128) -> u128 {
    return (U256::from(basis_points) * U256::from(amount) / U256::from(10_000)).as_u128();
}

// fn wait_period_ended(sp:&Value, state:&State) -> bool {
//     if as_u128(&sp["unstaked_requested_epoch_height"]) > state.epoch as u128 {
//         //bad data at unstk_req_epoch_height or there was a hard-fork
//         return true;
//     }
//     //true if we reached epoch_requested+NUM_EPOCHS_TO_UNLOCK
//     return state.epoch as u128 >= as_u128(&sp["unstaked_requested_epoch_height"]) + NUM_EPOCHS_TO_UNLOCK as u128;
// }

// /// finds a staking pool requiring some stake to get balanced
// /// WARN: returns (0,0) if no pool requires staking/all are busy
// fn get_staking_pool_requiring_unstake(
//     state: &State,
// ) -> (usize, u128, u16) {
//     let mut selected_to_unstake_amount: u128 = 0;
//     let mut selected_sp_inx: usize = 0;
//     let mut count_unblocked: u16 = 0;

//     for (sp_inx, sp) in state.sps.iter().enumerate() {
//         // if the pool is not busy, has stake
//         let staked = as_u128(&sp["staked"]);
//         let unstaked = as_u128(&sp["unstaked"]);
//         let w = as_u32(&sp["weight_basis_points"]);
//         let should_have = state.total_for_staking * w as u128 / 10_000;
//         println!(r#""{{"sp":{},"event":"unstaked:{}, should_have:{}","amount":"{}"}}""#, 
//             sp_inx,
//             unstaked/NEAR,
//             should_have/NEAR,
//             staked
//         );
//         // count how how many sps are unblocked, i.e. can receive an unstake request
//         if unstaked == 0 { count_unblocked += 1};
//         if staked > 0 {
//             //if has not unstaked balance waiting for withdrawal, or wait started in this same epoch (no harm in unstaking more)
//             if unstaked == 0 || as_u128(&sp["unstaked_requested_epoch_height"]) == state.epoch as u128 {
//                 // if this pool has an unbalance requiring un-staking
//                 let should_have = apply_pct(w as u16, state.total_for_staking);
//                 // does this pool requires un-staking? (has too much staked?)
//                 if staked > should_have {
//                     // how much?
//                     let unstake_amount = staked - should_have;
//                     // is this the most unbalanced pool so far?
//                     if unstake_amount > selected_to_unstake_amount {
//                         selected_to_unstake_amount = unstake_amount;
//                         selected_sp_inx = sp_inx;
//                     }
//                 }
//             }
//         }
//     }

//     return (selected_sp_inx, selected_to_unstake_amount, count_unblocked);
// }

//-----------------
pub fn bot_change_pools_weight(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {

    let state = start.clone();

    let metapool = &sim.metapool;

    let mut rng = Pcg32::seed_from_u64(start.epoch as u64);

    // change pools weight
    let mut weights_bp:Vec<u16> = vec!(0,0,0,0);
    for times in 0..=1000 {
        let mut total:u16 = 0;
        for n in 0..=2 {
            let rand_w: u16 = rng.gen_range(0..4000) as u16;
            weights_bp[n] = rand_w;
            total += rand_w;
        }
        if total<9900 && total>5000 {
            weights_bp[3] = 10000 - total;
            set_staking_pools_weight(weights_bp, &sim);
            let diff = state_diff(&start, &state);
            return Ok(StateAndDiff {
                state,
                diff,
                res: None,
            });
        }
    }
    panic!("no good random weights at bot_change_pools_weight")

}

//-----------------
pub fn bot_rebalance_unstake(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {

    // before rebalance_unstake, we do a bot_retrieve
    // rebalance_unstake is done always afer retrieving, we must retrieve to free sp.unstaked
    let mut state = bot_retrieve(&sim, &start)?.state.clone();

    //let mut state = start.clone();

    let metapool = &sim.metapool;

    // before END_OF_EPOCH: rebalance up to 1%
    let mut more_work = state.unstaked_for_rebalance < apply_pct(100, state.total_for_staking);
    while more_work {

        //println!("about to call do_rebalance_unstake");
        let result = step_call(
            sim,
            &sim.operator,
            "do_rebalance_unstake",
            json!({}),
            200 * TGAS,
            NO_DEPOSIT,
            &state,
        )?;

        state = result.state;
        more_work = result.res.unwrap().unwrap_json();
        println!("--result {}", more_work);
        if let Err(err) = state.test_invariants() {
            panic!("invariant check {}", err);
            //return Err(err)
        }

    }

    let diff = state_diff(&start, &state);
    return Ok(StateAndDiff {
        state,
        diff,
        res: None,
    });
}

//-----------------
pub fn bot_ping_rewards(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {
    // COMPUTE REWARDS
    //if the epoch is recently started -- ping the pools so they compute rewards and do the same in the meta-pool

    let mut state = start.clone();

    for inx in 0..state.sps.len() {
        let pool = &state.sps[inx];
        let staked = as_u128(&pool["staked"]);
        let unstaked = as_u128(&pool["unstaked"]);
        if (staked > 0 || unstaked > 0) && &pool["last_asked_rewards_epoch_height"] != state.epoch {
            //ping on the pool so it calculates rewards
            println!("about to call PING & DISTRIBUTE on {}", pool.to_string());
            let pool_id = pool["account_id"].as_str().unwrap().to_string();
            let ping = sim
                .operator
                .call(pool_id, "ping", &[], 200 * TGAS, NO_DEPOSIT);
            check_exec_result(&ping);
            //await near.call(pool.account_id, "ping", {}, OPERATOR_ACCOUNT, credentials.private_key, 200);
            //calculates rewards now in the meta for that pool
            //pub fn distribute_rewards(&mut self, sp_inx: u16) -> void
            println!("meta.DISTR");
            let result = step_call(
                sim,
                &sim.operator,
                "distribute_rewards",
                json!({ "sp_inx": inx }),
                200 * TGAS,
                NO_DEPOSIT,
                &state,
            )?;
            state = result.state;
        }
    }

    let diff = state_diff(&start, &state);
    return Ok(StateAndDiff {
        state,
        diff,
        res: None,
    });
}

//-----------------
pub fn bot_retrieve(sim: &Simulation, start: &State) -> Result<StateAndDiff, String> {
    let mut state = start.clone();
    // RETRIEVE UNSTAKED FUNDS
    for inx in 0..state.sps.len() {
        let pool = &state.sps[inx];
        let staked = as_u128(&pool["staked"]);
        let unstaked = as_u128(&pool["unstaked"]);
        if unstaked > 0 && &pool["unstaked_requested_epoch_height"] != "0" {
            println!("about to try RETRIEVE UNSTAKED FUNDS on pool {:?}", pool);
            let now = state.epoch;
            let mut when =
                as_u128(&pool["unstaked_requested_epoch_height"]) as u64 + NUM_EPOCHS_TO_UNLOCK;
            if when > now + 30 {
                when = now
            }; //bad data or hard-fork
            if when <= now {
                //try RETRIEVE UNSTAKED FUNDS
                match step_call(
                    sim,
                    &sim.operator,
                    "retrieve_funds_from_a_pool",
                    json!({ "inx": inx }),
                    200 * TGAS,
                    NO_DEPOSIT,
                    &state,
                ) {
                    Err(x) => return Err(x),
                    Ok(data) => state = data.state,
                }
            }
        }
    }

    let diff = state_diff(&start, &state);
    return Ok(StateAndDiff {
        state,
        diff,
        res: None,
    });
}

pub struct StateAndDiff {
    pub state: State,
    pub diff: StateDiff,
    pub res: Option<ExecutionResult>,
}

//-----------
pub fn step_call(
    sim: &Simulation,
    acc: &UserAccount,
    method: &str,
    args: Value,
    gas: u64,
    attached_near: u128,
    pre: &State,
) -> Result<StateAndDiff, String> {
    println!("step_call {}", method);
    let res = acc.call(
        sim.metapool.account_id(),
        method,
        args.to_string().as_bytes(),
        gas,
        attached_near,
    ); // call!(pepe, metapool.nslp_add_liquidity(),10_000*NEAR,200*TGAS);
       //print_exec_result(&res);
    print_logs(&res);
    if res.is_ok() {
        let post = build_state(&sim);
        let diff = state_diff(&pre, &post);
        println!(
            "--DIFF {}",
            serde_json::to_string(&diff).unwrap_or_default()
        );
        println!(
            "--POST {}",
            serde_json::to_string(&post).unwrap_or_default()
        );

        if let Err(err) = post.test_invariants() {
            panic!("invariant check {}", err);
            //return Err(err)
        }
        return Ok(StateAndDiff {
            state: post,
            diff,
            res: Some(res),
        });
    } else {
        let msg = format!("Txn Failed, {}.{}", sim.metapool.account_id(), method);
        println!("step_call failed {}", msg);
        //println!("res.is_ok()={} {:?}", &res.is_ok(), &res);
        print_exec_result(&res);
        return Err(msg);
    }
}

'''
'''--- metapool/tests/sim/sim_utils.rs ---
#![allow(unused_imports)]
#![allow(dead_code)]
use near_sdk_sim::{
    account::AccessKey,
    call, deploy, init_simulator,
    near_crypto::{KeyType, SecretKey, Signer},
    to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
    STORAGE_AMOUNT,
};

use near_sdk::serde_json::Value;

use metapool::*;

/// Helper to log ExecutionResult outcome of a call/view
pub fn print_exec_result_single(res: &ExecutionResult) {
    let is_ok = res.is_ok();

    for line in &res.outcome().logs {
        if !is_ok && line.starts_with("{\"") {
            //add a prefix to event lines if the transaction failed
            println!("(failed) {:?}", line);
        } else {
            println!("{:?}", line);
        }
    }
    if !is_ok {
        println!("{:?}", res);
    }
}
/// Helper to log ExecutionResult outcome of a call/view
pub fn print_exec_result_promise(inx: u64, res: &ExecutionResult) {
    if res.outcome().logs.len() == 0 || res.is_ok() {
        return;
    }
    println!("--promise #{}", inx);
    print_exec_result_single(&res);
}

pub fn print_exec_result(res: &ExecutionResult) {
    print_exec_result_single(&res);
    let mut inx = 0;
    for pr in &res.promise_results() {
        if let Some(some_pr) = pr {
            print_exec_result_promise(inx, &some_pr);
            inx += 1;
        }
    }
}

pub fn print_logs(res: &ExecutionResult) {
    for item in &res.promise_results() {
        if let Some(some_res) = item {
            for line in &some_res.outcome().logs {
                println!("{:?}", line);
            }
        }
    }
}

pub fn check_exec_result_single(res: &ExecutionResult) {
    //println!("Result: {:#?}", res);
    for line in &res.outcome().logs {
        println!("{:?}", line);
    }
    //println!("executor_id {} gas burnt {} tokens_burnt {}", res.executor_id(), res.gas_burnt(), res.tokens_burnt());
    if !res.is_ok() {
        println!("{:?}", res);
    }
    assert!(res.is_ok());
}

pub fn check_exec_result(res: &ExecutionResult) -> u128 {
    // println!("-----------------");
    // check_exec_result_single(res); -- main receipt is in promises too
    // let mut total_tokens_burnt = res.tokens_burnt();
    let mut total_tokens_burnt = 0;
    println!("------------ promises");
    for pr in res.promise_results() {
        if let Some(some_pr) = pr {
            check_exec_result_single(&some_pr);
            total_tokens_burnt += some_pr.tokens_burnt();
        }
    }
    println!("------------end promises");
    assert!(res.is_ok());
    total_tokens_burnt
}

/// Helper to log ExecutionResult outcome of a call/view
// fn check_exec_result_profile(res: &ExecutionResult) {
//   println!("Promise results: {:#?}", res.promise_results());
//   //println!("Receipt results: {:#?}", res.get_receipt_results());
//   //println!("Profiling: {:#?}", res.profile_data());
//   //println!("Result: {:#?}", res);
//   assert!(res.is_ok());
// }

pub fn print_vec_u8(title: &str, v: &Vec<u8>) {
    println!(
        "{}:{}",
        title,
        match std::str::from_utf8(v) {
            Ok(v) => v,
            Err(_) => "[[can't decode result, invalid UFT8 sequence]]",
        }
    )
}

pub fn ntoy(near: u64) -> u128 {
    to_yocto(&near.to_string())
}
#[allow(non_snake_case)]
pub fn ntoU128(near: u64) -> String {
    ntoy(near).to_string()
}

pub fn yton(yoctos: u128) -> String {
    let mut str = format!("{:0>25}", yoctos);
    let dec = str.split_off(str.len() - 24);
    return [&str, ".", &dec].concat();
}

//----------------------
pub fn view(contract_account: &UserAccount, method: &str, args_json: &str) -> Value {
    // let pct = PendingContractTx {
    //   receiver_id: contract_account.account_id(),
    //   method: method.into(),
    //   args: args_json.into(),
    //   is_view:true,
    // };
    let vr = &contract_account.view(contract_account.account_id(), method, args_json.as_bytes());
    //println!("view Result: {:#?}", vr.unwrap_json_value());
    return vr.unwrap_json_value();
}

pub fn as_u128(v: &Value) -> u128 {
    return match v.as_str() {
        Some(x) => {
            //println!("{}",x);
            x.parse::<u128>().unwrap()
        }
        _ => panic!("invalid u128 value {:#?}", v),
    };
}
pub fn view_u128(contract_account: &UserAccount, method: &str, args_json: &str) -> u128 {
    let result = view(contract_account, method, args_json);
    return as_u128(&result);
}

pub fn as_u32(v: &Value) -> u32 {
    return match v.as_i64() {
        Some(x) => {
            //println!("{}",x);
            x as u32
        }
        _ => panic!("invalid i64 value {:#?}", v),
    };
}

//----------------------
pub fn call(
    who: &UserAccount,
    contract_account: &UserAccount,
    method: &str,
    args_json: &str,
    attached_deposit: u128,
    gas: u64,
) -> ExecutionResult {
    // let pct = PendingContractTx {
    //   receiver_id: contract_account.account_id(),
    //   method: method.into(),
    //   args: args_json.into(),
    //   is_view:false,
    // };
    let exec_res = who.call(
        contract_account.account_id(),
        method,
        args_json.as_bytes(),
        gas,
        attached_deposit,
    );
    //println!("Result: {:#?}", exec_res);
    return exec_res;
}

#[allow(dead_code)]
pub fn show_balance(ua: &UserAccount) {
    println!("@{} balance: {}", ua.account_id(), balance(ua));
}

pub fn assert_less_than_one_milli_near_diff_balance(
    action: &str,
    bal: u128,
    expected: u128,
) -> bool {
    if bal == expected {
        return true;
    };
    if bal > expected {
        panic!(
            "{} failed MORE THAN EXPECTED diff:{} bal:{} expected:{}",
            action,
            yton(bal - expected),
            yton(bal),
            yton(expected)
        );
    }
    let differ = expected - bal;
    if differ < ONE_MILLI_NEAR {
        return true;
    };
    panic!(
        "{} failed LESS THAN EXPECTED by more than 0.001 diff:{} bal:{} expected:{}",
        action,
        yton(differ),
        yton(bal),
        yton(expected)
    );
}

pub fn balance(acc: &UserAccount) -> u128 {
    if let Some(data) = acc.account() {
        data.amount + data.locked
    } else {
        0
    }
}

'''
'''--- metapool/tests/sim/simulation_desk_check.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::{
  borsh::{self, BorshDeserialize, BorshSerialize},
  json_types::{Base58PublicKey, U128},
  serde::{Deserialize, Serialize},
  serde_json::json,
  serde_json::Value,
  *,
};
use near_sdk_sim::{
  account::AccessKey,
  call, deploy, init_simulator,
  near_crypto::{KeyType, SecretKey, Signer},
  to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
  STORAGE_AMOUNT,
};

//
// desk check aka algorithm test plan
//
// Mechanism:
// ---------
// for each step {
//   retrieve state
//   execute method
//   retrieve state
//   compute diffs
//   assert on diffs (according to method)
//   assert on invariants (general)
// }
//
// https://docs.google.com/spreadsheets/d/1VYynsw2yOGIE_0bFdy4CabnI1fnTXDEEffDVbYZSq6Q/edit?usp=sharing
// 

use crate::sim_setup::*;
use crate::sim_utils::*;
use crate::sim_steps::*;
use crate::sim_contract_state::*;
use metapool::*;

#[test]
fn simulation_desk_check() {

  let sim = Simulation::new();

  let metapool = &sim.metapool;

  let contract_info = view!(metapool.get_contract_info());
  print_vec_u8("contract_info", &contract_info.unwrap());

  let contract_state = view!(metapool.get_contract_state());
  print_vec_u8("contract_state", &contract_state.unwrap());

  //starting sp balances
  sim.show_sps_staked_balances();

  //---- Users
  let lucio = sim.testnet.create_user("lucio".to_string(), ntoy(500_000));
  let pepe = sim.testnet.create_user("pepe".to_string(), ntoy(500_000));
  let jose = sim.testnet.create_user("jose".to_string(), ntoy(500_000));
  let maria = sim.testnet.create_user("maria".to_string(), ntoy(500_000));

  let pre = build_state(&sim);
  // initial stake
  println!("--PRE {}",serde_json::to_string(&pre).unwrap_or_default());

  // let mut state: State = pre;
  // let mut diff: StateDiff;

  // step: lucio stakes & the bot distributes in the pools pool
  let amount_initial_stake = 50_000*NEAR;
  let mut result = step_call(&sim, &lucio, "deposit_and_stake", json!({}), 50*TGAS,amount_initial_stake , &pre).unwrap();
  // state = step_call(&sim, &lucio, "deposit_and_stake", json!({}), 50*TGAS, 10100*NEAR,&state);
  // state = step_call(&sim, &lucio, "deposit_and_stake", json!({}), 50*TGAS, 10200*NEAR,&state);
  // state = step_call(&sim, &lucio, "deposit_and_stake", json!({}), 50*TGAS, 10300*NEAR,&state);

  assert_eq!(result.diff.total_for_staking, amount_initial_stake as i128);
  assert_eq!(result.diff.epoch_stake_orders, amount_initial_stake as i128);

  // step: operator d.stake / d.unstake
  result = bot_distributes(&sim, &result.state).unwrap();
  assert_eq!(result.diff.staked_in_pools, amount_initial_stake as i128);
  
  result = bot_ping_rewards(&sim, &result.state).unwrap();

  // step: pepe add liq
  let amount_add_liq = 10_000*NEAR;
  result = step_call(&sim, &pepe, "nslp_add_liquidity", json!({}), 200*TGAS, amount_add_liq, &result.state).unwrap();

  assert_eq!(result.diff.total_available, amount_add_liq as i128 );
  assert_eq!(result.diff.contract_account_balance, amount_add_liq as i128);

  // step: lucio d.unstakes
  result = step_call(&sim, &lucio, "unstake", json!({"amount":ntoU128(300)}), 100*TGAS, NO_DEPOSIT, &result.state).unwrap();

  // step: operator d.stake / d.unstake
  result = bot_distributes(&sim, &result.state).unwrap();
  result = bot_ping_rewards(&sim, &result.state).unwrap();
  result = bot_end_of_epoch_clearing(&sim, &result.state).unwrap();
  result.state.assert_rest_state();

  result = step_call(&sim, &jose, "deposit_and_stake", json!({}), 50*TGAS, 420*NEAR, &result.state).unwrap();

  result = bot_distributes(&sim, &result.state).unwrap();
  result = bot_ping_rewards(&sim, &result.state).unwrap();
  result = bot_retrieve(&sim, &result.state).unwrap();

  result = step_call(&sim, &lucio, "withdraw", json!({"amount":ntoU128(300)}), 50*TGAS, NO_DEPOSIT, &result.state).unwrap();

  result = step_call(&sim, &lucio, "unstake", json!({"amount":ntoU128(300)}), 50*TGAS, NO_DEPOSIT, &result.state).unwrap();

  result = step_call(&sim, &maria, "deposit_and_stake", json!({}), 50*TGAS, 500*NEAR, &result.state).unwrap();

  result = step_call(&sim, &pepe, "deposit_and_stake", json!({}), 50*TGAS, 150*NEAR, &result.state).unwrap();

  result = step_call(&sim, &maria, "unstake", json!({"amount":ntoU128(30)}), 50*TGAS, NO_DEPOSIT, &result.state).unwrap();

  result = bot_distributes(&sim, &result.state).unwrap();
  result = bot_ping_rewards(&sim, &result.state).unwrap();
  result = bot_retrieve(&sim, &result.state).unwrap();
  result = bot_end_of_epoch_clearing(&sim, &result.state).unwrap();

  assert_eq!(result.state.epoch_stake_orders,0);
  assert_eq!(result.state.epoch_unstake_orders,0);
}

'''
'''--- metapool/tests/sim/simulation_fuzzy.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
///
/// fuzzy tests
///
/// Mechanism:
/// ---------
/// create n users
/// chose a pseudo-random seed
/// according to rand, make one user perform an action
/// it can be the bot performing distribute, retrieve, clearing
/// repeat until 50 actions or errors
/// check & fix bugs.
/// try other seeds, record useful seeds (complex patterns, low % of errors)
///
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::{Base58PublicKey, U128},
    serde::{Deserialize, Serialize},
    serde_json::json,
    serde_json::Value,
    *,
};
use near_sdk_sim::{
    account::AccessKey,
    call, deploy, init_simulator,
    near_crypto::{KeyType, SecretKey, Signer},
    to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
    STORAGE_AMOUNT,
};

use rand::{Rng, SeedableRng};
use rand_pcg::Pcg32;

use crate::sim_contract_state::*;
use crate::sim_setup::*;
use crate::sim_steps::*;
use crate::sim_utils::*;
use metapool::*;

const COUNT_USERS: usize = 10;

#[derive(Debug)]
pub enum Action {
    Stake,
    LiquidUnstake,
    DelayedUnstake,
    DUWithdraw,
    AddLiquidity,
    RemoveLiquidity,
    BotDistributes,
    BotEndOfEpochClearing,
    BotRetrieveFunds,
    BotPingRewards,
    StartRebalanceUnstake,
    ChangePoolsWeight,
    LastAction,
}

impl Action {
    fn from_u8(n: u8) -> Option<Action> {
        if n < Action::LastAction as u8 {
            Some(unsafe { std::mem::transmute(n) })
        } else {
            None
        }
    }
}

//-----------
pub fn step_random_action(
    sim: &Simulation,
    acc: &UserAccount,
    action: Action,
    amount_near: u64,
    pre: &State,
) -> Result<StateAndDiff, String> {
    println!("step_random_action {:?} {}", action, amount_near);

    return match action {
        Action::Stake => step_call(
            &sim,
            &acc,
            "deposit_and_stake",
            json!({}),
            50 * TGAS,
            amount_near as u128 * NEAR,
            &pre,
        ),
        Action::AddLiquidity => step_call(
            &sim,
            &acc,
            "nslp_add_liquidity",
            json!({}),
            200 * TGAS,
            amount_near as u128 * NEAR,
            &pre,
        ),
        Action::RemoveLiquidity => step_call(
            &sim,
            &acc,
            "nslp_remove_liquidity",
            json!({ "amount": ntoU128(amount_near) }),
            200 * TGAS,
            NO_DEPOSIT,
            &pre,
        ),
        Action::DelayedUnstake => step_call(
            &sim,
            &acc,
            "unstake",
            json!({ "amount": ntoU128(amount_near) }),
            100 * TGAS,
            NO_DEPOSIT,
            &pre,
        ),
        Action::DUWithdraw => step_call(
            &sim,
            &acc,
            "withdraw",
            json!({ "amount": ntoU128(amount_near) }),
            50 * TGAS,
            NO_DEPOSIT,
            &pre,
        ),
        Action::LiquidUnstake => step_call(
            &sim,
            &acc,
            "liquid_unstake",
            json!({"st_near_to_burn": ntoU128(amount_near), "min_expected_near": ntoU128(amount_near*95/100)}),
            50 * TGAS,
            NO_DEPOSIT,
            &pre,
        ),
        Action::BotDistributes => bot_distributes(&sim, &pre),
        Action::BotEndOfEpochClearing => bot_end_of_epoch_clearing(&sim, &pre),
        Action::BotRetrieveFunds => bot_retrieve(&sim, &pre),
        Action::BotPingRewards => bot_ping_rewards(&sim, &pre),
        Action::StartRebalanceUnstake => bot_rebalance_unstake(&sim, &pre),
        Action::ChangePoolsWeight => bot_change_pools_weight(&sim, &pre),
        Action::LastAction => panic!("invalid action"),
    };
}

const SEED_COUNT: u16 = 5;
const START_SEED: u16 = 0;
const END_SEED: u16 = START_SEED + SEED_COUNT;

#[derive(Debug)]
struct SeedResults {
    seed: u64,
    steps_ok: u16,
}

fn execute_assume_ok(f: &dyn Fn(&Simulation, &State)->Result<StateAndDiff,String>, sim: &Simulation, start: &State) -> State
{
    match f(&sim, &start) {
        Err(x) => panic!("{}", x),
        Ok(data) => {
            data.state
        }
    }
}

#[test]
fn simulation_fuzzy() {
    let mut seed_results: Vec<SeedResults> = Vec::with_capacity(SEED_COUNT as usize);

    for seed in START_SEED..END_SEED {
        println!("//----------------");
        println!("// -- Start seed = {}", seed);
        println!("//----------------");

        let mut rng = Pcg32::seed_from_u64(seed as u64);
        // for _ in 0..50 {
        //     let y: u8 = rng.gen_range(0..10);
        //     println!("{} {}", x, y);
        // }

        let sim = Simulation::new();

        // extra init
        crate::sim_contract_state::set_unstake_for_rebalance_cap_bp(100, &sim);

        let metapool = &sim.metapool;

        //---- Users
        let mut users: Vec<UserAccount> = Vec::with_capacity(COUNT_USERS);
        for n in 0..COUNT_USERS {
            users.push(sim.testnet.create_user(format!("user{}", n), ntoy(500_000)));
        }

        let pre = build_state(&sim);
        // initial stake
        println!("--PRE {}", serde_json::to_string(&pre).unwrap_or_default());

        let amount_add_liq = 100_000 * NEAR;
        let amount_stake = 190_000 * NEAR;
        // user0 adds liquidity
        let mut initial_commands = step_call(
            &sim,
            &users[0],
            "nslp_add_liquidity",
            json!({}),
            200 * TGAS,
            amount_add_liq,
            &pre,
        )
        .unwrap();
        //everyone stakes
        for n in 0..COUNT_USERS {
            initial_commands = step_call(
                &sim,
                &users[n],
                "deposit_and_stake",
                json!({}),
                200 * TGAS,
                amount_stake,
                &initial_commands.state,
            )
            .unwrap()
        }

        let mut count_steps: u16 = 0;
        let mut count_steps_ok: u16 = 0;
        let mut state: State = initial_commands.state;
        // let mut diff: StateDiff;

        //50 fuzzy steps for each seed
        for fuzzy_steps in 1..50 {
            //--------------------
            //choose a random user
            //--------------------
            let user: usize = rng.gen_range(0..COUNT_USERS);

            count_steps += 1;
            println!("//---seed-step {}.{}", seed, count_steps);

            //--------------------
            //choose a random action
            //--------------------
            const COUNT_ACTIONS: usize = Action::LastAction as usize;
            let action_index: u8 = rng.gen_range(0..COUNT_ACTIONS) as u8;
            let action = Action::from_u8(action_index).unwrap();
            println!("random action {} {:?}", action_index, action);

            //---------------------
            //choose a random amount
            //---------------------
            let amount_u16: u16 = rng.gen();
            let amount_near = amount_u16 as u64;

            match step_random_action(&sim, &users[user], action, amount_near, &state) {
                Err(x) => println!("{}", x),
                Ok(data) => {
                    state = data.state;
                    count_steps_ok += 1;
                }
            }
        } //50 fuzzy steps

        seed_results.push(SeedResults {
            seed: seed.into(),
            steps_ok: count_steps_ok,
        });

        // orderly end of epoch
        crate::sim_contract_state::set_unstake_for_rebalance_cap_bp(0, &sim);
        state = execute_assume_ok(&bot_ping_rewards, &sim, &state);
        state = execute_assume_ok(&bot_distributes,&sim, &state);
        // advance 4 epochs to allow retrieve all
        state = execute_assume_ok(&bot_ping_rewards, &sim, &state);
        state = execute_assume_ok(&bot_ping_rewards, &sim, &state);
        state = execute_assume_ok(&bot_ping_rewards, &sim, &state);
        state = execute_assume_ok(&bot_ping_rewards, &sim, &state);
        // retrieve
        state = execute_assume_ok(&bot_retrieve,&sim, &state);
        // after retrieve we can have something to rebalance (restake), so try distribute again
        state = execute_assume_ok(&bot_distributes,&sim, &state);

        let result = bot_end_of_epoch_clearing(&sim, &state);
        //after orderly end_of_epoch check stricter invariants
        if let Ok(res) = &result {
            if res.state.epoch_stake_orders != 0 || res.state.epoch_unstake_orders != 0 {
                // both must be 0 after an orderly end_of_epoch
                panic!("after orderly end_of_epoch_clearing epoch_stake_orders {} epoch_unstake_orders {}",
                    res.state.epoch_stake_orders,
                    res.state.epoch_unstake_orders)
            }
            //no delta should remain
            if res.state.to_stake_delta != 0 {
                panic!("after orderly end_of_epoch_clearing to_stake_delta != 0, is {}, TFS:{} TAS:{}",
                    res.state.to_stake_delta, 
                    res.state.total_for_staking, 
                    res.state.total_actually_staked
                )
            }
        }
    } // x seeds

    println!("{:?}", seed_results);
}

'''
'''--- metapool/tests/sim/simulation_simple.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::{
  borsh::{self, BorshDeserialize, BorshSerialize},
  json_types::{Base58PublicKey, U128},
  serde::{Deserialize, Serialize},
  serde_json::json,
  serde_json::Value,
  *,
};
use near_sdk_sim::{
  account::AccessKey,
  call, deploy, init_simulator,
  near_crypto::{KeyType, SecretKey, Signer},
  to_yocto, view, ContractAccount, ExecutionResult, UserAccount, ViewResult, DEFAULT_GAS,
  STORAGE_AMOUNT,
};

use crate::sim_setup::*;
use crate::sim_utils::*;
use metapool::*;

// #[test]
// fn sim_bug() {
//     let master_account = init_simulator(None);
//     let testnet = master_account.create_user("testnet".into(), ntoy(1_000_000_000));

//     let test_staker = testnet.create_user("staker".to_string(), ntoy(500_000));
//     show_balance(&test_staker);
//     let get_epoch_acc = master_account.deploy(&WASM_BYTES_GET_EPOCH, String::from("get_epoch_acc"), SP_INITIAL_BALANCE);
//     let user_txn = master_account
//       .create_transaction(get_epoch_acc.account_id())
//         .function_call(
//           "new".into(),
//           "{}".into(),
//           50*TGAS, 0)
//         .submit();

//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));

//     let sk = SecretKey::from_seed(KeyType::ED25519, "test");
//     //stake => 10K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(10_000),  sk.public_key())
//       .submit();
//     show_balance(&test_staker);
//     assert!(test_staker.locked() == ntoy(10_000));
//     //stake => 15K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(15_000),  sk.public_key())
//       .submit();
//       show_balance(&test_staker);
//       assert!(test_staker.locked() == ntoy(15_000));
//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));
//     //stake => down to 7K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(7_000),  sk.public_key())
//       .submit();
//     show_balance(&test_staker);

//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));

//     //do it 15 times
//     //in the sim => 3 blocks make and epoch
//     for n in 0..5 {
//       call(&test_staker,&get_epoch_acc,"set_i32", &format!(r#"{{"num":{}}}"#,n),0,10*TGAS);
//       println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));
//     }

//     show_balance(&test_staker);

//     //stake => down to 7K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(7_000),  sk.public_key())
//       .submit();

//     assert!(test_staker.locked() == ntoy(7_000));
// }

#[test]
fn simtest_simple() {
  let sim = Simulation::new();

  let metapool = &sim.metapool;

  let view_results = view!(metapool.get_contract_info());
  print_vec_u8("contract_info", &view_results.unwrap());

  sim.show_sps_staked_balances();

  //Example transfer to account
  // let transaction = master_account
  //   .create_transaction("sp1".to_string());
  //["sp1",".", &metapool_contract.user_account.account_id()].concat());
  //let res = transaction.transfer(ntoy(1)).submit();
  //check_exec_result(res);

  //test sp1 exists
  //println!("sp0 owner {}",view_call(&sim.sp[0], "get_owner_id", "{}"));

  // test yton & ntoy
  // println!("test: {}", yton(1*NEAR));
  // println!("test: {}", yton(10*NEAR));
  // println!("test: {}", yton(123*NEAR));
  // println!("test: {}", yton(ntoy(1)));
  // println!("test: {}", yton(ntoy(10)));
  // println!("test: {}", yton(ntoy(123)));

  //println!("treasury amount: {}", sim.treasury.amount());

  //---- alice
  //---- deposit & buy stnear
  let alice = sim.testnet.create_user("alice".to_string(), ntoy(500_000));
  let prev_contract_balance = balance(&metapool.user_account);
  println!("prev contract balance {}", prev_contract_balance);
  let pre_alice = balance(&alice);
  println!("pre balance(&alice) {}", pre_alice);
  let alice_dep_and_stake = ntoy(100_000);
  let gas_tokens_burnt = {
    let res = call!(
      alice,
      metapool.deposit_and_stake(),
      alice_dep_and_stake,
      50 * TGAS
    );
    check_exec_result(&res)
  };
  println!("total tokens burnt {}", gas_tokens_burnt);
  let contract_rewards = gas_tokens_burnt / 100 * 30;
  println!("contract_rewards 30% total tokens burnt {}", contract_rewards);
  sim.show_account_info(&alice.account_id());
  let post_contract_balance = balance(&metapool.user_account);
  println!("post contract balance {}", post_contract_balance);
  let post_alice = balance(&alice);
  println!("post balance alice    {}", post_alice);
  
  println!("contract added    {}", post_contract_balance-prev_contract_balance);
  println!("alice removed     {}", pre_alice-post_alice);
  let extra_contract_added = (post_contract_balance-prev_contract_balance)-alice_dep_and_stake;
  println!("extra contract added {}, 30% of {}", 
    extra_contract_added, extra_contract_added/30*100
  );
  let alice_spent = alice_dep_and_stake + gas_tokens_burnt;
  assert_eq!( pre_alice-post_alice, alice_spent);
  assert!(post_contract_balance >= prev_contract_balance);
  assert!(post_contract_balance > prev_contract_balance + alice_dep_and_stake);
  assert!(post_contract_balance < prev_contract_balance + alice_dep_and_stake + contract_rewards);

  //---- bob
  let bob = sim.testnet.create_user("bob".to_string(), ntoy(500_000));
  let bob_dep_and_stake = ntoy(200_000);
  let bds_res = call!(
    bob,
    metapool.deposit_and_stake(),
    bob_dep_and_stake,
    50 * TGAS
  );
  sim.show_account_info(&bob.account_id());

  //---- carol
  let carol = sim.testnet.create_user("carol".to_string(), ntoy(500_000));
  let carol_deposit = ntoy(250_000);

  //let cd_res = call!(carol,metapool.deposit(), carol_deposit, 50*TGAS);
  println!("----------------------------------");
  println!("------- carol adds liquidity --");
  {
    let res = call!(
      carol,
      metapool.nslp_add_liquidity(),
      carol_deposit,
      50 * TGAS
    );
    check_exec_result(&res);
  }

  //contract state
  let view_results = view!(metapool.get_contract_state());
  print_vec_u8("contract_state", &view_results.unwrap());

  println!("----------------------------------");
  println!("------- small qty add-remove liq --");
  {
    let r1 = call!(bob, metapool.nslp_add_liquidity(), 30 * NEAR, 50 * TGAS);
    check_exec_result(&r1);
    let bob_info_1 = sim.show_account_info(&bob.account_id());
    assert!(as_u128(&bob_info_1["nslp_shares"]) == 30 * NEAR);
    let r2 = call!(
      bob,
      metapool.nslp_remove_liquidity(U128::from(30 * NEAR + 9)),
      gas = 100 * TGAS
    );
    check_exec_result(&r2);
    let bob_info_2 = sim.show_account_info(&bob.account_id());
    assert!(as_u128(&bob_info_2["nslp_shares"]) == 0);
    call!(bob, metapool.nslp_add_liquidity(), 30 * NEAR, 50 * TGAS);
    let r4 = call!(
      bob,
      metapool.nslp_remove_liquidity(U128::from(30 * NEAR + 1 - ONE_MILLI_NEAR)),
      gas = 100 * TGAS
    );
    check_exec_result(&r4);
    let bob_info_4 = sim.show_account_info(&bob.account_id());
    assert!(as_u128(&bob_info_4["nslp_shares"]) == 0);
  }

  sim.show_sps_staked_balances();

  //---- test distribute_staking
  println!("----------------------------------");
  println!("------- test distribute_staking --");
  for n in 0..4 {
    println!("------- call #{} to distribute_staking", n);
    let distribute_result = call!(
      sim.operator,
      metapool.distribute_staking(),
      gas = 125 * TGAS
    );
    //check_exec_result_profile(&distribute_result);
    sim.show_sps_staked_balances();
  }
  const STORAGE_DEPOSIT:u128 = 384 * NEAR / 100_000;
  //check the staking was distributed according to weight
  let total_staked = alice_dep_and_stake + bob_dep_and_stake - 2*STORAGE_DEPOSIT;
  for n in 0..sim.sp.len() {
    let expected: u128 = total_staked * sim.weight_basis_points_vec[n] as u128 / 10000;
    let staked = sim.sp_staked(n);
    assert!(
      staked >= expected - 1 && staked <= expected + 1,
      "total_for_staking:{}, sp{} balance = {}, wbp:{}, !== expected:{}",
      total_staked,
      n,
      &sim.sp_staked(n),
      sim.weight_basis_points_vec[n],
      expected
    );
  }

  //test unstake
  // let unstake_result = view(&sim.sp[0],"unstake_all","{}",0,50*TGAS);
  // check_exec_result_promise(&unstake_result);
  // sim.show_sps_staked_balances();

  //-----------
  sim.show_account_info(&alice.account_id());

  println!("-------------------------");
  println!("------- alice unstakes --");
  let alice_unstaking = ntoy(6_000);
  {
    let ads_res = call!(
      alice,
      metapool.unstake(alice_unstaking.into()),
      gas = 50 * TGAS
    );
    check_exec_result(&ads_res);

    sim.show_account_info(&alice.account_id());
  }

  //------------------------------
  //---- test distribute_unstaking
  println!("------------------------------------");
  println!("------- test distribute_unstaking --");
  for n in 0..20 {
    println!("------- call #{} to distribute_unstaking", n);
    let distribute_result = call!(
      sim.operator,
      metapool.distribute_unstaking(),
      gas = 125 * TGAS
    );
    check_exec_result(&distribute_result);
    sim.show_sps_staked_balances();
    if &distribute_result.unwrap_json_value() == false {
      break;
    };
  }

  //---------------------------------
  //---- test retrieve unstaked funds
  //---------------------------------
  println!("---------------------------------------------");
  println!("------- test retrieve funds from the pools --");
  for n in 0..30 {
    
    println!(
      "epoch {}",
      view(&sim.get_epoch_acc, "get_epoch_height", "{}")
    );

    println!(
      "------- call #{} to get_staking_pool_requiring_retrieve()",
      n
    );
    let retrieve_result = view!(metapool.get_staking_pool_requiring_retrieve());
    let inx = retrieve_result.unwrap_json_value().as_i64().unwrap();
    println!("------- result {}", inx);

    if inx >= 0 {
      println!("------- pool #{} requires retrieve", inx);
      println!("------- pool #{} sync unstaked", inx);
      let retrieve_result_sync = call!(
        sim.operator,
        metapool.sync_unstaked_balance(inx as u16),
        gas = 200 * TGAS
      );
      check_exec_result(&retrieve_result_sync);
      println!("{:?}",&sim.sp[inx as usize].account().unwrap());
      println!("------- pool #{} retrieve unstaked", inx);
      let retrieve_result_2 = call!(
        sim.operator,
        metapool.retrieve_funds_from_a_pool(inx as u16),
        gas = 200 * TGAS
      );
      check_exec_result(&retrieve_result_2);
    } else if inx == -3 {
      //no more funds unstaked
      break;
    }

    for epoch in 1..4 {
      //make a dummy txn to advance the epoch
      call(
        &sim.owner,
        &sim.get_epoch_acc,
        "set_i32",
        &format!(r#"{{"num":{}}}"#, inx).to_string(),
        0,
        10 * TGAS,
      );
      println!(
        "epoch {}",
        view(&sim.get_epoch_acc, "get_epoch_height", "{}")
      );
    }
  }

  println!("----------------------------------------");
  println!("------- alice calls withdraw_unstaked --");
  {
    let previous = balance(&alice);
    let ads_res = call!(alice, metapool.withdraw_unstaked(), gas = 50 * TGAS);
    check_exec_result(&ads_res);
    assert_less_than_one_milli_near_diff_balance(
      "withdraw_unstaked",
      balance(&alice),
      previous + alice_unstaking,
    );
  }

  println!("---------------------------");
  println!("------- bob liquid-unstakes");
  {
    sim.show_account_info(&bob.account_id());
    sim.show_account_info(&carol.account_id());
    sim.show_account_info(NSLP_INTERNAL_ACCOUNT);
    let vr1 = view!(metapool.get_contract_state());
    print_vec_u8("contract_state", &vr1.unwrap());
    let vr2 = view!(metapool.get_contract_params());
    print_vec_u8("contract_params", &vr2.unwrap());

    let previous = balance(&bob);
    const TO_SELL: u128 = 20_000 * NEAR;
    const MIN_REQUESTED: u128 = 19_300 * NEAR; //7% discount
    let dbp = view!(metapool.nslp_get_discount_basis_points(TO_SELL.into()));
    print_vec_u8("metapool.nslp_get_discount_basis_points", &dbp.unwrap());

    let lu_res = call!(
      bob,
      metapool.liquid_unstake(U128::from(ntoy(20_000)), U128::from(MIN_REQUESTED)),
      0,
      100 * TGAS
    );
    check_exec_result(&lu_res);
    println!("liquid unstake result {}", &lu_res.unwrap_json_value());

    let bob_info = sim.show_account_info(&bob.account_id());
    let carol_info = sim.show_account_info(&carol.account_id());
    let nslp_info = sim.show_account_info(NSLP_INTERNAL_ACCOUNT);

    assert_eq!(as_u128(&bob_info["meta"]), 250 * NEAR);
    assert_eq!(as_u128(&carol_info["meta"]), 700 * NEAR);
  }

  println!("-----------------------------------");
  println!("------- carol will remove liquidity");
  {
    const AMOUNT: u128 = 100_000 * NEAR;
    println!("-- pre ");
    let pre_balance = balance(&carol);
    println!("pre balance {}", yton(pre_balance));
    let carol_info_pre = sim.show_account_info(&carol.account_id());
    println!("-- nslp_remove_liquidity");
    let res = call!(
      carol,
      metapool.nslp_remove_liquidity(U128::from(AMOUNT)),
      gas = 100 * TGAS
    );
    check_exec_result(&res);
    //let res_json = serde_json::from_str(std::str::from_utf8(&res.unwrap()).unwrap()).unwrap();
    let res_json = res.unwrap_json_value();
    println!("-- result: {:?}", res_json);
    println!("-- after ");
    let carol_info = sim.show_account_info(&carol.account_id());
    let new_balance = balance(&carol);
    println!("new balance {}", yton(new_balance));
    let stnear = as_u128(&carol_info["st_near"]);
    println!("st_near {}", yton(stnear));
    assert_less_than_one_milli_near_diff_balance(
      "rem.liq",
      new_balance + stnear - pre_balance,
      AMOUNT,
    );
  }
}

'''
'''--- metapool/tests/sim/test_utils.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#[cfg(not(target_arch = "wasm32"))]
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};

pub const LOCKUP_NEAR: u128 = 1000;
pub const GENESIS_TIME_IN_DAYS: u64 = 500;
pub const YEAR: u64 = 365;
pub const TEST_INITIAL_BALANCE: u128 = 100;

pub fn lockup_account() -> AccountId {
    "lockup".to_string()
}

pub fn system_account() -> AccountId {
    "system".to_string()
}

pub fn account_owner() -> AccountId {
    "account_owner".to_string()
}

pub fn non_owner() -> AccountId {
    "non_owner".to_string()
}

pub fn account_foundation() -> AccountId {
    "near".to_string()
}

pub fn ntoy(near_amount: u128) -> u128 {
    return near_amount * 10u128.pow(24)
}
pub fn to_near(yoctos_amount: u128) -> u128 {
    return yoctos_amount / 10u128.pow(24)
}
//convert yocto to f64 NEAR truncate to 4 dec places
pub fn ytof(yoctos_amount: u128) -> f64 {
    let four_dec_f:f64 = ((yoctos_amount / 10u128.pow(20)) as u32).into();
    return four_dec_f / 10000.0;
}

pub fn to_nanos(num_days: u64) -> u64 {
    return num_days * 86400_000_000_000
}

pub fn to_ts(num_days: u64) -> u64 {
    // 2018-08-01 UTC in nanoseconds
    1533081600_000_000_000 + to_nanos(num_days)
}

pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
    assert!(
        std::cmp::max(left, right) - std::cmp::min(left, right) < max_delta,
            "Left {} is not even close to Right {} within delta {}",
            left, right, max_delta
    );
}

pub fn assert_almost_eq(left: u128, right: u128) {
    assert_almost_eq_with_max_delta(left, right, ntoy(10));
}

pub fn get_context(
    predecessor_account_id: AccountId,
    account_balance: u128,
    account_locked_balance: u128,
    block_timestamp: u64,
    is_view: bool,
) -> VMContext {
    VMContext {
        current_account_id: lockup_account(),
        signer_account_id: predecessor_account_id.clone(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id,
        input: vec![],
        block_index: 1,
        block_timestamp,
        epoch_height: 1,
        account_balance,
        account_locked_balance,
        storage_usage: 10u64.pow(6),
        attached_deposit: 0,
        prepaid_gas: 10u64.pow(15),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
        Default::default(),
    )));
}

pub fn public_key(byte_val: u8) -> Base58PublicKey {
    let mut pk = vec![byte_val; 33];
    pk[0] = 0;
    Base58PublicKey(pk)
}

'''
'''--- metapool/tests/tests.md ---
## TODO: migrate to near-workspaces-test (use get-mpdao tests as a model)

### Glossary

USER DEPOSIT_AND_STAKE: add to epoch_stake_orders (maybe nspl_clearing), increment total_for_stake
USER UNSTAKE: delayed-unstake, add to epoch_unstake_orders, decrement total_for_stake

DISTRIBUTE STAKE: move from the contract to sps
DISTRIBUTE UNSTAKE: invoke unstake in the sp, added to unstaked_and_waiting

RETRIEVE: Move from a sp to the contract
WITHDRAW: Move from the contract to the user

### Tests

- [x]  create contract, configure sps
- [x]  deposit and stake
- [x]  distribute staking
- [x]  delayed unstake
- [x]  withdraw unstaked
- [x]  distribute unstaking
- [x]  add liquidity
- [x]  liquid unstake
- [x]  get meta
- [x]  remove liquidity
- [x]  migration

instructions and variables

                                  epoch   epoch    total    total     retrieved    total        total    contract
                                  stake   unstake  for      actually  for_unstake  unstaked     unstake  account
                                  orders  orders   staking  staked    claims       and_waiting  claims   balance

deposit_and_stake                   +x               +x                                                     +x

deposit_and_stake+nslp_clearing   0:+x-x            0:+x-x                                                  +x (because more NEAR in nslp)
(ok,is a swap NEAR->stNEAR
so only affects the nslp)

liquid-unstake                                                                                              -x (NEAR sent to the user)
(user account and nslp)

delayed-unstake                              +x       -x                                           +x

end_of_epoch_clearing               p:0     p:0                         +delta

distribute_staking                   -x                       +x                                            -x
distribute_staking stake-from-unstk  -x                       +x         +x            -x                       (special case, as if instant retrieve)

distribute_unstaking                         -x               -x                       +x

start_rebalance_unstake                                       -x                       +x

retrieve_from_pool                                                        +x           -x                   +x
retrieve_from_pool REBAL             +y                                   +x-y         -x                   +x
(y depends on total 
unstake claims, extra)

user claim (withdraw)                                                     -x                       -x       -x

'''
'''--- scripts/call-testnet.sh ---
set -e
NETWORK=testnet
OWNER=lucio.$NETWORK
MASTER_ACC=pool.$NETWORK
OPERATOR_ACC_SUFFIX=.meta.pool.$NETWORK
OPERATOR_ACC=operator$OPERATOR_ACC_SUFFIX
CONTRACT_ACC=meta-v2.$MASTER_ACC
GOV_TOKEN=token.meta.$MASTER_ACC

export NEAR_ENV=$NETWORK

set -ex
near call $CONTRACT_ACC test_method '{}' --accountId $OPERATOR_ACC --depositYocto 1

'''
'''--- scripts/deploy-dev.sh ---
set -e
NETWORK=testnet
OWNER=lucio.$NETWORK
MASTER_ACC=pool.$NETWORK
CONTRACT_ACC=test.$MASTER_ACC
GOV_TOKEN=token.$MASTER_ACC

export NODE_ENV=$NETWORK

## delete acc
echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
read input
near delete $CONTRACT_ACC $MASTER_ACC
near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
near deploy $CONTRACT_ACC ./res/get_epoch_contract-v1.wasm
near call $CONTRACT_ACC new  --accountId $MASTER_ACC

## redeploy code only
# near deploy $CONTRACT_ACC ./res/get_epoch_contract-v1.wasm

'''
'''--- scripts/deploy-guildnet.sh ---
set -e
NETWORK=guildnet
OWNER=luciotato.$NETWORK
OPERATOR=$OWNER
MASTER_ACC=pools.$NETWORK
CONTRACT_ACC=meta.$MASTER_ACC

divy --cliconf -c $CONTRACT_ACC -acc $OWNER

export NODE_ENV=$NETWORK

#echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
#read input
#near delete $CONTRACT_ACC $MASTER_ACC
#near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
#divy deploy ./res/meta_staking_pool.wasm
#divy new { owner_account_id:$OWNER, treasury_account_id:treasury.$CONTRACT_ACC, operator_account_id:$OPERATOR } --accountId $MASTER_ACC

## redeploy code only
divy deploy ./res/meta_staking_pool.wasm  --accountId $MASTER_ACC

'''
'''--- scripts/deploy-mainnet.sh ---
set -e
NETWORK=mainnet
SUFFIX=near
export NODE_ENV=$NETWORK

OWNER=narwallets.$SUFFIX
MASTER_ACC=meta-pool.$SUFFIX
CONTRACT_ACC=$MASTER_ACC
GOV_TOKEN=meta-token.$SUFFIX
OPERATOR_ACC=operator.meta-pool.$SUFFIX
TREASURY_ACC=treasury.meta-pool.$SUFFIX

#meta --cliconf -c $CONTRACT_ACC -acc $OWNER

# near create-account $OPERATOR_ACC --masterAccount $MASTER_ACC --accountId $OWNER --initialBalance 0.5
# near create-account $TREASURY_ACC --masterAccount $MASTER_ACC --accountId $OWNER --initialBalance 0.5

## delete acc
#echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
#read input
#near delete $CONTRACT_ACC $MASTER_ACC
set -ex
near deploy $CONTRACT_ACC ./res/metapool.wasm
# near deploy $CONTRACT_ACC ./res/metapool.wasm \
#   --initFunction "new" \
#   --initArgs "{\"owner_account_id\":\"$OWNER\",\"treasury_account_id\":\"$TREASURY_ACC\",\"operator_account_id\":\"$OPERATOR_ACC\",\"meta_token_account_id\":\"$GOV_TOKEN\"}" \
#   --accountId $OWNER

#meta set_params
#near call $CONTRACT_ACC set_busy "{\"value\":false}" --accountId preprod-pool.testnet --depositYocto 1
## deafult 4 pools
##meta default_pools_testnet

## redeploy code only
# near deploy $CONTRACT_ACC ./res/metapool.wasm  --accountId $MASTER_ACC
#meta set_params

#save this deployment  (to be able to recover state/tokens)
set -ex
mkdir -p res/mainnet/metapool
cp res/metapool.wasm res/mainnet/metapool.$CONTRACT_ACC.`date +%F.%T`.wasm
date +%F.%T

'''
'''--- scripts/deploy-restore.sh ---
set -e
NETWORK=testnet
OWNER=lucio.$NETWORK
MASTER_ACC=pool.$NETWORK
CONTRACT_ACC=meta.$MASTER_ACC

meta --cliconf -c $CONTRACT_ACC -acc $OWNER

export NODE_ENV=$NETWORK

## delete acc
#echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
#read input
#near delete $CONTRACT_ACC $MASTER_ACC
#near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
#meta deploy ./res/metapool.wasm
#meta new { owner_account_id:$OWNER, treasury_account_id:treasury.$CONTRACT_ACC, operator_account_id:operator.$CONTRACT_ACC} --accountId $MASTER_ACC
## set params@meta set_params
#meta default_pools_testnet

## redeploy code only
#meta deploy ./res/metapool.wasm  --accountId $MASTER_ACC
meta deploy ./res/metapool.2021-04-13.02:49:21.wasm

#save last deployment  (to be able to recover state/tokens)
#cp ./res/metapool.wasm ./res/metapool.`date +%F.%T`.wasm
#date +%F.%T

'''
'''--- scripts/deploy-testnet.sh ---
set -e
NETWORK=testnet
OWNER=lucio.$NETWORK
MASTER_ACC=pool.$NETWORK
OPERATOR_ACC_SUFFIX=.meta.pool.$NETWORK
OPERATOR_ACC=operator$OPERATOR_ACC_SUFFIX
CONTRACT_ACC=meta-v2.$MASTER_ACC
GOV_TOKEN=token.meta.$MASTER_ACC

export NEAR_ENV=$NETWORK

## delete acc
#echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
#read input
#near delete $CONTRACT_ACC $MASTER_ACC
#near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
#meta deploy ./res/metapool.wasm
#meta new { owner_account_id:$OWNER, treasury_account_id:treasury$OPERATOR_ACC_SUFFIX, operator_account_id:OPERATOR_ACC, meta_token_account_id:$GOV_TOKEN } --accountId $MASTER_ACC
## set params@meta set_params
#meta set_params
## deafult 4 pools
##meta default_pools_testnet

## test
#near call $CONTRACT_ACC set_busy "{\"value\":false}" --accountId $CONTRACT_ACC --depositYocto 1

# set contract busy to make sure we're not upgrading in the middle of a cross-contract call
set -ex
bash build.sh
#near call $CONTRACT_ACC set_busy '{"value":true}' --accountId $OPERATOR_ACC --depositYocto 1
set -e

# ## redeploy code only
echo $NETWORK, $CONTRACT_ACC
near deploy $CONTRACT_ACC ./res/metapool.wasm  --accountId $MASTER_ACC --networkId $NETWORK
# ## MIGRATE ##
echo --TRY MIGRATE--
near call $CONTRACT_ACC migrate "{}" --accountId $OPERATOR_ACC
echo --END TRY MIGRATE, CAN FAIL ON 2dN DEPLOY IF YOU FORGET TO CHANGE OLD_STATE, BUT THAT IS NO PROBLEM --

#near call $CONTRACT_ACC set_busy '{"value":false}' --accountId $OPERATOR_ACC --depositYocto 1

#near deploy contract4.preprod-pool.testnet ./res/metapool.wasm  --accountId preprod-pool.testnet
#near call contract4.preprod-pool.testnet set_busy "{\"value\":false}" --accountId preprod-pool.testnet --depositYocto 1

#save this deployment  (to be able to recover state/tokens)
set -ex
mkdir -p res/testnet/metapool
cp res/metapool.wasm res/testnet/metapool/$CONTRACT_ACC.`date +%F.%T`.wasm
date +%F.%T

'''
'''--- scripts/propose-upgrade.sh ---
CONTRACT_ACC=meta-pool.near
set -ex
bash build.sh
meta-util dao propose upgrade $CONTRACT_ACC res/metapool.wasm
mkdir -p res/mainnet/metapool
cp res/metapool.wasm res/mainnet/metapool/$CONTRACT_ACC.`date +%F.%T`.wasm
date +%F.%T

'''
'''--- test-core-staking-pool/Cargo.toml ---
[package]
name = "staking-pool"
version = "0.4.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
# near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- test-core-staking-pool/README.md ---
# COPIED HERE FOR SIMULATION-TESTING --- internal_ping commented so withdaw works in simulation

# Staking / Delegation contract

This contract provides a way for other users to delegate funds to a single validation node.

Implements the https://github.com/nearprotocol/NEPs/pull/27 standard.

There are three different roles:
- The staking pool contract account `my_validator`. A key-less account with the contract that pools funds.
- The owner of the staking contract `owner`. Owner runs the validator node on behalf of the staking pool account.
- Delegator accounts `user1`, `user2`, etc. Accounts that want to stake their funds with the pool.

The owner can setup such contract and validate on behalf of this contract in their node.
Any other user can send their tokens to the contract, which will be pooled together and increase the total stake.
These users accrue rewards (subtracted fees set by the owner).
Then they can unstake and withdraw their balance after some unlocking period.

## Staking pool implementation details

For secure operation of the staking pool, the contract should not have any access keys.
Otherwise the contract account may issue a transaction that can violate the contract guarantees.

After users deposit tokens to the contract, they can stake some or all of them to receive "stake" shares.
The price of a "stake" share can be defined as the total amount of staked tokens divided by the the total amount of "stake" shares.
The number of "stake" shares is always less than the number of the staked tokens, so the price of single "stake" share is not less than `1`.

### Initialization

A contract has to be initialized with the following parameters:
- `owner_id` - `string` the account ID of the contract owner. This account will be able to call owner-only methods. E.g. `owner`
- `stake_public_key` - `string` the initial public key that will be used for staking on behalf of the contract's account in base58 ED25519 curve. E.g. `KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7`
- `reward_fee_fraction` - `json serialized object` the initial value of the fraction of the reward that the owner charges delegators for running the node.
The fraction is defined by the numerator and denumerator with `u32` types. E.g. `{numerator: 10, denominator: 100}` defines `10%` reward fee.
The fraction can be at most `1`. The denumerator can't be `0`.

During the initialization the contract checks validity of the input and initializes the contract.
The contract shouldn't have locked balance during the initialization.

At the initialization the contract allocates one trillion yocto NEAR tokens towards "stake" share price guarantees.
This fund is later used to adjust the the amount of staked and unstaked tokens due to rounding error.
For each stake and unstake action, the contract may spend at most 1 yocto NEAR from this fund (implicitly).

The current total balance (except for the "stake" share price guarantee amount) is converted to shares and will be staked (after the next action).
This balance can never be unstaked or withdrawn from the contract.
It's used to maintain the minimum number of shares, as well as help pay for the potentially growing contract storage.

### Delegator accounts

The contract maintains account information per delegator associated with the hash of the delegator's account ID.

The information contains:
- Unstaked balance of the account.
- Number of "stake" shares.
- The minimum epoch height when the unstaked balance can be withdrawn. Initially zero.

A delegator can do the following actions:

#### Deposit

When a delegator account first deposits funds to the contract, the internal account is created and credited with the
attached amount of unstaked tokens.

#### Stake

When an account wants to stake a given amount, the contract calculates the number of "stake" shares (`num_shares`) and the actual rounded stake amount (`amount`).
The unstaked balance of the account is decreased by `amount`, the number of "stake" shares of the account is increased by `num_shares`.
The contract increases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Unstake

When an account wants to unstake a given amount, the contract calculates the number of "stake" shares needed (`num_shares`) and
the actual required rounded unstake amount (`amount`). It's calculated based on the current total price of "stake" shares.
The unstaked balance of the account is increased by `amount`, the number of "stake" shares of the account is decreased by `num_shares`.
The minimum epoch height when the account can withdraw is set to the current epoch height increased by `4`.
The contract decreases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Withdraw

When an account wants to withdraw, the contract checks the minimum epoch height of this account and checks the amount.
Then sends the transfer and decreases the unstaked balance of the account.

#### Ping

Calls the internal function to distribute rewards if the blockchain epoch switched. The contract will restake in this case.

### Reward distribution

Before every action the contract calls method `internal_ping`.
This method distributes rewards towards active delegators when the blockchain epoch switches.
The rewards might be given due to staking and also because the contract earns gas fee rebates for every function call.
Note, the if someone accidentally (or intentionally) transfers tokens to the contract (without function call), then
tokens from the transfer will be distributed to the active stake participants of the contract in the next epoch.
Note, in a rare scenario, where the owner withdraws tokens and while the call is being processed deletes their account, the
withdraw transfer will fail and the tokens will be returned to the staking pool. These tokens will also be distributed as
a reward in the next epoch.

The method first checks that the current epoch is different from the last epoch, and if it's not changed exits the method.

The reward are computed the following way. The contract keeps track of the last known total account balance.
This balance consist of the initial contract balance, and all delegator account balances (including the owner) and all accumulated rewards.
(Validation rewards are added automatically at the beginning of the epoch, while contract execution gas rebates are added after each transaction)

When the method is called the contract uses the current total account balance (without attached deposit) and the subtracts the last total account balance.
The difference is the total reward that has to be distributed.

The fraction of the reward is awarded to the contract owner. The fraction is configurable by the owner, but can't exceed 100%.
Note, that it might be unfair for the participants of the pool if the owner changes reward fee. But this owner will lose trust of the
participants and it will lose future revenue in the long term. This should be enough to prevent owner from abusing reward fee.
It could also be the case that they could change the reward fee to make their pool more attractive.

The remaining part of the reward is added to the total staked balance. This action increases the price of each "stake" share without
changing the amount of "stake" shares owned by different accounts. Which is effectively distributing the reward based on the number of shares.

The owner's reward is converted into "stake" shares at the new price and added to the owner's account.
It's done similarly to `stake` method but without debiting the unstaked balance of owner's account.

Once the rewards are distributed the contract remembers the new total balance.

## Owner-only methods

Contract owner can do the following:
- Change public staking key. This action restakes with the new key.
- Change reward fee fraction.
- Vote on behalf of the pool. This is needed for the NEAR chain governance, and can be discussed in the following NEP: https://github.com/nearprotocol/NEPs/pull/62
- Pause and resume staking. When paused, the pool account unstakes everything (stakes 0) and doesn't restake.
It doesn't affect the staking shares or reward distribution. Pausing is useful for node maintenance. Note, the contract is not paused by default.

## Staking pool contract guarantees and invariants

This staking pool implementation guarantees the required properties of the staking pool standard:

- The contract can't lose or lock tokens of users.
- If a user deposited X, the user should be able to withdraw at least X.
- If a user successfully staked X, the user can unstake at least X.
- The contract should not lock unstaked funds for longer than 4 epochs after unstake action.

It also has inner invariants:

- The staking pool contract is secure if it doesn't have any access keys.
- The price of a "stake" is always at least `1`.
- The price of a "stake" share never decreases.
- The reward fee is a fraction be from `0` to `1` inclusive.
- The owner can't withdraw funds from other delegators.
- The owner can't delete the staking pool account.

NOTE: Guarantees are based on the no-slashing condition. Once slashing is introduced, the contract will no longer
provide some guarantees. Read more about slashing in [Nightshade paper](https://near.ai/nightshade).

## Changelog

### `0.4.0`

- Internal refactoring. Moving internal methods to `internal.rs`
- Added 4 new delegator methods:
    - `deposit_and_stake` - to deposit and stake attached balance in one call.
    - `stake_all` - to stake all unstaked balance.
    - `unstake_all` - to unstake all staked balance.
    - `withdraw_all` - to withdraw all unstaked balance.

### `0.3.0`

- Inner implementation has changed from using the hash of the account ID to use unmodified account ID as a key.
- Added 3 new view methods:
    - `get_account` - Returns human readable representation of the account for the given account ID
    - `get_number_of_accounts` - returns the total number of accounts that have positive balance in this staking pool.
    - `get_accounts` - Returns up to the limit of accounts starting from the given offset

### `0.2.1`

- Update `vote` interface to match the voting contract interface.

### `0.2.0`

- Added new owners methods: `pause_staking` and `resume_staking`. Allows pool owner to unstake everything from the pool for node maintenance.
- Added a new view method `is_staking_paused` to check whether the pool has paused staking.

## Pre-requisites

To develop Rust contracts you would need to:
* Install [Rustup](https://rustup.rs/):
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
* Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```

## Building the contract

```bash
./build.sh
```

## Usage

Commands to deploy and initialize a staking contract:

```bash
near create_account my_validator --masterAccount=owner
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
# Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee.
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
# TODO: Delete all access keys from the `my_validator` account
```

As a user, to delegate money:

```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```

To update current rewards:

```bash
near call my_validator ping '{}' --accountId user1
```

View methods:

```bash
# User1 total balance
near view my_validator get_account_total_balance '{"account_id": "user1"}'

# User1 staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

# User1 unstaked balance
near view my_validator get_account_unstaked_balance '{"account_id": "user1"}'

# Whether user1 can withdraw now
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

# Total staked balance of the entire pool
near view my_validator get_total_staked_balance '{}'

# Owner of the staking pool
near view my_validator get_owner_id '{}'

# Current reward fee
near view my_validator get_reward_fee_fraction '{}'

# Owners balance
near view my_validator get_account_total_balance '{"account_id": "owner"}'

# Staking key
near view my_validator get_staking_key '{}'
```

To un-delegate, first run `unstake`:

```bash
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1
```

And after 3 epochs, run `withdraw`:

```bash
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```

## Interface

```rust
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

/// Initializes the contract with the given owner_id, initial staking public key (with ED25519
/// curve) and initial reward fee fraction that owner charges for the validation work.
#[init]
pub fn new(
    owner_id: AccountId,
    stake_public_key: Base58PublicKey,
    reward_fee_fraction: RewardFeeFraction,
);

/// Distributes rewards and restakes if needed.
pub fn ping(&mut self);

/// Deposits the attached amount into the inner account of the predecessor.
#[payable]
pub fn deposit(&mut self);

 /// Deposits the attached amount into the inner account of the predecessor and stakes it.
#[payable]
pub fn deposit_and_stake(&mut self);

/// Withdraws the non staked balance for given account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
pub fn withdraw(&mut self, amount: U128);

/// Withdraws the entire unstaked balance from the predecessor account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
pub fn withdraw_all(&mut self);

/// Stakes the given amount from the inner account of the predecessor.
/// The inner account should have enough unstaked balance.
pub fn stake(&mut self, amount: U128);

/// Stakes all available unstaked balance from the inner account of the predecessor.
pub fn stake_all(&mut self);

/// Unstakes the given amount from the inner account of the predecessor.
/// The inner account should have enough staked balance.
/// The new total unstaked balance will be available for withdrawal in four epochs.
pub fn unstake(&mut self, amount: U128);

/// Unstakes all staked balance from the inner account of the predecessor.
/// The new total unstaked balance will be available for withdrawal in four epochs.
pub fn unstake_all(&mut self);

/****************/
/* View methods */
/****************/

/// Returns the unstaked balance of the given account.
pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

/// Returns the staked balance of the given account.
/// NOTE: This is computed from the amount of "stake" shares the given account has and the
/// current amount of total staked balance and total stake shares on the account.
pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

/// Returns the total balance of the given account (including staked and unstaked balances).
pub fn get_account_total_balance(&self, account_id: AccountId) -> U128;

/// Returns `true` if the given account can withdraw tokens in the current epoch.
pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool;

/// Returns the total staking balance.
pub fn get_total_staked_balance(&self) -> U128;

/// Returns account ID of the staking pool owner.
pub fn get_owner_id(&self) -> AccountId;

/// Returns the current reward fee as a fraction.
pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction;

/// Returns the staking public key
pub fn get_staking_key(&self) -> Base58PublicKey;

/// Returns true if the staking is paused
pub fn is_staking_paused(&self) -> bool;

/// Returns human readable representation of the account for the given account ID.
pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount;

/// Returns the number of accounts that have positive balance on this staking pool.
pub fn get_number_of_accounts(&self) -> u64;

/// Returns the list of accounts
pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount>;

/*******************/
/* Owner's methods */
/*******************/

/// Owner's method.
/// Updates current public key to the new given public key.
pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey);

/// Owner's method.
/// Updates current reward fee fraction to the new given fraction.
pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction);

/// Owner's method.
/// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise;

/// Owner's method.
/// Pauses pool staking.
pub fn pause_staking(&mut self);

/// Owner's method.
/// Resumes pool staking.
pub fn resume_staking(&mut self);
```

## Migrating from an existing validator or contract
This provides instructions to migrate your staked validator or a validator contract to a new contract

#### Upgrade to the latest near-shell:
```bash
npm install -g near-shell
```
#### Set Environment and Login:

##### If not logged into the browser, recover your account with the seed phrase first
https://wallet.betanet.nearprotocol.com/create/

```bash
#Set the NEAR environment to the target network (betanet,testnet,mainnet)
export NEAR_ENV=betanet

near login
```

#### Unstake and Withdraw:
```bash
#If you staked to your validator unstake, there is no withdraw
near stake nearkat.betanet <staking public key> 0

#If you staked to a contract get the staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

#Unsake by copying and pasting the staked balance
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1

#Wait 4 epochs (12 hours) to withdraw and check if balance is available to withdraw
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

#If is_account_unstaked_balance_available returns "true" withdraw
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Download new contract with Git:
```bash
mkdir staking-pool

cd staking-pool

git clone https://github.com/near/initial-contracts

cd initial-contracts

cd staking-pool
```
#### Build contract with Rust (This step is optional since the contract is compiled):
##### Install Rust:
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

#Add rust to current shell path
source $HOME/.cargo/env
```
##### Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```
##### Build:
```bash
./build.sh
```
#### Create a new account to deploy contract to
- Set my_validator to the name you want publicly displayed
- --masterAccount is your account you signed up to StakeWars2 with
```bash
near create_account my_validator --masterAccount=owner
```
#### Deploy the contract to the new account
```bash
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
```
#### Create a new node:

**Note** after you NEAR is unstaked stop your node and create a new one to run as the contract account

##### Stop your node
```bash
nearup stop
```
##### Move your ~/.near/betanet folder, to remove references to any previous validator node
```bash
mv ~/.near/betanet ~/.near/betanet_old
```
##### Launch your new node
With the command nearup betanet. Modify the launch command according to your actual validator configuration (e.g. using --nodocker and --binary-path)

##### Set your validator ID.
Put your staking pool account (the one we called my_validator in the steps above)

##### Copy your validator public key, or issue the command (before the next step)
```bash
cat ~/.near/betanet/validator_key.json |grep "public_key"
```
#### Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee
```bash
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
```
#### Check the current `seat price` to transfer the correct amount to your delegator(s)
```bash
near validators next| grep "seat price"
```
#### Register a delegator account (repeat these steps for additional delegators)
-- https://wallet.betanet.near.org
-- backup your seed phrase
-- transfer NEAR from your MasterAccount to the delegator account

#### Login and authorize the delegator
```bash
near login
```
#### Deposit NEAR from the delegator account to the valdiator contract
```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
```
#### Stake the deposited amount to the validator contract
```bash
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Check that your validator proposal was (Accepted) or deposit and stake more NEAR
```bash
near proposals | grep my_validator
#After some time check to make sure you're listed
near validators next | grep my_validator
```
## Common errors and resolutions

#### ERROR while adding wasm32 to toolchain: error[E0463]: can't find crate for `core`
You might have a nightly version of cargo, rustc, rustup, update to stable
```bash
rustup update stable

#Install target with stable version of Rustup
rustup +stable target add wasm32-unknown-unknown
```

#### Error:  TypedError: [-32000] Server error: account <accountId> does not exist while viewing
You are not logged in
```bash
near login
```

#### Error:  GasExceeded [Error]: Exceeded the prepaid gas
Add additional gas by adding the parameter: --gas 10000000000000000

#### Error: "wasm execution failed with error: FunctionCallError(MethodResolveError(MethodNotFound))"
Your function call is incorrect or your contract is not updated

'''
'''--- test-core-staking-pool/src/internal.rs ---
use crate::*;

impl StakingContract {
    /********************/
    /* Internal methods */
    /********************/

    /// Restakes the current `total_staked_balance` again.
    pub(crate) fn internal_restake(&mut self) {
        if self.paused {
            return;
        }
        // Stakes with the staking public key. If the public key is invalid the entire function
        // call will be rolled back.
        // Promise::new(env::current_account_id())
        //     .stake(self.total_staked_balance, self.stake_public_key.clone())
        //     .then(ext_self::on_stake_action(
        //         &env::current_account_id(),
        //         NO_DEPOSIT,
        //         ON_STAKE_ACTION_GAS,
        //     ));
    }

    pub(crate) fn internal_deposit(&mut self) -> u128 {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let amount = env::attached_deposit();
        account.unstaked += amount;
        self.internal_save_account(&account_id, &account);
        self.last_total_balance += amount;

        env::log(
            format!(
                "@{} deposited {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );
        amount
    }

    pub(crate) fn internal_withdraw(&mut self, amount: Balance) {
        assert!(amount > 0, "Withdrawal amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        assert!(
            account.unstaked_available_epoch_height <= env::epoch_height(),
            "The unstaked balance is not yet available due to unstaking delay"
        );
        account.unstaked -= amount;
        self.internal_save_account(&account_id, &account);

        env::log(
            format!(
                "@{} withdrawing {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );

        Promise::new(account_id).transfer(amount);
        self.last_total_balance -= amount;
    }

    pub(crate) fn internal_stake(&mut self, amount: Balance) {
        assert!(amount > 0, "Staking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked -= charge_amount;
        account.stake_shares += num_shares;
        self.internal_save_account(&account_id, &account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        env::log(
            format!(
                "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} staking shares",
                account_id, charge_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    pub(crate) fn inner_unstake(&mut self, amount: u128) {
        assert!(amount > 0, "Unstaking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked += receive_amount;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.internal_save_account(&account_id, &account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;

        env::log(
            format!(
                "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} staking shares",
                account_id, receive_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    /// Asserts that the method was called by the owner.
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
    }

    /// Distributes rewards after the new epoch. It's automatically called before every action.
    /// Returns true if the current epoch height is different from the last epoch height.
    pub(crate) fn internal_ping(&mut self) -> bool {
        let epoch_height = env::epoch_height();
        if self.last_epoch_height == epoch_height {
            return false;
        }
        self.last_epoch_height = epoch_height;

        // New total amount (both locked and unlocked balances).
        // NOTE: We need to subtract `attached_deposit` in case `ping` called from `deposit` call
        // since the attached deposit gets included in the `account_balance`, and we have not
        // accounted it yet.
        let total_balance =
            env::account_locked_balance() + env::account_balance() - env::attached_deposit();

        assert!(
            total_balance >= self.last_total_balance,
            "The new total balance should not be less than the old total balance"
        );
        let total_reward = total_balance - self.last_total_balance;
        if total_reward > 0 {
            // The validation fee that the contract owner takes.
            let owners_fee = self.reward_fee_fraction.multiply(total_reward);

            // Distributing the remaining reward to the delegators first.
            let remaining_reward = total_reward - owners_fee;
            self.total_staked_balance += remaining_reward;

            // Now buying "stake" shares for the contract owner at the new share price.
            let num_shares = self.num_shares_from_staked_amount_rounded_down(owners_fee);
            if num_shares > 0 {
                // Updating owner's inner account
                let owner_id = self.owner_id.clone();
                let mut account = self.internal_get_account(&owner_id);
                account.stake_shares += num_shares;
                self.internal_save_account(&owner_id, &account);
                // Increasing the total amount of "stake" shares.
                self.total_stake_shares += num_shares;
            }
            // Increasing the total staked balance by the owners fee, no matter whether the owner
            // received any shares or not.
            self.total_staked_balance += owners_fee;

            env::log(
                format!(
                    "Epoch {}: Contract received total rewards of {} tokens. New total staked balance is {}. Total number of shares {}",
                    epoch_height, total_reward, self.total_staked_balance, self.total_stake_shares,
                )
                    .as_bytes(),
            );
            if num_shares > 0 {
                env::log(format!("Total rewards fee is {} stake shares.", num_shares).as_bytes());
            }
        }

        self.last_total_balance = total_balance;
        true
    }

    /// Returns the number of "stake" shares rounded down corresponding to the given staked balance
    /// amount.
    ///
    /// price = total_staked / total_shares
    /// Price is fixed
    /// (total_staked + amount) / (total_shares + num_shares) = total_staked / total_shares
    /// (total_staked + amount) * total_shares = total_staked * (total_shares + num_shares)
    /// amount * total_shares = total_staked * num_shares
    /// num_shares = amount * total_shares / total_staked
    pub(crate) fn num_shares_from_staked_amount_rounded_down(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn num_shares_from_staked_amount_rounded_up(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    pub(crate) fn staked_amount_from_num_shares_rounded_down(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn staked_amount_from_num_shares_rounded_up(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: &Account) {
        if account.unstaked > 0 || account.stake_shares > 0 {
            self.accounts.insert(account_id, &account);
        } else {
            self.accounts.remove(account_id);
        }
    }
}

'''
'''--- test-core-staking-pool/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
// const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}

'''
'''--- test-core-staking-pool/src/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}
pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
    )));
}

'''
'''--- test-get-epoch-contract/Cargo.toml ---
[package]
edition = "2018"
name = "get-epoch-contract"
version = "0.1.0"
authors = ["luciotato <luciotato@gmail.com>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "*"

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }

'''
'''--- test-get-epoch-contract/gec-deploy-testnet.sh ---
set -e
NETWORK=testnet
OWNER=lucio.$NETWORK
MASTER_ACC=pool.$NETWORK
#OPERATOR_ACC_SUFFIX=.meta.pool.testnet
#CONTRACT_ACC=get-epoch.$MASTER_ACC
CONTRACT_ACC=test.$MASTER_ACC

export NEAR_ENV=$NETWORK
#near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
near deploy $CONTRACT_ACC target/wasm32-unknown-unknown/release/get_epoch_contract.wasm  --accountId $MASTER_ACC --networkId $NETWORK
#near call $CONTRACT_ACC new --accountId $MASTER_ACC
date

'''
'''--- test-get-epoch-contract/src/lib.rs ---
//------------------------------------
//------------------------------------
//---- TEST ONLY CONTRACT ------------
//------------------------------------
//------------------------------------
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, is_promise_success, log, near_bindgen, PanicOnDefault, 
    PromiseOrValue,
};

#[cfg(target_arch = "wasm32")]
use near_sdk::env::BLOCKCHAIN_INTERFACE;

#[global_allocator]
//static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

const CONTRACT_VERSION: &str = "2.0.0 BLOCKCHAIN_INTERFACE"; //to test Sputnik V2 remote-upgrade

mod owner;

const TGAS: u64 = 1_000_000_000_000;

//contract state
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TestContract {
    //test state
    pub saved_message: String,
    pub saved_i32: i32,
    //last response received
    pub last_epoch: u64,
    // dao
    pub owner_id: String,
}

const ONE_NEAR: Balance = 1_000_000_000_000_000_000_000_000;
const NEAR: Balance = ONE_NEAR;

const NO_DEPOSIT: u128 = 0;

type U128String = U128;

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128String;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128String);
    fn withdraw_all(&mut self);

    fn stake(&mut self, amount: U128String);

    fn unstake(&mut self, amount: U128String);

    fn unstake_all(&mut self);
}

#[ext_contract(ext_self_owner)]
pub trait SelfCallbacks {
    fn on_get_sp_total_balance(&mut self, big_amount: u128, #[callback] total_balance: U128String);
}

#[near_bindgen]
impl TestContract {
    #[init]
    pub fn new() -> Self {
        /* Prevent re-initializations */
        assert!(!env::state_exists(), "This contract is already initialized");
        return Self {
            saved_message: String::from("init"),
            saved_i32: 0,
            last_epoch: env::epoch_height(),
            owner_id: "dao2.pool.testnet".into(),
        };
    }

    // ------------------------------
    // to test Sputnik V2 remote-upgrade
    // ------------------------------
    /// get version ()
    pub fn get_version(&self) -> String {
        CONTRACT_VERSION.into()
    }

    // ------------------------------
    // Main methods
    // ------------------------------
    #[payable]
    pub fn set_message(&mut self, message: String) {
        self.saved_message = message;
    }
    #[payable]
    pub fn set_i32(&mut self, num: i32) {
        self.saved_i32 = num;
    }

    pub fn get_message(&self) -> String {
        return self.saved_message.clone();
    }

    ///Make a request to the dia-gateway smart contract
    pub fn get_epoch_height(&self) -> u64 {
        return env::epoch_height();
    }

    ///Make a request to the dia-gateway smart contract
    pub fn get_block_index(&self) -> u64 {
        return env::block_index();
    }

    // ------------------------------
    //Test u128 as argument type in a callback
    // ------------------------------
    pub fn test_callbacks(&self) -> PromiseOrValue<u128> {
        let big_amount: u128 = u128::MAX;
        //query our current balance (includes staked+unstaked+staking rewards)
        ext_staking_pool::get_account_total_balance(
            String::from("lucio.testnet"),
            //promise params
            &String::from("meta.pool.testnet"),
            NO_DEPOSIT,
            10 * TGAS,
        )
        .then(ext_self_owner::on_get_sp_total_balance(
            big_amount,
            //promise params
            &env::current_account_id(),
            NO_DEPOSIT,
            10 * TGAS,
        ))
        .into()
    }
    //prev-fn continues here
    #[private]
    pub fn on_get_sp_total_balance(
        big_amount: u128,
        #[callback] balance: U128String,
    ) -> U128String {
        log!(
            "is_promise_success:{} big_amount:{} big_amount(nears):{} balance:{}",
            is_promise_success(),
            big_amount,
            big_amount / NEAR,
            balance.0
        );
        return balance;
    }

    #[cfg(target_arch = "wasm32")]
    pub fn upgrade(self) {
        assert!(env::prepaid_gas()>150*TGAS,"set 200TGAS or more for this transaction");
        log!("start env::used_gas = {}",env::used_gas());
        //assert!(env::predecessor_account_id() == self.owner_id);
        //input is code:<Vec<u8> on REGISTER 0
        //log!("bytes.length {}", code.unwrap().len());
        const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";
        //assert!(env::predecessor_account_id() == self.controlling_dao);
        let current_id = env::current_account_id().into_bytes();
        let method_name = "migrate".as_bytes().to_vec();
        let attached_gas_pre = env::prepaid_gas() - env::used_gas();
        log!(
            "(1) attached_gas {} env::prepaid_gas(){} - env::used_gas(){}",
            attached_gas_pre,
            env::prepaid_gas(),
            env::used_gas()
        );
        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input (new contract code) into register 0
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);

                //prepare self-call promise
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);

                // 1st item, upgrade code (takes data from register 0)
                // Note: this "promise preparation" CONSUMES an important amount of gas
                // because at this point the WASM code is checked and "compiled"
                // total gas cost formula is: (2 * 184765750000 + contract_size_in_bytes * (6812999 + 64572944) + 2 * 108059500000)
                // https://github.com/Narwallets/meta-pool/issues/21
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);

                const GAS_FOR_THE_REST_OF_THIS_FUNCTION:u64 = 10*TGAS;
                let gas_for_migration = env::prepaid_gas() - env::used_gas() - GAS_FOR_THE_REST_OF_THIS_FUNCTION;
                log!(
                    "(2) gas_for_migration:{} env::prepaid_gas(){} - env::used_gas(){} - GAS_FOR_THE_REST_OF_THIS_FUNCTION {}",
                    gas_for_migration,
                    env::prepaid_gas(),
                    env::used_gas(),
                    GAS_FOR_THE_REST_OF_THIS_FUNCTION
                );
                //2nd item, schedule a call to "migrate".- (will execute on the *new code*)
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        gas_for_migration,
                    );
            });
        }
    }
}

// ------------------------------
// Unit tests
// ------------------------------

#[cfg(test)]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    /// Set the contract context
    pub fn initialize() {
        let context = get_context(String::from("client.testnet"), 10);
        testing_env!(context);
    }

    /// Defines the context for the contract
    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "contract.testnet".to_string(),
            signer_account_id: "alice.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    ///Test get_id and set_id methods
    #[test]
    fn test_id() {
        initialize();
        /* Initialize contract */
        let mut contract = super::TestContract::new();
        let msg = String::from("test string");
        contract.set_message(msg.clone());
        assert_eq!(
            contract.get_message(),
            msg.clone(),
            "Contract message is different from the expected"
        );
    }
}

'''
'''--- test-get-epoch-contract/src/owner.rs ---
use crate::*;

use near_sdk::AccountId;

// /// Amount of gas used for upgrade function itself.
// pub const GAS_FOR_UPGRADE_CALL: Gas = 50_000_000_000_000;
// /// Amount of gas for deploy action.
// pub const GAS_FOR_DEPLOY_CALL: Gas = 20_000_000_000_000;

/* KEEP OLD STATE struct to be able to read from storage
#[derive(BorshDeserialize, BorshSerialize)]
pub struct TestContractOld {
    //test state
    pub saved_message: String,
    pub saved_i32: i32,
    //last response received
    pub last_epoch: u64,
    // dao
    //pub controlling_dao:String,
}
*/

#[near_bindgen]
impl TestContract {
    pub fn set_owner(&mut self, owner_id: AccountId) {
        self.assert_owner();
        self.owner_id = owner_id.into();
    }

    // /// Upgrades given contract. Only can be called by owner/DAO.
    // /// if `migrate` is true, calls `migrate()` function right after deployment.
    // /// TODO: consider adding extra grace period in case `owner` got attacked.
    // pub fn upgrade(
    //     &self,
    //     #[serializer(borsh)] code: Vec<u8>
    // ) -> Promise {
    //     self.assert_owner();
    //     let mut promise = Promise::new(env::current_account_id()).deploy_contract(code);
    //     promise = promise.function_call(
    //         "migrate".into(),
    //         vec![],
    //         0,
    //         env::prepaid_gas() - GAS_FOR_UPGRADE_CALL - GAS_FOR_DEPLOY_CALL,
    //     );
    //     promise
    // }

    //-----------------
    //-- migration called after code upgrade
    ///  For next version upgrades, change this function.
    //-- executed after upgrade to NEW CODE
    //-----------------
    /// Should only be called by this contract on upgrade (started from DAO)
    /// Originally a NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "ERR_INVALID_PREDECESSOR"
        );
        //read old state (old structure with different name)
        let old: TestContract/*Old*/ = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        //Create the new contract using the data from the old contract.
        let new = TestContract {
            saved_message: old.saved_message,
            saved_i32: old.saved_i32,
            last_epoch: old.last_epoch,
            owner_id: "dao.pool.testnet".into(),
        };
        return new; //return new struct, will be stored as contract state
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "ERR_NOT_ALLOWED"
        );
    }
}

'''
'''--- test.sh ---
echo $(date)
cargo build
set -e
echo "NOTE: does not work (PermissionDenied) in VSCODE terminal, use an external terminal"
cd metapool

RUST_BACKTRACE=1 cargo test -- --nocapture >desk-check.log

echo "-- Output sent to metapool/desk-check.log"
echo $(date)
cd -

'''