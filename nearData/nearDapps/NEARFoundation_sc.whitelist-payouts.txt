*GitHub Repository "NEARFoundation/sc.whitelist-payouts"*

'''--- Cargo.toml ---
[package]
name = "whitelist_payouts"
version = "0.1.0"
authors = ["Oleh Ivaniuk <fedencer7@gmail.com"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0-pre.8"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.8"

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- README.md ---
# sc.whitelist-payouts
Whitelist payouts contract

![Contract flow](docs/payout_process2.png)

'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e

cargo build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/whitelist_payouts.wasm ../wasm

'''
'''--- src/lib.rs ---
use std::ops::Mul;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{
  env,
  ext_contract,
  is_promise_success,
  near_bindgen,
  AccountId,
  Balance,
  Gas,
  PanicOnDefault,
  Promise,
  PromiseError,
};

const NO_DEPOSIT: Balance = 0;
const CALLBACK: Gas = Gas(25_000_000_000_000);
const CHECK_CALL_GAS: Gas = Gas(5_000_000_000_000);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct WhitelistPayouts {
  sputnik_factory: AccountId,
  whitelist_contract: AccountId,
}

#[ext_contract(ext_self)]
pub trait ExtWhitelistPayouts {
  fn on_whitelisted(
    &mut self,
    #[callback_result] is_whitelisted: Result<bool, PromiseError>,
    account_id: AccountId,
    amount: U128,
    predecessor_account_id: AccountId,
  ) -> bool;

  fn on_transferred(
    &mut self,
    account_id: AccountId,
    amount: U128,
    predecessor_account_id: AccountId,
  ) -> bool;
}

#[near_bindgen]
impl WhitelistPayouts {
  #[init]
  pub fn new(sputnik_factory: AccountId, whitelist_contract: AccountId) -> Self {
    Self {
      sputnik_factory,
      whitelist_contract,
    }
  }

  #[payable]
  pub fn payout(&mut self, account_id: AccountId) -> Promise {
    assert!(
      env::predecessor_account_id()
        .as_str()
        .ends_with(format!(".{}", self.sputnik_factory).as_str()),
      "ERR_CALLED_ONLY_BY_FACTORY_SUB-ACCOUNT"
    );
    assert!(
      env::attached_deposit() > 0,
      "ERR_DEPOSIT_AMOUNT_CANNOT_BE_ZERO"
    );

    Promise::new(self.whitelist_contract.clone())
      .function_call(
        "is_whitelisted".to_string(),
        json!({ "account_id": account_id })
          .to_string()
          .into_bytes(),
        NO_DEPOSIT,
        CHECK_CALL_GAS, // 5 TGas
      )
      .then(ext_self::on_whitelisted(
        account_id,
        U128::from(env::attached_deposit()),
        env::predecessor_account_id(),
        env::current_account_id(),
        NO_DEPOSIT,
        CALLBACK.mul(2), // 50 TGas
      ))
  }

  #[private]
  pub fn on_whitelisted(
    &mut self,
    #[callback_result] is_whitelisted: Result<bool, PromiseError>,
    account_id: AccountId,
    amount: U128,
    predecessor_account_id: AccountId,
  ) -> bool {
    let has_whitelisted = is_promise_success() && match is_whitelisted {
      Ok(v) => v,
      _ => false
    };

    if has_whitelisted {
      Promise::new(account_id.clone())
        .transfer(amount.0)
        .then(ext_self::on_transferred(
          account_id,
          amount,
          predecessor_account_id,
          env::current_account_id(),
          NO_DEPOSIT,
          CALLBACK, // 25 TGas
        ));
      true

    } else {
      env::log_str("ERR_RECEIVER_IS_NOT_WHITELISTED");
      Promise::new(predecessor_account_id).transfer(amount.0);
      false
    }
  }

  #[private]
  pub fn on_transferred(
    &mut self,
    account_id: AccountId,
    amount: U128,
    predecessor_account_id: AccountId,
  ) -> bool {
    if is_promise_success() {
      env::log_str(&json!({
            "amount": amount,
            "payer": predecessor_account_id,
            "receiver": account_id
        })
        .to_string()
        .as_str(),
      );
      true
    } else {
      env::log_str("ERR_TRANSFERRING_TO_RECEIVER_ACCOUNT");
      Promise::new(predecessor_account_id).transfer(amount.0);
      false
    }
  }
}

#[cfg(test)]
mod tests {
  use near_sdk::test_utils::test_env::alice;
  use near_sdk::test_utils::VMContextBuilder;
  use near_sdk::{testing_env, VMContext};
  use near_sdk_sim::to_yocto;
  use super::*;

  fn get_context(predecessor_account_id: AccountId, amount: Balance) -> VMContext {
    VMContextBuilder::new()
      .predecessor_account_id(predecessor_account_id)
      .attached_deposit(amount)
      .build()
  }

  fn sputnik_factory_account() -> AccountId {
    AccountId::new_unchecked("sputnik.near".to_string())
  }

  fn whitelist_account() -> AccountId {
    AccountId::new_unchecked("whitelist.near".to_string())
  }

  fn not_dao_account() -> AccountId {
    AccountId::new_unchecked("dao.near".to_string())
  }

  fn dao_account() -> AccountId {
    AccountId::new_unchecked("dao.sputnik.near".to_string())
  }

  #[test]
  #[should_panic(expected = "ERR_CALLED_ONLY_BY_FACTORY_SUB-ACCOUNT")]
  fn test_not_caused_by_dao_account() {
    let context = get_context(not_dao_account(), to_yocto("1"));
    testing_env!(context);
    let mut contract = WhitelistPayouts::new(
      sputnik_factory_account(),
      whitelist_account()
    );
    contract.payout(alice());
  }

  #[test]
  #[should_panic(expected = "ERR_DEPOSIT_AMOUNT_CANNOT_BE_ZERO")]
  fn test_zero_deposit() {
    let context = get_context(dao_account(), 0);
    testing_env!(context);
    let mut contract = WhitelistPayouts::new(
      sputnik_factory_account(),
      whitelist_account()
    );
    contract.payout(alice());
  }
}

'''
'''--- tests/sim/main.rs ---
use crate::utils::TestUtils;
use near_sdk_sim::{call, to_yocto};
mod utils;

#[test]
fn test_successful_payout() {
  let utils = TestUtils::init_whitelist_contracts();

  let alice = &utils.alice;
  let dao = &utils.dao;
  let contract = &utils.payouts_contract;
  let transfer_amount = to_yocto("1"); // 1 NEAR

  assert!(utils.is_whitelisted(alice.account_id.clone()));

  let result = call!(
    dao,
    contract.payout(alice.account_id.clone()),
    deposit = transfer_amount
  );
  result.assert_success();

  // Check Alice balance
  let alice_balance = utils.retrieve_account_balance(alice.account_id.as_str());
  TestUtils::assert_eq_with_gas(
    to_yocto("11"), // 10 + 1 NEAR
    alice_balance
  );

  // Check Dao balance
  let dao_balance = utils.retrieve_account_balance(dao.account_id.as_str());
  TestUtils::assert_eq_with_gas(
    to_yocto("9"), // 10 - 1 NEAR
    dao_balance
  );
}

#[test]
fn test_account_is_not_whitelisted() {
  let utils = TestUtils::init_whitelist_contracts();

  let bob = &utils.bob;
  let dao = &utils.dao;
  let contract = &utils.payouts_contract;
  let transfer_amount = to_yocto("1"); // 1 NEAR

  assert!(!utils.is_whitelisted(bob.account_id.clone()));
  let dao_balance_start = utils.retrieve_account_balance(dao.account_id.as_str());
  let bob_balance_start = utils.retrieve_account_balance(bob.account_id.as_str());

  let result = call!(
    dao,
    contract.payout(bob.account_id.clone()),
    deposit = transfer_amount
  );
  result.assert_success();

  // Check the log for callback output
  assert_eq!(result.logs().len(), 1);
  assert!(result.logs()[0].contains("ERR_RECEIVER_IS_NOT_WHITELISTED"));

  // The balance of the Dao has not changed
  let dao_balance_end = utils.retrieve_account_balance(dao.account_id.as_str());
  TestUtils::assert_eq_with_gas(dao_balance_start, dao_balance_end);

  // Bob's balance has not changed
  let bob_balance_end = utils.retrieve_account_balance(dao.account_id.as_str());
  TestUtils::assert_eq_with_gas(bob_balance_start, bob_balance_end);
}

#[test]
fn test_non_existing_account() {
  let utils = TestUtils::init_whitelist_contracts();

  let dao = &utils.dao;
  let contract = &utils.payouts_contract;
  let transfer_amount = to_yocto("1"); // 1 NEAR

  let dao_balance_start = utils.retrieve_account_balance(dao.account_id.as_str());

  let result = call!(
    dao,
    contract.payout("charlie".parse().unwrap()),
    deposit = transfer_amount
  );
  result.assert_success();

  // Check the log for callback output
  assert_eq!(result.logs().len(), 1);
  assert!(result.logs()[0].contains("ERR_RECEIVER_IS_NOT_WHITELISTED"));

  // The balance of the Dao has not changed
  let dao_balance_end = utils.retrieve_account_balance(dao.account_id.as_str());
  TestUtils::assert_eq_with_gas(dao_balance_start, dao_balance_end);
}

#[test]
fn test_account_is_whitelisted_but_deleted() {
  let utils = TestUtils::init_whitelist_contracts();

  let alice = &utils.alice;
  let dao = &utils.dao;
  let contract = &utils.payouts_contract;
  let transfer_amount = to_yocto("1"); // 1 NEAR

  assert!(utils.is_whitelisted(alice.account_id.clone()));
  utils.delete_account(alice);
  let dao_balance_start = utils.retrieve_account_balance(dao.account_id.as_str());

  let result = call!(
    dao,
    contract.payout(alice.account_id.clone()),
    deposit = transfer_amount
  );
  result.assert_success();

  // One error should occur during the promise execute
  TestUtils::assert_one_promise_error(
    result.clone(),
    "Can't complete the action because account \"alice\" doesn't exist"
  );

  // The balance of the Dao has not changed
  let dao_balance_end = utils.retrieve_account_balance(dao.account_id.as_str());
  TestUtils::assert_eq_with_gas(dao_balance_start, dao_balance_end);
}

'''
'''--- tests/sim/utils.rs ---
use near_sdk::{AccountId, Balance};
use near_sdk::serde_json::json;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{
   deploy,
   init_simulator,
   lazy_static_include,
   to_yocto,
   ContractAccount,
   DEFAULT_GAS,
   ExecutionResult,
   UserAccount
};
use whitelist_payouts::WhitelistPayoutsContract;

const SPUTNIK_FACTORY_CONTRACT_ID: &str = "sputnik";
const SMART_WHITELIST_CONTRACT_ID: &str = "smart-whitelist";
const WHITELIST_PAYOUTS_CONTRACT_ID: &str = "whitelist-payouts";
const DEFAULT_BALANCE: &str = "10";
const CONTRACT_BALANCE: &str = "20";
const NO_DEPOSIT: Balance = 0;

   lazy_static_include::lazy_static_include_bytes! {
   SMART_WHITELIST_BYTES => "tests/sim/external_wasm/smart_whitelist.wasm",
   WHITELIST_PAYOUTS_BYTES => "wasm/whitelist_payouts.wasm",
}

pub struct TestUtils {
   pub root: UserAccount,
   pub payouts_contract: ContractAccount<WhitelistPayoutsContract>,
   pub whitelist: UserAccount,
   pub dao: UserAccount,
   pub alice: UserAccount,
   pub bob: UserAccount,
}

impl TestUtils {
   pub fn init_whitelist_contracts() -> Self {
      let root = init_simulator(None);

      // Smart-whitelist contract
      let whitelist = root.deploy(
         &SMART_WHITELIST_BYTES,
         SMART_WHITELIST_CONTRACT_ID.parse().unwrap(),
         to_yocto(CONTRACT_BALANCE),
      );

      // Whitelist payouts contract
      let payouts_contract = deploy!(
      contract: WhitelistPayoutsContract,
      contract_id: WHITELIST_PAYOUTS_CONTRACT_ID,
      bytes: &WHITELIST_PAYOUTS_BYTES,
      signer_account: root,
      deposit: to_yocto(CONTRACT_BALANCE),
      init_method: new(
            SPUTNIK_FACTORY_CONTRACT_ID.parse().unwrap(),
            whitelist.account_id.clone()
         )
      );

      let factory = Self::create_user(
         &root,
         SPUTNIK_FACTORY_CONTRACT_ID.to_string(),
         CONTRACT_BALANCE
      );
      let dao = Self::create_user(
         &factory,
         format!("dao.{}", SPUTNIK_FACTORY_CONTRACT_ID),
         DEFAULT_BALANCE
      );
      let alice = Self::create_user(
         &root,
         "alice".to_string(),
         DEFAULT_BALANCE
      );
      Self::init_whitelist(&root, &whitelist, &alice);
      let bob = Self::create_user(
         &root,
         "bob".to_string(),
         DEFAULT_BALANCE
      );

      TestUtils {
         root,
         payouts_contract,
         whitelist,
         dao,
         alice,
         bob,
      }
   }

   pub fn is_whitelisted(&self, account_id: AccountId) -> bool {
      self.root.view(
         self.whitelist.account_id.clone(),
         "is_whitelisted",
         &json!({
            "account_id": account_id
         })
           .to_string()
           .into_bytes()
      ).unwrap_json()
   }

   pub fn retrieve_account_balance(&self, account_id: &str) -> Balance {
      self.root
        .borrow_runtime()
        .view_account(account_id)
        .unwrap()
        .amount
   }

   pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
      assert!(
         std::cmp::max(left, right) - std::cmp::min(left, right) <= max_delta,
         "{}",
         format!(
            "Left {} is not even close to Right {} within delta {}",
            left, right, max_delta
         )
      );
   }

   pub fn assert_eq_with_gas(left: u128, right: u128) {
      Self::assert_almost_eq_with_max_delta(left, right, to_yocto("0.03")); // 300 Tgas
   }

   pub fn delete_account(&self, account: &UserAccount) {
      account.create_transaction(account.account_id.clone())
        .delete_account(self.root.account_id.clone())
        .submit();
   }

   pub fn assert_one_promise_error(promise_result: ExecutionResult, expected_error_message: &str) {
      assert_eq!(promise_result.promise_errors().len(), 1);

      if let ExecutionStatus::Failure(execution_error) =
      &promise_result.promise_errors().remove(0).unwrap().outcome().status
      {
         assert!(execution_error.to_string().contains(expected_error_message));
      } else {
         unreachable!();
      }
   }

   fn init_whitelist(root: &UserAccount, whitelist: &UserAccount, user: &UserAccount) {
      let admin_account = Self::create_user(
         root,
         "whitelist-admin".to_string(),
         DEFAULT_BALANCE
      );
      whitelist.call(
         whitelist.account_id.clone(),
         "new",
         &json!({
            "admin_pk": admin_account.signer.public_key
      })
           .to_string()
           .into_bytes(),
         DEFAULT_GAS,
         NO_DEPOSIT,
      ).assert_success();

      let service_account = Self::create_user(
         root,
         "whitelist-service".to_string(),
         DEFAULT_BALANCE
      );
      admin_account.call(
         whitelist.account_id.clone(),
         "add_service_account",
         &json!({
            "service_account_id": service_account.account_id
         })
           .to_string()
           .into_bytes(),
         DEFAULT_GAS,
         NO_DEPOSIT,
      ).assert_success();

      user.call(
         whitelist.account_id.clone(),
         "register_applicant",
         "{}".as_bytes(),
         DEFAULT_GAS,
         NO_DEPOSIT,
      ).assert_success();

      service_account.call(
         whitelist.account_id.clone(),
         "add_account",
         &json!({
            "account_id": user.account_id
         })
           .to_string()
           .into_bytes(),
         DEFAULT_GAS,
         NO_DEPOSIT,
      ).assert_success();
   }

   fn create_user(owner: &UserAccount, name: String, initial_balance: &str) -> UserAccount {
      owner.create_user(AccountId::new_unchecked(name), to_yocto(initial_balance))
   }
}

'''