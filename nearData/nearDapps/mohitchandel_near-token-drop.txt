*GitHub Repository "mohitchandel/near-token-drop"*

'''--- .github/scripts/readme.sh ---
#!/bin/bash
echo ==== Quicket deploy ====
TEXT=$(printf 'y\n' | near dev-deploy --wasmFile res/fungible_token.wasm --helperUrl https://near-contract-helper.onrender.com)
if [[ ! "$TEXT" =~ .*"Done deploying to".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Set dev account env variable ====
source neardev/dev-account.env
TEXT=$(echo $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"dev-".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Initialize contract using the new method ====
TEXT=$(near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== View contract metadata ====
TEXT=$(near view $CONTRACT_NAME ft_metadata)
if [[ ! "$TEXT" =~ .*"Example Token Name".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Create sub-account ====
TEXT=$(near create-account bob.$CONTRACT_NAME --masterAccount $CONTRACT_NAME --initialBalance 1)
if [[ ! "$TEXT" =~ .*"Account bob.$CONTRACT_NAME for network".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Add sub-account storage deposit ====
TEXT=$(near call $CONTRACT_NAME storage_deposit '' --accountId bob.$CONTRACT_NAME --amount 0.00125)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Check balance of sub-account ====
TEXT=$(near view $CONTRACT_NAME ft_balance_of '{"account_id": "'bob.$CONTRACT_NAME'"}')
if [[ ! "$TEXT" =~ .*"'0'".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Transfer tokens ====
TEXT=$(near call $CONTRACT_NAME ft_transfer '{"receiver_id": "'bob.$CONTRACT_NAME'", "amount": "19"}' --accountId $CONTRACT_NAME --amount 0.000000000000000000000001)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Check balance of sub-account ====
TEXT=$(near view $CONTRACT_NAME ft_balance_of '{"account_id": "'bob.$CONTRACT_NAME'"}')
if [[ ! "$TEXT" =~ .*"'19'".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi
'''
'''--- .github/workflows/readme.yml ---
name: Readme CI
on:
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  readme-ci:
    strategy:
      matrix:
        platform: [ubuntu-latest] # mac-os lags out
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Install NEAR CLI
        run: npm install near-cli -g
      - name: Build
        run: cd scripts && bash ./build.sh
      - name: Run Readme Commands
        run: bash .github/scripts/readme.sh
'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: 
  repository_dispatch:
    types: [tests-report]
  push:
  pull_request_target:
    types: [opened, edited]
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest]  # mac-os in development
    runs-on: ${{ matrix.platform }}
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable-2020-10-08
          target: wasm32-unknown-unknown
      - name: Run unit tests
        run: cd ft && cargo test -- --nocapture --color=always
      - name: Run Rust integration tests
        run: cd integration-tests/rs && cargo run --example integration-tests
      - name: Run TS integration tests 
        run: cd integration-tests/ts && yarn && yarn test

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli --no-optional && nvm use default
    init: yarn
    command: clear && echo Hey! Check out examples of how to build a NEP-21 Fungible Token in Rust.

'''
'''--- .vscode/settings.json ---
{
  "cSpell.words": ["bindgen", "mult"]
}

'''
'''--- README-Windows.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install --global near-cli`

## Building

To build run in CMD:
```bash
build.bat
```

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    set NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    set ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId %ID%

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call %ID% new "{\"owner_id\": \""%ID%"\", \"total_supply\": \"1000000000000000\", \"metadata\": { \"spec\": \"ft-1.0.0\", \"name\": \"Example Token Name\", \"symbol\": \"EXLT\", \"decimals\": 8 }}" --accountId %ID%

Get metadata:

    near view %ID% ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.%ID% --masterAccount %ID% --initialBalance 1

Add storage deposit for Bob's account:

    near call %ID% storage_deposit '' --accountId bob.%ID% --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view %ID% ft_balance_of "{\"account_id\": \""bob.%ID%"\"}"

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% ft_transfer "{\"receiver_id\": \""bob.%ID%"\", \"amount\": \"19\"}" --accountId %ID% --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

'''
'''--- README.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

  [Fungible Token]: https://nomicon.io/Standards/FungibleToken/Core
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install -g near-cli`

## Building

To build run:
```bash
./scripts/build.sh
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/concepts/basics/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/fungible_token.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $CONTRACT_NAME
```

To get the fungible token metadata:

```bash
near view $CONTRACT_NAME ft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    export NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId $ID

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call $ID new '{"owner_id": "'$ID'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $ID

Get metadata:

    near view $ID ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.$ID --masterAccount $ID --initialBalance 1

Add storage deposit for Bob's account:

    near call $ID storage_deposit '' --accountId bob.$ID --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view $ID ft_balance_of '{"account_id": "'bob.$ID'"}'

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID ft_transfer '{"receiver_id": "'bob.$ID'", "amount": "19"}' --accountId $ID --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run unit tests with the following command:

```bash
cd ft && cargo test -- --nocapture --color=always
```

You can run integration tests with the following commands:
*Rust*
```bash
cd integration-tests/rs && cargo run --example integration-tests
```
*TypeScript*
```bash
cd integration-tests/ts && yarn && yarn test
```

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

Note that if the `rust-toolchain` file in this repository changes, please make sure to update the `.gitpod.Dockerfile` to explicitly specify using that as default as well.

'''
'''--- airdrop-contract/Cargo.toml ---
[package]
name = "token_distribution"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
serde_json = "1.0"

'''
'''--- airdrop-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise};
use serde_json::json;

// Define the state of the contract
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    whitelisted_wallets: Vec<AccountId>,
    fungible_token_account_id: AccountId,
}

impl Default for Contract {
    fn default() -> Self {
        Self {
            fungible_token_account_id: AccountId::new_unchecked("".to_string()),
            whitelisted_wallets: vec![],
        }
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(fungible_token_account_id: AccountId) -> Self {
        // assert!(!env::state_exists(), "Already initialized");
        Self {
            fungible_token_account_id: fungible_token_account_id.into(),
            whitelisted_wallets: vec![],
        }
    }

    // Store multiple wallet addresses in the `whitelisted_wallets` array
    pub fn store_wallets(&mut self, wallet_addresses: Vec<AccountId>) {
        for wallet in wallet_addresses {
            if !self.whitelisted_wallets.contains(&wallet) {
                self.whitelisted_wallets.push(wallet);
            }
        }
    }

    // Distribute fungible tokens to those whitelisted wallets
    pub fn distribute_tokens(&self, amount_per_wallet: Balance) {
        for wallet in &self.whitelisted_wallets {
            Promise::new(self.fungible_token_account_id.clone()).function_call(
                "ft_transfer".to_string(),
                json!({ "receiver_id":wallet , "amount": amount_per_wallet })
                    .to_string()
                    .as_bytes()
                    .to_vec(),
                0,
                near_sdk::Gas(1000000),
            );
        }
    }

    // Get the whitelisted wallets
    pub fn get_whitelisted_wallets(&self) -> Vec<AccountId> {
        self.whitelisted_wallets.clone()
    }
}

'''
'''--- ft/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

'''
'''--- ft/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0-pre.7"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/rs/src/tests.rs ---
use near_sdk::json_types::U128;
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::prelude::*;
use workspaces::result::CallExecutionDetails;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const DISTRIBUTION_WASM_FILEPATH: &str = "../../res/token_distribution.wasm";
const FT_WASM_FILEPATH: &str = "../../res/fungible_token.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let distribute_wasm = std::fs::read(DISTRIBUTION_WASM_FILEPATH)?;
    let distribute_contract = worker.dev_deploy(&distribute_wasm).await?;
    let ft_wasm = std::fs::read(FT_WASM_FILEPATH)?;
    let ft_contract = worker.dev_deploy(&ft_wasm).await?;

    // create accounts
    let owner = worker.root_account().unwrap();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let bob = owner
        .create_subaccount(&worker, "bob")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let charlie = owner
        .create_subaccount(&worker, "charlie")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let dave = owner
        .create_subaccount(&worker, "dave")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    ft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": owner.id(),
            "total_supply": parse_near!("1,000,000,000 N").to_string(),
        }))?
        .transact()
        .await?;
    distribute_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "fungible_token_account_id": ft_contract.id()
        }))?
        .transact()
        .await?;
    distribute_contract
        .as_account()
        .call(&worker, ft_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
            "account_id": distribute_contract.id()
        }))?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    // begin tests
    test_total_supply(&owner, &ft_contract, &worker).await?;
    test_simple_transfer(&owner, &alice, &ft_contract, &worker).await?;
    test_store_wallets(&distribute_contract, &alice, &bob, &worker).await?;
    test_distribute_tokens(&distribute_contract, &worker).await?;
    test_get_whitelisted_wallets(&distribute_contract, &alice, &bob, &worker).await?;

    test_transfer_call_with_burned_amount(&owner, &charlie, &ft_contract, &distribute_contract, &worker)
        .await?;
    Ok(())
}

async fn test_total_supply(
    owner: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("1,000,000,000 N"));
    let res: U128 = owner
        .call(&worker, contract.id(), "ft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(res, initial_balance);
    println!("      Passed ✅ test_total_supply");
    Ok(())
}

async fn test_simple_transfer(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let transfer_amount = U128::from(parse_near!("1,000 N"));

    // register user
    user.call(&worker, contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
            "account_id": user.id()
        }))?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    // transfer ft
    owner
        .call(&worker, contract.id(), "ft_transfer")
        .args_json(serde_json::json!({
            "receiver_id": user.id(),
            "amount": transfer_amount
        }))?
        .deposit(1)
        .transact()
        .await?;

    let root_balance: U128 = owner
        .call(&worker, contract.id(), "ft_balance_of")
        .args_json(serde_json::json!({
            "account_id": owner.id()
        }))?
        .transact()
        .await?
        .json()?;

    let alice_balance: U128 = owner
        .call(&worker, contract.id(), "ft_balance_of")
        .args_json(serde_json::json!({
            "account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(root_balance, U128::from(parse_near!("999,999,000 N")));
    assert_eq!(alice_balance, transfer_amount);

    println!("      Passed ✅ test_simple_transfer");
    Ok(())
}

async fn test_transfer_call_with_burned_amount(
    owner: &Account,
    user: &Account,
    ft_contract: &Contract,
    distribute_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let transfer_amount_str = parse_near!("1,000,000 N").to_string();
    let ftc_amount_str = parse_near!("1,000 N").to_string();

    // register user
    owner
        .call(&worker, ft_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
            "account_id": user.id()
        }))?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    // transfer ft
    owner
        .call(&worker, ft_contract.id(), "ft_transfer")
        .args_json(serde_json::json!({
            "receiver_id": user.id(),
            "amount": transfer_amount_str
        }))?
        .deposit(1)
        .transact()
        .await?;

    user.call(&worker, ft_contract.id(), "ft_transfer_call")
        .args_json(serde_json::json!({
            "receiver_id": distribute_contract.id(),
            "amount": ftc_amount_str,
            "msg": "0",
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    let storage_result: CallExecutionDetails = user
        .call(&worker, ft_contract.id(), "storage_unregister")
        .args_json(serde_json::json!({"force": true }))?
        .deposit(1)
        .transact()
        .await?;

    // assert new state
    assert_eq!(
        storage_result.logs()[0],
        format!(
            "Closed @{} with {}",
            user.id(),
            parse_near!("999,000 N") // balance after defi ft transfer
        )
    );

    let total_supply: U128 = owner
        .call(&worker, ft_contract.id(), "ft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(total_supply, U128::from(parse_near!("999,000,000 N")));

    let defi_balance: U128 = owner
        .call(&worker, ft_contract.id(), "ft_total_supply")
        .args_json(json!({"account_id": distribute_contract.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(defi_balance, U128::from(parse_near!("999,000,000 N")));

    println!("      Passed ✅ test_transfer_call_with_burned_amount");
    Ok(())
}

async fn test_store_wallets(
    distribute_contract: &Contract,
    alice: &Account,
    bob: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // Call the store_wallets function
    distribute_contract
        .call(&worker, "store_wallets")
        .args_json(serde_json::json!({
            "wallet_addresses": [alice.id(), bob.id()]
        }))?
        .transact()
        .await?;

    // Fetch whitelisted wallets and verify
    let wallets: Vec<String> = distribute_contract
        .call(&worker, "get_whitelisted_wallets")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert!(wallets.contains(&alice.id().to_string()) && wallets.contains(&bob.id().to_string()));
    println!("      Passed ✅ test_store_wallets");
    Ok(())
}

// Test the `distribute_tokens` function
// Note: This is a mock test as we can't verify transaction side-effects on fungible token contract without added complexity
async fn test_distribute_tokens(
    distribute_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    distribute_contract
        .call(&worker, "distribute_tokens")
        .args_json(serde_json::json!({
            "amount_per_wallet": parse_near!("10 N").to_string()
        }))?
        .transact()
        .await?;

    // There isn't a direct way to verify if tokens were transferred unless we have added logic to the fungible token contract
    // to capture the transaction or have a callback mechanism in the distribution contract to capture failed transfers.
    // For now, assume it passed. You'll need more integration tests to fully verify this.
    println!("      Passed ✅ test_distribute_tokens (mock verification)");
    Ok(())
}

// Test the `get_whitelisted_wallets` function
async fn test_get_whitelisted_wallets(
    distribute_contract: &Contract,
    alice: &Account,
    bob: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // Fetch whitelisted wallets
    let wallets: Vec<String> = distribute_contract
        .call(&worker, "get_whitelisted_wallets")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert!(wallets.contains(&alice.id().to_string()) && wallets.contains(&bob.id().to_string()));
    println!("      Passed ✅ test_get_whitelisted_wallets");
    Ok(())
}

'''
'''--- integration-tests/ts/package.json ---
{
  "name": "fungible-token-integration-tests-ts",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "^3.1.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- integration-tests/ts/src/main.ava.ts ---
import { Worker, NearAccount, captureError, NEAR, BN } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const STORAGE_BYTE_COST = "1.5 mN";
const INITIAL_SUPPLY = "10000";

async function registerUser(ft: NearAccount, user: NearAccount) {
  await user.call(
    ft,
    "storage_deposit",
    { account_id: user },
    // Deposit pulled from ported sim test
    { attachedDeposit: STORAGE_BYTE_COST }
  );
}

async function ft_balance_of(ft: NearAccount, user: NearAccount): Promise<BN> {
  return new BN(await ft.view("ft_balance_of", { account_id: user }));
}

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  const worker = await Worker.init();
  const root = worker.rootAccount;
  const ft = await root.devDeploy("../../res/fungible_token.wasm", {
    initialBalance: NEAR.parse("100 N").toJSON(),
    method: "new_default_meta",
    args: {
      owner_id: root,
      total_supply: INITIAL_SUPPLY,
    },
  });
  const tokenDistribution = await root.devDeploy(
    "../../res/token_distribution.wasm",
    {
      initialBalance: NEAR.parse("100 N").toJSON(),
      method: "new",
      args: { fungible_token_account_id: ft },
    }
  );

  const ali = await root.createSubAccount("ali", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  console.log(ali);

  t.context.worker = worker;
  t.context.accounts = { root, ft, tokenDistribution, ali };
});

test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to tear down the worker:", error);
  });
});

test("Total supply", async (t) => {
  const { ft } = t.context.accounts;
  const totalSupply: string = await ft.view("ft_total_supply");
  t.is(totalSupply, INITIAL_SUPPLY);
});

test("Simple transfer", async (t) => {
  const { ft, ali, root } = t.context.accounts;
  const initialAmount = new BN(INITIAL_SUPPLY);
  const transferAmount = new BN("100");

  // Register by prepaying for storage.
  await registerUser(ft, ali);

  await root.call(
    ft,
    "ft_transfer",
    {
      receiver_id: ali,
      amount: transferAmount,
    },
    { attachedDeposit: "1" }
  );

  const rootBalance = await ft_balance_of(ft, root);
  const aliBalance = await ft_balance_of(ft, ali);

  t.deepEqual(new BN(rootBalance), initialAmount.sub(transferAmount));
  t.deepEqual(new BN(aliBalance), transferAmount);
});

test("Can close empty balance account", async (t) => {
  const { ft, ali } = t.context.accounts;

  await registerUser(ft, ali);

  const result = await ali.call(
    ft,
    "storage_unregister",
    {},
    { attachedDeposit: "1" }
  );

  t.is(result, true);
});

test("Can force close non-empty balance account", async (t) => {
  const { ft, root } = t.context.accounts;

  const errorString = await captureError(async () =>
    root.call(ft, "storage_unregister", {}, { attachedDeposit: "1" })
  );
  t.regex(
    errorString,
    /Can't unregister the account with the positive balance without force/
  );

  const result = await root.callRaw(
    ft,
    "storage_unregister",
    { force: true },
    { attachedDeposit: "1" }
  );

  t.is(result.logs[0], `Closed @${root.accountId} with ${INITIAL_SUPPLY}`);
});

test("Transfer call with burned amount", async (t) => {
  const { ft, tokenDistribution, root } = t.context.accounts;

  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);
  const burnAmount = new BN(10);

  await registerUser(ft, tokenDistribution);
  const result = await root
    .batch(ft)
    .functionCall(
      "ft_transfer_call",
      {
        receiver_id: tokenDistribution,
        amount: transferAmount,
        msg: burnAmount,
      },
      { attachedDeposit: "1", gas: "150 Tgas" }
    )
    .functionCall(
      "storage_unregister",
      { force: true },
      { attachedDeposit: "1", gas: "150 Tgas" }
    )
    .transact();

  t.true(
    result.logs.includes(
      `Closed @${root.accountId} with ${initialAmount
        .sub(transferAmount)
        .toString()}`
    )
  );

  t.is(result.parseResult(), true);

  t.true(result.logs.includes("The account of the sender was deleted"));

  t.true(
    result.logs.includes(
      `Account @${root.accountId} burned ${burnAmount.toString()}`
    )
  );

  // Help: this index is diff from sim, we have 10 len when they have 4
  const callbackOutcome = result.receipts_outcomes[5];
  t.is(callbackOutcome.parseResult(), transferAmount.toString());
  const expectedAmount = transferAmount.sub(burnAmount);
  const totalSupply: string = await ft.view("ft_total_supply");
  t.is(totalSupply, expectedAmount.toString());
  const defiBalance = await ft_balance_of(ft, tokenDistribution);
  t.deepEqual(defiBalance, expectedAmount);
});

test("Transfer call immediate return no refund", async (t) => {
  const { ft, tokenDistribution, root } = t.context.accounts;
  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);

  await registerUser(ft, tokenDistribution);

  await root.call(
    ft,
    "ft_transfer_call",
    {
      receiver_id: tokenDistribution,
      amount: transferAmount,
      memo: null,
      msg: "take-my-money",
    },
    { attachedDeposit: "1", gas: "150 Tgas" }
  );

  const rootBalance = await ft_balance_of(ft, root);
  const defiBalance = await ft_balance_of(ft, tokenDistribution);

  t.deepEqual(rootBalance, initialAmount.sub(transferAmount));
  t.deepEqual(defiBalance, transferAmount);
});

test("Transfer call promise panics for a full refund", async (t) => {
  const { ft, tokenDistribution, root } = t.context.accounts;
  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);

  await registerUser(ft, tokenDistribution);

  const result = await root.callRaw(
    ft,
    "ft_transfer_call",
    {
      receiver_id: tokenDistribution,
      amount: transferAmount,
      memo: null,
      msg: "this won't parse as an integer",
    },
    { attachedDeposit: "1", gas: "150 Tgas" }
  );

  t.regex(result.receiptFailureMessages.join("\n"), /ParseIntError/);

  const rootBalance = await ft_balance_of(ft, root);
  const defiBalance = await ft_balance_of(ft, tokenDistribution);

  t.deepEqual(rootBalance, initialAmount);
  t.assert(defiBalance.isZero(), `Expected zero got ${defiBalance.toJSON()}`);
});

test("add wallets to white listed wallets", async (t) => {
  const { ft, tokenDistribution, root } = t.context.accounts;
  const wallets: string[] = ["test.near", "test2.near"];
  await root.call(tokenDistribution, "store_wallets", { wallets });
  const whitelistedWallets: string[] = await tokenDistribution.view(
    "get_whitelisted_wallets",
    {}
  );
  t.is(whitelistedWallets, wallets);
});

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- scripts/build.bat ---
@echo off

title token_distribution build
cd ..
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/../airdrop-contract
cargo build --all --target wasm32-unknown-unknown --release
cd ..
cp airdrop-contract/target/wasm32-unknown-unknown/release/*.wasm ./res/

'''