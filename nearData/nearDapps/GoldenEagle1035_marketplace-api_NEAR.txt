*GitHub Repository "GoldenEagle1035/marketplace-api_NEAR"*

'''--- .gitlab-ci.yml ---
image: node:latest

before_script:
    - apt-get update -qy
    - apt-get install -y ruby-dev
    - gem install dpl

stages:
    - production

production:
    type: deploy
    stage: production
    image: ruby:latest
    script:
        - dpl --provider=heroku --app=$HEROKU_APP_PRODUCTION --api-key=$HEROKU_API_KEY
    only:
        - v2
'''
'''--- .vscode/c_cpp_properties.json ---
{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [],
            "macFrameworkPath": [],
            "compilerPath": "/usr/bin/clang++",
            "cStandard": "gnu17",
            "cppStandard": "gnu++14",
            "intelliSenseMode": "macos-gcc-x64"
        }
    ],
    "version": 4
}
'''
'''--- app/controllers/Albums.js ---
let { Album, Transfer } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    { putNFTForSelling, buyNFTToken, getNearPriceInUSD } = require('../lib/near'),
    axios = require('axios'),
    moment = require('moment')

const { utils: { format: { parseNearAmount } } } = require('near-api-js');
module.exports = {
    async getAlbums(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, Album, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getAlbum(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        let theAlbum = await Album.query().findById(id).eager(query.related)

        if (!theAlbum) {
            throw {
                message: 'Album Not Found',
                statusCode: 404
            }
        }
        let res = await axios.get(`https://amplify-dev.mypinata.cloud/ipfs/${theAlbum.cid}`).catch(err => {
            throw {
                message: err.response.data
            }
        })
        theAlbum.metadata = res.data
        return theAlbum
    },
    async sellAlbumCover(tokenBody, user) {
        if (!tokenBody.id) {
            throw {
                message: 'Id is not provided',
            }
        }
        if (!tokenBody.copy_number) {
            throw {
                message: '#copy is not provided',
            }
        }
        if (!tokenBody.price) {
            throw {
                message: 'price is not provided',
            }
        }
        let token = await Transfer.query().findById(parseInt(tokenBody.id)).eager('[transferTo]')
        if (!token) {
            throw {
                message: 'Album does not exists'
            }
        }
        if (token.transfer_to !== user.id) {
            throw {
                message: 'Only owner call sell this item'
            }
        }
        const transfer = await transaction(
            Album,
            Transfer,
            async (Album, Transfer) => {
                let tokenid = `${token.token}:${tokenBody.copy_number}`
                let { USD } = await getNearPriceInUSD()
                let nearPrice = parseInt(albumBody.price / 100) / USD
                let txnHash = await putNFTForSelling(token.transferTo.near_account_id, tokenid, nearPrice)
                let transaction = await Transfer.query().patchAndFetchById(token.id, {
                    bidding_price: parseInt(tokenBody.price),
                    is_for_sale: true
                })
                return {
                    ...transaction
                }
            })
        return transfer
    },
    async buyAlbumCover(tokenBody, user) {
        if (!tokenBody.id) {
            throw {
                message: 'Id is not provided',
            }
        }
        const transfer = await transaction(
            Album,
            Transfer,
            async (Album, Transfer) => {
                let token = await Transfer.query().findById(parseInt(tokenBody.id))
                if (!token) {
                    throw {
                        message: 'Album does not exists'
                    }
                }
                let tokenid = `${token.token}:${token.copy_number}`
                let { USD } = await getNearPriceInUSD()
                let nearPrice = parseInt(albumBody.price / 100) / USD
                let txnHash = await buyNFTToken(user.near_account_id, parseNearAmount(String(nearPrice)), tokenid)
                await Transfer.query().patchAndFetchById(token.id, { is_owner: false, is_for_sale: false })
                let transfer = await Transfer.query().insert({
                    transfer_by: token.transfer_to,
                    transfer_to: user.id,
                    token: token.token,
                    copy_number: token.copy_number,
                    type: 'album',
                    transaction_hash: txnHash,
                    yocto_near_price: parseNearAmount(String(nearPrice)),
                    price_in_usd: albumBody.price
                })
                return {
                    ...transfer
                }
            }
        )
        return transfer

    },
    async createAlbum(albumBody,) {
        const album = await transaction(
            Album,
            async (Album) => {
                var newAlbum = await Album.query().insert({
                    ...albumBody
                })

                return newAlbum
            }
        )

        return album

    },

    async editAlbum(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedAlbum = await Album.query().patchAndFetchById(id, { ...newBody })

        if (!editedAlbum) {
            throw {
                message: 'Album Not Found',
                statusCode: 404
            }
        }

        return editedAlbum
    },

    async deleteAlbum(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Album.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Album.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Album Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Auth.js ---

const { User } = require('../models'),
  md5 = require('md5'),
  jsonwebtoken = require('jsonwebtoken'),
  { sendMail } = require('../lib/external-services'),
  { transaction } = require('objection')

module.exports = {
  standardLogin: async (email, password) => {
    if (!email || !password) {
      throw {
        success: false,
        message: "Email or Password missing.",
        status: 400
      };
    }
    email = email.trim().toLowerCase();
    password = password.trim();
    const user = await User.query().findOne({
      username: email,
      password: md5(password)
    }).eager('currentRole')
    if (!user) {
      throw {
        message: 'Email and password does not match',
        statusCode: 401
      }
    }
    return {
      token: jsonwebtoken.sign({
        first_name: user.first_name,
        last_name: user.last_name,
        email: user.email,
        id: user.id,
        current_role: user.currentRole,
      },
        process.env.JWT_SECRET_KEY,
      )
    }
    try {

    } catch (e) {
      throw {
        message: e.error.message,
        statusCode: e.statusCode
      }
    }

  },
  async createUser(userBody, ) {
    let password = userBody.password
    if (userBody.password) {
      userBody.password = md5(userBody.password)
    }
    const wasFoundUser = await User.query().findOne({ email: userBody.email.trim() })
    if (wasFoundUser) {
      throw {
        message: `An user is already associated with this email`,
        statusCode: 400
      }
    }
    const user = await transaction(
      User,
      async (User) => {
        var newUser = await User.query().insert({
          ...userBody
        })

        return newUser
      }
    )
    sendMail(
      "welcome",
      userBody.email,
      "Welcome to QuipDealio!", {
      email: userBody.username,
      password: password,
      website: 'https://quipdealio.com/qd'
    })

    return {
      token: jsonwebtoken.sign({
        first_name: user.first_name,
        last_name: user.last_name,
        email: user.email,
        id: user.id,
      },
        process.env.JWT_SECRET_KEY),
      ...user.safeValues(),
    };

  },
  async ResetPassword(userBody, ) {
    if (!userBody.key) {
      throw {
        message: 'Reset Key is not provided',
        statusCode: 400
      }
    }
    if (!userBody.password) {
      throw {
        message: 'Password is not provided',
        statusCode: 400
      }
    }
    if (userBody.password) {
      userBody.password = md5(userBody.password)
    }
    const user = await User.query().findOne({ reset_token: userBody.key })
    if (!user) {
      throw {
        message: 'Invalid user token',
        statusCode: 400
      }
    }
    const patchUser = await User.query().patchAndFetchById(user.id, {
      reset_token: null,
      password: userBody.password
    })
    return {
      token: jsonwebtoken.sign({
        first_name: user.first_name,
        last_name: user.last_name,
        email: user.email,
        id: user.id,
      },
        process.env.JWT_SECRET_KEY),
      ...user.safeValues(),
    };

  },
  async ForgotPassword(userBody, ) {
    if (!userBody.email) {
      throw {
        message: 'Email is not provided',
        statusCode: 400
      }
    }
    const user = await User.query().findOne({ email: userBody.email })
    if (!user) {
      throw {
        message: 'User not found',
        statusCode: 400
      }
    }
    const key = md5((new Date()).toString())
    const patchUser = await User.query().patchAndFetchById(user.id, {
      reset_token: key,
    })
    let url = process.env.NODE_ENV === 'production' ? `https://quipdealio.com/qd/reset-password?q=${key}` : `http://localhost:8000/reset-password?q=${key}`
    sendMail(
      "forgotPassword",
      userBody.email,
      "Your Password Reset Notification", {
      name: user.first_name,
      token: patchUser.reset_token,
      url,
    }
    )
    return {
      message: 'An email has been sent with password reset link.',
      success: true
    };

  },
}
'''
'''--- app/controllers/Followers.js ---
let Follower = require('../models').Follower,
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters')
module.exports = {
    async getFollowers(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, Follower, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getFollower(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theFollower = await Follower.query().findById(id).eager(query.related)

        if (!theFollower) {
            throw {
                message: 'Follower Not Found',
                statusCode: 404
            }
        }

        return theFollower
    },

    async createFollower(followerBody, userPermissions = {}) {
        const follower = await transaction(
            Follower,
            async (Follower) => {
                var newFollower = await Follower.query().insert({
                    ...followerBody
                })

                return newFollower
            }
        )

        return follower

    },

    async editFollower(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedFollower = await Follower.query().patchAndFetchById(id, { ...newBody })

        if (!editedFollower) {
            throw {
                message: 'Follower Not Found',
                statusCode: 404
            }
        }

        return editedFollower
    },

    async deleteFollower(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Follower.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Follower.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Follower Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Marketplace.js ---
const { accountCreator } = require('near-api-js')
let { Transfer, } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    _ = require('lodash')
module.exports = {
    async getMarketplaceSongs(query = {}, pageNumber = 0, perPage = 20) {
        query.filter = {
            ...(query.filter || {})
        }
        query.filter.type = 'song'
        query.filter.is_for_sale = true
        query.related = '[song.[album,artist], transferTo]'
        let data = await filterer(query, Transfer, {
            pageNumber,
            perPage,
            related: query.related,
            orderBy: query.orderBy || 'id'
        })
        data.results = data.results.map(result => result.safeValues({}))
        data.results = data.results.reduce((acc, cur) => {
            let found = acc.find(f => f.id === cur.song.id)
            if (found) {
                found.transfers.push({ ...cur, song: undefined, })
            } else {
                acc = [...acc, { ...cur.song, transfers: [{ ...cur, song: undefined, }] }]
            }
            return acc
        }, [])

        return {
            ...data,
            page: pageNumber,
            per_page: perPage
        }

    },

    async getMarketplaceSong(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theMarketplaceSong = await MarketplaceSong.query().findById(id).eager(query.related)

        if (!theMarketplaceSong) {
            throw {
                message: 'Song Not Found',
                statusCode: 404
            }
        }

        return theMarketplaceSong
    },
}

'''
'''--- app/controllers/Near.js ---
const { keyStores, KeyPair, connect, Contract, utils: { format: { parseNearAmount } } } = require('near-api-js'),
    { User, Transfer } = require('../models'),
    jsonwebtoken = require('jsonwebtoken'),
    { getNearConfig } = require('../lib/near'),
    fs = require('fs'),
    { transaction } = require('objection'),
    { getNearPriceInUSD } = require('../lib/near')

async function LinkWallet(body) {
    const user = await User.query().findOne({ twitter_id: body.user.twitter_id })
    if (!user) {
        throw {
            message: 'User not found!'
        }
    }
    await User.query().patchAndFetchById(user.id, {
        near_account_id: body.account_id, connected_to_near: true, near_public_key: body.near_public_key, near_account_type: 'connected'
    })
    let token = jsonwebtoken.sign({
        twitter_id: user.twitter_id,
        username: user.username,
        name: user.name,
        avatar: user.avatar,
        banner: user.banner,
        near_connected: true,
        near_account_id: body.account_id,
        near_public_key: body.near_public_key,
        id: user.id,
        type: user.type,
        near_account_type: 'connected'
    },
        process.env.JWT_SECRET_KEY,
    )
    return {
        success: true,
        token
    }
}
async function sendMoney(body, user) {
    if (!body.is_wallet && !body.receiver_id) {
        throw {
            message: 'External account should be provided!'
        }
    }
    if (!body.near_price) {
        throw {
            message: 'Amount should be provided!'
        }
    }
    let reciever
    if (!body.is_wallet) {
        reciever = await User.query().findById(body.receiver_id)
    }

    if (!body.is_wallet && !reciever) {
        throw {
            message: 'Reciever does not found'
        }
    }
    let nearConfig = await getNearConfig([user.near_account_id, process.env.NEAR_CONTRACT_ACCOUNT])
    let price = parseNearAmount(`${body.near_price}`)
    // Configure the client with nearConfig and our local key store
    const client = await connect(nearConfig);
    const account = await client.account(user.near_account_id)
    let { USD } = await getNearPriceInUSD()
    let usdPrice = parseInt(body.near_price * USD * 100)
    let send = await account.sendMoney(body.is_wallet ? body.wallet : reciever.near_account_id, price)
    const transfer = await transaction(
        Transfer,
        async (Transfer) => {
            let transfer = await Transfer.query().insert({
                transfer_to: body.receiver_id,
                transfer_by: user.id,
                type: 'send',
                transaction_hash: send.transaction.hash,
                yocto_near_price: price,
                price_in_usd: usdPrice,
            })
            transfer.price = -1 * transfer.price_in_usd
            transfer.price_in_usd = -1 * transfer.price_in_usd
            transfer.price_in_yocto_near = -1 * price
            transfer.transferBy = user
            transfer.transferTo = reciever
            return transfer
        }
    )
    return {
        success: true,
        ...transfer
    }
}
async function createNewNearAccount(u) {
    const user = await User.query().findOne({ twitter_id: u.twitter_id })
    if (!user) {
        throw {
            message: 'User not found!'
        }
    }
    if (user.connected_to_near) {
        throw {
            message: `User is already associated with ${user.near_account_id}`
        }
    }
    let accountId = String((new Date()).getTime())
    let nearConfig = await getNearConfig([accountId, process.env.OWNER_NEAR_ACCOUNT])
    let publicKey = nearConfig.publicKey
    delete nearConfig.publicKey

    // Configure the client with nearConfig and our local key store
    const client = await connect(nearConfig);
    const creatorAccount = await client.account(process.env.OWNER_NEAR_ACCOUNT);
    // Create the account
    try {
        await creatorAccount.functionCall({
            contractId: process.env.NODE_ENV === 'production' ? "near" : "testnet",
            methodName: "create_account",
            args: {
                new_account_id: accountId + (process.env.NODE_ENV === 'production' ? '.near' : ''),
                new_public_key: publicKey,
            },
            gas: "300000000000000",
            attachedDeposit: parseNearAmount(`0.01`),
        });
        await User.query().patchAndFetchById(user.id, {
            near_account_id: accountId + (process.env.NODE_ENV === 'production' ? '.near' : ''),
            connected_to_near: true,
            near_public_key: publicKey
        })
        let token = jsonwebtoken.sign({
            twitter_id: user.twitter_id,
            username: user.username,
            name: user.name,
            avatar: user.avatar,
            banner: user.banner,
            near_connected: true,
            near_account_id: accountId + (process.env.NODE_ENV === 'production' ? '.near' : ''),
            near_public_key: publicKey,
            id: user.id,
            type: user.type,
        },
            process.env.JWT_SECRET_KEY,
        )
        return {
            success: true,
            token
        }
    }
    catch (error) {
        console.log("ERROR:", error.message);
        throw {
            message: error.message
        }
    }
}

module.exports = {
    LinkWallet,
    createNewNearAccount,
    sendMoney
}

'''
'''--- app/controllers/NominationVotes.js ---
let { NominationVote, Nomination } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters')

module.exports = {
    async getNominationVotes(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, NominationVote, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getNominationVote(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theNominationVote = await NominationVote.query().findById(id).eager(query.related)

        if (!theNominationVote) {
            throw {
                message: 'NominationVote Not Found',
                statusCode: 404
            }
        }

        return theNominationVote
    },

    async createNominationVote(nominationvoteBody, user_id) {
        let doesExist = await NominationVote.query().findOne({ voter_id: user_id, nomination_id: nominationvoteBody.nomination_id })
        if (doesExist) {
            throw {
                message: 'You have already nominated for this month!'
            }
        }
        const nominationvote = await transaction(
            NominationVote,
            async (NominationVote) => {
                var newNominationVote = await NominationVote.query().insert({
                    ...nominationvoteBody,
                    voter_id: user_id,
                })

                return newNominationVote
            }
        )

        return nominationvote

    },

    async editNominationVote(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedNominationVote = await NominationVote.query().patchAndFetchById(id, { ...newBody })

        if (!editedNominationVote) {
            throw {
                message: 'NominationVote Not Found',
                statusCode: 404
            }
        }

        return editedNominationVote
    },

    async deleteNominationVote(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await NominationVote.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(NominationVote.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'NominationVote Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Nominations.js ---
const { parse } = require('handlebars')
let { Nomination, NominationQueue, User, NominationVote } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    moment = require('moment')
module.exports = {
    async getNominations(query = {}, pageNumber = 0, perPage = 20) {
        query.filter = {
            ...(query.filter || {})
        }
        query.filter.for_month = moment().clone().startOf('month').format('YYYY-MM-DD')
        return {
            ...await filterer(query, Nomination, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getNomination(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theNomination = await Nomination.query().findById(id).eager(query.related)

        if (!theNomination) {
            throw {
                message: 'Nomination Not Found',
                statusCode: 404
            }
        }

        return theNomination
    },

    async createNomination(nominationBody, user_id) {
        let thisMonth = moment().clone().startOf('month').format('YYYY-MM-DD')
        let doesExist = await Nomination.query().findOne({ for_month: thisMonth, nominee: nominationBody.nominee, nominated_by: user_id, is_in_queue: true })
        if (doesExist) {
            throw {
                message: 'You have already nominated for this month!'
            }
        }
        let nominee = await User.query().findById(parseInt(nominationBody.nominee))
        if (!nominee) {
            throw {
                message: 'Nominee does not exists!'
            }
        }
        if (nominee.type === 'artist') {
            throw {
                message: `${nominee.username} is already an artist`
            }
        }
        const nomination = await transaction(
            Nomination,
            NominationVote,
            async (Nomination, NominationVote) => {
                let wasFound = await Nomination.query().findOne({ for_month: thisMonth, nominee: nominationBody.nominee })
                if (!wasFound) {
                    wasFound = await Nomination.query().insert({ for_month: thisMonth, is_in_queue: true, nominee: nominationBody.nominee, nominated_by: user_id })
                }
                var newNomination = await NominationVote.query().insert({
                    voter_id: user_id,
                    nomination_id: wasFound.id,
                })
                return newNomination
            }
        )

        return nomination

    },

    async editNomination(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedNomination = await Nomination.query().patchAndFetchById(id, { ...newBody })

        if (!editedNomination) {
            throw {
                message: 'Nomination Not Found',
                statusCode: 404
            }
        }

        return editedNomination
    },

    async deleteNomination(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Nomination.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Nomination.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Nomination Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Playlists.js ---
let { Playlist, PlaylistsSong, Song } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters')
module.exports = {
    async getPlaylists(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, Playlist, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getPlaylist(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let thePlaylist = await Playlist.query().findById(id).eager(query.related)

        if (!thePlaylist) {
            throw {
                message: 'Playlist Not Found',
                statusCode: 404
            }
        }

        return thePlaylist
    },

    async createPlaylist(playlistBody,) {
        console.log(playlistBody, 'playlistBody')
        const playlist = await transaction(
            Playlist,
            PlaylistsSong,
            async (Playlist, PlaylistsSong) => {
                var newPlaylist = await Playlist.query().insert({
                    ...playlistBody
                })
                let songIds = playlistBody.songs || []
                let songs = await Song.query().whereIn('id', songIds)
                await Promise.all(songIds.map(songId => PlaylistsSong.query().insert({ song_id: songId, playlist_id: newPlaylist.id })))
                newPlaylist.songs = songs
                return newPlaylist
            }
        )

        return playlist

    },

    async editPlaylist(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedPlaylist = await Playlist.query().patchAndFetchById(id, { ...newBody })

        if (!editedPlaylist) {
            throw {
                message: 'Playlist Not Found',
                statusCode: 404
            }
        }

        return editedPlaylist
    },

    async deletePlaylist(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Playlist.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Playlist.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Playlist Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/PlaylistsSongs.js ---
let PlaylistsSong = require('../models').PlaylistsSong,
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters')
module.exports = {
    async getPlaylistsSongs(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, PlaylistsSong, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getPlaylistsSong(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let thePlaylistsSong = await PlaylistsSong.query().findById(id).eager(query.related)

        if (!thePlaylistsSong) {
            throw {
                message: 'PlaylistsSong Not Found',
                statusCode: 404
            }
        }

        return thePlaylistsSong
    },

    async createPlaylistsSong(playlistssongBody, ) {
        const playlistssong = await transaction(
            PlaylistsSong,
            async (PlaylistsSong) => {
                var newPlaylistsSong = await PlaylistsSong.query().insert({
                    ...playlistssongBody
                })

                return newPlaylistsSong
            }
        )

        return playlistssong

    },

    async editPlaylistsSong(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedPlaylistsSong = await PlaylistsSong.query().patchAndFetchById(id, { ...newBody })

        if (!editedPlaylistsSong) {
            throw {
                message: 'PlaylistsSong Not Found',
                statusCode: 404
            }
        }

        return editedPlaylistsSong
    },

    async deletePlaylistsSong(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await PlaylistsSong.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(PlaylistsSong.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'PlaylistsSong Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Search.js ---
let { Album, User, Song } = require('../models')

module.exports = {
    async getSearch(query = {}, pageNumber = 0, perPage = 20, user_id) {
        if (!query.q) {
            throw {
                message: 'Provide query to search'
            }
        }
        let results = []

        let artists = await User.query().where('name', 'ilike', `%${query.q}%`).andWhere({ type: 'artist' }).andWhere({ is_deleted: false }).eager('[songs]')
        results.push({
            type: 'artists',
            data: artists.map(a => a.safeValues())
        })
        console.log(query.q)
        let albums = await Album.query().where('title', 'ilike', `%${query.q}%`).andWhere({ is_deleted: false }).eager('[songs,user,transfers]')
        results.push({
            type: 'albums',
            data: albums.map(a => a.safeValues({ user_id }))
        })

        let songs = await Song.query().where('title', 'ilike', `%${query.q}%`).andWhere({ is_deleted: false }).eager('[album, artist, transfers.transferTo]')

        results.push({
            type: 'songs',
            data: songs.map(a => a.safeValues({ user_id, is_for_sale: true }))
        })

        return {
            results
        }

    }
}

'''
'''--- app/controllers/Showcases.js ---
let { Showcase, Album } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters')
module.exports = {
    async getShowcases(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, Showcase, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getShowcase(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theShowcase = await Showcase.query().findById(id).eager(query.related)

        if (!theShowcase) {
            throw {
                message: 'Showcase Not Found',
                statusCode: 404
            }
        }
        return theShowcase
    },

    async createShowcase(showcaseBody,) {
        const showcase = await transaction(
            Showcase,
            async (Showcase) => {
                let showcases = await Showcase.query().where({ is_deleted: false, album_id: showcaseBody.album_id, user_id: showcaseBody.user_id })
                if (showcases.length) {
                    throw {
                        message: 'This album is already added to your showcase'
                    }
                }
                var newShowcase = await Showcase.query().insert({
                    ...showcaseBody
                })
                newShowcase.album = await Album.query().findById(showcaseBody.album_id)
                return newShowcase
            }
        )

        return showcase

    },

    async editShowcase(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedShowcase = await Showcase.query().patchAndFetchById(id, { ...newBody })

        if (!editedShowcase) {
            throw {
                message: 'Showcase Not Found',
                statusCode: 404
            }
        }

        return editedShowcase
    },

    async deleteShowcase(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Showcase.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Showcase.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Showcase Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Songs.js ---
let { Song, Transfer, Playlist, Album } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    { putNFTForSelling, buyNFTToken, getNearPriceInUSD } = require('../lib/near'),
    moment = require('moment'),
    _ = require('lodash')
const { utils: { format: { parseNearAmount } } } = require('near-api-js');

module.exports = {
    async getSongs(query = {}, pageNumber = 0, perPage = 20, user) {
        let albums = await Album.query().where({ is_deleted: false, user_id: user.id, has_copy: true }).eager('[songs.album]')
        let preparedFetch = Song.query().alias('model')
        // if (query && query.filter && query.filter.user_playlist) {
        let playlist = Playlist.query().alias('play')
        let playlists = await playlist.where({ is_deleted: false, user_id: user.id }).eager('[songs]')
        let songIds = playlists.reduce((acc, cur) => [...acc, ...cur.songs.map(s => s.id)], [])
        preparedFetch.whereNotIn('model.id', songIds)
        // }
        preparedFetch.joinRelated('[transfers]', { alias: 't' })
        preparedFetch.where('t.is_owner', '=', true);
        preparedFetch.andWhere('t.transfer_to', '=', user.id);
        preparedFetch.andWhere('model.is_deleted', '=', false);
        preparedFetch.eager('[album, transfers.song.album]')
        let results = await preparedFetch
        results = results.map(song => ({
            ...song, is_album_cover_owner: song.transfers.some(t => t.is_owner && t.transfer_to === user.id)
        }))
        // console.log(results)
        let albumSongs = albums.reduce((acc, album) => [...acc, ...album.songs.map(song => ({ ...song, is_album_cover_owner: song.album.has_copy && song.album.user_id === user.id }))], [])
        results = _.uniqBy([...results, ...albumSongs], 'song_cid')
        let total = results.length
        pageNumber = parseInt(pageNumber)
        perPage = parseInt(perPage)
        results = results.slice((pageNumber * (perPage || 20)), ((perPage || 20)) * (pageNumber + 1))
        return {
            results,
            page: pageNumber,
            per_page: perPage,
            total
        }

    },

    async getSong(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theSong = await Song.query().findById(id).eager(query.related)

        if (!theSong) {
            throw {
                message: 'Song Not Found',
                statusCode: 404
            }
        }

        return theSong
    },

    async createSong(songBody,) {
        const song = await transaction(
            Song,
            async (Song) => {
                var newSong = await Song.query().insert({
                    ...songBody
                })

                return newSong
            }
        )

        return song

    },
    async sellSong(songBody) {
        if (!songBody.id) {
            throw {
                message: 'Id is not provided',
            }
        }
        if (!songBody.price) {
            throw {
                message: 'price is not provided',
            }
        }
        const transfer = await transaction(
            Transfer,
            async (Transfer) => {
                let token = await Transfer.query().findById(parseInt(songBody.id)).eager('[song.album, transferTo]')
                if (!token) {
                    throw {
                        message: 'Song does not exists'
                    }
                }
                let songtokenid = `${token.song.album.cover_cid}:${token.copy_number}:${token.token}`
                // fetch ammount
                let { USD } = await getNearPriceInUSD()
                let nearPrice = songBody.price / (100 * USD)
                let txnHash = await putNFTForSelling(token.transferTo.near_account_id, songtokenid, nearPrice)
                let transaction = await Transfer.query().patchAndFetchById(token.id, {
                    bidding_price: parseInt(songBody.price),
                    is_for_sale: true,
                    yocto_near_price: parseNearAmount(`${nearPrice}`)
                })
                return {
                    ...transaction
                }
            })
        return transfer
    },
    async buySong(songBody, user) {
        if (!songBody.id) {
            throw {
                message: 'Id is not provided',
            }
        }
        if (!songBody.price) {
            throw {
                message: 'price is not provided',
            }
        }
        let token = await Transfer.query().findById(parseInt(songBody.id)).eager('[song.album, transferTo]')
        if (!token) {
            throw {
                message: 'Song does not exists'
            }
        }
        let songtokenid = `${token.song.album.cover_cid}:${token.copy_number}:${token.token}`
        let txnHash = await buyNFTToken(user.near_account_id, token.yocto_near_price, songtokenid)
        await Transfer.query().patchAndFetchById(token.id, { is_owner: false, is_for_sale: false })
        let { USD } = await getNearPriceInUSD()
        let nearPrice = token.bidding_price / (100 * USD)
        let transfer = await Transfer.query().insert({
            transfer_by: token.transfer_to,
            transfer_to: user.id,
            token: token.token,
            copy_number: token.copy_number,
            type: 'song',
            transaction_hash: txnHash,
            price_in_usd: token.bidding_price,
            yocto_near_price: parseNearAmount(`${nearPrice}`)
        })
        return {
            ...transfer
        }
    },
    async editSong(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedSong = await Song.query().patchAndFetchById(id, { ...newBody })

        if (!editedSong) {
            throw {
                message: 'Song Not Found',
                statusCode: 404
            }
        }

        return editedSong
    },

    async deleteSong(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await Song.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(Song.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'Song Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/controllers/Transactions.js ---
let { Transfer, Album } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    _ = require('lodash')
const { utils: { format: { parseNearAmount } }, } = require('near-api-js')

module.exports = {

    async getTransactions(query = {}, pageNumber = 0, perPage = 20, user) {
        // fetch transfered album/songs
        let preparedFetch1 = Transfer.query().where({ is_deleted: false })
        preparedFetch1.andWhere(qb => {
            qb.where({ transfer_by: user.id })
            qb.orWhere({ transfer_to: user.id })
        })
        preparedFetch1.eager('[transferBy, transferTo, album, song.album]')
        let results = await preparedFetch1

        // fetch minted albums
        let preparedFetch2 = Album.query().where({ is_deleted: false, user_id: user.id }).eager('user')

        let results1 = await preparedFetch1
        let results2 = await preparedFetch2

        //filter out the albums bundle transaction
        results1 = _.uniqBy(results1, (each) => {
            return each.transaction_hash
        })
        let total = results1.length + results2.length
        pageNumber = parseInt(pageNumber)
        perPage = parseInt(perPage)
        let sorted = [...results1, ...results2].sort((a, b) => b.created_at - a.created_at)
        results = sorted.slice((pageNumber * (perPage || 20)), ((perPage || 20)) * (pageNumber + 1))
        results = results.map(result => ({
            transfer_to: result.transfer_to,
            transaction_hash: result.type ? result.transaction_hash : result.txn_hash,
            created_at: result.created_at,
            price: result.type ? result.transfer_to !== user.id && result.type !== 'send' ? result.price_in_usd : result.price_in_usd * -1 : result.minting_cost * -1,
            price_in_yocto_near: result.type ? result.transfer_to !== user.id && result.type !== 'send' ? result.yocto_near_price : '-' + result.yocto_near_price : '-' + parseNearAmount('0.1'), // currently 0.1 NEAR is deducted while minting
            type: result.type ? result.type : 'minted',
            is_owner: result.is_owner,
            price_in_usd: result.price_in_usd,
            id: result.id,
            transferBy: result.type ? result.transferBy : result.user,
            transferTo: result.type ? result.transferTo : user,
            cover: result.album ? result.album.cover_cid : result.song && result.song.album ? result.song.album.cover_cid : result.cover_cid,
            title: result.album ? result.album.title : result.song ? result.song.title : result.title,
            description: result.album ? result.album.description : result.song ? result.song.description : result.description,
        }))
        return {
            results,
            page: pageNumber,
            per_page: perPage,
            total
        }
    }
}

'''
'''--- app/controllers/Transfer.js ---
let { Album, Transfer, Song } = require('../models'),
    { onBuyAlbumTokens, unlockToken, getSale, getNearPriceInUSD, onBuySongToken } = require('../lib/near'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    _ = require('lodash'),
    moment = require('moment')
const { utils: { format: { parseNearAmount } } } = require('near-api-js');

module.exports = {
    async getTransfers(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, Transfer, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id'
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getTransfer(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theTransfer = await Transfer.query().findById(id).eager(query.related)

        if (!theTransfer) {
            throw {
                message: 'Transfer Not Found',
                statusCode: 404
            }
        }

        return theTransfer
    },
    async transferToken(tokenBody, user) {
        let token = await Album.query().findOne({ id: tokenBody.token_id }).eager('[currentOwner]')
        if (!token) {
            throw {
                message: 'Album not found'
            }
        }
        if (!tokenBody.copy_number && (!token.has_copy || !parseInt(token.available_qty))) {
            throw {
                message: 'This album does not have album copies any more'
            }
        }
        let copy_number = parseInt(token.qty) - parseInt(token.available_qty) + 1

        let transactionHash = await onBuyAlbumTokens(token.cover_cid, parseInt(copy_number), user.near_account_id, token.yocto_near_price)
        const transfer = await transaction(
            Album,
            Transfer,
            Song,
            async (Album, Transfer) => {
                await Album.query().patchAndFetchById(token.id, {
                    available_qty: token.available_qty - 1,
                    has_copy: Boolean(token.available_qty - 1),
                    current_owner: user.id,
                    is_purchased: true
                })
                let transfer = await Transfer.query().insert({
                    // if current album has copies, then it is transferred from the original author
                    transfer_by: Boolean(token.available_qty) ? token.user_id : token.currentOwner.id,
                    transfer_to: user.id,
                    transaction_hash: transactionHash,
                    copy_number: (token.qty - token.available_qty) + 1,
                    token: token.cover_cid,
                    type: 'album_bundle',
                    yocto_near_price: token.yocto_near_price,
                    price_in_usd: token.price
                })
                let songs = await Song.query().where({ album_id: token.id })
                let results = await Promise.all(
                    songs.map(song =>
                        Transfer.query().insert({
                            transfer_by: token.currentOwner.id,
                            transfer_to: user.id,
                            transaction_hash: transactionHash,
                            copy_number: (token.qty - token.available_qty) + 1,
                            token: song.song_cid,
                            type: 'song',
                            yocto_near_price: 0,
                            price_in_usd: 0
                        }))
                )
                return transfer
            })
        return transfer
    },
    async unlockToken(tokenBody, user) {
        if (!tokenBody.token) {
            throw {
                message: 'Token is not provided',
            }
        }
        let transactionHash = await unlockToken(tokenBody.token, user.near_account_id)

        return {
            message: 'Successfully unlocked!',
            hash: transactionHash
        }
    },
    async getSale(tokenBody, user) {
        if (!tokenBody.type) {
            throw {
                message: 'Type is not provided',
            }
        }
        if (!tokenBody.copy_number || typeof tokenBody.copy_number !== 'number') {
            throw {
                message: 'Please provide the copy number',
            }
        }
        let token, type = tokenBody.type
        if (type === 'album') {
            token = await Album.query().findOne({ cover_cid: tokenBody.token_id }).eager('[currentOwner]')
            if (!token) {
                throw {
                    message: 'Album not found'
                }
            }
            if (token.current_owner !== user.id) {
                throw {
                    message: 'Only owner can unlock this token'
                }
            }
        } else {
            token = await Song.query().findOne({ song_cid: tokenBody.token_id }).eager('[currentOwner]')
            if (!token) {
                throw {
                    message: 'Song not found'
                }
            }
            if (token.current_owner !== user.id) {
                throw {
                    message: 'Only owner can unlock this token'
                }
            }
        }
        let sale = await getSale(type === 'album' ? token.cover_cid : token.song_cid, parseInt(token.available_qty), user.near_account_id)

        return {
            ...sale
        }
    }
}

'''
'''--- app/controllers/Upload.js ---
let { Song, Album, User } = require('../models'),
    { transaction } = require('objection'),
    { processMinting, minyBatchTransactionsForSong } = require('../lib/near')
const fs = require("fs"),
    path = require("path"),
    moment = require("moment")
const { utils: { format: { parseNearAmount } } } = require('near-api-js');
const del = require('del');
const { getNearPriceInUSD } = require('../lib/near')
const pinataSDK = require('@pinata/sdk');
const pinata = pinataSDK(process.env.PINATA_API_KEY, process.env.PINATA_API_SECRET);

const ipfsGateway = 'https://amplify-dev.mypinata.cloud'
module.exports = {
    ipfsGateway,
    async uploadFileToPinata(path, metaname, keyvalues = {}) {
        const options = {
            pinataMetadata: {
                name: metaname,
                keyvalues
            },
            pinataOptions: {
                cidVersion: 0
            }
        };
        return await pinata.pinFileToIPFS(path, options)
    },
    async uploadFile(file, body) {
        let uploadedJSON = await module.exports.uploadFileToPinata(fs.createReadStream(path.resolve() + '/' + file.path), body.name, {})
        if (uploadedJSON.isDuplicate) {
            let album = await Album.query().findOne({ is_deleted: false, cover_cid: uploadedJSON.IpfsHash })
            if (album) {
                throw {
                    message: `This is already associated with album with title : ${album.title}`,
                    type: 'EXISTS'
                }
            } else {
                let song = await Song.query().findOne({ is_deleted: false, song_cid: uploadedJSON.IpfsHash })
                console.log(song, 'song')
                if (song) {
                    throw {
                        message: `This is already associated with song with title : ${song.title}`,
                        type: 'EXISTS'
                    }
                }
            }
            await del.sync([`${path.resolve()}/${file.path}`])
        }
        return uploadedJSON;
    },
    async uploadJSONToPinata(body, metaname, keyvalues = {}) {
        const options = {
            pinataMetadata: {
                name: metaname,
                keyvalues
            },
            pinataOptions: {
                cidVersion: 0
            }
        };
        return await pinata.pinJSONToIPFS(body, options)
    },
    async uploadAlbum(albumBody, user_id) {
        if (!albumBody.cover) {
            throw {
                message: 'Album cover should be provided'
            }
        }
        if (!albumBody.name) {
            throw {
                message: 'Album name should be provided'
            }
        }
        const uploadedAlbum = await transaction(
            User,
            Album,
            async (User, Album) => {
                const user = await User.query().findById(user_id)
                let albumUrl = `${ipfsGateway}/ipfs/${albumBody.cover}`
                // upload metadata for the song
                const albumSchema = {}
                albumSchema['name'] = `${albumBody.name}`
                albumSchema['cover'] = albumUrl
                albumSchema['description'] = `${albumBody.description}`
                let metaObj = await module.exports.uploadJSONToPinata(albumSchema, albumBody.name + '- Info', {})
                let metdataUrl = `${ipfsGateway}/ipfs/${metaObj.IpfsHash}`
                let { USD } = await getNearPriceInUSD()
                let nearPrice = parseInt(albumBody.price / 100) / USD
                let price = parseNearAmount(`${nearPrice}`)
                // mint token with song url
                try {
                    // await del.sync([`${path.resolve()}/${file.path}`])
                    const album = await Album.query().insert({
                        cid: metaObj.IpfsHash,
                        title: albumBody.name,
                        description: albumBody.description,
                        cover_cid: albumBody.cover,
                        user_id: user.id,
                        qty: parseInt(albumBody.qty) || 1,
                        available_qty: parseInt(albumBody.qty),
                        current_owner: user_id,
                        price: albumBody.price,
                        yocto_near_price: price,
                        minting_cost: (0.1 * USD).toFixed(2) * 100
                    })
                    return {
                        album_id: album.id,
                        owner: user.near_account_id,
                        medadata: metdataUrl,
                        ...album,
                        cover_url: albumUrl,
                        // txn_hash: txnHash,
                    }
                } catch (e) {
                    console.log(e, 'MES')
                    throw {
                        message: JSON.parse(e.message).kind.ExecutionError
                    }
                }
            })
        return uploadedAlbum
    },
    async uploadSongs(songBody, user_id) {
        let songsMetadata = songBody.metadata
        songsMetadata.map(f => {
            if (!f.title) {
                throw {
                    message: 'Song title is missing for one of your files'
                }
            }
        })
        let qty = songBody.qty
        delete songBody.qty
        const uploadedSongs = await transaction(
            User,
            Song,
            async (User, Song) => {
                const user = await User.query().findById(user_id)

                let album = await Album.query().findOne({ id: songBody.album_id })
                if (!album) {
                    throw {
                        message: 'Album does not exist'
                    }
                }
                let albumUrl = `${ipfsGateway}/ipfs/${album.cid}`

                // upload file to pinata
                const results = await Promise.all(songsMetadata.map(async (file, index) => {
                    let songUrl = `${ipfsGateway}/ipfs/${file.hash}`
                    // upload metadata for the song
                    const songSchema = {}
                    const now = new Date().getTime()
                    songSchema['date'] = now
                    songSchema['name'] = `${songsMetadata[index].title}`
                    songSchema['album'] = albumUrl
                    songSchema['description'] = `${songsMetadata[index].description}`
                    songSchema['song_url'] = songUrl

                    let metaObj = await module.exports.uploadJSONToPinata(songSchema, songsMetadata[index].title + '- Info', {})

                    let metdataUrl = `${ipfsGateway}/ipfs/${metaObj.IpfsHash}`
                    // mint token with song url
                    try {
                        await del.sync([`${path.resolve()}/${file.path}`])

                        const song = await Song.query().insert({
                            cid: metaObj.IpfsHash,
                            title: songsMetadata[index].title,
                            user_id: user.id,
                            released_year: new Date(),
                            lyricist: songBody.lyricist,
                            genre: songBody.genre,
                            singer: songBody.singer,
                            song_cid: file.hash,
                            album_id: album.id,
                            current_owner: user_id,
                            qty,
                            available_qty: qty
                        })

                        // await Song.query().patchAndFetchById(song.id, {
                        //     txn_hash: txnHash
                        // })
                        return {
                            owner: user.near_account_id,
                            medadata: metdataUrl,
                            ...song,
                            // txn_hash: txnHash
                        }
                    } catch (e) {
                        console.log(e)
                        // since minting fails, delete album record
                        console.log(album, 'adsfdf')
                        await Album.query().patchAndFetchById(album.id, { is_deleted: true })
                        throw {
                            message: JSON.parse(e.message).kind.ExecutionError
                        }
                    }

                }))

                let songsHashes = results.map(r => r.song_cid)
                // add album cover as NFT
                songsHashes.push(album.cover_cid)
                const albumSchema = {}
                albumSchema['title'] = `${album.title}`
                albumSchema['media'] = albumUrl
                albumSchema['copies'] = album.qty
                // albumSchema['issued_at'] = now
                albumSchema['description'] = `${album.description}`
                albumSchema['songs'] = results.map(r => ({ title: r.title, url: `${ipfsGateway}/ipfs/${r.song_cid}` }))
                try {
                    const txnHash = await processMinting(album.cover_cid, songsHashes, parseInt(qty), album.yocto_near_price, user.near_account_id,)
                    await Album.query().patchAndFetchById(album.id, {
                        txn_hash: txnHash,
                    })
                    return {
                        results
                    }
                } catch (e) {
                    console.log(JSON.parse(e.message))
                    // since minting fails, delete album record
                    await Album.query().patchAndFetchById(album.id, { is_deleted: true })
                    throw {
                        message: JSON.parse(e.message).kind.ExecutionError
                    }
                }

            })
        return uploadedSongs
    },
}

'''
'''--- app/controllers/UserNFT.js ---
let { User, Album, Song, Transfer } = require('../models'),
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    { getTokenOwner } = require('../lib/near'),
    { ipfsGateway, uploadJSONToPinata } = require('./Upload')
const { getNearPriceInUSD } = require('../lib/near')
const { utils: { format: { parseNearAmount } } } = require('near-api-js')

module.exports = {
    async getUserNFTs(id, query) {
        let mapped = []
        if (query.type === 'album') {
            let relations = 'currentOwner,songs'
            if (query.showcase) {
                relations = relations.replace('currentOwner', 'currentOwner.showcases')
            }
            const userOwnedAlbums = await Album.query().where({ is_deleted: false, current_owner: id }).eager(`[${relations}]`)
            let mappedAlbums = userOwnedAlbums.map(m => ({ ...m, type: 'album' }))
            mapped = [...mappedAlbums]
        } else if (query.type === 'song') {
            let relations = 'currentOwner,album'
            if (query.showcase) {
                relations = relations.replace('currentOwner', 'currentOwner.showcases')
            }
            const userOwnedSongs = await Song.query().where({ is_deleted: false, current_owner: id }).eager(`[${relations}]`)
            let mappedSongs = userOwnedSongs.map(m => ({ ...m, type: 'song' }))
            mapped = [...mappedSongs]
        } else {
            let relations1 = 'currentOwner,album'
            let relations2 = 'currentOwner,songs'
            if (query.showcase) {
                relations1 = relations1.replace('currentOwner', 'currentOwner.showcases')
                relations2 = relations2.replace('currentOwner', 'currentOwner.showcases')
            }
            const userOwnedSongs = await Song.query().where({ is_deleted: false, current_owner: id }).eager(`[${relations1}]`)
            const userOwnedAlbums = await Album.query().where({ is_deleted: false, current_owner: id }).eager(`[${relations2}]`)
            let mappedAlbums = userOwnedAlbums.map(m => ({ ...m, type: 'album' }))
            let mappedSongs = userOwnedSongs.map(m => ({ ...m, type: 'song' }))
            mapped = [...mappedAlbums, ...mappedSongs]
        }
        let total = mapped.length
        return {
            results: mapped,
            total
        }
    },
    async getUserByIdNFTs(id, query) {
        let mapped = []
        if (query.type === 'album') {
            const userOwnedAlbums = await Album.query().where({ is_deleted: false, current_owner: id })
            let mappedAlbums = userOwnedAlbums.map(m => ({ ...m, type: 'album' }))
            mapped = [...mappedAlbums]
        } else if (query.type === 'song') {
            const userOwnedSongs = await Song.query().where({ is_deleted: false, current_owner: id })
            let mappedSongs = userOwnedSongs.map(m => ({ ...m, type: 'song' }))
            mapped = [...mappedSongs]
        } else {
            const userOwnedSongs = await Song.query().where({ is_deleted: false, current_owner: id })
            const userOwnedAlbums = await Album.query().where({ is_deleted: false, current_owner: id })
            let mappedAlbums = userOwnedAlbums.map(m => ({ ...m, type: 'album' }))
            let mappedSongs = userOwnedSongs.map(m => ({ ...m, type: 'song' }))
            mapped = [...mappedAlbums, ...mappedSongs]
        }
        let total = mapped.length
        return {
            results: mapped,
            total
        }
    },
    async getNFTOwner(token, user) {
        let transactionHash = await getTokenOwner(user.near_account_id, token)
        return {
            ...transactionHash,
        }
    },
    async mintToken(body, user) {
        const mint = await transaction(
            Album,
            Song,
            async (Album, Song) => {
                let albumUrl = `${ipfsGateway}/ipfs/${body.cover}`
                // upload metadata for the song
                const albumSchema = {}
                albumSchema['name'] = `${body.title}`
                albumSchema['cover'] = albumUrl
                albumSchema['description'] = `${body.description}`
                let metaObj = await uploadJSONToPinata(albumSchema, body.name + '- Info', {})

                let { USD } = await getNearPriceInUSD()
                let nearPrice = parseInt(body.price / 100) / USD
                let price = parseNearAmount(`${nearPrice}`)

                const album = await Album.query().insert({
                    cid: metaObj.IpfsHash,
                    title: body.title,
                    description: body.description,
                    cover_cid: body.cover,
                    user_id: user.id,
                    current_owner: user.id,
                    price: body.price,
                    has_copy: true,
                    txn_hash: body.txn_hash,
                    qty: body.qty,
                    available_qty: body.qty,
                    yocto_near_price: price,
                    minting_cost: (0.1 * USD).toFixed(2) * 100
                })
                // upload metadata for the song
                let songIpfs = await Promise.all(body.songs.map(song => {
                    let songUrl = `${ipfsGateway}/ipfs/${song.hash}`
                    const songSchema = {}
                    const now = new Date().getTime()
                    songSchema['date'] = now
                    songSchema['name'] = song.title
                    songSchema['album'] = albumUrl
                    songSchema['song_url'] = songUrl
                    return uploadJSONToPinata(songSchema, song.title + '- Info', {})
                }))
                // mint token with song url
                const song = await Promise.all(body.songs.map((s, i) => Song.query().insert({
                    title: s.title,
                    song_cid: s.hash,
                    cid: songIpfs[i].IpfsHash,
                    txn_hash: body.txn_hash,
                    user_id: user.id,
                    current_owner: user.id,
                    available_qty: body.qty,
                    qty: body.qty,
                    has_copy: true,
                    album_id: album.id
                })
                ))
                return body
            })
        return mint
    }
}

'''
'''--- app/controllers/Users.js ---
let User = require('../models').User,
    { transaction } = require('objection'),
    { filterer } = require('../lib/filters'),
    _ = require('lodash'),
    jsonwebtoken = require('jsonwebtoken')
module.exports = {
    async getUsers(query = {}, pageNumber = 0, perPage = 20) {
        return {
            ...await filterer(query, User, {
                pageNumber,
                perPage,
                related: query.related,
                orderBy: query.orderBy || 'id',
                search: query.search
            }),
            page: pageNumber,
            per_page: perPage
        }

    },

    async getUser(id, query) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }

        let theUser = await User.query().findById(id).eager(query.related)

        if (!theUser) {
            throw {
                message: 'User Not Found',
                statusCode: 404
            }
        }

        return _.pick(theUser, ['id', 'name', 'avatar', 'banner', 'type'])
    },

    async createUser(userBody,) {
        const user = await transaction(
            User,
            async (User) => {
                var newUser = await User.query().insert({
                    ...userBody
                })

                return newUser
            }
        )

        return user

    },

    async editUser(id, newBody) {
        if (!id) {
            throw {
                message: 'ID Not Provided',
                statusCode: 400
            }
        }
        if (newBody.id) {
            delete newBody.id
        }
        let editedUser = await User.query().patchAndFetchById(id, { ...newBody })
        let token = jsonwebtoken.sign({
            id: editedUser.id,
            twitter_id: editedUser.twitter_id,
            username: editedUser.username,
            name: editedUser.name,
            avatar: editedUser.avatar,
            banner: editedUser.banner,
            near_connected: editedUser.connected_to_near,
            near_account_id: editedUser.near_account_id,
            type: editedUser.type,
        },
            process.env.JWT_SECRET_KEY,
        )
        if (!editedUser) {
            throw {
                message: 'User Not Found',
                statusCode: 404
            }
        }
        editedUser.token = token
        return editedUser
    },

    async deleteUser(id) {

        if (!id) {
            throw {
                message: 'No ID Provided',
                statusCode: 400
            }
        }

        let deletedCount = await User.query().patchAndFetchById(id, { is_deleted: true })
        await Promise.all(
            Object.keys(User.getRelations()).map((relation) => {
                return deletedCount.$relatedQuery(relation).unrelate()
            })
        )

        if (deletedCount < 1) {
            throw {
                message: 'User Not Found',
                statusCode: 404
            }
        }

        return deletedCount

    }

}

'''
'''--- app/lib/cron.js ---
const { Nomination } = require('../models'),
    moment = require('moment')

module.exports = {
    clearNominationQueue: async function () {
        //since this runs on first of each month, we have to consider the last month to clear
        let prevMonth = moment().startOf('month').subtract(1, 'days').startOf('month')
        await Nomination.query().patch({ is_in_queue: false }).where({ for_month: prevMonth })
    }
}
'''
'''--- app/lib/db.js ---
var objection = require('objection'),
    Model = objection.Model

let knexfile = require('../../knexfile')[process.env.NODE_ENV || 'development'],
    knex = require('knex')(knexfile)
Model.knex(knex)

module.exports = Model
'''
'''--- app/lib/external-services.js ---
const
  fs = require('fs'),
  path = require('path'),
  Handlebars = require('handlebars'),
  axios = require('axios')

module.exports = {
  sendMail(emailTemplate, email, subject, emailVars) {
    return new Promise((resolve, reject) => {
      fs.readFile(`${path.join(__dirname, '../emails')}/${emailTemplate}.html`, 'utf8', (err, data) => {
        if (err) return reject(err)
        // emailVars.url = process.env.SITE_FRONT
        var templateBody = data
        templateBody = Handlebars.compile(templateBody)
        templateBody = templateBody(emailVars)
        fs.readFile(`${path.join(__dirname, '../emails')}/emailBase.html`, 'utf8', (err, data) => {
          if (err) return reject(err)
          var email_body = data
          email_body = Handlebars.compile(email_body)
          email_body = email_body({ content: templateBody })
          // mailgun.messages().send({
          //   from: `${process.env.BUSINESS_NAME}<${process.env.NO_REPLY_ADDRESS}>`,
          //   to: email,
          //   subject: subject,
          //   html: email_body
          // }, (err, result) => {
          //   if (err) return reject(err)
          //   resolve(result)
          // })
        })
      })
    })
  }
}
'''
'''--- app/lib/filters.js ---
const { transaction } = require('objection'),
  _ = require('lodash')

exports.filterer = async function (query, Model, operations) {
  //  console.log(query)
  const order = await transaction(Model, async (Model) => {
    let filter = _.isPlainObject(query.filter) ? query.filter : {}
    query.filter = filter

    let preparedFetch = Model.query().skipUndefined().alias('model')
    let comparison_keys = { 'eq': '=', 'like': 'ILIKE', 'not': '<>', 'lt': '<', 'lte': '<=', 'gt': '>', 'gte': '>=', 'in': 'in' }

    /* To get notification filterd by user_id */
    if (Model.name === 'Notification' && query.filter.hasOwnProperty('user')) {
      preparedFetch.joinRelation('users')
        .where('users.id', query.filter.user);
      delete query.filter.user
    }

    // _.mapKeys(query.filter, (value, key) => {
    //   let comp = (query.operand) ? comparison_keys[query.operand[key]] || '=' : '='
    //   preparedFetch.where(key, comp, value)
    // })

    if (query.hasOwnProperty('filterRelated')) {
      let relateItem = Object.keys(query.filterRelated)[0]
      let relateItemArray = relateItem.split('.')
      preparedFetch.joinRelation(relateItemArray[0], { alias: 'table' })
        .where(`table.${relateItemArray[1]}`, relateItemArray[2] || '=', query.filterRelated[relateItem])
    }
    let filters = Object.entries(query.filter)

    filters.forEach(([key, value]) => {
      let comp = (query.operand) ? comparison_keys[query.operand[key]] || '=' : '='
      let values
      if (value === true || value === false) {
        values = [value]
      }
      else
        values = value.split(',')
      if (values.length === 1)
        preparedFetch.where(`model.${key}`, comp, value)
      else {
        values.forEach((value, index) => {
          if (index === 0)
            preparedFetch.where(`model.${key}`, comp, value)
          else
            preparedFetch.orWhere(`model.${key}`, comp, value)
        })
      }
    })
    filters.shift()

    filters.forEach(([key, value]) => {
      let comp = (query.operand) ? comparison_keys[query.operand[key]] || '=' : '='
      let values
      if (value === true || value === false) {
        values = [value]
      }
      else
        values = value.split(',')
      if (values.length === 1)
        preparedFetch.andWhere(`model.${key}`, comp, value)
      else {
        values.forEach((value, index) => {
          if (index === 0)
            preparedFetch.andWhere(`model.${key}`, comp, value)
          else
            preparedFetch.andWhere(`model.${key}`, comp, value)
        })
      }
    })
    if (operations.search && typeof (Model.getSearchable) === 'function') {
      let fields = Model.getSearchable()
      preparedFetch.where(qb => {
        for (let i = 0; i < fields.length; i++) {
          if (i === 0) {
            qb.where(`model.${fields[i]}`, 'ILIKE', `%${operations.search}%`)
          } else {
            qb.orWhere(`model.${fields[i]}`, 'ILIKE', `%${operations.search}%`)
          }
        }
        if (query.searchRelated && typeof (Model.getRelatedSearchable) === 'function') {
          let f1 = Model.getRelatedSearchable()
          let related = Object.keys(query.searchRelated)
          let search = Object.values(query.searchRelated)[0]
          related.forEach((r, index) => {
            qb.leftOuterJoinRelation(r, { alias: `searchTable${index}` }).orWhere(qb1 => {
              for (let i = 0; i < f1.length; i++) {
                qb1.orWhere(`searchTable${index}.${f1[i]}`, 'ILIKE', `%${search}%`)
              }
            })
          })
        }
      })
    }

    if (query.searchRelated && typeof (Model.getRelatedSearchable) === 'function') {
      let related = Object.keys(query.searchRelated)
      related.forEach((r, i) => {
        preparedFetch.leftOuterJoinRelation(r, { alias: `searchTable${i}` })
      })
    }

    if (operations.match && typeof (Model.getSearchable) === 'function') {
      let fields = Model.getSearchable()
      preparedFetch.where(qb => {
        for (let i = 0; i < fields.length; i++) {
          if (i === 0) {
            qb.where(`model.${fields[i]}`, 'ILIKE', `%${operations.match}%`)
          } else {
            qb.orWhere(`model.${fields[i]}`, 'ILIKE', `%${operations.match}%`)
          }
        }
      })
    }

    if (query.hasOwnProperty('filter') && query.filter.hasOwnProperty('is_deleted')) {
      if (query.filter.is_deleted === 'true') {
        preparedFetch.where(`model.is_deleted`, '=', true)
      }
      else
        preparedFetch.where(`model.is_deleted`, '=', false)
    }
    else {
      preparedFetch.where(`model.is_deleted`, '=', false)
    }

    if (query.first_name) {
      preparedFetch.where(qb => {
        qb.where('model.first_name', 'ILIKE', `%${query.first_name}%`)
      })
    }

    if (query.last_name) {
      preparedFetch.where(qb => {
        qb.where('model.last_name', 'ILIKE', `%${query.last_name}%`)
      })
    }
    if (query.name) {
      let names = query.name.split(' ')
      preparedFetch.where(qb => {
        for (let i = 0; i < names.length; i++) {
          if (i === 0) {
            qb.where('model.first_name', 'ILIKE', `%${names[i]}%`)
            qb.orWhere('model.last_name', 'ILIKE', `%${names[i]}%`)
          } else {
            qb.andWhere('model.last_name', 'ILIKE', `%${names[i]}%`)
          }
        }
      })
    }

    if (query.last_four_of_social) {
      preparedFetch.where(qb => {
        qb.where('model.last_four_of_social', 'ILIKE', `%${query.last_four_of_social}%`)
      })
    }

    if (query.related) {
      if (operations.orderBy && operations.orderBy.indexOf('.') > -1) {
        if (operations.orderBy.charAt(0) === '-') {
          preparedFetch.joinRelation(operations.orderBy.substring(1, operations.orderBy.indexOf('.')))
        } else {
          preparedFetch.joinRelation(operations.orderBy.substring(0, operations.orderBy.indexOf('.')))
        }
      }
      preparedFetch.eager(query.related)
    }

    if (operations.orderBy) {
      let orderBy = operations.orderBy
      if (orderBy.charAt(0) === '-') {
        orderBy = orderBy.substr(1)
        preparedFetch.orderBy(orderBy || 'id', 'desc')
      } else {
        preparedFetch.orderBy(orderBy || 'id')
      }
    }

    if (operations.pageNumber, operations.perPage) {
      preparedFetch.page(operations.pageNumber, operations.perPage)
    }

    if (operations.count) {
      preparedFetch.count('*')
    }

    return await preparedFetch
  })

  return order
}
'''
'''--- app/lib/helper.js ---
const _ = require('lodash'),
    joi = require('joi')

module.exports = {
    checkPermissions(neededPerms, userPerms) {
        if (userPerms[neededPerms] === true) {
            return true
        } else {
            throw {
                message: `You do not have ${neededPerms} rights.`,
                statusCode: 401
            }
        }
    },

    trimmer: function (object) {
        for (let key in object) {
            if (typeof myVar === 'string' || object[key] instanceof String) {
                object[key] = object[key].trim()
            }
        }
        return object
    },

    queryBuilder(query, model, attributes, relatedModels = false) {
        query.filter = cleanObject(query.filter)
        return this._queryHelper(
            query,
            attributes ? attributes : model.getAttributes(),
            relatedModels ? relatedModels : model.getRelatedModels())
    },

    _queryHelper(query, attributes, relatedAttributes = []) {
        attributes.push('id')
        let filter = _.isPlainObject(query.filter) ? query.filter : {}
        filter = _.pick(filter, attributes)

        let page = _.isPlainObject(query.page) ? query.page : {}
        page = Object.assign({ number: 1, size: 20 }, _.pick(page, ['number', 'size']))

        if (page.number < 1) {
            page.number = 1
        }
        if (page.size < 1) {
            page.size = 20
        }

        let sort = []
        if (query.sort) {
            query.sort.split(',').forEach(field => {
                let direction = 'ASC'
                if (field.length > 0 && field[0] == '-') {
                    direction = 'DESC'
                    field = field.substr(1)
                }
                if (attributes.indexOf(field) > -1) {
                    sort.push({ field, direction })
                }
            })
        }
        if (sort.length == 0) {
            sort.push({ field: 'created_at', direction: 'DESC' })
        }

        let include = []
        if (query.include) {
            include = query.include.split(',')
        }
        if (relatedAttributes) {
            include = _.intersection(include, relatedAttributes)
        }

        return {
            filter,
            page,
            sort,
            include
        }
    },

    paginate(query, Model, withRelated, whereArr = [], searchTerm = null, arrayOfIds = [], rawQuery) {
        let comparison_keys = { 'eq': '=', 'like': 'ILIKE', 'not': '<>', 'lt': '<', 'lte': '<=', 'gt': '>', 'gte': '>=', 'in': 'in' }
        let preparedFetch = Model.forge()
        if (rawQuery) {
            if (rawQuery.query && rawQuery.where) {
                if (rawQuery.query.constructor === Array && rawQuery.where.constructor === Array) {
                    preparedFetch.query(...rawQuery.query).where(...rawQuery.where)
                }
            }
        }

        _.mapKeys(query.filter, (value, key) => {
            if (_.isPlainObject(value)) {
                _.mapKeys(value, (plainValue, comp) => {
                    if (!_.isUndefined(comparison_keys[comp])) {
                        if (comp == 'in') {
                            if (_.isString(plainValue)) {
                                plainValue = plainValue.split(',')
                            }
                        }
                        whereArr.push({ attr: key, comp: comparison_keys[comp], value: plainValue })
                    }
                })
                delete query.filter[key]
            }
        })

        preparedFetch.where(query.filter)

        whereArr.forEach((where) => {
            preparedFetch.where(where.attr, where.comp, tryParseDate(where.value))
        })

        if (searchTerm && typeof Model.getSearchable === 'function') {
            preparedFetch.where(function () {
                Model.getSearchable(this, searchTerm)
            })
        }

        if (arrayOfIds.length > 0) {
            preparedFetch.where(function () {
                this.where('id', 'IN', arrayOfIds)
            })
        }

        query.sort.forEach(sortItem => {
            preparedFetch.orderBy(sortItem.field, sortItem.direction)
        })

        if (withRelated) {
            withRelated = withRelated.filter(relation => Model.getRelatedModels().indexOf(relation) > -1)
        }

        return preparedFetch.fetchPage({
            page: query.page.number,
            pageSize: query.page.size,
            withRelated: withRelated ? withRelated : query.include
        })
    },

    indexResponse(data, pickAttr) {
        return {
            total: data.pagination.rowCount,
            limit: data.pagination.pageSize,
            skip: data.pagination.pageSize * data.pagination.page - data.pagination.pageSize,
            data: (Array.isArray(pickAttr)) ? data.toJSON().map(item => _.pick(item, pickAttr)) : data
        }
    },
    validateData(data, schema, options = {}) {
        return new Promise(async (resolve, reject) => {
            options.abortEarly = false
            try {
                var result = await joi.validate(data, schema, options)
            } catch (error) {
                console.error(error)
                reject(error)
            }
            resolve(result)
        })
    },
    formatStringValue: (value = '', delimiter = '_') => {
        let values = value.split(delimiter)
        let result = ''
        values.forEach(each => {
            result += `${each} `
        })
        return result.trim()
    }
}

function tryParseDate(date) {
    if (/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/.test(date)) {
        return new Date(Date.parse(date))
    } else {
        return date
    }
}

function cleanObject(object) {
    for (var key in object) {
        if (object[key] === null || object[key] === undefined || object[key] === '') {
            delete object[key]
        }
    }
    return object
}
'''
'''--- app/lib/near.js ---

const { keyStores, KeyPair, connect, Contract, transactions, utils: { format: { parseNearAmount } }, } = require('near-api-js'),
    { User, Album } = require('../models'),
    jsonwebtoken = require('jsonwebtoken')
const path = require("path");
// Load NEAR Javascript API components
const near = require("near-api-js");
const _ = require('lodash');
const axios = require('axios')
const bs58 = require('bs58')

const getNearConfig = async (accountIds) => {
    let keyStore, publicKey
    const keyPair = KeyPair.fromString(process.env.PRIVATE_KEY);

    // Setup default client options
    keyStore = new keyStores.InMemoryKeyStore();
    // adds the keyPair you created to keyStore
    await Promise.all(accountIds.map(accountId => keyStore.setKey(process.env.NEAR_NETWORK, accountId, keyPair)))
    publicKey = keyPair.getPublicKey()

    const options = {
        networkId: process.env.NEAR_NETWORK,
        nodeUrl: process.env.NEAR_NODE_URL,
        walletUrl: `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
        helperUrl: `https://helper.${process.env.NEAR_NETWORK}.near.org`,
        explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
        accountId: process.env.OWNER_NEAR_ACCOUNT,
        keyStore: keyStore,
        publicKey: publicKey.toString()
    }
    return options
}

module.exports = {
    getNearConfig,
    getSale: async function (tokenId, copy) {
        try {
            let nearConfig = await module.exports.getNearConfig([process.env.NEAR_CONTRACT_ACCOUNT])
            // Configure the client with nearConfig and our local key store
            const client = await connect(nearConfig);
            const account = await client.account(process.env.NEAR_CONTRACT_ACCOUNT)
            const DELIMETER = '||';
            const sale = await account.viewFunction(process.env.NEAR_MARKET_ACCOUNT,
                'get_sale',
                { nft_contract_token: process.env.NEAR_CONTRACT_ACCOUNT + DELIMETER + tokenId + `:${copy}` }
            );
            return sale
        } catch (e) {
            console.log(e)
            throw {
                message: e.message
            }
        }
    },
    onBuyAlbumTokens: async function (tokenId, copy, buyerId, price) {
        try {
            let result = await module.exports.buyAlbumNftAsBundle(tokenId, buyerId, copy, price);
            return result.transaction.hash
        } catch (e) {
            console.log(e)
            throw {
                message: e.message
            }
        }
    },
    unlockToken: async function (tokenId, ownerId) {
        try {
            let nearConfig = await module.exports.getNearConfig([process.env.NEAR_CONTRACT_ACCOUNT, ownerId])
            // Configure the client with nearConfig and our local key store
            const client = await connect(nearConfig);
            const ownerAccount = await client.account(ownerId);
            let result = await module.exports.unlock_album_copy_token_type(ownerAccount, tokenId)
            return result.transaction.hash
        } catch (e) {
            console.log(e)
            throw {
                message: e.message
            }
        }
    },
    async getNearPriceInUSD() {
        try {
            const price = await axios.get(`https://min-api.cryptocompare.com/data/price?fsym=NEAR&tsyms=NEAR,USD`)
            return price.data
        } catch (e) {
            console.error(e)
            throw {
                message: 'Erro while fetching USD to NEAR'
            }
        }
    },
    async getTokenOwner(account, token) {
        let nearConfig = await module.exports.getNearConfig([process.env.NEAR_CONTRACT_ACCOUNT, account])
        // Configure the client with nearConfig and our local key store
        const client = await connect(nearConfig);
        const Account = await client.account(account);
        const result = await Account.functionCall(
            process.env.NEAR_CONTRACT_ACCOUNT,
            "nft_token",
            { token_id: token }

        )
        const jsjd = Buffer.from(result.status.SuccessValue, 'base64').toString('utf-8');
        const obj = JSON.parse(jsjd);
        return obj
    },
    async processMinting(albumHash, songsHashes, qty, price, owner_account) {
        try {
            let nearConfig = await module.exports.getNearConfig([owner_account])
            // Configure the client with nearConfig and our local key store
            const client = await connect(nearConfig);
            const OwnerAccount = await client.account(owner_account)
            let result = await OwnerAccount.functionCall(
                process.env.NEAR_CONTRACT_ACCOUNT,
                'add_token_types',
                {
                    album_hash: albumHash,
                    cover_songslist: songsHashes,
                    number_of_album_copies: qty,
                    price,
                },
                200000000000000,
                parseNearAmount('0.1'),
            )
            return result.transaction.hash
        } catch (error) {
            console.log(error)
            if (error.type === 'Expired') {
                await module.exports.processMinting(albumHash, songsHashes, qty, price, owner_account)
                return
            }
            throw {
                message: error.message,
            }
        }
    },
    async buyAlbumNftAsBundle(albumHash, buyer, copy_no, price) {
        console.log(`${albumHash}:${copy_no}`)
        let nearConfig = await module.exports.getNearConfig([buyer])
        // Configure the client with nearConfig and our local key store
        const client = await connect(nearConfig);
        const buyerAccount = await client.account(buyer)
        try {
            let result = await buyerAccount.functionCall(
                process.env.NEAR_MARKET_ACCOUNT,
                "offer_album",
                {
                    nft_contract_id: process.env.NEAR_CONTRACT_ACCOUNT,
                    albumipfs_hash_copy: `${albumHash}:${copy_no}`,
                },
                300000000000000,
                price,
            )
            return result
        } catch (error) {
            console.log({ error })
            if (error.type === 'Expired') {
                await module.exports.buyAlbumNftAsBundle(albumHash, buyer, copy_no, price)
                return
            }
            throw {
                message: error.message,
            }
        }
    },
    async putNFTForSelling(account_which_bought_the_album, songtokenid, nearPrice) {
        try {
            let nearConfig = await module.exports.getNearConfig([account_which_bought_the_album])
            // Configure the client with nearConfig and our local key store
            const client = await connect(nearConfig);
            const sellerAccount = await client.account(account_which_bought_the_album)
            const price = parseNearAmount(`${nearPrice}`);
            result = await sellerAccount.functionCall(
                process.env.NEAR_CONTRACT_ACCOUNT,
                'nft_approve',
                {
                    token_id: songtokenid,
                    account_id: process.env.NEAR_MARKET_ACCOUNT,
                    price,
                },
                300000000000000,
                parseNearAmount('0.01')
            );
            return result.transaction.hash
        } catch (error) {
            console.log({ error })
            throw {
                message: error.message,
            }
        }
    },
    async buyNFTToken(anotheraccount, price, songtokenid) {
        let nearConfig = await module.exports.getNearConfig([anotheraccount])
        // Configure the client with nearConfig and our local key store
        const client = await connect(nearConfig);
        const buyerAccount = await client.account(anotheraccount)
        try {
            result = await buyerAccount.functionCall(
                process.env.NEAR_MARKET_ACCOUNT,
                "offer",
                {
                    nft_contract_id: process.env.NEAR_CONTRACT_ACCOUNT,
                    receiver_id: buyerAccount.accountId,
                    song_token_id: songtokenid
                },
                300000000000000,
                price
            )
            return result.transaction.hash;
        } catch (error) {
            console.log(error.type)
            if (error.type == 'Expired') {
                console.log('HERE')
                await module.exports.buyNFTToken(anotheraccount, price, songtokenid)
                return
            }
            throw {
                message: error.message,
            }
        }
    }
}

'''
'''--- app/lib/passport.js ---
const passport = require('passport')
const TwitterStrategy = require('passport-twitter'),
    { User } = require('../models'),
    jsonwebtoken = require('jsonwebtoken')

passport.use(new TwitterStrategy({
    consumerKey: process.env.TWITTER_CONSUMER_KEY,
    consumerSecret: process.env.TWITTER_CONSUMER_SECRET,
    callbackURL: `${process.env.TWITTER_OAUTH_URL}/auth/twitter/callback`
},
    async function (token, tokenSecret, profile, cb) {
        console.log(profile, 'profile')
        let user = await User.query().findOne({ twitter_id: profile.id, is_deleted: false })
        if (!user) {
            let u = await User.query().insert({
                twitter_id: profile.id,
                name: profile.displayName,
                username: profile.username,
                avatar: profile._json.profile_image_url && profile._json.profile_image_url.replace('normal', '400x400'),
                banner: profile._json.profile_banner_url
            });
            profile.user_id = u.id
        } else {
            if (user.avatar !== (profile._json.profile_image_url && profile._json.profile_image_url.replace('normal', '400x400'))) {
                await User.query().patchAndFetchById(user.id, {
                    avatar: profile._json.profile_image_url && profile._json.profile_image_url.replace('normal', '400x400'),
                });
            }
            profile.near_connected = user.connected_to_near || false
            profile.near_account_id = user.near_account_id || null
            profile.user_id = user.id
            profile.type = user.type
            profile.profile_banner_url = user.banner
        }
        return cb(null, profile);
    }
));

module.exports = passport
'''
'''--- app/models/Album.js ---
var Model = require('../lib/db')

class Album extends Model {
  static get tableName() {
    return 'albums'
  }

  static get relationMappings() {
    return {
      songs: {
        relation: Model.HasManyRelation,
        modelClass: 'Song',
        join: {
          to: 'songs.album_id',
          from: 'albums.id'
        }
      },
      transfers: {
        relation: Model.HasManyRelation,
        modelClass: 'Transfer',
        join: {
          to: 'transfers.token',
          from: 'albums.cover_cid'
        }
      },
      currentOwner: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'albums.current_owner',
          to: 'users.id'
        }
      },
      user: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'albums.user_id',
          to: 'users.id'
        }
      },
    }
  }
  safeValues({ user_id }) {
    return {
      id: this.id,
      title: this.title,
      cover_cid: this.cover_cid,
      qty: parseInt(this.qty) || 0,
      available_qty: this.available_qty,
      price: this.price,
      user: this.user,
      songs: this.songs && this.songs.map(s => s.safeValues({})),
      mints_owned: (this.transfers || []).filter(t => t.is_owner && t.transfer_to === user_id).map(t => t.copy_number)
    }
  }
  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Album

'''
'''--- app/models/Follower.js ---
var Model = require('../lib/db')

class Follower extends Model {
  static get tableName() {
    return 'followers'
  }

  static get relationMappings() {
    return {
      artist: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'followers.artist_id',
          to: 'users.id'
        }
      },
      follower: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'followers.follower_id',
          to: 'users.id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Follower

'''
'''--- app/models/Nomination.js ---
var Model = require('../lib/db')

class Nomination extends Model {
  static get tableName() {
    return 'nominations'
  }

  static get relationMappings() {
    return {
      votedFor: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'nominations.nominee',
          to: 'users.id'
        }
      },
      votedBy: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'nominations.nominated_by',
          to: 'users.id'
        }
      },
      votes: {
        relation: Model.HasManyRelation,
        modelClass: 'NominationVote',
        join: {
          from: 'nominations.id',
          to: 'nomination_votes.nomination_id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Nomination

'''
'''--- app/models/NominationVote.js ---
var Model = require('../lib/db')

class Nomination extends Model {
  static get tableName() {
    return 'nomination_votes'
  }

  static get relationMappings() {
    return {
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Nomination

'''
'''--- app/models/Playlist.js ---
var Model = require('../lib/db')

class Playlist extends Model {
  static get tableName() {
    return 'playlists'
  }

  static get relationMappings() {
    return {
      songs: {
        relation: Model.ManyToManyRelation,
        modelClass: 'Song',
        join: {
          from: 'playlists.id',
          through: {
            from: 'playlists_songs.playlist_id',
            to: 'playlists_songs.song_id'
          },
          to: 'songs.id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Playlist

'''
'''--- app/models/PlaylistsSong.js ---
var Model = require('../lib/db')

class PlaylistsSong extends Model {
  static get tableName() {
    return 'playlists_songs'
  }

  static get relationMappings() {
    return {
      song: {
        relation: Model.HasOneRelation,
        modelClass: 'Song',
        join: {
          from: 'playlists_songs.song_id',
          to: 'songs.id'
        }
      },
      playlist: {
        relation: Model.HasOneRelation,
        modelClass: 'Playlist',
        join: {
          from: 'playlists_songs.playlist_id',
          to: 'playlists.id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = PlaylistsSong

'''
'''--- app/models/Showcase.js ---
var Model = require('../lib/db')

class Showcase extends Model {
  static get tableName() {
    return 'showcases'
  }

  static get relationMappings() {
    return {
      album: {
        relation: Model.HasOneRelation,
        modelClass: 'Album',
        join: {
          from: 'showcases.album_id',
          to: 'albums.id'
        }
      },
      user: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'showcases.user_id',
          to: 'users.id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Showcase

'''
'''--- app/models/Song.js ---
var Model = require('../lib/db')

class Song extends Model {
  static get tableName() {
    return 'songs'
  }

  static get relationMappings() {
    return {
      album: {
        relation: Model.BelongsToOneRelation,
        modelClass: 'Album',
        join: {
          from: 'songs.album_id',
          to: 'albums.id'
        }
      },
      playlists: {
        relation: Model.ManyToManyRelation,
        modelClass: 'Playlist',
        join: {
          from: 'songs.id',
          through: {
            from: 'playlists_songs.song_id',
            to: 'playlists_songs.playlist_id'
          },
          to: 'playlists.id'
        }
      },
      artist: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'songs.user_id',
          to: 'users.id'
        }
      },
      currentOwner: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'songs.current_owner',
          to: 'users.id'
        }
      },
      transfers: {
        relation: Model.HasManyRelation,
        modelClass: 'Transfer',
        join: {
          to: 'transfers.token',
          from: 'songs.song_cid'
        }
      },
    }
  }
  safeValues({ user_id, is_for_sale }) {
    return {
      id: this.id,
      title: this.title,
      song_cid: this.song_cid,
      album: this.album && this.album.safeValues({}),
      artist: this.artist && this.artist.safeValues({}),
      available_qty: this.available_qty,
      qty: parseInt(this.qty) || 0,
      transfers: (this.transfers || []).map(t => t.safeValues({})).filter(f => is_for_sale ? f.is_for_sale : is_for_sale === false ? !f.is_for_sale : true),
      mints_owned: (this.transfers || []).filter(t => t.is_owner && t.transfer_to === user_id).map(t => t.copy_number)
    }
  }
  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Song

'''
'''--- app/models/Transfer.js ---
var Model = require('../lib/db')

class Transfer extends Model {
  static get tableName() {
    return 'transfers'
  }

  static get relationMappings() {
    return {
      transferBy: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'transfers.transfer_by',
          to: 'users.id'
        }
      },
      transferTo: {
        relation: Model.HasOneRelation,
        modelClass: 'User',
        join: {
          from: 'transfers.transfer_to',
          to: 'users.id'
        }
      },
      album: {
        relation: Model.HasOneRelation,
        modelClass: 'Album',
        join: {
          from: 'transfers.token',
          to: 'albums.cover_cid'
        }
      },
      song: {
        relation: Model.HasOneRelation,
        modelClass: 'Song',
        join: {
          from: 'transfers.token',
          to: 'songs.song_cid'
        }
      },
    }
  }
  safeValues({ }) {
    return {
      id: this.id,
      created_at: this.created_at,
      song: this.song && this.song.safeValues({}),
      album: this.album && this.album.safeValues({}),
      artist: this.artist && this.artist.safeValues({}),
      transferTo: this.transferTo && this.transferTo.safeValues({}),
      copy_number: this.copy_number,
      bidding_price: this.bidding_price,
      available_qty: this.available_qty,
      is_for_sale: this.is_for_sale,
      transaction_hash: this.transaction_hash
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
    ]
  }

  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = Transfer

'''
'''--- app/models/User.js ---
var Model = require('../lib/db')

class User extends Model {
  static get tableName() {
    return 'users'
  }

  static get relationMappings() {
    return {
      showcases: {
        relation: Model.HasManyRelation,
        modelClass: 'Showcase',
        join: {
          from: 'users.id',
          to: 'showcases.user_id'
        }
      },
      songs: {
        relation: Model.HasManyRelation,
        modelClass: 'Song',
        join: {
          from: 'users.id',
          to: 'songs.user_id'
        }
      },
    }
  }

  $beforeUpdate(opt, quetyContext) {
    this.updated_at = new Date().toISOString()
  }

  $beforeInsert() {
    this.updated_at, this.created_at = new Date().toISOString()
  }

  static getSearchable() {
    return [
      'username', 'name'
    ]
  }

  safeValues(obj) {
    return {
      id: this.id,
      name: this.name,
      avatar: this.avatar,
      banner: this.banner,
      type: obj && obj.type ? this.type : undefined,
      songs: (this.songs || []).length
    }
  }
  static get jsonSchema() {
    return {
      type: 'object',
      required: [],
      properties: {
        id: { type: 'integer' },
      }
    }
  }

  static get modelPaths() {
    return [__dirname]
  }
}

module.exports = User

'''
'''--- app/models/index.js ---
let fs = require('fs'),
    path = require('path'),
    models = {},
    name

fs.readdirSync(__dirname).filter((file) => {
    return file !== path.basename(__filename)
}).forEach((file) => {
    name = path.parse(file).name
    models[name] = require(`./${name}`)
})

module.exports = models
'''
'''--- app/routes/albums.js ---
let {
    getAlbums,
    getAlbum,
    createAlbum,
    deleteAlbum,
    editAlbum,
    sellAlbumCover,
    buyAlbumCover,
} = require('../controllers/Albums')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var albums = await getAlbums(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(albums)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var album = await getAlbum(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(album)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var album = await createAlbum(req.body, req.user.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(album)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/sell', async (req, res) => {
        try {
            var song = await sellAlbumCover(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/buy', async (req, res) => {
        try {
            var song = await buyAlbumCover(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.patch('/:id', async (req, res) => {
        try {
            var album = await editAlbum(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(album)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var album = await deleteAlbum(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(album))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/auth.js ---
let { standardLogin, ResetPassword, ForgotPassword, createUser } = require('../controllers/Auth')

module.exports = (router) => {

    router.post('/login', async (req, res) => {

        try {
            var user = await standardLogin(
                req.body.email,
                req.body.password
            )
        } catch (error) {
            console.log(error.message)
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/signup', async (req, res) => {

        try {
            var user = await createUser(
                req.body
            )
        } catch (error) {
            console.log(error.message)
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/reset-password', async (req, res) => {

        try {
            var user = await ResetPassword(
                req.body,
            )
        } catch (error) {
            console.log(error.message)
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/forgot-password', async (req, res) => {

        try {
            var user = await ForgotPassword(
                req.body,
            )
        } catch (error) {
            console.log(error.message)
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {
    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode || result.error.status
        }
    }
    return {
        ...result,
        success: result.success,
        status: 200
    }
}
'''
'''--- app/routes/followers.js ---
let {
    getFollowers,
    getFollower,
    createFollower,
    deleteFollower,
    editFollower
} = require('../controllers/Followers')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var followers = await getFollowers(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(followers)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var follower = await getFollower(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(follower)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var follower = await createFollower(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(follower)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var follower = await editFollower(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(follower)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var follower = await deleteFollower(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(follower))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/marketplace.js ---
let {
    getMarketplaceSongs,
    getMarketplaceSong,
} = require('../controllers/Marketplace')

module.exports = (router) => {

    router.get('/songs', async (req, res) => {

        try {
            var followers = await getMarketplaceSongs(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(followers)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var song = await getMarketplaceSong(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router;
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/moonpay.js ---
const crypto = require('crypto');

module.exports = (router) => {
    router.get('/sign', async (req, res) => {
        try {
            const originalUrl = 'https://buy-staging.moonpay.com?apiKey=pk_test_Atula0B14cvDEjG2VohLCsa2bmhInRk&currencyCode=eth&walletAddress=0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae';

            var signature = crypto
                .createHmac('sha256', process.env.MOONPAY_SECRET_KEY)
                .update(new URL(originalUrl).search)
                .digest('base64');
            signature = { signature }
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(signature)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/near.js ---
let {
    createNewNearAccount,
    LinkWallet,
    callFuncions,
    getOwner,
    sendMoney,
} = require('../controllers/Near'),
    { getNearPriceInUSD } = require('../lib/near')

module.exports = (router) => {
    router.post('/signup', async (req, res) => {
        try {
            var user = await createNewNearAccount(req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/link', async (req, res) => {
        req.body.user = req.user
        try {
            var user = await LinkWallet(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.get('/price', async (req, res) => {
        try {
            var price = await getNearPriceInUSD()
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(price)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/send', async (req, res) => {
        try {
            var price = await sendMoney(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(price)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/nfts.js ---
let {
    getUserNFTs,
    getUserByIdNFTs,
    getNFTOwner,
    mintToken
} = require('../controllers/UserNFT')

module.exports = (router) => {
    router.get('/:id(\\d+)', async (req, res) => {
        try {
            var song = await getUserByIdNFTs(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/', async (req, res) => {
        try {
            var song = await getUserNFTs(req.user.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/owner/:token', async (req, res) => {
        try {
            var song = await getNFTOwner(req.params.token, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/mint', async (req, res) => {
        try {
            var song = await mintToken(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/nomination-votes.js ---
let {
    getNominationVotes,
    getNominationVote,
    createNominationVote,
    deleteNominationVote,
    editNominationVote
} = require('../controllers/NominationVotes')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var nominationvotes = await getNominationVotes(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nominationvotes)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var nominationvote = await getNominationVote(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nominationvote)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var nominationvote = await createNominationVote(req.body, req.user.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nominationvote)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var nominationvote = await editNominationVote(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nominationvote)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var nominationvote = await deleteNominationVote(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(nominationvote))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/nominations.js ---
let {
    getNominations,
    getNomination,
    createNomination,
    deleteNomination,
    editNomination
} = require('../controllers/Nominations')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var nominations = await getNominations(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nominations)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var nomination = await getNomination(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nomination)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var nomination = await createNomination(req.body, req.user.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nomination)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var nomination = await editNomination(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(nomination)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var nomination = await deleteNomination(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(nomination))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/playlists-songs.js ---
let {
    getPlaylistsSongs,
    getPlaylistsSong,
    createPlaylistsSong,
    deletePlaylistsSong,
    editPlaylistsSong
} = require('../controllers/PlaylistsSongs')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var playlistssongs = await getPlaylistsSongs(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlistssongs)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var playlistssong = await getPlaylistsSong(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlistssong)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var playlistssong = await createPlaylistsSong(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlistssong)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var playlistssong = await editPlaylistsSong(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlistssong)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var playlistssong = await deletePlaylistsSong(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(playlistssong))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/playlists.js ---
let {
    getPlaylists,
    getPlaylist,
    createPlaylist,
    deletePlaylist,
    editPlaylist
} = require('../controllers/Playlists')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var playlists = await getPlaylists(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlists)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var playlist = await getPlaylist(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlist)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        req.body.user_id = req.user.id
        try {
            var playlist = await createPlaylist(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlist)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var playlist = await editPlaylist(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlist)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var playlist = await deletePlaylist(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(playlist))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/search.js ---
let {
    getSearch
} = require('../controllers/Search')

module.exports = (router) => {
    router.get('/', async (req, res) => {

        try {
            var playlists = await getSearch(
                req.query,
                req.query.page,
                req.query.perPage,
                req.user.id
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(playlists)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/showcases.js ---
let {
    getShowcases,
    getShowcase,
    createShowcase,
    deleteShowcase,
    editShowcase
} = require('../controllers/Showcases')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var showcases = await getShowcases(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(showcases)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var showcase = await getShowcase(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(showcase)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        req.body.user_id = req.user.id
        try {
            var showcase = await createShowcase(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(showcase)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var showcase = await editShowcase(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(showcase)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var showcase = await deleteShowcase(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(showcase))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/songs.js ---
let {
    getSongs,
    getSong,
    createSong,
    deleteSong,
    editSong,
    sellSong,
    buySong
} = require('../controllers/Songs')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var songs = await getSongs(
                req.query,
                req.query.page,
                req.query.perPage,
                req.user
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(songs)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var song = await getSong(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var song = await createSong(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/sell', async (req, res) => {
        try {
            var song = await sellSong(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/buy', async (req, res) => {
        try {
            var song = await buySong(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.patch('/:id', async (req, res) => {
        try {
            var song = await editSong(req.params.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var song = await deleteSong(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(song))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/transactions.js ---
let {
    getTransactions
} = require('../controllers/Transactions')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var transactions = await getTransactions(
                req.query,
                req.query.page,
                req.query.perPage,
                req.user
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(transactions)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/transfers.js ---
let {
    transferToken,
    unlockToken,
    getTransfers,
    getTransfer,
    getSale
} = require('../controllers/Transfer')

module.exports = (router) => {
    router.get('/', async (req, res) => {

        try {
            var songs = await getTransfers(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(songs)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var song = await getTransfer(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/sale', async (req, res) => {
        try {
            var song = await getSale(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/', async (req, res) => {
        try {
            var song = await transferToken(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    router.post('/unlock', async (req, res) => {
        try {
            var song = await unlockToken(req.body, req.user)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/uploads.js ---
let { uploadAlbum, uploadSongs, uploadFile } = require('../controllers/Upload')
const multer = require('multer')
const upload = multer({ dest: 'uploads/' })

module.exports = (router) => {
    router.post('/', upload.single('file'), async (req, res) => {
        try {
            var song = await uploadFile(req.file, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    }),
        router.post('/album', async (req, res) => {
            try {
                var song = await uploadAlbum(req.body, req.user.id)
            } catch (error) {
                if (error.statusCode === 500) {
                    console.error(error)
                }
                let errResponse = formatResponse({ error }, true)
                let status = errResponse.status || 500
                delete errResponse.status
                return res.status(status).json({
                    ...errResponse
                })
            }

            let response = formatResponse(song)
            let status = response.status || 200
            delete response.status

            return res.status(status || 200).json({
                ...response
            })

        })
    router.post('/song', async (req, res) => {
        try {
            var song = await uploadSongs(req.body, req.user.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(song)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })
    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- app/routes/users.js ---
let {
    getUsers,
    getUser,
    createUser,
    deleteUser,
    editUser
} = require('../controllers/Users')

module.exports = (router) => {

    router.get('/', async (req, res) => {

        try {
            var users = await getUsers(
                req.query,
                req.query.page,
                req.query.perPage,
            )
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(users)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.get('/:id', async (req, res) => {
        try {
            var user = await getUser(req.params.id, req.query)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.post('/', async (req, res) => {
        try {
            var user = await createUser(req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.patch('/:id', async (req, res) => {
        try {
            var user = await editUser(req.user.id, req.body)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        let response = formatResponse(user)
        let status = response.status || 200
        delete response.status

        return res.status(status || 200).json({
            ...response
        })

    })

    router.delete('/:id', async (req, res) => {
        try {
            var user = await deleteUser(req.params.id)
        } catch (error) {
            if (error.statusCode === 500) {
                console.error(error)
            }
            let errResponse = formatResponse({ error }, true)
            let status = errResponse.status || 500
            delete errResponse.status
            return res.status(status).json({
                ...errResponse
            })
        }

        return res.json(formatResponse(user))

    })

    return router
}

function formatResponse(result, isError = false) {

    if (isError === true) {
        return {
            message: result.error.message.message || result.error.message,
            success: false,
            status: result.error.statusCode
        }
    }
    return {
        ...result,
        success: true,
        status: 200
    }
}

'''
'''--- knexfile.js ---
// Update with your config settings.
// var pg = require('pg')
// pg.defaults.ssl = true // Forces SSL to Heroku
require('dotenv').config()
module.exports = {

  development: {
    client: 'postgresql',
    connection: {
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASS,
      database: process.env.DB_NAME,
      port: process.env.DB_PORT,
      charset: 'utf8'
    },
    pool: {
      min: 2,
      max: 6,
      createTimeoutMillis: 3000,
      acquireTimeoutMillis: 30000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 100,
      propagateCreateError: false // <- default is true, set to false
    },
  },

  staging: {
    client: 'postgresql',
    connection: process.env.DATABASE_URL,
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: 'knex_migrations'
    }
  },

  production: {
    client: 'postgresql',
    connection: process.env.DATABASE_URL + '?ssl=true',
    pool: {
      min: 2,
      max: 10
    },
    migrations: {
      tableName: 'knex_migrations'
    }
  }
}

'''
'''--- migrations/20210510111634_User.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('users', (t) => {
            t.increments().primary()
            t.timestamps()
            t.string('name')
            t.string('username')
            t.string('twitter_id')
            t.text('avatar')
            t.text('banner')
            t.string('near_account_id')
            t.boolean('connected_to_near').default(false)
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('users')
    ])
};
'''
'''--- migrations/20210511134544_publicKey.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('users', (t) => {
            t.text('near_public_key')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210517104752_AlbumSOngs.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('albums', (t) => {
            t.increments().primary()
            t.timestamps()
            t.string('title')
            t.text('description')
            t.integer('user_id')
            t.foreign('user_id').references('id').inTable('users')
            t.text('url')
            t.boolean('is_deleted').default(false)
        }),
        knex.schema.createTableIfNotExists('songs', (t) => {
            t.increments().primary()
            t.timestamps()
            t.text('title')
            t.text('url')
            t.integer('album_id')
            t.foreign('album_id').references('id').inTable('albums')
            t.integer('owner_id')
            t.foreign('owner_id').references('id').inTable('users')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('users')
    ])
};
'''
'''--- migrations/20210517112700_albumQty.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.text('qty')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210603142153_cid.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.string('cid')
        }),
        knex.schema.alterTable('songs', (t) => {
            t.string('cid')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210604123353_newFields.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.dropColumn('url')
            t.dropColumn('qty')
        }),
        knex.schema.alterTable('songs', (t) => {
            t.dropColumn('url')
            t.string('lyricist')
            t.string('genre')
            t.string('singer')
            t.date('released_year')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210604131006_fileCID.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.string('cover_cid')
        }),
        knex.schema.alterTable('songs', (t) => {
            t.string('song_cid')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210604163032_txn_hash.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.string('txn_hash')
        }),
        knex.schema.alterTable('songs', (t) => {
            t.string('txn_hash')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210608161243_songUsedId.js ---

exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('songs', (t) => {
            t.integer('user_id')
            t.foreign('user_id').references('id').inTable('users')
        }),
    ])
};

exports.down = function (knex) {

};

'''
'''--- migrations/20210615160447_Readdqty.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.text('qty')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210616124423_AlbumOwnedBy.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.integer('current_owner')
            t.foreign('current_owner').references('id').inTable('users')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210616125014_SongsOwnedBy.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('songs', (t) => {
            t.integer('current_owner')
            t.foreign('current_owner').references('id').inTable('users')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210616143157_removeSongowerid.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('songs', (t) => {
            t.dropColumn('owner_id')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210622135329_playlist.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('playlists', (t) => {
            t.increments().primary()
            t.timestamps()
            t.string('title')
            t.integer('user_id')
            t.foreign('user_id').references('id').inTable('users')
            t.boolean('is_deleted').default(false)
        }),
        knex.schema.createTableIfNotExists('playlists_songs', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('song_id')
            t.foreign('song_id').references('id').inTable('songs')
            t.integer('playlist_id')
            t.foreign('playlist_id').references('id').inTable('playlists')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('playlists'),
        knex.schema.dropTableIfExists('playlists_songs')
    ])
};
'''
'''--- migrations/20210622145720_Showcase.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('showcases', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('album_id')
            t.foreign('album_id').references('id').inTable('albums')
            t.integer('user_id')
            t.foreign('user_id').references('id').inTable('users')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('showcases'),
    ])
};
'''
'''--- migrations/20210622180245_nominate.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('nominations', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('nominee')
            t.foreign('nominee').references('id').inTable('users')
            t.integer('nominated_by')
            t.foreign('nominated_by').references('id').inTable('users')
            t.date('for_month')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('nominations'),
    ])
};
'''
'''--- migrations/20210623122207_NominationQueue.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('nomination_queues', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('nominee')
            t.foreign('nominee').references('id').inTable('users')
            t.date('for_month')
            t.boolean('is_opted').default(false)
            t.boolean('is_in_queue').default(true)
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('nomination_queues'),
    ])
};
'''
'''--- migrations/20210623124951_nominationQueueId.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('nominations', (t) => {
            t.integer('nomination_queue_id')
            t.foreign('nomination_queue_id').references('id').inTable('nomination_queues')
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210623183926_mintCopies.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.integer('available_qty')
            t.boolean('has_copy').default(true)
        }),
        knex.schema.alterTable('songs', (t) => {
            t.integer('available_qty')
            t.boolean('has_copy').default(true)
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210628150207_songsQty.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('songs', (t) => {
            t.text('qty')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210628152436_Price.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.integer('price').unsigned()
        }),
        knex.schema.alterTable('songs', (t) => {
            t.integer('price').unsigned()
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210629164224_Transfers.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('transfers', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('transfer_by')
            t.foreign('transfer_by').references('id').inTable('users')
            t.integer('transfer_to')
            t.foreign('transfer_to').references('id').inTable('users')
            t.string('transaction_hash')
            t.string('token')
            t.integer('copy_number')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('transfers'),
    ])
};
'''
'''--- migrations/20210630170112_artisttype.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('users', (t) => {
            t.string('type').default('user')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210707121342_near_in_yocto.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.string('yocto_near_price')
        }),
        knex.schema.alterTable('songs', (t) => {
            t.string('yocto_near_price')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210708163338_isPurchased.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.boolean('is_purchased').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210708163812_isPurchasedSong.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('songs', (t) => {
            t.boolean('is_purchased').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210715164602_transactionType.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('transfers', (t) => {
            t.string('type')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210719160404_is_owner.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('transfers', (t) => {
            t.boolean('is_owner').default(true)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210719162446_bidding_price.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('transfers', (t) => {
            t.integer('bidding_price').unsigned()
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210719162831_isForSale.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('transfers', (t) => {
            t.boolean('is_for_sale').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210728160802_followers.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('followers', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('follower_id')
            t.foreign('follower_id').references('id').inTable('users')
            t.integer('artist_id')
            t.foreign('artist_id').references('id').inTable('users')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('followers'),
    ])
};
'''
'''--- migrations/20210802193835_nominationVotes.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.createTableIfNotExists('nomination_votes', (t) => {
            t.increments().primary()
            t.timestamps()
            t.integer('voter_id')
            t.foreign('voter_id').references('id').inTable('users')
            t.integer('nomination_id')
            t.foreign('nomination_id').references('id').inTable('nominations')
            t.boolean('is_deleted').default(false)
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
        knex.schema.dropTableIfExists('nomination_votes'),
    ])
};
'''
'''--- migrations/20210802195459_queue.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('nominations', (t) => {
            t.boolean('is_in_queue').default(true)
        }),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210802203421_RemoveNotificationQuueTable.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('nominations', (t) => {
            t.dropColumn('nomination_queue_id')
        }),
        knex.schema.dropTableIfExists('nomination_queues'),
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210806153553_removeYoctoNear.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.dropColumn('yocto_near_price')
        })
    ])
};

exports.down = function (knex) {
};
'''
'''--- migrations/20210811124826_yoctoNear.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.string('yocto_near_price')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20210825131425_nearAmount.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('transfers', (t) => {
            t.string('yocto_near_price')
            t.integer('price_in_usd').unsigned()
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20211007151154_minting_cost.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('albums', (t) => {
            t.integer('minting_cost').unsigned()
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- migrations/20211012171822_near_account_type.js ---
exports.up = function (knex) {
    return Promise.all([
        knex.schema.alterTable('users', (t) => {
            t.string('near_account_type').default('new')
        })
    ])
};

exports.down = function (knex) {
    return Promise.all([
    ])
};
'''
'''--- package.json ---
{
    "name": "amplify-music-api",
    "version": "1.0.0",
    "main": "server.js",
    "author": "Anil Kumar M C",
    "license": "Private",
    "private": true,
    "scripts": {
        "start": "node server.js",
        "dev": "nodemon --inspect server.js"
    },
    "dependencies": {
        "@pinata/sdk": "^1.1.23",
        "axios": "^0.19.2",
        "body-parser": "^1.18.3",
        "borsh": "^0.4.0",
        "bs58": "^4.0.1",
        "connect-timeout": "^1.9.0",
        "cors": "^2.8.4",
        "del": "^6.0.0",
        "dotenv": "^6.0.0",
        "express": "^4.16.3",
        "express-jwt": "^5.3.1",
        "express-session": "^1.17.1",
        "fs": "^0.0.1-security",
        "handlebars": "^4.7.6",
        "jsonwebtoken": "^8.3.0",
        "knex": "^0.21.1",
        "lodash": "^4.17.21",
        "md5": "^2.2.1",
        "moment": "^2.22.2",
        "multer": "^1.4.2",
        "near-api-js": "^0.41.0",
        "near-sdk-as": "^3.1.0",
        "node-cron": "^3.0.0",
        "objection": "^2.1.3",
        "passport": "^0.4.0",
        "passport-twitter": "^1.0.4",
        "pg": "^8.0.3",
        "progress-stream": "^2.0.0",
        "stripe": "^8.167.0",
        "throng": "^5.0.0"
    },
    "devDependencies": {
        "eslint": "^5.5.0",
        "nodemon": "^1.18.4"
    },
    "engines": {
        "node": ">=0.12"
    }
}

'''
'''--- pinata.js ---
const pinataSDK = require('@pinata/sdk');
const pinata = pinataSDK('1f90852a0c130b04ab9b', '947b290a669955f38545055a79e5a56b5f9e3fafdb717bdb9fa1cf5ffdfeae80');
const fs = require('fs')

const ipfsGateway = 'https://amplify-dev.mypinata.cloud'

async function uploadFileToPinata(path, metaname, keyvalues = {}) {
    const options = {
        pinataMetadata: {
            name: metaname,
            keyvalues
        },
        pinataOptions: {
            cidVersion: 0
        }
    };
    return await pinata.pinFileToIPFS(path, options)
}

async function init() {
    let results = await Promise.all([
        fs.createReadStream(`./uploads/bro1.mp3`), fs.createReadStream(`./uploads/bro2.mp3`), fs.createReadStream(`./uploads/bro3.mp3`)
    ].map((file, i) => uploadFileToPinata(file, `Bro${i}`, {})))
}
'''
'''--- server.js ---
require('dotenv').config()
const express = require('express'),
  app = express(),
  server = require('http').Server(app),
  router = express.Router(),
  bodyParser = require('body-parser'),
  ejwt = require('express-jwt'),
  passport = require('./app/lib/passport'),
  cors = require('cors'),
  port = process.env.PORT || 8000,
  fs = require('fs'),
  path = require('path'),
  _ = require('lodash'),
  session = require('express-session'),
  jsonwebtoken = require('jsonwebtoken'),
  cron = require('node-cron'),
  { clearNominationQueue } = require('./app/lib/cron'),
  timeout = require('connect-timeout');

app.use(timeout(480000));
app.use(haltOnTimedout);

function haltOnTimedout(req, res, next) {
  if (!req.timedout) next();
}
app.use(cors({
  origin: true,
  methods: ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Forwarded-For'],
  credentials: true
}))

app.use(bodyParser.urlencoded({
  limit: '500mb',
  extended: true,
  type: 'application/x-www-form-urlencoded'
}))

app.use(bodyParser.json({
  limit: '500mb',
  type: 'application/*'
}))

app.use(ejwt({
  secret: process.env.JWT_SECRET_KEY || 'supersecret'
}).unless({
  path: [
    {
      url: /\/auth*/,
    }
  ]
}))

passport.serializeUser(function (user, cb) {
  cb(null, user);
});

passport.deserializeUser(function (obj, cb) {
  cb(null, obj);
});
app.use(session({
  resave: false,
  saveUninitialized: true,
  secret: 'bla bla bla'
}));

app.use(passport.initialize())
app.use(passport.session());

app.get('/auth/twitter',
  passport.authenticate('twitter'));

app.get('/auth/twitter/callback',
  passport.authenticate('twitter', { failureRedirect: '/login' }),
  function (req, res) {
    let token = jsonwebtoken.sign({
      id: req.user.user_id,
      twitter_id: req.user.id,
      username: req.user.username,
      name: req.user.displayName,
      avatar: req.user.photos[0].value && req.user.photos[0].value.replace('normal', '400x400'),
      banner: req.user.profile_banner_url,
      near_connected: req.user.near_connected,
      near_account_id: req.user.near_account_id,
      type: req.user.type,
    },
      process.env.JWT_SECRET_KEY,
    )
    // Successful authentication, redirect home.
    res.redirect(`${process.env.CLIENT_URL}/auth/redirect?token=${token}`);
  });

app.use(function (req, res, next) {

  if (req.query.related) {
    req.query.related = `[${req.query.related}]`
  }

  next()
})

function parseQueryString(req, res, next) {
  if (req.query && req.query.hasOwnProperty('filter')) {
    req.query.filter = _.mapValues(req.query.filter, function (value, key) {
      if (value === 'false')
        return false
      else if (value === 'true')
        return true
      else
        return value
    });
  }
  if (req.query && req.query.hasOwnProperty('filterRelated')) {
    req.query.filterRelated = _.mapValues(req.query.filterRelated, function (value, key) {
      if (value === 'false')
        return false
      else if (value === 'true')
        return true
      else
        return value
    });
  }
  next()
}

fs.readdirSync('./app/routes').forEach((file) => {
  router.use(`/${path.parse(file).name}`, parseQueryString, require(`./app/routes/${file}`)(
    express.Router()
  ))
})
app.get('/', (req, res) => res.send('OK'))
app.use(router)

cron.schedule('0 0 1 * *', () => {
  //this runs on first of each month
  clearNominationQueue()
});

// const throng = require('throng')

// const WORKERS = process.env.WEB_CONCURRENCY || 1

// throng(start)

// function start() {
//   server.listen(port, () => {
//     console.log(`Server active at http://localhost:${port} on ID: ${process.pid}`)
//   })
// }
// if (process.env.NODE_ENV == 'development' || process.env.NODE_ENV === undefined) {
server.listen(port, () => {
  console.log(`Server active at http://localhost:${port} on ID: ${process.pid}`)
})

// } 
// else {
//   exports.server = server
// }

'''