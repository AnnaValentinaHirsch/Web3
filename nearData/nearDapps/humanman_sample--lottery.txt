*GitHub Repository "humanman/sample--lottery"*

'''--- Cargo.toml ---
[workspace]
members = [
  "simulation"
]

'''
'''--- README.md ---
# Lottery

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform.

The example here is playful.  It's a toy involving a lottery.

The goal of this repository is to make it as easy as possible to get started writing unit and simulation tests for AssemblyScript contracts built to work with NEAR Protocol.

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test`

### Top-level `yarn` commands

- run `yarn test` to run all tests
  - (!) be sure to run `yarn build:release` at least once before:
    - run `yarn test:unit` to run only unit tests
    - run `yarn test:simulate` to run only simulation tests
- run `yarn build` to quickly verify build status
- run `yarn clean` to clean up build folder

### Other documentation

- Lottery contract and test documentation
  - see `/src/lottery/README` for Lottery interface
  - see `/src/lottery/__tests__/README` for Lottery unit testing details

- Lottery contract simulation tests
  - see `/simulation/README` for simulation testing

## The file system

Please note that boilerplate project configuration files have been omitted from the following lists for simplicity.

### Contracts and Unit Tests

```txt
src
├── lottery                       <-- Lottery contract
│   ├── README.md
│   ├── __tests__
│   │   ├── README.md
│   │   ├── fee-strategies.unit.spec.ts
│   │   ├── index.unit.spec.ts
│   │   └── lottery.unit.spec.ts
│   └── assembly
│       ├── fee-strategies.ts
│       ├── index.ts
│       └── lottery.ts
└── utils.ts                      <-- shared contract code
```

### Simulation Tests

```txt
simulation                        <-- simulation tests
├── Cargo.toml
├── README.md
└── src
    ├── lib.rs
    └── lottery.rs
```

### Helper Scripts

```txt
scripts
├── 1.init.sh
├── 2.play.sh
├── 3.reset.sh
├── README.md                     <-- instructions
├── report.sh
├── x-configure-fee.sh
└── x-configure-lottery.sh
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/lottery"
  ]
}

'''
'''--- package.json ---
{
  "name": "starterkit-assemblyscript-contracts",
  "version": "0.0.1",
  "description": "Starter project for writing AssemblyScript contracts for NEAR Protocol",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit && yarn test:simulate",
    "test:simulate": "cargo test -- --nocapture",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target",
    "test:debug": "node --inspect-brk ./node_modules/.bin/asp"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.0.0"
  }
}

'''
'''--- scripts/1.init.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/lottery.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo "near call \$CONTRACT init '{\"owner\":\"'\$OWNER'\"}' --accountId \$CONTRACT"
echo
echo

exit 0

'''
'''--- scripts/2.play.sh ---
#!/usr/bin/env bash
set -e

echo
echo 'About to call play() on the contract'
echo near call \$CONTRACT play --account_id \$PLAYER --amount \$FEE
echo
echo \$CONTRACT is $CONTRACT
echo \$PLAYER is $PLAYER
echo \$FEE is [ $1 NEAR ] '(the optionally attached amount)'
echo
near call $CONTRACT play --account_id $PLAYER --amount $FEE

'''
'''--- scripts/3.reset.sh ---
#!/usr/bin/env bash
set -e

echo
echo 'About to call reset() on the CONTRACT'
echo near call \$CONTRACT reset --account_id \$CONTRACT
echo
echo \$CONTRACT is $CONTRACT
echo
near call $CONTRACT reset --account_id $CONTRACT

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder support a simple demonstration of the contract.
Although this contract supports an unlimited number of player, this demonstration uses only 2 players.

It uses the following setup:

```txt
┌───────────────────────────────────────┬───────────────────────────────────────┐
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                   B                   │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                  A                    ├───────────────────┬───────────────────┤
│                                       │                   │                   │
│                                       │                   │         D         │
│                                       │                   │                   │
│                                       │         C         ├───────────────────┤
│                                       │                   │                   │
│                                       │                   │         E         │
│                                       │                   │                   │
└───────────────────────────────────────┴───────────────────┴───────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control
  export PLAYER=          # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  # export PLAYER=ajax.testnet
  ```

- Commands
  ```sh
  1.init.sh               # cleanup, compile and deploy contract
  2.play.sh               # play the game, optionally takes a number as payment
  3.reset.sh              # reset the game when it's finished (ie. "active" is false)

  report.sh               # run a report of the game state
  x-configure-fee.sh      # change the fee strategy to any one of many supported strategies
  x-configure-lottery.sh  # change the terms of the lottery by adjusting chance in the range (0..1]
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```

### Terminal **C**

 *This window is used to render contract account state and keys*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract account state (for balance changes) and keys (for nonce changes)
  watch -d -n 1 "near state $CONTRACT && echo && near keys $CONTRACT"
  ```

### Terminal **D**

*This window is used to render the account state of player 1*
- Environment
  ```sh
  export PLAYER=          # any account you control

  # for example (player 1)
  # export PLAYER=ajax.testnet
  ```

- Commands
  ```sh
  # monitor player 1 account state (for balance changes)
  watch -d -n 1 near state $PLAYER
  ```

### Terminal **E**

*This window is used to render the account state of player 2*
- Environment
  ```sh
  export PLAYER=          # any account you control

  # for example (player 2)
  # export PLAYER=bran.testnet
  ```

- Commands
  ```sh
  # monitor player 2 account state (for balance changes)
  watch -d -n 1 near state $PLAYER
  ```

---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linux-watch-command#191068)

'''
'''--- scripts/report.sh ---
#!/usr/bin/env bash
set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable" && exit 1
[ -z "$PLAYER" ] && echo "Missing \$PLAYER environment variable" && exit 1

echo "These are the environment variables being used:"
echo
echo "CONTRACT is [ $CONTRACT ]"
echo "OWNER is [ $OWNER ]"
echo "PLAYER is [ $PLAYER ]"
echo
echo

echo "--------------------------------------------"
echo Contract Metadata
echo "--------------------------------------------"
# who owns this lottery? -> AccountId
echo "near view \$CONTRACT get_owner '{}'"
near view $CONTRACT get_owner '{}'
echo

# is the lottery still active? -> bool
echo "near view \$CONTRACT get_active '{}'"
near view $CONTRACT get_active '{}'
echo
echo

echo "--------------------------------------------"
echo Lottery Details
echo "--------------------------------------------"

# explain terms of the lottery -> string
echo "near view \$CONTRACT explain_lottery '{}'"
near view $CONTRACT explain_lottery '{}'
echo

# what is the pot currently? -> string
echo "near view \$CONTRACT get_pot '{}'"
near view $CONTRACT get_pot '{}'
echo

# who played last? -> AccountId
echo "near view \$CONTRACT get_last_played '{}'"
near view $CONTRACT get_last_played '{}'
echo

# has PLAYER played already? -> bool
echo "near view \$CONTRACT get_has_played '{\"player\":\"'\$PLAYER'\"}'"
near view $CONTRACT get_has_played '{"player":"'$PLAYER'"}'
echo

# who, if anyone, won? -> AccountId
# (this will be empty unless get_active returns false)
echo "near view \$CONTRACT get_winner '{}'"
near view $CONTRACT get_winner '{}'
echo
echo

echo "--------------------------------------------"
echo Lottery Fees
echo "--------------------------------------------"

# what is the fee for the lottery? -> string
echo "near view \$CONTRACT get_fee '{}'"
near view $CONTRACT get_fee '{}'
echo

# what is the fee strategy for the lottery? -> StrategyType
echo "near view \$CONTRACT get_fee_strategy '{}'"
near view $CONTRACT get_fee_strategy '{}'
echo

# explain fees for the lottery -> string
echo "near view \$CONTRACT explain_fees '{}'"
near view $CONTRACT explain_fees '{}'
echo

'''
'''--- scripts/x-configure-fee.sh ---
#!/usr/bin/env bash
set -e

[ -z "$1" ] && echo "No fee strategy supplied. Append a 0, 1, 2 or 3" && exit 1
echo
echo 'About to call configure_fee() on the contract'
echo near call \$CONTRACT configure_fee --account_id \$CONTRACT \$1
echo
echo \$CONTRACT is $CONTRACT
echo \$1 is $1
echo
near call $CONTRACT configure_fee '{"strategy": '$1'}' --account_id $CONTRACT

'''
'''--- scripts/x-configure-lottery.sh ---
#!/usr/bin/env bash
set -e

[ -z "$1" ] && echo "No lottery configuration supplied. Append any <f32> value between 0 and 1" && exit 1
echo
echo 'About to call configure_lottery() on the contract'
echo near call \$CONTRACT configure_lottery --account_id \$CONTRACT \$1
echo
echo \$CONTRACT is $CONTRACT
echo \$1 is $1
echo
near call $CONTRACT configure_lottery '{"chance": "'$1'"}' --account_id $CONTRACT

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/lottery/README.md ---

'''
'''--- src/lottery/__tests__/README.md ---
## Unit tests

Unit tests can be run from the top level folder using the following command:

```
yarn test:unit
```

### Tests for Contract in `index.unit.spec.ts`

You can run just these tests using

```
yarn asp -f index.unit
```

```
[Describe]: Contract

 [Success]: ✔ can be initialized with owner
 [Success]: ✔ is active when initialized

[Describe]: Contract interface for Lottery

 [Success]: ✔ provides an explanation of the lottery
 [Success]: ✔ provides a value for what a player may win
 [Success]: ✔ allows a player to play
 [Success]: ✔ provides access to most recent player
 [Success]: ✔ confirms whether a player has played
 [Success]: ✔ reports the winner of the lottery

[Describe]: Contract interface for Lottery Fees

 [Success]: ✔ reports the current fee to play the lottery
 [Success]: ✔ reports the fee strategy
 [Success]: ✔ explains possible fee strategies
 [Success]: ✔ adjusts the fee after 1 player

[Describe]: Contract interface for Lottery Management

 [Success]: ✔ allows ONLY the owner to change the terms of the lottery
 [Success]: ✔ adjusts the fee based on FeeStrategy
 [Success]: ✔ allows ONLY the owner to reset the lottery

    [File]: src/lottery/__tests__/index.unit.spec.ts
  [Groups]: 5 pass, 5 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 15 pass,  0 fail, 15 total
    [Time]: 133.988ms
```

### Tests for Lottery in `lottery.unit.spec.ts`

You can run just these tests using

```
yarn asp -f lottery.unit
```

```
[Describe]: Lottery

 [Success]: ✔ can explain itself

[Describe]: Lottery#play

 [Success]: ✔ plays like a lottery

[Describe]: Lottery#configure

 [Success]: ✔ can be reconfigured
 [Success]: ✔ throws with invalid values for chance

    [File]: src/lottery/__tests__/lottery.unit.spec.ts
  [Groups]: 4 pass, 4 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 4 pass,  0 fail, 4 total
    [Time]: 11.824ms
```

### Tests for FeeStrategy in `fee-strategies.unit.spec.ts`

You can run just these tests using

```
yarn asp -f strategies.unit
```

```
[Describe]: FeeStrategy

 [Success]: ✔ is instantiated with exponential strategy by default
 [Success]: ✔ can be instantiated with a different strategy
 [Success]: ✔ can explain itself

[Describe]: FeeStrategy#calculate_fee

 [Success]: ✔ handles StrategyType.Free
 [Success]: ✔ handles StrategyType.Constant
 [Success]: ✔ handles StrategyType.Linear
 [Success]: ✔ handles StrategyType.Exponential

    [File]: src/lottery/__tests__/fee-strategies.unit.spec.ts
  [Groups]: 3 pass, 3 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 7 pass,  0 fail, 7 total
    [Time]: 6.896ms
```

'''
'''--- src/lottery/__tests__/fee-strategies.unit.spec.ts ---
import { u128 } from "near-sdk-core";
import { FeeStrategy, StrategyType } from "../assembly/fee-strategies";

describe("FeeStrategy", () => {
  it("is instantiated with exponential strategy by default", () => {
    const strategy = new FeeStrategy()
    expect(strategy.strategy).toBe(StrategyType.Exponential)
  });

  it("can be instantiated with a different strategy", () => {
    const strategy = new FeeStrategy(StrategyType.Free)
    expect(strategy.strategy).toBe(StrategyType.Free)
  })

  it("can explain itself", () => {
    expect(FeeStrategy.explain()).toBe("one of [ Free | Constant | Linear | Exponential ]")
  })
})

describe("FeeStrategy#calculate_fee", () => {
  it("handles StrategyType.Free", () => {
    const strategy = new FeeStrategy(StrategyType.Free)
    const fee = strategy.calculate_fee(2, u128.from(1))
    expect(fee).toBe(u128.Zero)
  })

  it("handles StrategyType.Constant", () => {
    const strategy = new FeeStrategy(StrategyType.Constant)
    const fee = strategy.calculate_fee(2, u128.from(1))
    expect(fee).toBe(u128.from(1))
  })

  it("handles StrategyType.Linear", () => {
    const strategy = new FeeStrategy(StrategyType.Linear)
    const fee = strategy.calculate_fee(2, u128.from(1))
    expect(fee).toBe(u128.from(2))
  })

  it("handles StrategyType.Exponential", () => {
    const strategy = new FeeStrategy(StrategyType.Exponential)
    const fee = strategy.calculate_fee(2, u128.from(1))
    expect(fee).toBe(u128.from(4))
  })
})

'''
'''--- src/lottery/__tests__/index.unit.spec.ts ---
import { VMContext } from "near-sdk-as";

import { Contract } from "../assembly/index";
import { StrategyType } from "../assembly/fee-strategies";
import { ONE_NEAR } from "../../utils";

const contract = "lottery"
const owner = "alice"
const player1 = "bob"
const player2 = "carol"

let lottery: Contract

beforeEach(() => {
  VMContext.setCurrent_account_id(contract)
  VMContext.setAccount_balance(ONE_NEAR) // resolves HostError(BalanceExceeded)
  lottery = new Contract(owner)
})

// --------------------------------------------
// --------------------------------------------
// VIEW method tests
// --------------------------------------------
// --------------------------------------------

// --------------------------------------------
// Contract Metadata
// --------------------------------------------
describe("Contract", () => {

  it("can be initialized with owner", () => {
    // who owns this lottery? -> AccountId
    expect(lottery.get_owner()).toBe(owner)
  });

  it("is active when initialized", () => {
    // is the lottery still active? -> bool
    expect(lottery.get_active()).toBe(true)
  })
})

// --------------------------------------------
// Lottery Details
// --------------------------------------------
describe("Contract interface for Lottery", () => {

  it("provides an explanation of the lottery", () => {
    // explain terms of the lottery -> string
    expect(lottery.explain_lottery()).toBe("Players have a 20.0% chance of winning.")
  });

  it("provides a value for what a player may win", () => {
    // what is the pot currently? -> string
    expect(lottery.get_pot()).toBe("1 NEAR")
  });

  it("allows a player to play", () => {
    // play the lottery
    expect(() => {
      lottery.play()
    }).not.toThrow()
  });

  it("provides access to most recent player", () => {
    // who played last? -> AccountId
    expect(lottery.get_last_played()).toBeNull()

    VMContext.setSigner_account_id(player1)
    lottery.play()

    expect(lottery.get_last_played()).toBe(player1)
  });

  it("confirms whether a player has played", () => {
    // has player played already? -> bool
    expect(lottery.get_has_played(player1)).toBe(false)

    VMContext.setSigner_account_id(player1)
    lottery.play()

    expect(lottery.get_has_played(player1)).toBe(true)
  });

  it("reports the winner of the lottery", () => {
    // who, if anyone, won? -> AccountId
    expect(lottery.get_winner()).toBeNull()

    // setup lottery to guarantee a win
    VMContext.setPredecessor_account_id(contract) // resolves Error: "Only this contract may call itself"
    lottery.configure_lottery('1.0') // 100% chance of winning

    VMContext.setSigner_account_id(player1)
    lottery.play()

    expect(lottery.get_winner()).toBe(player1)
  });
})

// --------------------------------------------
// Lottery Fees
// --------------------------------------------
describe("Contract interface for Lottery Fees", () => {

  it("reports the current fee to play the lottery", () => {
    // what is the fee for the lottery? -> string
    expect(lottery.get_fee()).toBe("0 NEAR")
  });

  it("reports the fee strategy", () => {
    // what is the fee strategy for the lottery? -> StrategyType
    expect(lottery.get_fee_strategy()).toBe(StrategyType.Exponential)
  })

  it("explains possible fee strategies", () => {
    // explain fees for the lottery -> string
    expect(lottery.explain_fees()).toBe("one of [ Free | Constant | Linear | Exponential ]")
  })

  it("adjusts the fee after 1 player", () => {
    VMContext.setSigner_account_id(player1)
    lottery.play()

    // assuming anything except FeeStrategy.Free
    expect(lottery.get_fee()).toBe("1 NEAR")
  })
})

// --------------------------------------------
// --------------------------------------------
// CHANGE method tests
// --------------------------------------------
// --------------------------------------------

// --------------------------------------------
// Lottery Management
// --------------------------------------------
describe("Contract interface for Lottery Management", () => {

  it("allows ONLY the owner to change the terms of the lottery", () => {
    // configure the terms of the lottery
    expect(lottery.explain_lottery()).toBe("Players have a 20.0% chance of winning.")

    VMContext.setPredecessor_account_id(contract) // resolves Error: "Only this contract may call itself"

    lottery.configure_lottery('1')
    expect(lottery.explain_lottery()).toBe("Players have a 100.0% chance of winning.")
  });

  it("adjusts the fee based on FeeStrategy", () => {
    VMContext.setSigner_account_id(player1)
    lottery.play()
    VMContext.setSigner_account_id(player2)
    lottery.play()

    VMContext.setPredecessor_account_id(contract) // resolves Error: "Only this contract may call itself"

    // configure the fee strategy
    lottery.configure_fee(StrategyType.Free)
    expect(lottery.get_fee()).toBe("0 NEAR")

    lottery.configure_fee(StrategyType.Constant)
    expect(lottery.get_fee()).toBe("1 NEAR")

    lottery.configure_fee(StrategyType.Linear)
    expect(lottery.get_fee()).toBe("2 NEAR")

    lottery.configure_fee(StrategyType.Exponential) // default
    expect(lottery.get_fee()).toBe("4 NEAR")
  });

  it("allows ONLY the owner to reset the lottery", () => {
    // reset the lottery
    expect(() => {
      lottery.reset()
    }).toThrow()

    expect(() => {
      VMContext.setPredecessor_account_id(contract) // resolves Error: "Only this contract may call itself"
      lottery.reset()
    }).not.toThrow()

  });

})

// --------------------------------------------
// Cross-contract calls
// --------------------------------------------
// CANNOT BE TESTED using unit tests because it's a callback (after payout is complete)
// MUST USE SIMULATION tests to verify this works as expected
// on_payout_complete(): void {
// --------------------------------------------

'''
'''--- src/lottery/__tests__/lottery.unit.spec.ts ---
import { Lottery } from "../assembly/lottery";

let lottery: Lottery;
beforeEach(() => {
  lottery = new Lottery()
})

describe("Lottery", () => {
  it("can explain itself", () => {
    expect(lottery.explain()).toBe("Players have a 20.0% chance of winning.")
  })
})

describe("Lottery#play", () => {
  // TODO: how do we actually test this?
  it("plays like a lottery", () => {
    // 100% chance of winning
    lottery.configure(1)
    expect(lottery.play()).toBe(true)

    // 0% chance of winning (1 in 10 billion ... but the limit is 1 in 1 billion bc u32)
    lottery.configure(0.000000001)
    expect(lottery.play()).toBe(false)
  })
})

describe("Lottery#configure", () => {
  it("can be reconfigured", () => {
    lottery.configure(1)
    expect(lottery.explain()).toBe("Players have a 100.0% chance of winning.")

    lottery.configure(0.5)
    expect(lottery.explain()).toBe("Players have a 50.0% chance of winning.")

    lottery.configure(0.25)
    expect(lottery.explain()).toBe("Players have a 25.0% chance of winning.")

    lottery.configure(0.01)
    expect(lottery.explain()).toBe("Players have a 1.0% chance of winning.")

    // TODO: format this level of message more clearly
    lottery.configure(0.000000001)
    expect(lottery.explain()).toBe("Players have a 1.0000000000000001e-7% chance of winning.")
  })

  it("throws with invalid values for chance", () => {
    expect(() => {
      lottery.configure(-1) // chance < 0
      lottery.configure(2)  // chance > 1
    }).toThrow("Chance must be within range (0..1]")
  })
})

'''
'''--- src/lottery/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/lottery/assembly/fee-strategies.ts ---
import { env, logging, u128 } from "near-sdk-as";

export const enum StrategyType {
  Free = 0,
  Constant,
  Linear,
  Exponential,
}

@nearBindgen
export class FeeStrategy {
  constructor(
    public strategy: StrategyType = StrategyType.Exponential
  ) {
    this.assert_valid_fee_strategy(strategy);
  }

  static explain(): string {
    return "one of [ Free | Constant | Linear | Exponential ]";
  }

  // TODO: handle possible overflow for each strategy
  calculate_fee(scalar: u32, base: u128): u128 {
    let fee: u128 = u128.Zero;

    switch (this.strategy) {
      case StrategyType.Free:
        // fee is already zero
        break;
      case StrategyType.Constant:
        fee = this.calculate_constant(base);
        break;
      case StrategyType.Linear:
        fee = this.calculate_linear(scalar, base);
        break;
      case StrategyType.Exponential:
        fee = this.calculate_exponential(scalar, base);
        break;
      default:
        logging.log("Unexpected StrategyType encountered");
        env.panic();
    }
    return fee;
  }

  //---------------------------------------------------------------------------
  // FeeStrategy helper methods
  //---------------------------------------------------------------------------

  private calculate_constant(base: u128): u128 {
    return base;
  }

  private calculate_linear(scalar: number, base: u128): u128 {
    return u128.mul(base, u128.from(scalar));
  }

  private calculate_exponential(scalar: u32, base: u128): u128 {
    return u128.mul(base, u128.pow(u128.from(scalar), 2));
  }

  private assert_valid_fee_strategy(strategy: StrategyType): void {
    assert(this.isValidFeeStrategy(strategy), "Invalid FeeStrategy: " + strategy.toString());
  }

  private isValidFeeStrategy(s: i32): bool {
    switch (s) {
      case StrategyType.Free:
      case StrategyType.Constant:
      case StrategyType.Linear:
      case StrategyType.Exponential: return true;
      default: return false;
    }
  }
}

'''
'''--- src/lottery/assembly/index.ts ---
import { logging, Context, u128, ContractPromiseBatch, PersistentSet } from "near-sdk-as";

import { AccountId, ONE_NEAR, asNEAR, XCC_GAS } from "../../utils";

import { FeeStrategy, StrategyType } from "./fee-strategies";
import { Lottery } from "./lottery";

@nearBindgen
export class Contract {

  private owner: AccountId;
  private winner: AccountId;
  private last_played: AccountId;
  private active: bool = true;
  private pot: u128 = ONE_NEAR;
  private fee_strategy: FeeStrategy = new FeeStrategy();
  private lottery: Lottery = new Lottery();
  private players: PersistentSet<AccountId> = new PersistentSet<AccountId>("p");

  constructor(owner: AccountId) {
    this.owner = owner;
  };

  // --------------------------------------------------------------------------
  // Public VIEW methods
  // --------------------------------------------------------------------------

  get_owner(): AccountId {
    return this.owner;
  }

  get_winner(): AccountId {
    return this.winner;
  }

  get_pot(): string {
    return asNEAR(this.pot) + " NEAR";
  }

  get_fee(): string {
    return asNEAR(this.fee()) + " NEAR";
  }

  get_fee_strategy(): StrategyType {
    return this.fee_strategy.strategy
  }

  get_has_played(player: AccountId): bool {
    return this.players.has(player);
  }

  get_last_played(): AccountId {
    return this.last_played;
  }

  get_active(): bool {
    return this.active;
  }

  explain_fees(): string {
    return FeeStrategy.explain()
  }

  explain_lottery(): string {
    return this.lottery.explain()
  }

  // --------------------------------------------------------------------------
  // Public CHANGE methods
  // --------------------------------------------------------------------------

  /**
   * "Pay to play"
   *
   * First time is free to play and you may win!
   *
   * If you've already played once then any other play costs you a fee.
   * This fee is calculated as 1 NEAR X the square of the total number of unique players
   */
  @mutateState()
  play(): void {
    assert(this.active, this.winner + " won " + this.pot.toString() + ". Please reset the game.");
    const signer = Context.sender;

    // if you've played before then you have to pay extra
    if (this.players.has(signer)) {
      const fee = this.fee();
      assert(Context.attachedDeposit >= fee, this.generate_fee_message(fee));
      this.increase_pot();

      // if it's your first time then you may win for the price of gas
    } else {
      this.players.add(signer);
    }

    this.last_played = signer;

    if (this.won()) {
      this.winner = signer;
      this.payout();
    } else {
      this.lose();
    }
  }

  @mutateState()
  configure_lottery(chance: string): bool {
    this.assert_self();
    this.lottery.configure(<f32>parseFloat(chance));
    return true;
  }

  // StrategyType is 0,1,2,or 3, and mapped to Free, Constant, Linear, and Exponential respectively
  @mutateState()
  configure_fee(strategy: StrategyType): bool {
    this.assert_self();
    this.fee_strategy = new FeeStrategy(strategy);
    return true;
  }

  @mutateState()
  reset(): void {
    this.assert_self();
    this.players.clear();
    this.winner = "";
    this.last_played = "";
    this.pot = ONE_NEAR;
    this.active = true;
  }

  // this method is only here for the promise callback,
  // it should never be called directly
  @mutateState()
  on_payout_complete(): void {
    this.assert_self();
    this.active = false;
    logging.log("game over.");
  }

  // --------------------------------------------------------------------------
  // Private methods
  // --------------------------------------------------------------------------

  private fee(): u128 {
    return this.fee_strategy.calculate_fee(this.players.size, ONE_NEAR);
  }

  private increase_pot(): void {
    this.pot = u128.add(this.pot, Context.attachedDeposit);
  }

  private won(): bool {
    return this.lottery.play()
  }

  private lose(): void {
    logging.log(this.last_played + " did not win.  The pot is currently " + this.get_pot());
  }

  private payout(): void {
    logging.log(this.winner + " won " + this.get_pot() + "!");

    if (this.winner.length > 0) {
      const to_winner = ContractPromiseBatch.create(this.winner);
      const self = Context.contractName

      // transfer payout to winner
      to_winner.transfer(this.pot);

      // receive confirmation of payout before setting game to inactive
      to_winner.then(self).function_call("on_payout_complete", "{}", u128.Zero, XCC_GAS);
    }
  }

  private generate_fee_message(fee: u128): string {
    return ("There are " + this.players.size.toString()
      + " players. Playing more than once now costs " + asNEAR(fee)
      + " NEAR");
  }

  private assert_self(): void {
    const caller = Context.predecessor
    const self = Context.contractName
    assert(caller == self, "Only this contract may call itself");
  }
}

'''
'''--- src/lottery/assembly/lottery.ts ---
import { logging, RNG } from "near-sdk-as";

@nearBindgen
export class Lottery {
  private chance: f64 = 0.20

  explain(): string {
    return "Players have a " + (this.chance * 100).toString() + "% chance of winning.";
  }

  play(): bool {
    const rng = new RNG<u32>(1, u32.MAX_VALUE);
    const roll = rng.next();
    logging.log("roll: " + roll.toString());
    return roll <= <u32>(<f64>u32.MAX_VALUE * this.chance);
  }

  configure(chance: f64): void {
    assert(chance >= 0.000000001 && chance <= 1, "Chance must be within range (0..1]");
    this.chance = chance;
    logging.log(this.explain());
  }
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''