*GitHub Repository "magic-powered/near.js"*

'''--- .changeset/config.json ---
{
  "$schema": "https://unpkg.com/@changesets/config@2.3.0/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "restricted",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}

'''
'''--- .eslintrc.json ---
{
  "root": true,
  "env": { "node": true, "es6": true },
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended", "airbnb-base", "airbnb-typescript/base"],
  "parser": "@typescript-eslint/parser",
  "parserOptions": { "project": ["./tsconfig.base.json"] },
  "plugins": ["@typescript-eslint"],
  "rules": {
    "indent": "off",
    "@typescript-eslint/indent": ["error", 2],
    "linebreak-style": ["error", "unix"],
    "quotes": ["error", "single"],
    "semi": ["error", "always"],
    "no-console": "off",
    "@typescript-eslint/no-empty-interface": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "max-classes-per-file": "off",
    "import/prefer-default-export": "off",
    "max-len": ["error", 120],
    "no-nested-ternary": "off",
    "class-methods-use-this": "off"
  },
  "globals": {
    "window": true,
    "fetch": true,
    "Headers": true,
    "document": true
  },
  "ignorePatterns": ["*.d.ts", "vite.config.ts"]
}

'''
'''--- .idea/codeStyles/Project.xml ---
<component name="ProjectCodeStyleConfiguration">
  <code_scheme name="Project" version="173">
    <JSCodeStyleSettings version="0">
      <option name="FORCE_SEMICOLON_STYLE" value="true" />
      <option name="USE_DOUBLE_QUOTES" value="false" />
      <option name="FORCE_QUOTE_STYlE" value="true" />
      <option name="VAR_DECLARATION_WRAP" value="2" />
      <option name="OBJECT_LITERAL_WRAP" value="2" />
    </JSCodeStyleSettings>
    <TypeScriptCodeStyleSettings version="0">
      <option name="FORCE_SEMICOLON_STYLE" value="true" />
      <option name="USE_DOUBLE_QUOTES" value="false" />
      <option name="FORCE_QUOTE_STYlE" value="true" />
      <option name="VAR_DECLARATION_WRAP" value="2" />
      <option name="OBJECT_LITERAL_WRAP" value="2" />
      <option name="SPACES_WITHIN_IMPORTS" value="true" />
    </TypeScriptCodeStyleSettings>
    <codeStyleSettings language="JavaScript">
      <option name="RIGHT_MARGIN" value="120" />
      <option name="BLOCK_COMMENT_ADD_SPACE" value="true" />
      <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
      <option name="METHOD_CALL_CHAIN_WRAP" value="2" />
      <option name="IF_BRACE_FORCE" value="1" />
      <option name="DOWHILE_BRACE_FORCE" value="1" />
      <option name="WHILE_BRACE_FORCE" value="1" />
      <option name="FOR_BRACE_FORCE" value="1" />
    </codeStyleSettings>
    <codeStyleSettings language="TypeScript">
      <option name="RIGHT_MARGIN" value="120" />
      <option name="BLOCK_COMMENT_ADD_SPACE" value="true" />
      <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
      <option name="METHOD_CALL_CHAIN_WRAP" value="2" />
      <option name="IF_BRACE_FORCE" value="1" />
      <option name="DOWHILE_BRACE_FORCE" value="1" />
      <option name="WHILE_BRACE_FORCE" value="1" />
      <option name="FOR_BRACE_FORCE" value="1" />
      <indentOptions>
        <option name="INDENT_SIZE" value="2" />
        <option name="CONTINUATION_INDENT_SIZE" value="2" />
      </indentOptions>
    </codeStyleSettings>
  </code_scheme>
</component>
'''
'''--- .idea/codeStyles/codeStyleConfig.xml ---
<component name="ProjectCodeStyleConfiguration">
  <state>
    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
  </state>
</component>
'''
'''--- README.md ---
# Near.JS

Near.JS is a community driven typescript library to interact with Near blockchain.

## Features:

- Modular architecture. You can install only what you need and keep your node_modules tiny.
- Fully typed. Significant simplification of learning for the new developers by providing proper and clean typings for all Near objects and interfaces.
- Dynamic typings for RPC endpoints: Library will put proper result type based on request you send to RPC endpoint.
- Multi wallet integration.
- Separate helpers for "small needs": rates api, units api, etc...
- Complete packages for your specific usecase: cli tool sdk, backend application sdk, frontend application sdk
- Extensive documentation.
- Complete functionality for all Near desires.
- MIT License.

## Documentation

- [Getting started](https://magic-powered.github.io/near.js/)

## Contribute

- [Library architecture](docs/architecture.md)
- [Contribution guide](docs/contributing.md)
- [Roadmap](docs/roadmap.md)

# License

MIT License

'''
'''--- docs/README.md ---
# Near.JS

Near.JS is a community driven typescript library to interact with Near blockchain.

## Features:

- Modular architecture. You can install only what you need and keep your node_modules tiny.
- Fully typed. Significant simplification of learning for the new developers by providing proper and clean typings for all Near objects and interfaces.
- Dynamic typings for RPC endpoints: Library will put proper result type based on request you send to RPC endpoint.
- Multi wallet integration.
- Separate helpers for "small needs": rates api, units api, etc...
- Complete packages for your specific usecase: cli tool sdk, backend application sdk, frontend application sdk
- Extensive documentation.
- Complete functionality for all Near desires.
- MIT License.

# License

MIT License

'''
'''--- docs/_coverpage.md ---
[//]: # (![logo]&#40;_media/icon.svg&#41;)

# NearJS

> A magical near js client library

- Simple and lightweight

[GitHub](https://github.com/magic-powered/near.js)
[Get Started](#main)

![color](#656565)

'''
'''--- docs/_sidebar.md ---
* [HOME](/)

* Quick start
  * [NearJS for frontend app](./quick-start/web.md)
  * [NearJS for cli app](./quick-start/cli.md)
  * [NearJS for backend app](./quick-start/backend.md)
* [Packages](./packages.md)
  * [@nearjs/account](./packages/account)
  * [@nearjs/browser-key-store](./packages/browser-key-store.md)
  * [@nearjs/fs-key-store](./packages/fs-key-store.md)
  * [@nearjs/provider-core](./packages/provider-core.md)
  * [@nearjs/provider-my-near-wallet](./packages/provider-wallet-my-near-wallet.md)
  * [@nearjs/tx](./packages/tx)
  * [@nearjs/utils](./packages/utils.md)

'''
'''--- docs/architecture.md ---
# Near.js architecture v0.1

Near.js is a modular typescript developer tool which provides everything you need to build your Web2 application that interacts with the Near and any ways.

This tool can be used for any usecases:

1. Building CLI tools
2. Building backend applications and APIs
3. Building web UI application

## Library mind map

The vision of MagicPowered team is that any application built around web3 apps or blockchain in general essentially doing two major things:

1. Query and send transactions
2. Manage accounts

![near.js mindmap](./resources/mindmap.png)

The diagram above shows an abstract mind map of the library. As you can see the library is structured around two main pieces:

- Transaction
- Account

Everything around this two circles considered complimentary to the one of these points.

## Library structure

```
.
├── LICENSE
├── README.md
├── doc
├── packages
│   ├── config
│   ├── keys
│   ├── keystore
│   ├── provider-core
│   ├── provider-rpc
│   ├── provider-wallet-core
│   ├── provider-wallet-my-near-wallet
│   ├── provider-wallet-sender
│   ├── tx
│   └── units
├── package.json
├── pnpm-workspace.yaml
├── tsconfig.package.json
└── tsconfig.project.json
```

The library is a multi package repo. Each package represents its own responsibility and functionality developer may need building their application.
The list of packages can be found [here](./packages.md)

'''
'''--- docs/contributing.md ---
# Near.js contributing guide

## Getting started

Following steps describes how to setup the Near.js repository on your local machine

### Setup

The following tools need to be installed on your system prior to installing the Near.js:

"node": ">=18",
"pnpm": ">=7"

- [NodeJS >=16.14.0](https://nodejs.org/download/release/latest-v16.x/)
- [PNPM >=7](https://pnpm.io/installation)

```shell
git clone git@github.com:magic-powered/near.js.git
cd near.js
pnpm i
```

### Repo structure

The Near.js is a NPM project written in typescript. More specifically, it is a [monorepo managed using pnpm](https://pnpm.io/workspaces). If you're unfamiliar with any of these technologies, it is useful to learn about them and will make understanding the Near.js codebase easier but strictly not necessary for simple contributions.

The repo contains packages/ directory that contains the Near.js public modules. 
The source code for the provider-rpc API in the Near.js can be found at the location packages/provider-rpc.

### Pull Requests

**Step 1**: Find something to work on

You can find out many issues posted by the community to the [Issues](https://github.com/magic-powered/near.js/issues) tab of the repository.

Choose one by assigning it on your self.

**Step 2**: Fork the repository

Public contributors are not allowed to push anything to the Near.js repository.
To start your contributing you should fork the repo and work inside your own sandbox.

**Step 3**: Do the code magic

Implement your changes. Make sure your changeset comply with the following rules:

1. You code clean, readable and complete.
2. You do not introduce TODO comments.
3. Your code is covered by unit tests.
4. Your code is covered with JSDoc annotations
5. Your code is covered with all necessary guides, manuals and explanations in `./docs` folder. Please refer to [Docsify](http://docsify.js.org) documentation to learn how to structure your documentation

**Step 4**: Push your changes and create Pull Request

Once you're done you may push your code and create the Pull Request.
You should not worry about squashing your changes, the Github can do it for you once PR is approved and merged.

**Step 4.1**: Formatting your PR

- Make sure PR title is meaningful.
- Make sure your PR description is meaningful and reviewer can understand what you did by just reading the description.
- Make sure your PR is linked to the issue you want to address.
- Assign suggested people to review. Assign original issue author as a reviewer.

'''
'''--- docs/getting-started.md ---
# Getting started

## Installation 

```shell
npm i near.js --save
```

```shell
yarn add near.js
```

## Packages

Near.js is a set of independent modules that can be used without installing the whole library.

Each module is available as a separate package under @naer.js namespace:

```shell
npm i @nearjs/provider-rpc --save
```

```shell
yarn add @nearjs/provider-rpc
```

The modular structure allows developers to be more granular building their app. 
Ensure their microservices and micro frontends fetch only essential Near modules.

Learn more about packages [here](./packages.md)

'''
'''--- docs/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta charset="UTF-8">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify/themes/dark.css" />
</head>
<body>
<div id="app"></div>
<script>
  window.$docsify = {
    search: 'auto',
    el: "#app",
    repo: 'https://github.com/magic-powered/near.js/tree/main/docs',
    loadSidebar: true,
    coverpage: true
  }
</script>
<script src="//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-tsx.min.js"></script>
</body>
</html>

'''
'''--- docs/packages.md ---
# Packages

| Name                                                                                    | Description                                                                                              |
|-----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| [@nearjs/account](./packages/account.md)                                               | Provides everything you need to manage accounts: keypair, key store, access key management tools, etc... |
| [@nearjs/browser-key-store](./packages/browser-key-store.md)                           | The implementation of the KeyStore that can store keys in browser local or session store.                |
| [@nearjs/fs-key-store](./packages/fs-key-store.md)                                     | The implementation of the KeyStore that can store keys in local filesystem.                              |
| [@nearjs/provider-core](./packages/provider-core.md)                                   | Core RPC provider. Extend to create your custom providers                                                |
| [@nearjs/provider-wallet-my-near-wallet](./packages/provider-wallet-my-near-wallet.md) | Integration with MyNearWallet.                                                                           |
| [@nearjs/contracts](./packages/contracts.md)                                           | Abstract contract and FT/NFT contracts implementation (NEP-141, NEP-171 NEP-181 NEP-178 NEP-177 NEP-297) |
| [@nearjs/tx](./packages/tx.md)                                                         | Provides typed transaction builder.                                                                      |

Each package includes typescript typings. Can be used for both: javascript and typescript code.

'''
'''--- docs/packages/account.md ---
# @nearjs/account

## Installation

```shell
npm i @nearjs/account --save
```

```shell
yarn add @nearjs/account
```

## About

The package provides several tools helping manage users keys and key pairs

```
.
├── index.ts
├── lib
│   ├── keys
│   │   ├── access-key.ts
│   │   ├── index.ts
│   │   ├── key-pair.ts
│   │   └── keys.ts
│   └── keys-store
│       ├── index.ts
│       ├── inmemory-key-store.ts
│       └── keys-store.ts
├── package.json
└── tsconfig.json
```

### Keys

Contains several classes that manages users keys:

- Access Key - The user's [access key](https://docs.near.org/concepts/basics/accounts/access-keys)
- Keys - Implements Public and Private keys representation
- Key Pair - Container or storage for Public and Private keys pair and access keys

### Keys store

Provides base abstract key store interface for all further implementations of keys stores: fs, browser, inmemmory, etc...
Includes in-memory key store 

#### Usage

```typescript
import {
  InMemoryKeyStore, KeyId, KeyPair
} from '@nearjs/account';

(async () => {
  /**
   * Create the key store object
   */
  const keyStore = new InMemoryKeyStore();

  /**
   * Define the ID of the key
   */
  const keyId = new KeyId('account.near', 'mainnet');

  /**
   * Create new KeyPair and store in the store
   */
  const keyPair = KeyPair.fromRandom();
  await keyStore.addKeyByKeyIdString(keyId, keyPair);

  /**
   * Get existing KeyPair from the store
   */
  const existingKeyPair = await keyStore.getKeyPairByKeyId(keyId);
})();
```

'''
'''--- docs/packages/browser-key-store.md ---
# @nearjs/browser-key-store

## Installation

```shell
npm i @nearjs/browser-key-store --save
```

```shell
yarn add @nearjs/browser-key-store
```

## About

The package provides implementation of KeyStore that can store KeyPair in browser local or session store

## Usage

```typescript
import {
  BrowserKeyStore
} from '@nearjs/browser-key-store';

(async () => {
  /**
   * Create the key store object
   */
  const keyStore = new BrowserKeyStore({
    storage: window.localStorage || window.sessionStorage // you can choose any storage you want
  });

  /**
   * Define the ID of the key
   */
  const keyId = new KeyId('account.near', 'mainnet');

  /**
   * Create new KeyPair and store in the store
   */
  const keyPair = KeyPair.fromRandom();
  await keyStore.addKeyByKeyIdString(keyId, keyPair);

  /**
   * Get existing KeyPair from the store
   */
  const existingKeyPair = await keyStore.getKeyPairByKeyId(keyId);
})();
```

'''
'''--- docs/packages/contracts.md ---
# @nearjs/contracts

## Installation

```shell
npm i @nearjs/contracts --save
```

```shell
yarn add @nearjs/contracts
```

## About

The contracts package provides an abstract Contract class that can be extended to implement your own smart-contract client object.
Used for simplification of the interactions with the contracts deployed to the Near blockchain.

## Usage

The package supports FungibleTokens and NonFungibleTokens standards with folowing NEPs:

- FT: NEP-141
- NFT: NEP-171 NEP-181 NEP-178 NEP-177 NEP-297

### NFT tokens

```typescript
import { FileSystemKeyStore } from '@nearjs/fs-key-store';
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { NonFungibleToken } from '@nearjs/contracts';

const iam = 'toxa.testnet';
const friend = 'toxa02.testnet';
const nftContract = 'toxa.mintspace2.testnet';

(async () => {
  const keyStore = new FileSystemKeyStore();

  const provider = new NearRPCProvider(testnetRPCConfig(keyStore));

  const nft = new NonFungibleToken(nftContract, provider);
  const myTokens = await nft.nftTokensForOwner(iam);

  await nft.nftTransfer(friend, myTokens[0].token_id);

  const myFriendsTokens = await nft.nftTokensForOwner(friend);
})();
```

### FT tokens

```typescript
import { FileSystemKeyStore } from '@nearjs/fs-key-store';
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FungibleToken } from '@nearjs/contracts';

const iam = 'toxa.testnet';
const friend = 'toxa02.testnet';
const ftContract = 'toxa.tokens.testnet';

(async () => {
  const keyStore = new FileSystemKeyStore();

  const provider = new NearRPCProvider(testnetRPCConfig(keyStore));

  const ft = new FungibleToken(nftContract, provider);
  const myTokens = await ft.ftBalanceOf(iam);

  await ft.ftTransfer(friend, 10);

  const myFriendsTokens = await ft.ftBalanceOf(friend);
})();
```

### Defining your custom contract interface

```typescript
import { Contract, NearRPCProvider, testnetRPCConfig } from '@nearjs/contracts';

export class MyCustomSmartContract extends Contract {
  public async myCallFunction1(
    arg1: string,
    arg2: string,
    gasLimit = 300000000000000,
  ) {
    return this.call(
      'my_call_function_1',
      {
        arg1,
        arg2
      },
      gasLimit,
      '1', // define yoctonear deposit if needed
    );
  }

  public async myViewFunction2(arg: string): Promise<{ [key: string]: string }> {
    const result = await this.callView('my_view_function_2', { arg });

    return result.result.parsedResult; // the base class will parse JSON responses for you
  }
}

(async () => {
  const contractAddress = 'some.contract.testnet';
  
  const keyStore = new FileSystemKeyStore();

  const provider = new NearRPCProvider(testnetRPCConfig(keyStore));

  const contract = new MyCustomSmartContract(contractAddress, provider);
  
  await contract.myCallFunction1('foo', 'bar');

  const response = contract.myViewFunction2('foo');
  
  console.log(response);
})();
```

'''
'''--- docs/packages/fs-key-store.md ---
# @nearjs/fs-key-store

## Installation

```shell
npm i @nearjs/fs-key-store --save
```

```shell
yarn add @nearjs/fs-key-store
```

## About

The package provides implementation of KeyStore that can store KeyPair in the local filesystem

## Usage

```typescript
import {
  BrowserKeyStore
} from '@nearjs/fs-key-store';

const keyBasePath = '/some/path';

(async () => {
  /**
   * Create the key store object
   */
  const keyStore = new FileSystemKeyStore({
    keyPath: keyBasePath // base path to the folder where keys will be stored. Homedir used as default
  });

  /**
   * Define the ID of the key
   */
  const keyId = new KeyId('account.near', 'mainnet');

  /**
   * Create new KeyPair and store in the store
   */
  const keyPair = KeyPair.fromRandom();
  await keyStore.addKeyByKeyIdString(keyId, keyPair);

  /**
   * Get existing KeyPair from the store
   */
  const existingKeyPair = await keyStore.getKeyPairByKeyId(keyId);
})();
```

By default, the KeyStore will persist your keys in `.near-keys` folder inside your HOME directory

'''
'''--- docs/packages/provider-core.md ---
# @nearjs/provider-core

Core RPC provider is a client library for Near Blockchain RPC API.
With this library you can query RPC, send View calls and transactions, and operate with connected accounts.

## Installation

```shell
npm i @nearjs/provider-core --save
```

## Usage

### Configuration

```typescript
import { KeyStore } from '@nearjs/account';

type RPCProviderHeadersConfig = { [key: string]: string | number };

enum Network {
  TESTNET = 'testnet',
  MAINNET = 'mainnet',
  BETANET = 'betanet',
  LOCALNET = 'localnet',
  CUSTOM = 'custom',
}

interface RPCProviderConfig {
  rpcUrl: string; // url of Near RCP API
  networkId: Network; // network id: testnet, betanet, mainnet, custom
  allowInsecure?: boolean; // not recomended: allow insecure connection to RPC API 
  timeout?: number; // timeout for RPC requests (default: 30s)
  headers?: RPCProviderHeadersConfig; // headers that should be injected to every RPC call
  keyStore?: KeyStore; // Container for user key pairs and access keys
}
```

Since RPCProviderConfig is just an interface you may construct plain object with this fields and just put it to the provider constructor.

```typescript
import { NearRPCProvider, Network } from '@nearjs/provider-core';

const provider = new NearRPCProvider({
  rpcUrl: 'https://rpc.testnet.near.org',
  networkId: Network.TESTNET
});
```

If you are using default Near networks (localnet, testnet, betanet or mainnet) with default RPC API URLs you may use one of predefined configuration constructors:

```typescript
import { mainnetRPCConfig, betanetRPCConfig, testnetRPCConfig, localnetRPCConfig, NearRPCProvider } from '@nearjs/provider-core';

const mainnetProvider = new NearRPCProvider(mainnetRPCConfig());
const betanetProvider = new NearRPCProvider(betanetRPCConfig());
const testnetProvider = new NearRPCProvider(testnetRPCConfig());
const localnetProvider = new NearRPCProvider(localnetRPCConfig());
```

#### Configuring key stores

Configuration of KeyStore is optional for Near RPC Provider since all query and view calls does not require any access keys.
However, to send transactions you have to sign them using wallet access keys. In order to manage user keys NearJS provides several options to store user's keys:

- [@nearjs/account](./account.md) - InMemoryKeyStore - stores access keys in RAM
- [@nearjs/browser-key-store](./browser-key-store.md) - BrowserKeyStore - store access keys in browser local or session storage
- [@nearjs/fs-key-store](./fs-key-store.md) - FileSystemKeyStore - store access keys in file system

To enable sending transactions using NearRPCProvider you have to set one of KeyStores implementation to the provider configuration, otherwise all transactions sending will throw an error

```typescript
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Instantiate FileSystem KeyStore implementation
  const keyStore = new FileSystemKeyStore();
  
  // use keyStore with testnet configuration
  const config = testnetRPCConfig(keyStore);

  // provide complete configuration to the provider constructor
  const provider = new NearRPCProvider(config);

  // Define actions to execcute. In this case we send 20 toxa tokens to toxa02.testnet address
  const actions = [
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: 'toxa02.testnet',
        amount: '200000000000000000000'
      },
      1,
      1
    )
  ];

  // send transaction successfull 
  const result = await provider.sendTransactionSync('toxa.testnet', 'toxa.tokens.testnet', actions);
})();
```

```typescript
import { NearRPCProvider, testnetRPCConfig, ViewAccount } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // construct testnet configuration without key store
  const config = testnetRPCConfig();

  // provide complete configuration to the provider constructor
  const provider = new NearRPCProvider(config);
  
  // error will be thrown since there is not available key store, so we cannot sign transaction before send
  try {
    const actions = [
      new FunctionCall(
        'ft_transfer',
        {
          receiver_id: 'toxa02.testnet',
          amount: '200000000000000000000'
        },
        1,
        1
      )
    ];
    const result = await provider.sendTransactionSync('toxa.testnet', 'toxa.tokens.testnet', actions);
  } catch (e) { 
    console.error(e)
  }

  // success call since there is no signature required to send view calls
  const result = await provider.sendViewCall('nft.token.testnet', 'nft_tokens_for_owner', {account_id: 'some-user.testnet'});

  // success call since ViewAccount is a query call to RPC node, so no signature required to send this call
  const viewAccountRequest = new ViewAccount('some-user.testnet');
  const userAccountInfo = await provider.sendRPCRequest(viewAccountRequest); 
})();
```

### Operating with connected accounts

NearRPCProvider provides a set of functions that helps you control list of connected accounts and their access keys:

```typescript
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Define that our keys are stored in file system
  const keyStore = FileSystemKeyStore();
  // Construct provider configuration
  const config = testnetRPCConfig(keyStore);
  // Construct RPC Provider
  const provider = new NearRPCProvider(config);
  
  // returns public key for provided user. Return null if no key found
  const publicKey = await provider.getPublicKey('my.account.testnet');
  
  // returns list of connected accounts
  const accountsConnected = await provider.listConnectedAccounts();
  
  // defines if provided account is connected to this provider (can sign on behalf of provided user)
  const isAccountConnected = await provider.isAccountConnected('my.account.testnet');
})();
```

### Sign and verify messages with user keys

Provide can sign random messages with user's keys and verify signatures with provided public key

#### Sign messages

```typescript
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Define that our keys are stored in file system
  const keyStore = FileSystemKeyStore();
  // Construct provider configuration
  const config = testnetRPCConfig(keyStore);
  // Construct RPC Provider
  const provider = new NearRPCProvider(config);
  
  const messageToSign = 'some message';
  // convert string message to bytes to sign them
  const messageBytes = Uint8Array.from(messageToSign.split('').map(letter => letter.charCodeAt(0)));
  
  // sign message bytes with key that correspond to provided user
  const signature = await provider.sign('my.account.testnet', messageBytes);
})();
```

#### Verify signatures

```typescript
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

const message = new Uint8Array();
const signature = new Uint8Array();
const publicKey = new Uint8Array();

(async (message: Uint8Array, signature: Uint8Array, publicKey: Uint8Array) => {
  // Define that our keys are stored in file system
  const keyStore = FileSystemKeyStore();
  // Construct provider configurations
  const config = testnetRPCConfig(keyStore);
  // Construct RPC Provider
  const provider = new NearRPCProvider(config);
  
  // pass message, 
  const isSignatureValid = await provider.verify(message, signature, publicKey);
})(message, signature, publicKey);
```

### Sending transactions

As was mentioned above user's keys required to send any transaction, since sending transactions requires user signature.
Before sending transaction you should build necessary actions that should be executed in your transaction using [@nearjs/tx](./tx.md) module:

```typescript
import { FunctionCall } from '@nearjs/tx';

const action =
  new FunctionCall(
    'ft_transfer', // method name
    { // arguments
      receiver_id: 'toxa02.testnet',
      amount: '200000000000000000000'
    },
    1, // gas limit
    1 // attached Near deposit
  );
```

Learn more about action types and their constructors [here](./tx.md)

Complete example:

```typescript
import { NearRPCProvider, testnetRPCConfig } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Instantiate FileSystem KeyStore implementation
  const keyStore = new FileSystemKeyStore();
  
  // use keyStore with testnet configuration
  const config = testnetRPCConfig(keyStore);

  // provide complete configuration to the provider constructor
  const provider = new NearRPCProvider(config);

  // Define actions to execcute. In this case we send 20 toxa tokens to toxa02.testnet address
  const action =
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: 'toxa02.testnet',
        amount: '200000000000000000000'
      },
      1, // gas limit
      1 // attached Near deposit
    );
  
  // send transaction successfull 
  const result = await provider.sendTransactionSync('toxa.testnet', 'toxa.tokens.testnet', [action]);
})();
```

### Sending RPC queries

You can send RPC queries to the RPC API by using `sendRPCRequest` method:

```typescript
import { NearRPCProvider, testnetRPCConfig, ViewAccessKey, ViewAccount } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Instantiate FileSystem KeyStore implementation
  const keyStore = new FileSystemKeyStore();

  // use keyStore with testnet configuration
  const config = testnetRPCConfig(keyStore);

  // provide complete configuration to the provider constructor
  const provider = new NearRPCProvider(config);

  // Build ViewAccount query
  const viewAccount = new ViewAccount('my.account.testnet');
  // send query 
  const account = await provider.sendRPCRequest(viewAccount);
})();
```

You can query account state, account keys, block height and any other queries supported by Near RPC provider. 

### Sending view requests to your contracts

To send view call you can use one of: 
- `sendRPCRequest` - low level API for RPC query calls
- `sendViewCall` - special API for view calls

```typescript
import { NearRPCProvider, testnetRPCConfig, ViewAccessKey, ViewAccount } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // Instantiate FileSystem KeyStore implementation
  const keyStore = new FileSystemKeyStore();

  // use keyStore with testnet configuration
  const config = testnetRPCConfig(keyStore);

  // provide complete configuration to the provider constructor
  const provider = new NearRPCProvider(config);
  
  // send view call to see amount of tokens of user 
  const amountOfTokens = await provider.sendViewCall('toxa.tokens.testnet', 'ft_balance_of', { account_id: 'toxa.testnet' });
})();
```

## Dynamic annotations

The provider class support dynamic type annotations meaning that return type of RPC request is defined on the flight by the `sendRPCRequest` input argument:

For example, if you send BroadcastTX request, the result field will be typed as string

![Showcase of BroadcastTX result](../resources/broadcast-tx-annotation.png)

If you send ViewAccount request, the result field will be typed as a ViewAccountResult object

![Showcase of ViewAccount result](../resources/viewaccount-annotation.png)

Dynamic signature supported by majority of javascript IDE, if you have any troubles with it don't hesitate to open new issue on our GitHub :) 

'''
'''--- docs/packages/provider-wallet-my-near-wallet.md ---
# @nearjs/provider-wallet-my-near-wallet

## Installation

```shell
npm i @nearjs/provider-wallet-my-near-wallet --save
```

```shell
yarn add @nearjs/provider-wallet-my-near-wallet
```

## Usage

Provides the full integration with MyNearWallet.
Extends [@nearjs/provider-core](./provider-core.md) - refer to the provider-core documentation for detailed manual

### Connect account

```typescript
import { BrowserKeyStore } from '@nearjs/browser-key-store';
import { ProviderMyNearWallet, getConfiguration } from '@nearjs/provider-wallet-my-near-wallet';

(async () => {
  // define keystore - the place where account key pairs are stored
  // you can provide any key store for your usecase: fs-key-store, in-memmory-keystore or browser one
  const keyStore = new BrowserKeyStore();

  // if you are using default RPC endpoints and 
  // default Near networks (testnet, betanet, mainnet), you can use 'getConfiguration' function provided with the package
  // otherwise you have to provide your own configuration object that extends MyNearWalletConfiguration interface
  const providerConfig = getConfiguration(Network.TESTNET, keyStore);

  // Instantiate MyNearWallet provider class
  const provider = new ProviderMyNearWallet(providerConfig);
  
  // this function should be called twice. 
  // The first call will open browser window that promts user login with your dApp
  // The second call will complete authorization. The second call should be called when user lands to the callback url after login.
  await provider.connectAccount({
    contractId: 'toxa.tokens.testnet',
    methodNames: ['ft_transfer']
  });
})();
```

#### Connect account options

You can ask user to login with limited access, 
to only your contract and defined methods on it by providing contract address and methodNames that app should be able to call on behalf of user.

```typescript
await provider.connectAccount({
    contractId: 'toxa.tokens.testnet',
    methodNames: ['ft_transfer']
  });
```

Also, you can request FullAccess key from the user to be able to send any rpc call to the blockchain on behalf of user:

```typescript
await provider.connectAccount({
    fullAccess: true
  });
```

### Sending transactions

```typescript
import { BrowserKeyStore } from '@nearjs/browser-key-store';
import { ProviderMyNearWallet, getConfiguration } from '@nearjs/provider-wallet-my-near-wallet';
import { FunctionCall } from '@nearjs/tx'

(async () => {
  // define keystore - the place where account key pairs are stored
  // you can provide any key store for your usecase: fs-key-store, in-memmory-keystore or browser one
  const keyStore = new BrowserKeyStore();

  // if you are using default RPC endpoints and 
  // default Near networks (testnet, betanet, mainnet), you can use 'getConfiguration' function provided with the package
  // otherwise you have to provide your own configuration object that extends MyNearWalletConfiguration interface
  const providerConfig = getConfiguration(Network.TESTNET, keyStore);
  
  const provider = new ProviderMyNearWallet(providerConfig);

  // Define actions to execcute. In this case we send 20 toxa tokens to toxa02.testnet address
  const actions = [
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: 'toxa02.testnet',
        amount: '200000000000000000000'
      },
      1,
      1
    )
  ];

  const result = await provider.sendTransactionSync('toxa.testnet', 'toxa.tokens.testnet', actions);
})();
```

Since MyNearWallet provides both: FullAccess and LimitedAccessKeys with network allowance your app can send direct RPC calls to the blockchain omitting opening wallet webpage.
Direct RPC calls can be executed only if:

- Your app has FullAccess key of the user
- Your app has LimitedAccessKey of the user, transaction does not require Near deposit to the transaction and there is enough network allowance to execute the transaction

MyNearWallet provider implements `sendTransactionSync` method in a way that it checks if it able to send direct RPC call and if it cannot it fallback to opening MyNearWallet window.

You can restrict library opening MyNearWallet webpage by providing `blockPopupFallback` option to the provider constructor

```typescript
import { BrowserKeyStore } from '@nearjs/browser-key-store';
import { ProviderMyNearWallet, getConfiguration } from '@nearjs/provider-wallet-my-near-wallet';
import { FunctionCall } from '@nearjs/tx'

(async () => {
  const keyStore = new BrowserKeyStore();

  const providerConfig = getConfiguration(Network.TESTNET, keyStore);
  providerConfig.blockPopupFallback = true; // prevent provider open MyNearWallet webpage

  const provider = new ProviderMyNearWallet(providerConfig);

  // Define actions to execcute. In this case we send 20 toxa tokens to toxa02.testnet address
  const actions = [
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: 'toxa02.testnet',
        amount: '200000000000000000000'
      },
      1,
      1
    )
  ];

  // this line throw an error because there is not FullAccess key provided for the user 'toxa.testnet'
  const result = await provider.sendTransactionSync('toxa.testnet', 'toxa.tokens.testnet', actions);
})();
```

In this case `sendTransactionSync` will throw an error if there is no FullAccessKey for the user or transaction require non-zero deposit to be attached

You might find this useful when you implement backend service/cronjobs/etc where opening browser window does not make sense.

### Account operation, view calls, query calls, etc...

Since MyNearWallet provider extends core NearRPCProvider it support the same functionality as that. [Learn more](./provider-core.md)

'''
'''--- docs/packages/tx.md ---
# @nearjs/tx

## Installation

```shell
npm i @nearjs/tx --save
```

## Usage

**@nearjs/tx** package provides necessary classes and builders to build transactions that can be sent to the RPC API using [RPC provider](./provider-core.md)

### Actions

Action is an object in Near RPC API that defines what exactly transaction should execute. There is a [different types of actions](https://nomicon.io/RuntimeSpec/Actions).

#### Action builder 

Each action is represented as a simple class that can be build by calling it's constructor:

```typescript
import { Transfer } from '@nearjs/tx';

const amountToTransferInYoctoNear = 1000000000000;

const transferNearAction = new Transfer(amountToTransferInYoctoNear);
```

```typescript
import { FunctionCall } from '@nearjs/tx';

const callFunctionAction = new new FunctionCall(
  'ft_transfer', // smart contract method name: transfer token
  { // arguments
    receiver_id: receiverId, // token receiver
    amount: '1000000000000000000', // 1 token
  },
  300000000000000, // gas limit
  '1' // deposit (required for all ft transfer calls)
);
```

@nearjs/tx support all actions that [supported by Near RPC API](https://nomicon.io/RuntimeSpec/Actions)

### Transaction builder

The transaction itself is a complex object with a big amount of fields.
The tx package provides `TransactionBuilder` class which helps build transaction in easy, robust and typed way.

```typescript
import { TransactionBuilder, Transfer } from '@nearjs/tx';
import { KeyPair } from '@nearjs/keys';

const keyPair = KeyPair.fromRandom();

const transaction = TransactionBuilder.builder()
  .withNonce(1)
  .addAction(new Transfer(100))
  .withReceiverId('receiver.testnet')
  .withSignerId('signer.testnet')
  .withPublicKey(keyPair.getPublicKey())
  .build();

const signedTransaction = keyPair.sign(transaction.toBorsh());
```

It is possible to add multiple actions to the transaction using builder. There are two ways doing that:

```typescript
import { Stake, TransactionBuilder, Transfer } from '@nearjs/tx';
import { KeyPair } from '@nearjs/keys';

const keyPair = KeyPair.fromRandom();

const transactionBuilder = TransactionBuilder.builder()
  .withNonce(1)
  .withReceiverId('receiver.testnet')
  .withSignerId('signer.testnet')
  .withPublicKey(keyPair.getPublicKey());

// append actions to the builder object one by one
transactionBuilder.addAction(new Transfer(100));
transactionBuilder.addAction(new Stake(100, keyPair.getPublicKey()));

const signedTransaction = keyPair.sign(transactionBuilder.build().toBorsh());
```

```typescript
import { TransactionBuilder, Transfer } from '@nearjs/tx';
import { KeyPair } from '@nearjs/keys';

const keyPair = KeyPair.fromRandom();

const transactionBuilder = TransactionBuilder.builder()
  .withNonce(1)
  .withReceiverId('receiver.testnet')
  .withSignerId('signer.testnet')
  .withPublicKey(keyPair.getPublicKey());

// append actions to the builder object all at once
transactionBuilder.addActions([new Transfer(100), new Stake(100, keyPair.getPublicKey())])

const signedTransaction = keyPair.sign(transactionBuilder.toBorsh());
```

'''
'''--- docs/page-1.md ---
# Page 1

rtertetr

'''
'''--- docs/quick-start/backend.md ---
# NearJS for backend applications

This section describes how use NearJS with your backend application to integrate with Near blockchain

## Installation

```
$ npm install --save @nearjs/backend
```

**@nearjs/backend** package includes three essential packages:

- [@nearjs/account](../packages/account.md) - base library for account / encryption keys and access keys
- [@nearjs/fs-key-store](../packages/fs-key-store.md) - file system storage wrapper for KeyPair storage
- [@nearjs/provider-core](../packages/provider-core) - Near provider - provide Near API client

you can extend your setup with any other package you might need by simple installation them into your app 

## Example usage

You backend application should have full access key to be able to perform transactions to the Near Blockchain.

By default, FileSystemKeyStore expect `~/.near-keys` folder where key pair files are stored.
All key pairs from the folder will be automatically loaded to the provider and will be used to sign transactions.

```typescript
import { NearRPCProvider, testnetRPCConfig, FileSystemKeyStore } from '@nearjs/bakend';

(async () => {
  // Define that our keys are stored in file system
  const keyStore = FileSystemKeyStore();
  // Construct provider configuration
  const config = testnetRPCConfig(keyStore);
  // Construct RPC Provider
  const provider = new NearRPCProvider(config);

  // returns public key for provided user. Return null if no key found
  const publicKey = await provider.getPublicKey('my.account.testnet');

  // Define actions to execcute. In this case we send 20 tokens to toxa02.testnet address
  const action =
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: 'toxa02.testnet',
        amount: '200000000000000000000'
      },
      1, // gas limit
      1 // attached Near deposit
    );
  
  const sender = 'toxa.testnet';
  const tokenContractAddress = 'toxa.tokens.testnet';

  // send transaction
  const result = await provider.sendTransactionSync(sender, tokenContractAddress, [action]);
})();
```

However, it is not required to provide any keys or keystore to use Near RPC API and API Provider. If you not configure key store or not configure key pair files in the store you still able to send all RPC requests excluding transactions.

```typescript
import { NearRPCProvider, testnetRPCConfig, ViewAccessKey, ViewAccount } from '@nearjs/provider-core';
import { FileSystemKeyStore } from '@nearjs/fs-key-store';

(async () => {
  // testnet configuration without key store
  const config = testnetRPCConfig();

  // provide configuration to the provider constructor without key store
  // provider now works in readonly mode
  const provider = new NearRPCProvider(config);

  // Build ViewAccount query
  const viewAccount = new ViewAccount('my.account.testnet');
  // send query 
  const account = await provider.sendRPCRequest(viewAccount);
})();
```

[Learn more](../packages/provider-core.md) about more use cases in @nearjs/provider-core documentation page  

'''
'''--- docs/quick-start/cli.md ---
# NearJS for cli applications

This section describes how use NearJS with your cli application to integrate with Near blockchain

## Installation

```
$ npm install --save @nearjs/cli
```

**@nearjs/cli** package includes three essential packages:

- [@nearjs/account](../packages/account.md) - base library for account / encryption keys and access keys
- [@nearjs/fs-key-store](../packages/fs-key-store.md) - file system storage wrapper for KeyPair storage
- [@nearjs/provider-my-near-wallet](../packages/provider-my-near-wallet) - Near provider - provide Near API client and MyNearWallet integration

you can extend your setup with any other package you might need by simple installation them into your app

## Example

**@nearjs/cli** package provides all necessary modules and classes aimed to hel developers build their own cli tools.

```typescript
import { Command } from "commander";
import * as fs from "fs";
import * as path from "path";
import * as figlet from "figlet";
import { mainnetRPCConfig } from '@nearjs/cli';

const program = new Command();

console.log(figlet.textSync("NEAR Token Console"));

program
  .version("1.0.0")
  .description("An example CLI for sending tokens in Near Blockchain")
  .option("-t, --token  <value>", "Smart contract address")
  .option("-a, --amount <value>", "Amount of tokens to send")
  .option("-r, --receiver <value>", "Token receiver address")
  .option("-s, --sender <value>", "Token sender address. Account should be connected")
  .option("-n, --network <value>", "Near network ID: testnet or mainnet")
  .parse(process.argv);

const options = program.opts();

(async () => {
  // Define that our keys are stored in file system
  const keyStore = FileSystemKeyStore();
  // Construct provider configuration based on provided input
  const config = options.network === 'mainnet' ? mainnetRPCConfig(keyStore) : testnetRPCConfig(keyStore);
  // Construct RPC Provider
  const provider = new NearRPCProvider(config);

  // returns public key for provided user. Return null if no key found
  const publicKey = await provider.getPublicKey(options.sender);

  // Define actions to execcute. In this case we send 20 tokens to toxa02.testnet address
  const action =
    new FunctionCall(
      'ft_transfer',
      {
        receiver_id: options.receiver,
        amount: options.amount
      },
      3000000000, // gas limit
      1 // attached Near deposit
    );

  const sender = options.sender;
  const tokenContractAddress = options.token;

  // send transaction
  const result = await provider.sendTransactionSync(sender, tokenContractAddress, [action]);
})();
```

## Connecting account and receiving access keys

In order to authenticate with your account you can use `login` function provided by the package:

```typescript
import { Command } from "commander";
import * as figlet from "figlet";
import { FileSystemKeyStore, getConfiguration, login, Network, ProviderMyNearWallet } from '@nearjs/cli';

const program = new Command();

console.log(figlet.textSync("NEAR Token Console"));

program
  .version("1.0.0")
  .description("An example CLI for sending tokens in Near Blockchain")
  .command('login')
  .action(async () => {
    // Define that our keys are stored in file system
    const keyStore = new FileSystemKeyStore();
    // Construct provider configuration based on provided input
    const config = getConfiguration(Network.TESTNET, keyStore);
    // Construct RPC Provider
    const provider = new ProviderMyNearWallet(config);

    const accountId = await login(provider, keyStore);

    console.log(`Welcome, ${accountId}!`);
  })
  .parse(process.argv);
```

'''
'''--- docs/quick-start/web.md ---
# NearJS for frontend applications

This section describes how use NearJS with your frontend application to integrate with Near blockchain

## Installation 

```
$ npm install --save @nearjs/web
```

**@nearjs/web** package includes three essential packages:

- [@nearjs/account](../packages/account.md) - base library for account / encryption keys and access keys
- [@nearjs/browser-key-store](../packages/browser-key-store.md) - browser local or session storage wrapper for KeyPair storage 
- [@nearjs/provider-wallet-my-near-wallet](../packages/provider-wallet-my-near-wallet.md) - Near provider - provide Near API and MyNearWallet integration
  
you can extend your setup with any other package you might need by simple installation them into your app

## Example usage

```typescript
import { ProviderMyNearWallet, getConfiguration, Network, BrowserKeyStore } from '@nearjs/web'
import { useEffect, useState } from 'react';

export const MyNearComponent = ({
                                  contractId,
                                  methodNames
                                }) => {
  const [accountId, setAccountId] = useState(null);
  const [receiver, setReceiver] = useState(null);
  
  // create BrowserKeyStore - wrap around browser's localstorage
  const keyStore = new BrowserKeyStore();
  
  // create Near provider. Specify that we use testnet environment and our browser key store
  const provider = new ProviderMyNearWallet(getConfiguration(Network.TESTNET, keyStore));

  // Connect user's wallet account to your frontend application
  useEffect(() => {
    (async () => {
      // Check if account already connected
      const accountConnected = await provider.listConnectedAccounts();
      if (accountConnected.length) {
        return; // do not proceed if user already connected their account
      }

      // This will open MyNearWallet webpage that will ask user to approve login
      // This should be called second time after redirect user to the page to complete authentication.
      const connectedAccountId = await provider.connectAccount({ contractId, methodNames });
      setAccountId(connectedAccountId);
    })();
  }, [provider]);

  const send = async () => {
    // we need construct action object to let blockchain know what transaction it shoul execute
    const action = new FunctionCall(
      'ft_transfer', // smart contract method name: transfer token
      { // arguments
        receiver_id: receiverId, // token receiver
        amount: '1000000000000000000', // 1 token
      },
      300000000000000, // gas limit
      '1' // deposit (required for all ft transfer calls)
    );
    
    // Only FullAccess keys can send RPC calls directly.
    // If MyNearWallet provider finds fullaccess key it will call 
    // Near RPC endpoint directly with no additional wallet approval step.
    // Otherwise, if you operate with limitted access keys it will 
    // open MyNearWallet webpage and ask user to approve transaction.
    await this.provider.sendTransactionSync(
      accountId, // current user account 
      contractId, // address of token smart contract
      [action], // action to execute (ft_transfer)
    );
    
    alert('done!');
  }
  
  if (!accountId) {
    return (
      <div id="my-near-component">
        Please wait until you be redirected to the wallet for login...
      </div>
    );
  }

  return (
    <div id="my-near-component">
      <input onchange={setReceiver} />
      <button onClick={send}>Send 1 token</button>
    </div>
  );
}
```

'''
'''--- docs/roadmap.md ---
# Near.js roadmap

<table>
  <thead>
    <tr>
      <th>Milestone</th>
      <th>Feature</th>
      <th>Description</th>
      <th>Status/ETA</th>
    </tr>
  </thead>
<tbody>
  <tr>
    <td rowspan="3">m0</td>
    <td>Repo setup</td>
    <td>Setup the repo and initial repo structure</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Start Typescript project.</td>
    <td>Setup monorepo and necessary configuration: build, lint, githooks, monorepo engine, etc</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Build pipeline</td>
    <td>Rollup configuration. NPm publish pipeline. Github Actions</td>
    <td>80%</td>
  </tr>

  <tr>
    <td rowspan="5">m1</td>
    <td>Architecture and Documentation</td>
    <td>Design for library architecture and documentation: Readme, architecture, getting started, packages and roadmap documents</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Development for Wallet Providers</td>
    <td>Implement base classes for wallet providers, MyNearWallet integration and Sender wallet integration</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Web API </td>
    <td>A package that includes wallet integration and necessary tools for the UI applications building</td>
    <td>done</td>
  </tr>
  <tr>
    <td>RPC providers</td>
    <td>RPC API provider and contract interfaces for common NEPs</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Helper modules</td>
    <td>Implement "rates" and "units" package</td>
    <td>done</td>
  </tr>
  
  <tr>
    <td rowspan="3">m2</td>
    <td>CLI tool</td>
    <td>CLI interface: CLI tool and API to let developers build their own CLI</td>
    <td>done</td>
  </tr>
  <tr>
    <td>API doc</td>
    <td>API doc reference and documentation website</td>
    <td>done</td>
  </tr>
  <tr>
    <td>Version 1.0 Launch</td>
    <td>Version 1.0 Launch</td>
    <td>80%</td>
  </tr>
</tbody>
</table>

'''
'''--- package.json ---
{
  "name": "nearjs",
  "version": "1.0.2",
  "author": "Anatolii Petrovskyi <anatolii@magicpowered.io>",
  "license": "MIT",
  "engines": {
    "node": ">=18",
    "pnpm": ">=7"
  },
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && pnpm run build:workspaces",
    "build:workspaces": "pnpm --stream -r run build",
    "prepublishOnly": "pnpm build",
    "lint": "eslint . --ext ts --fix",
    "prepare": "husky install",
    "preinstall": "npx only-allow pnpm"
  },
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "devDependencies": {
    "@babel/parser": "^7.19.6",
    "@babel/types": "^7.19.4",
    "@changesets/cli": "^2.26.1",
    "@types/node": "^18.8.3",
    "@typescript-eslint/eslint-plugin": "^5.41.0",
    "@typescript-eslint/parser": "^5.41.0",
    "eslint": "^8.26.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.0.0",
    "eslint-plugin-import": "^2.26.0",
    "husky": "^8.0.1",
    "typescript": "^4.8.4"
  },
  "packageManager": "pnpm@7.15.0"
}

'''
'''--- packages/account/index.ts ---
export * from './lib/keys';
export * from './lib/keys-store';

'''
'''--- packages/account/lib/keys-store/index.ts ---
export * from './keys-store';
export * from './inmemory-key-store';

'''
'''--- packages/account/lib/keys-store/inmemory-key-store.ts ---
import { KeyIdString, KeyStore } from './keys-store';
import { KeyPair } from '../keys';

export class InMemoryKeyStore extends KeyStore {
  private readonly keyStore: { [key: KeyIdString]: KeyPair } = {};

  protected async getKey(keyIdString: KeyIdString): Promise<KeyPair> {
    if (!this.keyStore[keyIdString]) {
      throw new Error(`Key ${keyIdString} not found`);
    }

    return this.keyStore[keyIdString];
  }

  protected async storeKey(keyIdString: KeyIdString, keyPair: KeyPair): Promise<void> {
    this.keyStore[keyIdString] = keyPair;
  }

  public async listKeys(): Promise<KeyIdString[]> {
    return Object.keys(this.keyStore);
  }

  protected async deleteKey(keyIdString: KeyIdString): Promise<void> {
    if (!this.keyStore[keyIdString]) {
      return;
    }

    delete this.keyStore[keyIdString];
  }
}

'''
'''--- packages/account/lib/keys-store/keys-store.ts ---
import { KeyPair } from '../keys';

export type KeyIdString = string;

const KeyIdPartsDelimiter = '::';

export class KeyId {
  private readonly accountId: string;

  private readonly networkId: string; // TODO: make enum

  constructor(accountId: string, networkId: string) {
    this.accountId = accountId;
    this.networkId = networkId;
  }

  public toString() {
    return `${this.accountId}${KeyIdPartsDelimiter}${this.networkId}`;
  }

  public static fromString(keyIdString: KeyIdString): KeyId {
    KeyId.validateKeyIdStringOrThrow(keyIdString);

    // TODO: introduce parse function
    const [accountId, networkId] = keyIdString.split('.');

    return new KeyId(accountId, networkId);
  }

  public static validateKeyIdString(keyIdString: KeyIdString) {
    return keyIdString.indexOf(KeyIdPartsDelimiter) !== -1;
  }

  public static validateKeyIdStringOrThrow(keyIdString: KeyIdString) {
    if (!KeyId.validateKeyIdString(keyIdString)) {
      throw new Error('Invalid key id'); // TODO: make good errors
    }
  }

  public static extractAccountId(keyIdString: KeyIdString): string {
    if (!KeyId.validateKeyIdString(keyIdString)) {
      throw new Error('Invalid key id'); // TODO: make good errors
    }

    // TODO: introduce parse function
    return keyIdString.split(KeyIdPartsDelimiter)[0];
  }
}

export abstract class KeyStore {
  public addKeyByKeyId(keyId: KeyId, keyPair: KeyPair): Promise<void> {
    return this.addKeyByKeyIdString(keyId.toString(), keyPair);
  }

  public addKeyByKeyIdString(keyIdString: KeyIdString, keyPair: KeyPair): Promise<void> {
    KeyId.validateKeyIdStringOrThrow(keyIdString);
    return this.storeKey(keyIdString, keyPair);
  }

  protected abstract storeKey(keyIdString: KeyIdString, keyPair: KeyPair): Promise<void>;

  public getKeyPairByKeyId(keyId: KeyId): Promise<KeyPair> {
    return this.getKeyPairByKeyIdString(keyId.toString());
  }

  public getKeyPairByKeyIdString(keyIdString: KeyIdString): Promise<KeyPair> {
    KeyId.validateKeyIdStringOrThrow(keyIdString);
    return this.getKey(keyIdString);
  }

  public deleteKeyPairByKeyId(keyId: KeyId): Promise<void> {
    return this.deleteKeyPairByKeyIdString(keyId.toString());
  }

  public deleteKeyPairByKeyIdString(keyIdString: KeyIdString): Promise<void> {
    KeyId.validateKeyIdStringOrThrow(keyIdString);
    return this.deleteKey(keyIdString);
  }

  protected abstract deleteKey(keyIdString: KeyIdString): Promise<void>;

  protected abstract getKey(keyIdString: KeyIdString): Promise<KeyPair>;

  public abstract listKeys(): Promise<KeyIdString[]>;
}

'''
'''--- packages/account/lib/keys/access-key.ts ---
import BN from 'bn.js';
import {
  field, option, variant, vec,
} from '@dao-xyz/borsh';

export abstract class AccessKeyPermission {}

@variant(0)
export class FullAccess extends AccessKeyPermission {

}

@variant(1)
export class FunctionCallPermission {
  /// Allowance is a balance limit to use by this access key to pay for function call gas and
  /// transaction fees. When this access key is used, both account balance and the allowance is
  /// decreased by the same value.
  /// `None` means unlimited allowance.
  /// NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
  /// access key should be created.
  @field({ type: option('u128') })
    allowance?: BN;

  /// The access key only allows transactions with the given receiver's account id.
  @field({ type: 'string' })
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
    receiver_id: string;

  /// A list of method names that can be used. The access key only allows transactions with the
  /// function call of one of the given method names.
  /// Empty list means any method name can be used.
  @field({ type: vec('string') })
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
    method_names: string[];

  constructor(allowance: string, receiver_id: string, method_names: string[]) {
    this.allowance = new BN(allowance);
    this.receiver_id = receiver_id;
    this.method_names = method_names;
  }
}

export const serializeAccessKeyPermission = (accessKeyPermission: AccessKeyPermission): string => {
  let accessKeyString = '';
  if (accessKeyPermission instanceof FunctionCallPermission) {
    accessKeyString = JSON.stringify({
      type: FunctionCallPermission.name,
      allowance: accessKeyPermission.allowance,
      receiverId: accessKeyPermission.receiver_id,
      methodNames: accessKeyPermission.method_names,
    });
  } else {
    accessKeyString = JSON.stringify({
      type: FullAccess.name,
    });
  }

  return Buffer.from(accessKeyString).toString('base64');
};

export const deserializePermission = (
  serializedAccessKeyPermission: string,
): AccessKeyPermission => {
  const obj = JSON.parse(Buffer.from(serializedAccessKeyPermission, 'base64').toString());

  if (obj.type === FunctionCallPermission.name) {
    return new FunctionCallPermission(obj.allowance, obj.receiverId, obj.methodNames);
  }

  if (obj.type === FullAccess.name) {
    return new FullAccess();
  }

  throw new Error(`Invalid Access Key Permission${serializedAccessKeyPermission}`);
};

export class AccessKey {
  /// The nonce for this access key.
  /// NOTE: In some cases the access key needs to be recreated. If the new access key reuses the
  /// same public key, the nonce of the new access key should be equal to the nonce of the old
  /// access key. It's required to avoid replaying old transactions again.
  @field({ type: 'u64' })
  public nonce: number;

  /// Defines permissions for this access key.
  @field({ type: AccessKeyPermission })
  readonly permission: AccessKeyPermission;

  constructor(nonce: number, permission: AccessKeyPermission) {
    this.nonce = nonce;
    this.permission = permission;
  }

  public getAndIncrementNonce() {
    this.nonce += 1;
    return this.nonce;
  }

  public setNonce(newNonce: number) {
    this.nonce = newNonce;
  }

  public toString() {
    return Buffer.from(
      JSON.stringify({
        nonce: this.nonce,
        permission: serializeAccessKeyPermission(this.permission),
      }),
    ).toString('base64');
  }

  public static fromString(accessKey: string): AccessKey {
    const obj = JSON.parse(Buffer.from(accessKey, 'base64').toString());

    return new AccessKey(obj.nonce, deserializePermission(obj.permission));
  }
}

'''
'''--- packages/account/lib/keys/index.ts ---
export * from './access-key';
export * from './key-pair';
export * from './keys';

'''
'''--- packages/account/lib/keys/key-pair.ts ---
import { sign } from 'tweetnacl';
import buffer from 'buffer/';
import { KeyType, PrivateKey, PublicKey } from './keys';
import { AccessKey, FullAccess } from './access-key';

if (typeof window !== 'undefined') {
  window.Buffer = window.Buffer || buffer.Buffer;
}

export class KeyPair {
  private readonly publicKey: PublicKey;

  private readonly privateKey: PrivateKey;

  private accessKey?: AccessKey;

  private nonce: number;

  constructor(
    privateKey: PrivateKey,
    publicKey: PublicKey,
    accessKey?: AccessKey,
    nonce?: number,
  ) {
    this.privateKey = privateKey;
    this.publicKey = publicKey;
    this.accessKey = accessKey;
    this.nonce = nonce || 0;
  }

  public getAndIncrementNonce() {
    if (this.accessKey) {
      return this.accessKey.getAndIncrementNonce();
    }

    this.nonce += 1;
    return this.nonce;
  }

  public setNonce(newNonce: number) {
    if (this.accessKey) {
      this.accessKey.setNonce(newNonce);

      return;
    }

    this.nonce = newNonce;
  }

  public setAccessKey(accessKey: AccessKey) {
    this.accessKey = accessKey;
  }

  public isFullAccessKey() {
    if (!this.accessKey) {
      return false;
    }

    return this.accessKey.permission instanceof FullAccess;
  }

  public iterateNonce() {
    if (!this.accessKey) {
      throw new Error(`Access key is missing for key ${this.publicKey.toString()}`);
    }
    this.accessKey.nonce += 1;
    return this.accessKey.nonce;
  }

  public sign(message: Uint8Array): Uint8Array {
    return sign.detached(message, this.privateKey.data);
  }

  public verify(message: Uint8Array, signature: Uint8Array) {
    return sign.detached.verify(message, signature, this.publicKey.data);
  }

  public static verifyWithPublicKey(
    message: Uint8Array,
    signature: Uint8Array,
    publicKey: Uint8Array,
  ) {
    return sign.detached.verify(message, signature, publicKey);
  }

  public getPublicKey(): PublicKey {
    return this.publicKey;
  }

  public getPrivateKey(): PrivateKey {
    return this.privateKey;
  }

  public toJsonString(): string {
    return JSON.stringify({
      publicKey: this.publicKey.toString(),
      privateKey: this.privateKey.toString(),
      accessKey: this.accessKey?.toString(),
      nonce: this.nonce,
    });
  }

  public static fromJson(keyPairJsonString: string): KeyPair {
    try {
      const parsed = JSON.parse(keyPairJsonString);

      const privateKey = PrivateKey.fromString(parsed.privateKey);
      const publicKey = PublicKey.fromString(parsed.publicKey);
      const accessKey = parsed.accessKey ? AccessKey.fromString(parsed.accessKey) : undefined;
      const nonce = parsed.nonce || 0;

      return new KeyPair(
        privateKey,
        publicKey,
        accessKey,
        nonce,
      );
    } catch (e) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      throw new Error(e);
    }
  }

  public toBase64JsonString(): string {
    return Buffer.from(this.toJsonString()).toString('base64');
  }

  public static fromBase64JsonString(base64JsonString: string): KeyPair {
    return KeyPair.fromJson(Buffer.from(base64JsonString, 'base64').toString());
  }

  public static fromRandom(keyType: KeyType = KeyType.ED25519): KeyPair {
    const keypair = sign.keyPair();

    return new KeyPair(
      new PrivateKey(keypair.secretKey, keyType),
      new PublicKey(keypair.publicKey, keyType),
    );
  }

  public static fromPrivate(privateKey: PrivateKey, keyType: KeyType = KeyType.ED25519): KeyPair {
    const keypair = sign.keyPair.fromSecretKey(privateKey.data);

    return new KeyPair(
      new PrivateKey(keypair.secretKey, keyType),
      new PublicKey(keypair.publicKey, keyType),
    );
  }

  public static fromSeed(seed: string, keyType: KeyType = KeyType.ED25519): KeyPair {
    const keyPair = sign.keyPair.fromSeed(new TextEncoder().encode(seed));

    return new KeyPair(
      new PrivateKey(keyPair.secretKey, keyType),
      new PublicKey(keyPair.publicKey, keyType),
    );
  }
}

'''
'''--- packages/account/lib/keys/keys.ts ---
import { field, fixedArray } from '@dao-xyz/borsh';

// TODO: typings
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { binary_to_base58 as toBase58, base58_to_binary as fromBase58 } from 'base58-js';

export enum KeyType {
  ED25519 = 0,

  UNKNOWN = 999,
}

export const keyTypeToString = (keyType: KeyType): string => {
  switch (keyType) {
    case KeyType.ED25519:
      return 'ED25519';
    default:
      return 'unknown';
  }
};

export const stringToKeyType = (keyTypeString: string): KeyType => {
  switch (keyTypeString.toLowerCase()) {
    case 'ed25519':
      return KeyType.ED25519;
    default:
      return KeyType.UNKNOWN;
  }
};

export interface IKey {
  keyType: KeyType;

  data: Uint8Array;

  toString(): string;
}

export class PublicKey implements IKey {
  @field({ type: 'u8' })
  readonly keyType: KeyType;

  @field({ type: fixedArray('u8', 32) })
  readonly data: Uint8Array;

  constructor(data: Uint8Array, keyType = KeyType.ED25519) {
    this.data = data;
    this.keyType = keyType;
  }

  public toString(): string {
    const b58String = toBase58(this.data);
    return `${keyTypeToString(this.keyType)}:${b58String}`;
  }

  public static fromString(keyString: string): PublicKey {
    const [keyTypeString, keyBase58String] = keyString.split(':');

    if (!keyTypeString || !keyBase58String) {
      throw new Error(`Cannot reconstruct public key: ${keyString}`);
    }

    const keyType = stringToKeyType(keyTypeString);

    if (keyType === KeyType.UNKNOWN) {
      throw new Error(`Unsupported public key type ${keyTypeString}`);
    }

    const keyData = fromBase58(keyBase58String);

    return new PublicKey(keyData, keyType);
  }
}

export class PrivateKey implements IKey {
  readonly keyType: KeyType;

  readonly data: Uint8Array;

  constructor(data: Uint8Array, keyType = KeyType.ED25519) {
    this.data = data;
    this.keyType = keyType;
  }

  public toString(): string {
    const b58String = toBase58(this.data);
    return `${keyTypeToString(this.keyType)}:${b58String}`;
  }

  public static fromString(keyString: string): PrivateKey {
    const [keyTypeString, keyBase58String] = keyString.split(':');

    if (!keyTypeString || !keyBase58String) {
      throw new Error(`Cannot reconstruct private key: ${keyString}`);
    }

    const keyType = stringToKeyType(keyTypeString);

    if (keyType === KeyType.UNKNOWN) {
      throw new Error(`Unsupported private key type ${keyTypeString}`);
    }

    const keyData = fromBase58(keyBase58String);

    return new PrivateKey(keyData, keyType);
  }
}

'''
'''--- packages/account/package.json ---
{
  "name": "@nearjs/account",
  "version": "1.1.1",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@dao-xyz/borsh": "^4.0.7",
    "base58-js": "^1.0.5",
    "bn.js": "^5.2.1",
    "buffer": "^6.0.3",
    "tweetnacl": "^1.0.3"
  },
  "devDependencies": {
    "@protobufjs/utf8": "^1.1.0",
    "@types/bn.js": "^5.1.1"
  }
}

'''
'''--- packages/account/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/backend/index.ts ---
export * from '@nearjs/account';
export * from '@nearjs/provider-core';
export * from '@nearjs/fs-key-store';

'''
'''--- packages/backend/package.json ---
{
  "name": "@nearjs/backend",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.3",
    "@nearjs/fs-key-store": "workspace:^1.0.0",
    "@nearjs/provider-core": "workspace:^1.0.2"
  }
}

'''
'''--- packages/backend/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/browser-key-store/index.ts ---
export * from './lib';

'''
'''--- packages/browser-key-store/lib/browser-key-store.ts ---
import { KeyPair, KeyStore, KeyIdString } from '@nearjs/account';

export interface BrowserLocalStorageKeyStoreConfig {
  baseKey?: string;

  storage?: Storage
}

export class BrowserKeyStore extends KeyStore {
  private readonly baseKey: string;

  private readonly storage: Storage;

  constructor(config?: BrowserLocalStorageKeyStoreConfig) {
    super();

    this.baseKey = (config && config.baseKey) ? config.baseKey : 'nearjs';
    this.storage = (config && config.storage) ? config.storage : window.localStorage;
  }

  public async listKeys(): Promise<KeyIdString[]> {
    const listString = this.storage.getItem(this.buildStorageKey('list'));
    if (!listString) {
      return [];
    }

    return JSON.parse(listString);
  }

  private buildStorageKey(keyIdString: KeyIdString): string {
    return `${this.baseKey}:${keyIdString}`;
  }

  private async updateList(keyIdString: KeyIdString) {
    const list = await this.listKeys();

    if (!list.includes(keyIdString)) {
      list.push(keyIdString);
      this.storage.setItem(this.buildStorageKey('list'), JSON.stringify(list));
    }
  }

  protected async storeKey(keyIdString: KeyIdString, keyPair: KeyPair): Promise<void> {
    this.storage.setItem(this.buildStorageKey(keyIdString), keyPair.toBase64JsonString());
    await this.updateList(keyIdString);
  }

  protected async getKey(keyIdString: KeyIdString): Promise<KeyPair> {
    const base64JsonString = this.storage.getItem(
      this.buildStorageKey(keyIdString),
    );

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return KeyPair.fromBase64JsonString(base64JsonString);
  }

  protected async deleteKey(keyIdString: KeyIdString): Promise<void> {
    if (!this.storage.getItem(this.buildStorageKey(keyIdString))) {
      return;
    }

    this.storage.removeItem(this.buildStorageKey(keyIdString));

    const keys = await this.listKeys();
    this.storage.setItem(this.buildStorageKey('list'), JSON.stringify(keys.filter((key) => key !== keyIdString)));
  }
}

'''
'''--- packages/browser-key-store/lib/index.ts ---
export * from './browser-key-store';

'''
'''--- packages/browser-key-store/package.json ---
{
  "name": "@nearjs/browser-key-store",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.0"
  }
}

'''
'''--- packages/browser-key-store/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/cli/index.ts ---
export * from '@nearjs/account';
export * from '@nearjs/provider-wallet-my-near-wallet';
export * from '@nearjs/fs-key-store';

export * from './lib';

'''
'''--- packages/cli/lib/index.ts ---
export * from './login';

'''
'''--- packages/cli/lib/login.ts ---
import { KeyId, KeyPair, KeyStore } from '@nearjs/account';
import { ProviderMyNearWallet, AUTH_ID_URL_QUERY_PARAM } from '@nearjs/provider-wallet-my-near-wallet';
import { RedirectHandler } from './redirect-handler';

const openPkg = import('open');

const ACCOUNT_ID_QUERY_PARAM = 'account_id';

export const login = async (provider: ProviderMyNearWallet, keyStore: KeyStore) => {
  const redirectHandler = new RedirectHandler([ACCOUNT_ID_QUERY_PARAM, AUTH_ID_URL_QUERY_PARAM]);
  const keyPair = KeyPair.fromRandom();

  const loginLink = provider.constructLoginLink(
    'cli-auth',
    { fullAccess: true, callbackUrl: redirectHandler.getHandlerUrl() },
    keyPair.getPublicKey().toString(),
  );

  redirectHandler.setRedirectUrl(loginLink);

  await redirectHandler.start();

  try {
    const open = await openPkg;
    await open.default(loginLink);
  } catch (e) {
    await redirectHandler.stop();
    throw e;
  }

  const authParams = await redirectHandler.listenForRedirectParams();

  if (!authParams.has(AUTH_ID_URL_QUERY_PARAM)) {
    throw new Error('Failed to fetch auth info.');
  }

  if (authParams.get(AUTH_ID_URL_QUERY_PARAM) !== 'cli-auth') {
    throw new Error('Failed to fetch auth info.');
  }

  const accountIdParameter = authParams.get(ACCOUNT_ID_QUERY_PARAM);

  if (!accountIdParameter) {
    throw new Error('Failed to fetch auth info.');
  }

  if (Array.isArray(accountIdParameter) && !accountIdParameter.length) {
    throw new Error('Failed to fetch auth info');
  }

  const accountId = Array.isArray(accountIdParameter) ? accountIdParameter[0] : accountIdParameter;

  const keyId = new KeyId(accountId, provider.getNetworkId());

  await keyStore.addKeyByKeyId(keyId, keyPair);

  await provider.fetchAccessKey(accountId);

  return accountId;
};

'''
'''--- packages/cli/lib/redirect-handler.ts ---
import * as net from 'net';
import * as http from 'http';
import * as url from 'url';

export const DEFAULT_PORT = 4000;
export const MAX_PORT = 4020;

export class RedirectHandler {
  private readonly expectedFields: string[];

  private readonly successWebPage: string;

  private readonly fetchedParameters: Map<string, string | string[]>;

  private readonly server: http.Server;

  private redirectUrl: string;

  private handlerUrl: string;

  private expired: boolean;

  constructor(expectedFields: string[], successWebPage = 'You may close this window now.') {
    this.expectedFields = expectedFields;
    this.successWebPage = successWebPage;
    this.fetchedParameters = new Map<string, string | string[]>();
    this.expired = false;
    this.server = http.createServer(this.handler.bind(this));
    this.redirectUrl = `http://127.0.0.1:${DEFAULT_PORT}`;
    this.handlerUrl = `http://127.0.0.1:${DEFAULT_PORT}`;
  }

  public setRedirectUrl(redirectUrl: string) {
    this.redirectUrl = redirectUrl;
  }

  public async start() {
    if (this.expired) {
      throw new Error('Redirect handler is expired.');
    }

    const port = await this.findFreePort();

    this.handlerUrl = `http://127.0.0.1:${port}`;

    this.server.listen(port, '127.0.0.1');
  }

  public async stop() {
    if (this.expired) {
      return;
    }

    this.server.closeAllConnections();
    this.server.close();
  }

  public listenForRedirectParams(): Promise<Map<string, string | string[]>> {
    return new Promise((resolve, reject) => {
      if (this.expired) {
        reject(new Error('Redirect handler is expired.'));
        return;
      }

      this.server.on('close', () => {
        if (!this.fetchedParameters.size) {
          return reject(new Error('Failed to fetch auth session'));
        }

        this.expired = true;

        return resolve(this.fetchedParameters);
      });
    });
  }

  public getHandlerUrl() {
    return this.handlerUrl;
  }

  private resolveListener(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.server.closeAllConnections();
      this.server.close((err) => {
        if (err) {
          return reject(err);
        }

        return resolve();
      });
    });
  }

  private findFreePort(port: number = DEFAULT_PORT): Promise<number> {
    return new Promise((resolve, reject) => {
      if (port > MAX_PORT) {
        reject(new Error(`Cannot find free port in a range ${DEFAULT_PORT} ${MAX_PORT}`));
        return;
      }
      const connection = net.createConnection({
        port,
        host: '127.0.0.1',
      });
      connection.on('connect', async () => {
        connection.end();
        resolve(await this.findFreePort(port + 1));
      });
      connection.on('error', async () => {
        connection.end();
        resolve(port);
      });
    });
  }

  private handler(request: http.IncomingMessage, response: http.ServerResponse) {
    const throwError = async (err: Error | undefined) => {
      console.error(err);
      await this.resolveListener();
    };

    const parsedUrl = url.parse(request.url as string, true);

    if (!Object.keys(parsedUrl.query).length) {
      response.writeHead(302, { Location: this.redirectUrl });
      response.end();
      return;
    }

    response.statusCode = 200;
    response.setHeader('Content-Type', 'text/html');
    response.end(this.successWebPage, () => {
      this.expectedFields.forEach((field) => {
        const value = parsedUrl.query[field];
        if (!value) {
          return;
        }
        this.fetchedParameters.set(field, value);
      });

      this.resolveListener().catch(throwError);
    });
  }
}

'''
'''--- packages/cli/package.json ---
{
  "name": "@nearjs/cli",
  "version": "1.1.9",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.1.1",
    "@nearjs/fs-key-store": "workspace:^1.0.0",
    "@nearjs/provider-wallet-my-near-wallet": "workspace:^1.1.5",
    "open": "^9.0.0"
  }
}

'''
'''--- packages/cli/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types",
    "moduleResolution": "node16"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/contracts/index.ts ---
export * from './lib';

'''
'''--- packages/contracts/lib/abstract-contract.ts ---
/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-ignore
import { NearRPCProvider, CallViewFunction } from '@nearjs/provider-core';
import { FunctionCall } from '@nearjs/tx';

export abstract class Contract {
  private readonly provider: NearRPCProvider<any>;

  private readonly contractAccountId: string;

  private signerAccountId?: string;

  constructor(
    contractAccountId: string,
    provider: NearRPCProvider<any>,
    signerAccountId?: string,
  ) {
    this.contractAccountId = contractAccountId;
    this.provider = provider;
    this.signerAccountId = signerAccountId;
  }

  public async setSignerAccountId(signerAccountId: string) {
    if (!(await this.provider.isAccountConnected(signerAccountId))) {
      throw new Error(
        `account ${signerAccountId} is not connected to the provider.`
          + `Please authorize ${signerAccountId} with near provider`,
      );
    }
    this.signerAccountId = signerAccountId;
  }

  protected async call(
    methodName: string,
    args: { [key: string]: any },
    gas: number,
    deposit: string,
  ) {
    if (!this.signerAccountId) {
      const connectedAccounts = await this.provider.listConnectedAccounts();
      if (connectedAccounts.length === 1) {
        [this.signerAccountId] = connectedAccounts;
      } else {
        if (!connectedAccounts.length) {
          throw new Error(
            'No Near accounts connected. '
              + 'Please connect at least one account ot call the contract functions',
          );
        }
        throw new Error(
          'Signer account id ambiguous. Please choose one from connected',
        );
      }
    }

    return this.provider.sendTransactionSync(
      this.signerAccountId,
      this.contractAccountId,
      [new FunctionCall(methodName, args, gas, deposit)],
    );
  }

  protected async callView(
    methodName: string,
    args: { [key: string]: any },
  ): CallViewFunction {
    return this.provider.sendViewCall(this.contractAccountId, methodName, args);
  }
}

'''
'''--- packages/contracts/lib/index.ts ---
export * from './abstract-contract';
export * from './neps';

'''
'''--- packages/contracts/lib/neps/ft.ts ---
// TODO: remove nocheck
/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck
import { Contract } from '../abstract-contract';

export interface FTMetadata {
  spec: string;
  name: string;
  symbol: string;
  icon: string;
  reference: string;
  reference_hash: string;
  decimals: number;
}

export class FungibleToken extends Contract {
  private metadata: FTMetadata;

  public async ftTransfer(
    receiverId: string,
    amount: string,
    memo?: string,
    gasLimit = 300000000000000,
  ) {
    return this.call(
      'ft_transfer',
      {
        receiver_id: receiverId,
        amount,
        memo,
      },
      gasLimit,
      '1',
    );
  }

  public async ftBalanceOf(accountId: string): Promise<string> {
    const result = await this.callView('ft_balance_of', {
      account_id: accountId,
    });

    return result.result.parsedResult.replace('"', '').replace('"', '');
  }

  public async ftMetadata(): Promise<FTMetadata> {
    if (this.metadata) {
      return this.metadata;
    }
    const result = await this.callView('ft_metadata', {});
    this.metadata = JSON.parse(result.result.parsedResult);
    return this.ftMetadata();
  }
}

'''
'''--- packages/contracts/lib/neps/index.ts ---
export * from './ft';
export * from './nft';

'''
'''--- packages/contracts/lib/neps/nft.ts ---
// TODO: remove nocheck
/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck
import { Contract } from '../abstract-contract';

export interface NFTMetadata {
  spec: string;
  name: string;
  symbol: string;
  icon: string;
  reference: string;
  reference_hash: string;
  base_uri: string;
}

export interface NFTTokenMetadata {
  title: string;
  description: string;
  media: string;
  media_hash: string;
  copies: number;
  issued_at: string;
  expires_at: string;
  starts_at: string;
  updated_at: string;
  extra: string;
  reference: string;
  reference_hash: string;
}

export interface NFTToken {
  token_id: string;
  owner_id: string;
  approved_account_ids: { [key: string]: number };
  metadata: NFTTokenMetadata;
  royalty: {
    split_between: { [key: string]: { enumerator: number } };
    percentage: { enumerator: number };
  };
  split_owners: string;
  minter: string;
  loan: string;
  composeable_stats: { local_depth: number; cross_contract_children: number };
  origin_key: string;
}

export interface NFTApproveEventData {
  token_id: string;
  approval_id: number;
  account_id: string;
}

export interface NftMintLog {
  owner_id: string;
  token_ids: string[];
  memo?: string;
}

export interface NftBurnLog {
  owner_id: string;
  authorized_id?: string;
  token_ids: string[];
  memo?: string;
}

export interface NftTransferLog {
  authorized_id?: string;
  old_owner_id: string;
  new_owner_id: string;
  token_ids: string[];
  memo?: string;
}

export interface NFTEvent<DataType> {
  standard: string;
  version: string;
  event: string;
  data: DataType;
}

export class NonFungibleToken extends Contract {
  private metadata: NFTMetadata;

  public async nftMetadata(): Promise<NFTMetadata> {
    if (this.metadata) {
      return this.metadata;
    }
    const result = await this.callView('nft_metadata', {});
    this.metadata = JSON.parse(result.result.parsedResult);
    return this.nftMetadata();
  }

  // APPROVAL MANAGEMENT

  public async nftApprove(
    tokenId: string,
    accountId: string,
    msg?: string,
    gasLimit = 300000000000000,
  ): Promise<NFTEvent<NFTApproveEventData>> {
    const result = await this.call(
      'nft_approve',
      {
        token_id: tokenId,
        account_id: accountId,
        msg,
      },
      gasLimit,
      '800000000000000000000',
    );

    if (
      result.result.receipts_outcome.length
      && result.result.receipts_outcome[0].outcome.logs.length
    ) {
      return JSON.parse(
        result.result.receipts_outcome[0].outcome.logs[0].replace(
          'EVENT_JSON:',
          '',
        ),
      );
    }

    if (result.result.status.Failure) {
      throw new Error(JSON.stringify(result.result.status.Failure));
    }

    // TODO: very important to log
    // console.log('unexpected result');
    // console.log(JSON.stringify(result, null, 2));
    throw new Error('Unexpected result');
  }

  public async nftIsApproved(
    tokenId: string,
    approvedAccountId: string,
    approvalId: number,
  ) {
    const result = await this.callView('nft_is_approved', {
      token_id: tokenId,
      approved_account_id: approvedAccountId,
      approval_id: approvalId,
    });

    return result.result.parsedResult === 'true';
  }

  public async nftRevoke(
    tokenId: string,
    accountId: string,
    gasLimit = 300000000000000,
  ) {
    return this.call(
      'nft_revoke',
      {
        token_id: tokenId,
        account_id: accountId,
      },
      gasLimit,
      '1',
    );
  }

  public async nftRevokeAll(tokenId: string, gasLimit = 300000000000000) {
    return this.call(
      'nft_revoke_all',
      {
        token_id: tokenId,
      },
      gasLimit,
      '1',
    );
  }

  // CORE

  public async nftTransfer(
    receiverId: string,
    tokenId: string,
    approvalId?: number,
    memo?: string,
    gasLimit = 300000000000000,
  ) {
    return this.call(
      'nft_transfer',
      {
        receiver_id: receiverId,
        token_id: tokenId,
        approval_id: approvalId,
        memo,
      },
      gasLimit,
      '1',
    );
  }

  public async nftTransferCall(
    receiverId: string,
    tokenId: string,
    msg: string,
    approvalId?: number,
    memo?: string,
    gasLimit = 300000000000000,
  ) {
    return this.call(
      'nft_transfer_call',
      {
        receiver_id: receiverId,
        token_id: tokenId,
        msg,
        approval_id: approvalId,
        memo,
      },
      gasLimit,
      '1',
    );
  }

  public async nftToken(tokenId: string): Promise<NFTToken> {
    const result = await this.callView('nft_token', { token_id: tokenId });

    return JSON.parse(result.result.parsedResult);
  }

  public async nftTotalSupply() {
    const result = await this.callView('nft_total_supply', {});

    return Number(result.result.parsedResult.replace('"', '').replace('"', ''));
  }

  public async nftSupplyForOwner(accountId: string) {
    const result = await this.callView('nft_supply_for_owner', {
      account_id: accountId,
    });

    return Number(result.result.parsedResult.replace('"', '').replace('"', ''));
  }

  public async nftTokens(
    fromIndex?: string,
    limit?: number,
  ): Promise<NFTToken[]> {
    const result = await this.callView('nft_tokens', {
      from_index: fromIndex,
      limit,
    });

    return JSON.parse(result.result.parsedResult);
  }

  public async nftTokensForOwner(
    accountId: string,
    fromIndex?: string,
    limit?: number,
  ): Promise<NFTToken[]> {
    const result = await this.callView('nft_tokens_for_owner', {
      account_id: accountId,
      from_index: fromIndex,
      limit,
    });

    return JSON.parse(result.result.parsedResult);
  }
}

'''
'''--- packages/contracts/package.json ---
{
  "name": "@nearjs/contracts",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/provider-core": "workspace:^1.0.1",
    "@nearjs/tx": "workspace:^1.0.1"
  }
}

'''
'''--- packages/contracts/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/fs-key-store/index.ts ---
export * from './lib';

'''
'''--- packages/fs-key-store/lib/file-system-key-store.ts ---
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import { KeyPair, KeyIdString, KeyStore } from '@nearjs/account';

export interface FileSystemStoreConfig {
  keysPath?: string;
}

export class FileSystemKeyStore extends KeyStore {
  private readonly keyStorePath: string;

  constructor(config?: FileSystemStoreConfig) {
    super();

    const keysFolder = config?.keysPath ? config.keysPath : os.homedir();

    this.keyStorePath = path.join(path.resolve(keysFolder), '.near-keys');
  }

  public async listKeys(): Promise<KeyIdString[]> {
    return fs.readdirSync(this.keyStorePath)
      .filter((fileName) => fileName.includes('.json'))
      .map((fileName) => fileName.replace('.json', ''));
  }

  private getKeyPath(keyIdString: KeyIdString) {
    return path.resolve(path.join(this.keyStorePath, `${keyIdString}.json`));
  }

  protected async getKey(keyIdString: KeyIdString): Promise<KeyPair> {
    const keyPath = this.getKeyPath(keyIdString);

    if (!fs.existsSync(keyPath)) {
      throw new Error(`Key ${keyIdString} not found.`);
    }

    const rawKey = fs.readFileSync(keyPath);

    return KeyPair.fromJson(rawKey.toString());
  }

  protected storeKey(keyIdString: KeyIdString, keyPair: KeyPair): Promise<void> {
    if (!fs.existsSync(this.keyStorePath)) {
      fs.mkdirSync(this.keyStorePath, { recursive: true });
    }

    const keyPath = this.getKeyPath(keyIdString);

    const oldTmpFile = `${keyPath}__old`;

    if (fs.existsSync(keyPath)) {
      fs.renameSync(keyPath, oldTmpFile);
    }

    try {
      fs.writeFileSync(keyPath, keyPair.toJsonString());
    } catch (e) {
      fs.renameSync(oldTmpFile, keyPath);

      return Promise.reject(e); // TODO: wrap this error
    }

    if (fs.existsSync(oldTmpFile)) {
      fs.rmSync(oldTmpFile);
    }

    return Promise.resolve();
  }

  protected async deleteKey(keyIdString: KeyIdString): Promise<void> {
    const keyPath = this.getKeyPath(keyIdString);

    if (!fs.existsSync(keyPath)) {
      return;
    }

    fs.rmSync(keyPath, { force: true });
  }
}

'''
'''--- packages/fs-key-store/lib/index.ts ---
export * from './file-system-key-store';

'''
'''--- packages/fs-key-store/package.json ---
{
  "name": "@nearjs/fs-key-store",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.0"
  }
}

'''
'''--- packages/fs-key-store/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/provider-core/index.ts ---
export * from './lib';
export * from './lib/errors';

'''
'''--- packages/provider-core/lib/config.ts ---
import { KeyStore } from '@nearjs/account';

// TODO: add auth options

export type RPCProviderHeadersConfig = { [key: string]: string | number };

export enum Network {
  TESTNET = 'testnet',
  MAINNET = 'mainnet',
  BETANET = 'betanet',
  LOCALNET = 'localnet',
  CUSTOM = 'custom',
}

export interface RPCProviderConfig {
  rpcUrl: string;
  networkId: Network;
  allowInsecure?: boolean;
  timeout?: number;
  headers?: RPCProviderHeadersConfig;
  keyStore?: KeyStore;
}

export const networkUrls = {
  [Network.MAINNET]: 'https://rpc.mainnet.near.org',
  [Network.TESTNET]: 'https://rpc.testnet.near.org',
  [Network.BETANET]: 'https://rpc.betanet.near.org',
  [Network.LOCALNET]: 'http://localhost:3030',
};

export const getRPCConfig = (networkId: Network, keyStore?: KeyStore): RPCProviderConfig => {
  if (networkId === Network.CUSTOM) {
    throw new Error('getRPCConfig support only predefined RPCs. Please build RPCProviderConfig for your env manually');
  }

  if (!networkUrls[networkId]) {
    throw new Error(`network ${networkId} is not default, please construct custom RPCProviderConfig`);
  }

  return {
    networkId,
    rpcUrl: networkUrls[networkId],
    keyStore,
  };
};

export const mainnetRPCConfig = (keyStore?: KeyStore): RPCProviderConfig => getRPCConfig(Network.MAINNET, keyStore);

export const testnetRPCConfig = (keyStore?: KeyStore): RPCProviderConfig => getRPCConfig(Network.TESTNET, keyStore);

export const betanetRPCConfig = (keyStore?: KeyStore): RPCProviderConfig => getRPCConfig(Network.BETANET, keyStore);

export const localnetRPCConfig = (keyStore?: KeyStore): RPCProviderConfig => getRPCConfig(Network.LOCALNET, keyStore);

'''
'''--- packages/provider-core/lib/errors/index.ts ---
export * from './provider-error';
export * from './rpc-error';

'''
'''--- packages/provider-core/lib/errors/provider-error.ts ---
export class ProviderError extends Error {}

'''
'''--- packages/provider-core/lib/errors/rpc-error.ts ---
import { ProviderError } from './provider-error';

export type RPCErrorCauseObject = {
  info: any; // TODO
  name: string; // TODO enum
};

export type RPCErrorObject = {
  name: string; // TODO enum
  cause: RPCErrorCauseObject;
  code: number;
  message: string;
  data: string;
};

export class UnknownError extends ProviderError {
  private readonly errorData: unknown;

  constructor(errorData: unknown) {
    super(`Unexpected error happened: ${JSON.stringify(errorData)}`);
    this.errorData = errorData;
  }

  getErrorData() {
    return this.errorData;
  }
}

export class RPCError extends ProviderError {
  private readonly errorObject: RPCErrorObject;

  constructor(errorObject: RPCErrorObject) {
    const message = `${errorObject.code}: ${errorObject.name}/${errorObject.cause.name} - `
      + `${errorObject.message}: ${JSON.stringify(errorObject.data, null, 2)}`;
    super(message);
    this.errorObject = errorObject;
  }

  public getRawJson() {
    return this.errorObject;
  }

  public getCause() {
    return this.errorObject.cause;
  }

  public getCauseName() {
    return this.errorObject.cause.name;
  }

  public getCode() {
    return this.errorObject.code;
  }

  public getName() {
    return this.errorObject.name;
  }
}

'''
'''--- packages/provider-core/lib/index.ts ---
export * from './config';
export * from './near-rpc-provider';
export * from './request';
export * from './response';
export * from './requests';

'''
'''--- packages/provider-core/lib/near-rpc-provider.ts ---
import {
  PublicKey, KeyId, KeyPair, FullAccess, FunctionCallPermission, AccessKey,
} from '@nearjs/account';
import {
  Transaction,
  SignedTransaction,
  IAction,
  TransactionBuilder,
} from '@nearjs/tx';
// TODO: custom typings needed
// @ts-ignore
import { base58_to_binary as fromBase58 } from 'base58-js';
import { JsonRPCRequest, RPCRequest } from './request';
import { IJsonRpcResponse, RPCResponse } from './response';
import { RPCProviderConfig } from './config';
import { RPCError, UnknownError } from './errors';
import { Block, BroadcastTxSync, ViewAccessKey } from './requests';
import { CallViewFunction } from './requests/call-view-function';

export enum HTTPMethods {
  POST = 'POST',
  GET = 'GET',
}

export interface WalletConnectOptions {
  contractId?: string;
  methodNames?: string[];
  fullAccess?: boolean;
}

export class NearRPCProvider<
  ProviderConfig extends RPCProviderConfig,
> {
  protected requestId = 1;

  protected readonly config: ProviderConfig;

  constructor(config: ProviderConfig) {
    this.config = config;
  }

  public getNetworkId() {
    return this.config.networkId;
  }

  public async sign(
    accountId: string,
    message: Uint8Array,
  ): Promise<Uint8Array> {
    const keyPair = await this.getKeyPair(accountId);

    return keyPair.sign(message);
  }

  // eslint-disable-next-line class-methods-use-this
  public async verify(
    message: Uint8Array,
    signature: Uint8Array,
    publicKey: Uint8Array,
  ): Promise<boolean> {
    return KeyPair.verifyWithPublicKey(message, signature, publicKey);
  }

  public async getPublicKey(accountId: string): Promise<PublicKey | null> {
    const keyPair = await this.getKeyPair(accountId);

    if (!keyPair) {
      return null;
    }

    return keyPair.getPublicKey();
  }

  public async signTransaction(
    accountId: string,
    transaction: Transaction,
  ): Promise<SignedTransaction> {
    const signature = await this.sign(accountId, transaction.getHash().data);
    return new SignedTransaction(transaction, signature);
  }

  protected async getKeyPair(accountId: string): Promise<KeyPair> {
    if (!this.config.keyStore) {
      throw new Error('No KeyStore was provided.');
    }
    const keyId = new KeyId(accountId, this.config.networkId);
    return this.config.keyStore.getKeyPairByKeyId(keyId);
  }

  protected async persistKeyPair(accountId: string, keyPair: KeyPair) {
    if (!this.config.keyStore) {
      throw new Error('No KeyStore was provided.');
    }
    const keyId = new KeyId(accountId, this.config.networkId);
    await this.config.keyStore.addKeyByKeyId(keyId, keyPair);
  }

  public async listConnectedAccounts(): Promise<string[]> {
    if (!this.config.keyStore) {
      throw new Error('No KeyStore was provided.');
    }
    const keyIdStrings = await this.config.keyStore.listKeys();
    return keyIdStrings.map(KeyId.extractAccountId);
  }

  public async isAccountConnected(accountId: string): Promise<boolean> {
    const connectedAccounts = await this.listConnectedAccounts();

    return connectedAccounts.includes(accountId);
  }

  public async fetchAccessKey(accountId: string, tryCount = 1): Promise<void> {
    const keyPair = await this.getKeyPair(accountId);
    if (!keyPair) {
      throw new Error(`Cannot fetch access key for account ${accountId} because no keypair found for the account`);
    }

    const accessKeyResponse = await this.sendRPCRequest(new ViewAccessKey(accountId, keyPair.getPublicKey()));

    if (accessKeyResponse.result.error) {
      if (tryCount > 2) {
        return;
      }

      await (new Promise<void>((resolve, reject) => {
        setTimeout(() => {
          this.fetchAccessKey(accountId, tryCount).then(resolve).catch(reject);
        }, 1000);
      }));

      return;
    }

    const accessKeyPermission = accessKeyResponse.result.permission === 'FullAccess'
      ? new FullAccess()
      : new FunctionCallPermission(
        accessKeyResponse.result.permission.FunctionCall.allowance,
        accessKeyResponse.result.permission.FunctionCall.receiver_id,
        accessKeyResponse.result.permission.FunctionCall.method_names,
      );
    const accessKey = new AccessKey(accessKeyResponse.result.nonce, accessKeyPermission);

    keyPair.setAccessKey(accessKey);

    await this.persistKeyPair(accountId, keyPair);
  }

  protected async buildTransaction(
    senderAccountId: string,
    receiverAccountId: string,
    actions: IAction[],
  ): Promise<Transaction> {
    const keyPair = await this.getKeyPair(senderAccountId);

    const block = await this.sendRPCRequest(new Block('final'));

    const tx = TransactionBuilder.builder()
      .withActions(actions)
      .withSignerId(senderAccountId)
      .withReceiverId(receiverAccountId)
      .withPublicKey(keyPair.getPublicKey())
      .withNonce(keyPair.getAndIncrementNonce())
      .withBlockHash(fromBase58(block.result.header.hash))
      .build();

    await this.persistKeyPair(senderAccountId, keyPair);

    return tx;
  }

  public async sendTransactionSync(
    senderAccountId: string,
    receiverAccountId: string,
    actions: IAction[],
    retryCount = 0,
  ): Promise<RPCResponse<BroadcastTxSync>> {
    const transaction = await this.buildTransaction(senderAccountId, receiverAccountId, actions);

    const signedTransaction = await this.signTransaction(
      senderAccountId,
      transaction,
    );

    const broadcastTxSync = new BroadcastTxSync(signedTransaction);

    try {
      return await this.sendRPCRequest(broadcastTxSync);
    } catch (e) {
      if (retryCount > 2) {
        throw e;
      }
      // TODO: parse and wrap errors separately
      // TODO: typings for errors
      if (
        e
        && (e as any).errorObject
        && (e as any).errorObject.cause
        && (e as any).errorObject.cause.name === 'INVALID_TRANSACTION'
      ) {
        if (
          (e as any).errorObject.data
          && (e as any).errorObject.data.TxExecutionError
          && (e as any).errorObject.data.TxExecutionError.InvalidTxError
          && (e as any).errorObject.data.TxExecutionError.InvalidTxError.InvalidNonce
          && (e as any).errorObject.data.TxExecutionError.InvalidTxError.InvalidNonce
            .ak_nonce
        ) {
          const keyPair = await this.getKeyPair(senderAccountId);

          keyPair.setNonce(
            (e as any).errorObject.data.TxExecutionError.InvalidTxError.InvalidNonce
              .ak_nonce,
          );
          await this.persistKeyPair(senderAccountId, keyPair);

          // TODO: do a exp. backoff??
          return this.sendTransactionSync(
            senderAccountId,
            receiverAccountId,
            actions,
            retryCount + 1,
          );
        }
      }

      throw e;
    }
  }

  public async sendViewCall(
    targetAccountId: string,
    functionName: string,
    args: { [key: string]: any },
  ) {
    const request = new CallViewFunction(targetAccountId, functionName, args);
    const result = await this.sendRPCRequest(request);
    if (result.result.error) {
      throw new Error(result.result.error);
    }
    result.result.parsedResult = Buffer.from(result.result.result).toString();

    return result;
  }

  public async sendRPCRequest<RequestType extends RPCRequest>(
    rpcRequest: RequestType,
    method: HTTPMethods = HTTPMethods.POST,
  ): Promise<RPCResponse<RequestType>> {
    this.requestId += 1;
    return this.sendJsonRpcRequest(
      rpcRequest.toJsonRPCRequest(this.requestId),
      method,
    );
  }

  protected async sendJsonRpcRequest<ReturnType>(
    request: JsonRPCRequest,
    method: HTTPMethods = HTTPMethods.POST,
  ): Promise<IJsonRpcResponse<ReturnType>> {
    const controller = new AbortController();
    const id = this.config.timeout
      ? setTimeout(() => controller.abort(), this.config.timeout) : null;

    const response = await fetch(this.config.rpcUrl, {
      method,
      body: JSON.stringify(request.toObject()),
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
      },
      signal: controller.signal,
    });

    if (id) {
      clearTimeout(id);
    }

    const result = await response.json();

    if (!response.ok) {
      throw new UnknownError(result);
    }

    if (result.error) {
      throw new RPCError(result.error);
    }

    return result;
  }
}

'''
'''--- packages/provider-core/lib/request.ts ---
export enum RPCRequestMethod {
  BLOCK = 'block',
  TX_ASYNC = 'broadcast_tx_async',
  TX_COMMIT = 'broadcast_tx_commit',
  CHUNK = 'chunk',
  GAS_PRICE = 'gas_price',
  HEALTH = 'health',
  LIGHT_CLIENT_PROOF = 'light_client_proof',
  NEXT_LIGHT_CLIENT_BLOCK = 'next_light_client_block',
  NETWORK_INFO = 'network_info',
  QUERY = 'query',
  STATUS = 'status',
  TX = 'tx',
  VALIDATORS = 'validators',
}

export interface IJsonRPCRequest {
  method: RPCRequestMethod;
  params: unknown;
}

export type RequestId = number;

export class JsonRPCRequest {
  public readonly jsonrpc: '2.0';

  public readonly id: RequestId;

  public readonly method: RPCRequestMethod;

  public readonly params: any;

  constructor(id: RequestId, method: RPCRequestMethod, params?: any) {
    this.jsonrpc = '2.0';
    this.id = id;
    this.method = method;
    this.params = params;
  }

  public toObject() {
    return {
      jsonrpc: this.jsonrpc,
      id: this.id,
      method: this.method,
      params: this.params,
    };
  }

  public static fromObject(requestId: number, request: IJsonRPCRequest) {
    return new JsonRPCRequest(requestId, request.method, request.params);
  }
}

export abstract class RPCRequest {
  public abstract toJsonRPCRequest(requestId: RequestId): JsonRPCRequest;
}

'''
'''--- packages/provider-core/lib/requests/block.ts ---
import {
  JsonRPCRequest, RequestId, RPCRequest, RPCRequestMethod,
} from '../request';

export class Block extends RPCRequest {
  public readonly finality?: string; // TODO: enum

  public readonly blockId?: number | string; // TODO: id (height?) or hash type

  constructor(finality?: string, blockId?: number) {
    super();
    if (!finality && !blockId) {
      throw new Error('Should specify at least one: finality OR block_id');
    } // TODO: consider put 'final' finality as default value

    this.blockId = blockId;
    this.finality = finality;
  }

  toJsonRPCRequest(requestId: RequestId): JsonRPCRequest {
    let params = {};
    if (this.finality) {
      params = {
        ...params,
        finality: this.finality,
      };
    }

    if (this.blockId) {
      params = {
        ...params,
        block_id: this.blockId,
      };
    }

    return new JsonRPCRequest(requestId, RPCRequestMethod.BLOCK, params);
  }
}

export type Chunk = {
  chunk_hash: string;
  prev_block_hash: string;
  outcome_root: string;
  prev_state_root: string;
  encoded_merkle_root: string;
  encoded_length: number;
  height_created: number;
  height_included: number;
  shard_id: number;
  gas_used: number;
  gas_limit: number;
  rent_paid: string;
  validator_reward: string;
  balance_burnt: string;
  outgoing_receipts_root: string;
  tx_root: string;
  validator_proposals: any[];
  signature: string;
};

export type BlockHeader = {
  height: number;
  epoch_id: string;
  next_epoch_id: string;
  hash: string;
  prev_hash: string;
  prev_state_root: string;
  chunk_receipts_root: string;
  chunk_headers_root: string;
  chunk_tx_root: string;
  outcome_root: string;
  chunks_included: number;
  challenges_root: string;
  timestamp: number;
  timestamp_nanosec: string;
  random_value: string;
  validator_proposals: any[];
  chunk_mask: boolean[];
  gas_price: string;
  rent_paid: string;
  validator_reward: string;
  total_supply: string;
  challenges_result: any[];
  last_final_block: string;
  last_ds_final_block: string;
  next_bp_hash: string;
  block_merkle_root: string;
  approvals: string[];
  signature: string;
  latest_protocol_version: number;
};

export type BlockResult = {
  author: string;
  header: BlockHeader;
  chunks: Chunk[];
};

'''
'''--- packages/provider-core/lib/requests/broadcast-tx-async.ts ---
export type BroadcastTxAsyncResult = string;

'''
'''--- packages/provider-core/lib/requests/broadcast-tx-sync.ts ---
import { SignedTransaction } from '@nearjs/tx';
import {
  JsonRPCRequest, RequestId, RPCRequest, RPCRequestMethod,
} from '../request';

export class BroadcastTxSync extends RPCRequest {
  public readonly tx: string;

  constructor(tx: SignedTransaction) {
    super();
    this.tx = tx.toBorshString();
  }

  toJsonRPCRequest(requestId: RequestId): JsonRPCRequest {
    return new JsonRPCRequest(requestId, RPCRequestMethod.TX_COMMIT, [this.tx]);
  }
}

export type TransactionView = {
  actions: any[];
  hash: string;
  nonce: number;
  public_key: string;
  receiver_id: string;
  signature: string;
  signer_id: string;
};

export type Status = {
  Failure?: any;
  SuccessValue?: any;
  SuccessReceiptId?: any;
};

export type Metadata = {
  gas_profile: any;
  version: number;
};

export type Outcome = {
  executor_id: string;
  gas_burnt: number;
  logs: any[];
  metadata: Metadata;
  receipt_ids: string[];
  status: Status;
};

export type Proof = {
  direction: string;
  hash: string;
};

export type TransactionOutcome = {
  block_hash: string;
  id: string;
  outcome: Outcome;
  proof: Proof[];
};

export type BroadcastTxSyncResult = {
  receipts_outcome: TransactionOutcome[];
  status: Status;
  transaction: TransactionView;
  transaction_outcome: TransactionOutcome;
};

'''
'''--- packages/provider-core/lib/requests/call-view-function.ts ---
import {
  JsonRPCRequest, RequestId, RPCRequest, RPCRequestMethod,
} from '../request';

export class CallViewFunction extends RPCRequest {
  public readonly accountId: string;

  public readonly functionName: string;

  public readonly args: { [key: string]: any };

  constructor(accountId: string, functionName: string, args: { [key: string]: any }) {
    super();
    this.accountId = accountId;
    this.functionName = functionName;
    this.args = args;
  }

  toJsonRPCRequest(requestId: RequestId): JsonRPCRequest {
    return new JsonRPCRequest(requestId, RPCRequestMethod.QUERY, {
      request_type: 'call_function',
      finality: 'final',
      account_id: this.accountId,
      method_name: this.functionName,
      args_base64: Buffer.from(JSON.stringify(this.args)).toString('base64'),
    });
  }
}

export type CallViewFunctionResult = {
  block_hash: string;
  block_height: number;
  logs: string[];
  result: Uint8Array;
  parsedResult: string;
  error?: string;
};

'''
'''--- packages/provider-core/lib/requests/index.ts ---
export * from './block';
export * from './broadcast-tx-sync';
export * from './view-account';
export * from './broadcast-tx-async';
export * from './view-access-key';

'''
'''--- packages/provider-core/lib/requests/view-access-key.ts ---
import { PublicKey } from '@nearjs/account';
import {
  JsonRPCRequest, RequestId, RPCRequest, RPCRequestMethod,
} from '../request';

export class ViewAccessKey extends RPCRequest {
  public readonly accountId: string;

  public readonly publicKey: PublicKey;

  constructor(accountId: string, publicKey: PublicKey) {
    super();
    this.accountId = accountId;
    this.publicKey = publicKey;
  }

  toJsonRPCRequest(requestId: RequestId): JsonRPCRequest {
    return new JsonRPCRequest(requestId, RPCRequestMethod.QUERY, {
      request_type: 'view_access_key',
      finality: 'final',
      account_id: this.accountId,
      public_key: this.publicKey.toString(),
    });
  }
}

export type ViewAccessKeyResult = {
  nonce: number,
  permission: {
    FunctionCall: {
      allowance: string;
      receiver_id: string;
      method_names: string[];
    }
  } | 'FullAccess',
  block_height: number;
  block_hash: string;
  error?: string;
};

'''
'''--- packages/provider-core/lib/requests/view-account.ts ---
import {
  JsonRPCRequest, RequestId, RPCRequest, RPCRequestMethod,
} from '../request';

export class ViewAccount extends RPCRequest {
  public readonly accountId: string;

  constructor(accountId: string) {
    super();
    this.accountId = accountId;
  }

  toJsonRPCRequest(requestId: RequestId): JsonRPCRequest {
    return new JsonRPCRequest(requestId, RPCRequestMethod.QUERY, {
      request_type: 'view_account',
      finality: 'final',
      account_id: this.accountId,
    });
  }
}

export type ViewAccountResult = {
  amount: string;
  block_hash: string;
  block_height: number;
  code_hash: string;
  locked: string;
  storage_paid_at: number;
  storage_usage: number;
};

'''
'''--- packages/provider-core/lib/response.ts ---
import { RPCErrorObject } from './errors';
import {
  Block,
  BlockResult,
  BroadcastTxSync,
  ViewAccount,
  ViewAccountResult,
  BroadcastTxSyncResult,
} from './requests';
import { CallViewFunction, CallViewFunctionResult } from './requests/call-view-function';
import { ViewAccessKey, ViewAccessKeyResult } from './requests/view-access-key';

export interface IJsonRpcResponse<ResultType> {
  id: string;
  jsonrpc: string;
  result: ResultType;
  error?: RPCErrorObject;
}

export type RPCResponse<RequestType> = IJsonRpcResponse<
RequestType extends CallViewFunction ?
  CallViewFunctionResult :
  RequestType extends BroadcastTxSync ?
    BroadcastTxSyncResult :
    RequestType extends ViewAccessKey ?
      ViewAccessKeyResult :
      RequestType extends Block ?
        BlockResult :
        RequestType extends ViewAccount ?
          ViewAccountResult :
          unknown
>;

'''
'''--- packages/provider-core/package.json ---
{
  "name": "@nearjs/provider-core",
  "version": "1.1.3",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.3",
    "@nearjs/tx": "workspace:^1.0.1",
    "base58-js": "^1.0.5"
  }
}

'''
'''--- packages/provider-core/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/provider-wallet-my-near-wallet/index.ts ---
export * from '@nearjs/provider-core';
export { IAction } from '@nearjs/tx';

export * from './lib';

'''
'''--- packages/provider-wallet-my-near-wallet/lib/index.ts ---
export * from './my-near-wallet-configuration';
export * from './my-near-wallet-sign-in-options';
export * from './provider-my-near-wallet';
export { AUTH_ID_URL_QUERY_PARAM } from './provider-my-near-wallet-connect';

'''
'''--- packages/provider-wallet-my-near-wallet/lib/my-near-wallet-configuration.ts ---
import { KeyStore } from '@nearjs/account';
import { getRPCConfig, Network, RPCProviderConfig } from '@nearjs/provider-core';

export interface MyNearWalletConfiguration extends RPCProviderConfig {
  walletBaseUrl: string;
  blockPopupFallback?: boolean;
  window?: Window;
}

export { Network } from '@nearjs/provider-core';

export const getConfiguration = (networkId: Network, keyStore: KeyStore): MyNearWalletConfiguration => {
  const walletBaseUrl = networkId === Network.TESTNET
    ? 'https://testnet.mynearwallet.com'
    : 'https://app.mynearwallet.com';

  const config: MyNearWalletConfiguration = { ...getRPCConfig(networkId, keyStore), walletBaseUrl };

  if (typeof window !== 'undefined') {
    config.window = window;
  }

  return config;
};

'''
'''--- packages/provider-wallet-my-near-wallet/lib/my-near-wallet-sign-in-options.ts ---
import { WalletConnectOptions } from '@nearjs/provider-core';

export interface MyNearWalletSignInOptions extends WalletConnectOptions {
  callbackUrl?: string;
}

'''
'''--- packages/provider-wallet-my-near-wallet/lib/provider-my-near-wallet-connect.ts ---
import {
  KeyPair,
  KeyId,
  KeyType,
} from '@nearjs/account';

import { v4 as uuid } from 'uuid';

import { MyNearWalletSignInOptions } from './my-near-wallet-sign-in-options';
import { ProviderMyNearWalletTransactionSender } from './provider-my-near-wallet-transaction-sender';

export const AUTH_ID_URL_QUERY_PARAM = 'nearJsAuthId';

export abstract class ProviderMyNearWalletConnect
  extends ProviderMyNearWalletTransactionSender {
  public async connectAccount(
    signInOptions: MyNearWalletSignInOptions = {},
  ): Promise<string> {
    if (!this.config.keyStore) {
      throw new Error('Cannot authenticate user without KeyStore');
    }

    if (!this.config.window) { // TODO: use open pkg to open browser if it is not browser
      throw new Error('Can connect wallet only in browser');
    }

    return this.connectAccountInBrowser(signInOptions);
  }

  private async connectAccountInBrowser(
    signInOptions: MyNearWalletSignInOptions = {},
  ): Promise<string> {
    if (!this.config.window) {
      throw new Error('Cannot start login via popup outside browser environment');
    }

    if (!this.config.keyStore) {
      throw new Error('Cannot authenticate user without KeyStore');
    }

    const currentUrl = new URL(this.config.window.location.href);
    if (!currentUrl.searchParams.has(AUTH_ID_URL_QUERY_PARAM)) {
      await this.startLogin(signInOptions);
      return '';
    }

    return this.completeAuth();
  }

  private async completeAuth(): Promise<string> {
    if (!this.config.window) {
      throw new Error('Cannot authenticate outside browser environment');
    }

    if (!this.config.keyStore) {
      throw new Error('Cannot authenticate user without KeyStore');
    }

    const currentUrl = new URL(this.config.window.location.href);
    const authId = currentUrl.searchParams.get(AUTH_ID_URL_QUERY_PARAM);

    if (!authId) {
      throw new Error('Unknown auth id');
    }

    const accountId = currentUrl.searchParams.get('account_id') || '';
    if (accountId) {
      // TODO: what if there is no accountId
      const keyPair = await this.config.keyStore.getKeyPairByKeyIdString(
        `pending::${authId}`,
      );

      if (keyPair) {
        await this.config.keyStore.deleteKeyPairByKeyIdString(
          `pending::${authId}`,
        );

        // TODO: fetch accessKey
        // TODO: put access key to the key pair
        const keyId = new KeyId(accountId, this.config.networkId);

        await this.config.keyStore.addKeyByKeyId(keyId, keyPair);

        await this.fetchAccessKey(accountId);
      }
    }
    currentUrl.searchParams.delete('public_key');
    currentUrl.searchParams.delete('all_keys');
    currentUrl.searchParams.delete('account_id');
    currentUrl.searchParams.delete('meta');
    currentUrl.searchParams.delete('transactionHashes');
    currentUrl.searchParams.delete(AUTH_ID_URL_QUERY_PARAM);

    this.config.window.history.replaceState(
      {},
      document.title,
      currentUrl.toString(),
    );

    return accountId;
  }

  private async startLogin(signInOptions: MyNearWalletSignInOptions = {}) {
    if (!this.config.window) {
      throw new Error('Cannot start login via popup outside browser environment');
    }

    if (!this.config.keyStore) {
      throw new Error('Cannot authenticate user without KeyStore');
    }

    const authId = uuid();

    let publicKey: string | undefined;

    if (signInOptions.contractId || signInOptions.fullAccess) {
      const keyPair = KeyPair.fromRandom(KeyType.ED25519);

      await this.config.keyStore.addKeyByKeyIdString(`pending::${authId}`, keyPair);

      publicKey = keyPair.getPublicKey().toString();
    }

    this.config.window.location.assign(this.constructLoginLink(authId, signInOptions, publicKey));
  }

  public constructLoginLink(
    authId: string,
    signInOptions: MyNearWalletSignInOptions = {},
    publicKey?: string,
  ): string {
    const loginUrl = new URL(`${this.config.walletBaseUrl}/login`);

    const callbackUrlBasePath = signInOptions.callbackUrl ? signInOptions.callbackUrl
      : !this.config.window ? this.config.walletBaseUrl : this.config.window.location.href;

    const callbackUrl = new URL(callbackUrlBasePath);
    callbackUrl.searchParams.set(AUTH_ID_URL_QUERY_PARAM, authId);

    loginUrl.searchParams.set('success_url', callbackUrl.toString());
    loginUrl.searchParams.set('failure_url', callbackUrl.toString());

    if (signInOptions.contractId) {
      loginUrl.searchParams.set('contract_id', signInOptions.contractId);
    }

    if (publicKey) {
      loginUrl.searchParams.set('public_key', publicKey);
    }

    if (signInOptions.methodNames) {
      signInOptions.methodNames.forEach((methodName) => {
        loginUrl.searchParams.append('methodNames', methodName);
      });
    }

    return loginUrl.toString();
  }
}

'''
'''--- packages/provider-wallet-my-near-wallet/lib/provider-my-near-wallet-transaction-sender.ts ---
import { BroadcastTxSync, NearRPCProvider, RPCResponse } from '@nearjs/provider-core';
import { IAction } from '@nearjs/tx';
import { MyNearWalletConfiguration } from './my-near-wallet-configuration';

export abstract class ProviderMyNearWalletTransactionSender
  extends NearRPCProvider<MyNearWalletConfiguration> {
  public async sendTransactionSync(
    senderAccountId: string,
    receiverAccountId: string,
    actions: IAction[],
  ): Promise<RPCResponse<BroadcastTxSync>> {
    const hasNonZeroDeposit = actions.filter((action) => !!action.deposit).length > 0;

    const senderKeyPair = await this.getKeyPair(senderAccountId);
    if (hasNonZeroDeposit && senderKeyPair && !senderKeyPair.isFullAccessKey()) {
      if (this.config.blockPopupFallback) {
        throw new Error('Cannot send direct RPC calls without full access key. Please provide full access key');
      }

      // TODO: deal with popup fallback (investigate how open popup without permission of the browser)
      // @ts-ignore
      return this.sendTransactionPopup(senderAccountId, receiverAccountId, actions);
    }

    return super.sendTransactionSync(senderAccountId, receiverAccountId, actions);
  }

  public async sendTransactionPopup(
    senderAccountId: string,
    receiverAccountId: string,
    actions: IAction[],
    callbackUrl?: string,
    meta?: string,
  ): Promise<void> {
    if (!this.config.window) {
      throw new Error('Cannot send transaction via popup outside browser environment');
    }

    const currentUrl = new URL(this.config.window.location.href);
    const newUrl = new URL('sign', this.config.walletBaseUrl);

    const tx = await this.buildTransaction(senderAccountId, receiverAccountId, actions);

    newUrl.searchParams.set('transactions', tx.toBorshString());
    newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);
    if (meta) {
      newUrl.searchParams.set('meta', meta);
    }

    this.config.window.location.assign(newUrl.toString());
  }
}

'''
'''--- packages/provider-wallet-my-near-wallet/lib/provider-my-near-wallet.ts ---
import { ProviderMyNearWalletConnect } from './provider-my-near-wallet-connect';

export class ProviderMyNearWallet extends ProviderMyNearWalletConnect {}

'''
'''--- packages/provider-wallet-my-near-wallet/package.json ---
{
  "name": "@nearjs/provider-wallet-my-near-wallet",
  "version": "1.1.5",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.0",
    "@nearjs/provider-core": "workspace:^1.1.2",
    "@nearjs/tx": "workspace:^1.0.0",
    "base58-js": "^1.0.5",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/uuid": "^9.0.0"
  }
}

'''
'''--- packages/provider-wallet-my-near-wallet/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/tx/index.ts ---
export * from './lib';

'''
'''--- packages/tx/lib/action.ts ---
import BN from 'bn.js';
import { PublicKey, AccessKey } from '@nearjs/account';
import { field, variant, vec } from '@dao-xyz/borsh';

export interface IAction {
  deposit?: BN;
}

export abstract class Action implements IAction {}

@variant(0)
export class CreateAccount extends Action {}

@variant(1)
export class DeployContract extends Action {
  @field({ type: vec('u8') })
  readonly code: Uint8Array;

  constructor(code: Uint8Array) {
    super();
    this.code = code;
  }
}

@variant(2)
export class FunctionCall extends Action {
  @field({ type: 'string' })
  readonly method_name: string;

  @field({ type: vec('u8') })
  readonly args: Uint8Array;

  @field({ type: 'u64' })
  readonly gas: BN;

  @field({ type: 'u128' })
  readonly deposit: BN;

  constructor(
    methodName: string,
    args: { [key: string]: any },
    gas: number,
    deposit: string, // TODO: see what we can do better
  ) {
    super();
    this.method_name = methodName;
    this.args = Buffer.from(JSON.stringify(args));
    this.gas = new BN(gas);
    this.deposit = new BN(deposit);
  }
}

@variant(3)
export class Transfer extends Action {
  @field({ type: 'u128' })
  readonly deposit: BN;

  constructor(deposit: number) {
    super();
    this.deposit = new BN(deposit);
  }
}

@variant(4)
export class Stake extends Action {
  @field({ type: 'u128' })
  readonly stake: BN;

  @field({ type: PublicKey })
  readonly public_key: PublicKey;

  constructor(stake: BN, publicKey: PublicKey) {
    super();
    this.stake = stake;
    this.public_key = publicKey;
  }
}

@variant(5)
export class AddKey extends Action {
  @field({ type: PublicKey })
  readonly public_key: PublicKey;

  @field({ type: AccessKey })
  readonly access_key: AccessKey;

  constructor(publicKey: PublicKey, accessKey: AccessKey) {
    super();
    this.public_key = publicKey;
    this.access_key = accessKey;
  }
}

@variant(6)
export class DeleteKey extends Action {
  @field({ type: PublicKey })
  readonly public_key: PublicKey;

  constructor(publicKey: PublicKey) {
    super();
    this.public_key = publicKey;
  }
}

@variant(7)
export class DeleteAccount extends Action {
  @field({ type: 'string' })
  readonly beneficiary_id: string;

  constructor(beneficiaryId: string) {
    super();
    this.beneficiary_id = beneficiaryId;
  }
}

'''
'''--- packages/tx/lib/index.ts ---
export * from './action';
export * from './signed-transaction';
export * from './transaction';
export * from './transaction-builder';

'''
'''--- packages/tx/lib/signed-transaction.ts ---
import { KeyType } from '@nearjs/account';
import {
  deserialize, field, fixedArray, serialize,
} from '@dao-xyz/borsh';

import { Transaction } from './transaction';

export class Signature {
  @field({ type: 'u8' })
  public readonly keyType: KeyType;

  @field({ type: fixedArray('u8', 64) })
  public readonly data: Uint8Array;

  constructor(data: Uint8Array, keyType: KeyType) {
    this.data = data;
    this.keyType = keyType;
  }
}

export class SignedTransaction {
  @field({ type: Transaction })
  public readonly transaction: Transaction;

  @field({ type: Signature })
  public readonly signature: Signature;

  constructor(transaction: Transaction, signature: Uint8Array, keyType = KeyType.ED25519) {
    this.transaction = transaction;
    this.signature = new Signature(signature, keyType);
  }

  toBorsh(): Uint8Array {
    return serialize(this);
  }

  toBorshString(): string {
    return Buffer.from(this.toBorsh()).toString('base64');
  }

  static fromBorsh(borsh: Uint8Array): SignedTransaction {
    return deserialize(borsh, SignedTransaction);
  }

  static fromBorshString(borshString: string): SignedTransaction {
    return SignedTransaction.fromBorsh(Buffer.from(borshString, 'base64'));
  }
}

'''
'''--- packages/tx/lib/transaction-builder.ts ---
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { PublicKey } from '@nearjs/account';
import BN from 'bn.js';
import { IAction } from './action';
import { Transaction } from './transaction';

export class TransactionBuilder {
  private actions: IAction[];

  // @ts-ignore
  private blockHash: Uint8Array;

  // @ts-ignore
  private nonce: BN;

  // @ts-ignore
  private publicKey: PublicKey;

  // @ts-ignore
  private receiverId: string;

  // @ts-ignore
  private signerId: string;

  public static builder(): TransactionBuilder {
    return new TransactionBuilder();
  }

  constructor() {
    this.actions = [];
  }

  public withActions(actions: IAction[]) {
    this.actions = actions;

    return this;
  }

  public addAction(action: IAction) {
    this.actions.push(action);

    return this;
  }

  public withBlockHash(blockHash: Uint8Array) {
    this.blockHash = blockHash;

    return this;
  }

  public withNonce(nonce: number) {
    this.nonce = new BN(nonce);

    return this;
  }

  public withPublicKey(publicKey: PublicKey) {
    this.publicKey = publicKey;

    return this;
  }

  public withReceiverId(receiverId: string) {
    this.receiverId = receiverId;

    return this;
  }

  public withSignerId(signerId: string) {
    this.signerId = signerId;

    return this;
  }

  public build() {
    // TODO: make cool errors

    if (!this.actions.length) {
      throw new Error('You must specify at lease one action');
    }

    if (!this.blockHash) {
      // TODO: really?
      throw new Error('You must specify block hash');
    }

    if (!this.publicKey) {
      throw new Error('You must specify public key');
    }

    if (!this.nonce) {
      throw new Error('You must specify nonce');
    }

    if (!this.receiverId) {
      // TODO: really?
      throw new Error('You must specify receiver Id');
    }

    if (!this.signerId) {
      throw new Error('You must specify signerId');
    }

    return new Transaction(
      this.actions,
      this.receiverId,
      this.blockHash,
      this.nonce,
      this.publicKey,
      this.signerId,
    );
  }
}

'''
'''--- packages/tx/lib/transaction.ts ---
import BN from 'bn.js';
import { PublicKey } from '@nearjs/account';
import {
  deserialize, field, fixedArray, serialize, vec,
} from '@dao-xyz/borsh';
import { sha256 } from 'js-sha256';
// TODO: typings
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { binary_to_base58 as toBase58, base58_to_binary as fromBase58 } from 'base58-js';

import { Action } from './action';

export class TransactionHash {
  public readonly data: Uint8Array;

  constructor(data: Uint8Array) {
    this.data = data;
  }

  public toString(): string {
    return toBase58(this.data);
  }

  public static fromString(hashString: string): TransactionHash {
    return new TransactionHash(fromBase58(hashString));
  }
}

/*
    pub signer_id: AccountId,
    /// A public key of the access key which was used to sign an account.
    /// Access key holds permissions for calling certain kinds of actions.
    pub public_key: PublicKey,
    /// Nonce is used to determine order of transaction in the pool.
    /// It increments for a combination of `signer_id` and `public_key`
    pub nonce: Nonce,
    /// Receiver account for this transaction
    pub receiver_id: AccountId,
    /// The hash of the block in the blockchain on top of which the given transaction is valid
    pub block_hash: CryptoHash,
    /// A list of actions to be applied
    pub actions: Vec<Action>,
 */
export class Transaction {
  @field({ type: 'string' })
  public readonly signerId: string;

  @field({ type: PublicKey })
  public readonly publicKey: PublicKey;

  @field({ type: 'u64' })
  public readonly nonce: BN;

  @field({ type: 'string' })
  public readonly receiverId: string;

  @field({ type: fixedArray('u8', 32) })
  public readonly blockHash: Uint8Array;

  @field({ type: vec(Action) })
  public readonly actions: Action[];

  public readonly hash: TransactionHash;

  constructor(
    actions: Action[],
    receiverId: string,
    blockHash: Uint8Array,
    nonce: BN,
    publicKey: PublicKey,
    signerId: string,
  ) {
    this.actions = actions;
    this.blockHash = blockHash;
    this.nonce = nonce;
    this.publicKey = publicKey;
    this.receiverId = receiverId;
    this.signerId = signerId;

    const borsh = this.toBorsh();
    const hash = sha256.create();
    hash.update(borsh);
    this.hash = new TransactionHash(new Uint8Array(hash.array()));
  }

  public getHash(): TransactionHash {
    return this.hash;
  }

  public toBorsh(): Uint8Array {
    return serialize(this);
  }

  public toBorshString(): string {
    return Buffer.from(this.toBorsh()).toString('base64');
  }

  static fromBorsh(borsh: Uint8Array): Transaction {
    return deserialize(borsh, Transaction);
  }
}

'''
'''--- packages/tx/package.json ---
{
  "name": "@nearjs/tx",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@dao-xyz/borsh": "^4.0.7",
    "@nearjs/account": "workspace:^1.0.3",
    "base58-js": "^1.0.5",
    "bn.js": "^5.2.1",
    "js-sha256": "^0.9.0"
  },
  "devDependencies": {
    "@protobufjs/utf8": "^1.1.0",
    "@types/bn.js": "^5.1.1"
  }
}

'''
'''--- packages/tx/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/units/index.ts ---
export * from './lib/units';

'''
'''--- packages/units/lib/units.ts ---
export interface IUnits {}

'''
'''--- packages/units/package.json ---
{
  "name": "@nearjs/units",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "devDependencies": {}
}

'''
'''--- packages/units/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- packages/web/index.ts ---
export * from '@nearjs/account';
export * from '@nearjs/provider-wallet-my-near-wallet';
export * from '@nearjs/browser-key-store';

'''
'''--- packages/web/package.json ---
{
  "name": "@nearjs/web",
  "version": "1.1.0",
  "description": "",
  "types": "./dist/types/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "clean": "rm -rf dist",
    "build": "pnpm run clean && tsc",
    "prepublishOnly": "pnpm build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Magic-Powered/near.js.git"
  },
  "author": "Magic Powered",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/Magic-Powered/near.js/issues"
  },
  "homepage": "https://github.com/Magic-Powered/near.js#readme",
  "dependencies": {
    "@nearjs/account": "workspace:^1.0.3",
    "@nearjs/browser-key-store": "workspace:^1.0.0",
    "@nearjs/provider-wallet-my-near-wallet": "workspace:^1.0.2"
  },
  "devDependencies": {
  }
}

'''
'''--- packages/web/tsconfig.json ---
{
  "extends": "./../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "declarationDir": "./dist/types"
  },
  "include": ["./*.ts", "./lib/**/*.ts"],
  "exclude": ["node_modules"]
}

'''
'''--- tsconfig.base.json ---
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "Node",
    "outDir": "./../dist",
    "declarationDir": "./../dist/types",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "checkJs": true,
    "allowJs": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true
  },
  "exclude": [
    "../node_modules",
  ],
  "include": [
    "./packages/**/*.ts",
    "./packages/**/lib/**/*.ts"
  ]
}

'''