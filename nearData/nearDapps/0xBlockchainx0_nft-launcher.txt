*GitHub Repository "0xBlockchainx0/nft-launcher"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- server/app.js ---
const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { withNear } = require('./middleware/near');
const { near, contractAccount } = require('./utils/near-utils');
const { contractName, networkId, GAS, contractMethods, GUESTS_ACCOUNT_SECRET } = getConfig();
const {
    Account,
    KeyPair,
	utils: {
		format: {
			parseNearAmount
		}
	}
} = nearAPI;

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
	res.send('Hello World!');
});

/// WARNING NO RESTRICTION ON THIS ENDPOINT
app.post('/add-guest', async (req, res) => {
	const { account_id, public_key } = req.body;
    const contractId = account_id.substr(account_id.indexOf('.') + 1)
    /// setup signer for guestAccount txs
    const guestId = 'guests.' + contractId
    const guestKeyPair = KeyPair.fromString(GUESTS_ACCOUNT_SECRET)
    near.connection.signer.keyStore.setKey(networkId, guestId, guestKeyPair);
    const guestsAccount = new Account(near.connection, guestId)
    /// try adding key to guestAccount and guest record to contract
    console.log('\nAdding guest account:', account_id)
	try {
		const addKey = await guestsAccount.addKey(public_key, contractId, contractMethods.changeMethods, parseNearAmount('0.1'));
		const add_guest = await contractAccount.functionCall(contractId, 'add_guest', { account_id, public_key }, GAS);
		res.json({ success: true, result: { addKey, add_guest } });
	} catch(e) {
		console.log(e);
		return res.status(403).send({ error: `error adding guest`, e});
	}
});

app.listen(port, () => {
	console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});
'''
'''--- server/middleware/near.js ---

const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const { near, connection, contractAccount } = require('../utils/near-utils');

const withNear = () => (req, res, next) => {
	req.near = near;
	next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
	const nearAccount = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(data).digest();
		let accessKeys = await nearAccount.getAccessKeys();
		if (contractName.length) {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
		} else {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission === 'FullAccess');
		}
		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

const hasAccessKey = async (req, res, next) => {
	const { accountId, contractName, blockNumber, blockNumberSignature } = req.body;
    
	if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
		return res.status(403).send({ error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature' });
	}

	if (!(await validBlock(blockNumber))) {
		return res.status(403).send({ error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
	}

	if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
		return res.status(403).send({ error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
	}

	return await next();
};

module.exports = {
	contractAccount,
	withNear,
	hasAccessKey,
};
'''
'''--- server/utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../../src/config");
const { nodeUrl, networkId, contractName, contractMethods, accessKeyMethods } =
  getConfig();
const {
  keyStores: { InMemoryKeyStore },
  Near,
  Account,
  Contract,
  KeyPair,
} = nearAPI;

console.log(
  "Loading Credentials:\n",
  `${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);
const credentials = JSON.parse(
  fs.readFileSync(
    `${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
  )
);

const keyStore = new InMemoryKeyStore();
keyStore.setKey(
  networkId,
  contractName,
  KeyPair.fromString(credentials.private_key)
);
const near = new Near({
  networkId,
  nodeUrl,
  deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
  near,
  keyStore,
  connection,
  contract,
  contractName,
  contractAccount,
  accessKeyMethods,
};

'''
'''--- src/App.js ---
import React, { useContext, useEffect, useState } from 'react';

import { appStore, onAppMount } from './state/app';

import { Wallet } from './components/Wallet';
import { Contract } from './components/Contract';
import { Keys } from './components/Keys';
import { Gallery } from './components/Gallery';

import Avatar from 'url:./img/avatar.jpg';
import NearLogo from 'url:./img/near_icon.svg';

import './App.scss';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

    console.log(state)
    
	const { near, wallet, contractAccount, account, localKeys, loading } = state;
    
	const [profile, setProfile] = useState(false);

	const onMount = () => {
		dispatch(onAppMount());
	};
	useEffect(onMount, []);

	const signedIn = ((wallet && wallet.signedIn) || (localKeys && localKeys.signedIn));
	let accountId = '';
	if (signedIn) {
		accountId = account ? account.accountId : <span>Guest Account<br />{localKeys.accessAccountId.split('.')[0]}</span>;
	}

	if (profile && !signedIn) {
		setProfile(false);
	}
    
	return <>
		{ loading && <div className="loading">
			<img src={NearLogo} />
		</div>
		}
        
		<div id="menu">
			<div>
				<div>
					<img style={{ opacity: signedIn ? 1 : 0.25 }} src={Avatar} 
						onClick={() => setProfile(!profile)}
					/>
				</div>
				<div>
					{ !signedIn ? <Wallet {...{ wallet }} /> : accountId }
				</div>
			</div>
		</div>

		{
			profile && signedIn && <div id="profile">
				<div>
					{
						wallet && wallet.signedIn && <Wallet {...{ wallet, account, update, dispatch, handleClose: () => setProfile(false) }} />
					}
					{
						localKeys && localKeys.signedIn && <Keys {...{ near, update, localKeys }} />
					}
				</div>
			</div>
		}

		{ !signedIn &&
            <div id="guest">
            	<>
            		<Keys {...{ near, update, localKeys }} />
            	</>
            </div>
		}
		{ signedIn &&
            <div id="contract">
            	{
            		signedIn &&
                    <Contract {...{ near, update, localKeys, wallet, account }} />
            	}
            </div>
		}
		<div id="gallery">
			<Gallery {...{ near, signedIn, contractAccount, account, localKeys, loading, update }} />
		</div>
	</>;
};

export default App;

'''
'''--- src/components/Contract.js ---
import React, {useEffect, useState} from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import { 
    contractName,
    createGuestAccount,
	accessKeyMethods,
	createAccessKeyAccount,
	getContract,
} from '../utils/near-utils';

const {
	KeyPair,
} = nearAPI;

export const Contract = ({ near, update, localKeys = {}, account }) => {
	if (!account && !localKeys.signedIn) return null;

	const [metadata, setMetadata] = useState('');
	const [freebies, setFreebies] = useState(0);
    
	const checkFreebies = async () => {
        if (!localKeys.accessPublic) return
		const guestAccount = createGuestAccount(near, KeyPair.fromString(localKeys.accessSecret));
        const guest = await guestAccount.viewFunction(contractName, 'get_guest', { public_key: localKeys.accessPublic })
		setFreebies(guest.mints + 1);
	};
	useEffect(checkFreebies, []);

	const handleMint = async () => {
		if (!metadata.length) {
			alert('Please enter some metadata');
			return;
		}
		update('loading', true);
		let appAccount = account;
		let accountId, deposit;
		if (!appAccount) {
			appAccount = createGuestAccount(near, KeyPair.fromString(localKeys.accessSecret));
			accountId = localKeys.accessAccountId;
		} else {
			accountId = account.accountId;
			deposit = parseNearAmount('1');
		}
        
		const contract = getContract(appAccount);
		await contract[!account ? 'nft_mint_guest' : 'nft_mint']({
            token_id: 'token-' + Date.now(),
			metadata,
		}, GAS, deposit);
		checkFreebies();
		update('loading', false);
        setMetadata('')
	};

	return <>
		<h3>Mint Something</h3>
		{ 
			!account ? <>
				{
					freebies > 0 && <>{
						freebies < 4 ? <>
							<p>{freebies} / 3 Free Mint</p>
							<input placeholder="Metadata (Image URL)" value={metadata} onChange={(e) => setMetadata(e.target.value)} />
							<button onClick={() => handleMint()}>Mint</button>
						</> :
							<p>You are out of free mints ðŸ˜­</p>
					}</>
				}
			</> :
				<>
					<input placeholder="Metadata (Image URL)" value={metadata} onChange={(e) => setMetadata(e.target.value)} />
					<button onClick={() => handleMint()}>Mint</button>
				</>
		}
	</>;
};

'''
'''--- src/components/Gallery.js ---
import React, {useEffect, useState} from 'react';
import * as nearAPI from 'near-api-js';
import { get, set, del } from '../utils/storage';
import { GAS, parseNearAmount } from '../state/near';
import { 
    marketId,
    contractName,
	getContract,
	formatAccountId,
    createGuestAccount,
    marketDeposit,
} from '../utils/near-utils';

const ADD_SALE = '__ADD_SALE';

const {
	KeyPair,
	utils: { format: { formatNearAmount } }
} = nearAPI;

export const Gallery = ({ near, signedIn, contractAccount, account, localKeys, loading, update }) => {
	if (!contractAccount) return null;

	const [fetching, setFetching] = useState(false);
	const [items, setItems] = useState([]);
	const [amount, setAmount] = useState('');
	const [filter, setFilter] = useState(1);

	useEffect(() => {
		if (!fetching && !loading) loadItems();
	}, [loading]);

	const loadItems = async () => {
		setFetching(true);
		const contract = getContract(contractAccount);
		const token_ids = await contract.get_token_ids();
        console.log(token_ids)
		const newItems = [];
		for (let i = 0; i < token_ids.length; i++) {
            const token_id = token_ids[i]
			const data = await contract.nft_token({
				token_id
			});
            data.sales = []
            for (let j = 0; j < data.approved_account_ids.length; j++) {
                const marketId = data.approved_account_ids[j]
                /// gotta get sale from marketplace contract
                try {
                    const sale = await contractAccount.viewFunction(marketId, 'get_sale', {
                        token_contract_id: contractAccount.accountId,
                        token_id
                    });
                    data.sales.push(sale)
                } catch (e) {
                    console.warn(e)
                    const sale = get(ADD_SALE, {})
                    if (sale.price) {
                        del(ADD_SALE)
                        await account.functionCall(marketId, 'add_sale', sale, GAS, marketDeposit)
                    }
                }
            }
			newItems.push({
				...data,
				token_id
			});
		}
		newItems.reverse();
		setItems(newItems);
		console.log('loaded items', newItems);
		setFetching(false);
	};

	const handlePurchase = async (token_id) => {
        if (!account) return
		update('loading', true);
		const item = items.find(({ token_id: id }) => token_id === id);
        if (!item.sales.length) return
		await account.functionCall(marketId, 'purchase', {
            token_contract_id: contractName,
			token_id: token_id,
		}, GAS, item.sales[0].price);
		await loadItems();
		update('loading', false);
	};

	const handleSetPrice = async (token_id) => {
		update('loading', true);
		if (!account) {
			const guestAccount = createGuestAccount(near, KeyPair.fromString(localKeys.accessSecret));
            try {
                await guestAccount.functionCall(contractName, 'nft_remove_sale_guest', {
                    token_id,
                    market_id: marketId,
                }, GAS)
            } catch(e) {
                console.warn(e)
            }
            await guestAccount.functionCall(contractName, 'nft_add_sale_guest', {
                token_id,
                price: parseNearAmount(amount),
                market_id: marketId,
                market_deposit: marketDeposit
            }, GAS)
		} else {
			try {
				const sale = await account.viewFunction(marketId, 'get_sale', { token_contract_id: contractName, token_id });
				console.log('\n\nSale exists, updating price:', sale, '\n\n');
				/// paying above marketDeposit, but after sale deposit will be paid back
				await account.functionCall(marketId, 'update_price', {
					token_contract_id: contractName,
					token_id,
					price: parseNearAmount(amount)
				}, GAS)
			} catch(e) {
				console.warn(e)
				/// paying above marketDeposit, but after sale deposit will be paid back
				await account.functionCall(contractName, 'nft_approve_account_id', {
					token_id,
					account_id: marketId,
					msg: JSON.stringify({
						beneficiary: account.accountId,
						price: parseNearAmount(amount)
					})
				}, GAS, parseNearAmount('0.1001'))
			}
        }
		await loadItems();
		update('loading', false);
	};

	let accountId;
	if (account) accountId = account.accountId;
	if (localKeys) accountId = localKeys.accessAccountId;

	let market = [], mine = [];
	if (signedIn) {
		market = items.filter(({ owner_id }) => owner_id !== accountId);
		mine = items.filter(({ owner_id }) => owner_id === accountId);
	} else {
		market = items;
    }

    console.log(mine)

	return <>
		{signedIn && <div className="filters">
			<button onClick={() => setFilter(1)} style={{ background: filter === 1 ? '#FFB259' : ''}}>Market</button>
			<button onClick={() => setFilter(2)} style={{ background: filter === 2 ? '#FFB259' : ''}}>My Tokens</button>
		</div>}
		{
			(filter === 1 ? market : mine).map(({ metadata, owner_id, sales, token_id }) => <div key={token_id} className="item">
				<img src={metadata} />
				{(filter === 1) &&<div className="line"></div>}
				{filter === 1 && <p>Owned by {formatAccountId(owner_id)}</p>}
				{
					sales.map(({ price }, i) =>
                        <div key={i}>
                            <p>Price {formatNearAmount(price, 2)}</p>
                            {
                                account && account.accountId !== owner_id &&
                                 <button onClick={() => handlePurchase(token_id)}>Purchase</button>
                            }
                        </div>
                    ) 
				}
				{filter === 2 && <>
					<input placeholder="Price (N)" value={amount} onChange={(e) => setAmount(e.target.value)} />
					<button onClick={() => handleSetPrice(token_id)}>Set a Price</button>
				</>}
			</div>)
		}
	</>;
};

'''
'''--- src/components/Keys.js ---
import React, { useState, useEffect } from 'react';
import * as nearAPI from 'near-api-js';
import { get, set, del } from '../utils/storage';
import { generateSeedPhrase, parseSeedPhrase } from 'near-seed-phrase';
import {
    setSignerFromSeed,
	contractName,
    createGuestAccount,
	postJson,
    networkId,
	GAS
} from '../utils/near-utils';

const LOCAL_KEYS = '__LOCAL_KEYS';

const {
    Account,
	KeyPair,
	utils: { PublicKey,
		format: {
			formatNearAmount
		} }
} = nearAPI;

export const Keys = ({ near, update, localKeys }) => {
	if (!near.connection) return null;
    
	const [username, setUsername] = useState('');
	const [accountId, setAccountId] = useState('');

	useEffect(() => {
		if (!localKeys) loadKeys();
	}, []);

	const loadKeys = async () => {
        console.log(loadKeys)
		const { seedPhrase, accessAccountId, accessPublic, accessSecret, signedIn } = get(LOCAL_KEYS);
		if (!accessAccountId) return;
		const { secretKey } = parseSeedPhrase(seedPhrase);
		const keyPair = KeyPair.fromString(secretKey);
		const guestAccount = createGuestAccount(near, keyPair);
        let guest
        try {
            guest = await guestAccount.viewFunction(contractName, 'get_guest', { public_key: accessPublic })
            console.log(guest)
        } catch (e) {
            console.warn(e)
        }
        
		update('localKeys', { seedPhrase, accessAccountId, accessPublic, accessSecret, signedIn, balance: guest.balance });
	};

	const handleCreateGuest = async () => {
        if (localKeys && window.confirm('Sign in as: ' + localKeys.accessAccountId + ' or CANCEL to sign in with a new username. WARNING you will lose access to the account: ' + localKeys.accessAccountId)) {
			return signIn();
		}
        const account_id = username + '.' + contractName
        const contractAccount = new Account(near.connection, contractName)
        try {
            await contractAccount.viewFunction(contractName, 'get_account', { account_id })
            return alert('username taken')
        } catch (e) {
            console.warn(e)
        }
		update('loading', true);
		const { seedPhrase, publicKey, secretKey } = generateSeedPhrase();
        let public_key = publicKey.toString()
		// WARNING NO RESTRICTION ON THIS ENDPOINT
		const result = await postJson({
			url: 'http://localhost:3000/add-guest',
			data: { 
                account_id,
                public_key
            }
		});
		if (result && result.success) {
			try {
                await contractAccount.viewFunction(contractName, 'get_account', { account_id })
                const keys = {
					seedPhrase,
                    accessAccountId: account_id,
					accessPublic: publicKey.toString(),
					accessSecret: secretKey,
					signedIn: true,
				};
				update('localKeys', keys);
				set(LOCAL_KEYS, keys);
            } catch (e) {
                update('loading', false);
                return alert('error creating guest account')
            }
		}
		update('loading', false);
		return null;
	};

	const signIn = () => {
		localKeys.signedIn = true;
		update('localKeys', localKeys);
		set(LOCAL_KEYS, localKeys);
	};

	const signOut = () => {
		localKeys.signedIn = false;
		update('localKeys', localKeys);
		set(LOCAL_KEYS, localKeys);
	};

    const handleUpgrade = async () => {
        /// the new full access key
        const { seedPhrase, publicKey } = generateSeedPhrase();
        if (!window.prompt('Keep this somewhere safe!', seedPhrase)) {
            return alert('you have to copy the seed phrase down somewhere')
        }
        console.log('seedPhrase', seedPhrase)
        /// additional access key so upgraded user doens't have to sign in with wallet
        const { seedPhrase: accessSeed, secretKey: accessSecret, publicKey: accessPublic } = generateSeedPhrase();

        /// current guest credentials
        const { accessAccountId: accountId, seedPhrase: guestSeed } = localKeys
        /// prep contract and args
        const guestAccount = createGuestAccount(near, KeyPair.fromString(localKeys.accessSecret));
        update('loading', true);
        const public_key = publicKey.toString();
        try {
            await guestAccount.functionCall(contractName, 'upgrade_guest', {
                public_key,
                access_key: accessPublic,
                method_names: ''
            }, GAS);

            /// wallet hijacking
            set(`near-api-js:keystore:${accountId}:default`, accessSecret);
            set(`undefined_wallet_auth_key`, `{"accountId":"${accountId}","allKeys":["${accessPublic}"]}`);
            /// set to access key pair, still a guest 
            /// e.g. don't have to get full access key secret from app (can use wallet /extention)
            const accessKeyPair = KeyPair.fromString(accessSecret)
            near.connection.signer.keyStore.setKey(networkId, accountId, accessKeyPair);
            signOut()
            update('loading', false);
            /// because we hacked the wallet
            window.location.reload();
        } catch (e) {
            console.warn(e);
            alert('upgrading failed')
        }
    };

	const deleteAccessKeys = window.deleteUsers = async () => {
		del(LOCAL_KEYS);
	};

	return <>
		{ localKeys && localKeys.signedIn ?
			<>
				<p>Balance: {formatNearAmount(localKeys.balance, 2) || '0'} N</p>
				{
					localKeys.balance && localKeys.balance !== '0' && <>
						<button onClick={() => handleUpgrade()}>Upgrade Account</button>
					</>
				}
				<br />
				<button onClick={() => signOut()}>Sign Out</button>
			</> :

            <div>
            <input placeholder="username" value={username} onChange={(e) => setUsername(e.target.value)} /> 
            <br />
			<button onClick={() => handleCreateGuest()}>Create Guest Account</button>
            </div>
		}
		{/* <button onClick={() => deleteAccessKeys()}>DELETE ALL ACCESS KEY ACCOUNTS</button> */}
	</>;
};

'''
'''--- src/components/Wallet.js ---
import React, { useEffect, useState } from 'react';

import * as nearAPI from 'near-api-js';
import { updateWallet } from '../state/near'
import {
    getContract,
    contractMethods,
	GAS
} from '../utils/near-utils';
const {
	KeyPair,
	utils: { PublicKey,
		format: {
			formatNearAmount
		} }
} = nearAPI;

export const Wallet = ({ wallet, account, update, dispatch, handleClose }) => {

	const [accountId, setAccountId] = useState('');
	const [proceeds, setProceeds] = useState('0');

	useEffect(() => {
		if (account) loadProceeds();
	}, []);
	const loadProceeds = async () => {
        const contract = getContract(account, contractMethods);
        console.log(await contract.get_proceeds({ owner_id: account.accountId }))
		setProceeds(formatNearAmount(await contract.get_proceeds({ owner_id: account.accountId }), 2));
	};

	const handleFundAccount = async() => {
		if (!accountId.length) return alert('Please enter an accountId to fund!');
		update('loading', true);
		const contract = getContract(account, contractMethods);
		await contract.withdraw({
			account_id: account.accountId,
			beneficiary: accountId,
		}, GAS);
        loadProceeds();
        dispatch(updateWallet());
		update('loading', false);
	};

	if (wallet && wallet.signedIn) {
		return <>
			<h3>Wallet</h3>
			<p>Balance: { wallet.balance } N</p>
			<p>Sale Proceeds: {proceeds} N</p>
			{
				proceeds !== '0' && <>
					<input placeholder="Funding AccountId" value={accountId} onChange={(e) => setAccountId(e.target.value)} />
					<button onClick={() => handleFundAccount()}>Transfer Funds</button>
				</>
			}
			<br />
			<button onClick={handleClose}>Close</button>
			<br />
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>;
	}

	return <>
		<button onClick={() => wallet.signIn()}>Connect Wallet</button>
	</>;
};

'''
'''--- src/config.js ---
const contractName = 'dev-1621363566808-83299674058879';

module.exports = function getConfig() {
  let config = {
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
    // walletUrl: 'http://localhost:1234',
    walletUrl: "https://wallet.testnet.near.org",
    helperUrl: "https://helper.testnet.near.org",
    contractName,
  };

  if (process.env.REACT_APP_ENV !== undefined) {
    config = {
      ...config,
      GAS: "200000000000000",
      DEFAULT_NEW_ACCOUNT_AMOUNT: "5",
      GUESTS_ACCOUNT_SECRET:
        "7UVfzoKZL4WZGF98C3Ue7tmmA6QamHCiB1Wd5pkxVPAc7j6jf3HXz5Y9cR93Y68BfGDtMLQ9Q29Njw5ZtzGhPxv",
      contractMethods: {
        changeMethods: [
          "new",
          "nft_mint",
          "nft_transfer",
          "add_guest",
          "remove_guest",
          "nft_approve_account_id",
          "nft_mint_guest",
          "nft_add_sale_guest",
          "nft_remove_sale_guest",
          "upgrade_guest",
        ],
        viewMethods: ["get_guest", "get_token_ids", "nft_token", "get_sale"],
      },
      marketDeposit: "100000000000000000000000",
      marketId: "market." + contractName,
    };
  }

  if (process.env.REACT_APP_ENV === "prod") {
    config = {
      ...config,
      networkId: "mainnet",
      nodeUrl: "https://rpc.mainnet.near.org",
      walletUrl: "https://wallet.near.org",
      helperUrl: "https://helper.mainnet.near.org",
      contractName: "near",
    };
  }

  return config;
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NEAR Onboarding Template</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { initNear } from './near';

const initialState = {
	app: {
		mounted: false,
	},
	near: {
		initialized: false,
	},
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear());
};

'''
'''--- src/state/near.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';
import { getWallet, postSignedJson } from '../utils/near-utils';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

export const initNear = () => async ({ update, getState, dispatch }) => {
	const { near, wallet, contractAccount } = await getWallet();

	wallet.signIn = () => {
		wallet.requestSignIn(contractName, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
		update('', { account: null });
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
		await update('', { near, wallet, contractAccount, account });
	}

	await update('', { near, wallet, contractAccount, account });
};

export const updateWallet = () => async ({ update, getState }) => {
    const { wallet } = await getState()
    wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
    await update('', { wallet });
}

'''
'''--- src/utils/near-utils.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName, contractMethods,
	accessKeyMethods,
    marketId, marketDeposit,
} = getConfig();

const {
	Account,
	Contract,
	InMemorySigner,
} = nearAPI;

let near

export const setSignerFromSeed = async (accountId, seedPhrase) => {
    const { secretKey } = parseSeedPhrase(seedPhrase);
    const keyPair = KeyPair.fromString(secretKey);
    near.connection.signer.keyStore.setKey(networkId, accountId, keyPair);
}
export function formatAccountId (accountId, len = 16) {
	if (accountId.length > len) {
		return accountId.substr(0, len - 3) + '...';
	}
	return accountId;
}

export function getContract(account, methods = contractMethods) {
	return new Contract(account, contractName, { ...methods });
}

export const getWallet = async () => {
	near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
	});
	const wallet = new nearAPI.WalletAccount(near);
	const contractAccount = new Account(near.connection, contractName);
	return { near, wallet, contractAccount };
};

export const getSignature = async (account, key) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

export const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
};

export const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({ ...data })
	}).then((res) => res.json());
};

export const createGuestAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, 'guests.' + contractName, key);
	const account = new Account(near.connection, 'guests.' + contractName);
	return account;
};

export const createAccessKeyAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, contractName, key);
	const account = new Account(near.connection, contractName);
	return account;
};

/********************************
Not used
********************************/

export const hasKey = async (near, accountId, publicKey) => {
	const pubKeyStr = publicKey.toString();
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		const accessKeys = await account.getAccessKeys();
		if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
			return true;
		}
	} catch (e) {
		console.warn(e);
	}
	return false;
};

export const isAccountTaken = async (near, accountId) => {
	if (accountId.indexOf(nameSuffix) > -1) {
		return true;
	}
	accountId = accountId + nameSuffix;
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		await account.state();
		return true;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return false;
};

export const getContractSigner = async ({ keyPair }) => {
	const signer = await InMemorySigner.fromKeyPair(networkId, contractName, keyPair);
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
	});
	const account = new nearAPI.Account(near.connection, contractName);
	const contract = await new nearAPI.Contract(account, contractName, {
		changeMethods: ['send', 'claim', 'create_account_and_claim'],
		sender: account
	});
	return { contract };
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
	let v = localStorage.getItem(k);
	if (typeof d !== 'object') {
		return v;
	}
	try {
		return JSON.parse(v || JSON.stringify(d));
	} catch (e) {
		return v;
	}
};
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = (k) => localStorage.removeItem(k);
'''
'''--- test/app.test.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { 
    Contract, KeyPair, Account,
    utils: { format: { parseNearAmount }},
    transactions: { deployContract, functionCall },
} = nearAPI;
const { 
	connection, initContract, getAccount, getAccountBalance,
	contract, contractAccount, contractName, contractMethods, createAccessKeyAccount,
	createOrInitAccount,
    getContract,
} = testUtils;
const { 
	networkId, GAS, GUESTS_ACCOUNT_SECRET
} = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
    let alice, bobId, bob, bobKey, marketAccount;

    const market_deposit = parseNearAmount('0.1');
    const metadata = 'https://media1.tenor.com/images/4c1d96a989150e7019bfbabbebd2ff36/tenor.gif?itemid=20269144'
    const metadata2 = 'https://media1.tenor.com/images/818161c07948bac34aa7c5f5712ec3d7/tenor.gif?itemid=15065455'

    const tokenIds = [
        'token' + Date.now(),
        'token' + Date.now() + 1,
        'token' + Date.now() + 2
    ]

    /// contractAccount.accountId is the token contract and contractAccount is the owner
    /// see initContract in ./test-utils.js for details
    const contractId = contractAccount.accountId
    /// this MUST be guests.NFT_CONTRACT_ACCOUNT_ID
    /// see lib.rs get_predecessor method for details
    const guestId = 'guests.' + contractId;
    const marketId = 'market.' + contractId;

	beforeAll(async () => {
	    await initContract();

		// /// normal user alice
		alice = await getAccount();
		console.log('\n\nAlice accountId:', alice.accountId, '\n\n');
		/// create guest account for bob
        /// add key to guests account (pays for gas, manages guest keys)
        /// add guest record to contract
        /// add key to current near connection signer keyStore (bob's key signs for guestId account)
		bobId = 'g' + Date.now() + '.' + contractId;
		console.log('\n\nBob accountId:', bobId, '\n\n');
		const keyPair = KeyPair.fromRandom('ed25519');
        /// saving public_key to bobKey (available for future tests)
		const public_key = bobKey = keyPair.publicKey.toString();
		const guestAccount = await createOrInitAccount(guestId, GUESTS_ACCOUNT_SECRET);
		await guestAccount.addKey(public_key, contractId, contractMethods.changeMethods, parseNearAmount('0.1'));
		try {
			await contract.add_guest({ account_id: bobId, public_key }, GAS);
		} catch(e) {
			console.warn(e);
		}
		connection.signer.keyStore.setKey(networkId, guestId, keyPair);
		bob = new Account(connection, guestId);
		const guest = await bob.viewFunction(contractId, 'get_guest', { public_key: bobKey });
		console.log('\n\nBob guest record:', guest, '\n\n');

        /// create or get market account and deploy market.wasm
		marketAccount = await createOrInitAccount(marketId, GUESTS_ACCOUNT_SECRET);
        let state = await marketAccount.state()
		console.log('\n\nstate:', state, '\n\n');
        if (state.code_hash === '11111111111111111111111111111111') {
            const contractBytes = fs.readFileSync('./out/market.wasm');
            console.log('\n\ndeploying contractBytes:', contractBytes.length, '\n\n');
            const actions = [
                deployContract(contractBytes),
                functionCall('new', { owner_id: contractId }, GAS)
            ]
            await marketAccount.signAndSendTransaction(marketId, actions)
        }
	});

    test('nft mint and approve but no sale', async () => {
        const token_id = tokenIds[2]
		await alice.functionCall(contractId, 'nft_mint', { token_id, metadata: metadata2 }, GAS, parseNearAmount('1'));
        /// msg is the price
        await alice.functionCall(contractId, 'nft_approve', {
            token_id,
            account_id: marketId,
            msg: JSON.stringify({
                beneficiary: alice.accountId,
                price: parseNearAmount('1')
            })
        }, GAS, parseNearAmount('0.1001'));
        const token = await contract.nft_token({ token_id });
        const sale = await alice.viewFunction(marketId, 'get_sale', { token_contract_id: contractId, token_id });
		console.log('\n\n', sale, '\n\n');
        expect(sale.price).toEqual(parseNearAmount('1'))
        expect(token.owner_id).toEqual(alice.accountId)
	});

	test('change price', async () => {
        const token_id = tokenIds[2]
		await alice.functionCall(marketId, 'update_price', { token_contract_id: contractId, token_id, price: parseNearAmount('2') }, GAS);
        const sale = await alice.viewFunction(marketId, 'get_sale', { token_contract_id: contractId, token_id });
		console.log('\n\n', sale, '\n\n');
        expect(sale.price).toEqual(parseNearAmount('2'))
	});

	test('nft mint', async () => {
        const token_id = tokenIds[0]
		await alice.functionCall(contractId, 'nft_mint', { token_id, metadata }, GAS, parseNearAmount('1'));
        const token = await contract.nft_token({ token_id });
        expect(token.metadata).toEqual(metadata)
        expect(token.owner_id).toEqual(alice.accountId)
	});

	test('nft transfer to guest', async () => {
        const token_id = tokenIds[0]
		await alice.functionCall(contractId, 'nft_transfer', { token_id, receiver_id: bobId }, GAS, 1);
        const token = await contract.nft_token({ token_id });
        expect(token.owner_id).toEqual(bobId)
	});

	test('nft mint guest', async () => {
        const token_id = tokenIds[1]
		await bob.functionCall(contractId, 'nft_mint_guest', { token_id, metadata }, GAS);
        const token = await contract.nft_token({ token_id });
        expect(token.metadata).toEqual(metadata)
        expect(token.owner_id).toEqual(bobId)
	});

    /// selling token as guest

	test('nft add sale guest', async () => {
        const token_id = tokenIds[0]
		await bob.functionCall(contractId, 'nft_add_sale_guest', {
            token_id,
            price: parseNearAmount('1'),
            market_id: marketId,
            market_deposit
        }, GAS);
        /// don't panic
	});

	test('get sale', async () => {
        const token_id = tokenIds[0]
		const sale = await alice.viewFunction(marketId, 'get_sale', {
            token_contract_id: contractId,
            token_id
        });
		console.log('\n\n', sale, '\n\n');
        expect(sale.owner_id).toEqual(bobId)
	});

	test('purchase nft from market', async () => {
        const token_id = tokenIds[0]
		await alice.functionCall(marketId, 'purchase', {
            token_contract_id: contractId,
            token_id
        }, GAS, parseNearAmount('1'));
        const token = await contract.nft_token({ token_id });
        expect(token.owner_id).toEqual(alice.accountId)
	});

	test('get guest', async () => {
		const guest = await bob.viewFunction(contractId, 'get_guest', { public_key: bobKey });
        console.log('\n\n', guest, '\n\n');
	});

	test('upgrade guest self', async () => {
		const keyPair = KeyPair.fromRandom('ed25519');
		const keyPair2 = KeyPair.fromRandom('ed25519');
		const public_key = keyPair.publicKey.toString();
		const public_key2 = keyPair2.publicKey.toString();
		connection.signer.keyStore.setKey(networkId, bobId, keyPair);
		const result = await bob.functionCall(contractId, 'upgrade_guest', {
			public_key,
			access_key: public_key2,
			method_names: '',
		}, GAS);
        console.log('\n\n', result, '\n\n');
		/// update account and contract for bob (bob now pays gas)
		const balance = await testUtils.getAccountBalance(bobId);
		expect(balance.total).toEqual(parseNearAmount('0.9'));
		
	});

});
'''
'''--- test/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../src/config");
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
  keyStores: { InMemoryKeyStore },
  Near,
  Account,
  Contract,
  KeyPair,
  utils: {
    format: { parseNearAmount },
  },
} = nearAPI;

console.log(
  "Loading Credentials:\n",
  `${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);
const credentials = JSON.parse(
  fs.readFileSync(
    `${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
  )
);
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
  networkId,
  contractName,
  KeyPair.fromString(credentials.private_key)
);
const near = new Near({
  networkId,
  nodeUrl,
  deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
  contractAccount.addKey(
    publicKey,
    contractName,
    contractMethods.changeMethods,
    parseNearAmount("0.1")
  );
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
  near,
  keyStore,
  connection,
  contract,
  contractName,
  contractAccount,
  contractMethods,
};

'''
'''--- test/server.test.js ---
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { Account, KeyPair, utils: { format: { parseNearAmount }} } = nearAPI;
const { near, TEST_HOST, initContract, getAccount, contractAccount: ownerAccount, postJson } = testUtils;
const { GAS, contractName: ownerId, networkId } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy API owned by: ' + ownerId, () => {
	let alice, contractAlice, bob, bobId, bobAccount;
    const name = `token-${Date.now()}`
    const tokenId = `${name}.${ownerId}`
    const guestId = 'guests.' + ownerId

	beforeAll(async () => {
		alice = await getAccount();
		await initContract();
	});

    /// API
	test('deploy token', async () => {
		const { success, result } = await postJson({
            url: TEST_HOST + '/launch-token',
            data: {
                name,
                symbol: 'TEST',
                totalSupply: parseNearAmount('1000000'),
            }
        })
        expect(success).toEqual(true)
	});

    /// API
	test('add guest user', async () => {
		bobId = 'bob.' + tokenId
        const keyPair = KeyPair.fromRandom('ed25519');
        /// bob's key signs tx from guest account (sponsored)
        near.connection.signer.keyStore.setKey(networkId, guestId, keyPair)
        bobAccount = new Account(near.connection, guestId)

        const { success, result } = await postJson({
            url: TEST_HOST + '/add-guest',
            data: {
                account_id: bobId,
                public_key: keyPair.publicKey.toString(),
            }
        })
        expect(success).toEqual(true)
	});

    /// CLIENT
	test('bob guest claim drop self', async () => {
		await bobAccount.functionCall(tokenId, 'claim_drop', {}, GAS)
        const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS)
        expect(balance).toEqual(parseNearAmount('100'))
	});

    /// CLIENT
	test('owner transfer tokens to guest (client)', async () => {
		await ownerAccount.functionCall(tokenId, 'ft_transfer', {
            receiver_id: bobId,
            amount: parseNearAmount('50'),
        }, GAS, 1)
        const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS)
        expect(balance).toEqual(parseNearAmount('150'))
	});

    /// API
	test('owner transfer tokens to guest (api)', async () => {
		const { success, result } = await postJson({
            url: TEST_HOST + '/transfer-tokens',
            data: {
                tokenId,
                receiver_id: bobId,
                amount: parseNearAmount('50'),
            }
        })
        expect(success).toEqual(true)
        const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS)
        expect(balance).toEqual(parseNearAmount('200'))
	});

    /// CLIENT
	test('bob guest transfer to alice', async () => {
        /// send tokens to alice who needs to register her storage
		const storageMinimum = await alice.viewFunction(tokenId, 'storage_minimum_balance', {});
		await alice.functionCall(tokenId, 'storage_deposit', {}, GAS, storageMinimum);
        const amount = parseNearAmount('100')
		await bobAccount.functionCall(tokenId, 'ft_transfer_guest', { receiver_id: alice.accountId, amount }, GAS)
        const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS)
        expect(balance).toEqual(amount)
        const balance2 = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: alice.accountId }, GAS)
        expect(balance2).toEqual(amount)
	});

    /// CLIENT
	test('bob upgrades to full account', async () => {
        const keyPair = KeyPair.fromRandom('ed25519');
		const keyPair2 = KeyPair.fromRandom('ed25519');
		const public_key = keyPair.publicKey.toString();
		const public_key2 = keyPair2.publicKey.toString();
		near.connection.signer.keyStore.setKey(networkId, bobId, keyPair);
		await bobAccount.functionCall(tokenId, 'upgrade_guest', {
			public_key,
			access_key: public_key2,
			method_names: '',
		}, GAS);
		/// update account and contract for bob (bob now pays gas)
		const balance = await testUtils.getAccountBalance(bobId);
		/// creating account only moves 0.5 NEAR and the rest is still wNEAR
		expect(balance.total).toEqual(parseNearAmount('0.5'));
	});

});
'''
'''--- test/test-utils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('../src/config');
const {
	networkId, contractName, contractMethods,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
} = getConfig();

const TEST_HOST = 'http://localhost:3000'
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
        const newArgs = {
			owner_id: contractAccount.accountId,
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const createOrInitAccount = async(accountId, secret) => {
	let account;
	try {
		account = await createAccount(accountId, DEFAULT_NEW_ACCOUNT_AMOUNT, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);
		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
	}
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

module.exports = { 
    TEST_HOST,
	near,
	connection,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
};
'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''