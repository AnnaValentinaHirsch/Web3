*GitHub Repository "khorolets/keyvalue-contract"*

'''--- Cargo.toml ---
[package]
name = "keyvalue-contract"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
near-sdk-sim = "3.2.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# keyvalue-contract

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/keyvalue_contract.wasm res/

'''
'''--- src/getters.rs ---
use near_sdk::near_bindgen;

use crate::*;

#[near_bindgen]
impl KeyValueContract {
    /// Returns the account ID of the owner
    pub fn get_owner_account_id(&self) -> Vec<AccountId> {
        vec![env::current_account_id(), self.get_master_account()]
    }

    /// Returns the values for the given keys
    pub fn get_keys(&self, keys: Vec<String>) -> HashMap<String, String> {
        let mut result = HashMap::<String, String>::new();
        for key in keys.into_iter() {
            if let Some(value) = self.store.get(&key) {
                result.insert(key, value);
            }
        }
        result
    }
}

'''
'''--- src/internal.rs ---
use crate::*;

/********************/
/* Internal methods */
/********************/

impl KeyValueContract {
    pub fn assert_owner(&self) {
        if &env::current_account_id() != &env::predecessor_account_id() {
            assert_eq!(
                &env::predecessor_account_id(),
                &self.get_master_account(),
                "Can only be called by the owner"
            )
        }
    }

    pub fn get_master_account(&self) -> AccountId {
        if let Some((_, master_account)) = env::current_account_id().split_once(".") {
            master_account.to_string()
        } else {
            env::current_account_id()
        }
    }
}

'''
'''--- src/lib.rs ---
//! A smart contract that allows tokens to be locked up.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::{env, near_bindgen, AccountId};
use std::collections::HashMap;

pub use crate::getters::*;
pub use crate::internal::*;
pub use crate::owner::*;

pub mod getters;
pub mod internal;
pub mod owner;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct KeyValueContract {
    pub store: UnorderedMap<String, String>,
}

impl Default for KeyValueContract {
    fn default() -> Self {
        Self {
            store: UnorderedMap::<String, String>::new(b"s"),
        }
    }
}

#[near_bindgen]
impl KeyValueContract {
    #[init]
    pub fn new(initial_store: Option<HashMap<String, String>>) -> Self {
        let mut store = UnorderedMap::<String, String>::new(b"s");

        if let Some(initial_store) = initial_store {
            store.extend(initial_store.into_iter());
        }

        Self { store }
    }
}

// #[cfg(not(target_arch = "wasm32"))]
// #[cfg(test)]
// mod tests {
//     use std::convert::TryInto;

//     use near_sdk::{testing_env, MockedBlockchain, PromiseResult, VMContext};

//     use test_utils::*;

//     use super::*;

//     mod test_utils;

//     pub type AccountId = String;

//     const SALT: [u8; 3] = [1, 2, 3];

//     fn basic_context() -> VMContext {
//         get_context(
//             system_account(),
//             to_yocto(LOCKUP_NEAR),
//             0,
//             to_ts(GENESIS_TIME_IN_DAYS),
//             false,
//         )
//     }

//     testing_env!(context.clone());
// }

'''
'''--- src/owner.rs ---
use crate::*;
use near_sdk::near_bindgen;

#[near_bindgen]
impl KeyValueContract {
    /// OWNER'S METHOD
    /// Inserts/updates the key-value pairs into store
    pub fn set_keys(&mut self, data: HashMap<String, String>) {
        self.assert_owner();
        env::log(format!("Extending store with data {:?}.", data).as_bytes());

        self.store.extend(data.into_iter());
    }

    /// OWNER'S METHOD
    /// Removes keys with values from store
    pub fn delete_keys(&mut self, keys: Vec<String>) {
        self.assert_owner();
        env::log(format!("Deleting keys {:?} from store.", keys).as_bytes());

        for key in keys.iter() {
            self.store.remove(key);
        }
    }

    /// OWNER'S METHOD
    /// Clears store
    pub fn clear_store(&mut self) {
        self.assert_owner();
        env::log(format!("Clearing entire store.").as_bytes());

        self.store.clear();
    }
}

'''