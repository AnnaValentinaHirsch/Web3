*GitHub Repository "near/repro-near-funcall"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- Cargo.toml ---
[package]
name = "repro-near-funcall-contracts"
version = "0.0.0"
publish = false
authors = ["Bo Yao <hello@nearprotocol.com>"]
edition = "2018"
license = "Apache-2.0"

[dependencies]
once_cell = "1"

'''
'''--- README.md ---
# Tool to get enough information for reproduce NEAR contract execution locally

## Usage for repro with near-sandbox
WIP in https://github.com/near/docs/pull/724

## Usage for repro with near-vm-standalone [DEPRECIATED]

```
npm i
node index.js -a <txn sender> -t <txn hash>
```

It will download `state.json`, `vmcontext.json` and `contract.wasm`, which can be pass to near-vm-runner-standalone

## Examples

Let's trying with examples of contract in different senarios, where you can reproduce contract execution from simplest state, multiple state where per user data is stored as seperate entry on trie, and cross contract read/write. These examples are intentionally created to simulate real world contract reproduce workflow.

### Preparation

- Have `near-cli` installed locally
- Have `near-vm-runner-standalone` compiled after merge this two branches into master: `fix-vmcontext-ser`, `state-file-standalone`.
- Register an account on https://wallet.testnet.near.org
- Login with `near login`
- Set environment var of your near account: `export REPRO_ACCOUNT=<your-account.testnet>`

### Repro execution of a simple contract

1. Deploy contract on testnet:

```
near create-account simple-state.$REPRO_ACCOUNT --initialBalance 10 --masterAccount $REPRO_ACCOUNT
near deploy --accountId simple-state.$REPRO_ACCOUNT --wasmFile res/simple_state.wasm
```

2. Call a contract method:

```
near call simple-state.$REPRO_ACCOUNT set_status --accountId $REPRO_ACCOUNT '{"message":"hello"}'
```

It will print a explorer link, such as: https://explorer.testnet.near.org/transactions/8No2dz4GKNRAFJcdU34wYngr6HRBQkNV5ZLMn1z1TfVc. Remember the transaction hash: `export TXN=8No2dz4GKNRAFJcdU34wYngr6HRBQkNV5ZLMn1z1TfVc`

3. Download code, state and vmcontext used to execute the function call action (contract method call):

```
node index.js -a $REPRO_ACCOUNT -t $TXN
```

4. Now we're able to reproduce this transaction locally, by:

```
near-vm-runner-standalone --context-file vmcontext.json --method-name set_status --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

Result:

```
      74.47Âµs get_key
        10.86ms run_method/instantiate
        5.52ms run_method/call
        6.54ms run_method/drop_instance
      23.03ms run_method
    1.11s run_wasmer
  1.11s run_vm

{"outcome":{"balance":"189978309984683730567830612","storage_usage":346,"return_data":"None","burnt_gas":291040465116,"used_gas":291040465116,"logs":["repro.testnet set_status with message hello"]},"err":null,"receipts":[],"state":{"U1RBVEU=":"AQAAAA0AAAByZXByby50ZXN0bmV0BQAAAGhlbGxv"}}
------------------------------
Total gas: 291040465116
Host gas: 215297482305 [73% total]
Action gas: 0 [0% total]
Wasm execution: 75742982811 [26% total]
------ Host functions --------
base -> 2912449221 [1% total, 1% host]
contract_compile_base -> 35445963 [0% total, 0% host]
contract_compile_bytes -> 30761160000 [10% total, 14% host]
read_memory_base -> 10439452800 [3% total, 4% host]
read_memory_byte -> 315510639 [0% total, 0% host]
write_memory_base -> 8411384583 [2% total, 3% host]
write_memory_byte -> 168873864 [0% total, 0% host]
read_register_base -> 7551495558 [2% total, 3% host]
read_register_byte -> 6110844 [0% total, 0% host]
write_register_base -> 11462089944 [3% total, 5% host]
write_register_byte -> 349743888 [0% total, 0% host]
utf8_decoding_base -> 3111779061 [1% total, 1% host]
utf8_decoding_byte -> 12537960597 [4% total, 5% host]
log_base -> 3543313050 [1% total, 1% host]
log_byte -> 567548013 [0% total, 0% host]
storage_write_base -> 64196736000 [22% total, 29% host]
storage_write_key_byte -> 352414335 [0% total, 0% host]
storage_write_value_byte -> 930556170 [0% total, 0% host]
storage_write_evicted_byte -> 963519210 [0% total, 0% host]
storage_read_base -> 56356845750 [19% total, 26% host]
storage_read_key_byte -> 154762665 [0% total, 0% host]
storage_read_value_byte -> 168330150 [0% total, 0% host]
------ Actions --------
------------------------------
```

### Repro execution of a contract with per account state as seperate entries on trie

Steps are same as simple-contract, only difference is you'll get more entries in state.json:

```
# Deploy contract
near create-account multiple-state.$REPRO_ACCOUNT --initialBalance 10 --masterAccount $REPRO_ACCOUNT
near deploy --accountId multiple-state.$REPRO_ACCOUNT --wasmFile res/multiple_state.wasm --initFunction new --initArgs '{}'
# Call a contract method
near call multiple-state.$REPRO_ACCOUNT set --accountId $REPRO_ACCOUNT '{"title":"hello","message":"world"}'
# Let's call with different to see multiple state in actions
near call multiple-state.$REPRO_ACCOUNT set --accountId multiple-state.$REPRO_ACCOUNT '{"title":"hello2","message":"world2"}'
Scheduling a call: multiple-state.repro.testnet.set({"title":"hello2","message":"world2"})
# Here record the txn hash manually, choose the txn hash of the second call above:
# export TXN=
# Download code, state and vmcontext
node index.js -a $REPRO_ACCOUNT -t $TXN
# cat state.json will show multiple entries
# Repro
near-vm-runner-standalone --context-file vmcontext.json --method-name set --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

### Repro execution of a function call that has cross contract write

Initial steps are same

```
# Deploy contract
near create-account cross-contract.$REPRO_ACCOUNT --initialBalance 10 --masterAccount $REPRO_ACCOUNT
near deploy --accountId cross-contract.$REPRO_ACCOUNT --wasmFile res/cross_contract.wasm --initFunction new --initArgs "{\"state_contract\":\"simple-state.$REPRO_ACCOUNT\"}"
# Call a contract method
near call cross-contract.$REPRO_ACCOUNT set_in_other_contract --accountId $REPRO_ACCOUNT '{"message":"world"}'
```

Now if you see this transaction on explorer you'll see these receipts:

```
$REPRO_ACCOUNT calls cross-contract.$REPRO_ACCOUNT
  cross-contract.$REPRO_ACCOUNT calls simple-state.$REPRO_ACCOUNT
    system calls $REPRO_ACCOUNT
  system calls $REPRO_ACCOUNT
```

Ignore system calls receipts, the second one is you'll see the one than previous non-cross contract call receipts. If you click on the block you'll also see it happens one block later than the first receipt (The most likely case, if network is on high load then more is possible). So to reproduce it locally you'll need to do it in two step, since they're having different block height, different state, different vm context and different contract code.

#### `$REPRO_ACCOUNT` calls `cross-contract.$REPRO_ACCOUNT`

This step is easy, just download and reproduce as before:

```
# export TXN=
node index.js -a $REPRO_ACCOUNT -t $TXN
near-vm-runner-standalone --context-file vmcontext.json --method-name set_in_other_contract --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

The major difference of the output is it has a (Promise) ReceiptIndex return and a receipt saying it's going to do a function call in another contract:

```
"return_data":{"ReceiptIndex":0},...,
"receipts":[{"receipt_indices":[],"receiver_id":"simple-state.repro.testnet","actions":[{"FunctionCall":{"method_name":"set_status","args":"{\"message\":\"world\"}","gas":50000000000000,"deposit":0}}]}],"state":{"U1RBVEU=":"AAAAABoAAABzaW1wbGUtc3RhdGUucmVwcm8udGVzdG5ldA=="}
```

#### `cross-contract.$REPRO_ACCOUNT` calls `simple-state.$REPRO_ACCOUNT`

This step download a different vm context, state and code. First look up the receipt id of this function call action from explorer, then download with:

```
node index.js -a $REPRO_ACCOUNT -t $TXN -r GrkKW2WJRKgkLfnAVVjktRba3RoLa6UVMSUhyJ6Dpwpf # replace with receipt id found in explorer
```

And reproduce with

```
near-vm-runner-standalone --context-file vmcontext.json --method-name set_status --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

### Repro execution of a function call that has cross contract read or promise result as input

Use the contract deployed in previous section, then call:

```
near call cross-contract.$REPRO_ACCOUNT get_from_other_contract_and_record --accountId $REPRO_ACCOUNT "{\"account_id\":\"$REPRO_ACCOUNT\"}"
```

There are three steps in this transaction:

1. `$REPRO_ACCOUNT` calls `cross-contract.$REPRO_ACCOUNT`, `get_from_other_contract_and_record` method, which create two receipts (step 2 and 3) that does the actual cross contract call.
2. `cross-contract.$REPRO_ACCOUNT` calls `simple-state.$REPRO_ACCOUNT`, `get_status` method. This is a cross contract read, returned result is used as parameter as step 3.
3. `cross-contract.$REPRO_ACCOUNT` calls it's `get_from_other_callback` method, takes argument from step 2's return.

Reproduce the first step (a cross contract read) of the transaction is same as before:

```
export TXN=
node index.js -a $REPRO_ACCOUNT -t $TXN
near-vm-runner-standalone --context-file vmcontext.json --method-name get_from_other_contract_and_record --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

Reproduce the second step is also similar to the previous section's second part, lookup the receipt id from explorer (Find the receipt include `get_status` function call) then run:

```
node index.js -a $REPRO_ACCOUNT -t $TXN -r <Your receipt id>
near-vm-runner-standalone --context-file vmcontext.json --method-name get_status --wasm-file contract.wasm --state-file state.json --profile-gas --timings
```

Reproduce the third step need return data from step 2 (this is also same for any contract call that used as callback that takes return data from previous calls). To reproduce it first locate the receipt id from explorer (the one has content "Called method: 'get_from_other_callback'")

```
node index.js -a $REPRO_ACCOUNT -t $TXN -r <Your receipt id>
```

Obtain the return data from step 2's output (the "return_data" section)

```
{"outcome":{"balance":"169954889277699040312798592","storage_usage":346,"return_data":{"Value":"\u0001\u0003\u0000\u0000\u0000ooo"},"burnt_gas":201805752385,"used_gas":201805752385,"logs":["get_status for account_id repro.testnet"]},"err":null,"receipts":[],"state":{"U1RBVEU=":"AQAAAA0AAAByZXByby50ZXN0bmV0AwAAAG9vbw=="}}
```

Then run vm standalone with step 2's return data as promise_results:

```
./near-vm-runner-standalone --context-file vmcontext.json --method-name get_from_other_callback --wasm-file contract.wasm --state-file state.json --promise-results '{"Successful":"\u0001\u0003\u0000\u0000\u0000ooo"}'  --profile-gas --timings
```

## TODO

- [x] Check to ensure block hash is the correct one that "before" transaction and receipt execution, not after
- [x] Figure out pass promise results to cross contract calls
- [x] Figure out how to tell if a function call is a view programmatically:
  - view method is also executed as call, when execute as part of cross contract read
- [x] Add reproduce example that has cross contract read

'''
'''--- build.rs ---
use std::process::Command;
use std::{fs, io, process};

fn main() {
    if let Err(err) = try_main() {
        eprintln!("{}", err);
        process::exit(1);
    }
}

fn try_main() -> io::Result<()> {
    let status = Command::new("rustup")
        .args(&["target", "add", "wasm32-unknown-unknown"])
        .status()?;
    if !status.success() {
        return Err(io::Error::new(
            io::ErrorKind::Other,
            "rustup target add failed",
        ));
    }

    build_contract("./simple-state", &[], "simple_state")?;
    build_contract("./multiple-state", &[], "multiple_state")?;
    build_contract("./cross-contract", &[], "cross_contract")?;

    Ok(())
}

fn build_contract(dir: &str, args: &[&str], output: &str) -> io::Result<()> {
    let mut cmd = cargo_build_cmd();
    cmd.args(args);
    cmd.current_dir(dir);
    let status = cmd.status()?;
    if !status.success() {
        return Err(io::Error::new(io::ErrorKind::Other, "cargo build failed"));
    }
    fs::copy(
        format!(
            "./{}/target/wasm32-unknown-unknown/release/{}.wasm",
            dir,
            dir.replace('-', "_")
        ),
        format!("./res/{}.wasm", output),
    )?;
    println!("cargo:rerun-if-changed=./{}/src/lib.rs", dir);
    println!("cargo:rerun-if-changed=./{}/Cargo.toml", dir);
    Ok(())
}

fn cargo_build_cmd() -> Command {
    let mut res = Command::new("cargo");
    res.env("RUSTFLAGS", "-C link-arg=-s");
    res.args(&["build", "--target=wasm32-unknown-unknown", "--release"]);
    res
}

'''
'''--- collect-state-records.js ---
const { Command } = require("commander");
const fetch = require("node-fetch");
const assert = require("assert").strict;
const program = new Command();
const fs = require("fs").promises;

program
  .requiredOption("-a, --accounts <accounts...>", "accounts to dump storage")
  .option("-b, --block-id <block>", "block height to dump")
  .option(
    "-u, --rpc-node-url <url>",
    "NEAR rpc node url",
    "https://rpc.testnet.near.org"
  );

async function fetchContractState({ blockId, contractAccount, rpcNodeUrl }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: "final" };
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },

    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "query",
      params: {
        request_type: "view_state",
        account_id: contractAccount,
        prefix_base64: "",
        ...params,
      },
    }),
  });
  const res = await req.json();
  //   let result = {};
  let stateRecords = [];
  //   let prefix = Buffer.concat([
  //     Buffer.from([9]),
  //     Buffer.from(contractAccount),
  //     Buffer.from(","),
  //   ]);
  for (let kv of res.result.values) {
    // format of raw trie key
    // result[Buffer.concat([prefix, Buffer.from(kv.key)]).toString("base64")] =
    //   kv.value;
    stateRecords.push({
      Data: { account_id: contractAccount, data_key: kv.key, value: kv.value },
    });
  }
  return stateRecords;
}

async function main() {
  program.parse(process.argv);
  const options = program.opts();
  //   console.log(options);
  let allState = [];
  for (let contractAccount of options.accounts) {
    let contractState = await fetchContractState({
      contractAccount,
      blockId: options.blockId,
      rpcNodeUrl: options.rpcNodeUrl,
    });
    allState = allState.concat(contractState);
  }
  console.log(JSON.stringify(allState, null, 2));
}

main();

'''
'''--- cross-contract/Cargo.toml ---
[package]
name = "cross-contract"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []
'''
'''--- cross-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, ext_contract, near_bindgen, setup_alloc, AccountId, Promise};

setup_alloc!();

#[ext_contract]
pub trait ExtSimpleState {
    fn set_status(&mut self, message: String);
    fn get_status(&self, account_id: String) -> Option<String>;
}

#[ext_contract(ext)]
pub trait ExtCrossContract {
    fn get_from_other_callback(
        &mut self,
        #[callback]
        #[serializer(borsh)]
        last_read: Option<String>,
    );
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct CrossContract {
    last_read: String,
    state_contract: AccountId,
}

impl Default for CrossContract {
    fn default() -> Self {
        panic!("CrossContract should be initialized before usage")
    }
}

#[near_bindgen]
impl CrossContract {
    #[init]
    pub fn new(state_contract: AccountId) -> Self {
        Self {
            state_contract,
            last_read: "".to_string(),
        }
    }

    #[payable]
    pub fn set_in_other_contract(&mut self, message: String) -> Promise {
        let account_id = env::signer_account_id();
        ext_simple_state::set_status(message, &self.state_contract, 0, env::prepaid_gas() / 2)
    }

    pub fn get_from_other_contract_and_record(&mut self, account_id: String) -> Promise {
        ext_simple_state::get_status(account_id, &self.state_contract, 0, env::prepaid_gas() / 3)
            .then(ext::get_from_other_callback(
                &env::current_account_id(),
                0,
                env::prepaid_gas() / 3,
            ))
    }

    pub fn get_from_other_callback(
        &mut self,
        #[callback]
        #[serializer(borsh)]
        last_read: Option<String>,
    ) {
        if last_read.is_some() {
            self.last_read = last_read.unwrap();
        }
    }

    pub fn get_last_read(&self) -> String {
        self.last_read.clone()
    }
}

'''
'''--- get-sandbox-repro-genesis.js ---
const { Command } = require('commander')
const fetch = require('node-fetch')
const assert = require('assert').strict
const program = new Command()
const fs = require('fs').promises
const path = require('path')
const BN = require('bn.js')

program
  .option('-c, --contracts <contracts...>', 'contract accounts to fetch')
  .option('-a, --accounts <accounts...>', 'accounts and access keys to fetch')
  .option(
    '-b, --block-id <block>',
    'block height to dump, if not specified, will use latest block'
  )
  .option(
    '-u, --rpc-node-url <url>',
    'NEAR rpc node url',
    'https://rpc.testnet.near.org'
  )
  .option(
    '-s, --sandbox-home <dir>',
    'Sandbox Node Home Directory',
    '/tmp/near-sandbox'
  )

async function loadAndBackupSandboxGenesis({ sandboxHome }) {
  let genesis = await fs.readFile(path.join(sandboxHome, 'genesis.json'))
  await fs.writeFile(path.join(sandboxHome, 'genesis.json.bak'), genesis)
  return JSON.parse(genesis)
}

async function fetchContractState({ blockId, contractAccount, rpcNodeUrl }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },

    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'query',
      params: {
        request_type: 'view_state',
        account_id: contractAccount,
        prefix_base64: '',
        ...params,
      },
    }),
  })
  const res = await req.json()
  let stateRecords = []
  for (let kv of res.result.values) {
    stateRecords.push({
      Data: { account_id: contractAccount, data_key: kv.key, value: kv.value },
    })
  }
  return stateRecords
}

async function fetchContractCode({ rpcNodeUrl, contractAccount, blockId }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'query',
      params: {
        request_type: 'view_code',
        account_id: contractAccount,
        prefix_base64: '',
        ...params,
      },
    }),
  })
  const res = await req.json()
  return {
    Contract: { account_id: contractAccount, code: res.result.code_base64 },
  }
}

async function fetchBlock({ rpcNodeUrl, blockId }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'block',
      params,
    }),
  })
  const res = await req.json()
  return res.result
}

async function fetchAccount({ blockId, rpcNodeUrl, account }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'query',
      params: {
        request_type: 'view_account',
        account_id: account,
        ...params,
      },
    }),
  })
  const res = await req.json()
  return formatAccount(account, res.result)
}

function formatAccount(accountId, account) {
  return {
    Account: {
      account_id: accountId,
      account: {
        amount: account.amount,
        locked: account.locked,
        code_hash: account.code_hash,
        storage_usage: account.storage_usage,
      },
    },
  }
}

async function fetchAccessKey({ blockId, rpcNodeUrl, account }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'query',
      params: {
        request_type: 'view_access_key_list',
        account_id: account,
        ...params,
      },
    }),
  })
  const res = await req.json()
  return res.result.keys.map((key) => formatAccessKey(account, key))
}

function formatAccessKey(account_id, key) {
  return {
    AccessKey: {
      account_id,
      ...key,
    },
  }
}

async function fetchProtocolConfig({ blockId, rpcNodeUrl }) {
  let params = blockId ? { block_id: Number(blockId) } : { finality: 'final' }
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'EXPERIMENTAL_protocol_config',
      params,
    }),
  })
  const res = await req.json()
  return res.result
}

async function fetchGenesisConfig({ rpcNodeUrl }) {
  const req = await fetch(rpcNodeUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'EXPERIMENTAL_genesis_config',
    }),
  })
  const res = await req.json()
  return res.result
}

function calculateOutputGenesisConfig({
  sandboxGenesis,
  protocolConfig,
  targetNetGenesis,
}) {
  // None of the genesis/protocol config from target net or the local sandbox's genesis config alone cannot
  // be used as sandbox's genesis config to reproduce transaction. So we calculate a synthetic genesis config
  // given these three.
  return {
    // Use protocol config as basis
    ...protocolConfig,
    // Network ID cannot be testnet or mainnet
    chain_id: 'sandbox-' + protocolConfig.chain_id,
    // This field is not available in protocol config yet
    protocol_upgrade_num_epochs: targetNetGenesis.protocol_upgrade_num_epochs,
    // Total supply is tricky, depends which accounts are added (specified by -a option), they should add up
    total_supply: sandboxGenesis.total_supply,
    // Use validator local sandbox's validator/key info so sandbox can continue produce blocks
    validators: sandboxGenesis.validators,
    records: sandboxGenesis.records,
  }
}

function addAccountToTotalSupply(genesis, account) {
  genesis.total_supply = new BN(genesis.total_supply)
    .add(new BN(account.Account.account.amount))
    .add(new BN(account.Account.account.locked))
    .toString()
}

async function main() {
  program.parse(process.argv)
  const options = program.opts()
  let sandboxGenesis = await loadAndBackupSandboxGenesis({
    sandboxHome: options.sandboxHome,
  })
  let protocolConfig = await fetchProtocolConfig({
    blockId: options.blockId,
    rpcNodeUrl: options.rpcNodeUrl,
  })
  let targetNetGenesis = await fetchGenesisConfig({
    rpcNodeUrl: options.rpcNodeUrl,
  })
  let outputGenesisConfig = calculateOutputGenesisConfig({
    sandboxGenesis,
    protocolConfig,
    targetNetGenesis,
  })
  let state_records = []
  if (options.contracts) {
    for (let contract of options.contracts) {
      let code = await fetchContractCode({
        contractAccount: contract,
        blockId: options.blockId,
        rpcNodeUrl: options.rpcNodeUrl,
      })
      let states = await fetchContractState({
        contractAccount: contract,
        blockId: options.blockId,
        rpcNodeUrl: options.rpcNodeUrl,
      })
      let account = await fetchAccount({
        account: contract,
        blockId: options.blockId,
        rpcNodeUrl: options.rpcNodeUrl,
      })
      let accessKeys = await fetchAccessKey({
        account: contract,
        blockId: options.blockId,
        rpcNodeUrl: options.rpcNodeUrl,
      })
      state_records.push(account)
      addAccountToTotalSupply(outputGenesisConfig, account)
      state_records = state_records.concat(accessKeys)
      state_records.push(code)
      state_records = state_records.concat(states)
    }
  }
  if (options.accounts) {
    for (let accountId of options.accounts) {
      if (
        !options.contracts ||
        (options.contracts && !options.contracts.includes(accountId))
      ) {
        let account = await fetchAccount({
          account: accountId,
          blockId: options.blockId,
          rpcNodeUrl: options.rpcNodeUrl,
        })
        let accessKeys = await fetchAccessKey({
          account: accountId,
          blockId: options.blockId,
          rpcNodeUrl: options.rpcNodeUrl,
        })
        state_records.push(account)
        addAccountToTotalSupply(outputGenesisConfig, account)
        state_records = state_records.concat(accessKeys)
      }
    }
  }
  outputGenesisConfig.records =
    outputGenesisConfig.records.concat(state_records)
  await fs.writeFile(
    path.join(options.sandboxHome, 'genesis.json'),
    JSON.stringify(outputGenesisConfig, null, 2)
  )
}

main()

'''
'''--- index.js ---
const { Command } = require("commander");
const fetch = require("node-fetch");
const assert = require("assert").strict;
const program = new Command();
const fs = require("fs").promises;

program
  .requiredOption("-a, --account <account>", "account id")
  .requiredOption("-t, --transaction <transaction>", "transaction hash")
  .option("-r --receipt-id <receipt-id>", "receipt id (hash)")
  .option(
    "-u, --rpc-node-url <url>",
    "NEAR rpc node url",
    "https://rpc.testnet.near.org"
  );

function txnStatusFullToVMContext({ txnStatusFull, receiptId }) {
  const { transaction, receipts } = txnStatusFull;
  let receipt = receiptId
    ? receipts.filter((r) => r.receipt_id == receiptId)
    : receipts.filter(
        (r) =>
          r.receiver_id == transaction.receiver_id &&
          r.predecessor_id == transaction.signer_id
      );

  assert(receipt.length == 1);
  receipt = receipt[0];
  let action = receipt.receipt.Action.actions;
  assert(action.length == 1);
  action = action[0];
  assert(action.FunctionCall);
  let signer_account_pk = transaction.public_key.split(":");
  assert(signer_account_pk[0] == "ed25519");
  signer_account_pk = signer_account_pk[1];
  return {
    current_account_id: receipt.receiver_id,
    signer_account_id: transaction.signer_id,
    signer_account_pk,
    predecessor_account_id: receipt.predecessor_id,
    input: action.FunctionCall.args,
    attached_deposit: action.FunctionCall.deposit,
    prepaid_gas: action.FunctionCall.gas,
    is_view: false,
    output_data_receivers: receipt.receipt.Action.output_data_receivers.map(
      (r) => r.receiver_id
    ),
  };
}

async function fetchBlock({ blockHash, rpcNodeUrl }) {
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "block",
      params: {
        block_id: blockHash,
      },
    }),
  });
  const res = await req.json();
  return res.result;
}

async function fetchTxnStatusFull({ transaction, account, rpcNodeUrl }) {
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "EXPERIMENTAL_tx_status",
      params: [transaction, account],
    }),
  });
  const res = await req.json();
  return res.result;
}

function blockToVMContext(block) {
  return {
    block_index: block.header.height,

    // TODO: once https://github.com/near/nearcore/pull/4221 merged, we'll have epoch_height from `validators` rpc
    // epoch_height: block.header.epoch_id,
    epoch_height: 1,
    block_timestamp: block.header.timestamp_nanosec,
    random_seed: block.header.random_value,
  };
}

async function fetchAccount({ blockHash, rpcNodeUrl, account }) {
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "query",
      params: {
        request_type: "view_account",
        block_id: blockHash,
        account_id: account,
      },
    }),
  });
  const res = await req.json();
  return res.result;
}

function accountToVMContext(account) {
  return {
    account_balance: account.amount,
    account_locked_balance: account.locked,
    storage_usage: account.storage_usage,
  };
}

async function fetchContractState({ rpcNodeUrl, contractAccount, blockHash }) {
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "query",
      params: {
        request_type: "view_state",
        block_id: blockHash,
        account_id: contractAccount,
        prefix_base64: "",
      },
    }),
  });
  const res = await req.json();
  console.log(res.result.values);
  let state = {};
  for (let kv of res.result.values) {
    state[kv.key] = kv.value;
  }
  return state;
}

async function fetchContractCode({ rpcNodeUrl, contractAccount, blockHash }) {
  const req = await fetch(rpcNodeUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "query",
      params: {
        request_type: "view_code",
        block_id: blockHash,
        account_id: contractAccount,
        prefix_base64: "",
      },
    }),
  });
  const res = await req.json();
  return Buffer.from(res.result.code_base64, "base64");
}

async function main() {
  program.parse(process.argv);
  const options = program.opts();
  const txnStatusFull = await fetchTxnStatusFull(options);
  const vmContext1 = txnStatusFullToVMContext({
    txnStatusFull,
    receiptId: options.receiptId,
  });
  let blockHash;
  if (options.receiptId) {
    let receipt = txnStatusFull.receipts_outcome.filter(
      (r) => r.id == options.receiptId
    );
    blockHash = receipt[0].block_hash;
  } else {
    blockHash = txnStatusFull.transaction_outcome.block_hash;
  }
  const block = await fetchBlock({
    blockHash,
    rpcNodeUrl: options.rpcNodeUrl,
  });
  const vmContext2 = blockToVMContext(block);
  const account = await fetchAccount({
    blockHash: txnStatusFull.transaction_outcome.block_hash,
    rpcNodeUrl: options.rpcNodeUrl,
    account: options.account,
  });
  const vmContext3 = accountToVMContext(account);
  const vmContext = { ...vmContext1, ...vmContext2, ...vmContext3 };

  await fs.writeFile("./vmcontext.json", JSON.stringify(vmContext, null, 2));
  const code = await fetchContractCode({
    rpcNodeUrl: options.rpcNodeUrl,
    contractAccount: vmContext.current_account_id,
    blockHash: txnStatusFull.transaction_outcome.block_hash,
  });
  await fs.writeFile("./contract.wasm", code);

  const state = await fetchContractState({
    rpcNodeUrl: options.rpcNodeUrl,
    contractAccount: vmContext.current_account_id,
    blockHash: txnStatusFull.transaction_outcome.block_hash,
  });
  await fs.writeFile("./state.json", JSON.stringify(state, null, 2));
}

main();

'''
'''--- multiple-state/Cargo.toml ---
[package]
name = "multiple-state"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []
'''
'''--- multiple-state/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::{env, near_bindgen, setup_alloc};

setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultipleState {
    records: UnorderedMap<String, UnorderedMap<String, String>>,
}

impl Default for MultipleState {
    fn default() -> Self {
        panic!("MultipleState should be initialized before usage")
    }
}

#[near_bindgen]
impl MultipleState {
    #[init]
    pub fn new() -> Self {
        Self { records: UnorderedMap::new(b"records".to_vec()) }
    }

    #[payable]
    pub fn set(&mut self, title: String, message: String) {
        let account_id = env::signer_account_id();
        let mut account_records = match self.records.get(&account_id) {
            Some(existing) => existing,
            None => UnorderedMap::new(b"account-record".to_vec()),
        };
        account_records.insert(&title, &message);
        self.records.insert(&account_id, &account_records);
    }

    pub fn get(&self, account_id: String, title: String) -> Option<String> {
        assert!(env::is_valid_account_id(account_id.as_bytes()), "Given account ID is invalid");
        self.records.get(&account_id).and_then(|account_records| account_records.get(&title))
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use std::convert::TryInto;

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("bob_near".try_into().unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    fn set_get_message() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = MultipleState::new();
        contract.set("hello".to_string(), "world".to_string());
        let context = get_context(true);
        testing_env!(context);
        assert_eq!(
            "world".to_string(),
            contract.get("bob_near".to_string(), "hello".to_string()).unwrap()
        );
    }

    #[test]
    fn get_nonexistent_message() {
        let context = get_context(true);
        testing_env!(context);
        let contract = MultipleState::new();
        assert_eq!(None, contract.get("francis.near".to_string(), "what".to_string()));
    }
}

'''
'''--- package-lock.json ---
{
  "name": "repro-near-funcall",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@types/bn.js": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-5.1.0.tgz",
      "integrity": "sha512-QSSVYj7pYFN49kW77o2s9xTCwZ8F2xLbjLLSEVh8D2F4JUhZtPAGOFLTD+ffqksBx/u4cE/KImFjyhqCjn/LIA==",
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/node": {
      "version": "14.14.37",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.14.37.tgz",
      "integrity": "sha512-XYmBiy+ohOR4Lh5jE379fV2IU+6Jn4g5qASinhitfyO71b/sCo6MKsMLF5tc7Zf2CE8hViVQyYSobJNke8OvUw=="
    },
    "base-x": {
      "version": "3.0.8",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.8.tgz",
      "integrity": "sha512-Rl/1AWP4J/zRrk54hhlxH4drNxPJXYUaKffODVI53/dAsV4t9fBxyxYKAVPU1XBHxYwOWP9h9H0hM2MVw4YfJA==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "borsh": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.3.1.tgz",
      "integrity": "sha512-gJoSTnhwLxN/i2+15Y7uprU8h3CKI+Co4YKZKvrGYUy0FwHWM20x5Sx7eU8Xv4HQqV+7rb4r3P7K1cBIQe3q8A==",
      "requires": {
        "@types/bn.js": "^4.11.5",
        "bn.js": "^5.0.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      },
      "dependencies": {
        "@types/bn.js": {
          "version": "4.11.6",
          "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-4.11.6.tgz",
          "integrity": "sha512-pqr857jrp2kPuO9uRjZ3PwnJTjoQy+fcdxvBTvHm6dkmEL9q+hDD/2j/0ELOBPtPnS8LjCX0gI9nbl8lVkadpg==",
          "requires": {
            "@types/node": "*"
          }
        }
      }
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE="
    },
    "commander": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-7.2.0.tgz",
      "integrity": "sha512-QrWXB+ZQSVPmIWIhtEO9H+gwHaMGYiF5ChvoJ+K9ZGHG/sVsa6yiesAD1GC/x46sET00Xlwo1u49RVVVzvcSkw=="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw=="
    },
    "error-polyfill": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.2.tgz",
      "integrity": "sha512-8uhnXlJuhFkmIfhw2tAHtWQGpXcw5rrc0dhuY3bhn8tBHvh6l0oL9VJvR2suqx9eltglKKhVPv8luPQy+UxLTA==",
      "requires": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.0"
      }
    },
    "http-errors": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.0.tgz",
      "integrity": "sha512-4I8r0C5JDhT5VkvI47QktDW75rNlGVsUf/8hzjCC/wkWI/jdTRmBb9aI7erSG82r1bjKY3F6k28WnsVxB1C73A==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.0"
      },
      "dependencies": {
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
        }
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ=="
    },
    "near-api-js": {
      "version": "0.39.0",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.39.0.tgz",
      "integrity": "sha512-RX2oLOg438QCY3UQLb6FMkXmInFQIS0S+xg/auNZP292ySsMTKppoD07g/ExEFbW8Uyej8/TvjhBjKxnDBUigQ==",
      "requires": {
        "@types/bn.js": "^5.1.0",
        "bn.js": "^5.0.0",
        "borsh": "^0.3.1",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.2",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node-fetch": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.1.tgz",
      "integrity": "sha512-V4aYg89jEoVRxRb2fJdAg8FHvI7cEyYdVAh94HH0UIK8oJxUfkjlDQN9RbMx+bEjP7+ggMiFRprSti032Oipxw=="
    },
    "o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
      "requires": {
        "capability": "^0.2.5"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "toidentifier": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.0.tgz",
      "integrity": "sha512-yaOH/Pk/VEhBWWTlhI+qXxDFXlejDGcQipMlyxda9nthulaxLZUNcUqFxokp0vcYnvteJln5FNQDRrxj3YcbVw=="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "u3": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.0.tgz",
      "integrity": "sha1-AGCSdmO2g1PFOc2pnpUR1mh+3Z0="
    }
  }
}

'''
'''--- package.json ---
{
  "name": "repro-near-funcall",
  "version": "1.0.0",
  "description": "Repro near function call actions with local near-vm-runner-standalone",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bn.js": "^5.2.0",
    "commander": "^7.2.0",
    "near-api-js": "^0.39.0",
    "node-fetch": "^2.6.1"
  }
}

'''
'''--- simple-state/Cargo.toml ---
[package]
name = "simple-state"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []
'''
'''--- simple-state/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, metadata, near_bindgen, setup_alloc};

use std::collections::HashMap;

setup_alloc!();

metadata! {
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct SimpleState {
    records: HashMap<String, String>,
}

#[near_bindgen]
impl SimpleState {
    #[payable]
    pub fn set_status(&mut self, message: String) {
        let account_id = env::signer_account_id();
        log!("{} set_status with message {}", account_id, message);
        self.records.insert(account_id, message);
    }

    #[result_serializer(borsh)]
    pub fn get_status(&self, account_id: String) -> Option::<String> {
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Given account ID is invalid"
        );
        log!("get_status for account_id {}", account_id);
        self.records.get(&account_id).cloned()
    }
}
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use std::convert::TryInto;

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("bob_near".try_into().unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    fn set_get_message() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = SimpleState::default();
        contract.set_status("hello".to_string());
        assert_eq!(get_logs(), vec!["bob_near set_status with message hello"]);
        let context = get_context(true);
        testing_env!(context);
        assert_eq!(
            "hello".to_string(),
            contract.get_status("bob_near".to_string()).unwrap()
        );
        assert_eq!(get_logs(), vec!["get_status for account_id bob_near"])
    }

    #[test]
    fn get_nonexistent_message() {
        let context = get_context(true);
        testing_env!(context);
        let contract = SimpleState::default();
        assert_eq!(None, contract.get_status("francis.near".to_string()));
        assert_eq!(get_logs(), vec!["get_status for account_id francis.near"])
    }
}

'''
'''--- src/lib.rs ---

'''