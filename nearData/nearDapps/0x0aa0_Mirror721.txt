*GitHub Repository "0x0aa0/Mirror721"*

'''--- lib/wormhole/algorand/TmplSig.py ---
from time import time, sleep
from typing import List, Tuple, Dict, Any, Optional, Union
from base64 import b64decode
import base64
import random
import hashlib
import uuid
import sys
import json
import uvarint
import pprint

from local_blob import LocalBlob

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic
from algosdk.encoding import decode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address

from algosdk.future.transaction import LogicSigAccount

class TmplSig:
    """KeySig class reads in a json map containing assembly details of a template smart signature and allows you to populate it with the variables
    In this case we are only interested in a single variable, the key which is a byte string to make the address unique.
    In this demo we're using random strings but in practice you can choose something meaningful to your application
    """

    def __init__(self, name):
        # Read the source map

#        with open("{}.json".format(name)) as f:
#            self.map = json.loads(f.read())

        self.map = {"name":"lsig.teal","version":6,"source":"","bytecode":"BiABAYEASIAASDEQgQYSRDEZIhJEMRiBABJEMSCAABJEMQGBABJEMQkyAxJEMRUyAxJEIg==",
                    "template_labels":{
                        "TMPL_ADDR_IDX":{"source_line":3,"position":5,"bytes":False},
                        "TMPL_EMITTER_ID":{"source_line":5,"position":8,"bytes":True},
                        "TMPL_APP_ID":{"source_line":16,"position":24,"bytes":False},
                        "TMPL_APP_ADDRESS":{"source_line":20,"position":30,"bytes":True}
                    },
                    "label_map":{},"line_map":[0,1,4,6,7,9,10,12,14,15,16,18,19,20,21,23,25,26,27,29,31,32,33,35,37,38,39,41,43,44,45,47,49,50,51]
        }

        self.src = base64.b64decode(self.map["bytecode"])
        self.sorted = dict(
            sorted(
                self.map["template_labels"].items(),
                key=lambda item: item[1]["position"],
            )
        )

    def populate(self, values: Dict[str, Union[str, int]]) -> LogicSigAccount:
        """populate uses the map to fill in the variable of the bytecode and returns a logic sig with the populated bytecode"""
        # Get the template source
        contract = list(base64.b64decode(self.map["bytecode"]))

        shift = 0
        for k, v in self.sorted.items():
            if k in values:
                pos = v["position"] + shift
                if v["bytes"]:
                    val = bytes.fromhex(values[k])
                    lbyte = uvarint.encode(len(val))
                    # -1 to account for the existing 00 byte for length
                    shift += (len(lbyte) - 1) + len(val)
                    # +1 to overwrite the existing 00 byte for length
                    contract[pos : pos + 1] = lbyte + val
                else:
                    val = uvarint.encode(values[k])
                    # -1 to account for existing 00 byte
                    shift += len(val) - 1
                    # +1 to overwrite existing 00 byte
                    contract[pos : pos + 1] = val

        # Create a new LogicSigAccount given the populated bytecode,

        #pprint.pprint({"values": values, "contract": bytes(contract).hex()})

        return LogicSigAccount(bytes(contract))

    def get_bytecode_chunk(self, idx: int) -> Bytes:
        start = 0
        if idx > 0:
            start = list(self.sorted.values())[idx - 1]["position"] + 1

        stop = len(self.src)
        if idx < len(self.sorted):
            stop = list(self.sorted.values())[idx]["position"]

        chunk = self.src[start:stop]
        return Bytes(chunk)

    def get_bytecode_raw(self, idx: int):
        start = 0
        if idx > 0:
            start = list(self.sorted.values())[idx - 1]["position"] + 1

        stop = len(self.src)
        if idx < len(self.sorted):
            stop = list(self.sorted.values())[idx]["position"]

        chunk = self.src[start:stop]
        return chunk

    def get_sig_tmpl(self):
        def sig_tmpl():
            admin_app_id = ScratchVar()
            admin_address= ScratchVar()

            return Seq(
                # Just putting adding this as a tmpl var to make the address unique and deterministic
                # We don't actually care what the value is, pop it
                Pop(Tmpl.Int("TMPL_ADDR_IDX")),
                Pop(Tmpl.Bytes("TMPL_EMITTER_ID")),
                
                Assert(Txn.type_enum() == TxnType.ApplicationCall),
                Assert(Txn.on_completion() == OnComplete.OptIn),
                Assert(Txn.application_id() == Tmpl.Int("TMPL_APP_ID")),
                Assert(Txn.rekey_to() == Tmpl.Bytes("TMPL_APP_ADDRESS")),

                Assert(Txn.fee() == Int(0)),
                Assert(Txn.close_remainder_to() == Global.zero_address()),
                Assert(Txn.asset_close_to() == Global.zero_address()),
                
                Approve()
            )
        
        return compileTeal(sig_tmpl(), mode=Mode.Signature, version=6, assembleConstants=True)

if __name__ == '__main__':
    core = TmplSig("sig")
#    client =  AlgodClient("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "http://localhost:4001")
#    pprint.pprint(client.compile( core.get_sig_tmpl()))

    with open("sig.tmpl.teal", "w") as f:
        f.write(core.get_sig_tmpl())

'''
'''--- lib/wormhole/algorand/admin.py ---
# python3 -m pip install pycryptodomex uvarint pyteal web3 coincurve

import os
from os.path import exists
from time import time, sleep
from eth_abi import encode_single, encode_abi
from typing import List, Tuple, Dict, Any, Optional, Union
from base64 import b64decode
import base64
import random
import time
import hashlib
import uuid
import sys
import json
import uvarint
from local_blob import LocalBlob
from wormhole_core import getCoreContracts
from TmplSig import TmplSig
import argparse
from gentest import GenTest

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic, abi
from algosdk.encoding import decode_address, encode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address
from vaa_verify import get_vaa_verify

from Cryptodome.Hash import keccak

from algosdk.future.transaction import LogicSig

from token_bridge import get_token_bridge

from test_contract import get_test_app

from algosdk.v2client import indexer

import pprint

max_keys = 15
max_bytes_per_key = 127
bits_per_byte = 8

bits_per_key = max_bytes_per_key * bits_per_byte
max_bytes = max_bytes_per_key * max_keys
max_bits = bits_per_byte * max_bytes

class Account:
    """Represents a private key and address for an Algorand account"""

    def __init__(self, privateKey: str) -> None:
        self.sk = privateKey
        self.addr = account.address_from_private_key(privateKey)
        print (privateKey)
        print ("    " + self.getMnemonic())
        print ("    " + self.addr)

    def getAddress(self) -> str:
        return self.addr

    def getPrivateKey(self) -> str:
        return self.sk

    def getMnemonic(self) -> str:
        return mnemonic.from_private_key(self.sk)

    @classmethod
    def FromMnemonic(cls, m: str) -> "Account":
        return cls(mnemonic.to_private_key(m))

class PendingTxnResponse:
    def __init__(self, response: Dict[str, Any]) -> None:
        self.poolError: str = response["pool-error"]
        self.txn: Dict[str, Any] = response["txn"]

        self.applicationIndex: Optional[int] = response.get("application-index")
        self.assetIndex: Optional[int] = response.get("asset-index")
        self.closeRewards: Optional[int] = response.get("close-rewards")
        self.closingAmount: Optional[int] = response.get("closing-amount")
        self.confirmedRound: Optional[int] = response.get("confirmed-round")
        self.globalStateDelta: Optional[Any] = response.get("global-state-delta")
        self.localStateDelta: Optional[Any] = response.get("local-state-delta")
        self.receiverRewards: Optional[int] = response.get("receiver-rewards")
        self.senderRewards: Optional[int] = response.get("sender-rewards")

        self.innerTxns: List[Any] = response.get("inner-txns", [])
        self.logs: List[bytes] = [b64decode(l) for l in response.get("logs", [])]

class PortalCore:
    def __init__(self) -> None:
        self.gt = None
        self.foundation = None
        self.devnet = False

        self.ALGOD_ADDRESS = "http://localhost:4001"
        self.ALGOD_TOKEN = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        self.FUNDING_AMOUNT = 100_000_000_000

        self.KMD_ADDRESS = "http://localhost:4002"
        self.KMD_TOKEN = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        self.KMD_WALLET_NAME = "unencrypted-default-wallet"
        self.KMD_WALLET_PASSWORD = ""

        self.INDEXER_TOKEN = "a" * 64
        self.INDEXER_ADDRESS = 'http://localhost:8980'
        self.INDEXER_ROUND = 0
        self.NOTE_PREFIX = 'publishMessage'.encode()

        self.myindexer = None

        self.seed_amt = int(1002000)  # The black magic in this number... 
        self.cache = {}
        self.asset_cache = {}

        self.kmdAccounts : Optional[List[Account]] = None

        self.accountList : List[Account] = []
        self.zeroPadBytes = "00"*32

        self.tsig = TmplSig("sig")

    def init(self, args) -> None:
        self.args = args
        self.ALGOD_ADDRESS = args.algod_address
        self.ALGOD_TOKEN = args.algod_token
        self.KMD_ADDRESS = args.kmd_address
        self.KMD_TOKEN = args.kmd_token
        self.KMD_WALLET_NAME = args.kmd_name
        self.KMD_WALLET_PASSWORD = args.kmd_password
        self.TARGET_ACCOUNT = args.mnemonic
        self.coreid = args.coreid
        self.tokenid = args.tokenid

        if exists(self.args.env):
            if self.gt == None:
                self.gt = GenTest(False)

            with open(self.args.env, encoding = 'utf-8') as f:
                for line in f:
                    e = line.rstrip('\n').split("=")
                    if "INIT_SIGNERS_CSV" in e[0]:
                        self.gt.guardianKeys = e[1].split(",")
                        print("guardianKeys=" + str(self.gt.guardianKeys))
                    if "INIT_SIGNERS_KEYS_CSV" in e[0]:
                        self.gt.guardianPrivKeys = e[1].split(",")
                        print("guardianPrivKeys=" + str(self.gt.guardianPrivKeys))

    def waitForTransaction(
            self, client: AlgodClient, txID: str, timeout: int = 10
    ) -> PendingTxnResponse:
        lastStatus = client.status()
        lastRound = lastStatus["last-round"]
        startRound = lastRound
    
        while lastRound < startRound + timeout:
            pending_txn = client.pending_transaction_info(txID)
    
            if pending_txn.get("confirmed-round", 0) > 0:
                return PendingTxnResponse(pending_txn)
    
            if pending_txn["pool-error"]:
                raise Exception("Pool error: {}".format(pending_txn["pool-error"]))
    
            lastStatus = client.status_after_block(lastRound + 1)
    
            lastRound += 1
    
        raise Exception(
            "Transaction {} not confirmed after {} rounds".format(txID, timeout)
        )

    def getKmdClient(self) -> KMDClient:
        return KMDClient(self.KMD_TOKEN, self.KMD_ADDRESS)
    
    def getGenesisAccounts(self) -> List[Account]:
        if self.kmdAccounts is None:
            kmd = self.getKmdClient()
    
            wallets = kmd.list_wallets()
            walletID = None
            for wallet in wallets:
                if wallet["name"] == self.KMD_WALLET_NAME:
                    walletID = wallet["id"]
                    break
    
            if walletID is None:
                raise Exception("Wallet not found: {}".format(self.KMD_WALLET_NAME))
    
            walletHandle = kmd.init_wallet_handle(walletID, self.KMD_WALLET_PASSWORD)
    
            try:
                addresses = kmd.list_keys(walletHandle)
                privateKeys = [
                    kmd.export_key(walletHandle, self.KMD_WALLET_PASSWORD, addr)
                    for addr in addresses
                ]
                self.kmdAccounts = [Account(sk) for sk in privateKeys]
            finally:
                kmd.release_wallet_handle(walletHandle)
    
        return self.kmdAccounts
    
    def getTemporaryAccount(self, client: AlgodClient) -> Account:
        if len(self.accountList) == 0:
            sks = [account.generate_account()[0] for i in range(3)]
            self.accountList = [Account(sk) for sk in sks]
    
            genesisAccounts = self.getGenesisAccounts()
            suggestedParams = client.suggested_params()
    
            txns: List[transaction.Transaction] = []
            for i, a in enumerate(self.accountList):
                fundingAccount = genesisAccounts[i % len(genesisAccounts)]
                txns.append(
                    transaction.PaymentTxn(
                        sender=fundingAccount.getAddress(),
                        receiver=a.getAddress(),
                        amt=self.FUNDING_AMOUNT,
                        sp=suggestedParams,
                    )
                )
    
            txns = transaction.assign_group_id(txns)
            signedTxns = [
                txn.sign(genesisAccounts[i % len(genesisAccounts)].getPrivateKey())
                for i, txn in enumerate(txns)
            ]
    
            client.send_transactions(signedTxns)
    
            self.waitForTransaction(client, signedTxns[0].get_txid())
    
        return self.accountList.pop()
    
    def getAlgodClient(self) -> AlgodClient:
        return AlgodClient(self.ALGOD_TOKEN, self.ALGOD_ADDRESS)

    def getBalances(self, client: AlgodClient, account: str) -> Dict[int, int]:
        balances: Dict[int, int] = dict()
    
        accountInfo = client.account_info(account)
    
        # set key 0 to Algo balance
        balances[0] = accountInfo["amount"]
    
        assets: List[Dict[str, Any]] = accountInfo.get("assets", [])
        for assetHolding in assets:
            assetID = assetHolding["asset-id"]
            amount = assetHolding["amount"]
            balances[assetID] = amount
    
        return balances

    def fullyCompileContract(self, client: AlgodClient, contract: Expr) -> bytes:
        teal = compileTeal(contract, mode=Mode.Application, version=6)
        response = client.compile(teal)
        return response

    # helper function that formats global state for printing
    def format_state(self, state):
        formatted = {}
        for item in state:
            key = item['key']
            value = item['value']
            formatted_key = base64.b64decode(key).decode('utf-8')
            if value['type'] == 1:
                # byte string
                if formatted_key == 'voted':
                    formatted_value = base64.b64decode(value['bytes']).decode('utf-8')
                else:
                    formatted_value = value['bytes']
                formatted[formatted_key] = formatted_value
            else:
                # integer
                formatted[formatted_key] = value['uint']
        return formatted
    
    # helper function to read app global state
    def read_global_state(self, client, addr, app_id):
        results = self.client.application_info(app_id)
        return self.format_state(results['params']['global-state'])

    def read_state(self, client, addr, app_id):
        results = client.account_info(addr)
        apps_created = results['created-apps']
        for app in apps_created:
            if app['id'] == app_id:
                return app
        return {}

    def encoder(self, type, val):
        if type == 'uint8':
            return encode_single(type, val).hex()[62:64]
        if type == 'uint16':
            return encode_single(type, val).hex()[60:64]
        if type == 'uint32':
            return encode_single(type, val).hex()[56:64]
        if type == 'uint64':
            return encode_single(type, val).hex()[64-(16):64]
        if type == 'uint128':
            return encode_single(type, val).hex()[64-(32):64]
        if type == 'uint256' or type == 'bytes32':
            return encode_single(type, val).hex()[64-(64):64]
        raise Exception("invalid type")

    def devnetUpgradeVAA(self):
        v = self.genUpgradePayload()
        print("core payload: " + str(v[0]))
        print("token payload: " + str(v[1]))

        if self.gt == None:
            self.gt = GenTest(False)

        emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")

        guardianSet = self.getGovSet()

        print("guardianSet: " + str(guardianSet))

        nonce = int(random.random() * 20000)
        ret = [
            self.gt.createSignedVAA(guardianSet, self.gt.guardianPrivKeys, int(time.time()), nonce, 1, emitter, int(random.random() * 20000), 32, 8, v[0]),
            self.gt.createSignedVAA(guardianSet, self.gt.guardianPrivKeys, int(time.time()), nonce, 1, emitter, int(random.random() * 20000), 32, 8, v[1]),
        ]
        
#        pprint.pprint(self.parseVAA(bytes.fromhex(ret[0])))
#        pprint.pprint(self.parseVAA(bytes.fromhex(ret[1])))

        return ret

    def getMessageFee(self):
        s = self.client.application_info(self.coreid)["params"]["global-state"]
        k = base64.b64encode(b"MessageFee").decode('utf-8')
        for x in s:
            if x["key"] == k:
                return x["value"]["uint"]
        return -1

    def getGovSet(self):
        s = self.client.application_info(self.coreid)["params"]["global-state"]
        k = base64.b64encode(b"currentGuardianSetIndex").decode('utf-8')
        for x in s:
            if x["key"] == k:
                return x["value"]["uint"]
        return -1

    def genUpgradePayload(self):
        approval1, clear1 = getCoreContracts(False, self.args.core_approve, self.args.core_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)

        approval2, clear2 = get_token_bridge(False, self.args.token_approve, self.args.token_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)

        return self.genUpgradePayloadBody(approval1, approval2)

    def genUpgradePayloadBody(self, approval1, approval2):
        b  = self.zeroPadBytes[0:(28*2)]
        b += self.encoder("uint8", ord("C"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", 1)
        b += self.encoder("uint16", 8)

        b += decode_address(approval1["hash"]).hex()
        print("core hash: " + decode_address(approval1["hash"]).hex())

        ret = [b]

        b  = self.zeroPadBytes[0:((32 -11)*2)]
        b += self.encoder("uint8", ord("T"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("k"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", ord("n"))
        b += self.encoder("uint8", ord("B"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("i"))
        b += self.encoder("uint8", ord("d"))
        b += self.encoder("uint8", ord("g"))
        b += self.encoder("uint8", ord("e"))

        b += self.encoder("uint8", 2)  # action
        b += self.encoder("uint16", 8) # target chain
        b += decode_address(approval2["hash"]).hex()
        print("token hash: " + decode_address(approval2["hash"]).hex())

        ret.append(b)
        return ret

    def createPortalCoreApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = getCoreContracts(False, self.args.core_approve, self.args.core_clear, client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)

        globalSchema = transaction.StateSchema(num_uints=8, num_byte_slices=40)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        app_args = [ ]
    
        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            extra_pages = 1,
            app_args=app_args,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        assert response.applicationIndex is not None and response.applicationIndex > 0

        # Lets give it a bit of money so that it is not a "ghost" account
        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), receiver = get_application_address(response.applicationIndex), amt = 100000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def createTokenBridgeApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = get_token_bridge(False, self.args.token_approve, self.args.token_clear, client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)

        if len(b64decode(approval["result"])) > 4060:
            print("token bridge contract is too large... This might prevent updates later")

        globalSchema = transaction.StateSchema(num_uints=4, num_byte_slices=30)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        app_args = [self.coreid, decode_address(get_application_address(self.coreid))]

        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            app_args=app_args,
            extra_pages = 2,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        #pprint.pprint(response.__dict__)
        assert response.applicationIndex is not None and response.applicationIndex > 0

        # Lets give it a bit of money so that it is not a "ghost" account
        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), receiver = get_application_address(response.applicationIndex), amt = 100000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def createTestApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = get_test_app(client)

        globalSchema = transaction.StateSchema(num_uints=4, num_byte_slices=30)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        assert response.applicationIndex is not None and response.applicationIndex > 0

        # Lets give it a bit of money so that it is not a "ghost" account
        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), receiver = get_application_address(response.applicationIndex), amt = 100000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def account_exists(self, client, app_id, addr):
        try:
            ai = client.account_info(addr)
            if "apps-local-state" not in ai:
                return False
    
            for app in ai["apps-local-state"]:
                if app["id"] == app_id:
                    return True
        except:
            print("Failed to find account {}".format(addr))
        return False

    def optin(self, client, sender, app_id, idx, emitter, doCreate=True):
        aa = decode_address(get_application_address(app_id)).hex()

        lsa = self.tsig.populate(
            {
                "TMPL_APP_ID": app_id,
                "TMPL_APP_ADDRESS": aa,
                "TMPL_ADDR_IDX": idx,
                "TMPL_EMITTER_ID": emitter,
            }
        )

        sig_addr = lsa.address()

        if sig_addr not in self.cache and not self.account_exists(client, app_id, sig_addr):
            if doCreate:
#                pprint.pprint(("Creating", app_id, idx, emitter, sig_addr))

                # Create it
                sp = client.suggested_params()
    
                seed_txn = transaction.PaymentTxn(sender = sender.getAddress(), 
                                                  sp = sp, 
                                                  receiver = sig_addr, 
                                                  amt = self.seed_amt)
                seed_txn.fee = seed_txn.fee * 2

                optin_txn = transaction.ApplicationOptInTxn(sig_addr, sp, app_id, rekey_to=get_application_address(app_id))
                optin_txn.fee = 0
    
                transaction.assign_group_id([seed_txn, optin_txn])
    
                signed_seed = seed_txn.sign(sender.getPrivateKey())
                signed_optin = transaction.LogicSigTransaction(optin_txn, lsa)
    
                client.send_transactions([signed_seed, signed_optin])
                self.waitForTransaction(client, signed_optin.get_txid())
                
                self.cache[sig_addr] = True

        return sig_addr

    def parseSeqFromLog(self, txn):
        return int.from_bytes(b64decode(txn.innerTxns[0]["logs"][0]), "big")

    def getCreator(self, client, sender, asset_id):
        return client.asset_info(asset_id)["params"]["creator"]

    def sendTxn(self, client, sender, txns, doWait):
        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            grp.append(t.sign(pk))

        client.send_transactions(grp)
        if doWait:
            return self.waitForTransaction(client, grp[-1].get_txid())
        else:
            return grp[-1].get_txid()

    def bootGuardians(self, vaa, client, sender, coreid):
        p = self.parseVAA(vaa)
        if "NewGuardianSetIndex" not in p:
            raise Exception("invalid guardian VAA")

        seq_addr = self.optin(client, sender, coreid, int(p["sequence"] / max_bits), p["chainRaw"].hex() + p["emitter"].hex())
        guardian_addr = self.optin(client, sender, coreid, p["index"], b"guardian".hex())
        newguardian_addr = self.optin(client, sender, coreid, p["NewGuardianSetIndex"], b"guardian".hex())

        # wormhole is not a cheap protocol... we need to buy ourselves
        # some extra CPU cycles by having an early txn do nothing.
        # This leaves cycles over for later txn's in the same group

        sp = client.suggested_params()

        txns = [
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=coreid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop", b"0"],
                sp=sp
            ),

            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=coreid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop", b"1"],
                sp=sp
            ),

            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=coreid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"init", vaa, decode_address(self.vaa_verify["hash"])],
                accounts=[seq_addr, guardian_addr, newguardian_addr],
                sp=sp
            ),

            transaction.PaymentTxn(
                sender=sender.getAddress(),
                receiver=self.vaa_verify["hash"],
                amt=100000,
                sp=sp
            )
        ]

        return self.sendTxn(client, sender, txns, True)

    def decodeLocalState(self, client, sender, appid, addr):
        app_state = None
        ai = client.account_info(addr)
        for app in ai["apps-local-state"]:
            if app["id"] == appid:
                app_state = app["key-value"]

        ret = b''
        if None != app_state:
            vals = {}
            e = bytes.fromhex("00"*127)
            for kv in app_state:
                k = base64.b64decode(kv["key"])
                if k == "meta":
                    continue
                key = int.from_bytes(k, "big")
                v = base64.b64decode(kv["value"]["bytes"])
                if v != e:
                    vals[key] = v
            for k in sorted(vals.keys()):
                ret = ret + vals[k]
        return ret

    # There is no client side duplicate suppression, error checking, or validity
    # checking. We need to be able to detect all failure cases in
    # the contract itself and we want to use this to drive the failure test
    # cases

    def simpleVAA(self, vaa, client, sender, appid):
        p = {"version": int.from_bytes(vaa[0:1], "big"), "index": int.from_bytes(vaa[1:5], "big"), "siglen": int.from_bytes(vaa[5:6], "big")}
        ret["signatures"] = vaa[6:(ret["siglen"] * 66) + 6]
        ret["sigs"] = []
        for i in range(ret["siglen"]):
            ret["sigs"].append(vaa[(6 + (i * 66)):(6 + (i * 66)) + 66].hex())
        off = (ret["siglen"] * 66) + 6
        ret["digest"] = vaa[off:]  # This is what is actually signed...
        ret["timestamp"] = int.from_bytes(vaa[off:(off + 4)], "big")
        off += 4
        ret["nonce"] = int.from_bytes(vaa[off:(off + 4)], "big")
        off += 4
        ret["chainRaw"] = vaa[off:(off + 2)]
        ret["chain"] = int.from_bytes(vaa[off:(off + 2)], "big")
        off += 2
        ret["emitter"] = vaa[off:(off + 32)]
        off += 32
        ret["sequence"] = int.from_bytes(vaa[off:(off + 8)], "big")
        off += 8
        ret["consistency"] = int.from_bytes(vaa[off:(off + 1)], "big")
        off += 1

        seq_addr = self.optin(client, sender, appid, int(p["sequence"] / max_bits), p["chainRaw"].hex() + p["emitter"].hex())
        # And then the signatures to help us verify the vaa_s
        guardian_addr = self.optin(client, sender, self.coreid, p["index"], b"guardian".hex())

        accts = [seq_addr, guardian_addr]

        keys = self.decodeLocalState(client, sender, self.coreid, guardian_addr)

        sp = client.suggested_params()

        txns = []

        # Right now there is not really a good way to estimate the fees,
        # in production, on a conjested network, how much verifying
        # the signatures is going to cost.

        # So, what we do instead
        # is we top off the verifier back up to 2A so effectively we
        # are paying for the previous persons overrage which on a
        # unconjested network should be zero

        pmt = 3000
        bal = self.getBalances(client, self.vaa_verify["hash"])
        if ((200000 - bal[0]) >= pmt):
            pmt = 200000 - bal[0]

        #print("Sending %d algo to cover fees" % (pmt))
        txns.append(
            transaction.PaymentTxn(
                sender = sender.getAddress(), 
                sp = sp, 
                receiver = self.vaa_verify["hash"], 
                amt = pmt
            )
        )

        # How many signatures can we process in a single txn... we can do 9!
        bsize = (9*66)
        blocks = int(len(p["signatures"]) / bsize) + 1

        # We don't pass the entire payload in but instead just pass it pre digested.  This gets around size
        # limitations with lsigs AND reduces the cost of the entire operation on a conjested network by reducing the
        # bytes passed into the transaction
        digest = keccak.new(digest_bits=256).update(keccak.new(digest_bits=256).update(p["digest"]).digest()).digest()

        for i in range(blocks):
            # Which signatures will we be verifying in this block
            sigs = p["signatures"][(i * bsize):]
            if (len(sigs) > bsize):
                sigs = sigs[:bsize]
            # keys
            kset = b''
            # Grab the key associated the signature
            for q in range(int(len(sigs) / 66)):
                # Which guardian is this signature associated with
                g = sigs[q * 66]
                key = keys[((g * 20) + 1) : (((g + 1) * 20) + 1)]
                kset = kset + key

            txns.append(transaction.ApplicationCallTxn(
                    sender=self.vaa_verify["hash"],
                    index=self.coreid,
                    on_complete=transaction.OnComplete.NoOpOC,
                    app_args=[b"verifySigs", sigs, kset, digest],
                    accounts=accts,
                    sp=sp
                ))

        txns.append(transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.coreid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"verifyVAA", vaa],
            accounts=accts,
            sp=sp
        ))

        return txns

    def signVAA(self, client, sender, txns):
        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            if ("app_args" in t.__dict__ and len(t.app_args) > 0 and t.app_args[0] == b"verifySigs"):
                grp.append(transaction.LogicSigTransaction(t, self.vaa_verify["lsig"]))
            else:
                grp.append(t.sign(pk))

        client.send_transactions(grp)
        ret = []
        for x in grp:
            response = self.waitForTransaction(client, x.get_txid())
            if "logs" in response.__dict__ and len(response.__dict__["logs"]) > 0:
                ret.append(response.__dict__["logs"])
        return ret

    def check_bits_set(self, client, app_id, addr, seq):
        bits_set = {}

        app_state = None
        ai = client.account_info(addr)
        for app in ai["apps-local-state"]:
            if app["id"] == app_id:
                app_state = app["key-value"]
        if app_state == None:
            return False

        start = int(seq / max_bits) * max_bits
        s = int((seq - start) / bits_per_key)
        b = int(((seq - start) - (s * bits_per_key)) / 8)

        k = base64.b64encode(s.to_bytes(1, "big")).decode('utf-8')
        for kv in app_state:
            if kv["key"] != k:
                continue
            v = base64.b64decode(kv["value"]["bytes"])
            bt = 1 << (seq%8)
            return ((v[b] & bt) != 0)

        return False

    def submitVAA(self, vaa, client, sender, appid):
        # A lot of our logic here depends on parseVAA and knowing what the payload is..
        p = self.parseVAA(vaa)

        #pprint.pprint(p)

        seq_addr = self.optin(client, sender, appid, int(p["sequence"] / max_bits), p["chainRaw"].hex() + p["emitter"].hex())

        assert self.check_bits_set(client, appid, seq_addr, p["sequence"]) == False
        # And then the signatures to help us verify the vaa_s
        guardian_addr = self.optin(client, sender, self.coreid, p["index"], b"guardian".hex())

        accts = [seq_addr, guardian_addr]

        # If this happens to be setting up a new guardian set, we probably need it as well...
        if p["Meta"] == "CoreGovernance" and p["action"] == 2:
            newguardian_addr = self.optin(client, sender, self.coreid, p["NewGuardianSetIndex"], b"guardian".hex())
            accts.append(newguardian_addr)

        # When we attest for a new token, we need some place to store the info... later we will need to 
        # mirror the other way as well
        if p["Meta"] == "TokenBridge Attest" or p["Meta"] == "TokenBridge Transfer" or p["Meta"] == "TokenBridge Transfer With Payload":
            if p["FromChain"] != 8:
                chain_addr = self.optin(client, sender, self.tokenid, p["FromChain"], p["Contract"])
            else:
                asset_id = int.from_bytes(bytes.fromhex(p["Contract"]), "big")
                chain_addr = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())
            accts.append(chain_addr)

        keys = self.decodeLocalState(client, sender, self.coreid, guardian_addr)
        print("keys: " + keys.hex())

        sp = client.suggested_params()

        txns = []

        # How many signatures can we process in a single txn... we can do 9!
        bsize = (9*66)
        blocks = int(len(p["signatures"]) / bsize) + 1

        # We don't pass the entire payload in but instead just pass it pre digested.  This gets around size
        # limitations with lsigs AND reduces the cost of the entire operation on a conjested network by reducing the
        # bytes passed into the transaction
        digest = keccak.new(digest_bits=256).update(keccak.new(digest_bits=256).update(p["digest"]).digest()).digest()

        for i in range(blocks):
            # Which signatures will we be verifying in this block
            sigs = p["signatures"][(i * bsize):]
            if (len(sigs) > bsize):
                sigs = sigs[:bsize]
            # keys
            kset = b''
            # Grab the key associated the signature
            for q in range(int(len(sigs) / 66)):
                # Which guardian is this signature associated with
                g = sigs[q * 66]
                key = keys[((g * 20) + 1) : (((g + 1) * 20) + 1)]
                kset = kset + key

            txns.append(transaction.ApplicationCallTxn(
                    sender=self.vaa_verify["hash"],
                    index=self.coreid,
                    on_complete=transaction.OnComplete.NoOpOC,
                    app_args=[b"verifySigs", sigs, kset, digest],
                    accounts=accts,
                    sp=sp
                ))
            txns[-1].fee = 0

        txns.append(transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.coreid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"verifyVAA", vaa],
            accounts=accts,
            sp=sp
        ))
        txns[-1].fee = txns[-1].fee * (1 + blocks)

        if p["Meta"] == "CoreGovernance":
            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.coreid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"governance", vaa],
                accounts=accts,
                sp=sp
            ))
            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.coreid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop", 5],
                sp=sp
            ))

        if p["Meta"] == "TokenBridge RegisterChain" or p["Meta"] == "TokenBridge UpgradeContract":
            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"governance", vaa],
                accounts=accts,
                foreign_apps = [self.coreid],
                sp=sp
            ))

        if p["Meta"] == "TokenBridge Attest":
            # if we DO decode it, we can do a sanity check... of
            # course, the hacker might NOT decode it so we have to
            # handle both cases...

            asset = (self.decodeLocalState(client, sender, self.tokenid, chain_addr))
            foreign_assets = []
            if (len(asset) > 8):
                foreign_assets.append(int.from_bytes(asset[0:8], "big"))

            txns.append(
                transaction.PaymentTxn(
                    sender = sender.getAddress(),
                    sp = sp, 
                    receiver = chain_addr,
                    amt = 100000
                )
            )

            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop", 1],
                sp=sp
            ))

            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop", 2],
                sp=sp
            ))

            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"receiveAttest", vaa],
                accounts=accts,
                foreign_assets = foreign_assets,
                sp=sp
            ))
            txns[-1].fee = txns[-1].fee * 2

        if p["Meta"] == "TokenBridge Transfer" or p["Meta"] == "TokenBridge Transfer With Payload":
            foreign_assets = []
            a = 0
            if p["FromChain"] != 8:
                asset = (self.decodeLocalState(client, sender, self.tokenid, chain_addr))
                if (len(asset) > 8):
                    a = int.from_bytes(asset[0:8], "big")
            else:
                a = int.from_bytes(bytes.fromhex(p["Contract"]), "big")

            # The receiver needs to be optin in to receive the coins... Yeah, the relayer pays for this

            aid = 0

            if p["ToChain"] == 8 and p["Type"] == 3:
                aid = int.from_bytes(bytes.fromhex(p["ToAddress"]), "big")
                addr = get_application_address(aid)
            else:
                addr = encode_address(bytes.fromhex(p["ToAddress"]))

            if a != 0:
                foreign_assets.append(a)
                self.asset_optin(client, sender, foreign_assets[0], addr)
                # And this is how the relayer gets paid...
                if p["Fee"] != self.zeroPadBytes:
                    self.asset_optin(client, sender, foreign_assets[0], sender.getAddress())

            accts.append(addr)

            txns.append(transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"completeTransfer", vaa],
                accounts=accts,
                foreign_assets = foreign_assets,
                sp=sp
            ))

            if aid != 0:
                txns[-1].foreign_apps = [aid]

            # We need to cover the inner transactions
            if p["Fee"] != self.zeroPadBytes:
                txns[-1].fee = txns[-1].fee * 3
            else:
                txns[-1].fee = txns[-1].fee * 2

            if p["Meta"] == "TokenBridge Transfer With Payload":
                m = abi.Method("portal_transfer", [abi.Argument("byte[]")], abi.Returns("byte[]"))
                txns.append(transaction.ApplicationCallTxn(
                    sender=sender.getAddress(),
                    index=int.from_bytes(bytes.fromhex(p["ToAddress"]), "big"),
                    on_complete=transaction.OnComplete.NoOpOC,
                    app_args=[m.get_selector(), m.args[0].type.encode(vaa)],
                    foreign_assets = foreign_assets,
                    sp=sp
                ))

        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            if ("app_args" in t.__dict__ and len(t.app_args) > 0 and t.app_args[0] == b"verifySigs"):
                grp.append(transaction.LogicSigTransaction(t, self.vaa_verify["lsig"]))
            else:
                grp.append(t.sign(pk))

        client.send_transactions(grp)
        ret = []
        for x in grp:
            response = self.waitForTransaction(client, x.get_txid())
            if "logs" in response.__dict__ and len(response.__dict__["logs"]) > 0:
                ret.append(response.__dict__["logs"])

        assert self.check_bits_set(client, appid, seq_addr, p["sequence"]) == True

        return ret

    def parseVAA(self, vaa):
#        print (vaa.hex())
        ret = {"version": int.from_bytes(vaa[0:1], "big"), "index": int.from_bytes(vaa[1:5], "big"), "siglen": int.from_bytes(vaa[5:6], "big")}
        ret["signatures"] = vaa[6:(ret["siglen"] * 66) + 6]
        ret["sigs"] = []
        for i in range(ret["siglen"]):
            ret["sigs"].append(vaa[(6 + (i * 66)):(6 + (i * 66)) + 66].hex())
        off = (ret["siglen"] * 66) + 6
        ret["digest"] = vaa[off:]  # This is what is actually signed...
        ret["timestamp"] = int.from_bytes(vaa[off:(off + 4)], "big")
        off += 4
        ret["nonce"] = int.from_bytes(vaa[off:(off + 4)], "big")
        off += 4
        ret["chainRaw"] = vaa[off:(off + 2)]
        ret["chain"] = int.from_bytes(vaa[off:(off + 2)], "big")
        off += 2
        ret["emitter"] = vaa[off:(off + 32)]
        off += 32
        ret["sequence"] = int.from_bytes(vaa[off:(off + 8)], "big")
        off += 8
        ret["consistency"] = int.from_bytes(vaa[off:(off + 1)], "big")
        off += 1

        ret["Meta"] = "Unknown"

        if vaa[off:(off + 32)].hex() == "000000000000000000000000000000000000000000546f6b656e427269646765":
            ret["Meta"] = "TokenBridge"
            ret["module"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["action"] = int.from_bytes(vaa[off:(off + 1)], "big")
            off += 1
            if ret["action"] == 1:
                ret["Meta"] = "TokenBridge RegisterChain"
                ret["targetChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
                off += 2
                ret["EmitterChainID"] = int.from_bytes(vaa[off:(off + 2)], "big")
                off += 2
                ret["targetEmitter"] = vaa[off:(off + 32)].hex()
                off += 32
            if ret["action"] == 2:
                ret["Meta"] = "TokenBridge UpgradeContract"
                ret["targetChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
                off += 2
                ret["newContract"] = vaa[off:(off + 32)].hex()
                off += 32
        pprint.pprint((vaa[off:(off + 32)].hex(), "00000000000000000000000000000000000000000000000000000000436f7265"))
        if vaa[off:(off + 32)].hex() == "00000000000000000000000000000000000000000000000000000000436f7265":
            ret["Meta"] = "CoreGovernance"
            ret["module"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["action"] = int.from_bytes(vaa[off:(off + 1)], "big")
            off += 1
            ret["targetChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            if ret["action"] == 2:
                ret["NewGuardianSetIndex"] = int.from_bytes(vaa[off:(off + 4)], "big")
            else:
                ret["Contract"] = vaa[off:(off + 32)].hex()

        if ((len(vaa[off:])) == 100) and int.from_bytes((vaa[off:off+1]), "big") == 2:
            ret["Meta"] = "TokenBridge Attest"
            ret["Type"] = int.from_bytes((vaa[off:off+1]), "big")
            off += 1
            ret["Contract"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["FromChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            ret["Decimals"] = int.from_bytes((vaa[off:off+1]), "big")
            off += 1
            ret["Symbol"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["Name"] = vaa[off:(off + 32)].hex()

        if ((len(vaa[off:])) == 133) and int.from_bytes((vaa[off:off+1]), "big") == 1:
            ret["Meta"] = "TokenBridge Transfer"
            ret["Type"] = int.from_bytes((vaa[off:off+1]), "big")
            off += 1
            ret["Amount"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["Contract"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["FromChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            ret["ToAddress"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["ToChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            ret["Fee"] = vaa[off:(off + 32)].hex()

        if int.from_bytes((vaa[off:off+1]), "big") == 3:
            ret["Meta"] = "TokenBridge Transfer With Payload"
            ret["Type"] = int.from_bytes((vaa[off:off+1]), "big")
            off += 1
            ret["Amount"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["Contract"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["FromChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            ret["ToAddress"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["ToChain"] = int.from_bytes(vaa[off:(off + 2)], "big")
            off += 2
            ret["Fee"] = self.zeroPadBytes;
            ret["FromAddress"] = vaa[off:(off + 32)].hex()
            off += 32
            ret["Payload"] = vaa[off:].hex()
        
        return ret

    def boot(self):
        print("")

        print("Creating the PortalCore app")
        self.coreid = self.createPortalCoreApp(client=self.client, sender=self.foundation)
        pprint.pprint({"wormhole core": str(self.coreid), "address": get_application_address(self.coreid), "emitterAddress": decode_address(get_application_address(self.coreid)).hex()})

        print("Create the token bridge")
        self.tokenid = self.createTokenBridgeApp(self.client, self.foundation)
        pprint.pprint({"token bridge": str(self.tokenid), "address": get_application_address(self.tokenid), "emitterAddress": decode_address(get_application_address(self.tokenid)).hex()})

        if self.devnet or self.args.testnet:

            if self.devnet:
                print("Create test app")
                self.testid = self.createTestApp(self.client, self.foundation)
                pprint.pprint({"testapp": str(self.testid)})

                suggestedParams = self.client.suggested_params()
                fundingAccount = self.getGenesisAccounts()[0]

                txns: List[transaction.Transaction] = []
                wallet = "castle sing ice patrol mixture artist violin someone what access slow wrestle clap hero sausage oyster boost tone receive rapid bike announce pepper absent involve"
                a = Account.FromMnemonic(wallet)
                txns.append(
                    transaction.PaymentTxn(
                        sender=fundingAccount.getAddress(),
                        receiver=a.getAddress(),
                        amt=self.FUNDING_AMOUNT,
                        sp=suggestedParams,
                    )
                )
                txns = transaction.assign_group_id(txns)
                signedTxns = [
                    txn.sign(fundingAccount.getPrivateKey()) for i, txn in enumerate(txns)
                ]
    
                self.client.send_transactions(signedTxns)
                print("Sent some ALGO to: " + wallet)

                print("Creating a Token...")
                txn = transaction.AssetConfigTxn(
                    sender=a.getAddress(),
                    sp=suggestedParams,
                    total=1000000,
                    default_frozen=False,
                    unit_name="NORIUM",
                    asset_name="ChuckNorium",
                    manager=a.getAddress(),
                    reserve=a.getAddress(),
                    freeze=a.getAddress(),
                    clawback=a.getAddress(),
                    strict_empty_address_check=False,
                    decimals=6)
                stxn = txn.sign(a.getPrivateKey())
                txid = self.client.send_transaction(stxn)
                print("NORIUM creation transaction ID: {}".format(txid))
                confirmed_txn = transaction.wait_for_confirmation(self.client, txid, 4)
                print("TXID: ", txid)
                print("Result confirmed in round: {}".format(confirmed_txn['confirmed-round']))

                print("Creating an NFT...")
                # JSON file
                dir_path = os.path.dirname(os.path.realpath(__file__))
                f = open (dir_path + 'cnNftMetadata.json', "r")
  
                # Reading from file
                metadataJSON = json.loads(f.read())
                metadataStr = json.dumps(metadataJSON)

                hash = hashlib.new("sha512_256")
                hash.update(b"arc0003/amj")
                hash.update(metadataStr.encode("utf-8"))
                json_metadata_hash = hash.digest()
                print("json_metadata_hash: ", hash.hexdigest())

				# Create transaction
                txn = transaction.AssetConfigTxn(
                    sender=a.getAddress(),
                    sp=suggestedParams,
                    total=1,
                    default_frozen=False,
                    unit_name="CNART",
                    asset_name="ChuckNoriumArtwork@arc3",
                    manager=a.getAddress(),
                    reserve=a.getAddress(),
                    freeze=a.getAddress(),
                    clawback=a.getAddress(),
                    strict_empty_address_check=False,
                    url="file://cnNftMetadata.json",
                    metadata_hash=json_metadata_hash,
                    decimals=0)
                stxn = txn.sign(a.getPrivateKey())
                txid = self.client.send_transaction(stxn)
                print("NORIUM NFT creation transaction ID: {}".format(txid))
                confirmed_txn = transaction.wait_for_confirmation(self.client, txid, 4)
                print("TXID: ", txid)
                print("Result confirmed in round: {}".format(confirmed_txn['confirmed-round']))

            if exists(self.args.env):
                if self.gt == None:
                    self.gt = GenTest(False)

                with open(self.args.env, encoding = 'utf-8') as f:
                    for line in f:
                        e = line.rstrip('\n').split("=")
                        print(e)
                        if "TOKEN_BRIDGE" in e[0]:
                            v = bytes.fromhex(e[1])
                            self.submitVAA(v, self.client, self.foundation, self.tokenid)
                        if "INIT_SIGNERS_CSV" in e[0]:
                            self.gt.guardianKeys = e[1].split(",")
                            print("guardianKeys: " + str(self.gt.guardianKeys))
                        if "INIT_SIGNERS_KEYS_CSV" in e[0]:
                            print("bootstrapping the guardian set...")
                            self.gt.guardianPrivKeys = e[1].split(",")
                            print("guardianPrivKeys: " + str(self.gt.guardianPrivKeys))

                            seq = int(random.random() * (2**31))
                            bootVAA = self.gt.genGuardianSetUpgrade(self.gt.guardianPrivKeys, self.args.guardianSet, self.args.guardianSet, seq, seq)
                            print("dev vaa: " + bootVAA)
                            self.bootGuardians(bytes.fromhex(bootVAA), self.client, self.foundation, self.coreid)
                seq = int(random.random() * (2**31))
                regChain = self.gt.genRegisterChain(self.gt.guardianPrivKeys, self.args.guardianSet, seq, seq, 8, decode_address(get_application_address(self.tokenid)).hex())
                print("ALGO_TOKEN_BRIDGE_VAA=" + regChain)
#                if self.args.env != ".env":
#                    v = bytes.fromhex(regChain)
#                    self.submitVAA(v, self.client, self.foundation, self.tokenid)
#                    print("We submitted it!")

    def updateCore(self) -> None:
        print("Updating the core contracts")
        if self.args.approve == "" and self.args.clear == "":
            approval, clear = getCoreContracts(False, self.args.core_approve, self.args.core_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)
            print("core approval " + decode_address(approval["hash"]).hex())
            print("core clear " + decode_address(clear["hash"]).hex())
        else:
            pprint.pprint([self.args.approve, self.args.clear])
            with open(self.args.approve, encoding = 'utf-8') as f:
                approval = {"result": f.readlines()[0]}
                pprint.pprint(approval)
            with open(self.args.clear, encoding = 'utf-8') as f:
                clear = {"result": f.readlines()[0]}
                pprint.pprint(clear)

        txn = transaction.ApplicationUpdateTxn(
            index=self.coreid,
            sender=self.foundation.getAddress(),
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            app_args=[ ],
            sp=self.client.suggested_params(),
        )
    
        signedTxn = txn.sign(self.foundation.getPrivateKey())
        print("sending transaction")
        self.client.send_transaction(signedTxn)
        resp = self.waitForTransaction(self.client, signedTxn.get_txid())
        pprint.pprint(resp)
        for x in resp.__dict__["logs"]:
            print(x.hex())
        print("complete")

    def updateToken(self) -> None:
        if self.args.approve == "" and self.args.clear == "":
            approval, clear = get_token_bridge(False, self.args.token_approve, self.args.token_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = self.devnet or self.args.testnet)
        else:
            pprint.pprint([self.args.approve, self.args.clear])
            with open(self.args.approve, encoding = 'utf-8') as f:
                approval = {"result": f.readlines()[0]}
                pprint.pprint(approval)
            with open(self.args.clear, encoding = 'utf-8') as f:
                clear = {"result": f.readlines()[0]}
                pprint.pprint(clear)

#        print("token " + decode_address(approval["hash"]).hex())

        print("Updating the token contracts: " + str(len(b64decode(approval["result"]))))

        state = self.read_global_state(self.client, self.foundation.addr, self.tokenid)
        pprint.pprint( { 
            "validUpdateApproveHash": b64decode(state["validUpdateApproveHash"]).hex(),
            "validUpdateClearHash": b64decode(state["validUpdateClearHash"]).hex()
        })

        txn = transaction.ApplicationUpdateTxn(
            index=self.tokenid,
            sender=self.foundation.getAddress(),
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            app_args=[ ],
            sp=self.client.suggested_params(),
        )
    
        signedTxn = txn.sign(self.foundation.getPrivateKey())
        print("sending transaction")
        self.client.send_transaction(signedTxn)
        resp = self.waitForTransaction(self.client, signedTxn.get_txid())
        for x in resp.__dict__["logs"]:
            print(x.hex())
        print("complete")

    def genTeal(self) -> None:
        print((True, self.args.core_approve, self.args.core_clear, self.client, self.seed_amt, self.tsig, self.devnet or self.args.testnet))
        devmode = (self.devnet or self.args.testnet) and not self.args.prodTeal
        approval1, clear1 = getCoreContracts(True, self.args.core_approve, self.args.core_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = devmode)
        print("Generating the teal for the core contracts")
        approval2, clear2 = get_token_bridge(True, self.args.token_approve, self.args.token_clear, self.client, seed_amt=self.seed_amt, tmpl_sig=self.tsig, devMode = devmode)
        print("Generating the teal for the token contracts: " + str(len(b64decode(approval2["result"]))))

        if self.devnet:
            v = self.genUpgradePayloadBody(approval1, approval2)
            if self.gt == None:
                self.gt = GenTest(False)
    
            emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")
    
            guardianSet = 0
    
            nonce = int(random.random() * 20000)
            coreVAA = self.gt.createSignedVAA(guardianSet, self.gt.guardianPrivKeys, int(time.time()), nonce, 1, emitter, int(random.random() * 20000), 32, 8, v[0])
            tokenVAA = self.gt.createSignedVAA(guardianSet, self.gt.guardianPrivKeys, int(time.time()), nonce, 1, emitter, int(random.random() * 20000), 32, 8, v[1])
    
            with open("teal/core_devnet.vaa", "w") as fout:
                fout.write(coreVAA)
    
            with open("teal/token_devnet.vaa", "w") as fout:
                fout.write(tokenVAA)

    def testnet(self):
        self.ALGOD_ADDRESS = self.args.algod_address = "https://testnet-api.algonode.cloud"
        self.INDEXER_ADDRESS = "https://testnet-idx.algonode.cloud"
        self.coreid = self.args.coreid
        self.tokenid = self.args.tokenid

    def mainnet(self):
        self.ALGOD_ADDRESS = self.args.algod_address = "https://mainnet-api.algonode.cloud"
        self.INDEXER_ADDRESS = "https://mainnet-idx.algonode.cloud"
        self.coreid = 842125965
        self.tokenid = 842126029
        if self.args.coreid != 4:
            self.coreid = self.args.coreid
        if self.args.tokenid != 6:
            self.tokenid = self.args.tokenid

    def setup_args(self) -> None:
        parser = argparse.ArgumentParser(description='algorand setup')
    
        parser.add_argument('--algod_address', type=str, help='algod address (default: http://localhost:4001)', 
                            default="http://localhost:4001")
        parser.add_argument('--algod_token', type=str, help='algod access token', 
                            default="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        parser.add_argument('--kmd_address', type=str, help='kmd wallet address (default: http://localhost:4002)',
                            default="http://localhost:4002")
        parser.add_argument('--kmd_token', type=str, help='kmd wallet access token', 
                            default="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        parser.add_argument('--kmd_name', type=str, help='kmd wallet name', 
                            default="unencrypted-default-wallet")
        parser.add_argument('--kmd_password', type=str, help='kmd wallet password', default="")

        parser.add_argument('--mnemonic', type=str, help='account mnemonic', default="")

        parser.add_argument('--core_approve', type=str, help='core approve teal', default="teal/core_approve.teal")
        parser.add_argument('--core_clear', type=str, help='core clear teal', default="teal/core_clear.teal")

        parser.add_argument('--token_approve', type=str, help='token approve teal', default="teal/token_approve.teal")
        parser.add_argument('--token_clear', type=str, help='token clear teal', default="teal/token_clear.teal")

        parser.add_argument('--coreid', type=int, help='core contract', default=4)
        parser.add_argument('--tokenid', type=int, help='token bridge contract', default=6)
        parser.add_argument('--devnet', action='store_true', help='setup devnet')
        parser.add_argument('--boot', action='store_true', help='bootstrap')
        parser.add_argument('--upgradePayload', action='store_true', help='gen the upgrade payload for the guardians to sign')
        parser.add_argument('--vaa', type=str, help='Submit the supplied VAA', default="")
        parser.add_argument('--env', type=str, help='deploying using the supplied .env file', default=".env")
        parser.add_argument('--guardianSet', type=int, help='What guardianSet should I syntheticly create if needed', default=0)
        parser.add_argument('--appid', type=str, help='The appid that the vaa submit is applied to', default="")
        parser.add_argument('--submit', action='store_true', help='submit the synthetic vaas')
        parser.add_argument('--updateCore', action='store_true', help='update the Core contracts')
        parser.add_argument('--updateToken', action='store_true', help='update the Token contracts')
        parser.add_argument('--upgradeVAA', action='store_true', help='generate a upgrade vaa for devnet')
        parser.add_argument('--print', action='store_true', help='print')
        parser.add_argument('--genParts', action='store_true', help='Get tssig parts')
        parser.add_argument('--prodTeal', action='store_true', help='use Production Deal')
        parser.add_argument('--genTeal', action='store_true', help='Generate all the teal from the pyteal')
        parser.add_argument('--fund', action='store_true', help='Generate some accounts and fund them')
        parser.add_argument('--testnet', action='store_true', help='Connect to testnet')
        parser.add_argument('--mainnet', action='store_true', help='Connect to mainnet')
        parser.add_argument('--bootGuardian', type=str, help='Submit the supplied VAA', default="")
        parser.add_argument('--rpc', type=str, help='RPC address', default="")
        parser.add_argument('--guardianKeys', type=str, help='GuardianKeys', default="")
        parser.add_argument('--guardianPrivKeys', type=str, help='guardianPrivKeys', default="")
        parser.add_argument('--approve', type=str, help='compiled approve contract', default="")
        parser.add_argument('--clear', type=str, help='compiled clear contract', default="")

        args = parser.parse_args()
        self.init(args)

        self.devnet = args.devnet

    def main(self) -> None:
        self.setup_args()

        args = self.args

        if args.testnet:
            self.testnet()

        if args.mainnet:
            self.mainnet()

        if args.rpc != "":
            self.ALGOD_ADDRESS = self.args.rpc
            
        self.client = self.getAlgodClient()

        if self.devnet or self.args.testnet:
            self.vaa_verify = self.client.compile(get_vaa_verify())
        else:
            c = AlgodClient("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "https://testnet-api.algonode.cloud")
            self.vaa_verify = c.compile(get_vaa_verify())

        self.vaa_verify["lsig"] = LogicSig(base64.b64decode(self.vaa_verify["result"]))

        if args.genTeal or args.boot:
            self.genTeal()

        # Generate the upgrade payload we need the guardians to sign
        if args.upgradePayload:
            print(self.genUpgradePayload())
            sys.exit(0)

        # This breaks the tsig up into the various parts so that we
        # can embed it into the Typescript code for reassembly  
        if args.genParts:
            print("this.ALGO_VERIFY_HASH = \"%s\""%self.vaa_verify["hash"]);
            print("this.ALGO_VERIFY = new Uint8Array([", end='')
            for x in b64decode(self.vaa_verify["result"]):
                print("%d, "%(x), end='')
            print("])")
    
            parts = [
                self.tsig.get_bytecode_raw(0).hex(),
                self.tsig.get_bytecode_raw(1).hex(),
                self.tsig.get_bytecode_raw(2).hex(),
                self.tsig.get_bytecode_raw(3).hex(),
                self.tsig.get_bytecode_raw(4).hex()
            ]

            pprint.pprint(parts)
            sys.exit(0)

        if args.mnemonic:
            self.foundation = Account.FromMnemonic(args.mnemonic)

        if args.devnet and self.foundation == None:
            print("Generating the foundation account...")
            self.foundation = self.getTemporaryAccount(self.client)
            print("Foundation account: " + self.foundation.getMnemonic())

        if self.args.fund:
            sys.exit(0)

        if self.foundation == None:
            print("We dont have a account?  Here is a random one I just made up...")
            pk = account.generate_account()[0]
            print(" pk:        " + pk)
            print(" address:   " + account.address_from_private_key(pk))
            print(" mnemonic:  " + mnemonic.from_private_key(pk))
            if args.testnet:
                print("go to https://bank.testnet.algorand.network/ to fill it up  (You will probably want to send at least 2 loads to the wallet)")
            sys.exit(0)

        bal = self.getBalances(self.client, self.foundation.addr)
        print("foundation address " + self.foundation.addr + "  (" + str(float(bal[0]) / 1000000.0) + " ALGO)")
        if bal[0] < 10000000:
            print("you need at least 10 ALGO to do darn near anything...")
            sys.exit(0)

        if args.guardianKeys != "":
            self.gt.guardianKeys = eval(args.guardianKeys)

        if args.guardianPrivKeys != "":
            self.gt.guardianPrivKeyss = eval(args.guardianPrivKeys)

        if args.upgradeVAA:
            ret = self.devnetUpgradeVAA()
            pprint.pprint(ret)
            if (args.submit) :
                print("submitting vaa to upgrade core: " + str(self.coreid))
                state = self.read_global_state(self.client, self.foundation.addr, self.coreid)
                pprint.pprint( { 
                    "validUpdateApproveHash": b64decode(state["validUpdateApproveHash"]).hex(),
                    "validUpdateClearHash": b64decode(state["validUpdateClearHash"]).hex()
                })
                self.submitVAA(bytes.fromhex(ret[0]), self.client, self.foundation, self.coreid)
                state = self.read_global_state(self.client, self.foundation.addr, self.coreid)
                pprint.pprint( { 
                    "validUpdateApproveHash": b64decode(state["validUpdateApproveHash"]).hex(),
                    "validUpdateClearHash": b64decode(state["validUpdateClearHash"]).hex()
                })

                print("submitting vaa to upgrade token: " + str(self.tokenid))
                state = self.read_global_state(self.client, self.foundation.addr, self.tokenid)
                pprint.pprint( { 
                    "validUpdateApproveHash": b64decode(state["validUpdateApproveHash"]).hex(),
                    "validUpdateClearHash": b64decode(state["validUpdateClearHash"]).hex()
                })
                self.submitVAA(bytes.fromhex(ret[1]), self.client, self.foundation, self.tokenid)
                state = self.read_global_state(self.client, self.foundation.addr, self.tokenid)
                pprint.pprint( { 
                    "validUpdateApproveHash": b64decode(state["validUpdateApproveHash"]).hex(),
                    "validUpdateClearHash": b64decode(state["validUpdateClearHash"]).hex()
                })

        if args.boot:
            self.boot()

        if args.updateCore:
            self.updateCore()

        if args.updateToken:
            self.updateToken()

        if args.vaa:
            if self.args.appid == "":
                raise Exception("You need to specifiy the appid when you are submitting vaas")
            vaa = bytes.fromhex(args.vaa)
            pprint.pprint(self.parseVAA(vaa))
            self.submitVAA(vaa, self.client, self.foundation, int(self.args.appid))

        if args.bootGuardian != "":
            vaa = bytes.fromhex(args.bootGuardian)
            pprint.pprint(self.parseVAA(vaa))
            response = self.bootGuardians(vaa, self.client, self.foundation, self.coreid)
            pprint.pprint(response.__dict__)

if __name__ == "__main__":
    core = PortalCore()
    core.main()

'''
'''--- lib/wormhole/algorand/gentest.py ---
from eth_abi import encode_single, encode_abi
import sys
import pprint
import time
from Cryptodome.Hash import keccak
import coincurve
import base64
from random import random
from algosdk.encoding import decode_address

class GenTest:
    def __init__(self, bigSet) -> None:
        if bigSet:
            self.guardianKeys = [
                "52A26Ce40F8CAa8D36155d37ef0D5D783fc614d2",
                "389A74E8FFa224aeAD0778c786163a7A2150768C",
                "B4459EA6482D4aE574305B239B4f2264239e7599",
                "072491bd66F63356090C11Aae8114F5372aBf12B",
                "51280eA1fd2B0A1c76Ae29a7d54dda68860A2bfF",
                "fa9Aa60CfF05e20E2CcAA784eE89A0A16C2057CB",
                "e42d59F8FCd86a1c5c4bA351bD251A5c5B05DF6A",
                "4B07fF9D5cE1A6ed58b6e9e7d6974d1baBEc087e",
                "c8306B84235D7b0478c61783C50F990bfC44cFc0",
                "C8C1035110a13fe788259A4148F871b52bAbcb1B",
                "58A2508A20A7198E131503ce26bBE119aA8c62b2",
                "8390820f04ddA22AFe03be1c3bb10f4ba6CF94A0",
                "1FD6e97387C34a1F36DE0f8341E9D409E06ec45b",
                "255a41fC2792209CB998A8287204D40996df9E54",
                "bA663B12DD23fbF4FbAC618Be140727986B3BBd0",
                "79040E577aC50486d0F6930e160A5C75FD1203C6",
                "3580D2F00309A9A85efFAf02564Fc183C0183A96",
                "3869795913D3B6dBF3B24a1C7654672c69A23c35",
                "1c0Cc52D7673c52DE99785741344662F5b2308a0",
            ]

            self.guardianPrivKeys = [
                "563d8d2fd4e701901d3846dee7ae7a92c18f1975195264d676f8407ac5976757",
                "8d97f25916a755df1d9ef74eb4dbebc5f868cb07830527731e94478cdc2b9d5f",
                "9bd728ad7617c05c31382053b57658d4a8125684c0098f740a054d87ddc0e93b",
                "5a02c4cd110d20a83a7ce8d1a2b2ae5df252b4e5f6781c7855db5cc28ed2d1b4",
                "93d4e3b443bf11f99a00901222c032bd5f63cf73fc1bcfa40829824d121be9b2",
                "ea40e40c63c6ff155230da64a2c44fcd1f1c9e50cacb752c230f77771ce1d856",
                "87eaabe9c27a82198e618bca20f48f9679c0f239948dbd094005e262da33fe6a",
                "61ffed2bff38648a6d36d6ed560b741b1ca53d45391441124f27e1e48ca04770",
                "bd12a242c6da318fef8f98002efb98efbf434218a78730a197d981bebaee826e",
                "20d3597bb16525b6d09e5fb56feb91b053d961ab156f4807e37d980f50e71aff",
                "344b313ffbc0199ff6ca08cacdaf5dc1d85221e2f2dc156a84245bd49b981673",
                "848b93264edd3f1a521274ca4da4632989eb5303fd15b14e5ec6bcaa91172b05",
                "c6f2046c1e6c172497fc23bd362104e2f4460d0f61984938fa16ef43f27d93f6",
                "693b256b1ee6b6fb353ba23274280e7166ab3be8c23c203cc76d716ba4bc32bf",
                "13c41508c0da03018d61427910b9922345ced25e2bbce50652e939ee6e5ea56d",
                "460ee0ee403be7a4f1eb1c63dd1edaa815fbaa6cf0cf2344dcba4a8acf9aca74",
                "b25148579b99b18c8994b0b86e4dd586975a78fa6e7ad6ec89478d7fbafd2683",
                "90d7ac6a82166c908b8cf1b352f3c9340a8d1f2907d7146fb7cd6354a5436cca",
                "b71d23908e4cf5d6cd973394f3a4b6b164eb1065785feee612efdfd8d30005ed",
            ]

        else:
            self.guardianKeys = [
                "beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe"
            ]
    
            self.guardianPrivKeys = [
                "cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0"
            ]

        self.zeroPadBytes = "00"*64

    def encoder(self, type, val):
        if type == 'uint8':
            return encode_single(type, val).hex()[62:64]
        if type == 'uint16':
            return encode_single(type, val).hex()[60:64]
        if type == 'uint32':
            return encode_single(type, val).hex()[56:64]
        if type == 'uint64':
            return encode_single(type, val).hex()[64-(16):64]
        if type == 'uint128':
            return encode_single(type, val).hex()[64-(32):64]
        if type == 'uint256' or type == 'bytes32':
            return encode_single(type, val).hex()[64-(64):64]
        raise Exception("invalid type")

    def createSignedVAA(self, guardianSetIndex, signers, ts, nonce, emitterChainId, emitterAddress, sequence, consistencyLevel, target, payload):
        print("createSignedVAA: " + str(signers))
        b = ""

        b += self.encoder("uint32", ts)
        b += self.encoder("uint32", nonce)
        b += self.encoder("uint16", emitterChainId)
        b += self.encoder("bytes32", emitterAddress)
        b += self.encoder("uint64", sequence)
        b += self.encoder("uint8", consistencyLevel)
        b += payload

        hash = keccak.new(digest_bits=256).update(keccak.new(digest_bits=256).update(bytes.fromhex(b)).digest()).digest()

        signatures = ""

        for  i in range(len(signers)):
            signatures += self.encoder("uint8", i)

            key = coincurve.PrivateKey(bytes.fromhex(signers[i]))
            signature = key.sign_recoverable(hash, hasher=None)
            signatures += signature.hex()

        ret  = self.encoder("uint8", 1)
        ret += self.encoder("uint32", guardianSetIndex)
        ret += self.encoder("uint8", len(signers))
        ret += signatures
        ret += b

        return ret

    def genGuardianSetUpgrade(self, signers, guardianSet, targetSet, nonce, seq):
        b  = self.zeroPadBytes[0:(28*2)]
        b += self.encoder("uint8", ord("C"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", 2)
        b += self.encoder("uint16", 0)
        b += self.encoder("uint32", targetSet)
        b += self.encoder("uint8", len(self.guardianKeys))

        for i in self.guardianKeys:
            b += i

        emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def genGSetFee(self, signers, guardianSet, nonce, seq, amt):
        b  = self.zeroPadBytes[0:(28*2)]
        b += self.encoder("uint8", ord("C"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", 3)
        b += self.encoder("uint16", 8)
        b += self.encoder("uint256", int(amt))  # a whole algo!

        emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def genGFeePayout(self, signers, guardianSet, targetSet, nonce, seq, amt, dest):
        b  = self.zeroPadBytes[0:(28*2)]
        b += self.encoder("uint8", ord("C"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", 4)
        b += self.encoder("uint16", 8)
        b += self.encoder("uint256", int(amt * 1000000))
        b += decode_address(dest).hex()

        emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def getEmitter(self, chain):
        if chain == 1:
            return "ec7372995d5cc8732397fb0ad35c0121e0eaa90d26f828a534cab54391b3a4f5"
        if chain == 2:
            return "0000000000000000000000003ee18b2214aff97000d974cf647e7c347e8fa585"
        if chain == 3:
            return "0000000000000000000000007cf7b764e38a0a5e967972c1df77d432510564e2"
        if chain == 4:
            return "000000000000000000000000b6f6d86a8f9879a9c87f643768d9efc38c1da6e7"
        if chain == 5:
            return "0000000000000000000000005a58505a96d1dbf8df91cb21b54419fc36e93fde"
        raise Exception("invalid chain")
        
    def genRegisterChain(self, signers, guardianSet, nonce, seq, chain, addr = None):
        b  = self.zeroPadBytes[0:((32 -11)*2)]
        b += self.encoder("uint8", ord("T"))
        b += self.encoder("uint8", ord("o"))
        b += self.encoder("uint8", ord("k"))
        b += self.encoder("uint8", ord("e"))
        b += self.encoder("uint8", ord("n"))
        b += self.encoder("uint8", ord("B"))
        b += self.encoder("uint8", ord("r"))
        b += self.encoder("uint8", ord("i"))
        b += self.encoder("uint8", ord("d"))
        b += self.encoder("uint8", ord("g"))
        b += self.encoder("uint8", ord("e"))

        b += self.encoder("uint8", 1)  # action
        b += self.encoder("uint16", 0) # target chain
        b += self.encoder("uint16", chain)
        if addr == None:
            b += self.getEmitter(chain)
        else:
            b += addr
        emitter = bytes.fromhex(self.zeroPadBytes[0:(31*2)] + "04")
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def genAssetMeta(self, signers, guardianSet, nonce, seq, tokenAddress, chain, decimals, symbol, name):
        b  = self.encoder("uint8", 2)
        b += self.zeroPadBytes[0:((32-len(tokenAddress))*2)]
        b += tokenAddress.hex()
        b += self.encoder("uint16", chain)
        b += self.encoder("uint8", decimals)
        b += symbol.hex()
        b += self.zeroPadBytes[0:((32-len(symbol))*2)]
        b += name.hex()
        b += self.zeroPadBytes[0:((32-len(name))*2)]
        emitter = bytes.fromhex(self.getEmitter(chain))
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def genTransfer(self, signers, guardianSet, nonce, seq, amount, tokenAddress, tokenChain, toAddress, toChain, fee):
        b  = self.encoder("uint8", 1)
        b += self.encoder("uint256", int(amount * 100000000))

        b += self.zeroPadBytes[0:((32-len(tokenAddress))*2)]
        b += tokenAddress.hex()

        b += self.encoder("uint16", tokenChain)

        b += self.zeroPadBytes[0:((32-len(toAddress))*2)]
        b += toAddress.hex()

        b += self.encoder("uint16", toChain)

        b += self.encoder("uint256", int(fee * 100000000))

        emitter = bytes.fromhex(self.getEmitter(tokenChain))
        return self.createSignedVAA(guardianSet, signers, int(time.time()), nonce, 1, emitter, seq, 32, 0, b)

    def genVaa(self, emitter, seq, payload):
        nonce = int(random() * 4000000.0)
        return self.createSignedVAA(1, self.guardianPrivKeys, int(time.time()), nonce, 8, emitter, seq, 32, 0, payload.hex())

    def test(self):
        print(self.genTransfer(self.guardianPrivKeys, 1, 1, 1, 1, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, decode_address("ROOKEPZMHHBAEH75Y44OCNXQAGTXZWG3PY7IYQQCMXO7IG7DJMVHU32YVI"), 8, 0))
        
if __name__ == '__main__':    
    core = GenTest(True)
    core.test()

'''
'''--- lib/wormhole/algorand/globals.py ---
#!/usr/bin/python3

# The maximum number of signatures verified by each transaction in the group.
# the total count of required transactions to verify all guardian signatures is
#
# floor(guardian_count  / SIGNATURES_PER_TRANSACTION)
#
from pyteal.types import *
from pyteal.ast import *
MAX_SIGNATURES_PER_VERIFICATION_STEP = 8

"""
Math ceil function.
"""

@Subroutine(TealType.uint64)
def ceil(n, d):
    q = n / d
    r = n % d
    return Seq([
        If(r != Int(0)).Then(Return(q + Int(1))).Else(Return(q))
    ])

"""
Return the minimum Uint64 of A,B
"""

@Subroutine(TealType.uint64)
def min(a, b):
    If(Int(a) < Int(b), Return(a), Return(b))

"""
Let G be the guardian count, N number of signatures per verification step, group must have CEIL(G/N) transactions.
"""

@Subroutine(TealType.uint64)
def get_group_size(num_guardians):
    return ceil(num_guardians, Int(MAX_SIGNATURES_PER_VERIFICATION_STEP))

"""
Get the number of signatures to verify in current step
"""

@Subroutine(TealType.uint64)
def get_sig_count_in_step(step, num_guardians):
    r = num_guardians % Int(MAX_SIGNATURES_PER_VERIFICATION_STEP)
    return Seq(
        If(r == Int(0)).Then(Return(Int(MAX_SIGNATURES_PER_VERIFICATION_STEP)))
        .ElseIf(step < get_group_size(num_guardians) - Int(1))
        .Then(
            Return(Int(MAX_SIGNATURES_PER_VERIFICATION_STEP)))
        .Else(
            Return(num_guardians % Int(MAX_SIGNATURES_PER_VERIFICATION_STEP))))

'''
'''--- lib/wormhole/algorand/inlineasm.py ---
#!/usr/bin/python3
from pyteal import *

class CustomOp():
    def __init__(self, opcode):
        self.opcode = opcode
        self.mode = Mode.Signature | Mode.Application
        self.min_version = 2

    def __str__(self) -> str:
        return self.opcode

class InlineAssembly(LeafExpr):
    def __init__(self, opcode: str, *args: "Expr", type: TealType = TealType.none) -> None:
        super().__init__()
        opcode_with_args = opcode.split(" ")
        self.op = CustomOp(opcode_with_args[0])
        self.type = type
        self.opcode_args = opcode_with_args[1:]
        self.args = args

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, self.op, *self.opcode_args)
        return TealBlock.FromOp(options, op, *self.args[::1])

    def __str__(self):
        return "(InlineAssembly: {})".format(self.opcode)

    def type_of(self):
        return self.type

'''
'''--- lib/wormhole/algorand/local_blob.py ---
from typing import Tuple

from pyteal import (
    And,
    App,
    Assert,
    Bytes,
    BytesZero,
    Concat,
    Expr,
    Extract,
    For,
    GetByte,
    If,
    Int,
    Itob,
    Len,
    Or,
    ScratchVar,
    Seq,
    SetByte,
    Subroutine,
    Substring,
    TealType,
)

_max_keys = 15
_page_size = 128 - 1  # need 1 byte for key
_max_bytes = _max_keys * _page_size
_max_bits = _max_bytes * 8

max_keys = Int(_max_keys)
page_size = Int(_page_size)
max_bytes = Int(_max_bytes)

def _key_and_offset(idx: Int) -> Tuple[Int, Int]:
    return idx / page_size, idx % page_size

@Subroutine(TealType.bytes)
def intkey(i: Expr) -> Expr:
    return Extract(Itob(i), Int(7), Int(1))

# TODO: Add Keyspace range?
class LocalBlob:
    """
    Blob is a class holding static methods to work with the local storage of an account as a binary large object

    The `zero` method must be called on an account on opt in and the schema of the local storage should be 16 bytes
    """

    @staticmethod
    @Subroutine(TealType.none)
    def zero(acct: Expr) -> Expr:
        """
        initializes local state of an account to all zero bytes

        This allows us to be lazy later and _assume_ all the strings are the same size

        """
        i = ScratchVar()
        init = i.store(Int(0))
        cond = i.load() < max_keys
        iter = i.store(i.load() + Int(1))
        return For(init, cond, iter).Do(
            App.localPut(acct, intkey(i.load()), BytesZero(page_size))
        )

    @staticmethod
    @Subroutine(TealType.uint64)
    def get_byte(acct: Expr, idx: Expr):
        """
        Get a single byte from local storage of an account by index
        """
        key, offset = _key_and_offset(idx)
        return GetByte(App.localGet(acct, intkey(key)), offset)

    @staticmethod
    @Subroutine(TealType.none)
    def set_byte(acct: Expr, idx: Expr, byte: Expr):
        """
        Set a single byte from local storage of an account by index
        """
        key, offset = _key_and_offset(idx)
        return App.localPut(
            acct, intkey(key), SetByte(App.localGet(acct, intkey(key)), offset, byte)
        )

    @staticmethod
    @Subroutine(TealType.bytes)
    def read(
        acct: Expr, bstart: Expr, bend: Expr
    ) -> Expr:
        """
        read bytes between bstart and bend from local storage of an account by index
        """

        start_key, start_offset = _key_and_offset(bstart)
        stop_key, stop_offset = _key_and_offset(bend)

        key = ScratchVar()
        buff = ScratchVar()

        start = ScratchVar()
        stop = ScratchVar()

        init = key.store(start_key)
        cond = key.load() <= stop_key
        incr = key.store(key.load() + Int(1))

        return Seq(
            buff.store(Bytes("")),
            For(init, cond, incr).Do(
                Seq(
                    start.store(If(key.load() == start_key, start_offset, Int(0))),
                    stop.store(If(key.load() == stop_key, stop_offset, page_size)),
                    buff.store(
                        Concat(
                            buff.load(),
                            Substring(
                                App.localGet(acct, intkey(key.load())),
                                start.load(),
                                stop.load(),
                            ),
                        )
                    ),
                )
            ),
            buff.load(),
        )

    @staticmethod
    @Subroutine(TealType.none)
    def meta(
        acct: Expr, val: Expr
    ):
        return Seq(
            App.localPut(acct, Bytes("meta"), val)
        )

    @staticmethod
    @Subroutine(TealType.none)
    def checkMeta(acct: Expr, val: Expr):
        return Seq(Assert(And(App.localGet(acct, Bytes("meta")) == val, Int(145))))

    @staticmethod
    @Subroutine(TealType.uint64)
    def write(
        acct: Expr, bstart: Expr, buff: Expr
    ) -> Expr:
        """
        write bytes between bstart and len(buff) to local storage of an account
        """

        start_key, start_offset = _key_and_offset(bstart)
        stop_key, stop_offset = _key_and_offset(bstart + Len(buff))

        key = ScratchVar()
        start = ScratchVar()
        stop = ScratchVar()
        written = ScratchVar()

        init = key.store(start_key)
        cond = key.load() <= stop_key
        incr = key.store(key.load() + Int(1))

        delta = ScratchVar()

        return Seq(
            written.store(Int(0)),
            For(init, cond, incr).Do(
                Seq(
                    start.store(If(key.load() == start_key, start_offset, Int(0))),
                    stop.store(If(key.load() == stop_key, stop_offset, page_size)),
                    App.localPut(
                        acct,
                        intkey(key.load()),
                        If(
                            Or(stop.load() != page_size, start.load() != Int(0))
                        )  # Its a partial write
                        .Then(
                            Seq(
                                delta.store(stop.load() - start.load()),
                                Concat(
                                    Substring(
                                        App.localGet(acct, intkey(key.load())),
                                        Int(0),
                                        start.load(),
                                    ),
                                    Extract(buff, written.load(), delta.load()),
                                    Substring(
                                        App.localGet(acct, intkey(key.load())),
                                        stop.load(),
                                        page_size,
                                    ),
                                ),
                            )
                        )
                        .Else(
                            Seq(
                                delta.store(page_size),
                                Extract(buff, written.load(), page_size),
                            )
                        ),
                    ),
                    written.store(written.load() + delta.load()),
                )
            ),
            written.load(),
        )

'''
'''--- lib/wormhole/algorand/requirements.txt ---
attrs==21.4.0
cffi==1.15.0
colorama==0.4.4
execnet==1.9.0
future-fstrings==1.2.0
iniconfig==1.1.1
msgpack==1.0.3
packaging==21.3
pluggy==1.0.0
py==1.11.0
pycparser==2.21
pycryptodomex==3.12.0
pydantic==1.9.0
PyNaCl==1.5.0
pyparsing==3.0.6
pyteal==v0.11.1
#pyteal==v0.10.0
py-algorand-sdk==1.10.0b1
pytest==6.2.5
pytest-depends==1.0.1
pytest-forked==1.4.0
pytest-xdist==2.5.0
PyYAML==6.0
toml==0.10.2
typing-extensions==4.0.1
uvarint==1.2.0
eth_abi==2.1.1
coincurve==16.0.0

'''
'''--- lib/wormhole/algorand/sandbox-algorand/images/algod/setup.py ---
#!/usr/bin/env python3

# Script to help configure and run different algorand configurations.
# Notably this script can configure an algorand installation to run as a
# private network, or as a node connected to a long-running network.
#
# For parameter information run with './setup.py -h'
#
# Parameter error handling is not great with this script. It wont complain
# if you provide arguments unused parameters.

import argparse
import os
import pprint
import shutil
import subprocess
import tarfile
import time
import json
import urllib.request
from os.path import expanduser, join

from typing import List

parser = argparse.ArgumentParser(description='''\
        Configure private network for SDK and prepare it to run. A start script and
        symlink to data directory will be generated to make it easier to use.''')
parser.add_argument('--bin-dir', required=True, help='Location to install algod binaries.')
parser.add_argument('--data-dir', required=True, help='Location to place a symlink to the data directory.')
parser.add_argument('--start-script', required=True, help='Path to start script, including the script name.')
parser.add_argument('--network-template', required=True, help='Path to private network template file.')
parser.add_argument('--network-token', required=True, help='Valid token to use for algod/kmd.')
parser.add_argument('--algod-port', required=True, help='Port to use for algod.')
parser.add_argument('--kmd-port', required=True, help='Port to use for kmd.')
parser.add_argument('--network-dir', required=True, help='Path to create network.')
parser.add_argument('--bootstrap-url', required=True, help='DNS Bootstrap URL, empty for private networks.')
parser.add_argument('--genesis-file', required=True, help='Genesis file used by the network.')

pp = pprint.PrettyPrinter(indent=4)

def algod_directories(network_dir):
    """
    Compute data/kmd directories.
    """
    data_dir=join(network_dir, 'Node')

    kmd_dir = None
    options = [filename for filename in os.listdir(data_dir) if filename.startswith('kmd')]

    # When setting up the real network the kmd dir doesn't exist yet because algod hasn't been started.
    if len(options) == 0:
        kmd_dir=join(data_dir, 'kmd-v0.5')
        os.mkdir(kmd_dir)
    else:
        kmd_dir=join(data_dir, options[0])

    return data_dir, kmd_dir

def create_real_network(bin_dir, network_dir, template, genesis_file) -> List[str]:
    data_dir_src=join(bin_dir, 'data')
    target=join(network_dir, 'Node')

    # Reset in case it exists
    if os.path.exists(target):
        shutil.rmtree(target)
    os.makedirs(target, exist_ok=True)

    # Copy in the genesis file...
    shutil.copy(genesis_file, target)

    data_dir, kmd_dir = algod_directories(network_dir)

    return ['%s/goal node start -d %s' % (bin_dir, data_dir),
            '%s/kmd start -t 0 -d %s' % (bin_dir, kmd_dir)]

def create_private_network(bin_dir, network_dir, template) -> List[str]:
    """
    Create a private network.
    """
    # Reset network dir before creating a new one.
    if os.path.exists(args.network_dir):
        shutil.rmtree(args.network_dir)

    # Use goal to create the private network.
    subprocess.check_call(['%s/goal network create -n sandnet -r %s -t %s' % (bin_dir, network_dir, template)], shell=True)

    data_dir, kmd_dir = algod_directories(network_dir)
    return ['%s/goal network start -r %s' % (bin_dir, network_dir),
            '%s/kmd start -t 0 -d %s' % (bin_dir, kmd_dir)]

def configure_data_dir(network_dir, token, algod_port, kmd_port, bootstrap_url):
    node_dir, kmd_dir = algod_directories(network_dir)

    # Set tokens
    with open(join(node_dir, 'algod.token'), 'w') as f:
        f.write(token)
    with open(join(kmd_dir, 'kmd.token'), 'w') as f:
        f.write(token)

    # Setup config, inject port
    with open(join(node_dir, 'config.json'), 'w') as f:
        f.write('{ "Version": 12, "GossipFanout": 1, "EndpointAddress": "0.0.0.0:%s", "DNSBootstrapID": "%s", "IncomingConnectionsLimit": 0, "Archival":false, "isIndexerActive":false, "EnableDeveloperAPI":true}' % (algod_port, bootstrap_url))
    with open(join(kmd_dir, 'kmd_config.json'), 'w') as f:
        f.write('{  "address":"0.0.0.0:%s",  "allowed_origins":["*"]}' % kmd_port)

if __name__ == '__main__':
    args = parser.parse_args()

    print('Configuring network with the following arguments:')
    pp.pprint(vars(args))

    # Setup network
    privateNetworkMode = args.genesis_file == None or args.genesis_file == '' or os.path.isdir(args.genesis_file)
    if privateNetworkMode:
        print('Creating a private network.')
        startCommands = create_private_network(args.bin_dir, args.network_dir, args.network_template)
    else:
        print('Setting up real retwork.')
        startCommands = create_real_network(args.bin_dir, args.network_dir, args.network_template, args.genesis_file)

    # Write start script
    print(f'Start commands for {args.start_script}:')
    pp.pprint(startCommands)
    with open(args.start_script, 'w') as f:
        f.write('#!/usr/bin/env bash\n')
        for line in startCommands:
            f.write(f'{line}\n')
        f.write('sleep infinity\n')
    os.chmod(args.start_script, 0o755)

    # Create symlink
    data_dir, _ = algod_directories(args.network_dir)
    print(f'Creating symlink {args.data_dir} -> {data_dir}')
    os.symlink(data_dir, args.data_dir)

    # Configure network
    configure_data_dir(args.network_dir, args.network_token, args.algod_port, args.kmd_port, args.bootstrap_url)

'''
'''--- lib/wormhole/algorand/test/attest.py ---
# python3 -m pip install pycryptodomex uvarint pyteal web3 coincurve

import sys
sys.path.append("..")

from admin import PortalCore, Account
from gentest import GenTest
from base64 import b64decode

from typing import List, Tuple, Dict, Any, Optional, Union
import base64
import random
import time
import hashlib
import uuid
import json

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic
from algosdk.encoding import decode_address, encode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address
from vaa_verify import get_vaa_verify

from algosdk.future.transaction import LogicSig

from test_contract import get_test_app

from algosdk.v2client import indexer

import pprint

class AlgoTest(PortalCore):
    def __init__(self) -> None:
        super().__init__()

    def getBalances(self, client: AlgodClient, account: str) -> Dict[int, int]:
        balances: Dict[int, int] = dict()
    
        accountInfo = client.account_info(account)
    
        # set key 0 to Algo balance
        balances[0] = accountInfo["amount"]
    
        assets: List[Dict[str, Any]] = accountInfo.get("assets", [])
        for assetHolding in assets:
            assetID = assetHolding["asset-id"]
            amount = assetHolding["amount"]
            balances[assetID] = amount
    
        return balances

    def createTestApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = get_test_app(client)

        globalSchema = transaction.StateSchema(num_uints=4, num_byte_slices=30)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        app_args = []

        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            app_args=app_args,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        assert response.applicationIndex is not None and response.applicationIndex > 0

        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), 
                                     receiver = get_application_address(response.applicationIndex), amt = 300000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def parseSeqFromLog(self, txn):
        try:
            return int.from_bytes(b64decode(txn.innerTxns[-1]["logs"][0]), "big")
        except Exception as err:
            pprint.pprint(txn.__dict__)
            raise

    def getVAA(self, client, sender, sid, app):
        if sid == None:
            raise Exception("getVAA called with a sid of None")

        saddr = get_application_address(app)

        # SOOO, we send a nop txn through to push the block forward
        # one

        # This is ONLY needed on a local net...  the indexer will sit
        # on the last block for 30 to 60 seconds... we don't want this
        # log in prod since it is wasteful of gas

        if (self.INDEXER_ROUND > 512 and not self.args.testnet):  # until they fix it
            print("indexer is broken in local net... stop/clean/restart the sandbox")
            sys.exit(0)

        txns = []

        txns.append(
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop"],
                sp=client.suggested_params(),
            )
        )
        self.sendTxn(client, sender, txns, False)

        if self.myindexer == None:
            print("indexer address: " + self.INDEXER_ADDRESS)
            self.myindexer = indexer.IndexerClient(indexer_token=self.INDEXER_TOKEN, indexer_address=self.INDEXER_ADDRESS)

        while True:
            nexttoken = ""
            while True:
                response = self.myindexer.search_transactions( min_round=self.INDEXER_ROUND, note_prefix=self.NOTE_PREFIX, next_page=nexttoken)
#                pprint.pprint(response)
                for x in response["transactions"]:
#                    pprint.pprint(x)
                    for y in x["inner-txns"]:
                        if "application-transaction" not in y:
                            continue
                        if y["application-transaction"]["application-id"] != self.coreid:
                            continue
                        if len(y["logs"]) == 0:
                            continue
                        args = y["application-transaction"]["application-args"]
                        if len(args) < 2:
                            continue
                        if base64.b64decode(args[0]) != b'publishMessage':
                            continue
                        seq = int.from_bytes(base64.b64decode(y["logs"][0]), "big")
                        if seq != sid:
                            continue
                        if y["sender"] != saddr:
                            continue;
                        emitter = decode_address(y["sender"])
                        payload = base64.b64decode(args[1])
#                        pprint.pprint([seq, y["sender"], payload.hex()])
#                        sys.exit(0)
                        return self.gt.genVaa(emitter, seq, payload)

                if 'next-token' in response:
                    nexttoken = response['next-token']
                else:
                    self.INDEXER_ROUND = response['current-round'] + 1
                    break
            time.sleep(1)
        
    def publishMessage(self, client, sender, vaa, appid):
        aa = decode_address(get_application_address(appid)).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        txns = []
        sp = client.suggested_params()

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=appid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"test1", vaa, self.coreid],
            foreign_apps = [self.coreid],
            accounts=[emitter_addr],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

        return self.parseSeqFromLog(resp)

    def createTestAsset(self, client, sender):
        txns = []

        a = transaction.PaymentTxn(
            sender = sender.getAddress(), 
            sp = client.suggested_params(), 
            receiver = get_application_address(self.testid), 
            amt = 300000
        )

        txns.append(a)

        sp = client.suggested_params()
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"setup"],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)
        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            grp.append(t.sign(pk))

        client.send_transactions(grp)
        resp = self.waitForTransaction(client, grp[-1].get_txid())
        
        aid = int.from_bytes(resp.__dict__["logs"][0], "big")

        print("Opting " + sender.getAddress() + " into " + str(aid))
        self.asset_optin(client, sender, aid, sender.getAddress())

        txns = []
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"mint"],
            foreign_assets = [aid],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

#        self.INDEXER_ROUND = resp.confirmedRound

        return aid

    def getCreator(self, client, sender, asset_id):
        return client.asset_info(asset_id)["params"]["creator"]

    def testAttest(self, client, sender, asset_id):
        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        creator = self.getCreator(client, sender, asset_id)
        c = client.account_info(creator)
        wormhole = c.get("auth-addr") == taddr

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())

        txns = []
        sp = client.suggested_params()

        txns.append(transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"nop"],
            sp=sp
        ))

        mfee = self.getMessageFee()
        if (mfee > 0):
            txns.append(transaction.PaymentTxn(sender = sender.getAddress(), sp = sp, receiver = get_application_address(self.tokenid), amt = mfee))

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"attestToken", asset_id],
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=[emitter_addr, creator, c["address"], get_application_address(self.coreid)],
            sp=sp
        )

        if (mfee > 0):
            a.fee = a.fee * 3
        else:
            a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        # Point us at the correct round
        self.INDEXER_ROUND = resp.confirmedRound

#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
#        pprint.pprint(resp.__dict__)
        return self.parseSeqFromLog(resp)

    def transferAsset(self, client, sender, asset_id, quantity, receiver, chain, fee, payload = None):
#        pprint.pprint(["transferAsset", asset_id, quantity, receiver, chain, fee])

        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        # asset_id 0 is ALGO

        if asset_id == 0:
            wormhole = False
        else:
            creator = self.getCreator(client, sender, asset_id)
            c = client.account_info(creator)
            wormhole = c.get("auth-addr") == taddr

        txns = []

        mfee = self.getMessageFee()
        if (mfee > 0):
            txns.append(transaction.PaymentTxn(sender = sender.getAddress(), sp = sp, receiver = get_application_address(self.tokenid), amt = mfee))

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())
            print("non wormhole account " + creator)

        sp = client.suggested_params()

        if (asset_id != 0) and (not self.asset_optin_check(client, sender, asset_id, creator)):
            print("Looks like we need to optin")

            txns.append(
                transaction.PaymentTxn(
                    sender=sender.getAddress(),
                    receiver=creator,
                    amt=100000,
                    sp=sp
                )
            )

            # The tokenid app needs to do the optin since it has signature authority
            a = transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"optin", asset_id],
                foreign_assets = [asset_id],
                accounts=[creator],
                sp=sp
            )

            a.fee = a.fee * 2
            txns.append(a)
            self.sendTxn(client, sender, txns, False)
            txns = []

        txns.insert(0, 
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop"],
                sp=client.suggested_params(),
            )
        )

        if asset_id == 0:
            print("asset_id == 0")
            txns.append(transaction.PaymentTxn(
                sender=sender.getAddress(),
                receiver=creator,
                amt=quantity,
                sp=sp,
            ))
            accounts=[emitter_addr, creator, creator]
        else:
            print("asset_id != 0")
            txns.append(
                transaction.AssetTransferTxn(
                    sender = sender.getAddress(), 
                    sp = sp, 
                    receiver = creator,
                    amt = quantity,
                    index = asset_id
                ))
            accounts=[emitter_addr, creator, c["address"]]

        args = [b"sendTransfer", asset_id, quantity, decode_address(receiver), chain, fee]
        if None != payload:
            args.append(payload)

        #pprint.pprint(args)

#        print(self.tokenid)
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=args,
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=accounts,
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

#        pprint.pprint([self.coreid, self.tokenid, resp.__dict__,
#                       int.from_bytes(resp.__dict__["logs"][1], "big"),
#                       int.from_bytes(resp.__dict__["logs"][2], "big"),
#                       int.from_bytes(resp.__dict__["logs"][3], "big"),
#                       int.from_bytes(resp.__dict__["logs"][4], "big"),
#                       int.from_bytes(resp.__dict__["logs"][5], "big")
#                       ])
#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
        return self.parseSeqFromLog(resp)

    def asset_optin_check(self, client, sender, asset, receiver):
        if receiver not in self.asset_cache:
            self.asset_cache[receiver] = {}

        if asset in self.asset_cache[receiver]:
            return True

        ai = client.account_info(receiver)
        if "assets" in ai:
            for x in ai["assets"]:
                if x["asset-id"] == asset:
                    self.asset_cache[receiver][asset] = True
                    return True

        return False

    def asset_optin(self, client, sender, asset, receiver):
        if self.asset_optin_check(client, sender, asset, receiver):
            return

        pprint.pprint(["asset_optin", asset, receiver])

        sp = client.suggested_params()
        optin_txn = transaction.AssetTransferTxn(
            sender = sender.getAddress(), 
            sp = sp, 
            receiver = receiver, 
            amt = 0, 
            index = asset
        )

        transaction.assign_group_id([optin_txn])
        signed_optin = optin_txn.sign(sender.getPrivateKey())
        client.send_transactions([signed_optin])
        resp = self.waitForTransaction(client, signed_optin.get_txid())
        assert self.asset_optin_check(client, sender, asset, receiver), "The optin failed"
        print("woah! optin succeeded")

    def simple_test(self):
#        q = bytes.fromhex(gt.genAssetMeta(gt.guardianPrivKeys, 1, 1, 1, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, 8, b"USDC", b"CircleCoin"))
#        pprint.pprint(self.parseVAA(q))
#        sys.exit(0)

#        vaa = self.parseVAA(bytes.fromhex("01000000010100e1232697de3681d67ca0c46fbbc9ea5d282c473daae8fda2b23145e7b7167f9a35888acf80ed9d091af3069108c25324a22d8665241db884dda53ca53a8212d100625436600000000100020000000000000000000000003ee18b2214aff97000d974cf647e7c347e8fa585000000000000000120010000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000004523c3F29447d1f32AEa95BEBD00383c4640F1b400020000000000000000000000000000000000000000000000000000aabbcc00080000000000000000000000000000000000000000000000000000000000000000"))
#        pprint.pprint(vaa)
#        sys.exit(0)

        gt = GenTest(True)
        self.gt = gt

        self.setup_args()

        if self.args.testnet:
            self.testnet()

        client = self.client = self.getAlgodClient()

        self.genTeal()

        self.vaa_verify = self.client.compile(get_vaa_verify())
        self.vaa_verify["lsig"] = LogicSig(base64.b64decode(self.vaa_verify["result"]))

        vaaLogs = []

        args = self.args

        if self.args.mnemonic:
            self.foundation = Account.FromMnemonic(self.args.mnemonic)

        if self.foundation == None:
            print("Generating the foundation account...")
            self.foundation = self.getTemporaryAccount(self.client)

        if self.foundation == None:
            print("We dont have a account?  ")
            sys.exit(0)

        foundation = self.foundation

        seq = int(time.time())

        self.coreid = 4
        self.tokenid = 6

        player = self.getTemporaryAccount(client)
        print("token bridge " + str(self.tokenid) + " address " + get_application_address(self.tokenid))

        player2 = self.getTemporaryAccount(client)
        player3 = self.getTemporaryAccount(client)

        # This creates a asset by using another app... you can also just creat the asset from the client sdk like we do in the typescript test
        self.testid = self.createTestApp(client, player2)

        print("Lets create a brand new non-wormhole asset and try to attest and send it out")
        self.testasset = self.createTestAsset(client, player2)
        
        print("test asset id: " + str(self.testasset))

        print("Lets try to create an attest for a non-wormhole thing with a huge number of decimals")
        # paul - attestFromAlgorand
        sid = self.testAttest(client, player2, self.testasset)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        v = self.parseVAA(bytes.fromhex(vaa))
        print("We got a " + v["Meta"])

if __name__ == "__main__":
    core = AlgoTest()
    core.simple_test()

'''
'''--- lib/wormhole/algorand/test/foo.js ---
var varint = require('varint')
//
//
t = {
    'contract': '0620010181004880220001000000000000000000000000000000000000000000000000000000000000000448880001433204810312443300102212443300088190943d124433002032031244330009320312443301108106124433011922124433011881df0412443301203203124433021022124433020881001244330220802050b9d5cd33b835f53649f25be3ba6e6b8271b6d16c0af8aa97cc11761e417feb1244330209320312442243',
    'TMPL_ADDR_IDX': 0,
    'TMPL_APP_ADDRESS': '50b9d5cd33b835f53649f25be3ba6e6b8271b6d16c0af8aa97cc11761e417feb',
    'TMPL_APP_ID': 607,
    'TMPL_EMITTER_ID': '00010000000000000000000000000000000000000000000000000000000000000004',
    'TMPL_SEED_AMT': 1002000
}

t2 = {
    'contract': '062001018101488008677561726469616e48880001433204810312443300102212443300088190943d124433002032031244330009320312443301108106124433011922124433011881df0412443301203203124433021022124433020881001244330220802050b9d5cd33b835f53\
649f25be3ba6e6b8271b6d16c0af8aa97cc11761e417feb1244330209320312442243',
    'TMPL_ADDR_IDX': 1,
    'TMPL_APP_ADDRESS': '50b9d5cd33b835f53649f25be3ba6e6b8271b6d16c0af8aa97cc11761e417feb',
    'TMPL_APP_ID': 607,
    'TMPL_EMITTER_ID': '677561726469616e',
    'TMPL_SEED_AMT': 1002000
}

function properHex(v) {
    if (v < 10)
        return '0' + v.toString(16)
    else
        return v.toString(16)
}

function populate(v) {
    foo = [
        '0620010181', 
        varint.encode(v["TMPL_ADDR_IDX"]).map (n => properHex(n)).join(''),
        '4880', 
        varint.encode(v["TMPL_EMITTER_ID"].length / 2).map (n => properHex(n)).join(''),
        v["TMPL_EMITTER_ID"],
        '488800014332048103124433001022124433000881', 
        varint.encode(v["TMPL_SEED_AMT"]).map (n => properHex(n)).join(''),
        '124433002032031244330009320312443301108106124433011922124433011881', 
        varint.encode(v["TMPL_APP_ID"]).map (n => properHex(n)).join(''),
        '1244330120320312443302102212443302088100124433022080', 
        varint.encode(v["TMPL_APP_ADDRESS"].length/2).map (n => properHex(n)).join(''),
        v["TMPL_APP_ADDRESS"],
        '1244330209320312442243'
    ].join('')
    return foo
}

if (t["contract"] == populate(t)) {
    console.log("omg it works!")
} else {
    console.log("You are weak")
}

if (t2["contract"] == populate(t2)) {
    console.log("omg it works!")
} else {
    console.log("You are weak")
}

'''
'''--- lib/wormhole/algorand/test/simple.py ---
# python3 -m pip install pycryptodomex uvarint pyteal web3 coincurve

import sys
sys.path.append("..")

from admin import PortalCore, Account
from gentest import GenTest
from base64 import b64decode

from typing import List, Tuple, Dict, Any, Optional, Union
import base64
import random
import time
import hashlib
import uuid
import json

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic
from algosdk.encoding import decode_address, encode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address
from vaa_verify import get_vaa_verify

from algosdk.future.transaction import LogicSig

from test_contract import get_test_app

from algosdk.v2client import indexer

import pprint

class AlgoTest(PortalCore):
    def __init__(self) -> None:
        super().__init__()

    def getBalances(self, client: AlgodClient, account: str) -> Dict[int, int]:
        balances: Dict[int, int] = dict()
    
        accountInfo = client.account_info(account)
    
        # set key 0 to Algo balance
        balances[0] = accountInfo["amount"]
    
        assets: List[Dict[str, Any]] = accountInfo.get("assets", [])
        for assetHolding in assets:
            assetID = assetHolding["asset-id"]
            amount = assetHolding["amount"]
            balances[assetID] = amount
    
        return balances

    def createTestApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = get_test_app(client)

        globalSchema = transaction.StateSchema(num_uints=4, num_byte_slices=30)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        app_args = []

        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            app_args=app_args,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        assert response.applicationIndex is not None and response.applicationIndex > 0

        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), 
                                     receiver = get_application_address(response.applicationIndex), amt = 300000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def parseSeqFromLog(self, txn):
        return int.from_bytes(b64decode(txn.innerTxns[0]["logs"][0]), "big")

    def getVAA(self, client, sender, sid, app):
        if sid == None:
            raise Exception("getVAA called with a sid of None")

        saddr = get_application_address(app)

        # SOOO, we send a nop txn through to push the block forward
        # one

        # This is ONLY needed on a local net...  the indexer will sit
        # on the last block for 30 to 60 seconds... we don't want this
        # log in prod since it is wasteful of gas

        if (self.INDEXER_ROUND > 512):  # until they fix it
            print("indexer is broken in local net... stop/clean/restart the sandbox")
            sys.exit(0)

        txns = []

        txns.append(
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop"],
                sp=client.suggested_params(),
            )
        )
        self.sendTxn(client, sender, txns, False)

        while True:
            nexttoken = ""
            while True:
                response = self.myindexer.search_transactions( min_round=self.INDEXER_ROUND, note_prefix=self.NOTE_PREFIX, next_page=nexttoken)
#                pprint.pprint(response)
                for x in response["transactions"]:
#                    pprint.pprint(x)
                    for y in x["inner-txns"]:
                        if y["application-transaction"]["application-id"] != self.coreid:
                            continue
                        if len(y["logs"]) == 0:
                            continue
                        args = y["application-transaction"]["application-args"]
                        if len(args) < 2:
                            continue
                        if base64.b64decode(args[0]) != b'publishMessage':
                            continue
                        seq = int.from_bytes(base64.b64decode(y["logs"][0]), "big")
                        if seq != sid:
#                            print(str(seq) + " != " + str(sid))
                            continue
                        if y["sender"] != saddr:
                            continue;
                        emitter = decode_address(y["sender"])
                        payload = base64.b64decode(args[1])
#                        pprint.pprint([seq, y["sender"], payload.hex()])
#                        sys.exit(0)
                        return self.gt.genVaa(emitter, seq, payload)

                if 'next-token' in response:
                    nexttoken = response['next-token']
                else:
                    self.INDEXER_ROUND = response['current-round'] + 1
                    break
            time.sleep(1)
        
    def publishMessage(self, client, sender, vaa, appid):
        aa = decode_address(get_application_address(appid)).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        txns = []
        sp = client.suggested_params()

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=appid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"test1", vaa, self.coreid],
            foreign_apps = [self.coreid],
            accounts=[emitter_addr],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

        return self.parseSeqFromLog(resp)

    def createTestAsset(self, client, sender):
        txns = []

        a = transaction.PaymentTxn(
            sender = sender.getAddress(), 
            sp = client.suggested_params(), 
            receiver = get_application_address(self.testid), 
            amt = 300000
        )

        txns.append(a)

        sp = client.suggested_params()
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"setup"],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)
        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            grp.append(t.sign(pk))

        client.send_transactions(grp)
        resp = self.waitForTransaction(client, grp[-1].get_txid())
        
        aid = int.from_bytes(resp.__dict__["logs"][0], "big")

        print("Opting " + sender.getAddress() + " into " + str(aid))
        self.asset_optin(client, sender, aid, sender.getAddress())

        txns = []
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"mint"],
            foreign_assets = [aid],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

#        self.INDEXER_ROUND = resp.confirmedRound

        return aid

    def getCreator(self, client, sender, asset_id):
        return client.asset_info(asset_id)["params"]["creator"]

    def testAttest(self, client, sender, asset_id):
        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        creator = self.getCreator(client, sender, asset_id)
        c = client.account_info(creator)
        wormhole = c.get("auth-addr") == taddr

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())

        txns = []
        sp = client.suggested_params()

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"attestToken", asset_id],
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=[emitter_addr, creator, c["address"]],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        # Point us at the correct round
        self.INDEXER_ROUND = resp.confirmedRound

#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
        return self.parseSeqFromLog(resp)

    def transferAsset(self, client, sender, asset_id, quantity, receiver, chain, fee, payload = None):
        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        # asset_id 0 is ALGO

        if asset_id == 0:
            wormhole = False
        else:
            creator = self.getCreator(client, sender, asset_id)
            c = client.account_info(creator)
            wormhole = c.get("auth-addr") == taddr

        txns = []

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())
            print("non wormhole account " + creator)

        sp = client.suggested_params()

        if (asset_id != 0) and (not self.asset_optin_check(client, sender, asset_id, creator)):
            print("Looks like we need to optin")

            txns.append(
                transaction.PaymentTxn(
                    sender=sender.getAddress(),
                    receiver=creator,
                    amt=100000,
                    sp=sp
                )
            )

            # The tokenid app needs to do the optin since it has signature authority
            a = transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"optin", asset_id],
                foreign_assets = [asset_id],
                accounts=[creator],
                sp=sp
            )

            a.fee = a.fee * 2
            txns.append(a)
            self.sendTxn(client, sender, txns, False)
            txns = []

        if asset_id == 0:
            print("asset_id == 0")
            txns.append(transaction.PaymentTxn(
                sender=sender.getAddress(),
                receiver=creator,
                amt=quantity,
                sp=sp,
            ))
            accounts=[emitter_addr, creator, creator]
        else:
            print("asset_id != 0")
            txns.append(
                transaction.AssetTransferTxn(
                    sender = sender.getAddress(), 
                    sp = sp, 
                    receiver = creator,
                    amt = quantity,
                    index = asset_id
                ))
            accounts=[emitter_addr, creator, c["address"]]

        args = [b"sendTransfer", asset_id, quantity, decode_address(receiver), chain, fee]
        if None != payload:
            args.append(payload)

#        pprint.pprint(args)

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=args,
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=accounts,
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

#        pprint.pprint(resp.__dict__)
#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
        return self.parseSeqFromLog(resp)

    def asset_optin_check(self, client, sender, asset, receiver):
        if receiver not in self.asset_cache:
            self.asset_cache[receiver] = {}

        if asset in self.asset_cache[receiver]:
            return True

        ai = client.account_info(receiver)
        if "assets" in ai:
            for x in ai["assets"]:
                if x["asset-id"] == asset:
                    self.asset_cache[receiver][asset] = True
                    return True

        return False

    def asset_optin(self, client, sender, asset, receiver):
        if self.asset_optin_check(client, sender, asset, receiver):
            return

        pprint.pprint(["asset_optin", asset, receiver])

        sp = client.suggested_params()
        optin_txn = transaction.AssetTransferTxn(
            sender = sender.getAddress(), 
            sp = sp, 
            receiver = receiver, 
            amt = 0, 
            index = asset
        )

        transaction.assign_group_id([optin_txn])
        signed_optin = optin_txn.sign(sender.getPrivateKey())
        client.send_transactions([signed_optin])
        resp = self.waitForTransaction(client, signed_optin.get_txid())
        assert self.asset_optin_check(client, sender, asset, receiver), "The optin failed"
        print("woah! optin succeeded")

    def simple_test(self):
#        q = bytes.fromhex(gt.genAssetMeta(gt.guardianPrivKeys, 1, 1, 1, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, 8, b"USDC", b"CircleCoin"))
#        pprint.pprint(self.parseVAA(q))
#        sys.exit(0)

#        vaa = self.parseVAA(bytes.fromhex("01000000011300c412b9e5b304bde8f8633a41568991ca56b7c11a925847f0059e95010ec5241b761719f12d3f4a79d1515e08152b2e8584cd1e8217dd7743c2bf863b78b2bf040001aebade2f601a4e9083585b1bb5f98d421f116e0393f525b95d51afbe69051587531771dc127a5e9d7b74662bb7ac378d44181522dc748b1b0cbfe1b1de6ed39d01024b4e9fc86ac64aaeef84ea14e4265c3c186042a3ae9ab2933bf06c0cbf326b3c2b89e7d9854fc5204a447bd202592a72d1d6db3d007bef9fea0e35953afbd9f1010342e4446ac94545a0447851eda5d5e3b8c97c6f4ef338977562cd4ecbee2b8fea42d536d7655c28a7f7fb2ff5fc8e5775e892d853c9b2e4969f9ce054ede801700104af0d783996ccfd31d6fc6f86b634288cd2f9cc29695cfcbf12d915c1b9c383dc792c7abbe8126cd917fb8658a8de843d64171122db182453584c0c330e8889730105f34d45ec63ec0a0c4535303fd9c83a0fad6b0a112b27306a288c1b46f2a78399754536ecb07f1ab6c32d92ed50b11fef3668b23d5c1ca010ec4c924441367eac0006566671ff859eec8429874ba9e07dd107b22859cf5029928bebec6eb73cdca6752f91bb252bca76cb15ede1121a84a9a54dad126f50f282a47f7d30880ef86a3900076d0d1241e1fc9d039810a8aebd7cab863017c9420eb67f4578577c5ec4d37162723dcd6213ff6895f280a88ba70de1a5b9257fe2937cbdea007e84886abc46dd0108b24dcddaae10f5e12b7085a0c3885a050640af17ba265a448102401854183e9f3ae9a14cad1af64eb57c6f145c6f709d7ed6bb8712a6b315dc2780c9eb42812e0109df696bf506dfcd8fce57968a84d5f773706b117fad31f86bbb089ede77d71a6e54b7729f79a82e7d6e4a6797380796fbcb9ba9428e8fcdf0400515f8205b31c5010a90a03c76fdec510712b2a6ee52cc0b6df5c921437896756f34b3782aa486eb5b5d02df783664257539233502ec25bbda7dd754afc139823da8a43c0d3c91c279000b33549edd8353c4d577cb273b88b545ae547ad01e85161a4fbbbb371cff453d6311c787254e2852c3b874ea60c67d40efc3ee3f24b51bc3fe95cc0a873e8a3fb6000ce2e206214ae2b4b048857f061ed3cf8cef060c67a85ad863f266145238c5d2a85e38b4eb9b3be4d33f502df4c45762504eb43a6bf78f01363d1399b67c354df8000d2d362d64a2e3d1583e1299238829cc11d81e9b9820121c0a2eb91d542aa54c993861e8225bc3e8d028dc128d284118703a4ec69144d69402efd72a29bb9f6b8f000e6bf56fa3ae6303f495f1379b450eb52580d7d9098dd909762e6186d19e06480d2bba8f06602dbd6d3d5deac7080fc2e61bd1be97e442b63435c91fa72b33534c000fad870b47c86f6997286bd4def4bacc5a8abbfef3f730f62183c638131004ea2f706ab73ebfe8f4879bf54f580444acec212e96e41abaf4acfc3383f05478e528001089599974feaab33862cd881af13f1645079bd2fa2ff07ca744674c8556aaf97c5c9c90df332d5b4ad1428776b68612f0b1ecb98c2ebc83f44f42426f180062cd00116aa93eecb4d528afaa07b72484acd5b79ad20e9ad8e55ce37cb9138b4c12a8eb3d10fa7d932b06ac441905e0226d3420101971a72c5488e4bfef222de8c3acd1011203a3e3d8ec938ffbc3a27d8caf50fc925bd25bd286d5ad6077dffd7e205ce0806e166b661d502f8c49acf88d42fde20e6015830d5517a0bfd40f79963ded4d2d006227697a000f68690008a0ae83030f1423aa97121527f65bbbb97925b43b95231bb0478fd650a057cc4b00000000000000072003000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000000000000008cf9ee7255420a50c55ef35d4bdcdd8048dee5c3c1333ecd97aff98869ea280780008000000000000000000000000000000000000000000000000000000000007a1206869206d6f6d"))
#        pprint.pprint(vaa)
#        sys.exit(0)

        gt = GenTest(False)
        self.gt = gt

        client = self.getAlgodClient()

        print("Generating the foundation account...")
        foundation = self.getTemporaryAccount(client)
        player = self.getTemporaryAccount(client)
        player2 = self.getTemporaryAccount(client)
        player3 = self.getTemporaryAccount(client)

        self.coreid = 4
        print("coreid = " + str(self.coreid))

        self.tokenid = 6
        print("token bridge " + str(self.tokenid) + " address " + get_application_address(self.tokenid))

        self.testid = self.createTestApp(client, player2)
        print("testid " + str(self.testid) + " address " + get_application_address(self.testid))

        print("Lets create a brand new non-wormhole asset and try to attest and send it out")
        self.testasset = self.createTestAsset(client, player2)
        
        print("test asset id: " + str(self.testasset))

        print("Lets try to create an attest for a non-wormhole thing with a huge number of decimals")
        # paul - attestFromAlgorand
        sid = self.testAttest(client, player2, self.testasset)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        v = self.parseVAA(bytes.fromhex(vaa))
        print("We got a " + v["Meta"])

#        pprint.pprint(self.getBalances(client, player.getAddress()))
#        pprint.pprint(self.getBalances(client, player2.getAddress()))
#        pprint.pprint(self.getBalances(client, player3.getAddress()))
#
#        print("Lets transfer that asset to one of our other accounts... first lets create the vaa")
#        # paul - transferFromAlgorand
#        sid = self.transferAsset(client, player2, self.testasset, 100, player3.getAddress(), 8, 0)
#        print("... track down the generated VAA")
#        vaa = self.getVAA(client, player, sid, self.tokenid)
#        print(".. and lets pass that to player3")
#        self.submitVAA(bytes.fromhex(vaa), client, player3)
#
#        pprint.pprint(self.getBalances(client, player.getAddress()))
#        pprint.pprint(self.getBalances(client, player2.getAddress()))
#        pprint.pprint(self.getBalances(client, player3.getAddress()))
#
#        # Lets split it into two parts... the payload and the fee
#        print("Lets split it into two parts... the payload and the fee")
#        sid = self.transferAsset(client, player2, self.testasset, 1000, player3.getAddress(), 8, 500)
#        print("... track down the generated VAA")
#        vaa = self.getVAA(client, player, sid, self.tokenid)
#        print(".. and lets pass that to player3 with fees being passed to player acting as a relayer")
#        self.submitVAA(bytes.fromhex(vaa), client, player)
#
#        pprint.pprint(self.getBalances(client, player.getAddress()))
#        pprint.pprint(self.getBalances(client, player2.getAddress()))
#        pprint.pprint(self.getBalances(client, player3.getAddress()))
#
#        # Now it gets tricky, lets create a virgin account...
#        pk, addr  = account.generate_account()
#        emptyAccount = Account(pk)
#
#        print("How much is in the empty account? (" + addr + ")")
#        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))
#
#        # paul - transferFromAlgorand
#        print("Lets transfer algo this time.... first lets create the vaa")
#        sid = self.transferAsset(client, player2, 0, 1000000, emptyAccount.getAddress(), 8, 0)
#        print("... track down the generated VAA")
#        vaa = self.getVAA(client, player, sid, self.tokenid)
##        pprint.pprint(vaa)
#        print(".. and lets pass that to the empty account.. but use somebody else to relay since we cannot pay for it")
#
#        # paul - redeemOnAlgorand
#        self.submitVAA(bytes.fromhex(vaa), client, player)
#
#        print("=================================================")
#
#        print("How much is in the source account now?")
#        pprint.pprint(self.getBalances(client, player2.getAddress()))
#
#        print("How much is in the empty account now?")
#        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))
#
#        print("How much is in the player3 account now?")
#        pprint.pprint(self.getBalances(client, player3.getAddress()))
#
#        print("Lets transfer more algo.. splut 50/50 with the relayer.. going to player3")
#        sid = self.transferAsset(client, player2, 0, 1000000, player3.getAddress(), 8, 500000)
#        print("... track down the generated VAA")
#        vaa = self.getVAA(client, player, sid, self.tokenid)
#        print(".. and lets pass that to player3.. but use the previously empty account to relay it")
#        self.submitVAA(bytes.fromhex(vaa), client, emptyAccount)
#
#        print("How much is in the source account now?")
#        pprint.pprint(self.getBalances(client, player2.getAddress()))
#
#        print("How much is in the empty account now?")
#        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))
#
#        print("How much is in the player3 account now?")
#        pprint.pprint(self.getBalances(client, player3.getAddress()))
#
#        print("How about a payload3")
#        sid = self.transferAsset(client, player2, 0, 100, player3.getAddress(), 8, 0, b'hi mom')
#        print("... track down the generated VAA")
#        vaa = self.getVAA(client, player, sid, self.tokenid)
#
#        print(".. and lets pass that to the wrong account")
#        try:
#            self.submitVAA(bytes.fromhex(vaa), client, emptyAccount)
#        except:
#            print("Exception thrown... nice")
#
#        print(".. and lets pass that to the right account")
#        self.submitVAA(bytes.fromhex(vaa), client, player3)

#        print("player account: " + player.getAddress())
#        pprint.pprint(client.account_info(player.getAddress()))

#        print("player2 account: " + player2.getAddress())
#        pprint.pprint(client.account_info(player2.getAddress()))

#        print("foundation account: " + foundation.getAddress())
#        pprint.pprint(client.account_info(foundation.getAddress()))
#
#        print("core app: " + get_application_address(self.coreid))
#        pprint.pprint(client.account_info(get_application_address(self.coreid))),
#
#        print("token app: " + get_application_address(self.tokenid))
#        pprint.pprint(client.account_info(get_application_address(self.tokenid))),
#
#        print("asset app: " + chain_addr)
#        pprint.pprint(client.account_info(chain_addr))

core = AlgoTest()
core.simple_test()

'''
'''--- lib/wormhole/algorand/test/test.py ---
# python3 -m pip install pycryptodomex uvarint pyteal web3 coincurve

import sys
sys.path.append("..")

from admin import PortalCore, Account
from gentest import GenTest
from base64 import b64decode

from typing import List, Tuple, Dict, Any, Optional, Union
import base64
import random
import time
import hashlib
import uuid
import json

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic
from algosdk.encoding import decode_address, encode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address
from vaa_verify import get_vaa_verify

from algosdk.future.transaction import LogicSig

from test_contract import get_test_app

from algosdk.v2client import indexer

import pprint

class AlgoTest(PortalCore):
    def __init__(self) -> None:
        super().__init__()

    def getBalances(self, client: AlgodClient, account: str) -> Dict[int, int]:
        balances: Dict[int, int] = dict()
    
        accountInfo = client.account_info(account)
    
        # set key 0 to Algo balance
        balances[0] = accountInfo["amount"]
    
        assets: List[Dict[str, Any]] = accountInfo.get("assets", [])
        for assetHolding in assets:
            assetID = assetHolding["asset-id"]
            amount = assetHolding["amount"]
            balances[assetID] = amount
    
        return balances

    def createTestApp(
        self,
        client: AlgodClient,
        sender: Account,
    ) -> int:
        approval, clear = get_test_app(client)

        globalSchema = transaction.StateSchema(num_uints=4, num_byte_slices=30)
        localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=16)
    
        app_args = []

        txn = transaction.ApplicationCreateTxn(
            sender=sender.getAddress(),
            on_complete=transaction.OnComplete.NoOpOC,
            approval_program=b64decode(approval["result"]),
            clear_program=b64decode(clear["result"]),
            global_schema=globalSchema,
            local_schema=localSchema,
            app_args=app_args,
            sp=client.suggested_params(),
        )
    
        signedTxn = txn.sign(sender.getPrivateKey())
    
        client.send_transaction(signedTxn)
    
        response = self.waitForTransaction(client, signedTxn.get_txid())
        assert response.applicationIndex is not None and response.applicationIndex > 0

        txn = transaction.PaymentTxn(sender = sender.getAddress(), sp = client.suggested_params(), 
                                     receiver = get_application_address(response.applicationIndex), amt = 300000)
        signedTxn = txn.sign(sender.getPrivateKey())
        client.send_transaction(signedTxn)

        return response.applicationIndex

    def parseSeqFromLog(self, txn):
        try:
            return int.from_bytes(b64decode(txn.innerTxns[-1]["logs"][0]), "big")
        except Exception as err:
            pprint.pprint(txn.__dict__)
            raise

    def getVAA(self, client, sender, sid, app):
        if sid == None:
            raise Exception("getVAA called with a sid of None")

        saddr = get_application_address(app)

        # SOOO, we send a nop txn through to push the block forward
        # one

        # This is ONLY needed on a local net...  the indexer will sit
        # on the last block for 30 to 60 seconds... we don't want this
        # log in prod since it is wasteful of gas

        if (self.INDEXER_ROUND > 512 and not self.args.testnet):  # until they fix it
            print("indexer is broken in local net... stop/clean/restart the sandbox")
            sys.exit(0)

        txns = []

        txns.append(
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop"],
                sp=client.suggested_params(),
            )
        )
        self.sendTxn(client, sender, txns, False)

        if self.myindexer == None:
            print("indexer address: " + self.INDEXER_ADDRESS)
            self.myindexer = indexer.IndexerClient(indexer_token=self.INDEXER_TOKEN, indexer_address=self.INDEXER_ADDRESS)

        while True:
            nexttoken = ""
            while True:
                response = self.myindexer.search_transactions( min_round=self.INDEXER_ROUND, next_page=nexttoken)
#                pprint.pprint(response)
                for x in response["transactions"]:
#                    pprint.pprint(x)
                    if 'inner-txns' not in x:
                        continue

                    for y in x["inner-txns"]:
                        if "application-transaction" not in y:
                            continue
                        if y["application-transaction"]["application-id"] != self.coreid:
                            continue
                        if len(y["logs"]) == 0:
                            continue
                        args = y["application-transaction"]["application-args"]
                        if len(args) < 2:
                            continue
                        if base64.b64decode(args[0]) != b'publishMessage':
                            continue
                        seq = int.from_bytes(base64.b64decode(y["logs"][0]), "big")
                        if seq != sid:
                            continue
                        if y["sender"] != saddr:
                            continue;
                        emitter = decode_address(y["sender"])
                        payload = base64.b64decode(args[1])
#                        pprint.pprint([seq, y["sender"], payload.hex()])
#                        sys.exit(0)
                        return self.gt.genVaa(emitter, seq, payload)

                if 'next-token' in response:
                    nexttoken = response['next-token']
                else:
                    self.INDEXER_ROUND = response['current-round'] + 1
                    break
            time.sleep(1)
        
    def publishMessage(self, client, sender, vaa, appid):
        aa = decode_address(get_application_address(appid)).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        txns = []
        sp = client.suggested_params()

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=appid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"test1", vaa, self.coreid],
            foreign_apps = [self.coreid],
            accounts=[emitter_addr],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

        return self.parseSeqFromLog(resp)

    def createTestAsset(self, client, sender):
        txns = []

        a = transaction.PaymentTxn(
            sender = sender.getAddress(), 
            sp = client.suggested_params(), 
            receiver = get_application_address(self.testid), 
            amt = 300000
        )

        txns.append(a)

        sp = client.suggested_params()
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"setup"],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)
        transaction.assign_group_id(txns)

        grp = []
        pk = sender.getPrivateKey()
        for t in txns:
            grp.append(t.sign(pk))

        client.send_transactions(grp)
        resp = self.waitForTransaction(client, grp[-1].get_txid())
        
        aid = int.from_bytes(resp.__dict__["logs"][0], "big")

        print("Opting " + sender.getAddress() + " into " + str(aid))
        self.asset_optin(client, sender, aid, sender.getAddress())

        txns = []
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.testid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"mint"],
            foreign_assets = [aid],
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

#        self.INDEXER_ROUND = resp.confirmedRound

        return aid

    def getCreator(self, client, sender, asset_id):
        return client.asset_info(asset_id)["params"]["creator"]

    def testAttest(self, client, sender, asset_id):
        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        if asset_id != 0:
            creator = self.getCreator(client, sender, asset_id)
            c = client.account_info(creator)
            wormhole = c.get("auth-addr") == taddr
        else:
            c = None
            wormhole = False

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())

        txns = []
        sp = client.suggested_params()

        txns.append(transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"nop"],
            sp=sp
        ))

        mfee = self.getMessageFee()
        if (mfee > 0):
            txns.append(transaction.PaymentTxn(sender = sender.getAddress(), sp = sp, receiver = get_application_address(self.tokenid), amt = mfee))

        accts = [emitter_addr, creator, get_application_address(self.coreid)]
        if c != None:
            accts.append(c["address"])

        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=[b"attestToken", asset_id],
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=accts,
            sp=sp
        )

        if (mfee > 0):
            a.fee = a.fee * 3
        else:
            a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        # Point us at the correct round
        self.INDEXER_ROUND = resp.confirmedRound

#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
#        pprint.pprint(resp.__dict__)
        return self.parseSeqFromLog(resp)

    def transferFromAlgorand(self, client, sender, asset_id, quantity, receiver, chain, fee, payload = None):
#        pprint.pprint(["transferFromAlgorand", asset_id, quantity, receiver, chain, fee])

        taddr = get_application_address(self.tokenid)
        aa = decode_address(taddr).hex()
        emitter_addr = self.optin(client, sender, self.coreid, 0, aa)

        # asset_id 0 is ALGO

        if asset_id == 0:
            wormhole = False
        else:
            creator = self.getCreator(client, sender, asset_id)
            c = client.account_info(creator)
            wormhole = c.get("auth-addr") == taddr

        txns = []

        mfee = self.getMessageFee()
        if (mfee > 0):
            txns.append(transaction.PaymentTxn(sender = sender.getAddress(), sp = sp, receiver = get_application_address(self.tokenid), amt = mfee))

        if not wormhole:
            creator = self.optin(client, sender, self.tokenid, asset_id, b"native".hex())
            print("non wormhole account " + creator)

        sp = client.suggested_params()

        if (asset_id != 0) and (not self.asset_optin_check(client, sender, asset_id, creator)):
            print("Looks like we need to optin")

            txns.append(
                transaction.PaymentTxn(
                    sender=sender.getAddress(),
                    receiver=creator,
                    amt=100000,
                    sp=sp
                )
            )

            # The tokenid app needs to do the optin since it has signature authority
            a = transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"optin", asset_id],
                foreign_assets = [asset_id],
                accounts=[creator],
                sp=sp
            )

            a.fee = a.fee * 2
            txns.append(a)
            self.sendTxn(client, sender, txns, False)
            txns = []

        txns.insert(0, 
            transaction.ApplicationCallTxn(
                sender=sender.getAddress(),
                index=self.tokenid,
                on_complete=transaction.OnComplete.NoOpOC,
                app_args=[b"nop"],
                sp=client.suggested_params(),
            )
        )

        if asset_id == 0:
            print("asset_id == 0")
            txns.append(transaction.PaymentTxn(
                sender=sender.getAddress(),
                receiver=creator,
                amt=quantity,
                sp=sp,
            ))
            accounts=[emitter_addr, creator, creator]
        else:
            print("asset_id != 0")
            txns.append(
                transaction.AssetTransferTxn(
                    sender = sender.getAddress(), 
                    sp = sp, 
                    receiver = creator,
                    amt = quantity,
                    index = asset_id
                ))
            accounts=[emitter_addr, creator, c["address"]]

        args = [b"sendTransfer", asset_id, quantity, receiver, chain, fee]
        if None != payload:
            args.append(payload)

        #pprint.pprint(args)

#        print(self.tokenid)
        a = transaction.ApplicationCallTxn(
            sender=sender.getAddress(),
            index=self.tokenid,
            on_complete=transaction.OnComplete.NoOpOC,
            app_args=args,
            foreign_apps = [self.coreid],
            foreign_assets = [asset_id],
            accounts=accounts,
            sp=sp
        )

        a.fee = a.fee * 2

        txns.append(a)

        resp = self.sendTxn(client, sender, txns, True)

        self.INDEXER_ROUND = resp.confirmedRound

#        pprint.pprint([self.coreid, self.tokenid, resp.__dict__,
#                       int.from_bytes(resp.__dict__["logs"][1], "big"),
#                       int.from_bytes(resp.__dict__["logs"][2], "big"),
#                       int.from_bytes(resp.__dict__["logs"][3], "big"),
#                       int.from_bytes(resp.__dict__["logs"][4], "big"),
#                       int.from_bytes(resp.__dict__["logs"][5], "big")
#                       ])
#        print(encode_address(resp.__dict__["logs"][0]))
#        print(encode_address(resp.__dict__["logs"][1]))
        return self.parseSeqFromLog(resp)

    def asset_optin_check(self, client, sender, asset, receiver):
        if receiver not in self.asset_cache:
            self.asset_cache[receiver] = {}

        if asset in self.asset_cache[receiver]:
            return True

        ai = client.account_info(receiver)
        if "assets" in ai:
            for x in ai["assets"]:
                if x["asset-id"] == asset:
                    self.asset_cache[receiver][asset] = True
                    return True

        return False

    def asset_optin(self, client, sender, asset, receiver):
        if self.asset_optin_check(client, sender, asset, receiver):
            return

        pprint.pprint(["asset_optin", asset, receiver])

        sp = client.suggested_params()
        optin_txn = transaction.AssetTransferTxn(
            sender = sender.getAddress(), 
            sp = sp, 
            receiver = receiver, 
            amt = 0, 
            index = asset
        )

        transaction.assign_group_id([optin_txn])
        signed_optin = optin_txn.sign(sender.getPrivateKey())
        client.send_transactions([signed_optin])
        resp = self.waitForTransaction(client, signed_optin.get_txid())
        assert self.asset_optin_check(client, sender, asset, receiver), "The optin failed"
        print("woah! optin succeeded")

    def simple_test(self):

        #vaa = self.parseVAA(bytes.fromhex("01000000000100ddc6993585b909c3e861830244122e0daf45101663942484aa56ee2b51fa3ff016411102f993935d428a5aa0c3ace74facd60822435893b74b24fadde0fbad49006277c3fe0000000000088edf5b0e108c3a1a0a4b704cc89591f2ad8d50df24e991567e640ed720a94be200000000000000060003000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000800080000000000000000000000000000000000000000000000000000000000000000ff"))
        #pprint.pprint(vaa)
        #sys.exit(0)

#        q = bytes.fromhex(gt.genAssetMeta(gt.guardianPrivKeys, 1, 1, 1, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, 8, b"USDC", b"CircleCoin"))
#        pprint.pprint(self.parseVAA(q))
#        sys.exit(0)

#        vaa = self.parseVAA(bytes.fromhex("0100000001010001ca2fbf60ac6227d47dda4fe2e7bccc087f27d22170a212b9800da5b4cbf0d64c52deb2f65ce58be2267bf5b366437c267b5c7b795cd6cea1ac2fee8a1db3ad006225f801000000010001000000000000000000000000000000000000000000000000000000000000000400000000000000012000000000000000000000000000000000000000000000000000000000436f72650200000000000001beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe"))
#        pprint.pprint(vaa)
#        vaa = self.parseVAA(bytes.fromhex("01000000010100c22ce0a3c995fca993cb0e91af74d745b6ec1a04b3adf0bb3e432746b3e2ab5e635b65d34d5148726cac10e84bf5932a7f21b9545c362bd512617aa980e0fbf40062607566000000010001000000000000000000000000000000000000000000000000000000000000000400000000000000012000000000000000000000000000000000000000000000000000000000436f72650200000000000101beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe"))
#        pprint.pprint(vaa)
#        sys.exit(0)

        gt = GenTest(False)
        self.gt = gt

        self.setup_args()

        if self.args.testnet:
            self.testnet()
        else:
            self.devnet = True

        client = self.client = self.getAlgodClient()

        self.genTeal()

        self.vaa_verify = self.client.compile(get_vaa_verify())
        self.vaa_verify["lsig"] = LogicSig(base64.b64decode(self.vaa_verify["result"]))

        vaaLogs = []

        args = self.args

        if self.args.mnemonic:
            self.foundation = Account.FromMnemonic(self.args.mnemonic)

        if self.foundation == None:
            print("Generating the foundation account...")
            self.foundation = self.getTemporaryAccount(self.client)

        if self.foundation == None:
            print("We dont have a account?  ")
            sys.exit(1)

        foundation = self.foundation

        seq = int(time.time())

        print("Creating the PortalCore app")
        self.coreid = self.createPortalCoreApp(client=client, sender=foundation)
        print("coreid = " + str(self.coreid) + " " + get_application_address(self.coreid))

        print("bootstrapping the guardian set...")
        bootVAA = bytes.fromhex(gt.genGuardianSetUpgrade(gt.guardianPrivKeys, 1, 1, seq, seq))

        self.bootGuardians(bootVAA, client, foundation, self.coreid)

        seq += 1

        print("grabbing a untrusted account")
        player = self.getTemporaryAccount(client)
        print(player.getAddress())
        print("")

        bal = self.getBalances(client, player.getAddress())
        pprint.pprint(bal)

        print("upgrading the the guardian set using untrusted account...")
        upgradeVAA = bytes.fromhex(gt.genGuardianSetUpgrade(gt.guardianPrivKeys, 1, 2, seq, seq))
        vaaLogs.append(["guardianUpgrade", upgradeVAA.hex()])
        self.submitVAA(upgradeVAA, client, player, self.coreid)

        bal = self.getBalances(client, player.getAddress())
        pprint.pprint(bal)

        seq += 1

        print("Create the token bridge")
        self.tokenid = self.createTokenBridgeApp(client, foundation)
        print("token bridge " + str(self.tokenid) + " address " + get_application_address(self.tokenid))

        ret = self.devnetUpgradeVAA()
#        pprint.pprint(ret)
        print("Submitting core")
        self.submitVAA(bytes.fromhex(ret[0]), self.client, foundation, self.coreid)
        print("Submitting token")
        self.submitVAA(bytes.fromhex(ret[1]), self.client, foundation, self.tokenid)

        print("successfully sent upgrade requests")

        for r in range(1, 6):
            print("Registering chain " + str(r))
            v = gt.genRegisterChain(gt.guardianPrivKeys, 2, seq, seq, r)
            vaa = bytes.fromhex(v)
#            pprint.pprint((v, self.parseVAA(vaa)))
            if r == 2:
                vaaLogs.append(["registerChain", v])
            self.submitVAA(vaa, client, player, self.tokenid)
            seq += 1

            bal = self.getBalances(client, player.getAddress())
            pprint.pprint(bal)

        print("Create a asset")
        attestVAA = bytes.fromhex(gt.genAssetMeta(gt.guardianPrivKeys, 2, seq, seq, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, 8, b"USDC", b"CircleCoin"))
        # paul - createWrappedOnAlgorand
        vaaLogs.append(["createWrappedOnAlgorand", attestVAA.hex()])
        self.submitVAA(attestVAA, client, player, self.tokenid)
        seq += 1

        p = self.parseVAA(attestVAA)
        chain_addr = self.optin(client, player, self.tokenid, p["FromChain"], p["Contract"])

        print("Create the same asset " + str(seq))
        # paul - updateWrappedOnAlgorand
        attestVAA = bytes.fromhex(gt.genAssetMeta(gt.guardianPrivKeys, 2, seq, seq, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, 8, b"USD2C", b"Circle2Coin"))
        self.submitVAA(attestVAA, client, player, self.tokenid)
        seq += 1

        print("Transfer the asset " + str(seq))
        transferVAA = bytes.fromhex(gt.genTransfer(gt.guardianPrivKeys, 1, 1, 1, 1, bytes.fromhex("4523c3F29447d1f32AEa95BEBD00383c4640F1b4"), 1, decode_address(player.getAddress()), 8, 0))
        # paul - redeemOnAlgorand
        vaaLogs.append(["redeemOnAlgorand", transferVAA.hex()])
        self.submitVAA(transferVAA, client, player, self.tokenid)
        seq += 1

        print("Create the test app we will use to torture ourselves using a new player")
        player2 = self.getTemporaryAccount(client)
        print("player2 address " + player2.getAddress())
        player3 = self.getTemporaryAccount(client)
        print("player3 address " + player3.getAddress())

        self.testid = self.createTestApp(client, player2)
        print("testid " + str(self.testid) + " address " + get_application_address(self.testid))

        print("Sending a message payload to the core contract")
        sid = self.publishMessage(client, player, b"you also suck", self.testid)
        self.publishMessage(client, player2, b"second suck", self.testid)
        self.publishMessage(client, player3, b"last message", self.testid)

        print("Lets create a brand new non-wormhole asset and try to attest and send it out")
        self.testasset = self.createTestAsset(client, player2)
        print("test asset id: " + str(self.testasset))
        
        print("Now lets create an attest of ALGO")
        sid = self.testAttest(client, player2, 0)
        vaa = self.getVAA(client, player, sid, self.tokenid)
        v = self.parseVAA(bytes.fromhex(vaa))
        print("We got a " + v["Meta"])

        print("Lets try to create an attest for a non-wormhole thing with a huge number of decimals")
        # paul - attestFromAlgorand
        sid = self.testAttest(client, player2, self.testasset)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        v = self.parseVAA(bytes.fromhex(vaa))
        print("We got a " + v["Meta"])

        pprint.pprint(self.getBalances(client, player.getAddress()))
        pprint.pprint(self.getBalances(client, player2.getAddress()))
        pprint.pprint(self.getBalances(client, player3.getAddress()))

        print("Lets transfer that asset to one of our other accounts... first lets create the vaa")
        # paul - transferFromAlgorand
        sid = self.transferFromAlgorand(client, player2, self.testasset, 100, decode_address(player3.getAddress()), 8, 0)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        print(".. and lets pass that to player3")
        vaaLogs.append(["transferFromAlgorand", vaa])
        #pprint.pprint(vaaLogs)
        self.submitVAA(bytes.fromhex(vaa), client, player3, self.tokenid)

        pprint.pprint(["player", self.getBalances(client, player.getAddress())])
        pprint.pprint(["player2", self.getBalances(client, player2.getAddress())])
        pprint.pprint(["player3", self.getBalances(client, player3.getAddress())])

        # Lets split it into two parts... the payload and the fee
        print("Lets split it into two parts... the payload and the fee (400 should go to player, 600 should go to player3)")
        sid = self.transferFromAlgorand(client, player2, self.testasset, 1000, decode_address(player3.getAddress()), 8, 400)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
#        pprint.pprint(self.parseVAA(bytes.fromhex(vaa)))
        print(".. and lets pass that to player3 with fees being passed to player acting as a relayer (" + str(self.tokenid) + ")")
        self.submitVAA(bytes.fromhex(vaa), client, player, self.tokenid)

        pprint.pprint(["player", self.getBalances(client, player.getAddress())])
        pprint.pprint(["player2", self.getBalances(client, player2.getAddress())])
        pprint.pprint(["player3", self.getBalances(client, player3.getAddress())])

#        sys.exit(0)

        # Now it gets tricky, lets create a virgin account...
        pk, addr  = account.generate_account()
        emptyAccount = Account(pk)

        print("How much is in the empty account? (" + addr + ")")
        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))

        # paul - transferFromAlgorand
        print("Lets transfer algo this time.... first lets create the vaa")
        sid = self.transferFromAlgorand(client, player2, 0, 1000000, decode_address(emptyAccount.getAddress()), 8, 0)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
#        pprint.pprint(vaa)
        print(".. and lets pass that to the empty account.. but use somebody else to relay since we cannot pay for it")

        # paul - redeemOnAlgorand
        self.submitVAA(bytes.fromhex(vaa), client, player, self.tokenid)

        print("=================================================")

        print("How much is in the source account now?")
        pprint.pprint(self.getBalances(client, player2.getAddress()))

        print("How much is in the empty account now?")
        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))

        print("How much is in the player3 account now?")
        pprint.pprint(self.getBalances(client, player3.getAddress()))

        print("Lets transfer more algo.. split 40/60 with the relayer.. going to player3")
        sid = self.transferFromAlgorand(client, player2, 0, 1000000, decode_address(player3.getAddress()), 8, 400000)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        print(".. and lets pass that to player3.. but use the previously empty account to relay it")
        self.submitVAA(bytes.fromhex(vaa), client, emptyAccount, self.tokenid)

        print("How much is in the source account now?")
        pprint.pprint(self.getBalances(client, player2.getAddress()))

        print("How much is in the empty account now?")
        pprint.pprint(self.getBalances(client, emptyAccount.getAddress()))

        print("How much is in the player3 account now?")
        pprint.pprint(self.getBalances(client, player3.getAddress()))

        print("How about a payload3: " + self.testid.to_bytes(32, "big").hex())
        sid = self.transferFromAlgorand(client, player2, 0, 100, self.testid.to_bytes(32, "big"), 8, 0, b'hi mom')
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)

        print("player address: " + decode_address(player2.getAddress()).hex())
        print("payload3 vaa: "+ vaa)
        pprint.pprint(self.parseVAA(bytes.fromhex(vaa)))

        print("testid balance before = ", self.getBalances(client, get_application_address(self.testid)))

        print(".. Lets let player3 relay it for us")
        self.submitVAA(bytes.fromhex(vaa), client, player3, self.tokenid)

        print("testid balance after = ", self.getBalances(client, get_application_address(self.testid)))

#        sys.exit(0)

        print(".. Ok, now it is time to up the message fees")

        bal = self.getBalances(client, get_application_address(self.coreid))
        print("core contract has " + str(bal) + " algo (" + get_application_address(self.coreid) + ")")
        print("core contract has a MessageFee set to " + str(self.getMessageFee()))

        seq += 1
        v = gt.genGSetFee(gt.guardianPrivKeys, 2, seq, seq, 2000000)
        self.submitVAA(bytes.fromhex(v), client, player, self.coreid)
        seq += 1

        print("core contract now has a MessageFee set to " + str(self.getMessageFee()))

#        v = gt.genGSetFee(gt.guardianPrivKeys, 2, seq, seq, 0)
#        self.submitVAA(bytes.fromhex(v), client, player, self.coreid)
#        seq += 1

#        print("core contract is back to  " + str(self.getMessageFee()))

        print("Generating an attest.. This will cause a message to get published .. which should cause fees to get sent to the core contract")
        sid = self.testAttest(client, player2, self.testasset)
        print("... track down the generated VAA")
        vaa = self.getVAA(client, player, sid, self.tokenid)
        v = self.parseVAA(bytes.fromhex(vaa))
        print("We got a " + v["Meta"])

        bal = self.getBalances(client, get_application_address(self.coreid))
        print("core contract has " + str(bal) + " algo (" + get_application_address(self.coreid) + ")")

#        print("player account: " + player.getAddress())
#        pprint.pprint(client.account_info(player.getAddress()))

#        print("player2 account: " + player2.getAddress())
#        pprint.pprint(client.account_info(player2.getAddress()))

#        print("foundation account: " + foundation.getAddress())
#        pprint.pprint(client.account_info(foundation.getAddress()))
#
#        print("core app: " + get_application_address(self.coreid))
#        pprint.pprint(client.account_info(get_application_address(self.coreid))),
#
#        print("token app: " + get_application_address(self.tokenid))
#        pprint.pprint(client.account_info(get_application_address(self.tokenid))),
#
#        print("asset app: " + chain_addr)
#        pprint.pprint(client.account_info(chain_addr))

if __name__ == "__main__":
    core = AlgoTest()
    core.simple_test()

'''
'''--- lib/wormhole/algorand/test_contract.py ---
#!/usr/bin/python3
"""
Copyright 2022 Wormhole Project Contributors

Licensed under the Apache License, Version 2.0 (the "License");

you may not use this file except in compliance with the License.

You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

"""

from typing import List, Tuple, Dict, Any, Optional, Union

from pyteal.ast import *
from pyteal.types import *
from pyteal.compiler import *
from pyteal.ir import  *
from globals import *
from inlineasm import *

from algosdk.v2client.algod import AlgodClient

from TmplSig import TmplSig

from local_blob import LocalBlob

import sys

portal_transfer_selector = MethodSignature("portal_transfer(byte[])byte[]")

def fullyCompileContract(client: AlgodClient, contract: Expr) -> bytes:
    teal = compileTeal(contract, mode=Mode.Application, version=6)
    response = client.compile(teal)
    return response

def clear_app():
    return Int(1)

def approve_app():
    me = Global.current_application_address()

    def nop():
        return Seq([Approve()])

    def test1():
        # Look! a proxy contract that sends message to the core
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.ApplicationCall,
                    TxnField.application_id: Btoi(Txn.application_args[2]),
                    TxnField.application_args: [Bytes("publishMessage"), Txn.application_args[1]],
                    TxnField.accounts: [Txn.accounts[1]],
                    TxnField.note: Bytes("publishMessage"),
                    TxnField.fee: Int(0),
                }
            ),
            InnerTxnBuilder.Submit(),
            Approve()
        )
        
    def setup():
        aid = ScratchVar()

        return Seq([
            # Create a test asset
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.sender: Global.current_application_address(),
                    TxnField.type_enum: TxnType.AssetConfig,
                    TxnField.config_asset_name: Bytes("TestAsset"),
                    TxnField.config_asset_unit_name: Bytes("testAsse"),
                    TxnField.config_asset_total: Int(int(1e17)),
                    TxnField.config_asset_decimals: Int(10),
                    TxnField.config_asset_manager: Global.current_application_address(),
                    TxnField.config_asset_reserve: Global.current_application_address(),

                    # We cannot freeze or clawback assets... per the spirit of 
                    TxnField.config_asset_freeze: Global.zero_address(),
                    TxnField.config_asset_clawback: Global.zero_address(),

                    TxnField.fee: Int(0),
                }
            ),
            InnerTxnBuilder.Submit(),

            aid.store(Itob(InnerTxn.created_asset_id())),

            App.globalPut(Bytes("asset"), aid.load()),
            Log(aid.load()),

            Approve()
        ])

    def completeTransfer():
        off = ScratchVar()

        return Seq([
            off.store(Btoi(Extract(Txn.application_args[1], Int(7), Int(1))) * Int(66) + Int(192)), 
            Log(Extract(Txn.application_args[1], off.load(), Len(Txn.application_args[1]) - off.load())),
            Approve()
        ])

    def mint():
        return Seq([
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                 {
                     TxnField.sender: Global.current_application_address(),
                     TxnField.type_enum: TxnType.AssetTransfer,
                     TxnField.xfer_asset: Btoi(App.globalGet(Bytes("asset"))),
                     TxnField.asset_amount: Int(100000),
                     TxnField.asset_receiver: Txn.sender(),
                     TxnField.fee: Int(0),
                 }
            ),
            InnerTxnBuilder.Submit(),

            Approve()
        ])

    METHOD = Txn.application_args[0]

    router = Cond(
        [METHOD == Bytes("nop"), nop()],
        [METHOD == Bytes("test1"), test1()],
        [METHOD == Bytes("setup"), setup()],
        [METHOD == Bytes("mint"), mint()],
        [METHOD == portal_transfer_selector, completeTransfer()],
    )

    on_create = Seq( [
        Return(Int(1))
    ])

    on_update = Seq( [
        Return(Int(1))
    ] )

    on_delete = Seq( [
        Return(Int(1))
    ] )

    on_optin = Seq( [
        Return(Int(1))
    ] )

    return Cond(
        [Txn.application_id() == Int(0), on_create],
        [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
        [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
        [Txn.on_completion() == OnComplete.OptIn, on_optin],
        [Txn.on_completion() == OnComplete.NoOp, router]
    )

def get_test_app(client: AlgodClient) -> Tuple[bytes, bytes]:
    APPROVAL_PROGRAM = fullyCompileContract(client, approve_app())
    CLEAR_STATE_PROGRAM = fullyCompileContract(client, clear_app())

    return APPROVAL_PROGRAM, CLEAR_STATE_PROGRAM

'''
'''--- lib/wormhole/algorand/token_bridge.py ---
#!/usr/bin/python3
"""
Copyright 2022 Wormhole Project Contributors

Licensed under the Apache License, Version 2.0 (the "License");

you may not use this file except in compliance with the License.

You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

"""
from typing import List, Tuple, Dict, Any, Optional, Union

from pyteal.ast import *
from pyteal.types import *
from pyteal.compiler import *
from pyteal.ir import *
from globals import *
from inlineasm import *

from algosdk.v2client.algod import AlgodClient
from algosdk.encoding import decode_address

from TmplSig import TmplSig
from local_blob import LocalBlob

import pprint
import sys

max_keys = 15
max_bytes_per_key = 127
bits_per_byte = 8

bits_per_key = max_bytes_per_key * bits_per_byte
max_bytes = max_bytes_per_key * max_keys
max_bits = bits_per_byte * max_bytes

portal_transfer_selector = MethodSignature("portal_transfer(byte[])byte[]")

def fullyCompileContract(genTeal, client: AlgodClient, contract: Expr, name, devmode) -> bytes:
    if devmode:
        teal = compileTeal(contract, mode=Mode.Application, version=6, assembleConstants=True)
    else:
        teal = compileTeal(contract, mode=Mode.Application, version=6, assembleConstants=True, optimize=OptimizeOptions(scratch_slots=True))

    if genTeal:
        with open(name, "w") as f:
            print("Writing " + name)
            f.write(teal)
    else:
        with open(name, "r") as f:
            print("Reading " + name)
            teal = f.read()

    response = client.compile(teal)

    with open(name + ".bin", "w") as fout:
        fout.write(response["result"])
    with open(name + ".hash", "w") as fout:
        fout.write(decode_address(response["hash"]).hex())

    return response

def clear_token_bridge():
    return Int(1)

def approve_token_bridge(seed_amt: int, tmpl_sig: TmplSig, devMode: bool):
    blob = LocalBlob()
    tidx = ScratchVar()
    mfee = ScratchVar()

    def MagicAssert(a) -> Expr:
        if devMode:
            from inspect import currentframe
            return Assert(And(a, Int(currentframe().f_back.f_lineno)))
        else:
            return Assert(a)

    @Subroutine(TealType.uint64)
    def governanceSet() -> Expr:
        maybe = App.globalGetEx(App.globalGet(Bytes("coreid")), Bytes("currentGuardianSetIndex"))
        return Seq(maybe, MagicAssert(maybe.hasValue()), maybe.value())

    @Subroutine(TealType.uint64)
    def getMessageFee() -> Expr:
        maybe = App.globalGetEx(App.globalGet(Bytes("coreid")), Bytes("MessageFee"))
        return Seq(maybe, MagicAssert(maybe.hasValue()), maybe.value())

    @Subroutine(TealType.bytes)
    def getAppAddress(appid : Expr) -> Expr:
        maybe = AppParam.address(appid)
        return Seq(maybe, MagicAssert(maybe.hasValue()), maybe.value())

    def assert_common_checks(e) -> Expr:
        return MagicAssert(And(
            e.rekey_to() == Global.zero_address(),
            e.close_remainder_to() == Global.zero_address(),
            e.asset_close_to() == Global.zero_address(),
            e.on_completion() == OnComplete.NoOp
        ))

    @Subroutine(TealType.none)
    def checkFeePmt(off : Expr):
        return Seq([
            If(mfee.load() > Int(0), Seq([
                    tidx.store(Txn.group_index() - off),
                    MagicAssert(And(
                        Gtxn[tidx.load()].type_enum() == TxnType.Payment,
                        Gtxn[tidx.load()].sender() == Txn.sender(),
                        Gtxn[tidx.load()].receiver() == Global.current_application_address(),
                        Gtxn[tidx.load()].amount() >= mfee.load()
                    )),
                    assert_common_checks(Gtxn[tidx.load()])
            ]))
        ])

    @Subroutine(TealType.none)
    def sendMfee():
        return Seq([
            If (mfee.load() > Int(0), Seq([
                    InnerTxnBuilder.SetFields(
                        {
                            TxnField.type_enum: TxnType.Payment,
                            TxnField.receiver: App.globalGet(Bytes("coreAddr")),
                            TxnField.amount: mfee.load(),
                            TxnField.fee: Int(0),
                        }
                    ),
                    InnerTxnBuilder.Next(),
            ])),
        ])
    
    @Subroutine(TealType.bytes)
    def encode_uvarint(val: Expr, b: Expr):
        buff = ScratchVar()
        return Seq(
            buff.store(b),
            Concat(
                buff.load(),
                If(
                        val >= Int(128),
                        encode_uvarint(
                            val >> Int(7),
                            Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),
                        ),
                        Extract(Itob(val & Int(255)), Int(7), Int(1)),
                ),
            ),
        )

    @Subroutine(TealType.bytes)
    def trim_bytes(str: Expr):
        len = ScratchVar()
        off = ScratchVar()
        zero = ScratchVar()
        r = ScratchVar()

        return Seq([
            r.store(str),

            len.store(Len(r.load())),
            zero.store(BytesZero(Int(1))),
            off.store(Int(0)),

            While(off.load() < len.load()).Do(Seq([
                If(Extract(r.load(), off.load(), Int(1)) == zero.load()).Then(Seq([
                        r.store(Extract(r.load(), Int(0), off.load())),
                        off.store(len.load())
                ])),
                    off.store(off.load() + Int(1))
            ])),
            r.load()
        ])

    @Subroutine(TealType.uint64)
    def getFactor(dec: Expr):
        return Cond(
            [dec < Int(9), Int(1)],
            [dec > Int(19), Seq(Reject(), Int(1))],
            [Int(1), Exp(Int(10), dec - Int(8))]
        )

    @Subroutine(TealType.bytes)
    def get_sig_address(acct_seq_start: Expr, emitter: Expr):
        # We could iterate over N items and encode them for a more general interface
        # but we inline them directly here

        return Sha512_256(
            Concat(
                Bytes("Program"),
                # ADDR_IDX aka sequence start
                tmpl_sig.get_bytecode_chunk(0),
                encode_uvarint(acct_seq_start, Bytes("")),

                # EMMITTER_ID
                tmpl_sig.get_bytecode_chunk(1),
                encode_uvarint(Len(emitter), Bytes("")),
                emitter,

                # APP_ID
                tmpl_sig.get_bytecode_chunk(2),
                encode_uvarint(Global.current_application_id(), Bytes("")),

                # TMPL_APP_ADDRESS
                tmpl_sig.get_bytecode_chunk(3),
                encode_uvarint(Len(Global.current_application_address()), Bytes("")),
                Global.current_application_address(),

                tmpl_sig.get_bytecode_chunk(4),
            )
        )

    def governance():
        off = ScratchVar()
        a = ScratchVar()
        targetChain = ScratchVar()
        chain = ScratchVar()
        emitter = ScratchVar()
        set = ScratchVar()
        idx = ScratchVar()
        verifyIdx = ScratchVar()

        verifyVAA = Gtxn[verifyIdx.load()]

    
        return Seq([
            checkForDuplicate(),

            # All governance must be done with the most recent guardian set...
            set.store(governanceSet()),
            idx.store(Extract(Txn.application_args[1], Int(1), Int(4))),
            MagicAssert(Btoi(idx.load()) == set.load()),

            # The offset of the chain
            off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(14)), 

            verifyIdx.store(Txn.group_index() - Int(1)),

            MagicAssert(And(
                # Did verifyVAA pass?
                verifyVAA.type_enum() == TxnType.ApplicationCall,
                verifyVAA.application_id() == App.globalGet(Bytes("coreid")),
                verifyVAA.application_args[0] == Bytes("verifyVAA"),
                verifyVAA.sender() == Txn.sender(),
                verifyVAA.on_completion() == OnComplete.NoOp,

                # Lets see if the vaa we are about to process was actually verified by the core
                verifyVAA.application_args[1] == Txn.application_args[1],

                # We all opted into the same accounts?
                verifyVAA.accounts[0] == Txn.accounts[0],
                verifyVAA.accounts[1] == Txn.accounts[1],
                verifyVAA.accounts[2] == Txn.accounts[2],

                # Better be the right emitters
                Extract(Txn.application_args[1], off.load(), Int(2)) == Bytes("base16", "0001"),
                Extract(Txn.application_args[1], off.load() + Int(2), Int(32)) == Concat(BytesZero(Int(31)), Bytes("base16", "04")),
            )),

            assert_common_checks(verifyVAA),
            assert_common_checks(Txn),

            # correct module?
            MagicAssert(Extract(Txn.application_args[1], off.load() + Int(43), Int(32)) == Concat(BytesZero(Int(21)), Bytes("base16", "546f6b656e427269646765"))),
            a.store(Btoi(Extract(Txn.application_args[1], off.load() + Int(75), Int(1)))),
            off.store(off.load() + Int(76)),

            Cond( 
                [a.load() == Int(1), Seq([
                    targetChain.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(2)))),

                    MagicAssert(Or((targetChain.load() == Int(0)), (targetChain.load() == Int(8)))),

                    chain.store(Extract(Txn.application_args[1], off.load() + Int(2), Int(2))),
                    emitter.store(Extract(Txn.application_args[1], off.load() + Int(4), Int(32))),

                    # Can I only register once?  Rumor says yes
                    MagicAssert(App.globalGet(Concat(Bytes("Chain"), chain.load())) == Int(0)),

                    App.globalPut(Concat(Bytes("Chain"), chain.load()), emitter.load()),
                ])],
                [a.load() == Int(2), Seq([
                    MagicAssert(Extract(Txn.application_args[1], off.load(), Int(2)) == Bytes("base16", "0008")),
                    App.globalPut(Bytes("validUpdateApproveHash"), Extract(Txn.application_args[1], off.load() + Int(2), Int(32)))
                ])]
            ),

            Approve()
        ])

#    # This blows up an asset on algorand.  This will be added temporarily (and then removed) to clean some stuff before we relaunch
#    def killAsset():
#        return Seq([
#            MagicAssert(Txn.sender() == Global.creator_address()),
#
#            blob.zero(Int(1)),
#
#            InnerTxnBuilder.Begin(),
#            InnerTxnBuilder.SetFields(
#                {
#                    TxnField.sender: Global.current_application_address(),
#                    TxnField.type_enum: TxnType.AssetConfig,
#                    TxnField.config_asset: Btoi(Txn.application_args[1]),
#                    TxnField.fee: Int(0),
#                }
#            ),
#            InnerTxnBuilder.Submit(),
#
#            Approve()
#        ])
    
    def receiveAttest():
        me = Global.current_application_address()
        off = ScratchVar()
        
        Address = ScratchVar()
        Chain = ScratchVar()
        FromChain = ScratchVar()
        Decimals = ScratchVar()
        Symbol = ScratchVar()
        Name = ScratchVar()

        asset = ScratchVar()
        buf = ScratchVar()
        c = ScratchVar()
        a = ScratchVar()

        return Seq([
            checkForDuplicate(),

            tidx.store(Txn.group_index() - Int(4)),

            MagicAssert(And(
                # Lets see if the vaa we are about to process was actually verified by the core
                Gtxn[tidx.load()].type_enum() == TxnType.ApplicationCall,
                Gtxn[tidx.load()].application_id() == App.globalGet(Bytes("coreid")),
                Gtxn[tidx.load()].application_args[0] == Bytes("verifyVAA"),
                Gtxn[tidx.load()].sender() == Txn.sender(),
                Gtxn[tidx.load()].on_completion() == OnComplete.NoOp,

                # we are all taking about the same vaa?
                Gtxn[tidx.load()].application_args[1] == Txn.application_args[1],

                # We all opted into the same accounts?
                Gtxn[tidx.load()].accounts[0] == Txn.accounts[0],
                Gtxn[tidx.load()].accounts[1] == Txn.accounts[1],
                Gtxn[tidx.load()].accounts[2] == Txn.accounts[2],
                )),
            assert_common_checks(Gtxn[tidx.load()]),
                
            tidx.store(Txn.group_index() - Int(3)),
            MagicAssert(And(
                # Did the user pay the lsig to attest a new product?
                Gtxn[tidx.load()].type_enum() == TxnType.Payment,
                Gtxn[tidx.load()].amount() >= Int(100000),
                Gtxn[tidx.load()].sender() == Txn.sender(),
                Gtxn[tidx.load()].receiver() == Txn.accounts[3],
                )),
            assert_common_checks(Gtxn[tidx.load()]),

            tidx.store(Txn.group_index() - Int(2)),
            MagicAssert(And(
                # We had to buy some extra CPU
                Gtxn[tidx.load()].type_enum() == TxnType.ApplicationCall,
                Gtxn[tidx.load()].application_id() == Global.current_application_id(),
                Gtxn[tidx.load()].application_args[0] == Bytes("nop"),
                Gtxn[tidx.load()].sender() == Txn.sender(),
                )),
            assert_common_checks(Gtxn[tidx.load()]),

            tidx.store(Txn.group_index() - Int(1)),
            MagicAssert(And(
                Gtxn[tidx.load()].type_enum() == TxnType.ApplicationCall,
                Gtxn[tidx.load()].application_id() == Global.current_application_id(),
                Gtxn[tidx.load()].application_args[0] == Bytes("nop"),
                Gtxn[tidx.load()].sender() == Txn.sender(),
                
                (Global.group_size() - Int(1)) == Txn.group_index()    # This should be the last entry...
            )),
            assert_common_checks(Gtxn[tidx.load()]),

            off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(6) + Int(8)), # The offset of the chain
            Chain.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(2)))),

            # Make sure that the emitter on the sending chain is correct for the token bridge
            MagicAssert(App.globalGet(Concat(Bytes("Chain"), Extract(Txn.application_args[1], off.load(), Int(2)))) 
                   == Extract(Txn.application_args[1], off.load() + Int(2), Int(32))),
            
            off.store(off.load()+Int(43)),

            MagicAssert(Int(2) ==      Btoi(Extract(Txn.application_args[1], off.load(),      Int(1)))),
            Address.store(             Extract(Txn.application_args[1], off.load() + Int(1),  Int(32))),
            
            FromChain.store(      Btoi(Extract(Txn.application_args[1], off.load() + Int(33), Int(2)))),
            Decimals.store(       Btoi(Extract(Txn.application_args[1], off.load() + Int(35), Int(1)))),
            Symbol.store(              Extract(Txn.application_args[1], off.load() + Int(36), Int(32))),
            Name.store(                Extract(Txn.application_args[1], off.load() + Int(68), Int(32))),

            # Lets trim this... seems these are limited to 8 characters
            Symbol.store(trim_bytes(Symbol.load())),
            If (Len(Symbol.load()) > Int(8), Symbol.store(Extract(Symbol.load(), Int(0), Int(8)))),
            Name.store(trim_bytes(Name.load())),

            # Due to constrains on some supported chains, all token
            # amounts passed through the token bridge are truncated to
            # a maximum of 8 decimals. 
            # 
            # Any chains implementation must make sure that of any
            # token only ever MaxUint64 units (post-shifting) are
            # bridged into the wormhole network at any given time (all
            # target chains combined), even tough the slot is 32 bytes
            # long (theoretically fitting uint256). 
            If(Decimals.load() > Int(8), Decimals.store(Int(8))),

            #   This confirms the user gave us access to the correct memory for this asset..
            MagicAssert(Txn.accounts[3] == get_sig_address(FromChain.load(), Address.load())),

            # Lets see if we've seen this asset before
            asset.store(blob.read(Int(3), Int(0), Int(8))),

            # The # offset to the digest
            off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(6)), 

            # New asset
            If(asset.load() == Itob(Int(0))).Then(Seq([
                    InnerTxnBuilder.Begin(),
                    InnerTxnBuilder.SetFields(
                        {
                            TxnField.sender: Txn.accounts[3],
                            TxnField.type_enum: TxnType.AssetConfig,
                            TxnField.config_asset_name: Name.load(),
                            TxnField.config_asset_unit_name: Symbol.load(),
                            TxnField.config_asset_total: Int(18446744073709550000),
                            TxnField.config_asset_decimals: Decimals.load(),
                            TxnField.config_asset_manager: me,
                            TxnField.config_asset_reserve: Txn.accounts[3],

                            TxnField.config_asset_freeze: me,
                            TxnField.config_asset_clawback: me,

                            TxnField.fee: Int(0),
                        }
                    ),
                    InnerTxnBuilder.Submit(),

                    asset.store(Itob(InnerTxn.created_asset_id())),
                    Pop(blob.write(Int(3), Int(0), asset.load())),
                    blob.meta(Int(3), Bytes("asset"))
            ])),

            # We save away the entire digest that created this asset in case we ever need to reproduce it while sending this
            # coin to another chain

            buf.store(Txn.application_args[1]),
            Pop(blob.write(Int(3), Int(8), Extract(buf.load(), off.load(), Len(buf.load()) - off.load()))),

            Approve()
        ])

    def completeTransfer():
        me = Global.current_application_address()
        off = ScratchVar()
        
        Chain = ScratchVar()
        Emitter = ScratchVar()

        Amount = ScratchVar()
        Origin = ScratchVar()
        OriginChain = ScratchVar()
        Destination = ScratchVar()
        DestChain = ScratchVar()
        Fee = ScratchVar()
        asset = ScratchVar()

        factor = ScratchVar()
        d = ScratchVar()
        zb = ScratchVar()
        action = ScratchVar()
        aid = ScratchVar()
        
        return Seq([
            checkForDuplicate(),

            zb.store(BytesZero(Int(32))),

            tidx.store(Txn.group_index() - Int(1)),

            MagicAssert(And(
                # Lets see if the vaa we are about to process was actually verified by the core
                Gtxn[tidx.load()].type_enum() == TxnType.ApplicationCall,
                Gtxn[tidx.load()].application_id() == App.globalGet(Bytes("coreid")),
                Gtxn[tidx.load()].application_args[0] == Bytes("verifyVAA"),
                Gtxn[tidx.load()].sender() == Txn.sender(),
                Gtxn[tidx.load()].on_completion() == OnComplete.NoOp,

                # Lets see if the vaa we are about to process was actually verified by the core
                Gtxn[tidx.load()].application_args[1] == Txn.application_args[1],

                # We all opted into the same accounts?
                Gtxn[tidx.load()].accounts[0] == Txn.accounts[0],
                Gtxn[tidx.load()].accounts[1] == Txn.accounts[1],
                Gtxn[tidx.load()].accounts[2] == Txn.accounts[2]
            )),
            assert_common_checks(Gtxn[tidx.load()]),
            assert_common_checks(Txn),

            off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(6) + Int(8)), # The offset of the chain

            Chain.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(2)))),
            Emitter.store(Extract(Txn.application_args[1], off.load() + Int(2), Int(32))),

            # We coming from the correct emitter on the sending chain for the token bridge
            # ... This is 90% of the security...
            If(Chain.load() == Int(8),
               MagicAssert(Global.current_application_address() == Emitter.load()), # This came from us?
               MagicAssert(App.globalGet(Concat(Bytes("Chain"), Extract(Txn.application_args[1], off.load(), Int(2)))) == Emitter.load())),

            off.store(off.load()+Int(43)),

            # This is a transfer message... right?
            action.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(1)))),

            MagicAssert(Or(action.load() == Int(1), action.load() == Int(3))),

            MagicAssert(Extract(Txn.application_args[1], off.load() + Int(1), Int(24)) == Extract(zb.load(), Int(0), Int(24))),
            Amount.store(        Btoi(Extract(Txn.application_args[1], off.load() + Int(25), Int(8)))),  # uint256

            Origin.store(             Extract(Txn.application_args[1], off.load() + Int(33), Int(32))),
            OriginChain.store(   Btoi(Extract(Txn.application_args[1], off.load() + Int(65), Int(2)))),
            Destination.store(        Extract(Txn.application_args[1], off.load() + Int(67), Int(32))),
            DestChain.store(     Btoi(Extract(Txn.application_args[1], off.load() + Int(99), Int(2)))),

            # This directed at us?
            MagicAssert(DestChain.load() == Int(8)),

            If (action.load() == Int(3), Seq([
                    aid.store(Btoi(Extract(Destination.load(), Int(24), Int(8)))), # The destination is the appid in a payload3
                    tidx.store(Txn.group_index() + Int(1)),
                    MagicAssert(And(
                        Gtxn[tidx.load()].type_enum() == TxnType.ApplicationCall,
                        Gtxn[tidx.load()].application_args[0] == portal_transfer_selector, # sha256("portal_transfer(byte[])byte[]")[:4]
                        Gtxn[tidx.load()].application_args[1] == Concat(Extract(Itob(Len(Txn.application_args[1])), Int(6), Int(2)), Txn.application_args[1]),
                        Gtxn[tidx.load()].application_id() == aid.load()
                    )),
                    Destination.store(getAppAddress(aid.load())),
                    Fee.store(Int(0))
                ]), Seq([
                    MagicAssert(Extract(Txn.application_args[1], off.load() + Int(101),Int(24)) == Extract(zb.load(), Int(0), Int(24))),
                    Fee.store(Btoi(Extract(Txn.application_args[1], off.load() + Int(125),Int(8)))),  # uint256
                    MagicAssert(Fee.load() <= Amount.load()),

                    # Remove the fee
                    Amount.store(Amount.load() - Fee.load()),
                ])
            ),

            If(OriginChain.load() == Int(8),
               Seq([
                   asset.store(Btoi(Extract(Origin.load(), Int(24), Int(8)))),
                   MagicAssert(Txn.accounts[3] == get_sig_address(asset.load(), Bytes("native"))),
                   # Now, the horrible part... we have to scale the amount back out to compensate for the "dedusting" 
                   # when this was sent...

                   If(asset.load() == Int(0),
                      Seq([
                          InnerTxnBuilder.Begin(),
                          InnerTxnBuilder.SetFields(
                              {
                                  TxnField.sender: Txn.accounts[3],
                                  TxnField.type_enum: TxnType.Payment,
                                  TxnField.receiver: Destination.load(),
                                  TxnField.amount: Amount.load(),
                                  TxnField.fee: Int(0),
                              }
                          ),
                          If(Fee.load() > Int(0), Seq([
                                  InnerTxnBuilder.Next(),
                                  InnerTxnBuilder.SetFields(
                                      {
                                          TxnField.sender: Txn.accounts[3],
                                          TxnField.type_enum: TxnType.Payment,
                                          TxnField.receiver: Txn.sender(),
                                          TxnField.amount: Fee.load(),
                                          TxnField.fee: Int(0),
                                      }
                                  ),
                          ])),
                          InnerTxnBuilder.Submit(),

                          Approve()
                      ]),            # End of special case for algo
                      Seq([          # Start of handling code for algorand tokens
                          factor.store(getFactor(Btoi(extract_decimal(asset.load())))),
                          If(factor.load() != Int(1),
                             Seq([
                                 Amount.store(Amount.load() * factor.load()),
                                 Fee.store(Fee.load() * factor.load())
                             ])
                          ),       # If(factor.load() != Int(1),
                      ])           # End of handling code for algorand tokens
                   ),              # If(asset.load() == Int(0),
               ]),                 # If(OriginChain.load() == Int(8),

               # OriginChain.load() != Int(8),
               Seq([
                   # Lets see if we've seen this asset before
                   asset.store(Btoi(blob.read(Int(3), Int(0), Int(8)))),
                   MagicAssert(And(
                       asset.load() != Int(0),
                       Txn.accounts[3] == get_sig_address(OriginChain.load(), Origin.load())
                     )
                   ),
               ])  # OriginChain.load() != Int(8),
            ),  #  If(OriginChain.load() == Int(8)

            # Actually send the coins...
#            Log(Bytes("Main")),
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.sender: Txn.accounts[3],
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: asset.load(),
                    TxnField.asset_amount: Amount.load(),
                    TxnField.asset_receiver: Destination.load(),
                    TxnField.fee: Int(0),
                }
            ),

            If(Fee.load() > Int(0), Seq([
#                    Log(Bytes("Fees")),
                    InnerTxnBuilder.Next(),
                    InnerTxnBuilder.SetFields(
                        {
                            TxnField.sender: Txn.accounts[3],
                            TxnField.type_enum: TxnType.AssetTransfer,
                            TxnField.xfer_asset: asset.load(),
                            TxnField.asset_amount: Fee.load(),
                            TxnField.asset_receiver: Txn.sender(),
                            TxnField.fee: Int(0),
                        }
                    ),
            ])),
            InnerTxnBuilder.Submit(),

            Approve()
        ])

    METHOD = Txn.application_args[0]

    on_delete = Seq([Reject()])

    @Subroutine(TealType.bytes)
    def auth_addr(id) -> Expr:
        maybe = AccountParam.authAddr(id)
        return Seq(maybe, If(maybe.hasValue(), maybe.value(), Bytes("")))

    @Subroutine(TealType.bytes)
    def extract_name(id) -> Expr:
        maybe = AssetParam.name(id)
        return Seq(maybe, If(maybe.hasValue(), maybe.value(), Bytes("")))

    @Subroutine(TealType.bytes)
    def extract_creator(id) -> Expr:
        maybe = AssetParam.creator(id)
        return Seq(maybe, If(maybe.hasValue(), maybe.value(), Bytes("")))

    @Subroutine(TealType.bytes)
    def extract_unit_name(id) -> Expr:
        maybe = AssetParam.unitName(id)
        return Seq(maybe, If(maybe.hasValue(), maybe.value(), Bytes("")))

    @Subroutine(TealType.bytes)
    def extract_decimal(id) -> Expr:
        maybe = AssetParam.decimals(id)
        return Seq(maybe, If(maybe.hasValue(), Extract(Itob(maybe.value()), Int(7), Int(1)), Bytes("base16", "00")))

    def sendTransfer():
        aid = ScratchVar()
        amount = ScratchVar()
        d = ScratchVar()
        p = ScratchVar()
        asset = ScratchVar()
        aaddr = ScratchVar()
        Address = ScratchVar()
        FromChain = ScratchVar()
        zb = ScratchVar()
        factor = ScratchVar()
        fee = ScratchVar()

        return Seq([
            mfee.store(getMessageFee()),

            zb.store(BytesZero(Int(32))),

            aid.store(Btoi(Txn.application_args[1])),

            # what should we pass as a fee...
            fee.store(Btoi(Txn.application_args[5])),

            checkFeePmt(Int(2)),

            tidx.store(Txn.group_index() - Int(1)),

            If(aid.load() == Int(0),
               Seq([
                   MagicAssert(And(
                       # The previous txn is the asset transfer itself
                       Gtxn[tidx.load()].type_enum() == TxnType.Payment,
                       Gtxn[tidx.load()].sender() == Txn.sender(),
                       Gtxn[tidx.load()].receiver() == Txn.accounts[2],
                   )),
                   assert_common_checks(Gtxn[tidx.load()]),

                   amount.store(Gtxn[tidx.load()].amount()),

                   # fee cannot exceed amount
                   MagicAssert(fee.load() <= amount.load()),
               ]),
               Seq([
                   MagicAssert(And(
                       # The previous txn is the asset transfer itself
                       Gtxn[tidx.load()].type_enum() == TxnType.AssetTransfer,
                       Gtxn[tidx.load()].sender() == Txn.sender(),
                       Gtxn[tidx.load()].xfer_asset() == aid.load(),
                       Gtxn[tidx.load()].asset_receiver() == Txn.accounts[2],
                   )),
                   assert_common_checks(Gtxn[tidx.load()]),

                   amount.store(Gtxn[tidx.load()].asset_amount()),

                   #  fee cannot exceed amount
                   MagicAssert(fee.load() <= amount.load()),

                   factor.store(getFactor(Btoi(extract_decimal(aid.load())))),

                   If(factor.load() != Int(1),
                      Seq([
                          amount.store(amount.load() / factor.load()),
                          fee.store(fee.load() / factor.load()),
                      ])
                    ),       # If(factor.load() != Int(1),
               ]),
            ),

            # If it is nothing but dust lets just abort the whole transaction and save 
            MagicAssert(And(amount.load() > Int(0), fee.load() >= Int(0))),

            If(aid.load() != Int(0),
               aaddr.store(auth_addr(extract_creator(aid.load()))),
               aaddr.store(Bytes(""))),
            
            # Is the authorizing signature of the creator of the asset the address of the token_bridge app itself?
            If(aaddr.load() == Global.current_application_address(),
               Seq([
                   asset.store(blob.read(Int(2), Int(0), Int(8))),
                   # This the correct asset?
                   MagicAssert(Txn.application_args[1] == asset.load()),

                   # Pull the address and chain out of the original vaa
                   Address.store(blob.read(Int(2), Int(60), Int(92))),
                   FromChain.store(blob.read(Int(2), Int(92), Int(94))),

                   # This the correct page given the chain and the address
                   MagicAssert(Txn.accounts[2] == get_sig_address(Btoi(FromChain.load()), Address.load())),
               ]),
               Seq([
                   MagicAssert(Txn.accounts[2] == get_sig_address(aid.load(), Bytes("native"))),
                   FromChain.store(Bytes("base16", "0008")),
                   Address.store(Txn.application_args[1]),
               ])
            ),

            # Correct address len?
            MagicAssert(And(
                Len(Address.load()) <= Int(32),
                Len(FromChain.load()) == Int(2),
                Len(Txn.application_args[3]) <= Int(32),
                Txn.application_args.length() <= Int(7)
            )),

            p.store(Concat(
                If(Txn.application_args.length() == Int(7),
                   Bytes("base16", "03"),
                   Bytes("base16", "01")),
                Extract(zb.load(), Int(0), Int(24)),
                Itob(amount.load()),  # 8 bytes
                Extract(zb.load(), Int(0), Int(32) - Len(Address.load())),
                Address.load(),
                FromChain.load(),
                Extract(zb.load(), Int(0), Int(32) - Len(Txn.application_args[3])),
                Txn.application_args[3],
                Extract(Txn.application_args[4], Int(6), Int(2)),
                If(Txn.application_args.length() == Int(7), Concat(Txn.sender(), Txn.application_args[6]), Concat(Extract(zb.load(), Int(0), Int(24)), Itob(fee.load())))
            )),

            # This one magic line should protect us from overruns/underruns and trickery..
            If(Txn.application_args.length() == Int(7), 
               MagicAssert(Len(p.load()) == Int(133) + Len(Txn.application_args[6])),
               MagicAssert(Len(p.load()) == Int(133))),

            InnerTxnBuilder.Begin(),
            sendMfee(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.ApplicationCall,
                    TxnField.application_id: App.globalGet(Bytes("coreid")),
                    TxnField.application_args: [Bytes("publishMessage"), p.load(), Itob(Int(0))],
                    TxnField.accounts: [Txn.accounts[1]],
                    TxnField.note: Bytes("publishMessage"),
                    TxnField.fee: Int(0),
                }
            ),
            InnerTxnBuilder.Submit(),

            Approve()
        ])

    def do_optin():
        return Seq([
            MagicAssert(Txn.accounts[1] == get_sig_address(Btoi(Txn.application_args[1]), Bytes("native"))),
            assert_common_checks(Txn),

            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.sender: Txn.accounts[1],
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: Btoi(Txn.application_args[1]),
                    TxnField.asset_amount: Int(0),
                    TxnField.asset_receiver: Txn.accounts[1],
                    TxnField.fee: Int(0),
                }
            ),
            InnerTxnBuilder.Submit(),

            Approve()
        ])

    # This is for attesting
    def attestToken():
        asset = ScratchVar()
        p = ScratchVar()
        zb = ScratchVar()
        d = ScratchVar()
        uname = ScratchVar()
        name = ScratchVar()
        aid = ScratchVar()

        Address = ScratchVar()
        FromChain = ScratchVar()

        return Seq([
            mfee.store(getMessageFee()),

            checkFeePmt(Int(1)),

            aid.store(Btoi(Txn.application_args[1])),
            # Is the authorizing signature of the creator of the asset the address of the token_bridge app itself?
            If(If(aid.load() != Int(0), auth_addr(extract_creator(aid.load())) == Global.current_application_address(), Int(0)),
               Seq([
                   # Cannot attest a wormhole wrapped token
                   Reject()
               ]),
               Seq([
                   MagicAssert(Txn.accounts[2] == get_sig_address(aid.load(), Bytes("native"))),

                   zb.store(BytesZero(Int(32))),
                   
                   aid.store(Btoi(Txn.application_args[1])),

                   If(aid.load() == Int(0),
                      Seq([
                          d.store(Bytes("base16", "06")),
                          uname.store(Bytes("ALGO")),
                          name.store(Bytes("ALGO"))
                      ]),
                      Seq([
                          d.store(extract_decimal(aid.load())),
                          If(Btoi(d.load()) > Int(8), d.store(Bytes("base16", "08"))),
                          uname.store(extract_unit_name(aid.load())),
                          name.store(extract_name(aid.load())),
                      ])
                    ),

                   p.store(
                       Concat(
                           #PayloadID uint8 = 2
                           Bytes("base16", "02"),
                           #TokenAddress [32]uint8
                           Extract(zb.load(),Int(0), Int(24)),
                           Itob(aid.load()),
                           #TokenChain uint16
                           Bytes("base16", "0008"),
                           #Decimals uint8
                           d.load(),
                           #Symbol [32]uint8
                           uname.load(),
                           Extract(zb.load(), Int(0), Int(32) - Len(uname.load())),
                           #Name [32]uint8
                           name.load(),
                           Extract(zb.load(), Int(0), Int(32) - Len(name.load())),
                       )
                   ),
               ])
               ),

            MagicAssert(Len(p.load()) == Int(100)),

            InnerTxnBuilder.Begin(),
            sendMfee(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.ApplicationCall,
                    TxnField.application_id: App.globalGet(Bytes("coreid")),
                    TxnField.application_args: [Bytes("publishMessage"), p.load(), Itob(Int(0))],
                    TxnField.accounts: [Txn.accounts[1]],
                    TxnField.note: Bytes("publishMessage"),
                    TxnField.fee: Int(0),
                }
            ),
            InnerTxnBuilder.Submit(),

            Approve()
        ])

    @Subroutine(TealType.none)
    def checkForDuplicate():
        off = ScratchVar()
        emitter = ScratchVar()
        sequence = ScratchVar()
        b = ScratchVar()
        byte_offset = ScratchVar()

        return Seq(
            # VM only is version 1
            MagicAssert(Btoi(Extract(Txn.application_args[1], Int(0), Int(1))) == Int(1)),

            off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(14)), # The offset of the emitter

            # emitter is chain/contract-address
            emitter.store(Extract(Txn.application_args[1], off.load(), Int(34))),
            sequence.store(Btoi(Extract(Txn.application_args[1], off.load() + Int(34), Int(8)))),

            # They passed us the correct account?  In this case, byte_offset points at the whole block
            byte_offset.store(sequence.load() / Int(max_bits)),
            MagicAssert(Txn.accounts[1] == get_sig_address(byte_offset.load(), emitter.load())),

            # Now, lets go grab the raw byte
            byte_offset.store((sequence.load() / Int(8)) % Int(max_bytes)),
            b.store(blob.get_byte(Int(1), byte_offset.load())),

            # I would hope we've never seen this packet before...   throw an exception if we have
            MagicAssert(GetBit(b.load(), sequence.load() % Int(8)) == Int(0)),

            # Lets mark this bit so that we never see it again
            blob.set_byte(Int(1), byte_offset.load(), SetBit(b.load(), sequence.load() % Int(8), Int(1)))
        )

    def nop():
        return Seq([Approve()])

    router = Cond(
        [METHOD == Bytes("nop"), nop()],
        [METHOD == Bytes("receiveAttest"), receiveAttest()],
        [METHOD == Bytes("attestToken"), attestToken()],
        [METHOD == Bytes("completeTransfer"), completeTransfer()],
        [METHOD == Bytes("sendTransfer"), sendTransfer()],
        [METHOD == Bytes("optin"), do_optin()],
        [METHOD == Bytes("governance"), governance()]
    )

    on_create = Seq( [
        App.globalPut(Bytes("coreid"), Btoi(Txn.application_args[0])),
        App.globalPut(Bytes("coreAddr"), Txn.application_args[1]),
        App.globalPut(Bytes("validUpdateApproveHash"), Bytes("")),
        Return(Int(1))
    ])

    def getOnUpdate():
        return Seq( [
            MagicAssert(Sha512_256(Concat(Bytes("Program"), Txn.approval_program())) == App.globalGet(Bytes("validUpdateApproveHash"))),
            MagicAssert(And(Len(Txn.clear_state_program()) == Int(4), Extract(Txn.clear_state_program(), Int(1), Int(3)) == Bytes("base16", "810143"))),
            Return(Int(1))
        ] )

    on_update = getOnUpdate()

    @Subroutine(TealType.uint64)
    def optin():
        # Alias for readability
        algo_seed = Gtxn[Txn.group_index() - Int(1)]
        optin = Txn

        well_formed_optin = And(
            # Check that we're paying it
            algo_seed.type_enum() == TxnType.Payment,
            algo_seed.amount() == Int(seed_amt),
            algo_seed.receiver() == optin.sender(),

            # Check that its an opt in to us
            optin.type_enum() == TxnType.ApplicationCall,
            optin.on_completion() == OnComplete.OptIn,
            optin.application_id() == Global.current_application_id(),
            optin.rekey_to() == Global.current_application_address(),
            optin.application_args.length() == Int(0)
        )

        return Seq(
            # Make sure its a valid optin
            MagicAssert(well_formed_optin),
            # Init by writing to the full space available for the sender (Int(0))
            blob.zero(Int(0)),
            # we gucci
            Int(1)
        )

    on_optin = Seq( [
        Return(optin())
    ])

    return Cond(
        [Txn.application_id() == Int(0), on_create],
        [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
        [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
        [Txn.on_completion() == OnComplete.OptIn, on_optin],
        [Txn.on_completion() == OnComplete.NoOp, router]
    )

def get_token_bridge(genTeal, approve_name, clear_name, client: AlgodClient, seed_amt: int, tmpl_sig: TmplSig, devMode: bool) -> Tuple[bytes, bytes]:
    if not devMode:
        client = AlgodClient("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "https://testnet-api.algonode.cloud")
    APPROVAL_PROGRAM = fullyCompileContract(genTeal, client, approve_token_bridge(seed_amt, tmpl_sig, devMode), approve_name, devMode)
    CLEAR_STATE_PROGRAM = fullyCompileContract(genTeal, client, clear_token_bridge(), clear_name, devMode)

    return APPROVAL_PROGRAM, CLEAR_STATE_PROGRAM

'''
'''--- lib/wormhole/algorand/vaa_verify.py ---
#!/usr/bin/python3
"""
================================================================================================

The VAA Signature Verify Stateless Program

Copyright 2022 Wormhole Project Contributors

Licensed under the Apache License, Version 2.0 (the "License");

you may not use this file except in compliance with the License.

You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

------------------------------------------------------------------------------------------------

This program verifies a subset of the signatures in a VAA against the guardian set. This
program works in tandem with the VAA Processor stateful program.

The difference between this version and the Randlabs version is I removed most of the asserts
since we are going to have to completely validate the arguments again in the
TokenBridge contract.

We also cannot retroactively see/verify what arguments were passed into this
function unless all the arguments are in the Txn.application_args so
everything has to get moved out of the lsig args and into the txn_args

================================================================================================

"""
from pyteal.ast import *
from pyteal.types import *
from pyteal.compiler import *
from pyteal.ir import *
from globals import *
from inlineasm import *

import sys

SLOTID_RECOVERED_PK_X = 240
SLOTID_RECOVERED_PK_Y = 241

@Subroutine(TealType.uint64)
def sig_check(signatures, dhash, keys):
    """
    Verifies some signatures of a VAA. Due to computation budget limitations,
    this can't verify all signatures in one go. Instead, it just makes sure that
    whatever signatures it's given correspond to the given keys.

    In addition, none of the arguments are validated here beyond the fact that
    the signatures are valid given the keys and the message hash. In particular,
    the message hash is also not validated here. Thus, the proper way to use
    this function is by calling it (by the client) before the token bridge
    program.  Then the token bridge program verify each input + that the right
    program was called. If it failed to verify any of these, then signature
    verification could be bypaseed.
    """
    si = ScratchVar(TealType.uint64)  # signature index (zero-based)
    ki = ScratchVar(TealType.uint64)  # key index
    slen = ScratchVar(TealType.uint64)  # signature length
    rec_pk_x = ScratchVar(TealType.bytes, SLOTID_RECOVERED_PK_X)
    rec_pk_y = ScratchVar(TealType.bytes, SLOTID_RECOVERED_PK_Y)

    return Seq(
        [
            rec_pk_x.store(Bytes("")),
            rec_pk_y.store(Bytes("")),
            slen.store(Len(signatures)),
            For(Seq([
                si.store(Int(0)),
                ki.store(Int(0))
            ]),
                si.load() < slen.load(),
                Seq([
                    si.store(si.load() + Int(66)),
                    ki.store(ki.load() + Int(20))
                ])).Do(
                    Seq([
                        InlineAssembly(
                            "ecdsa_pk_recover Secp256k1",
                            dhash,
                            Btoi(Extract(signatures, si.load() + Int(65), Int(1))),
                            Extract(signatures, si.load() + Int(1), Int(32)),       # R
                            Extract(signatures, si.load() + Int(33), Int(32)),      # S
                            type=TealType.none),

                        # returned values in stack, pass to scratch-vars

                        InlineAssembly("store " + str(SLOTID_RECOVERED_PK_Y)),
                        InlineAssembly("store " + str(SLOTID_RECOVERED_PK_X)),

                        # Generate Ethereum-type public key, compare with guardian key.

                        Assert(Extract(keys, ki.load(), Int(20)) == Substring(Keccak256(Concat(rec_pk_x.load(), rec_pk_y.load())), Int(12), Int(32)))
                    ])
            ),
            Return(Int(1))
        ]
    )

def vaa_verify_program():
    signatures = Txn.application_args[1]
    keys = Txn.application_args[2]
    dhash = Txn.application_args[3]

    return Seq([
        Assert(Txn.rekey_to() == Global.zero_address()),
        Assert(Txn.fee() == Int(0)),
        Assert(Txn.type_enum() == TxnType.ApplicationCall),
        Assert(sig_check(signatures, dhash, keys)),
        Approve()]
    )

def get_vaa_verify():
    teal = compileTeal(vaa_verify_program(), mode=Mode.Signature, version=6)

    with open("teal/vaa_verify.teal", "w") as f:
        f.write(teal)

    return teal

'''
'''--- lib/wormhole/algorand/wormhole_core.py ---
from time import time, sleep
from typing import List, Tuple, Dict, Any, Optional, Union
from base64 import b64decode
import base64
import random
import hashlib
import uuid
import sys
import json
import uvarint

from local_blob import LocalBlob
from TmplSig import TmplSig

from algosdk.v2client.algod import AlgodClient
from algosdk.kmd import KMDClient
from algosdk import account, mnemonic
from algosdk.encoding import decode_address
from algosdk.future import transaction
from pyteal import compileTeal, Mode, Expr
from pyteal import *
from algosdk.logic import get_application_address

from algosdk.future.transaction import LogicSigAccount
from inspect import currentframe

import pprint

max_keys = 15
max_bytes_per_key = 127
bits_per_byte = 8

bits_per_key = max_bytes_per_key * bits_per_byte
max_bytes = max_bytes_per_key * max_keys
max_bits = bits_per_byte * max_bytes

def fullyCompileContract(genTeal, client: AlgodClient, contract: Expr, name, devmode) -> bytes:
    if genTeal:
        if devmode:
            teal = compileTeal(contract, mode=Mode.Application, version=6, assembleConstants=True)
        else:
            teal = compileTeal(contract, mode=Mode.Application, version=6, assembleConstants=True, optimize=OptimizeOptions(scratch_slots=True))

        with open(name, "w") as f:
            print("Writing " + name)
            f.write(teal)
    else:
        with open(name, "r") as f:
            print("Reading " + name)
            teal = f.read()

    response = client.compile(teal)

    with open(name + ".bin", "w") as fout:
        fout.write(response["result"])
    with open(name + ".hash", "w") as fout:
        fout.write(decode_address(response["hash"]).hex())

    return response

def getCoreContracts(   genTeal, approve_name, clear_name,
                        client: AlgodClient,
                        seed_amt: int,
                        tmpl_sig: TmplSig,
                        devMode: bool
                        ) -> Tuple[bytes, bytes]:

    def vaa_processor_program(seed_amt: int, tmpl_sig: TmplSig):
        blob = LocalBlob()

        def MagicAssert(a) -> Expr:
            if devMode:
                return Assert(And(a, Int(currentframe().f_back.f_lineno)))
            else:
                return Assert(a)

        @Subroutine(TealType.bytes)
        def encode_uvarint(val: Expr, b: Expr):
            buff = ScratchVar()
            return Seq(
                buff.store(b),
                Concat(
                    buff.load(),
                    If(
                        val >= Int(128),
                        encode_uvarint(
                            val >> Int(7),
                            Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),
                        ),
                        Extract(Itob(val & Int(255)), Int(7), Int(1)),
                    ),
                ),
            )

        @Subroutine(TealType.bytes)
        def get_sig_address(acct_seq_start: Expr, emitter: Expr):
            # We could iterate over N items and encode them for a more general interface
            # but we inline them directly here
    
            return Sha512_256(
                Concat(
                Bytes("Program"),
                # ADDR_IDX aka sequence start
                tmpl_sig.get_bytecode_chunk(0),
                encode_uvarint(acct_seq_start, Bytes("")),

                # EMMITTER_ID
                tmpl_sig.get_bytecode_chunk(1),
                encode_uvarint(Len(emitter), Bytes("")),
                emitter,

                # APP_ID
                tmpl_sig.get_bytecode_chunk(2),
                encode_uvarint(Global.current_application_id(), Bytes("")),

                # TMPL_APP_ADDRESS
                tmpl_sig.get_bytecode_chunk(3),
                encode_uvarint(Len(Global.current_application_address()), Bytes("")),
                Global.current_application_address(),

                tmpl_sig.get_bytecode_chunk(4),
                )
            )
    
        @Subroutine(TealType.uint64)
        def optin():
            # Alias for readability
            algo_seed = Gtxn[0]
            optin = Gtxn[1]
    
            well_formed_optin = And(
                # Check that we're paying it
                algo_seed.type_enum() == TxnType.Payment,
                algo_seed.amount() == Int(seed_amt),
                algo_seed.receiver() == optin.sender(),
                # Check that its an opt in to us
                optin.type_enum() == TxnType.ApplicationCall,
                optin.on_completion() == OnComplete.OptIn,
                # Not strictly necessary since we wouldn't be seeing this unless it was us, but...
                optin.application_id() == Global.current_application_id(),
                optin.rekey_to() == Global.current_application_address(),
                optin.application_args.length() == Int(0)
            )
    
            return Seq(
                # Make sure its a valid optin
                MagicAssert(well_formed_optin),
                # Init by writing to the full space available for the sender (Int(0))
                blob.zero(Int(0)),
                # we gucci
                Int(1)
            )
    
        def nop():
            return Seq([Approve()])

        def publishMessage():
            seq = ScratchVar()
            fee = ScratchVar()

            pmt = Gtxn[Txn.group_index() - Int(1)]

            return Seq([
                # Lets see if we were handed the correct account to store the sequence number in
                MagicAssert(Txn.accounts[1] == get_sig_address(Int(0), Txn.sender())),

                fee.store(App.globalGet(Bytes("MessageFee"))),
                If(fee.load() > Int(0), Seq([
                        MagicAssert(And(
                            pmt.type_enum() == TxnType.Payment,
                            pmt.amount() >= fee.load(),
                            pmt.receiver() == Global.current_application_address(),
                            pmt.rekey_to() == Global.zero_address()
                        )),
                ])),

                # emitter sequence number
                seq.store(Itob(Btoi(blob.read(Int(1), Int(0), Int(8))) + Int(1))),
                Pop(blob.write(Int(1), Int(0), seq.load())),

                # Log it so that we can look for this on the guardian network
                Log(seq.load()),

                blob.meta(Int(1), Bytes("publishMessage")),
                
                Approve()
            ])

        def hdlGovernance(isBoot: Expr):
            off = ScratchVar()
            a = ScratchVar()
            emitter = ScratchVar()
            dest = ScratchVar()
            fee = ScratchVar()
            idx = ScratchVar()
            set = ScratchVar()
            len = ScratchVar()
            v = ScratchVar()
            tchain = ScratchVar()

            return Seq([

                # All governance must be done with the most recent guardian set
                set.store(App.globalGet(Bytes("currentGuardianSetIndex"))),
                If(set.load() != Int(0), Seq([
                        idx.store(Extract(Txn.application_args[1], Int(1), Int(4))),
                        MagicAssert(Btoi(idx.load()) == set.load()),
                ])),

                # The offset of the chain
                off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(14)), 
                # Correct source chain? 
                MagicAssert(Extract(Txn.application_args[1], off.load(), Int(2)) == Bytes("base16", "0001")),
                # Correct emitter?
                MagicAssert(Extract(Txn.application_args[1], off.load() + Int(2), Int(32)) == Bytes("base16", "0000000000000000000000000000000000000000000000000000000000000004")),
                # Get us to the payload
                off.store(off.load() + Int(43)),
                # Is this a governance message?
                MagicAssert(Extract(Txn.application_args[1], off.load(), Int(32)) == Bytes("base16", "00000000000000000000000000000000000000000000000000000000436f7265")),
                off.store(off.load() + Int(32)),
                # What is the target of this governance message?
                tchain.store(Extract(Txn.application_args[1], off.load() + Int(1), Int(2))),
                # Needs to point at us or to all chains

                a.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(1)))),
                Cond( 
                    [a.load() == Int(1), Seq([
                        # ContractUpgrade is a VAA that instructs an implementation on a specific chain to upgrade itself
                        # 
                        # In the case of Algorand, it contains the hash of the program that we are allowed to upgrade ourselves to.  We would then run the upgrade program itself
                        # to perform the actual upgrade
                        MagicAssert(tchain.load() == Bytes("base16", "0008")),
                        
                        off.store(off.load() + Int(3)),

                        App.globalPut(Bytes("validUpdateApproveHash"), Extract(Txn.application_args[1], off.load(), Int(32)))
                    ])],
                    [a.load() == Int(2), Seq([
                        # We are updating the guardian set

                        # This should point at all chains

                        MagicAssert(Or(tchain.load() == Bytes("base16", "0008"), tchain.load() == Bytes("base16", "0000"))),

                        # move off to point at the NewGuardianSetIndex and grab it
                        off.store(off.load() + Int(3)),
                        v.store(Extract(Txn.application_args[1], off.load(), Int(4))),
                        idx.store(Btoi(v.load())),

                        # Lets see if the user handed us the correct memory... no hacky hacky
                        MagicAssert(Txn.accounts[3] == get_sig_address(idx.load(), Bytes("guardian"))), 

                        # Make sure it is different and we can only walk forward
                        If(isBoot == Int(0), Seq(
                                MagicAssert(Txn.accounts[3] != Txn.accounts[2]),
                                MagicAssert(idx.load() == (set.load() + Int(1)))
                        )),

                        # Write this away till the next time
                        App.globalPut(Bytes("currentGuardianSetIndex"), idx.load()),

                        # Write everything out to the auxilliary storage
                        off.store(off.load() + Int(4)),
                        len.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(1)))),

                        # Lets not let us get bricked by somebody submitting a stupid guardian set...
                        MagicAssert(len.load() > Int(0)),  

                        Pop(blob.write(Int(3), Int(0), Extract(Txn.application_args[1], off.load(), Int(1) + (Int(20) * len.load())))),

                        If(Txn.accounts[3] != Txn.accounts[2],
                           Pop(blob.write(Int(2), Int(1000), Itob(Global.latest_timestamp() + Int(86400))))),
                        blob.meta(Int(3), Bytes("guardian"))
                    ])],
                    [a.load() == Int(3), Seq([
                        off.store(off.load() + Int(1)),
                        MagicAssert(tchain.load() == Bytes("base16", "0008")),
                        off.store(off.load() + Int(2) + Int(24)),
                        fee.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(8)))),
                        App.globalPut(Bytes("MessageFee"), fee.load()),
                    ])],
                    [a.load() == Int(4), Seq([
                        off.store(off.load() + Int(1)),
                        MagicAssert(tchain.load() == Bytes("base16", "0008")),
                        off.store(off.load() + Int(26)),
                        fee.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(8)))),
                        off.store(off.load() + Int(8)),
                        dest.store(Extract(Txn.application_args[1], off.load(), Int(32))),

                        InnerTxnBuilder.Begin(),
                        InnerTxnBuilder.SetFields(
                              {
                                  TxnField.type_enum: TxnType.Payment,
                                  TxnField.receiver: dest.load(),
                                  TxnField.amount: fee.load(),
                                  TxnField.fee: Int(0),
                              }
                        ),
                        InnerTxnBuilder.Submit(),
                    ])]
               ),
                Approve()
            ])

        def init():
            return Seq([
                # You better lose yourself in the music, the moment
                App.globalPut(Bytes("vphash"), Txn.application_args[2]),

                # You own it, you better never let it go
                MagicAssert(Txn.sender() == Global.creator_address()),

                # You only get one shot, do not miss your chance to blow
                MagicAssert(App.globalGet(Bytes("booted")) == Int(0)),
                App.globalPut(Bytes("booted"), Bytes("true")),

                # This opportunity comes once in a lifetime
                checkForDuplicate(),

                # You can do anything you set your mind to...
                hdlGovernance(Int(1))
            ])

        def verifySigs():
            return Return (Txn.sender() == STATELESS_LOGIC_HASH)

        @Subroutine(TealType.none)
        def checkForDuplicate():
            off = ScratchVar()
            emitter = ScratchVar()
            sequence = ScratchVar()
            b = ScratchVar()
            byte_offset = ScratchVar()

            return Seq(
                # VM only is version 1
                MagicAssert(Btoi(Extract(Txn.application_args[1], Int(0), Int(1))) == Int(1)),

                off.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1))) * Int(66) + Int(14)), # The offset of the emitter

                # emitter is chain/contract-address
                emitter.store(Extract(Txn.application_args[1], off.load(), Int(34))),
                sequence.store(Btoi(Extract(Txn.application_args[1], off.load() + Int(34), Int(8)))),

                # They passed us the correct account?  In this case, byte_offset points at the whole block
                byte_offset.store(sequence.load() / Int(max_bits)),
                MagicAssert(Txn.accounts[1] == get_sig_address(byte_offset.load(), emitter.load())),

                # Now, lets go grab the raw byte
                byte_offset.store((sequence.load() / Int(8)) % Int(max_bytes)),
                b.store(blob.get_byte(Int(1), byte_offset.load())),

                # I would hope we've never seen this packet before...   throw an exception if we have
                MagicAssert(GetBit(b.load(), sequence.load() % Int(8)) == Int(0)),

                # Lets mark this bit so that we never see it again
                blob.set_byte(Int(1), byte_offset.load(), SetBit(b.load(), sequence.load() % Int(8), Int(1))),

                blob.meta(Int(1), Bytes("duplicate"))
            )

        STATELESS_LOGIC_HASH = App.globalGet(Bytes("vphash"))

        def verifyVAA():
            i = ScratchVar()
            a = ScratchVar()
            total_guardians = ScratchVar()
            guardian_keys = ScratchVar()
            num_sigs = ScratchVar()
            off = ScratchVar()
            digest = ScratchVar()
            hits = ScratchVar()
            s = ScratchVar()
            eoff = ScratchVar()
            guardian = ScratchVar()

            return Seq([
                # We have a guardian set?  We have OUR guardian set?
                MagicAssert(Txn.accounts[2] == get_sig_address(Btoi(Extract(Txn.application_args[1], Int(1), Int(4))), Bytes("guardian"))),
                blob.checkMeta(Int(2), Bytes("guardian")),
                # Lets grab the total keyset
                total_guardians.store(blob.get_byte(Int(2), Int(0))),
                MagicAssert(total_guardians.load() > Int(0)),

                guardian_keys.store(blob.read(Int(2), Int(1), Int(1) + Int(20) * total_guardians.load())),

                # I wonder if this is an expired guardian set
                s.store(Btoi(blob.read(Int(2), Int(1000), Int(1008)))),
                If(s.load() != Int(0),
                   MagicAssert(Global.latest_timestamp() < s.load())),

                hits.store(Bytes("base16", "0x00000000")),

                # How many signatures are in this vaa?
                num_sigs.store(Btoi(Extract(Txn.application_args[1], Int(5), Int(1)))),

                # Lets create a digest of THIS vaa...
                off.store(Int(6) + (num_sigs.load() * Int(66))),
                digest.store(Keccak256(Keccak256(Extract(Txn.application_args[1], off.load(), Len(Txn.application_args[1]) - off.load())))),

                # We have enough signatures?
                MagicAssert(And(
                    total_guardians.load() > Int(0),
                    num_sigs.load() <= total_guardians.load(),
                    num_sigs.load() > ((total_guardians.load() * Int(2)) / Int(3)),
                    )),

                # Point it at the start of the signatures in the VAA
                off.store(Int(6)),

                # We'll check that the preceding transactions properly verify
                # all of the signatures. Due to size limitations, there will be
                # multiple 'verifySigs' calls to achieve this. First we walk
                # backwards from the current instruction to find all the
                # 'verifySigs' calls. We do it this way because it's possible
                # that the VAA transactions are composed with some other
                # contracts calls, so we do not rely in absolute transaction
                # indices.
                #
                # | | ...            |
                # | | something else |
                # | |----------------|
                # | | verifySigs     |
                # | | verifySigs     |
                # | | verifySigs     |
                # | | verifyVAA      | <- we are here now
                # | |----------------|
                # v | ...            |

                MagicAssert(Txn.group_index() > Int(0)),
                # the first 'verifySigs' tx is the one before us
                i.store(Txn.group_index() - Int(1)),
                MagicAssert(Gtxn[i.load()].application_args.length() > Int(0)),
                a.store(Gtxn[i.load()].application_args[0]),

                # Go back until we hit 'something else' or run out of
                # transactions (we allow nops too)
                While (And(i.load() > Int(0), Or(a.load() == Bytes("verifySigs"), a.load() == Bytes("nop")))).Do(Seq([
                        i.store(i.load() - Int(1)),
                        If (Gtxn[i.load()].application_args.length() > Int(0),
                            a.store(Gtxn[i.load()].application_args[0]),
                            Seq([
                                a.store(Bytes("")),
                                Break()
                            ]))
                ])),

                If(And(a.load() != Bytes("verifySigs"), a.load() != Bytes("nop")), i.store(i.load() + Int(1))),

                # Now look through the whole group of 'verifySigs'
                While(i.load() <= Txn.group_index()).Do(Seq([
                            MagicAssert(And(
                                Gtxn[i.load()].type_enum() == TxnType.ApplicationCall,
                                Gtxn[i.load()].rekey_to() == Global.zero_address(),
                                Gtxn[i.load()].application_id() == Txn.application_id(),
                                Gtxn[i.load()].accounts[1] == Txn.accounts[1],
                                Gtxn[i.load()].accounts[2] == Txn.accounts[2],
                            )),
                            a.store(Gtxn[i.load()].application_args[0]),
                            Cond(
                                [a.load() == Bytes("verifySigs"), Seq([
                                    # Lets see if they are actually verifying the correct signatures!
                                    
                                    # What signatures did this verifySigs check?
                                    s.store(Gtxn[i.load()].application_args[1]),

                                    # Make sure we bail earlier on incorrect arguments...
                                    MagicAssert(Len(s.load()) > Int(0)),

                                    # Look at the vaa and confirm those were the expected signatures we should have been checking
                                    # at this point in the process
                                    MagicAssert(Extract(Txn.application_args[1], off.load(), Len(s.load())) == s.load()),

                                    # Where is the end pointer...
                                    eoff.store(off.load() + Len(s.load())),

                                    # Now we will reset s and collect the keys
                                    s.store(Bytes("")),

                                    While(off.load() < eoff.load()).Do(Seq( [
                                            # Lets see if we ever reuse the same signature more then once (same guardian over and over)
                                            guardian.store(Btoi(Extract(Txn.application_args[1], off.load(), Int(1)))),
                                            MagicAssert(GetBit(hits.load(), guardian.load()) == Int(0)),
                                            hits.store(SetBit(hits.load(), guardian.load(), Int(1))),

                                            # This extracts out of the keys THIS guardian's public key
                                            s.store(Concat(s.load(), Extract(guardian_keys.load(), guardian.load() * Int(20), Int(20)))),

                                            off.store(off.load() + Int(66))
                                    ])),

                                    MagicAssert(And(
                                        Gtxn[i.load()].application_args[2] == s.load(),      # Does the keyset passed into the verify routines match what it should be?
                                        Gtxn[i.load()].sender() == STATELESS_LOGIC_HASH,     # Was it signed with our code?
                                        Gtxn[i.load()].application_args[3] == digest.load()  # Was it verifying the same vaa?
                                    )),
                                    
                                ])],
                                [a.load() == Bytes("nop"), Seq([])],       # if there is a function call not listed here, it will throw an error
                                [a.load() == Bytes("verifyVAA"), Seq([])],
                                [Int(1) == Int(1), Seq([Reject()])]   # Nothing should get snuck in between...
                            ),
                            i.store(i.load() + Int(1))
                        ])
                ),

                # Did we verify all the signatures?  If the answer is no, something is sus
                MagicAssert(off.load() == Int(6) + (num_sigs.load() * Int(66))),

                Approve(),
            ])

        def governance():
            return Seq([
                checkForDuplicate(), # Verify this is not a duplicate message and then make sure we never see it again

                MagicAssert(And(
                    Gtxn[Txn.group_index() - Int(1)].type_enum() == TxnType.ApplicationCall,
                    Gtxn[Txn.group_index() - Int(1)].application_id() == Txn.application_id(),
                    Gtxn[Txn.group_index() - Int(1)].application_args[0] == Bytes("verifyVAA"),
                    Gtxn[Txn.group_index() - Int(1)].sender() == Txn.sender(),
                    Gtxn[Txn.group_index() - Int(1)].rekey_to() == Global.zero_address(),
                    Gtxn[Txn.group_index() - Int(1)].on_completion() == OnComplete.NoOp,

                    # Lets see if the vaa we are about to process was actually verified by the core
                    Gtxn[Txn.group_index() - Int(1)].application_args[1] == Txn.application_args[1],

                    # What checks should I give myself
                    Gtxn[Txn.group_index()].rekey_to() == Global.zero_address(),
                    Gtxn[Txn.group_index()].sender() == Txn.sender(),

                    # We all opted into the same accounts?
                    Gtxn[Txn.group_index() - Int(1)].accounts[0] == Txn.accounts[0],
                    Gtxn[Txn.group_index() - Int(1)].accounts[1] == Txn.accounts[1],
                    Gtxn[Txn.group_index() - Int(1)].accounts[2] == Txn.accounts[2],
                )),
                    
                hdlGovernance(Int(0)),
                Approve(),
            ])

        METHOD = Txn.application_args[0]

        on_delete = Seq([Reject()])

        router = Cond(
            [METHOD == Bytes("publishMessage"), publishMessage()],
            [METHOD == Bytes("nop"), nop()],
            [METHOD == Bytes("init"), init()],
            [METHOD == Bytes("verifySigs"), verifySigs()],
            [METHOD == Bytes("verifyVAA"), verifyVAA()],
            [METHOD == Bytes("governance"), governance()],
        )

        on_create = Seq( [
            App.globalPut(Bytes("MessageFee"), Int(0)),
            App.globalPut(Bytes("vphash"), Bytes("")),
            App.globalPut(Bytes("currentGuardianSetIndex"), Int(0)),
            App.globalPut(Bytes("validUpdateApproveHash"), Bytes("")),
            Return(Int(1))
        ])

        progHash = ScratchVar()
        progSet = ScratchVar()
        clearHash = ScratchVar()
        clearSet = ScratchVar()

        def getOnUpdate():
            return Seq( [
                MagicAssert(Sha512_256(Concat(Bytes("Program"), Txn.approval_program())) == App.globalGet(Bytes("validUpdateApproveHash"))),
                MagicAssert(And(Len(Txn.clear_state_program()) == Int(4), Extract(Txn.clear_state_program(), Int(1), Int(3)) == Bytes("base16", "810143"))),
                Return(Int(1))
            ] )

        on_update = getOnUpdate()
        
        on_optin = Seq( [
            Return(optin())
        ])

        return Cond(
            [Txn.application_id() == Int(0), on_create],
            [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
            [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
            [Txn.on_completion() == OnComplete.OptIn, on_optin],
            [Txn.on_completion() == OnComplete.NoOp, router]
        )
    
    def clear_state_program():
        return Int(1)

    if not devMode:
        client = AlgodClient("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "https://testnet-api.algonode.cloud")
    APPROVAL_PROGRAM = fullyCompileContract(genTeal, client, vaa_processor_program(seed_amt, tmpl_sig), approve_name, devMode)
    CLEAR_STATE_PROGRAM = fullyCompileContract(genTeal, client, clear_state_program(), clear_name, devMode)

    return APPROVAL_PROGRAM, CLEAR_STATE_PROGRAM

'''
'''--- lib/wormhole/cosmwasm/tools/deploy.js ---
import "dotenv/config";
import { LCDClient, MnemonicKey } from "@terra-money/terra.js";
import {
  MsgInstantiateContract,
  MsgExecuteContract,
  MsgStoreCode,
} from "@terra-money/terra.js";
import { readFileSync, readdirSync } from "fs";
import { Bech32, toHex } from "@cosmjs/encoding";
import { zeroPad } from "ethers/lib/utils.js";

/*
  NOTE: Only append to this array: keeping the ordering is crucial, as the
  contracts must be imported in a deterministic order so their addresses remain
  deterministic.
*/
const artifacts = [
  "wormhole.wasm",
  "token_bridge_terra_2.wasm",
  "cw20_wrapped_2.wasm",
  "cw20_base.wasm",
  "mock_bridge_integration_2.wasm",
  "shutdown_core_bridge_cosmwasm.wasm",
  "shutdown_token_bridge_cosmwasm.wasm",
];

/* Check that the artifact folder contains all the wasm files we expect and nothing else */

const actual_artifacts = readdirSync("../artifacts/").filter((a) =>
  a.endsWith(".wasm")
);

const missing_artifacts = artifacts.filter(
  (a) => !actual_artifacts.includes(a)
);
if (missing_artifacts.length) {
  console.log(
    "Error during terra deployment. The following files are expected to be in the artifacts folder:"
  );
  missing_artifacts.forEach((file) => console.log(`  - ${file}`));
  console.log(
    "Hint: the deploy script needs to run after the contracts have been built."
  );
  console.log(
    "External binary blobs need to be manually added in tools/Dockerfile."
  );
  process.exit(1);
}

const unexpected_artifacts = actual_artifacts.filter(
  (a) => !artifacts.includes(a)
);
if (unexpected_artifacts.length) {
  console.log(
    "Error during terra deployment. The following files are not expected to be in the artifacts folder:"
  );
  unexpected_artifacts.forEach((file) => console.log(`  - ${file}`));
  console.log("Hint: you might need to modify tools/deploy.js");
  process.exit(1);
}

/* Set up terra client & wallet */

const terra = new LCDClient({
  URL: "http://localhost:1317",
  chainID: "localterra",
});

const wallet = terra.wallet(
  new MnemonicKey({
    mnemonic:
      "notice oak worry limit wrap speak medal online prefer cluster roof addict wrist behave treat actual wasp year salad speed social layer crew genius",
  })
);

await wallet.sequence();

/* Deploy artifacts */

const codeIds = {};
for (const file of artifacts) {
  const contract_bytes = readFileSync(`../artifacts/${file}`);
  console.log(`Storing WASM: ${file} (${contract_bytes.length} bytes)`);

  const store_code = new MsgStoreCode(
    wallet.key.accAddress,
    contract_bytes.toString("base64")
  );

  try {
    const tx = await wallet.createAndSignTx({
      msgs: [store_code],
      memo: "",
    });

    const rs = await terra.tx.broadcast(tx);
    const ci = /"code_id","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    codeIds[file] = parseInt(ci);
  } catch (e) {
    console.log(`${e}`);
  }
}

console.log(codeIds);

/* Instantiate contracts.
 *
 * We instantiate the core contracts here (i.e. wormhole itself and the bridge contracts).
 * The wrapped asset contracts don't need to be instantiated here, because those
 * will be instantiated by the on-chain bridge contracts on demand.
 * */

// Governance constants defined by the Wormhole spec.
const govChain = 1;
const govAddress =
  "0000000000000000000000000000000000000000000000000000000000000004";

async function instantiate(contract, inst_msg, label) {
  var address;
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgInstantiateContract(
          wallet.key.accAddress,
          wallet.key.accAddress,
          codeIds[contract],
          inst_msg,
          undefined,
          label
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => {
      address = /"_contract_address","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    });
  console.log(
    `Instantiated ${contract} at ${address} (${convert_terra_address_to_hex(
      address
    )})`
  );
  return address;
}

// Instantiate contracts.  NOTE: Only append at the end, the ordering must be
// deterministic for the addresses to work

const addresses = {};

const init_guardians = JSON.parse(process.env.INIT_SIGNERS);
if (!init_guardians || init_guardians.length === 0) {
  throw "failed to get initial guardians from .env file.";
}

addresses["wormhole.wasm"] = await instantiate(
  "wormhole.wasm",
  {
    gov_chain: govChain,
    gov_address: Buffer.from(govAddress, "hex").toString("base64"),
    guardian_set_expirity: 86400,
    initial_guardian_set: {
      addresses: init_guardians.map((hex) => {
        return {
          bytes: Buffer.from(hex, "hex").toString("base64"),
        };
      }),
      expiration_time: 0,
    },
    chain_id: 18,
    fee_denom: "uluna",
  },
  "wormhole"
);

addresses["token_bridge_terra_2.wasm"] = await instantiate(
  "token_bridge_terra_2.wasm",
  {
    gov_chain: govChain,
    gov_address: Buffer.from(govAddress, "hex").toString("base64"),
    wormhole_contract: addresses["wormhole.wasm"],
    wrapped_asset_code_id: codeIds["cw20_wrapped_2.wasm"],
    chain_id: 18,
    native_denom: "uluna",
    native_symbol: "LUNA",
    native_decimals: 6,
  },
  "tokenBridge"
);

addresses["mock.wasm"] = await instantiate(
  "cw20_base.wasm",
  {
    name: "MOCK",
    symbol: "MCK",
    decimals: 6,
    initial_balances: [
      {
        address: wallet.key.accAddress,
        amount: "100000000",
      },
    ],
    mint: null,
  },
  "mock"
);

/* Registrations: tell the bridge contracts to know about each other */

const contract_registrations = {
  "token_bridge_terra_2.wasm": [
    // Solana
    process.env.REGISTER_SOL_TOKEN_BRIDGE_VAA,
    // Ethereum
    process.env.REGISTER_ETH_TOKEN_BRIDGE_VAA,
    // BSC
    process.env.REGISTER_BSC_TOKEN_BRIDGE_VAA,
    // ALGO
    process.env.REGISTER_ALGO_TOKEN_BRIDGE_VAA,
    // TERRA
    process.env.REGISTER_TERRA_TOKEN_BRIDGE_VAA,
    // NEAR
    process.env.REGISTER_NEAR_TOKEN_BRIDGE_VAA,
    // Wormhole Chain
    process.env.REGISTER_WORMCHAIN_TOKEN_BRIDGE_VAA,
    // APTOS
    process.env.REGISTER_APTOS_TOKEN_BRIDGE_VAA,
  ],
};

for (const [contract, registrations] of Object.entries(
  contract_registrations
)) {
  console.log(`Registering chains for ${contract}:`);
  for (const registration of registrations) {
    await wallet
      .createAndSignTx({
        msgs: [
          new MsgExecuteContract(
            wallet.key.accAddress,
            addresses[contract],
            {
              submit_vaa: {
                data: Buffer.from(registration, "hex").toString("base64"),
              },
            },
            { uluna: 1000 }
          ),
        ],
        memo: "",
      })
      .then((tx) => terra.tx.broadcast(tx))
      .then((rs) => console.log(rs));
  }
}

// Terra addresses are "human-readable", but for cross-chain registrations, we
// want the "canonical" version
function convert_terra_address_to_hex(human_addr) {
  return "0x" + toHex(zeroPad(Bech32.decode(human_addr).data, 32));
}

'''
'''--- lib/wormhole/cosmwasm/tools/deploy_single.js ---
import { LCDClient, MnemonicKey } from "@terra-money/terra.js";
import {
  MsgInstantiateContract,
  MsgStoreCode,
} from "@terra-money/terra.js";
import { readFileSync } from "fs";
import { Bech32, toHex } from "@cosmjs/encoding";
import { zeroPad } from "ethers/lib/utils.js";
import axios from "axios";
import yargs from "yargs";
import {hideBin} from "yargs/helpers";

export const TERRA_GAS_PRICES_URL = "https://fcd.terra.dev/v1/txs/gas_prices";

const argv = yargs(hideBin(process.argv))
  .option('network', {
    description: 'Which network to deploy to',
    choices: ['mainnet', 'testnet', 'devnet'],
    required: true
  })
  .option('artifact', {
    description: 'Which WASM file to deploy',
    type: 'string',
    required: true
  })
  .option('mnemonic', {
    description: 'Mnemonic (private key)',
    type: 'string',
    required: true
  })
  .help()
  .alias('help', 'h').argv;

const artifact = argv.artifact;

/* Set up terra client & wallet */

const terra_host =
      argv.network === "mainnet"
    ? {
        URL: "https://lcd.terra.dev",
        chainID: "columbus-5",
        name: "mainnet",
      }
    : argv.network === "testnet"
    ? {
        URL: "https://bombay-lcd.terra.dev",
        chainID: "bombay-12",
        name: "testnet",
      }
    : {
        URL: "http://localhost:1317",
        chainID: "localterra",
      };

const lcd = new LCDClient(terra_host);

const feeDenoms = ["uluna"];

const gasPrices = await axios
  .get(TERRA_GAS_PRICES_URL)
  .then((result) => result.data);

const wallet = lcd.wallet(
  new MnemonicKey({
    mnemonic: argv.mnemonic
  })
);

await wallet.sequence();

/* Deploy artifacts */

let codeId;
const contract_bytes = readFileSync(artifact);
console.log(`Storing WASM: ${artifact} (${contract_bytes.length} bytes)`);

const store_code = new MsgStoreCode(
  wallet.key.accAddress,
  contract_bytes.toString("base64")
);

const feeEstimate = await lcd.tx.estimateFee(
  wallet.key.accAddress,
  [store_code],
  {
    memo: "",
    feeDenoms,
    gasPrices,
  }
);

console.log("Deploy fee: ", feeEstimate.amount.toString());

const tx = await wallet.createAndSignTx({
  msgs: [store_code],
  memo: "",
  feeDenoms,
  gasPrices,
  fee: feeEstimate,
});

const rs = await lcd.tx.broadcast(tx);
const ci = /"code_id","value":"([^"]+)/gm.exec(rs.raw_log)[1];
codeId = parseInt(ci);

console.log("Code ID: ", codeId);

/* Instantiate contracts.
 *
 * We instantiate the core contracts here (i.e. wormhole itself and the bridge contracts).
 * The wrapped asset contracts don't need to be instantiated here, because those
 * will be instantiated by the on-chain bridge contracts on demand.
 * */
async function instantiate(codeId, inst_msg) {
  var address;
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgInstantiateContract(
          wallet.key.accAddress,
          wallet.key.accAddress,
          codeId,
          inst_msg
        ),
      ],
      memo: "",
    })
    .then((tx) => lcd.tx.broadcast(tx))
    .then((rs) => {
      address = /"contract_address","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    });
  console.log(`Instantiated ${contract} at ${address} (${convert_terra_address_to_hex(address)})`);
  return address;
}

// example usage of instantiate:

// const contractAddress = await instantiate("wormhole.wasm", {
//   gov_chain: govChain,
//   gov_address: Buffer.from(govAddress, "hex").toString("base64"),
//   guardian_set_expirity: 86400,
//   initial_guardian_set: {
//     addresses: [
//       {
//         bytes: Buffer.from(
//           "beFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe",
//           "hex"
//         ).toString("base64"),
//       },
//     ],
//     expiration_time: 0,
//   },
//   chain_id: 18,
//   fee_denom: "uluna",
// });

// Terra addresses are "human-readable", but for cross-chain registrations, we
// want the "canonical" version
function convert_terra_address_to_hex(human_addr) {
  return "0x" + toHex(zeroPad(Bech32.decode(human_addr).data, 32));
}

'''
'''--- lib/wormhole/cosmwasm/tools/deploy_xpla.js ---
import "dotenv/config";
import {
  LCDClient,
  MnemonicKey,
  MsgInstantiateContract,
  MsgExecuteContract,
  MsgStoreCode,
} from "@xpla/xpla.js";
import { readFileSync, readdirSync } from "fs";
import { Bech32, toHex } from "@cosmjs/encoding";
import { zeroPad } from "ethers/lib/utils.js";

const MNEMONIC = process.env.MNEMONIC
if (MNEMONIC === "") {
  console.log("Please set MNEMONIC")
  process.exit(1);
}

const NETWORK = process.env.NETWORK

let LCD_URL;
let CHAIN_ID;
if (NETWORK === "testnet") {
  LCD_URL = "https://cube-lcd.xpla.dev";
  CHAIN_ID = "cube_47-5";
} else if (NETWORK === "mainnet") {
  LCD_URL = "https://dimension-lcd.xpla.dev";
  CHAIN_ID = "dimension_37-1";
} else {
  console.log("Please set NETWORK to either \"testnet\" or \"mainnet\".");
  process.exit(1);
}

console.log("Deploying to " + NETWORK + " at URL " + LCD_URL + ", chainId " + CHAIN_ID + ".");

/*
  NOTE: Only append to this array: keeping the ordering is crucial, as the
  contracts must be imported in a deterministic order so their addresses remain
  deterministic.
*/
const artifacts = [
  "wormhole.wasm",
  "token_bridge_terra_2.wasm",
  "cw20_wrapped_2.wasm",
  // Decided not to deploy these as of 10/10/2022:
  // "shutdown_core_bridge_cosmwasm.wasm",
  // "shutdown_token_bridge_cosmwasm.wasm",
];

/* Check that the artifact folder contains all the wasm files we expect and nothing else */

const actual_artifacts = readdirSync("../artifacts/").filter((a) =>
  a.endsWith(".wasm")
);

const missing_artifacts = artifacts.filter(
  (a) => !actual_artifacts.includes(a)
);
if (missing_artifacts.length) {
  console.log(
    "Error during cosmwasm deployment. The following files are expected to be in the artifacts folder:"
  );
  missing_artifacts.forEach((file) => console.log(`  - ${file}`));
  console.log(
    "Hint: the deploy script needs to run after the contracts have been built."
  );
  console.log(
    "External binary blobs need to be manually added in tools/Dockerfile."
  );
  process.exit(1);
}

const unexpected_artifacts = actual_artifacts.filter(
  (a) => !artifacts.includes(a)
);
if (unexpected_artifacts.length) {
  console.log(
    "Error during cosmwasm deployment. The following files are not expected to be in the artifacts folder:"
  );
  unexpected_artifacts.forEach((file) => console.log(`  - ${file}`));
  console.log("Hint: you might need to modify tools/deploy.js");
  process.exit(1);
}

/* Set up cosmwasm client & wallet */

const client = new LCDClient({
  URL: LCD_URL,
  chainID: CHAIN_ID,
});

const wallet = client.wallet(
  new MnemonicKey({
    mnemonic: MNEMONIC,
  })
);

await wallet.sequence();

/* Deploy artifacts */

const codeIds = {};
for (const file of artifacts) {
  const contract_bytes = readFileSync(`../artifacts/${file}`);
  console.log(`Storing WASM: ${file} (${contract_bytes.length} bytes)`);

  const store_code = new MsgStoreCode(
    wallet.key.accAddress,
    contract_bytes.toString("base64")
  );

  try {
    const tx = await wallet.createAndSignTx({
      msgs: [store_code],
      memo: "",
    });

    const rs = await client.tx.broadcast(tx);
    const ci = /"code_id","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    codeIds[file] = parseInt(ci);
  } catch (e) {
    console.log(`${e}`);
  }
}

console.log(codeIds);

/* Instantiate contracts.
 *
 * We instantiate the core contracts here (i.e. wormhole itself and the bridge contracts).
 * The wrapped asset contracts don't need to be instantiated here, because those
 * will be instantiated by the on-chain bridge contracts on demand.
 * */

// Governance constants defined by the Wormhole spec.
const govChain = 1;
const govAddress =
  "0000000000000000000000000000000000000000000000000000000000000004";

async function instantiate(contract, inst_msg, label) {
  var address;
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgInstantiateContract(
          wallet.key.accAddress,
          wallet.key.accAddress,
          codeIds[contract],
          inst_msg,
          undefined,
          label
        ),
      ],
      memo: "",
    })
    .then((tx) => client.tx.broadcast(tx))
    .then((rs) => {
      address = /"_contract_address","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    });
  console.log(
    `Instantiated ${contract} at ${address} (${convert_terra_address_to_hex(
      address
    )})`
  );
  return address;
}

// Instantiate contracts.  NOTE: Only append at the end, the ordering must be
// deterministic for the addresses to work

const addresses = {};

addresses["wormhole.wasm"] = await instantiate(
  "wormhole.wasm",
  {
    gov_chain: govChain,
    gov_address: Buffer.from(govAddress, "hex").toString("base64"),
    guardian_set_expirity: 86400,
    initial_guardian_set: {
      addresses: [
        {
          bytes: "WMw65cCXshPOPIGXnhuflXB0aqU=",
        },
      ],
      expiration_time: 0,
    },
    chain_id: 28,
    fee_denom: "axpla",
  },
  "wormhole"
);

addresses["token_bridge_terra_2.wasm"] = await instantiate(
  "token_bridge_terra_2.wasm",
  {
    gov_chain: govChain,
    gov_address: Buffer.from(govAddress, "hex").toString("base64"),
    wormhole_contract: addresses["wormhole.wasm"],
    wrapped_asset_code_id: codeIds["cw20_wrapped_2.wasm"],
    chain_id: 28,
    native_denom: "axpla",
    native_symbol: "XPLA",
    native_decimals: 18,
  },
  "tokenBridge"
);

// Terra addresses are "human-readable", but for cross-chain registrations, we
// want the "canonical" version
function convert_terra_address_to_hex(human_addr) {
  return "0x" + toHex(zeroPad(Bech32.decode(human_addr).data, 32));
}

process.exit(0)
///////////////////////////////////////////////////////////// Used the client to do all this ////////////////////////////////////

// First guardian set upgrade (#0 → #1)

const gs1 =
  "010000000001007ac31b282c2aeeeb37f3385ee0de5f8e421d30b9e5ae8ba3d4375c1c77a86e77159bb697d9c456d6f8c02d22a94b1279b65b0d6a9957e7d3857423845ac758e300610ac1d2000000030001000000000000000000000000000000000000000000000000000000000000000400000000000005390000000000000000000000000000000000000000000000000000000000436f7265020000000000011358cc3ae5c097b213ce3c81979e1b9f9570746aa5ff6cb952589bde862c25ef4392132fb9d4a42157114de8460193bdf3a2fcf81f86a09765f4762fd1107a0086b32d7a0977926a205131d8731d39cbeb8c82b2fd82faed2711d59af0f2499d16e726f6b211b39756c042441be6d8650b69b54ebe715e234354ce5b4d348fb74b958e8966e2ec3dbd4958a7cdeb5f7389fa26941519f0863349c223b73a6ddee774a3bf913953d695260d88bc1aa25a4eee363ef0000ac0076727b35fbea2dac28fee5ccb0fea768eaf45ced136b9d9e24903464ae889f5c8a723fc14f93124b7c738843cbb89e864c862c38cddcccf95d2cc37a4dc036a8d232b48f62cdd4731412f4890da798f6896a3331f64b48c12d1d57fd9cbe7081171aa1be1d36cafe3867910f99c09e347899c19c38192b6e7387ccd768277c17dab1b7a5027c0b3cf178e21ad2e77ae06711549cfbb1f9c7a9d8096e85e1487f35515d02a92753504a8d75471b9f49edb6fbebc898f403e4773e95feb15e80c9a99c8348d";

await wallet
  .createAndSignTx({
    msgs: [
      new MsgExecuteContract(
        wallet.key.accAddress,
        addresses["wormhole.wasm"],
        {
          submit_v_a_a: {
            vaa: Buffer.from(gs1, "hex").toString("base64"),
          },
        },
        { axpla: 1700000000000000000 }
      ),
    ],
    memo: "",
  })
  .then((tx) => client.tx.broadcastBlock(tx))
  .then((rs) => console.log(rs));

// Second guardian set upgrade (#1 → #2)

const gs2 =
  "01000000010d0012e6b39c6da90c5dfd3c228edbb78c7a4c97c488ff8a346d161a91db067e51d638c17216f368aa9bdf4836b8645a98018ca67d2fec87d769cabfdf2406bf790a0002ef42b288091a670ef3556596f4f47323717882881eaf38e03345078d07a156f312b785b64dae6e9a87e3d32872f59cb1931f728cecf511762981baf48303668f0103cef2616b84c4e511ff03329e0853f1bd7ee9ac5ba71d70a4d76108bddf94f69c2a8a84e4ee94065e8003c334e899184943634e12043d0dda78d93996da073d190104e76d166b9dac98f602107cc4b44ac82868faf00b63df7d24f177aa391e050902413b71046434e67c770b19aecdf7fce1d1435ea0be7262e3e4c18f50ddc8175c0105d9450e8216d741e0206a50f93b750a47e0a258b80eb8fed1314cc300b3d905092de25cd36d366097b7103ae2d184121329ba3aa2d7c6cc53273f11af14798110010687477c8deec89d36a23e7948feb074df95362fc8dcbd8ae910ac556a1dee1e755c56b9db5d710c940938ed79bc1895a3646523a58bc55f475a23435a373ecfdd0107fb06734864f79def4e192497362513171530daea81f07fbb9f698afe7e66c6d44db21323144f2657d4a5386a954bb94eef9f64148c33aef6e477eafa2c5c984c01088769e82216310d1827d9bd48645ec23e90de4ef8a8de99e2d351d1df318608566248d80cdc83bdcac382b3c30c670352be87f9069aab5037d0b747208eae9c650109e9796497ff9106d0d1c62e184d83716282870cef61a1ee13d6fc485b521adcce255c96f7d1bca8d8e7e7d454b65783a830bddc9d94092091a268d311ecd84c26010c468c9fb6d41026841ff9f8d7368fa309d4dbea3ea4bbd2feccf94a92cc8a20a226338a8e2126cd16f70eaf15b4fc9be2c3fa19def14e071956a605e9d1ac4162010e23fcb6bd445b7c25afb722250c1acbc061ed964ba9de1326609ae012acdfb96942b2a102a2de99ab96327859a34a2b49a767dbdb62e0a1fb26af60fe44fd496a00106bb0bac77ac68b347645f2fb1ad789ea9bd76fb9b2324f25ae06f97e65246f142df717f662e73948317182c62ce87d79c73def0dba12e5242dfc038382812cfe00126da03c5e56cb15aeeceadc1e17a45753ab4dc0ec7bf6a75ca03143ed4a294f6f61bc3f478a457833e43084ecd7c985bf2f55a55f168aac0e030fc49e845e497101626e9d9a5d9e343f00010000000000000000000000000000000000000000000000000000000000000004c1759167c43f501c2000000000000000000000000000000000000000000000000000000000436f7265020000000000021358cc3ae5c097b213ce3c81979e1b9f9570746aa5ff6cb952589bde862c25ef4392132fb9d4a42157114de8460193bdf3a2fcf81f86a09765f4762fd1107a0086b32d7a0977926a205131d8731d39cbeb8c82b2fd82faed2711d59af0f2499d16e726f6b211b39756c042441be6d8650b69b54ebe715e234354ce5b4d348fb74b958e8966e2ec3dbd4958a7cd66b9590e1c41e0b226937bf9217d1d67fd4e91f574a3bf913953d695260d88bc1aa25a4eee363ef0000ac0076727b35fbea2dac28fee5ccb0fea768eaf45ced136b9d9e24903464ae889f5c8a723fc14f93124b7c738843cbb89e864c862c38cddcccf95d2cc37a4dc036a8d232b48f62cdd4731412f4890da798f6896a3331f64b48c12d1d57fd9cbe7081171aa1be1d36cafe3867910f99c09e347899c19c38192b6e7387ccd768277c17dab1b7a5027c0b3cf178e21ad2e77ae06711549cfbb1f9c7a9d8096e85e1487f35515d02a92753504a8d75471b9f49edb6fbebc898f403e4773e95feb15e80c9a99c8348d";

await wallet
  .createAndSignTx({
    msgs: [
      new MsgExecuteContract(
        wallet.key.accAddress,
        addresses["wormhole.wasm"],
        {
          submit_v_a_a: {
            vaa: Buffer.from(gs2, "hex").toString("base64"),
          },
        },
        { axpla: 1700000000000000000 }
      ),
    ],
    memo: "",
  })
  .then((tx) => client.tx.broadcastBlock(tx))
  .then((rs) => console.log(rs));
await sleep(5000);

/* Registrations: tell the bridge contracts to know about each other */

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

const contract_registrations = {
  "token_bridge_terra_2.wasm": [
    // Solana
    "01000000020d0005d041155878a79b0c8b48aaf3a6266d85a808df5658de5c77715802ba2e38b54374a5a244b43c1a4129d31b47192cb80a565484e55f171c00df69be3107e32e0001fc342ba5227e2319c36fe7771d4626753960b5f6082770e57120b5057eb56c5066bab012670d532c259f6162f311458e187d7137298fa984a41d469df817f88f010349b730282809e94fdeb125dd30490e116ee6ebffa73296eb10a36848351a12c77e846daa5f6eeb83103a2d7325d7981fa4cae43fb84a91851c400c2573abaad30005ac798fcaddd7090a41b718f5786f02436f30d631e64ac46ccd058e87dabcf20f03dd4c7ca0e71d2bbd9c0cee90809a5cdd0bc72519abb9313a4d81763b48c79c01061cdc7c59590231f6f580c3b002ddfa5f41bd0118c67fcb4cb295ae239b74d0e322775d1e78c252eb605230e040c5af176e9ec5ab5f34dd36fcb202c894b6e4fa00087621ef01365e4d1f2e81ef9ce46f0d620cbf003ded06956df3e87a137640310037e8d605f9208a5e17719001fa662d2dcee1c500f0db1ec99119dd326140cf240109a406c0fffda03ffc741ac06743bc507d2a5bdb95eb1c6e3d24a41d99281ce9af20881add8926faec5ac33d3bf85c61a220dd0f699d713f4a453f18b2ad735b6b010a42fb4729a41b99029d06fc6395e1f676654002a28e08c073fe905e87883726b444aa70742c6c53ee8efdb004e756fae63bfe9a91d20971853cc0a8677ec1b0da000bf472a82642b1a3c7872a6594786fc803c8ed8948719f85d1ecfbf903deaba8505b02ffaa488b09e066a0d7210d8ee0871dd10d23b4249c942c64bd79a08d5f6f010c308bc162680851b2a94a888e068394bf4dcb5d5afab1faa350bb086884c20a535366302c37220db24cf6bf2de5abb904f1ffbb13afa624f0d413049b1cb034bb010df076e04e691e924bc9b4e855cc87ef67c237455e1cc3c96d5325c45f5c6002eb68740692e35a49a9e5147d30e796b184df6e7fc0633aa8286fabce5a1f99f0a00011d9cc70d9239887c638aa5f28f268e1c9993d34b0d33550ec373acd921d461eab31cdf77fb7c08f999d4ea7f32f48396dc1d0c3cb77beffb58e3ab5f57333a4b00012d64e7e0459fad8067a73e7fd0cc5b97e6794b5761db7b3b7d15858843ac044d112d2fa713d9c29d1c79f73434e2af1cd965c93aac3502b0f368652266d09d34200000000003681da22000100000000000000000000000000000000000000000000000000000000000000040d9c82f1591753eb20000000000000000000000000000000000000000000546f6b656e4272696467650100000001ec7372995d5cc8732397fb0ad35c0121e0eaa90d26f828a534cab54391b3a4f5",
    // Ethereum
    "01000000020d00045ea9d9fb9a10f83716100364a9c3d4560b00b1f960251ede94f78c0fb0d6c439b4fb60aaecddcd69f1b52886791eb340238d3a7e3fda3d372e20384155dcaa01011164f9336028b54d0c2183d6097e979da9ca30368102f5d4437643470dbd4c0c3876fe57223da274b2bab8746fd8535156e77cf7d8f78f7db69735f8814ab48801031903a81caa6dc37469a6e4ed1375de0d390c0dcbefc0ad9f5f912082610789a2687a65d91e7a100793a54bdd3b731c49ed38fff73e4e1d703db1111bb97801330005bac64f9a0642251ce45e7549aba8b2c9331be29d75b1ba77a9fd410346fbf65e68ef971c516f0423ba3b39c45bd5ab46f819a29d42b9ee8e261aab36affae8b501066ad5f52d3958068b82595b38aefacbb7247eb7cf31600f5d7f00b230f77f34f257b606586da3c1ecc6077799141a3573e9e274e0ca3f2ab4fc4b7a80c8dd21bb0008574496322f38da956ed90b56c54b4f6886083b201f555a3d764d9e43e00cf1aa5e2ef7c64a27384591458010ee8262ec1cec072625c3930202dabf909b4825460109857209084b4409ccd3f16ccbfc7aea3ea451b5dc90f8d41fa807163917b70b195140d93f53acb48f0972a94c90778dcd3479ca3ff0a7fd8d3892b50b57b671a8000a79f78e3af2e6a095bca2123e83e56bbddbddaadffc801c27c98f41bba92c4ac22a6c71d3f48616b9fab0a69af23e89c659e57fdd7a5f64aca0488b4ee83c717b000beef015fb5ea5c3cf7254818765295e0a61d1e2e2b712dcc4c1ffb3037869a4d561702e460650fcca55135a4f564d07469f79a4729e26bfcd8f804e672baf5a97010ceaf4be34eda4fb97b23c3ca74137e6c1f55f7f1df34a7f645d4beea457a2dc61637f2c8b6a9f35f3e13ff8f3a5cf9dc74a6389b7f19c453b578b2a7c35024d97000dbe6e237a96f4f7219f1d31f74d07ca76b9f11d3781f612ae684db6c6b000caaf4e21caea9f1ad947e8450aed7cd62599c7a6908ffcb900b91af2d80d7cd7660901119855d08e9b5c2ab854944ec5dda0f281c8d9d6408e89d43f6e2df91a82fb8f8714baf8daf7f7ad39c04ac19b39383a49f2db351d5c181c3f35e9b3a569668dfe0112e0a0a193c269f8d2db4acec3ed94fc6603050435ffd733c5f5ab6c9b12245af77b42adfac773a1860eda4500a266fd61292cc54652ba333bf294a6ded053a3f20100000000d77ea04400010000000000000000000000000000000000000000000000000000000000000004c550f77728915b5c20000000000000000000000000000000000000000000546f6b656e42726964676501000000020000000000000000000000003ee18b2214aff97000d974cf647e7c347e8fa585",
    // TERRA
    "01000000020d02bbee9e7948d48240e3073429a7791f4035289b6520f174c261bebf6ea54b381a5f7d9402cca78d75ebbb3c607ed507443e96b66513e8903ce4e19028954a1ba901035c8ce8fd98f6d195f61ac14d11c9f7b32c6e94def8d8e3408dc823d4c9ef5089684e405bc8ea772c73206b5789657a7118fb4305e17e95989fcb7bc0106c45e40104ef231b924c6aa072ca7759542feea1991329ee7074b473f36fb6284b2e0eabdf074c16c99c77596fc20c6e9e5b046c3aa5ab40e7a9ce5fe11de3af1ba14219900105688905aa06cd3ff8f615f23566194500126fb294fc1130e246484fcd1205a6701c674440cfaa91ea559d28ea25e957e001f40156d38f061155efe48c87e7136601068b9fee5035523e329219b9ce9ff3128591654b85d39a3aae75695f5de4230a81594e2039d4808a7e72ced5ffdeb4d5c090f2e070676a064c4938d300c51df65e010761cb4316f460703f1f454ad5825d54a5a496eb55c07124052823772698a92ebe67102687627e688737bec95cb4b408cc3c748e42f3bd7ad8534352ed0962e8ac0108bfdf7cbbb1cea6bab576e02bd7928be74d1a38f6892251ef02e00dcafb3eb41d78aeb3aad2693d6dba2c493bfc83d729a65f81a8517523e1916624b8bd8e67290009d8b0ef6910a9abe3e118ae387185647367a6e8ca059bfabf88500b780e88f4f960f2a177c924abc9ba9ce8e8d2e96b969d3fd229c0c10a030e36f808a92de9f6000c5ec295fc7976a6bc80802d4cbba29df0eacae53e223bb7e0e64021a4787454832ba1be31d2157536b7e1cc2348bfb1fec63cfcb26815967450ddf2b058fa9575010d33d1c1558052c0866b204cbef25f9c6286a61b96dbefa426e85225effcde9ec20c0e283c794b18ba9d28311e0548a7c808456a15e57a52f447f8094cecbfa271000f7426339442b83039f2d0c68ccdce4952a3898956ff21edd54b6c237c6c7d801a6b7a11d4e5d5befc7e1a4dc9debaf6f74d1860d262d25efe1970bf70ac124f360010322d3808532735a14c6c523a9fc2da458ca9049f4cbc6c3b7a2f037275a472450c7c5d9a112b4869251392b62b2a82c1271e5e50a9ee1a5f255eebe6fca97ac6011172a1c02539bdd284b0b21c00841fbec1c4df9e52f98bdd2243c7c3dccced08c67659a26d9be3ee4eac2e2b1ff05565207ca305ac67789f0b45984f82af6a32cf0100000000eafd93a400010000000000000000000000000000000000000000000000000000000000000004b4e6895ee716695420000000000000000000000000000000000000000000546f6b656e42726964676501000000030000000000000000000000007cf7b764e38a0a5e967972c1df77d432510564e2",
    // BSC
    "01000000020d026f8d64ef762f1e7126d0ce149d9fa7c8e163acc4134cebd569e0c6e8158a7d3b45d440125e031184bcf560872b1dcdfbdff69363e0e41f0d97cdd1c8b23fe3020003e5fb20bbda884014f0a52c533dd55ab0c1a1e5bf9bd254bc363574034536424d136d1ba6635132eefd09aeaa14958b551cfbfac26a82fd6c9d41094086bc209a00041dd6e91875257971f47523df8ae3f9b7f19bc5a770c9ef8f895e8aabd34266405ab0455dd60d8526730cd74e254eda1328cc668ff6e609efc19ced8f93a9decd0105780c3128d5fd867773ffa699bc6391197bc4451392f8e123fe001aa2d47e443e1aba56a28c51e3c13497a8efa5ff601ce201a3da611c4d986dfb6ab99ab064e5000616a054fa2975984828f20debf639d15d4c8ca4dfbb19db31c2c70c81f36bf1bd206a8e02f5202707f2b762408480a5dee4676328ac83602a1b55619df56b81a80007ec23349612484da2a0d447b404a7f63c966063f48ff3e635390578d5b22958154ded0f633ac1a54454a04a7bb23ca04cd18280c38189f127bcdb3fa8819b324601082b051226cb2e1b89f2f94fe301759a1e559edf0fb19b2d260cdb052e705f0fe62caaf19eb07d7c1a0d7470922d1f9b76b01def4dbab4df2d4a7736038f2069f300096c96c851f7386de4f628bede2be2c8a85530a4e079e5e50b7810d639939430f67b3d4f773b2c4151a481d0dc05b137568a995d307a4a1310db56814272f3286e010c8dc4208c78ae9ec3c6bc65c568a8cde4b0d2ea9687725354a557e3fa0f1529824f201fa4a5cde61b79870f574626ead8abde1ee08ed32e89f615398ccd782fcd000daa821071e0bfaab8f0e07db8be8b1d2725df6d91c93ce1597b3ae49baf3b7c22714e0a61dbd7c17cd2daaeae05478db53e41967ea000226d5a9680166c1f38dd010f46cd84cfdf7127a31ec4dc9d8dd4d67666ea1a4762130b11b9c92d3ec68713ea04b6171aea974fdc42b38a1823df3bfa2b5a23d90e8454622dd3a9a69c27cca901101654668dfa8a0506d4a787c02fd9ebf51549673ad589b4d82494ef15ce38c9547bbbd3c0346f65e38b415b39be5a99462e192b2b80dfcb89796fe18d68a90ed10011c9016546925c19d5672e4de9f93f8e96e09192ae6458ce59522a39536191e3d4186b2118eab268584cead31d176351e213ae46ab13faf52f0f04c96c296d7632000000000085d1925200010000000000000000000000000000000000000000000000000000000000000004fa79fce49a7b317420000000000000000000000000000000000000000000546f6b656e4272696467650100000004000000000000000000000000b6f6d86a8f9879a9c87f643768d9efc38c1da6e7",
    // Polygon
    "01000000020d023e3f20557912e47e3f8bcfc92d425d1c8f4b059aa552892f7960c61a5f5d0a7141e15ae77d380043686a8e41fc9edb4ef79931c6cbfcbe5d5a63c80116f8834f00030523eae2a37bf181e5879870dd6bfd31bc752e32696b1d06e0a2c7140e0112b8784a12b0da6bcd65913a8b411eb1fe35654055414ee90a22d983e63cdec5be610004f0446b5136e4a413dfeb09f7b050453f6db8341697ad7ec7bb1bf6a7bc003fa730df7f3b7ae8b65b8c03de5749290b9f6ac5db41fa370c3fa68a5ede6c6d03d10105bd59ae4996c229c40f8f0fd562042fd7b83ba049588296d40796d10d705c40895b3d3b0770dd17fedc024d1440b6d55f238a8a6bc303be5b6f851bb140ce2af30106d72414644ae17ae51a065fe66f110a2fe7993003f46e2e8dc396196de7754927761c56a57a88300fd4e812de2a3b9efff3df8f16ffdab273f7fbbb05eacc66860107ec8bce586f9d4942c125175fc083d6407a5a5c93b40f289286338db7e2519c905d1fca1aa6db645d05e55275915ca7845e35307495802ce6be4de879c13fd9700108a16805c8804d82971b10a0270edbfefa0a8e218e4c7bbd57377037678f01865a4822c0d2df6971936e4e283d443a003e492daedbefab64167282717ca74e7d8f0009acb88dd19c6bb63bd539c9021c09c17b2e7ca9897cadb353a224bbe052af6e3d5907e528c128d56df2d2050c52a33b29c1dd990e75383d7bdb084a64e4484085010c0aeadd15bbff6e5d3235b0fb4893000fbbdbe3f3420b71705ce8eae3a83c3bb47871b7dec96b82885d13748d49f3668729d08205db29ca24f3e307362bbd4b70010d504f8c81f2635e01221a3b6ad8e6d16995d440f2927f4aab1eead23f33df8cc709dd21609c562e359c1199a7fcc36ab23746c09f60be39abfdb8b594fe7f3474000faf74240ca2e5bf9254b28b85ab3335ce95c5c8116a7018de2b76e346f878ed5b6cb96f6aa1b7d378c93a897ca691a3cead5a24df946b0cb8978558f044aefac200102239ed032bbfc704cb8be157b3328c81f1c6d227a2eaef8eeeb78cb63ad46aaf4dca8ea91b92c17c7f11ad5e5e1ea05611dab7ca6bfd341c02b81a7608ab25a801119873e624878824285a8fd684effdb0ab24d994405913d09f207c5f4ee86d33d452a9feb7bfcfefd64cad1b2885ad3178b4dfbb9f96982e868c18523d3b04f9ac000000000006896149000100000000000000000000000000000000000000000000000000000000000000045fdbfbdc28c8aeb320000000000000000000000000000000000000000000546f6b656e42726964676501000000050000000000000000000000005a58505a96d1dbf8df91cb21b54419fc36e93fde",
    // Avalanche
    "01000000020d022fa91e5df8ef1a320710730c63143c72e8ac8309546c7b36e3a974cc42ae3188169bba1d62afb5a9d04d09cea0b6fdd5fbff9bd3828b9e43d40c66b4a7ac4188010355e8a4edb5de6ce386ba67204da0fb15559b43788cdd0471fdd560c4c5aa81307a6be777fc8f525fee0f79faef62f1a91f99465f84dad8ebb53b4df68a5322390104570a49a223c855bf61fefce149e52efab20d8be703f5a0decfb0cdcffea75cd9418ac7f375a8ddff481eb19494f0ada6532aa2bfcb8f5fe7d79ffa42bcb69d8b000559cf3254735ba37c09512da6cba3417892cef2d8cee64721d85bb652233965ce38d9ef1db109b138bd4a8a75bf05e414ea0123eda9ed673295d16aee13e2b0cd0106b9e38f4a941c104b1b2077061cf5212f4684795b90220f078fa4d38d08fe2080526c82bf9608197e594bb1e575789d201408ccdf56bf323b64ef173c6c75dd4401077a519ba78c4195272d4d14cb9464cc1e1cfd2322d542d1c83b523b0a110ccb935d2e94ea8f8eee72388f77e58b912ae465d079b16cffb717b94db595c99a5fc70008216485ceff70b54f363e49c00a5418cce3f460092f119e2049eb5ca56b8bf4d358e57b7180a97ade4700bee8b77d047515e63e83849039a4b2527a349ef6d1640109c8990d7c964186a264ffa01291a23ef8ff644830d76a6b9d17dff6455bcb67271913c099e3597656ab2016152f55af78861e513787847f645bacaa3193c053bb010c847815ab7ce77f9151fbd35fff9767f73035dbc76c0683e1efedc89eb16c93284de384ad6de521200a1cef67279a1d41b714b3e3e558796bd287243453b81a2c000d721ffed26dc5f06ee8858b9595c8a57870f663f10f03e2ad078679a6373b24ee457eafe4bdcc7005f2a2cfb674f0c29394a64c21c81a59824965566e6859dcf0000f28f1f759bc52cc011fcaba0482cd4c3012e9474cc5089b185747d848e998e72231a0c8dab79041bbe804c13032411afd78a386df08ac517939828a62effb22b60110720e9720728dd34858fa83e292730b64991ec9bc8c2f999ab3bf3873f2254e4972c097153e9dfa4cb9b6ab2e2ffd8d9483ac7d6002754795e41fd4aab001f9c6011161cc391d56aead20f0e1169e759cb320277afaf9cf08adb31db58040eb2c97042cf92037df376c87c65e386ec0eb26e22e4ce5d9ace143c02a26612a3d2cab81000000000032bda66200010000000000000000000000000000000000000000000000000000000000000004e2dcca3b0a7d091320000000000000000000000000000000000000000000546f6b656e42726964676501000000060000000000000000000000000e082f06ff657d94310cb8ce8b0d9a04541d8052",
    // Oasis
    "01000000020d01d73eb7f4cb191bc1be510f3157a0ab1a568782c56431bddfc0a31e930e7eb82a0745c8c99f61c8a5e9adc4709f627b5c72725b8b5c71d015c155004b1d4c7bbd0103b669e11ced2a091e2f0681364464e226942d1082c4f5e45b6055cb686aa7c7a22b50a4f144df92e61b98597d5cdc5621eeb796eff82a629a487a802f8824ed060104e4df25a48526d61f02926c78460154e4993903b35eb84b8fe3190a67c282919343849513da06fb162e063b25e9912cb36ad55e24a6c08764284728cc99cf4f340105670579b525e67ba5b1191e81b12e9774f5d758bca780f0845999b0e37c4f55464cb69a673acac0cf250be652912296f383bf0db11e53a12ca69eeffb2cfba10800068c44ca24448478a41de9bb6b389ba27459ea948f942d59b1d9190d92725fa551649ecad869f0181e495fb1e6a38f1a80b9a89f12361ceed4b3e694695256048001082010fa5ea37d120ddf723a48c51e408afb696c4abe9f23b029c3d0dab928465a509ad0ec98d26c65e579d1800bb0ae8b2888d19c9f897363abaab90e028a6a8b0009a65fd7ecccdf861913a1336bf6b81838d051379180a1ca84dcba27b3b0912a143695432fbc6449c313b54bcb0640d5c3f8ff9853085a5d94be7efee256e8fc3c010b99f198f424bd9fba16709934d38fadd0d99e17e7e5311baca827f283e0c1524934fe1a040fa3900b89836f9ade5defddd288fdc051b564067bb44d7620134a15000c8d1801f3767441a998f1e8b0250aabccaa7fd00c246aca4e487dc0d93ea2a95f20cc7f8ed426f605dbdbb75915004e7848d402414ca035d0cb30015d4d57ff9a010d42d17c5cd8882d3bb6189974b97f3bfc6ed1466aa1e3392a5389c7c9b2874c461a7c2e432a0ea4642a59b731d78f180a1d60aac54cd33c1a90181798ea3d326a0010b0b79171792d1c328ce7270e55834efd38d5e64d3f78f03f4195d83764a00e7904a1160341a5aee387fc7123ac96db99a5abb57942a3261a2a8d4011ab4af7590111fae3b5103e44fcf295d94958985a709b87f74a0fe553c614dc0a1f8c52ac1aab5af6f4f99ab63977462f54d002a77b80fe580aae7567908da7cae9d6770414dc00125a65a56f6fe4c03d86f95971a3792c70408be4ae4ba3b3859d6f85feeb9e93af1be80071b4eac4cee1bb4c652d14f9aa46e0c6f5c5c239919a58dd243a12bdb30100000000324615c900010000000000000000000000000000000000000000000000000000000000000004e9ed430721bd2d8d20000000000000000000000000000000000000000000546f6b656e42726964676501000000070000000000000000000000005848c791e09901b40a9ef749f2a6735b418d7564",
    // Aurora
    "01000000020d02a2d7f318a1c6b67a1451a4aea97f9ed088dd3f6a77664c0d622b4dcf345c0e1b3067c3d2afc699cc9325b2806ebe9a06e18f4c03521ce83be029e005f7d8b0730103623c67f397d0033deebbd88b90f0245e38f23151acac8d960df68289ae1a3cc930a99d34715b477c1ad86e8c32710fcab86ba8367143805130564a06e3abc256000434476ea16abcd146ad31c0958dbdb7e902a6a33b96ebdf7db3563ff6447bf8244ce1e7ad7107db14662d81b3335bf13a5cdbdd4bcdf64d58ba32b728f0ab260700059f65d58322f99b02e82228751770781d8f6a1c6b15f8427a31744e4e486e422e7ca28c95c52af3a18ff2b04acf2158a544f3e9fadf73e04686f5bfe3e02ba6440006024ced58b330ddabfc3876df8721614e27e5cd3238b3fd11f366d11ee649af502d1cae5478db1658eb207ec82ba9b554d22341731f8523652dc5cb6810793efd000772068b2590b6296c28b11068a389a2c63469aeaf876133ef12e137feb780d1e330fc901d48731af06333694980b50a08c7f5ce995347c1e05a565e81be7d21bb010864d76959392889f1fe8cbd2a7a1f14fc18e843fefae458c436e3a58b24e99a9578537f126150576886ec9810c295b95b4d3066f61c81a172a0324149f8ee1e8a010945ac357751b9b3ff13be9d88dc2079259eb574b91391cd75e7402c399e157a612658d4d9e5282dcb2fd8b546fc9a4e192f3044c0a32864b8afc05ba838c7048c000c31ef015209886d42bda4fba51634dd51d59888b8008ed60ab27858a74a952a3e2994384e51ac9d13e73736e568e72430227b85cd0ce275498bde942cfb8c9484000d5e1b9586c226b8172add8139a5920fc5b02456339f419319959f69a59beac3c41c08dde812341ad855311fadd56ef1f2a8b48def97fce137fa718aed50632fc9010f85793957c2fc6319470f745f440a2ff4893a3d9145cdc6c1624d86a929e3ad004707927092a5951db71aa958bbea7d96026cf70c18771cfb0f448b2fb188b7f90110f8e40975afd07984d56563c5baee64bc39f776ccd055a1ea22322adaa4d2ea6e63d6c469d819db644d80013a3410d963109a0aaadf50bcbe7ac1848e6809e06100119d72cd35a66fdd5ac892aa61a519bdad6b06d2b51b831e174784491999826f8867c981439654a4e064eb1ea48f74f10a81fbacca86be9087bbb182045aedb9e40000000000639496a5000100000000000000000000000000000000000000000000000000000000000000042c2817cc9b0f620520000000000000000000000000000000000000000000546f6b656e427269646765010000000900000000000000000000000051b5123a7b0f9b2ba265f9c4c8de7d78d52f510f",
    // Fantom
    "01000000020d03a82a32d9a0119a29c5d5d1e6bcba647c82c60678dd02169c2c566bf99fb65d6a1e5f2403e963471b5e224f4821d1408b6f699d17503fb3e18c1092a926b277b40105b9989551ce1e5305f89a401c9fbbce1ddc5021fc909744fb45c3c4a973e14a957d017028eeffd884e9ad1247118c391df8395b3d48dc57703835fa78b3e968000006f8f70c6c33c36d010bb63d12eeff49a910f2cb0f20c8a1e141b95620be27afd42bfc2e4ab12278e4edb12e14fc6178d96d43400c80fb44e1b058913ce2903fea0109763779ccb39f23ebaea4e7ce578f4042c262677cdb3ebc5fbf6ed2aa684606035baf518a0387b1803301c1d694501667283cea9a9dbc6bb086ef0f7f499dcaf2010a1cc87b373480fa0d17366d9660a79ea79bde2862bd74eb1e70ed5e3add45745e560a63254d85d0304886b4cc7cb84f43ceb0a2c67ed27059b516d0243097ab9c010b9da56edffce7fa25683702fb17a8f38905090d7a56f623e2efb4ce2465ca8c463aa3df6126842a743f9c8e63abc62d16ff2308a5de19f10991d378615551c9a8000cb63a1128063575f87a7b50ccc63b384d80fa80f96287705387d3eafec22cb0d70a55a1453c55ec17f868f274a047f750be6882474fb624dfd7f59f3665e6627a010d5a71dafeedee56cae863738c55e75fbac9903bde846770c4bd40d9864ac31fdc6f717bee177f2f380545b8c78e8fd09c60e2e726775aa948bdccc8ab33d8bb8a010edade1cfc075fdb4ef48171faeed7769aceab3eaed09581dafb6cc1c8c0ac944839772132bd9b4ea80817c2f08a8242900450db0d30369c9a5e70d22553ece0be010f573ddf1df2683cbcf8b68779d6a594712042ea077d6e4436c2f72fb114b5ffe31ea23daf21a1f66864b8c120c1eadce70c7ad1b77240bf8f9898c68f1b4dd623011046eea234a7226e0a902b5c429a074800e53b7ec3dbbfff5d1f37f99dd19318b242937e35950c6e4debac3dbac76405d77162dbb845942f5462101faa4c5f3dd80011bc0b5c1a809b20d2b115f930a41a56021e351d98203529fd5830fa6e41c0c66527ae11afc2f6789e2c5f637880525f38492f496b18d57e428b29ef9e7b4d2fff0012c62db363757e91f25a8f2619e0b370f0ce5a77ccaef99c95fdc46bd76507d2e97ca433aec7f3a023acde2d612c504ecf3b28a7ad817189236e8e2109920254d600000000008c6837d400010000000000000000000000000000000000000000000000000000000000000004230366eb9e6d3c4920000000000000000000000000000000000000000000546f6b656e427269646765010000000a0000000000000000000000007c9fc5741288cdfdd83ceb07f3ea7e22618d79d2",
    // Karura
    "01000000020d0238826e6d875ee99c28e1a7290ca018c62ef04fe0b1ec7f1f30e4d22c8dba96e101299f1bb5a21f66d8d07200088ffd9da08d1c995af13bfe07cc47573b401b1b0103272ca0805c8d7c6266c9a285ac39f896fb6db7771a92cd49b268b58fafc35beb3d1287a6db989df16e9ea61161455f0562e4251982be5c64f859696136ace32900046ee228d67e986f71b97b5003353fda9c1a739fc65fa632ffd3a9d9a3074585116241cc44e39eee1ce2597ddd615a0414d056519026cda7f5854b7245cc01101300052a0c536fe881773bdc285e9f01cf750f71651c143082fbe687df28d6f985b82e5f2b9442ee28cc1821d15133fe50d0b45682d55e1e601ff60f180a277224c51600060065799679aa61b64eee17a443cf00b39334e1589a959caadbfaf4707e495bee6c097373b80e57d2833727f948c846402b02fd2a0659a2b65fa37599a02243d40008fa46f6017f2846fafcfd9d974ce7d4821a022b85cc283c5dda6db38de6633fae12906a667952c6b4745ddde3896af7a7ea3e803723aa4796b27d64f8f18ed6610009126619c71961e3b5e9097220ebd470831940ba515672f1795f47fd31376d42b5220838e1a54bf7afc271bdd7b885c3c554ac8a2bd231cd2164d53e7ada4caa07000b72b042c82fe4c6269cd41b8c71d407dba851066855964cf05fe1a32038dd41e140ba200592476512b09e08d25c668955fbb3b0791c6c2da1fca41ae9486080d9000c2a11fd2b89e33af9471bea6a1cd7a999212ba273cf157677362ed0bc9e1af14a7edcb02795d3a0622cacd5190b3f01699db0de569f7cc91876152fb89a044208000dd41f9cf8e861a4d736e7997dfc70408842e2c99451531ee42a5a3c99902fb77a07e2cf8fe2a86874498ddd12c031ec835558522a593183792286a2c05195ed6a000e2f16ee8c8e2098ff422ed7e87a23804b9720933e006c72d84d51760dd3fb073e352f12a7b163edfde86665a2f915c5b651e186112080806c5fbb3db3d84fc337000f93a1bf75deaea42014dbfdf98614446e6bbedb530d34d11ba1013f9e287669d03ca535a973deee020cc777f8b725f07ef0829038270616887e807941e321f81600100fbc0b5bd2b5f87d6718201ab2cb3002b76d30f0c2ca07d3b63dd1b32c2eacd8198097ac1a7b83d5ee1a678c4c01f042916cd0276a278c383b15408b3e60511a0000000000897ccc42000100000000000000000000000000000000000000000000000000000000000000045c9fa2e92b0e73c520000000000000000000000000000000000000000000546f6b656e427269646765010000000b000000000000000000000000ae9d7fe007b3327aa64a32824aaac52c42a6e624",
    // Klaytn
    "01000000020d02e48a9b823697f08a4806c8a5a08783ce10f26aaa60a3bc69d2a705ced4e4a06675cc9b0579dd2ad5a72f65500d7e5cd8ecc6f5e6991cc832e75fd250079b8817010392e65ddc65e5cfec721ac42e02241ef4d6bb457428861e32ab8d888ddbbc742b0eb1a5dde8b06ac3173f9f2a8c709271b5ffa3fbdb82c440cac17d87932d907101044ab8e98639fddd70eecf342c40eb09fd2a9ee9c84991b186835c6438e0a8d88a5adee107bb49aae0ca58459b14de61101694d7e2c88fa2fa1a9f6af05e062fc40105306e14a59e4937a7414150ce73211377ebbc23760bb1bb55ce4d5b6e6fc2b2ed0864c51045a3f4f9d6fed0ea1a3270eb27ee5a34d19337c1012649bebbb76fc401074696f673418f5f0b945ece6b58fafaf55052fdffceed5e414bc7c4839f70d1ca27135e4e81f6955f99e348539b0127d024b7c462d3ac0f7c5339bc1fa6f6f1ff00085549585e70aec53d929aadaecd6cf5204ec78fbed837a2d30c42a9fc5daab8d2246b1cb8fa389078f23b602631bd1f7af08c546192a855ac4413fcc586b537ab000958a29e434e654233942f2b71843f163f4b07cc506bc37a082055ed418dfca4724b035ca21ba94ff4b51ff88d1656dc0ce8035a61036a20a262aa23c4df99d514010b80f02f0074a784ae3152dea6340efc005a0e101036b18a7cf89a0102be1d8ec728a0e183caadc8c22f17a5e69818125819710fb7d982c1dd0ead6e854acafdb3000dc1f7f209f0c5ae96fbac7abfe0a8cf5a5df9ad6ebebc8bf789d8f9ab4ccc6b3c2af5abd076d211d0d6b6d06c0af7a91275e5cb002df29e322c18a5d0732e8283010e974d4c33abf76da3ef99f6e688f344c30a6016f509faa46a089cdd890937e28e1022e5e9fbb1fb9ebe16c1ca54896c6e1bcb14ca88abd2331eb07eaa2dd258bb000f1a4f45d9070a205c0ea242be3a638ad10e327369028879f6ab47d7185baab56165706896bfc8ca80993d3c25c9a80037d4323401b0dcc3b1919b5701683bd2fa0110e27822f43c0f3eb555330ed555896715b306152b0d42d2ad4267e10c7bac21055850744344fc0e2385bb34f7b2aaf2465bfa0a7c667b6dc2e7410824d3fbd94a00122560fde65296ee41bc03db3c19c76b6790c593c80aadae4271f80a42368e857c58374a3cd72dec321bd67ca8e08dbd2ec4576a1094e20fc508e281f0bc721ea60100000000e3e3c1f8000100000000000000000000000000000000000000000000000000000000000000047799d8f9d5ca5ba820000000000000000000000000000000000000000000546f6b656e427269646765010000000d0000000000000000000000005b08ac39eaed75c0439fc750d9fe7e1f9dd0193f",
    // Celo
    "01000000020d026b48da063e5f751a91b900d8e1aa0d15fca3b06969157453e545463b3cca72de56a2e67d4cb351b0d43a7835f9aee14a1c0eaeffb485d94898614a2a6f640f2e00038e707b662d2280e9b0215f642b751b1e4dbe38a4547a6e3cfb8f8302db145a2a115ea1d6ba9d5444290df3f634dfdde350fbefe7a635cd60095972c433ccb7d701049015e40397387e38e8299d60dd682db7df67a52b1f2b0c72cc70a6e47745aac868fd54d41b7715aa87a213bd8c84dc4b518632d775801310e17af09d0538a2bb0005cce55406328773d6d5d19868d2833c341f9a89c566e50afaad0d1c5eddf18472227c932c0ecbf14adce6932740c6043007c294e0593ed417787d7dff4ccccf6c0007c329a8cbd8da4e1af5757a29f6d4655027da63f04a18da58ff3dd790f40515eb515f3022d3f0f265c525df560134b69f65540e8deac6a90bd4c9ae2322a0ef420108eab5ae5c18cdbe75fa68ee0d100b62d01768f38dd80b5607c6b9e1a12d9918b154af7b441e00835de46289648fa2ec7ad55dc73496a629ad39b26a067f8600f30109fddfeaefa1b180fb6d552cca5c80dda8e2d6a250652d920520bc2a9fa9ffabe94a42a12507062a4015591c2e9a9bcdd68cee2409481e053ad73ad6b857855b7a000be1d2843aa4d70db32d371df8bf380ada002b75c12f516ec28ac772d043748d7237aa5e18f674ac31f8008e1459b5678227a57e32b14591e1215a124825505a8d010d6e426df2e7ee7cbea91333f2eecfb19683e194e5d3fd3fafeb1876351f62776f6afe25a418e55594935760ce4886c62d08fcc411acee7314d88c7ecc38d3facd010e68cb769c5d42d681e059eef022a912125e4d86dd391f1066b74bf2af92a371dc0e2363db8d2a7cd9165af95452e6664b0727d72b823e0bcc76e991bac7853cb6000f04df79dfe70e8f5594dbac665a05b86fe0f292bf9a6432e0ee53b1dd83c846041efa83c8495a727d47fb49643482a15c08a02a8a029638f55963ecc910454aaf0110d8a58b36c86b8260510bba52de40015bd9d0a99b788c563c7405426488bcfb447a26da34e3151cb0bc4c8405655ddbaa873dad9db366e136ae2e4f72a5fd92e70012eb3c585880c66ca92bb8ec12896b44d65cfbd09631e1c9b6b8aebb5e129aaf0867b0dbd5d22590430973f921966dd307a9fd47710b0bde1b30dca028c5c414ce00000000001f77d2e900010000000000000000000000000000000000000000000000000000000000000004d918b69ed0a8cb4320000000000000000000000000000000000000000000546f6b656e427269646765010000000e000000000000000000000000796dff6d74f3e27060b71255fe517bfb23c93eed",
    // Acala
    "01000000020d0086612b561f657f7d859fe080ee1447b97f13b6e72fd68cbcc91e5ac5b04b616e5a1b046272f22098dac0a63677b430fa156e08b385f06a7f5c8c2ccc453fcdff0102c2dccd6d5f83ec6ef4ba9f367f234cb08fca7013b9470d7ba157650d72c8d0f222cdc722b8beef49c5c005acd2aef221823bf51c22a792a7641ff84ca72875d3010398f091e8113bc28af6cef37a9f97ef893bc537fb6cd4597b6ff204bb8748773b5a222ec0870de3510ab0640d3974d3c76420cdf8c1916a8dcd3cb54a6745ba000004202c5c5b6632a800b91ccc3058e5ca5f39aa20f192e66d80a0b55fbd0360a27a2fd1e79fde5dbf6c34b91f49230dd0e032bb54f0fc39126af56137588c13bf400105e53de0114eff96a0c88a7b6ea3f5b01560fad040d239aa92acfd0950e402ee217559bbf1ab6138fac9c620bb9cc45f5f2827e56dc94b82c43978d7a97d5ddb8001089bd171de7bac23b5e012e2f4302d5a8b7469f0e80589ff46f3422e55d4b205a41718e8e5315ac735584d50cce4cd1f7b5b997714d176991100e9150730187d330009984bbf980f2362bc0972d8f8fb323b10165de0827d13c3cb2ee95c1b71451ec6338397add1b3e57b85a9e0c219ac5c029fedb77cd3ef9cd797dfbf2729b1ad29010c771a4ec393e4f0545a5af2bbf18480807c6ad3d576f8e96b801e0269d4dba88e4e076b64300c8bb79e68b4a9ccec607135acab27fa65d136a0d20a75c60ad477010db6511f312fdb577d3542b4954225f32270645fc23405f4efda151073b53f54aa19c921105b24919504dfdf3ca0a27cf5df9128a67cefde2912425d3ede5db19f000ed08d351c0ad4a659a431edecfa8a1b0eefb7266f7f8f34ed836d9a9aa934eff0410f8e915a30528db04bf2a2b981dcafd41ae0f1dcf994fd76fec58ace113193010fe714d92060df8e8d48d89f9aa9d003cfb6fdcc6790c26e9aa1747f2f12b378b30817fa0f43b4a70bab18783853cf63f218f73c1fac5b5cea92f7b8400544464e0110eb41bc27c79098eb77cb7d270aa9b3b8f66f1f75ec48071ae7f39c0a803b63bf1744039b5e391f248b3439d767516329ebfeda9505904ed76c903d5aafa6905c00110094060ae0bd5121e051ab1311916d320e67a06b5a4eec3c08d31ce3795c7e195e08b73834ac75ec50949a28d83444c4e73ff07ef7bc1947a4b9b42b78565cf10000000000f97fd62e00010000000000000000000000000000000000000000000000000000000000000004757383b2c2ade11820000000000000000000000000000000000000000000546f6b656e427269646765010000000c000000000000000000000000ae9d7fe007b3327aa64a32824aaac52c42a6e624",
    // Terra2
    "01000000020d050b4ce2af187dc8d7b0cd6d36d4eba90887a81fff30aeb057c649bc265fe06621114a78c9558e390565dac4d837d5cb857860f6d370c9e408f1af0762791d6f7b01074b62c2c5d26d56b82fc6962829d7da7633bf9e07cf58718a5b447b11cb745f075549839caa3b8d90236c9c07637c5be8ddb019ba83b2fa0cb86f0dfc9b2c444b0108a8d52257078e804104c2ecc72b23a0942b3df2e01d03b7740a66010bca0acd000eba7910884f929c6318a0e160d0dfd677d035ad76ce42960b3dc681458c755400092de35a61294d434906c78bbebe47cc30b8cca40fc43f6f4c76df0d6d894819e9229691826fe6ab0688989cdad2216dd6fc82a73dccfb7fbe7128da47e5aec032010a585eecc77475a17b3cc52fba9c00c8a9f9e17cc35c5102120ef241412de4408c5a5028b84fb51461f291f017b46d70857e27b2158461c31604bca90a7eae3234010bb0b038d88f809b03132c12ab42168095dc9b2adc366b0c2e9f35822c20a2db4a0cfe9505f156239cdf77bde81e4c4b117fbd087e37087b2eb19292895344dbab000cdd40be5b51d5d7eb2c2fd5fcfcc418e5f2b89927129a2e62c4af17b8d1edcfee490b13f507b75d70a96daa7480d196e5126bba2fe5040ee6a4d9f552d017242f010d0b7a14c0150e6a18e83112a64f44df31554d9fa2cf0dffd525df58da0d49bddd362c872fedce7adf9bfe96f165d9276226b74e4233e768bf120740a4ae49f80c000e913f08c48646027cbf517b8a1dd5fee70c067b880911d1eda8bbf11f7d3b895f1123d5abe503e1bfcb238290bb166573a1566b0e537301e78645cb41f53f6019000f805f3572820ec64d6000190e8a6e1f86925b0fbf2df700a595a3bd9ec73cb12901b8c41c662c95d34914657036259cf1ea45ecd6d37f31f3e2816f897d0388130010380ac2e62d0180a862fd46144fa51b84f4771890dc2c466f50be97561d1ca823685c621119009671e6b3adcb1f22532a2d924c5c92630c8544bf7b718997e33a00110f20c75ac1398952c4743d864705d9230d3f9dd1de25d77a0a14bbea00d87b973fa56cbe59762629e2f243c2e4d142dd34937fb7841dac6d0b1636fdd21bb0250012b9472c22e57dda221e2955cb8c11c27de067cf0cdd0475905ca92ea903ea121d1db07e1fb8cdbff46a142d42d9d51f758a88954241b388dd77a9e1e35f84208e0000000000e63a60d800010000000000000000000000000000000000000000000000000000000000000004b8aff76d1bfa735920000000000000000000000000000000000000000000546f6b656e4272696467650100000012a463ad028fb79679cfc8ce1efba35ac0e77b35080a1abe9bebe83461f176b0a3",
    // Algorand
    "01000000020d039e5bf4669d56988cb0230c80ad566f8a24f31980424da3d1cd8c43e480c2ce9502cfead322a38ba14c56c3ebb8f6bc4654ef5c6e9d9c42288f47911e173c9ec20004cdc3ad95be19ae8cf7bdb2ce6c72f3c2b216926210d3c8ac1714f6ebb84e48e92dfe44e7b7263666b8ddea39f15672b6934fc0fe91b238043da6255db3ffdf2b0005022956d962de2bd9113a90a50d2f15e6ba333bd4d0895edbdcb8c0b1420c1bf00f296f5e275cbc5e23ada26387d060afc24d23a489c5d365bbec9a23bc1349430107e5aba49b9d9ca48aa1739907163abbe51239700075051e6e8a08788bf62d76da2fd949b47e79068fdde13305867520362fc068c3954cc49aea4a3b5a6d8a5bca0108dc7424cb82acd69812fc1b80c8282fca998a95a8fc998fc54c9d6a908f1eed99629e45af20b3888ce570bbd7b7d9225c63acd3d73f6dfc85c65b34d4bf72ec3301095cbf8412e12db817ae2cae65d69d5c753e223bcbe12d554373af005eccf4131f718ced9d3f63df04ff75c7c1dfa0979ebc0559c8ec91a0955d4044b1224e9f0f010ac182cce8ddcb2503ee4331d7ce8f4b182195692e13efb989c693c78636b0cdd951a9231923b2b3a6165fc3f023bfa4b396358eb938694792b2277852adb3d2f8000b82b0c8cb647e9a19a20a1dd19250195ebb4c21a863453d425b3215f71e020a31613683874a5583b2d9fe280b8fdce016726edc4b887d9685a6cfaacfdf28a230010c5a2573e0ca2c3135f7b8b59e60b28522ce5f85aadd19e18639685a714c1e67004a9b5f22879912f7bfab0dec7a377247f1f3c9f8ec2c947a77f47ab0fc280f63000d5c74fb6dc919817401ad67c54cce5b1f2d74637177e4b742b05b4b36457109252968cd223cdbb737c2393852b5db2030bfdc0240b628945665122a1ac5c35594000e1e3e9f45e82b444fdccdce0d1c3827098cbdc165e84000b2bddec505846d32cb4fda5f0ad42f1ceb4f34f16d243df56987a6692bc83435eb8938f50a49e0b87601115721ba2b656b5f7292040fcb8a82a7f30d0267bfd9309823a6ad910fd6c2752c3d4853dced57c10ae8cd949258b194eac4e9fa1c92ccd8ce26f0d8944a9409460012992833ad7d51bdc2d64ba6cff99d2f278cc30411cd7dc14a7a0986b1529d471132281d00109125116e77c20997ff783e20ceb3e60dcb357992967fcc17d7979b0000000000a1829dfb00010000000000000000000000000000000000000000000000000000000000000004f55042d3c512d39620000000000000000000000000000000000000000000546f6b656e427269646765010000000867e93fa6c8ac5c819990aa7340c0c16b508abb1178be9b30d024b8ac25193d45",
    // NEAR
    "01000000020d009391f4e4d74d097dbaae292a2191e1b3e47505d444f1eee2e7727a5d1541de0402fbcecfcb0898b61b1422a3e7c541ec8c84472c38e6ffe38fdad9ce32e2f341010388096b8c078d1a7930af3faddbd22480da3fd5df5830adbd4ed05ebfce6b9f7b5968b5db7cbf8ad3900af6bad8622a8c02324506b810f57c02602b6b98018e120004613497daf624ce8be2ff970781ea010f13e1ae73fbaaf82d4f2618189c91606269a2b99bc2e39400045d4d677f71349178c1578ba07b24f466448dd5098202bc00062087876f4a43e2f055a7a2b81abcb2816939ce32a2ce95ee39fa625b7bdfc9022e4c71a85267f2f920362c655247cca60819dc1b354993996f2e9a78888eb818000881c3aab03ef0206be2f29527fdd4fb8ad98529f21f46ee2ebed71705d34c5e422028a1c80ee0f87e1494d9221c411499ed17f273c64ff1458473e781fba5066001096b3bb76d7c3ddb5adf8468cbd0a3b6a6d9ebadcbc10e29a0d4f30e2905ad70a16f9f7d9fec52e90ef8f48ce0428a5a85d8cfc008354c4ad9794f2b96c0c614de010a4e23ace80190db70f3e615313b496a00bc80e40a01e25dbf57f1804f92185bf9771c1ea60165ca0d95a966b31184e6ab4a4b6b83e82a13f9e7466758dbd8ac44010bfa285466156cb293354ab79769e630085398e3abe0253c8b4a137c3bf96f901379ceb2f64f81f4d2c84ee7b14b2fcd9d73e4b6ed27197545035cddded73f9dc7000c42734a51ab194546481119c903947e49889b850540bb6d323222fed217e52cc535bc298eeebf99ce3921b96b71efad06959381d88b439ccc4ba466e32d5fb231000d2c561108c7bb1ab410f99697d58326f0e8af256ab988f98b4e5e3193e4bb9ab9427f0ed9a6dad9c5ab39fce63b52cf514c1118822a90f17fa89ab089ca480a17000ec8487d16115af83481d4615eec4a19afaacc191bb096f5fc010bcfe263bfc08e03748c79148784f53012e83fbbbaed66e4dfe3430f92133ae1d09648b444b915010fb5eba88f84850b20b9d55e96584e6718f792c53356e1a6b31855e611b41d7f706a0943c1d436ca7f279bcfdf4774819ec347aabf6d4a4bd97d5ae31f43ab25060010a0598060028e75922dfc01258dd8db848ab05418f0b94fd13ca35c4ab0b7d64f4e2737a104d8e2bd33f3626f9aad62440d6f1f20da1bd6baae3fa505d8e107ba0100000000bb04e8af00010000000000000000000000000000000000000000000000000000000000000004cd25ad66b4c6a6fd20000000000000000000000000000000000000000000546f6b656e427269646765010000000f148410499d3fcda4dcfd68a1ebfcdddda16ab28326448d4aae4d2f0465cdfcb7",
    // Moonbeam
    "01000000020d02f227a85a34547b42fca183d7f60177f40756acc43da1e07ef7ce97ed049e484e6f6a608e3ab2a999c5ecdddcc0ff81f3d512912ecd48b409733af707b6dc06bd0003355de163fab102bf7cd43c25d7798c700aceb0263c6391b85c40c51c6d99be6b331fbdc608af5198180cd9dee0be0c9cd33dc513680eff1600b2717b95eb50f200044b06b8bf20fc7227dac43c351a56e84895c2df902aecd7fb21b09b362a43950c417eeb96244f154805eb0e3e7aeb0e912eb04c6f91b5c93235fe657f3b2968450105b8f0069024af922ec28203751d85bcff3a0736b61e553e50b94aea6b003e3bd538dabf99df5eb02f4390b36c975cc22d9ec1ed9d66774e8e882283cabe7b03e40106c22fa08c2eb0fc8e28640a2e7732d5f06ac656b613e8861b1e342790bfc7b40a3b981fdd0798b4150c8ac3b05e34e1c940af78fd9500e7d2c75c10b8084b420f0107884cce4eebd5db26f363ac1c97edfe1bf95d544739ea492a5e30a6246721ac8561c34f99b5d902872b8b1b09b1ca0481cd6498ad3b3cf2e845f773b1820693b201084d62ae956caecbaef4b8ed908aa6f817e48856e2e7f7446a349beabb5c159fc863cbb120957f7850f989f30922dcb17dbaf0bb98cda0b493c9fbf073077342fc00094cb45d8970a5c44b72cdc8ebb689fb723b5b9f659e87f1d67e287e0b699b0bb24cb65f3840ee5a312c63c38ed5f1c8e4c047c245b5e9749687c241125bb6723c000c208a03e49cd9e227650076609bb008d35fd055ac0bba9aefe99b05f09a9d758445c619447437c80aa08d8b2844998b3e38e69be4cf5aced1d260e7e809ce5557010dd5c5d0b921dab5c3de31059ffd1fba74d641720483a70c5c91c3db59cf6d15f85f02aa9a44e3e8b251aa2bd40d7710d8fa676782b3532db336c18a0f0d1a2c26000f32577ed3aaf4da367aae825879f0f51fa8cd71bf728b3d4de63d3e5dd10059310766b33d8c2cb90be1d801503edc91b5660eb7335e0bb19d8cd9a3c8a3de0cba0110f0462f01960ab426f8d916e264e5343e3b9250925c3779b2e204176063e06d4509ea88141d8e1e3b614ba913221cbae44d336c2793e71f501ddcbfe0aed57b1c0011369224f3ff8e81c6a9fb261e89917ef6d30aea54993c41fedac0ee39a321bb3b559a42a08a98cd98509aa72975dad806c85d0661b8b50915f73437ed42bfb83c0100000000c06d7c3d0001000000000000000000000000000000000000000000000000000000000000000455f2d6158fde6ffa20000000000000000000000000000000000000000000546f6b656e4272696467650100000010000000000000000000000000b1731c586ca89a23809861c6103f0b96b3f57d92",
  ],
};

for (const [contract, registrations] of Object.entries(
  contract_registrations
)) {
  console.log(`Registering chains for ${contract}:`);
  for (const registration of registrations) {
    await wallet
      .createAndSignTx({
        msgs: [
          new MsgExecuteContract(
            wallet.key.accAddress,
            addresses[contract],
            {
              submit_vaa: {
                data: Buffer.from(registration, "hex").toString("base64"),
              },
            },
            { axpla: 1700000000000000000 }
          ),
        ],
        memo: "",
      })
      .then((tx) => client.tx.broadcast(tx))
      .then((rs) => console.log(rs));
    await sleep(5000);
  }
}

'''
'''--- lib/wormhole/cosmwasm/tools/migrate.js ---
import { Wallet, LCDClient, MnemonicKey } from "@terra-money/terra.js";
import {
  StdFee,
  MsgExecuteContract,
  MsgInstantiateContract,
  MsgMigrateContract,
  MsgStoreCode,
  MsgUpdateContractAdmin,
} from "@terra-money/terra.js";
import { readFileSync, readdirSync } from "fs";

async function main() {
  const terra = new LCDClient({
    URL: "http://localhost:1317",
    chainID: "localterra",
  });

  const wallet = terra.wallet(
    new MnemonicKey({
      mnemonic:
        "notice oak worry limit wrap speak medal online prefer cluster roof addict wrist behave treat actual wasp year salad speed social layer crew genius",
    })
  );

  const hardcodedGas = {
    "wormhole.wasm": 5000000,
  };
  // Deploy Wormhole alone.
  const file = "wormhole.wasm";
  const contract_bytes = readFileSync(`../artifacts/${file}`);
  console.log(`Storing WASM: ${file} (${contract_bytes.length} bytes)`);

  // Get new code id.
  const store_code = new MsgStoreCode(
    wallet.key.accAddress,
    contract_bytes.toString("base64")
  );

  const codeIds = {};
  try {
    const tx = await wallet.createAndSignTx({
      msgs: [store_code],
      memo: "",
      fee: new StdFee(hardcodedGas["wormhole.wasm"], {
        uluna: "100000",
      }),
    });

    const rs = await terra.tx.broadcast(tx);
    const ci = /"code_id","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    codeIds[file] = parseInt(ci);
  } catch (e) {
    console.log("Failed to Execute");
  }

  // Perform a Centralised update.
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgMigrateContract(
          wallet.key.accAddress,
          "terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5",
          codeIds["wormhole.wasm"],
          {
              "action": ""
          },
          { uluna: 1000 }
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  await wallet
    .createAndSignTx({
      msgs: [
        new MsgMigrateContract(
          wallet.key.accAddress,
          "terra10pyejy66429refv3g35g2t7am0was7ya7kz2a4",
          codeIds["token_bridge.wasm"],
          {
              "action": ""
          },
          { uluna: 1000 }
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  // Set the Admin to the contract.
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgUpdateContractAdmin(
          wallet.key.accAddress,
          "terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5",
          "terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5"
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  // Deploy a new CodeID.
  try {
    const tx = await wallet.createAndSignTx({
      msgs: [store_code],
      memo: "",
      fee: new StdFee(hardcodedGas["wormhole.wasm"], {
        uluna: "100000",
      }),
    });

    const rs = await terra.tx.broadcast(tx);
    const ci = /"code_id","value":"([^"]+)/gm.exec(rs.raw_log)[1];
    codeIds[file] = parseInt(ci);
  } catch (e) {
    console.log("Failed to Execute");
  }

  // Perform a Guardian Set Upgrade to check the following
  // flow with six guardians rather than the default one.
  const guardianUpgradeVAA = '01000000000100f8547caf1d1263e6b4742aef05691a9e2a7aa082bb2f1deb3850e43b801a87044cf786924d8adff5553f31b41149f94a32b568321390450f12c31aa15c2f941101000000010000000100010000000000000000000000000000000000000000000000000000000000000004000000000227cc370000000000000000000000000000000000000000000000000000000000436f72650200000000000106befa429d57cd18b7f8a4d91a2da9ab4af05d0fbe4ba0c2db9a26208b3bb1a50b01b16941c10d76db4ba0c2db9a26208b3bb1a50b01b16941c10d76db4ba0c2db9a26208b3bb1a50b01b16941c10d76db4ba0c2db9a26208b3bb1a50b01b16941c10d76db4ba0c2db9a26208b3bb1a50b01b16941c10d76db';

  await wallet
    .createAndSignTx({
      msgs: [
        new MsgExecuteContract(
          wallet.key.accAddress,
          "terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5",
          {
            submit_v_a_a: {
              vaa: Buffer.from(guardianUpgradeVAA, "hex").toString(
                "base64"
              ),
            },
          },
          { uluna: 1000 }
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  // Upgrace VAA with 5 signatures to test qurom threshold.
  const upgradeVAA = '0100000001050058f5e6a55261e137b12405eb5acf3e4670101c3b7561c6694d7116b6afec85b153f90992fb5e0d6d5a79506f524324fb21894ef655367cc37a572b07a9bfe43301011dba8dca119605dcd30efaf7c4f6980afdf5d58f9625648b652288505abe19be11eabe7424e69d3dae682a84c58208237a975c5ed7757613f546763e14db621200021dba8dca119605dcd30efaf7c4f6980afdf5d58f9625648b652288505abe19be11eabe7424e69d3dae682a84c58208237a975c5ed7757613f546763e14db621200031dba8dca119605dcd30efaf7c4f6980afdf5d58f9625648b652288505abe19be11eabe7424e69d3dae682a84c58208237a975c5ed7757613f546763e14db621200041dba8dca119605dcd30efaf7c4f6980afdf5d58f9625648b652288505abe19be11eabe7424e69d3dae682a84c58208237a975c5ed7757613f546763e14db6212000000000100000001000100000000000000000000000000000000000000000000000000000000000000040000000000a653200000000000000000000000000000000000000000000000000000000000436f72650100030000000000000000000000000000000000000000000000000000000000000005';

  // Perform a decentralised update with a signed VAA.
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgExecuteContract(
          wallet.key.accAddress,
          "terra18vd8fpwxzck93qlwghaj6arh4p7c5n896xzem5",
          {
            submit_v_a_a: {
              vaa: Buffer.from(upgradeVAA, "hex").toString(
                "base64"
              ),
            },
          },
          { uluna: 1000 }
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  // Set the Admin of the Token Bridge to itself.
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgUpdateContractAdmin(
          wallet.key.accAddress,
          "terra10pyejy66429refv3g35g2t7am0was7ya7kz2a4",
          "terra10pyejy66429refv3g35g2t7am0was7ya7kz2a4"
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));

  // Upgrade VAA for the Token Bridge.
  const upgradeTokenVAA = '01000000010500088c284fe2adf0976511290902cbb1dd29239dcd9cb343936c8e76825777db0912eecb7d1be70ddc8b15091834bc0626ea52cc82a202c71f1dc2ff6acffa111b0101b9c36107b2fa1ad413ec6a71aca58d4cd44dea28b692c242805ff0c6df7ce0cb5648f92f5a17a1e1cd2e6df89abb236716d9556a03e6ec5d2ad463cd326d1b830102b9c36107b2fa1ad413ec6a71aca58d4cd44dea28b692c242805ff0c6df7ce0cb5648f92f5a17a1e1cd2e6df89abb236716d9556a03e6ec5d2ad463cd326d1b830103b9c36107b2fa1ad413ec6a71aca58d4cd44dea28b692c242805ff0c6df7ce0cb5648f92f5a17a1e1cd2e6df89abb236716d9556a03e6ec5d2ad463cd326d1b830104b9c36107b2fa1ad413ec6a71aca58d4cd44dea28b692c242805ff0c6df7ce0cb5648f92f5a17a1e1cd2e6df89abb236716d9556a03e6ec5d2ad463cd326d1b8301000000010000000100010000000000000000000000000000000000000000000000000000000000000004000000000441f94100000000000000000000000000000000000000000000546f6b656e4272696467650200030000000000000000000000000000000000000000000000000000000000000005';

  // Perform a decentralised update with a signed VAA.
  await wallet
    .createAndSignTx({
      msgs: [
        new MsgExecuteContract(
          wallet.key.accAddress,
          "terra10pyejy66429refv3g35g2t7am0was7ya7kz2a4",
          {
            submit_vaa: {
              data: Buffer.from(upgradeTokenVAA, "hex").toString(
                "base64"
              ),
            },
          },
          { uluna: 1000 }
        ),
      ],
      memo: "",
    })
    .then((tx) => terra.tx.broadcast(tx))
    .then((rs) => console.log(rs));
}

main();

'''
'''--- lib/wormhole/cosmwasm/tools/migrate_testnet.js ---
import { LCDClient, MnemonicKey } from "@terra-money/terra.js";
import {
  MsgMigrateContract,
} from "@terra-money/terra.js";
import axios from "axios";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

export const TERRA_GAS_PRICES_URL = "https://fcd.terra.dev/v1/txs/gas_prices";

const argv = yargs(hideBin(process.argv))
  .option('code_id', {
    description: 'Which code id to upgrade to',
    type: 'number',
  })
  .option('mnemonic', {
    description: 'Mnemonic (private key)',
    type: 'string',
    required: true
  })
  .option('contract', {
    description: 'Contract to upgrade',
    type: 'string',
    required: true
  })
  .help()
  .alias('help', 'h').argv;

/* Set up terra client & wallet */

const terra_host = {
  URL: "https://bombay-lcd.terra.dev",
  chainID: "bombay-12",
  name: "testnet",
};

const lcd = new LCDClient(terra_host);

const feeDenoms = ["uluna"];

const gasPrices = await axios
  .get(TERRA_GAS_PRICES_URL)
  .then((result) => result.data);

const wallet = lcd.wallet(
  new MnemonicKey({
    mnemonic: argv.mnemonic
  })
);

await wallet.sequence();

/* Do upgrade */

const tx = await wallet.createAndSignTx({
  msgs: [
    new MsgMigrateContract(
      wallet.key.accAddress,
      argv.contract,
      argv.code_id,
      {
        "action": ""
      },
      { uluna: 1000 }
    ),
  ],
  memo: "",
  feeDenoms,
  gasPrices,
});

const rs = await lcd.tx.broadcast(tx);
console.log(rs);

'''
'''--- lib/wormhole/ethereum/devnet_mnemonic.txt ---
myth like bonus scare over problem client lizard pioneer submit female collect

'''
'''--- lib/wormhole/ethereum/migrations/10_deploy_batched_vaa_sender.js ---
require('dotenv').config({ path: "../.env" });

const Wormhole = artifacts.require("Wormhole");
const MockBatchedVAASender = artifacts.require("MockBatchedVAASender");

module.exports = async function (deployer, network, accounts) {

    await deployer.deploy(MockBatchedVAASender)

    const contract = new web3.eth.Contract(MockBatchedVAASender.abi, MockBatchedVAASender.address);

    await contract.methods.setup(
        Wormhole.address
    ).send({from: accounts[0]})
};

'''
'''--- lib/wormhole/ethereum/migrations/1_initial_migration.js ---
var Migrations = artifacts.require("Migrations");

module.exports = function(deployer) {
    // Deploy the Migrations contract as our only task
    deployer.deploy(Migrations);
};
'''
'''--- lib/wormhole/ethereum/migrations/2_deploy_wormhole.js ---
require('dotenv').config({ path: "../.env" });

const Setup = artifacts.require("Setup");
const Implementation = artifacts.require("Implementation");
const Wormhole = artifacts.require("Wormhole");

// CONFIG
const initialSigners = JSON.parse(process.env.INIT_SIGNERS);
const chainId = process.env.INIT_CHAIN_ID;
const governanceChainId = process.env.INIT_GOV_CHAIN_ID;
const governanceContract = process.env.INIT_GOV_CONTRACT; // bytes32
const evmChainId = process.env.INIT_EVM_CHAIN_ID;

module.exports = async function (deployer) {
    // deploy setup
    await deployer.deploy(Setup);

    // deploy implementation
    await deployer.deploy(Implementation);

    // encode initialisation data
    const setup = new web3.eth.Contract(Setup.abi, Setup.address);
    const initData = setup.methods.setup(
        Implementation.address,
        initialSigners,
        chainId,
        governanceChainId,
        governanceContract,
        evmChainId
    ).encodeABI();

    // deploy proxy
    await deployer.deploy(Wormhole, Setup.address, initData);
};

'''
'''--- lib/wormhole/ethereum/migrations/3_deploy_bridge.js ---
require('dotenv').config({ path: "../.env" });

const TokenBridge = artifacts.require("TokenBridge");
const BridgeImplementation = artifacts.require("BridgeImplementation");
const BridgeSetup = artifacts.require("BridgeSetup");
const TokenImplementation = artifacts.require("TokenImplementation");
const Wormhole = artifacts.require("Wormhole");

const chainId = process.env.BRIDGE_INIT_CHAIN_ID;
const governanceChainId = process.env.BRIDGE_INIT_GOV_CHAIN_ID;
const governanceContract = process.env.BRIDGE_INIT_GOV_CONTRACT; // bytes32
const WETH = process.env.BRIDGE_INIT_WETH;
const finality = process.env.BRIDGE_INIT_FINALITY;
const evmChainId = process.env.INIT_EVM_CHAIN_ID;

module.exports = async function (deployer) {
    // deploy token implementation
    await deployer.deploy(TokenImplementation);

    // deploy setup
    await deployer.deploy(BridgeSetup);

    // deploy implementation
    await deployer.deploy(BridgeImplementation);

    // encode initialisation data
    const setup = new web3.eth.Contract(BridgeSetup.abi, BridgeSetup.address);
    const initData = setup.methods.setup(
        BridgeImplementation.address,
        chainId,
        (await Wormhole.deployed()).address,
        governanceChainId,
        governanceContract,
        TokenImplementation.address,
        WETH,
        finality,
        evmChainId
    ).encodeABI();

    // deploy proxy
    await deployer.deploy(TokenBridge, BridgeSetup.address, initData);
};

'''
'''--- lib/wormhole/ethereum/migrations/4_deploy_nft_bridge.js ---
require('dotenv').config({ path: "../.env" });

const TokenBridge = artifacts.require("NFTBridgeEntrypoint");
const BridgeImplementation = artifacts.require("NFTBridgeImplementation");
const BridgeSetup = artifacts.require("NFTBridgeSetup");
const TokenImplementation = artifacts.require("NFTImplementation");
const Wormhole = artifacts.require("Wormhole");

const chainId = process.env.BRIDGE_INIT_CHAIN_ID;
const governanceChainId = process.env.BRIDGE_INIT_GOV_CHAIN_ID;
const governanceContract = process.env.BRIDGE_INIT_GOV_CONTRACT; // bytes32
const finality = process.env.BRIDGE_INIT_FINALITY;
const evmChainId = process.env.INIT_EVM_CHAIN_ID;

module.exports = async function (deployer) {
    // deploy token implementation
    await deployer.deploy(TokenImplementation);

    // deploy setup
    await deployer.deploy(BridgeSetup);

    // deploy implementation
    await deployer.deploy(BridgeImplementation);

    // encode initialisation data
    const setup = new web3.eth.Contract(BridgeSetup.abi, BridgeSetup.address);
    const initData = setup.methods.setup(
        BridgeImplementation.address,
        chainId,
        (await Wormhole.deployed()).address,
        governanceChainId,
        governanceContract,
        TokenImplementation.address,
        finality,
        evmChainId
    ).encodeABI();

    // deploy proxy
    await deployer.deploy(TokenBridge, BridgeSetup.address, initData);
};

'''
'''--- lib/wormhole/ethereum/migrations/6_deploy_bridge_implementation_only.js ---
// run with:
// npm run deploy-bridge-implementation-only
// e.g. Ethereum Mainnet
// INFURA_KEY="" MNEMONIC="" npm run deploy-bridge-implementation-only -- --network mainnet
// e.g. BSC
// MNEMONIC="" npm run deploy-bridge-implementation-only -- --network binance
// e.g. Polygon
// MNEMONIC="" npm run deploy-bridge-implementation-only -- --network polygon
const BridgeImplementation = artifacts.require("BridgeImplementation");
module.exports = async function(deployer, network) {
  if (network === "test") return;
  await deployer.deploy(BridgeImplementation);
};

'''
'''--- lib/wormhole/ethereum/migrations/7_deploy_token_implementation_only.js ---
// run with:
// npm run deploy-token-implementation-only
// e.g. Ethereum Mainnet
// INFURA_KEY="" MNEMONIC="" npm run deploy-token-implementation-only -- --network mainnet
// e.g. BSC
// MNEMONIC="" npm run deploy-token-implementation-only -- --network binance
// e.g. Polygon
// MNEMONIC="" npm run deploy-token-implementation-only -- --network polygon
const TokenImplementation = artifacts.require("TokenImplementation");
module.exports = async function(deployer, network) {
  if (network === "test") return;
  await deployer.deploy(TokenImplementation);
};

'''
'''--- lib/wormhole/ethereum/migrations/9_deploy_weth9.js ---
var WETH9 = artifacts.require("MockWETH9");

module.exports = function(deployer) {
    deployer.deploy(WETH9);
};

'''
'''--- lib/wormhole/ethereum/mine.js ---
/*
    This script advances Ganache network state. It runs as a sidecar pod alongside the devnet and
    ensures that manual token transfers triggered through the web UI will be able to be confirmed.
 */

advanceBlock = () => {
    return new Promise((resolve, reject) => {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_mine",
            id: new Date().getTime()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            const newBlockHash = web3.eth.getBlock('latest').hash;

            return resolve(newBlockHash)
        });
    });
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = function(callback) {
    const fn = async () => {
        while (true) {
            console.log(await advanceBlock());
            await sleep(1000);
        }
    }

    fn().catch(reason => console.error(reason))
}

'''
'''--- lib/wormhole/ethereum/scripts/deploy_batched_vaa_sender.js ---
const Wormhole = artifacts.require("Wormhole");
const MockBatchedVAASender = artifacts.require("MockBatchedVAASender");

module.exports = async function(callback) {
  try {
    const accounts = await web3.eth.getAccounts();

    await MockBatchedVAASender.deploy();

    // devnet contract address should be deterministic
    if (MockBatchedVAASender.address !== "0xf19a2a01b70519f67adb309a994ec8c69a967e8b") {
      throw new Error("unexpected batched-VAA contract address");
    }

    const batchedSender = new web3.eth.Contract(MockBatchedVAASender.abi, MockBatchedVAASender.address);
    await batchedSender.methods.setup(Wormhole.address).send({from: accounts[0]});

    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/deploy_core_bridge.js ---
const Implementation = artifacts.require("Implementation");
module.exports = async function(callback) {
  try {
    const bridge = (await Implementation.new());
    console.log('tx: ' + bridge.transactionHash);
    console.log('Implementation address: ' + bridge.address);
    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/deploy_nft_bridge.js ---
const BridgeImplementation = artifacts.require("NFTBridgeImplementation");
module.exports = async function(callback) {
  try {
    const bridge = (await BridgeImplementation.new());
    console.log('tx: ' + bridge.transactionHash);
    console.log('NFTBridge address: ' + bridge.address);
    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/deploy_test_token.js ---
// run this script with truffle exec

const ERC20 = artifacts.require("ERC20PresetMinterPauser");
const ERC721 = artifacts.require("ERC721PresetMinterPauserAutoId");

const interateToStandardTransactionCount = async () => {
  const accounts = await web3.eth.getAccounts();

  const transactionCount = await web3.eth.getTransactionCount(
    accounts[0],
    "latest"
  );
  console.log(
    "transaction count prior to test token deploys: ",
    transactionCount
  );

  const transactionsToBurn = 32 - transactionCount;
  const promises = [];
  for (let i = 0; i < transactionsToBurn; i++) {
    promises.push(
      web3.eth.sendTransaction({
        to: accounts[0],
        from: accounts[0],
        value: 530,
      })
    );
  }

  await Promise.all(promises);

  const burnCount = await web3.eth.getTransactionCount(accounts[0], "latest");

  console.log("transaction count after burn: ", burnCount);

  return Promise.resolve();
};

module.exports = async function(callback) {
  try {
    const accounts = await web3.eth.getAccounts();

    //Contracts deployed via this script deploy to an address which is determined by the number of transactions
    //which have been performed on the chain.
    //This is, however, variable. For example, if you optionally deploy contracts, more transactions are
    //performed than if you didn't.
    //In order to make sure the test contracts deploy to a location
    //which is deterministic with regard to other environment conditions, we fire bogus transactions up to a safe
    //count, currently 32, before deploying the test contracts.
    await interateToStandardTransactionCount();

    // deploy token contract
    const tokenAddress = (await ERC20.new("Ethereum Test Token", "TKN"))
      .address;
    const token = new web3.eth.Contract(ERC20.abi, tokenAddress);

    console.log("Token deployed at: " + tokenAddress);

    // mint 1000 units
    await token.methods.mint(accounts[0], "1000000000000000000000").send({
      from: accounts[0],
      gas: 1000000,
    });

    const nftAddress = (
      await ERC721.new(
        "Not an APE 🐒",
        "APE🐒",
        "https://cloudflare-ipfs.com/ipfs/QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/"
      )
    ).address;
    const nft = new web3.eth.Contract(ERC721.abi, nftAddress);
    await nft.methods.mint(accounts[0]).send({
      from: accounts[0],
      gas: 1000000,
    });
    await nft.methods.mint(accounts[0]).send({
      from: accounts[0],
      gas: 1000000,
    });

    console.log("NFT deployed at: " + nftAddress);

    const MockWETH9 = await artifacts.require("MockWETH9");
    //WETH deploy
    // deploy token contract
    const wethAddress = (await MockWETH9.new()).address;
    const wethToken = new web3.eth.Contract(MockWETH9.abi, wethAddress);

    console.log("WETH token deployed at: " + wethAddress);

    for (let idx = 2; idx < 10; idx++) {
      await token.methods.mint(accounts[idx], "1000000000000000000000").send({
        from: accounts[0],
        gas: 1000000,
      });
    }

    // devnet WETH token address should be deterministic
    if (wethAddress !== "0xDDb64fE46a91D46ee29420539FC25FD07c5FEa3E") {
      throw new Error("unexpected WETH token address");
    }

    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/deploy_token_bridge.js ---
const BridgeImplementation = artifacts.require("BridgeImplementation");
module.exports = async function(callback) {
  try {
    const bridge = (await BridgeImplementation.new());
    console.log('tx: ' + bridge.transactionHash);
    console.log('Bridge address: ' + bridge.address);
    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/register_algo_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync(
    "../build/contracts/BridgeImplementation.json"
).abi;
const algoTokenBridgeVAA = process.env.REGISTER_ALGO_TOKEN_BRIDGE_VAA;

module.exports = async function(callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(
            BridgeImplementationFullABI,
            TokenBridge.address
        );

        // Register the ALGO endpoint
        await initialized.methods
            .registerChain("0x" + algoTokenBridgeVAA)
            .send({
                value: 0,
                from: accounts[0],
                gasLimit: 2000000,
            });

        callback();
    } catch (e) {
        callback(e);
    }
};

'''
'''--- lib/wormhole/ethereum/scripts/register_aptos_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync(
    "../build/contracts/BridgeImplementation.json"
).abi;
const aptosTokenBridgeVAA = process.env.REGISTER_APTOS_TOKEN_BRIDGE_VAA;

module.exports = async function(callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(
            BridgeImplementationFullABI,
            TokenBridge.address
        );

        // Register the APTOS endpoint
        await initialized.methods
            .registerChain("0x" + aptosTokenBridgeVAA)
            .send({
                value: 0,
                from: accounts[0],
                gasLimit: 2000000,
            });

        callback();
    } catch (e) {
        callback(e);
    }
};

'''
'''--- lib/wormhole/ethereum/scripts/register_bsc_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync("../build/contracts/BridgeImplementation.json").abi
const bscTokenBridgeVAA = process.env.REGISTER_BSC_TOKEN_BRIDGE_VAA

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        // Register the BSC endpoint
        await initialized.methods.registerChain("0x" + bscTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        callback();
    }
    catch (e) {
        callback(e);
    }
}

'''
'''--- lib/wormhole/ethereum/scripts/register_eth_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync("../build/contracts/BridgeImplementation.json").abi
const ethTokenBridgeVAA = process.env.REGISTER_ETH_TOKEN_BRIDGE_VAA

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        // Register the ETH endpoint
        await initialized.methods.registerChain("0x" + ethTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        callback();
    }
    catch (e) {
        callback(e);
    }
}

'''
'''--- lib/wormhole/ethereum/scripts/register_near_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const BridgeImplementationFullABI = jsonfile.readFileSync(
    "../build/contracts/BridgeImplementation.json"
).abi;
const nearTokenBridgeVAA = process.env.REGISTER_NEAR_TOKEN_BRIDGE_VAA;

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const tokenBridge = new web3.eth.Contract(
            BridgeImplementationFullABI,
            TokenBridge.address
        );

        // Register the near token bridge endpoint
        await tokenBridge.methods.registerChain("0x" + nearTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000,
        });

        callback();
    } catch (e) {
        callback(e);
    }
};

'''
'''--- lib/wormhole/ethereum/scripts/register_solana_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const NFTBridge = artifacts.require("NFTBridgeEntrypoint");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync("../build/contracts/BridgeImplementation.json").abi
const solTokenBridgeVAA = process.env.REGISTER_SOL_TOKEN_BRIDGE_VAA
const solNFTBridgeVAA = process.env.REGISTER_SOL_NFT_BRIDGE_VAA

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const tokenBridge = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const nftBridge = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        // Register the Solana token bridge endpoint
        await tokenBridge.methods.registerChain("0x" + solTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // Register the Solana NFT bridge endpoint
        await nftBridge.methods.registerChain("0x" + solNFTBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        callback();
    }
    catch (e) {
        callback(e);
    }
}

'''
'''--- lib/wormhole/ethereum/scripts/register_terra2_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const BridgeImplementationFullABI = jsonfile.readFileSync(
  "../build/contracts/BridgeImplementation.json"
).abi;
const terra2TokenBridgeVAA = process.env.REGISTER_TERRA2_TOKEN_BRIDGE_VAA;

module.exports = async function (callback) {
  try {
    const accounts = await web3.eth.getAccounts();
    const tokenBridge = new web3.eth.Contract(
      BridgeImplementationFullABI,
      TokenBridge.address
    );

    // Register the terra2 token bridge endpoint
    await tokenBridge.methods.registerChain("0x" + terra2TokenBridgeVAA).send({
      value: 0,
      from: accounts[0],
      gasLimit: 2000000,
    });

    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/scripts/register_terra_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const NFTBridge = artifacts.require("NFTBridgeEntrypoint");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync("../build/contracts/BridgeImplementation.json").abi
const terraTokenBridgeVAA = process.env.REGISTER_TERRA_TOKEN_BRIDGE_VAA
const terraNFTBridgeVAA = process.env.REGISTER_TERRA_NFT_BRIDGE_VAA

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const tokenBridge = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const nftBridge = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        // Register the terra token bridge endpoint
        await tokenBridge.methods.registerChain("0x" + terraTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // Register the terra NFT bridge endpoint
        await nftBridge.methods.registerChain("0x" + terraNFTBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        callback();
    }
    catch (e) {
        callback(e);
    }
}

'''
'''--- lib/wormhole/ethereum/scripts/register_worm_chain.js ---
// run this script with truffle exec

const jsonfile = require("jsonfile");
const TokenBridge = artifacts.require("TokenBridge");
const TokenImplementation = artifacts.require("TokenImplementation");
const BridgeImplementationFullABI = jsonfile.readFileSync("../build/contracts/BridgeImplementation.json").abi;
const wormchainTokenBridgeVAA = process.env.REGISTER_WORMCHAIN_TOKEN_BRIDGE_VAA

module.exports = async function (callback) {
    try {
        const accounts = await web3.eth.getAccounts();
        const tokenBridge = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address
        );

        // Register the wormhole token bridge endpoint
        await tokenBridge.methods.registerChain("0x" + wormchainTokenBridgeVAA).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        callback();
    } catch (e) {
        callback(e);
    }
};

'''
'''--- lib/wormhole/ethereum/scripts/send_batched_vaa.js ---
const MockBatchedVAASender = artifacts.require("MockBatchedVAASender");

module.exports = async function(callback) {
  try {
    const accounts = await web3.eth.getAccounts();

    const batchedSender = await MockBatchedVAASender.deployed()

    const contract = new web3.eth.Contract(MockBatchedVAASender.abi, batchedSender.address);

    const nonce = Math.round(Date.now() / 1000);
    const nonceHex = nonce.toString(16)

    const res = await contract.methods.sendMultipleMessages(
      "0x" + nonceHex,
      "0x1",
      32
    ).send({
      value: 0,
      from: accounts[0]
    });

    console.log('sendMultipleMessages response', res)

    callback();
  } catch (e) {
    callback(e);
  }
};

'''
'''--- lib/wormhole/ethereum/test/bridge.js ---
const jsonfile = require('jsonfile');
const elliptic = require('elliptic');
const BigNumber = require('bignumber.js');

const Wormhole = artifacts.require("Wormhole");
const TokenBridge = artifacts.require("TokenBridge");
const BridgeImplementation = artifacts.require("BridgeImplementation");
const TokenImplementation = artifacts.require("TokenImplementation");
const FeeToken = artifacts.require("FeeToken");
const MockBridgeImplementation = artifacts.require("MockBridgeImplementation");
const MockTokenBridgeIntegration = artifacts.require("MockTokenBridgeIntegration");
const MockWETH9 = artifacts.require("MockWETH9");

const testSigner1PK = "cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0";
const testSigner2PK = "892330666a850761e7370376430bb8c2aa1494072d3bfeaed0c4fa3d5a9135fe";

const WormholeImplementationFullABI = jsonfile.readFileSync("build/contracts/Implementation.json").abi
const BridgeImplementationFullABI = jsonfile.readFileSync("build/contracts/BridgeImplementation.json").abi
const TokenImplementationFullABI = jsonfile.readFileSync("build/contracts/TokenImplementation.json").abi

const actionContractUpgrade = "02"
const actionRecoverChainId = "03"

const fakeChainId = 1337;
const fakeEvmChainId = 10001;

let lastDeployed;

contract("Bridge", function () {
    const testSigner1 = web3.eth.accounts.privateKeyToAccount(testSigner1PK);
    const testSigner2 = web3.eth.accounts.privateKeyToAccount(testSigner2PK);
    const testChainId = "2";
    const testEvmChainId = "1";
    const testFinality = "1";
    const testGovernanceChainId = "1";
    const testGovernanceContract = "0x0000000000000000000000000000000000000000000000000000000000000004";
    let WETH = process.env.BRIDGE_INIT_WETH;
    const testForeignChainId = "1";
    const testForeignBridgeContract = "0x000000000000000000000000000000000000000000000000000000000000ffff";
    const testBridgedAssetChain = "0001";
    const testBridgedAssetAddress = "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e";

    it("should be initialized with the correct signers and values", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const weth = await initialized.methods.WETH().call();
        assert.equal(weth, WETH);

        const tokenImplentation = await initialized.methods.tokenImplementation().call();
        assert.equal(tokenImplentation, TokenImplementation.address);

        // test beacon functionality
        const beaconImplementation = await initialized.methods.implementation().call();
        assert.equal(beaconImplementation, TokenImplementation.address);

        // chain id
        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, testChainId);

        // evm chain id
        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, testEvmChainId);

        // finality
        const finality = await initialized.methods.finality().call();
        assert.equal(finality, testFinality);

        // governance
        const governanceChainId = await initialized.methods.governanceChainId().call();
        assert.equal(governanceChainId, testGovernanceChainId);
        const governanceContract = await initialized.methods.governanceContract().call();
        assert.equal(governanceContract, testGovernanceContract);
    })

    it("should register a foreign bridge implementation correctly", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        let data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            "01",
            "0000",
            web3.eth.abi.encodeParameter("uint16", testForeignChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("bytes32", testForeignBridgeContract).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await initialized.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(before, "0x0000000000000000000000000000000000000000000000000000000000000000");

        await initialized.methods.registerChain("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await initialized.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(after, testForeignBridgeContract);
    })

    it("should accept a valid upgrade", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        let data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            "02",
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(TokenBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), BridgeImplementation.address.toLowerCase());

        await initialized.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await web3.eth.getStorageAt(TokenBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockBridgeImplementation.abi, TokenBridge.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
        lastDeployed = mock;
    })

    it("bridged tokens should only be mint- and burn-able by owner", async function () {
        const accounts = await web3.eth.getAccounts();

        // initialize our template token contract
        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);

        await token.methods.initialize(
            "TestToken",
            "TT",
            18,
            0,

            accounts[0],

            0,
            "0x0"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        await token.methods.mint(accounts[0], 10).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        await token.methods.burn(accounts[0], 5).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        let failed = false
        try {
            await token.methods.mint(accounts[0], 10).send({
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            failed = true
        }
        assert.ok(failed)

        failed = false
        try {
            await token.methods.burn(accounts[0], 5).send({
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            failed = true
        }
        assert.ok(failed)

        await token.methods.burn(accounts[0], 5).send({
            from: accounts[0],
            gasLimit: 2000000
        });
    })

    it("should attest a token correctly", async function () {
        const accounts = await web3.eth.getAccounts();

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        await initialized.methods.attestToken(TokenImplementation.address, "234").send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);

        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2, 200);

        // payload id
        assert.equal(log.payload.substr(2, 2), "02");

        // token address
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("address", TokenImplementation.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(68, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // decimals
        assert.equal(log.payload.substr(72, 2), web3.eth.abi.encodeParameter("uint8", 18).substring(2 + 64 - 2))

        // symbol (TT)
        assert.equal(log.payload.substr(74, 64), "5454000000000000000000000000000000000000000000000000000000000000")

        // name (TestToken)
        assert.equal(log.payload.substr(138, 64), "54657374546f6b656e0000000000000000000000000000000000000000000000")
    })

    it("should correctly deploy a wrapped asset for a token attestation", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const data = "0x02" +
            // tokenAddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // decimals
            "12" +
            // symbol
            "5454000000000000000000000000000000000000000000000000000000000000" +
            // name
            "54657374546f6b656e0000000000000000000000000000000000000000000000";

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.createWrapped("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const wrappedAddress = await initialized.methods.wrappedAsset("0x0001", "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e").call();

        assert.ok(await initialized.methods.isWrappedAsset(wrappedAddress).call())

        const initializedWrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        const symbol = await initializedWrappedAsset.methods.symbol().call();
        assert.equal(symbol, "TT");

        const name = await initializedWrappedAsset.methods.name().call();
        assert.equal(name, "TestToken");

        const decimals = await initializedWrappedAsset.methods.decimals().call();
        assert.equal(decimals, 18);

        const chainId = await initializedWrappedAsset.methods.chainId().call();
        assert.equal(chainId, 1);

        const nativeContract = await initializedWrappedAsset.methods.nativeContract().call();
        assert.equal(nativeContract, "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");
    })

    it("should correctly update a wrapped asset for a token attestation", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const data = "0x02" +
            // tokenAddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // decimals
            "12" +
            // symbol
            "5555000000000000000000000000000000000000000000000000000000000000" +
            // name
            "5472656500000000000000000000000000000000000000000000000000000000";

        let vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let failed = false;
        try {
            await initialized.methods.updateWrapped("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 2000000
            });
        } catch (error) {
            assert.equal(error.message, "Returned error: VM Exception while processing transaction: revert current metadata is up to date")
            failed = true
        }
        assert.ok(failed)

        vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            1,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.updateWrapped("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const wrappedAddress = await initialized.methods.wrappedAsset("0x0001", "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e").call();

        assert.ok(await initialized.methods.isWrappedAsset(wrappedAddress).call())

        const initializedWrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        const symbol = await initializedWrappedAsset.methods.symbol().call();
        assert.equal(symbol, "UU");

        const name = await initializedWrappedAsset.methods.name().call();
        assert.equal(name, "Tree");

        const decimals = await initializedWrappedAsset.methods.decimals().call();
        assert.equal(decimals, 18);

        const chainId = await initializedWrappedAsset.methods.chainId().call();
        assert.equal(chainId, 1);

        const nativeContract = await initializedWrappedAsset.methods.nativeContract().call();
        assert.equal(nativeContract, "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");
    })

    it("should deposit and log transfers correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";
        const fee = "100000000000000000";

        // mint and approve tokens
        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);
        await token.methods.mint(accounts[0], amount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(TokenBridge.address, amount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const accountBalanceBefore = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceBefore.toString(10), amount);
        assert.equal(bridgeBalanceBefore.toString(10), "0");

        await initialized.methods.transferTokens(
            TokenImplementation.address,
            amount,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            fee,
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceAfter.toString(10), "0");
        assert.equal(bridgeBalanceAfter.toString(10), amount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", TokenImplementation.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // fee
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2))
    })

    it("should deposit and log fee token transfers correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const mintAmount = "10000000000000000000";
        const amount = "1000000000000000000";
        const fee = "100000000000000000";

        // mint and approve tokens
        const deployFeeToken = await FeeToken.new();
        const token = new web3.eth.Contract(FeeToken.abi, deployFeeToken.address);
        await token.methods.initialize(
            "Test",
            "TST",
            "18",
            "123",
            accounts[0],
            "0",
            "0x0000000000000000000000000000000000000000000000000000000000000000"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.mint(accounts[0], mintAmount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(TokenBridge.address, mintAmount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(bridgeBalanceBefore.toString(10), "0");

        await initialized.methods.transferTokens(
            deployFeeToken.address,
            amount,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            fee,
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        let feeAmount = new BigNumber(amount).times(9).div(10)

        assert.equal(bridgeBalanceAfter.toString(10), feeAmount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", feeAmount.div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", deployFeeToken.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // fee
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2))
    })

    it("should transfer out locked assets for a valid transfer vm", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";

        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const accountBalanceBefore = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceBefore.toString(10), "0");
        assert.equal(bridgeBalanceBefore.toString(10), amount);

        const data = "0x" +
            "01" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", TokenImplementation.address).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            "0000000000000000000000000000000000000000000000000000000000000000";

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceAfter.toString(10), amount);
        assert.equal(bridgeBalanceAfter.toString(10), "0");
    })

    it("should deposit and log transfer with payload correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";

        // mint and approve tokens
        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);
        await token.methods.mint(accounts[0], amount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(TokenBridge.address, amount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const accountBalanceBefore = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(bridgeBalanceBefore.toString(10), "0");

        const additionalPayload = "abc123"

        await initialized.methods.transferTokensWithPayload(
            TokenImplementation.address,
            amount,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "234",
            "0x" + additionalPayload
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceAfter.toString(10), new BigNumber(accountBalanceBefore).minus(amount).toString(10));
        assert.equal(bridgeBalanceAfter.toString(10), amount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2 - additionalPayload.length, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "03");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", TokenImplementation.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // from address
        // the actual type is bytes32, but here we use 'address' encoding so that it gets left-padded as expected
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("address", accounts[0]).substring(2))

        // payload
        assert.equal(log.payload.substr(268), additionalPayload)
    })

    it("should transfer out locked assets for a valid transfer with payload vm", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";

        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const accountBalanceBefore = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(bridgeBalanceBefore.toString(10), amount);

        const data = "0x" +
            "03" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", TokenImplementation.address).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            "0000000000000000000000000000000000000000000000000000000000000000" +
            // additional payload
            "abc123";

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransferWithPayload("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await token.methods.balanceOf(accounts[0]).call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(accountBalanceAfter.toString(10), new BigNumber(accountBalanceBefore).plus(amount).toString(10));
        assert.equal(bridgeBalanceAfter.toString(10), "0");
    })

    it("should mint bridged assets wrappers on transfer from another chain and handle fees correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";
        const fee = "1000000000000000";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        const totalSupply = await wrappedAsset.methods.totalSupply().call();
        assert.equal(totalSupply.toString(10), "0");

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "01" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2);

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await wrappedAsset.methods.balanceOf(accounts[0]).call();
        const senderBalanceAfter = await wrappedAsset.methods.balanceOf(accounts[1]).call();
        const totalSupplyAfter = await wrappedAsset.methods.totalSupply().call();

        assert.equal(accountBalanceAfter.toString(10), new BigNumber(amount).minus(fee).toString(10));
        assert.equal(senderBalanceAfter.toString(10), fee);
        assert.equal(totalSupplyAfter.toString(10), amount);

        await wrappedAsset.methods.transfer(accounts[0], fee).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });
    })

    it("should not allow a redemption from msg.sender other than 'to' on token bridge transfer with payload", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "03" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // receiver (must be self msg.sender)
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // from address
            web3.eth.abi.encodeParameter("address", accounts[2]).substring(2) +
            // additional payload
            web3.eth.abi.encodeParameter("address", accounts[1]).substr(2);

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            1,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let hadSenderError = false
        try {
            await initialized.methods.completeTransferWithPayload("0x" + vm).send({
                value: 0,
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            hadSenderError = e.message.includes('revert invalid sender')
        }
        assert.equal(hadSenderError, true)
    })

    it("should allow a redemption from msg.sender == 'to' on token bridge transfer with payload and check that sender recieves fee", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "1000000000000000000";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        mock = (await MockTokenBridgeIntegration.new()).address;
        const MockIntegration = new web3.eth.Contract(MockTokenBridgeIntegration.abi, mock);
        await MockIntegration.methods.setup(TokenBridge.address).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        const accountBalanceBefore = await wrappedAsset.methods.balanceOf(accounts[0]).call();
        const senderBalanceBefore = await wrappedAsset.methods.balanceOf(accounts[1]).call();
        const totalSupplyBefore = await wrappedAsset.methods.totalSupply().call();

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "03" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // receiver
            web3.eth.abi.encodeParameter("address", mock).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // from address
            web3.eth.abi.encodeParameter("address", accounts[1]).substring(2) +
            // additional payload
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2);

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            2,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await MockIntegration.methods.completeTransferAndSwap("0x" + vm).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await wrappedAsset.methods.balanceOf(accounts[0]).call();
        const totalSupplyAfter = await wrappedAsset.methods.totalSupply().call();

        assert.equal(accountBalanceAfter.toString(10), new BigNumber(accountBalanceBefore).plus(amount).toString(10));
        assert.equal(totalSupplyAfter.toString(10), new BigNumber(totalSupplyBefore).plus(amount).toString(10));
    })

    it("should burn bridged assets wrappers on transfer to another chain", async function () {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const amount = "2000000000000000000";
        const wrappedFeesPaid = "0";

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(TokenImplementation.abi, wrappedAddress);

        await wrappedAsset.methods.approve(TokenBridge.address, amount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens

        const accountBalanceBefore = await wrappedAsset.methods.balanceOf(accounts[0]).call();

        assert.equal(accountBalanceBefore.toString(10), amount);

        await initialized.methods.transferTokens(
            wrappedAddress,
            amount,
            "11",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "0",
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await wrappedAsset.methods.balanceOf(accounts[0]).call();
        assert.equal(accountBalanceAfter.toString(10), "0");

        const bridgeBalanceAfter = await wrappedAsset.methods.balanceOf(TokenBridge.address).call();
        assert.equal(bridgeBalanceAfter.toString(10), "0");

        const totalSupplyAfter = await wrappedAsset.methods.totalSupply().call();
        assert.equal(totalSupplyAfter.toString(10), wrappedFeesPaid);
    })

    it("should handle ETH deposits correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "100000000000000000";
        const fee = "10000000000000000";

        // mint and approve tokens
        WETH = (await MockWETH9.new()).address;
        const token = new web3.eth.Contract(MockWETH9.abi, WETH);

        // set WETH contract
        const mock = new web3.eth.Contract(MockBridgeImplementation.abi, TokenBridge.address);
        mock.methods.testUpdateWETHAddress(WETH).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const totalWETHSupply = await token.methods.totalSupply().call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(totalWETHSupply.toString(10), "0");
        assert.equal(bridgeBalanceBefore.toString(10), "0");

        await initialized.methods.wrapAndTransferETH(
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            fee,
            "234"
        ).send({
            value: amount,
            from: accounts[0],
            gasLimit: 2000000
        });

        const totalWETHSupplyAfter = await token.methods.totalSupply().call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(totalWETHSupplyAfter.toString(10), amount);
        assert.equal(bridgeBalanceAfter.toString(10), amount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", WETH).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // fee
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2))
    })

    it("should handle ETH withdrawals and fees correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "100000000000000000";
        const fee = "50000000000000000";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const token = new web3.eth.Contract(MockWETH9.abi, WETH);

        const totalSupply = await token.methods.totalSupply().call();
        assert.equal(totalSupply.toString(10), amount);

        const feeRecipientBalanceBefore = await web3.eth.getBalance(accounts[0]);
        const accountBalanceBefore = await web3.eth.getBalance(accounts[1]);

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "01" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", WETH).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[1]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2);

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        const transferTX = await initialized.methods.completeTransferAndUnwrapETH("0x" + vm).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        const totalSupplyAfter = await token.methods.totalSupply().call();
        assert.equal(totalSupplyAfter.toString(10), "0");

        const accountBalanceAfter = await web3.eth.getBalance(accounts[1]);
        const feeRecipientBalanceAfter = await web3.eth.getBalance(accounts[0]);

        assert.equal((new BigNumber(accountBalanceAfter)).minus(accountBalanceBefore).toString(10), (new BigNumber(amount)).minus(fee).toString(10))
        assert.ok((new BigNumber(feeRecipientBalanceAfter)).gt(feeRecipientBalanceBefore))
    })

    it("should handle ETH deposits with payload correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "100000000000000000";

        // mint and approve tokens
        WETH = (await MockWETH9.new()).address;
        const token = new web3.eth.Contract(MockWETH9.abi, WETH);

        // set WETH contract
        const mock = new web3.eth.Contract(MockBridgeImplementation.abi, TokenBridge.address);
        mock.methods.testUpdateWETHAddress(WETH).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const totalWETHSupply = await token.methods.totalSupply().call();
        const bridgeBalanceBefore = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(totalWETHSupply.toString(10), "0");
        assert.equal(bridgeBalanceBefore.toString(10), "0");

        const additionalPayload = "abc123"

        await initialized.methods.wrapAndTransferETHWithPayload(
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "234",
            "0x" + additionalPayload
        ).send({
            value: amount,
            from: accounts[0],
            gasLimit: 2000000
        });

        const totalWETHSupplyAfter = await token.methods.totalSupply().call();
        const bridgeBalanceAfter = await token.methods.balanceOf(TokenBridge.address).call();

        assert.equal(totalWETHSupplyAfter.toString(10), amount);
        assert.equal(bridgeBalanceAfter.toString(10), amount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, TokenBridge.address)

        assert.equal(log.payload.length - 2 - additionalPayload.length, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "03");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", WETH).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // from address
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("address", accounts[0]).substring(2))

        // payload
        assert.equal(log.payload.substr(268), additionalPayload)
    })

    it("should handle ETH withdrawals with payload correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const amount = "100000000000000000";
        const fee = "0";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        const token = new web3.eth.Contract(MockWETH9.abi, WETH);

        const totalSupply = await token.methods.totalSupply().call();
        assert.equal(totalSupply.toString(10), amount);

        const accountBalanceBefore = await web3.eth.getBalance(accounts[0]);

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "03" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", WETH).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).toString()).substring(2) +
            // additional payload
            "abc123"

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        const transferTX = await initialized.methods.completeTransferAndUnwrapETHWithPayload("0x" + vm).send({
            from: accounts[0], //must be same as receiver
            gasLimit: 2000000
        });

        const totalSupplyAfter = await token.methods.totalSupply().call();
        assert.equal(totalSupplyAfter.toString(10), "0");

        const accountBalanceAfter = await web3.eth.getBalance(accounts[0]);

        assert.ok((new BigNumber(accountBalanceAfter)).gt(accountBalanceBefore))
    })

    it("should revert on transfer out of a total of > max(uint64) tokens", async function () {
        const accounts = await web3.eth.getAccounts();
        const supply = "184467440737095516160000000000";
        const firstTransfer = "1000000000000";

        // mint and approve tokens
        const token = new web3.eth.Contract(TokenImplementation.abi, TokenImplementation.address);
        await token.methods.mint(accounts[0], supply).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(TokenBridge.address, supply).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);

        await initialized.methods.transferTokens(
            TokenImplementation.address,
            firstTransfer,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "0",
            "0"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let failed = false;
        try {
            await initialized.methods.transferTokens(
                TokenImplementation.address,
                new BigNumber(supply).minus(firstTransfer).toString(10),
                "10",
                "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
                "0",
                "0"
            ).send({
                value: 0,
                from: accounts[0],
                gasLimit: 2000000
            });
        } catch (error) {
            assert.equal(error.message, "Returned error: VM Exception while processing transaction: revert transfer exceeds max outstanding bridged token amount")
            failed = true
        }

        assert.ok(failed)
    })

    it("should reject smart contract upgrades on forks", async function () {
        const mockInitialized = new web3.eth.Contract(MockBridgeImplementation.abi, TokenBridge.address);
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        // simulate a fork
        await mockInitialized.methods.testOverwriteEVMChainId(fakeChainId, fakeEvmChainId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, fakeChainId);

        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, fakeEvmChainId);

        data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            // Action 1 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        try {
            await initialized.methods.upgrade("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });

            assert.fail("governance packet accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "invalid fork")
        }
    })

    it("should allow recover chain ID governance packets forks", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, fakeChainId);

        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, fakeEvmChainId);

        data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            // Action 3 (Recover Chain ID)
            actionRecoverChainId,
            // EvmChainID
            web3.eth.abi.encodeParameter("uint256", testEvmChainId).substring(2),
            // NewChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        await initialized.methods.submitRecoverChainId("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const newChainId = await initialized.methods.chainId().call();
        assert.equal(newChainId, testChainId);

        const newEvmChainId = await initialized.methods.evmChainId().call();
        assert.equal(newEvmChainId, testEvmChainId);
    })

    it("should accept smart contract upgrades after chain ID has been recovered", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, TokenBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            // Action 2 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(TokenBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), lastDeployed.address.toLowerCase());

        let set = await initialized.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let after = await web3.eth.getStorageAt(TokenBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockBridgeImplementation.abi, TokenBridge.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
    })
});

const signAndEncodeVM = async function (
    timestamp,
    nonce,
    emitterChainId,
    emitterAddress,
    sequence,
    data,
    signers,
    guardianSetIndex,
    consistencyLevel
) {
    const body = [
        web3.eth.abi.encodeParameter("uint32", timestamp).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint32", nonce).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint16", emitterChainId).substring(2 + (64 - 4)),
        web3.eth.abi.encodeParameter("bytes32", emitterAddress).substring(2),
        web3.eth.abi.encodeParameter("uint64", sequence).substring(2 + (64 - 16)),
        web3.eth.abi.encodeParameter("uint8", consistencyLevel).substring(2 + (64 - 2)),
        data.substr(2)
    ]

    const hash = web3.utils.soliditySha3(web3.utils.soliditySha3("0x" + body.join("")))

    let signatures = "";

    for (let i in signers) {
        const ec = new elliptic.ec("secp256k1");
        const key = ec.keyFromPrivate(signers[i]);
        const signature = key.sign(hash.substr(2), { canonical: true });

        const packSig = [
            web3.eth.abi.encodeParameter("uint8", i).substring(2 + (64 - 2)),
            zeroPadBytes(signature.r.toString(16), 32),
            zeroPadBytes(signature.s.toString(16), 32),
            web3.eth.abi.encodeParameter("uint8", signature.recoveryParam).substr(2 + (64 - 2)),
        ]

        signatures += packSig.join("")
    }

    const vm = [
        web3.eth.abi.encodeParameter("uint8", 1).substring(2 + (64 - 2)),
        web3.eth.abi.encodeParameter("uint32", guardianSetIndex).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint8", signers.length).substring(2 + (64 - 2)),

        signatures,
        body.join("")
    ].join("");

    return vm
}

function zeroPadBytes(value, length) {
    while (value.length < 2 * length) {
        value = "0" + value;
    }
    return value;
}

'''
'''--- lib/wormhole/ethereum/test/nft.js ---
const jsonfile = require('jsonfile');
const elliptic = require('elliptic');
const BigNumber = require('bignumber.js');

const Wormhole = artifacts.require("Wormhole");
const NFTBridge = artifacts.require("NFTBridgeEntrypoint");
const NFTBridgeImplementation = artifacts.require("NFTBridgeImplementation");
const NFTImplementation = artifacts.require("NFTImplementation");
const MockBridgeImplementation = artifacts.require("MockNFTBridgeImplementation");

const testSigner1PK = "cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0";
const testSigner2PK = "892330666a850761e7370376430bb8c2aa1494072d3bfeaed0c4fa3d5a9135fe";

const WormholeImplementationFullABI = jsonfile.readFileSync("build/contracts/Implementation.json").abi
const BridgeImplementationFullABI = jsonfile.readFileSync("build/contracts/NFTBridgeImplementation.json").abi
const NFTImplementationFullABI = jsonfile.readFileSync("build/contracts/NFTImplementation.json").abi

const actionContractUpgrade = "02"
const actionRecoverChainId = "03"

const fakeChainId = 1337;
const fakeEvmChainId = 10001;

let lastDeployed;

contract("NFT", function () {
    const testSigner1 = web3.eth.accounts.privateKeyToAccount(testSigner1PK);
    const testSigner2 = web3.eth.accounts.privateKeyToAccount(testSigner2PK);
    const testChainId = "2";
    const testEvmChainId = "1";
    const testFinality = "1";
    const testGovernanceChainId = "1";
    const testGovernanceContract = "0x0000000000000000000000000000000000000000000000000000000000000004";
    let WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
    const testForeignChainId = "1";
    const testForeignBridgeContract = "0x000000000000000000000000000000000000000000000000000000000000ffff";
    const testBridgedAssetChain = "0003";
    const testBridgedAssetAddress = "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e";

    it("should be initialized with the correct signers and values", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        const tokenImplentation = await initialized.methods.tokenImplementation().call();
        assert.equal(tokenImplentation, NFTImplementation.address);

        // test beacon functionality
        const beaconImplementation = await initialized.methods.implementation().call();
        assert.equal(beaconImplementation, NFTImplementation.address);

        // chain id
        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, testChainId);

        // evm chain id
        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, testEvmChainId);

        // finality
        const finality = await initialized.methods.finality().call();
        assert.equal(finality, testFinality);

        // governance
        const governanceChainId = await initialized.methods.governanceChainId().call();
        assert.equal(governanceChainId, testGovernanceChainId);
        const governanceContract = await initialized.methods.governanceContract().call();
        assert.equal(governanceContract, testGovernanceContract);
    })

    it("should register a foreign bridge implementation correctly", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const accounts = await web3.eth.getAccounts();

        let data = [
            "0x",
            "00000000000000000000000000000000000000000000004e4654427269646765",
            "01",
            "0000",
            web3.eth.abi.encodeParameter("uint16", testForeignChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("bytes32", testForeignBridgeContract).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await initialized.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(before, "0x0000000000000000000000000000000000000000000000000000000000000000");

        await initialized.methods.registerChain("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await initialized.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(after, testForeignBridgeContract);
    })

    it("should accept a valid upgrade", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        let data = [
            "0x",
            "00000000000000000000000000000000000000000000004e4654427269646765",
            "02",
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(NFTBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), NFTBridgeImplementation.address.toLowerCase());

        await initialized.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await web3.eth.getStorageAt(NFTBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockBridgeImplementation.abi, NFTBridge.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
        lastDeployed = mock;
    })

    it("bridged tokens should only be mint- and burn-able by owner", async function () {
        const accounts = await web3.eth.getAccounts();

        // initialize our template token contract
        const token = new web3.eth.Contract(NFTImplementation.abi, NFTImplementation.address);

        await token.methods.initialize(
            "TestToken",
            "TT",
            accounts[0],

            0,
            "0x0"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        await token.methods.mint(accounts[0], 10, "").send({
            from: accounts[0],
            gasLimit: 2000000
        });

        let failed = false
        try {
            await token.methods.mint(accounts[0], 11, "").send({
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            failed = true
        }
        assert.ok(failed)

        failed = false
        try {
            await token.methods.burn(10).send({
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            failed = true
        }
        assert.ok(failed)

        await token.methods.burn(10).send({
            from: accounts[0],
            gasLimit: 2000000
        });
    })

    it("should deposit and log transfers correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        const tokenId = "1000000000000000000";

        // mint and approve tokens
        const token = new web3.eth.Contract(NFTImplementation.abi, NFTImplementation.address);
        await token.methods.mint(accounts[0], tokenId, "abcd").send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(NFTBridge.address, tokenId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        const ownerBefore = await token.methods.ownerOf(tokenId).call();
        assert.equal(ownerBefore, accounts[0]);
        await initialized.methods.transferNFT(
            NFTImplementation.address,
            tokenId,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const ownerAfter = await token.methods.ownerOf(tokenId).call();
        assert.equal(ownerAfter, NFTBridge.address);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, NFTBridge.address)

        assert.equal(log.payload.length - 2, 340);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // token
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("address", NFTImplementation.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(68, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // symbol (TT)
        assert.equal(log.payload.substr(72, 64), "5454000000000000000000000000000000000000000000000000000000000000")

        // name (TestToken (Wormhole))
        assert.equal(log.payload.substr(136, 64), "54657374546f6b656e0000000000000000000000000000000000000000000000")

        // tokenID
        assert.equal(log.payload.substr(200, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(tokenId).toString()).substring(2));

        // url length
        assert.equal(log.payload.substr(264, 2), web3.eth.abi.encodeParameter("uint8", 4).substring(2 + 64 - 2))

        // url
        assert.equal(log.payload.substr(266, 8), "61626364")

        // to
        assert.equal(log.payload.substr(274, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(338, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))
    })

    it("should transfer out locked assets for a valid transfer vm", async function () {
        const accounts = await web3.eth.getAccounts();
        const tokenId = "1000000000000000000";

        const token = new web3.eth.Contract(NFTImplementation.abi, NFTImplementation.address);
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        const ownerBefore = await token.methods.ownerOf(tokenId).call();
        assert.equal(ownerBefore, NFTBridge.address);

        // PayloadID uint8 = 1
        // // Address of the NFT. Left-zero-padded if shorter than 32 bytes
        // NFTAddress [32]uint8
        // // Chain ID of the NFT
        // NFTChain uint16
        // // Name of the NFT
        // Name [32]uint8
        // // Symbol of the NFT
        // Symbol [10]uint8
        // // ID of the token (big-endian uint256)
        // TokenID [32]uint8
        // // URL of the NFT
        // URLLength u8
        // URL [n]uint8
        // // Address of the recipient. Left-zero-padded if shorter than 32 bytes
        // To [32]uint8
        // // Chain ID of the recipient
        // ToChain uint16
        const data = "0x" +
            "01" +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", NFTImplementation.address).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // symbol
            "0000000000000000000000000000000000000000000000000000000000000000" +
            // name
            "0000000000000000000000000000000000000000000000000000000000000000" +
            // tokenID
            web3.eth.abi.encodeParameter("uint256", new BigNumber(tokenId).toString()).substring(2) +
            // url length
            "00" +
            // no URL
            "" +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4));

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const ownerAfter = await token.methods.ownerOf(tokenId).call();
        assert.equal(ownerAfter, accounts[0]);
    })

    it("should mint bridged assets wrappers on transfer from another chain and handle fees correctly", async function () {
        const accounts = await web3.eth.getAccounts();
        let tokenId = "1000000000000000001";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        // we are using the asset where we created a wrapper in the previous test
        let data = "0x" +
            "01" +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // symbol
            "464f520000000000000000000000000000000000000000000000000000000000" +
            // name
            "466f726569676e20436861696e204e4654000000000000000000000000000000" +
            // tokenID
            web3.eth.abi.encodeParameter("uint256", new BigNumber(tokenId).toString()).substring(2) +
            // url length
            "00" +
            // no URL
            "" +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4));

        let vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        assert.ok(await initialized.methods.isWrappedAsset(wrappedAddress).call())
        const wrappedAsset = new web3.eth.Contract(NFTImplementation.abi, wrappedAddress);

        let ownerAfter = await wrappedAsset.methods.ownerOf(tokenId).call();
        assert.equal(ownerAfter, accounts[0]);

        const symbol = await wrappedAsset.methods.symbol().call();
        assert.equal(symbol, "FOR");

        const name = await wrappedAsset.methods.name().call();
        assert.equal(name, "Foreign Chain NFT");

        const chainId = await wrappedAsset.methods.chainId().call();
        assert.equal(chainId, Number(testBridgedAssetChain));

        const nativeContract = await wrappedAsset.methods.nativeContract().call();
        assert.equal(nativeContract, "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // Transfer another tokenID of the same token address
        tokenId = "1000000000000000002"
        data = "0x" +
            "01" +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            testBridgedAssetChain +
            // symbol
            "464f520000000000000000000000000000000000000000000000000000000000" +
            // name
            "466f726569676e20436861696e204e4654000000000000000000000000000000" +
            // tokenID
            web3.eth.abi.encodeParameter("uint256", new BigNumber(tokenId + 1).toString()).substring(2) +
            // url length
            "00" +
            // no URL
            "" +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4));

        vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            1,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        ownerAfter = await wrappedAsset.methods.ownerOf(tokenId + 1).call();
        assert.equal(ownerAfter, accounts[0]);
    })

    it("should mint bridged assets from solana under unified name, caching the original", async function () {
        const accounts = await web3.eth.getAccounts();
        let tokenId = "1000000000000000001";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        // we are using the asset where we created a wrapper in the previous test
        let data = "0x" +
            "01" +
            // tokenaddress
            testBridgedAssetAddress +
            // tokenchain
            "0001" +
            // symbol
            "464f520000000000000000000000000000000000000000000000000000000000" +
            // name
            "466f726569676e20436861696e204e4654000000000000000000000000000000" +
            // tokenID
            web3.eth.abi.encodeParameter("uint256", new BigNumber(tokenId).toString()).substring(2) +
            // url length
            "00" +
            // no URL
            "" +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[0]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4));

        let vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        await initialized.methods.completeTransfer("0x" + vm).send({
            value: 0,
            from: accounts[1],
            gasLimit: 2000000
        });

        const cache = await initialized.methods.splCache(tokenId).call()
        assert.equal(cache.symbol, "0x464f520000000000000000000000000000000000000000000000000000000000");
        assert.equal(cache.name, "0x466f726569676e20436861696e204e4654000000000000000000000000000000");

        const wrappedAddress = await initialized.methods.wrappedAsset("0x0001", "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(NFTImplementation.abi, wrappedAddress);

        const symbol = await wrappedAsset.methods.symbol().call();
        assert.equal(symbol, "WORMSPLNFT");

        const name = await wrappedAsset.methods.name().call();
        assert.equal(name, "Wormhole Bridged Solana-NFT");
    })

    it("cached SPL names are loaded when transferring out, cache is cleared", async function () {
        const accounts = await web3.eth.getAccounts();
        let tokenId = "1000000000000000001";

        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);

        const wrappedAddress = await initialized.methods.wrappedAsset("0x0001", "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(NFTImplementation.abi, wrappedAddress);

        await wrappedAsset.methods.approve(NFTBridge.address, tokenId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const transfer = await initialized.methods.transferNFT(
            wrappedAddress,
            tokenId,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "2345"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // symbol
        assert.ok(transfer.events[4].raw.data.includes('464f520000000000000000000000000000000000000000000000000000000000'))
        // name
        assert.ok(transfer.events[4].raw.data.includes('466f726569676e20436861696e204e4654000000000000000000000000000000'))

        // check if cache is cleared
        const cache = await initialized.methods.splCache(tokenId).call()
        assert.equal(cache.symbol, "0x0000000000000000000000000000000000000000000000000000000000000000");
        assert.equal(cache.name, "0x0000000000000000000000000000000000000000000000000000000000000000");
    })

    it("should should fail deposit unapproved NFTs", async function () {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const tokenId = "1000000000000000001";

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();

        // deposit tokens
        let failed = false
        try {
            await initialized.methods.transferNFT(
                wrappedAddress,
                tokenId,
                "10",
                "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
                "234"
            ).send({
                value: 0,
                from: accounts[0],
                gasLimit: 2000000
            });
        } catch (e) {
            assert.equal(e.message, "Returned error: VM Exception while processing transaction: revert ERC721: transfer caller is not owner nor approved")
            failed = true
        }

        assert.ok(failed)
    })

    it("should refuse to burn wrappers not held by msg.sender", async function () {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const tokenId = "1000000000000000001";

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(NFTImplementation.abi, wrappedAddress);

        // approve from 0
        await wrappedAsset.methods.approve(NFTBridge.address, tokenId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens from 1
        let failed = false
        try {
            await initialized.methods.transferNFT(
                wrappedAddress,
                tokenId,
                "10",
                "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
                "234"
            ).send({
                value: 0,
                from: accounts[1],
                gasLimit: 2000000
            });
        } catch (e) {
            assert.equal(e.message, "Returned error: VM Exception while processing transaction: revert ERC721: transfer of token that is not own")
            failed = true
        }

        assert.ok(failed)
    })

    it("should deposit and burn approved bridged assets wrappers on transfer to another chain", async function () {
        const accounts = await web3.eth.getAccounts();
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const tokenId = "1000000000000000001";

        const wrappedAddress = await initialized.methods.wrappedAsset("0x" + testBridgedAssetChain, "0x" + testBridgedAssetAddress).call();
        const wrappedAsset = new web3.eth.Contract(NFTImplementation.abi, wrappedAddress);

        await wrappedAsset.methods.approve(NFTBridge.address, tokenId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        // deposit tokens

        const ownerBefore = await wrappedAsset.methods.ownerOf(tokenId).call();

        assert.equal(ownerBefore, accounts[0]);

        await initialized.methods.transferNFT(
            wrappedAddress,
            tokenId,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        try {
            await wrappedAsset.methods.ownerOf(tokenId).call();
            assert.fail("burned token still exists")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "ERC721: owner query for nonexistent token")
        }
    })

    it("should reject smart contract upgrades on forks", async function () {
        const mockInitialized = new web3.eth.Contract(MockBridgeImplementation.abi, NFTBridge.address);
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        // simulate a fork
        await mockInitialized.methods.testOverwriteEVMChainId(fakeChainId, fakeEvmChainId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, fakeChainId);

        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, fakeEvmChainId);

        data = [
            "0x",
            "00000000000000000000000000000000000000000000004e4654427269646765",
            // Action 1 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        try {
            await initialized.methods.upgrade("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });

            assert.fail("governance packet accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "invalid fork")
        }
    })

    it("should allow recover chain ID governance packets forks", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, fakeChainId);

        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, fakeEvmChainId);

        data = [
            "0x",
            "00000000000000000000000000000000000000000000004e4654427269646765",
            // Action 3 (Recover Chain ID)
            actionRecoverChainId,
            // EvmChainID
            web3.eth.abi.encodeParameter("uint256", testEvmChainId).substring(2),
            // NewChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        await initialized.methods.submitRecoverChainId("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const newChainId = await initialized.methods.chainId().call();
        assert.equal(newChainId, testChainId);

        const newEvmChainId = await initialized.methods.evmChainId().call();
        assert.equal(newEvmChainId, testEvmChainId);
    })

    it("should accept smart contract upgrades after chain ID has been recovered", async function () {
        const initialized = new web3.eth.Contract(BridgeImplementationFullABI, NFTBridge.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockBridgeImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            "0x",
            "00000000000000000000000000000000000000000000004e4654427269646765",
            // Action 2 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(NFTBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), lastDeployed.address.toLowerCase());

        let set = await initialized.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let after = await web3.eth.getStorageAt(NFTBridge.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockBridgeImplementation.abi, NFTBridge.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
    })
});

const signAndEncodeVM = async function (
    timestamp,
    nonce,
    emitterChainId,
    emitterAddress,
    sequence,
    data,
    signers,
    guardianSetIndex,
    consistencyLevel
) {
    const body = [
        web3.eth.abi.encodeParameter("uint32", timestamp).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint32", nonce).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint16", emitterChainId).substring(2 + (64 - 4)),
        web3.eth.abi.encodeParameter("bytes32", emitterAddress).substring(2),
        web3.eth.abi.encodeParameter("uint64", sequence).substring(2 + (64 - 16)),
        web3.eth.abi.encodeParameter("uint8", consistencyLevel).substring(2 + (64 - 2)),
        data.substr(2)
    ]

    const hash = web3.utils.soliditySha3(web3.utils.soliditySha3("0x" + body.join("")))

    let signatures = "";

    for (let i in signers) {
        const ec = new elliptic.ec("secp256k1");
        const key = ec.keyFromPrivate(signers[i]);
        const signature = key.sign(hash.substr(2), { canonical: true });

        const packSig = [
            web3.eth.abi.encodeParameter("uint8", i).substring(2 + (64 - 2)),
            zeroPadBytes(signature.r.toString(16), 32),
            zeroPadBytes(signature.s.toString(16), 32),
            web3.eth.abi.encodeParameter("uint8", signature.recoveryParam).substr(2 + (64 - 2)),
        ]

        signatures += packSig.join("")
    }

    const vm = [
        web3.eth.abi.encodeParameter("uint8", 1).substring(2 + (64 - 2)),
        web3.eth.abi.encodeParameter("uint32", guardianSetIndex).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint8", signers.length).substring(2 + (64 - 2)),

        signatures,
        body.join("")
    ].join("");

    return vm
}

function zeroPadBytes(value, length) {
    while (value.length < 2 * length) {
        value = "0" + value;
    }
    return value;
}

'''
'''--- lib/wormhole/ethereum/test/tokenmigrator.js ---
const jsonfile = require('jsonfile');
const BigNumber = require('bignumber.js');

const Migrator = artifacts.require("Migrator");
const TokenImplementation = artifacts.require("TokenImplementation");

contract("Migrator", function (accounts) {
    var migrator,
        fromToken,
        toToken,
        fromDecimals = 8,
        toDecimals = 18;

    it("should deploy with the correct values", async function () {
        fromToken = await TokenImplementation.new();
        await fromToken.initialize(
            "TestFrom",
            "FROM",
            fromDecimals,
            0,
            accounts[0],
            0,
            "0x00"
        )
        toToken = await TokenImplementation.new();
        await toToken.initialize(
            "TestTo",
            "TO",
            toDecimals,
            0,
            accounts[0],
            0,
            "0x00"
        )

        migrator = await Migrator.new(
            fromToken.address,
            toToken.address,
        );

        assert.equal(await migrator.fromAsset(), fromToken.address)
        assert.equal(await migrator.toAsset(), toToken.address)
        assert.equal((await migrator.fromDecimals()).toNumber(), fromDecimals)
        assert.equal((await migrator.toDecimals()).toNumber(), toDecimals)
    })

    it("should give out LP tokens 1:1 for a toToken deposit", async function () {
        await toToken.mint(accounts[0], "1000000000000000000")
        await toToken.approve(migrator.address, "1000000000000000000")
        await migrator.add("1000000000000000000")

        assert.equal((await toToken.balanceOf(migrator.address)).toString(), "1000000000000000000")
        assert.equal((await migrator.balanceOf(accounts[0])).toString(), "1000000000000000000")
    })

    it("should refund toToken for LP tokens", async function () {
        await migrator.remove("500000000000000000")

        assert.equal((await toToken.balanceOf(migrator.address)).toString(), "500000000000000000")
        assert.equal((await toToken.balanceOf(accounts[0])).toString(), "500000000000000000")
        assert.equal((await migrator.balanceOf(accounts[0])).toString(), "500000000000000000")
    })

    it("should redeem fromToken to toToken adjusting for decimals", async function () {
        await fromToken.mint(accounts[1], "50000000")
        await fromToken.approve(migrator.address, "50000000", {
            from : accounts[1]
        })
        await migrator.migrate("50000000", {
            from : accounts[1]
        })

        assert.equal((await toToken.balanceOf(accounts[1])).toString(), "500000000000000000")
        assert.equal((await fromToken.balanceOf(accounts[1])).toString(), "0")
        assert.equal((await fromToken.balanceOf(migrator.address)).toString(), "50000000")
        assert.equal((await toToken.balanceOf(migrator.address)).toString(), "0")
    })

    it("fromToken should be claimable for LP tokens, adjusting for decimals", async function () {
        await migrator.claim("500000000000000000")

        assert.equal((await fromToken.balanceOf(migrator.address)).toString(), "0")
        assert.equal((await fromToken.balanceOf(accounts[0])).toString(), "50000000")
        assert.equal((await migrator.balanceOf(accounts[0])).toString(), "0")
    })
})
'''
'''--- lib/wormhole/ethereum/test/upgrades/01_tokenbridge_feetoken_support.js ---
const jsonfile = require('jsonfile');
const elliptic = require('elliptic');
const BigNumber = require('bignumber.js');

const Wormhole = artifacts.require("Wormhole");
const TokenBridge = artifacts.require("TokenBridge");
const BridgeSetup = artifacts.require("BridgeSetup");
const BridgeImplementation = artifacts.require("BridgeImplementation");
const MockBridgeImplementation = artifacts.require("MockBridgeImplementation");
const TokenImplementation = artifacts.require("TokenImplementation");
const FeeToken = artifacts.require("FeeToken");

const testSigner1PK = "cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0";

const WormholeImplementationFullABI = jsonfile.readFileSync("build/contracts/Implementation.json").abi
const BridgeImplementationFullABI = jsonfile.readFileSync("build/contracts/BridgeImplementation.json").abi

// needs to run on a mainnet fork

contract("Update Bridge", function (accounts) {
    if (config.network === "test") return;
    const testChainId = "2";
    const testEvmChainId = "1";
    const testGovernanceChainId = "1";
    const testGovernanceContract = "0x0000000000000000000000000000000000000000000000000000000000000004";
    let WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
    const testForeignChainId = "1";
    const testForeignBridgeContract = "0x000000000000000000000000000000000000000000000000000000000000ffff";
    const testFinality = 15;

    const currentImplementation = "0x6c4c12987303b2c94b2C76c612Fc5F4D2F0360F7";
    let bridgeProxy;

    it("create bridge instance with current implementation", async function () {
        // encode initialisation data
        const setup = new web3.eth.Contract(BridgeSetup.abi, BridgeSetup.address);
        const initData = setup.methods.setup(
            currentImplementation,
            testChainId,
            (await Wormhole.deployed()).address,
            testGovernanceChainId,
            testGovernanceContract,
            TokenImplementation.address,
            WETH,
            testFinality,
            testEvmChainId
        ).encodeABI();

        const deploy = await TokenBridge.new(BridgeSetup.address, initData);

        bridgeProxy = new web3.eth.Contract(BridgeImplementationFullABI, deploy.address);
    })

    it("register a foreign bridge implementation", async function () {
        let data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            "01",
            "0000",
            web3.eth.abi.encodeParameter("uint16", testForeignChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("bytes32", testForeignBridgeContract).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await bridgeProxy.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(before, "0x0000000000000000000000000000000000000000000000000000000000000000");

        await bridgeProxy.methods.registerChain("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await bridgeProxy.methods.bridgeContracts(testForeignChainId).call();

        assert.equal(after, testForeignBridgeContract);
    })

    it("mimic previous deposits (deposit some ETH)", async function () {
        const amount = "100000000000000000";
        const fee = "10000000000000000";

        await bridgeProxy.methods.wrapAndTransferETH(
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            fee,
            "234"
        ).send({
            value: amount,
            from: accounts[0],
            gasLimit: 2000000
        });

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.payload.length - 2, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", WETH).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // fee
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2))
    })

    let upgradeDeployedAt;
    it("apply upgrade", async function () {
        const deploy = await BridgeImplementation.new();
        upgradeDeployedAt = deploy.address;

        let data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            "02",
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("address", deploy.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(bridgeProxy.options.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), currentImplementation.toLowerCase());

        await bridgeProxy.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await web3.eth.getStorageAt(bridgeProxy.options.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), deploy.address.toLowerCase());
    })

    it("test withdrawing existing assets (deposited ETH)", async function () {
        const amount = "100000000000000000";

        const accountBalanceBefore = await web3.eth.getBalance(accounts[1]);

        // we are using the asset where we created a wrapper in the previous test
        const data = "0x" +
            "01" +
            // amount
            web3.eth.abi.encodeParameter("uint256", new BigNumber(amount).div(1e10).toString()).substring(2) +
            // tokenaddress
            web3.eth.abi.encodeParameter("address", WETH).substr(2) +
            // tokenchain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // receiver
            web3.eth.abi.encodeParameter("address", accounts[1]).substr(2) +
            // receiving chain
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)) +
            // fee
            web3.eth.abi.encodeParameter("uint256", 0).substring(2);

        const vm = await signAndEncodeVM(
            0,
            0,
            testForeignChainId,
            testForeignBridgeContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        const transferTX = await bridgeProxy.methods.completeTransferAndUnwrapETH("0x" + vm).send({
            from: accounts[0],
            gasLimit: 2000000
        });

        const accountBalanceAfter = await web3.eth.getBalance(accounts[1]);

        assert.equal((new BigNumber(accountBalanceAfter)).minus(accountBalanceBefore).toString(10), (new BigNumber(amount)).toString(10))
    })

    it("test new functionality (fee token transfers)", async function () {
        const accounts = await web3.eth.getAccounts();
        const mintAmount = "10000000000000000000";
        const amount = "1000000000000000000";
        const fee = "100000000000000000";

        // mint and approve tokens
        const deployFeeToken = await FeeToken.new();
        const token = new web3.eth.Contract(FeeToken.abi, deployFeeToken.address);
        await token.methods.initialize(
            "Test",
            "TST",
            "18",
            "123",
            accounts[0],
            "0",
            "0x0000000000000000000000000000000000000000000000000000000000000000"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.mint(accounts[0], mintAmount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });
        await token.methods.approve(bridgeProxy.options.address, mintAmount).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const bridgeBalanceBefore = await token.methods.balanceOf(bridgeProxy.options.address).call();

        assert.equal(bridgeBalanceBefore.toString(10), "0");

        await bridgeProxy.methods.transferTokens(
            deployFeeToken.address,
            amount,
            "10",
            "0x000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e",
            fee,
            "234"
        ).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        const bridgeBalanceAfter = await token.methods.balanceOf(bridgeProxy.options.address).call();

        let feeAmount = new BigNumber(amount).times(9).div(10)

        assert.equal(bridgeBalanceAfter.toString(10), feeAmount);

        // check transfer log
        const wormhole = new web3.eth.Contract(WormholeImplementationFullABI, Wormhole.address);
        const log = (await wormhole.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))[0].returnValues

        assert.equal(log.sender, bridgeProxy.options.address)

        assert.equal(log.payload.length - 2, 266);

        // payload id
        assert.equal(log.payload.substr(2, 2), "01");

        // amount
        assert.equal(log.payload.substr(4, 64), web3.eth.abi.encodeParameter("uint256", feeAmount.div(1e10).toString()).substring(2));

        // token
        assert.equal(log.payload.substr(68, 64), web3.eth.abi.encodeParameter("address", deployFeeToken.address).substring(2));

        // chain id
        assert.equal(log.payload.substr(132, 4), web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + 64 - 4))

        // to
        assert.equal(log.payload.substr(136, 64), "000000000000000000000000b7a2211e8165943192ad04f5dd21bedc29ff003e");

        // to chain id
        assert.equal(log.payload.substr(200, 4), web3.eth.abi.encodeParameter("uint16", 10).substring(2 + 64 - 4))

        // fee
        assert.equal(log.payload.substr(204, 64), web3.eth.abi.encodeParameter("uint256", new BigNumber(fee).div(1e10).toString()).substring(2))
    })

    it("should accept a further upgrade", async function () {
        const mock = await MockBridgeImplementation.new();

        let data = [
            "0x",
            "000000000000000000000000000000000000000000546f6b656e427269646765",
            "02",
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            1,
            1,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            0
        );

        let before = await web3.eth.getStorageAt(bridgeProxy.options.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), upgradeDeployedAt.toLowerCase());

        await bridgeProxy.methods.upgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 2000000
        });

        let after = await web3.eth.getStorageAt(bridgeProxy.options.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockBridgeImplementation.abi, bridgeProxy.options.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
    })
});

const signAndEncodeVM = async function (
    timestamp,
    nonce,
    emitterChainId,
    emitterAddress,
    sequence,
    data,
    signers,
    guardianSetIndex,
    consistencyLevel
) {
    const body = [
        web3.eth.abi.encodeParameter("uint32", timestamp).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint32", nonce).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint16", emitterChainId).substring(2 + (64 - 4)),
        web3.eth.abi.encodeParameter("bytes32", emitterAddress).substring(2),
        web3.eth.abi.encodeParameter("uint64", sequence).substring(2 + (64 - 16)),
        web3.eth.abi.encodeParameter("uint8", consistencyLevel).substring(2 + (64 - 2)),
        data.substr(2)
    ]

    const hash = web3.utils.soliditySha3(web3.utils.soliditySha3("0x" + body.join("")))

    let signatures = "";

    for (let i in signers) {
        const ec = new elliptic.ec("secp256k1");
        const key = ec.keyFromPrivate(signers[i]);
        const signature = key.sign(hash.substr(2), {canonical: true});

        const packSig = [
            web3.eth.abi.encodeParameter("uint8", i).substring(2 + (64 - 2)),
            zeroPadBytes(signature.r.toString(16), 32),
            zeroPadBytes(signature.s.toString(16), 32),
            web3.eth.abi.encodeParameter("uint8", signature.recoveryParam).substr(2 + (64 - 2)),
        ]

        signatures += packSig.join("")
    }

    const vm = [
        web3.eth.abi.encodeParameter("uint8", 1).substring(2 + (64 - 2)),
        web3.eth.abi.encodeParameter("uint32", guardianSetIndex).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint8", signers.length).substring(2 + (64 - 2)),

        signatures,
        body.join("")
    ].join("");

    return vm
}

function zeroPadBytes(value, length) {
    while (value.length < 2 * length) {
        value = "0" + value;
    }
    return value;
}

'''
'''--- lib/wormhole/ethereum/test/wormhole.js ---
const jsonfile = require('jsonfile');
const elliptic = require('elliptic');
const path = require('path');

const Wormhole = artifacts.require("Wormhole");
const MockImplementation = artifacts.require("MockImplementation");
const Implementation = artifacts.require("Implementation");
const MockBatchedVAASender = artifacts.require("MockBatchedVAASender");

const testSigner1PK = "cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0";
const testSigner2PK = "892330666a850761e7370376430bb8c2aa1494072d3bfeaed0c4fa3d5a9135fe";
const testSigner3PK = "87b45997ea577b93073568f06fc4838cffc1d01f90fc4d57f936957f3c4d99fb";
const testBadSigner1PK = "87b45997ea577b93073568f06fc4838cffc1d01f90fc4d57f936957f3c4d99fc";

const core = '0x' + Buffer.from("Core").toString("hex").padStart(64, 0)
const actionContractUpgrade = "01"
const actionGuardianSetUpgrade = "02"
const actionMessageFee = "03"
const actionTransferFee = "04"
const actionRecoverChainId = "05"

const ImplementationFullABI = jsonfile.readFileSync("build/contracts/Implementation.json").abi

const fakeChainId = 1337;
const fakeEvmChainId = 10001;

let lastDeployed;

// Taken from https://medium.com/fluidity/standing-the-time-of-test-b906fcc374a9
advanceTimeAndBlock = async (time) => {
    await advanceTime(time);
    await advanceBlock();

    return Promise.resolve(web3.eth.getBlock('latest'));
}

advanceTime = (time) => {
    return new Promise((resolve, reject) => {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [time],
            id: new Date().getTime()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            return resolve(result);
        });
    });
}

advanceBlock = () => {
    return new Promise((resolve, reject) => {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_mine",
            id: new Date().getTime()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            const newBlockHash = web3.eth.getBlock('latest').hash;

            return resolve(newBlockHash)
        });
    });
}

contract("Wormhole", function () {
    const testSigner1 = web3.eth.accounts.privateKeyToAccount(testSigner1PK);
    const testSigner2 = web3.eth.accounts.privateKeyToAccount(testSigner2PK);
    const testSigner3 = web3.eth.accounts.privateKeyToAccount(testSigner3PK);
    const testChainId = "2";
    const testEvmChainId = "1";
    const testGovernanceChainId = "1";
    const testGovernanceContract = "0x0000000000000000000000000000000000000000000000000000000000000004";

    it("should be initialized with the correct signers and values", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const index = await initialized.methods.getCurrentGuardianSetIndex().call();
        const set = (await initialized.methods.getGuardianSet(index).call());

        // check set
        assert.lengthOf(set[0], 1);
        assert.equal(set[0][0], testSigner1.address);

        // check expiration
        assert.equal(set.expirationTime, "0");

        // chain id
        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, testChainId);

        // evm chain id
        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, testEvmChainId);

        // governance
        const governanceChainId = await initialized.methods.governanceChainId().call();
        assert.equal(governanceChainId, testGovernanceChainId);
        const governanceContract = await initialized.methods.governanceContract().call();
        assert.equal(governanceContract, testGovernanceContract);
    })

    it("should log a published message correctly", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const log = await initialized.methods.publishMessage(
            "0x123",
            "0x123321",
            32
        ).send({
            value: 0, // fees are set to 0 initially
            from: accounts[0]
        })

        assert.equal(log.events.LogMessagePublished.returnValues.sender.toString(), accounts[0]);
        assert.equal(log.events.LogMessagePublished.returnValues.sequence.toString(), "0");
        assert.equal(log.events.LogMessagePublished.returnValues.nonce, 291);
        assert.equal(log.events.LogMessagePublished.returnValues.payload.toString(), "0x123321");
        assert.equal(log.events.LogMessagePublished.returnValues.consistencyLevel, 32);
    })

    it("should log sequential sequence numbers for multi-VAA transactions", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const mockIntegration = new web3.eth.Contract(MockBatchedVAASender.abi, MockBatchedVAASender.address);

        await mockIntegration.methods.sendMultipleMessages(
            "0x1",
            "0x1",
            32
        ).send({
            value: 0, // fees are set to 0 initially
            from: accounts[0]
        });

        const events = (await initialized.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))

        let firstSequence = Number(events[0].returnValues.sequence.toString())

        let secondSequence = Number(events[1].returnValues.sequence.toString())
        assert.equal(secondSequence, firstSequence + 1);

        let thirdSequence = Number(events[2].returnValues.sequence.toString())
        assert.equal(thirdSequence, secondSequence + 1);
    })

    it("should increase the sequence for an account", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const log = await initialized.methods.publishMessage(
            "0x1",
            "0x1",
            32
        ).send({
            value: 0, // fees are set to 0 initially
            from: accounts[0]
        })

        assert.equal(log.events.LogMessagePublished.returnValues.sequence.toString(), "1");
    })

    it("should get the same nonce from all VAAs produced by a transaction", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const mockIntegration = new web3.eth.Contract(MockBatchedVAASender.abi, MockBatchedVAASender.address);

        const nonce = Math.round(Date.now() / 1000);
        const nonceHex = nonce.toString(16)

        await mockIntegration.methods.sendMultipleMessages(
            "0x" + nonceHex,
            "0x1",
            32
        ).send({
            value: 0, // fees are set to 0 initially
            from: accounts[0]
        });

        const events = (await initialized.getPastEvents('LogMessagePublished', {
            fromBlock: 'latest'
        }))

        assert.equal(events[0].returnValues.nonce, nonce);
        assert.equal(events[1].returnValues.nonce, nonce);
        assert.equal(events[2].returnValues.nonce, nonce);
    })

    it("parses VMs correctly", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            1337,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        let result
        try {
            result = await initialized.methods.parseAndVerifyVM("0x" + vm).call();
        } catch (err) {
            console.log(err)
            assert.fail("parseAndVerifyVM failed")
        }

        assert.equal(result.vm.version, 1);
        assert.equal(result.vm.timestamp, timestamp);
        assert.equal(result.vm.nonce, nonce);
        assert.equal(result.vm.emitterChainId, emitterChainId);
        assert.equal(result.vm.emitterAddress, emitterAddress);
        assert.equal(result.vm.payload, data);
        assert.equal(result.vm.guardianSetIndex, 0);
        assert.equal(result.vm.sequence, 1337);
        assert.equal(result.vm.consistencyLevel, 2);

        assert.equal(result.valid, true);

        assert.equal(result.reason, "");
    })

    it("should fail quorum on VMs with no signers", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            1337,
            data,
            [], // no valid signers present
            0,
            2
        );

        let result = await initialized.methods.parseAndVerifyVM("0x" + vm).call();
        assert.equal(result[1], false)
        assert.equal(result[2], "no quorum")
    })

    it("should fail to verify on VMs with bad signer", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            1337,
            data,
            [
                testBadSigner1PK, // not a valid signer
            ],
            0,
            2
        );

        let result = await initialized.methods.parseAndVerifyVM("0x" + vm).call();
        assert.equal(result[1], false)
        assert.equal(result[2], "VM signature invalid")
    })

    it("should error on VMs with invalid guardian set index", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            1337,
            data,
            [
                testSigner1PK,
            ],
            200,
            2
        );

        let result = await initialized.methods.parseAndVerifyVM("0x" + vm).call();
        assert.equal(result[1], false)
        assert.equal(result[2], "invalid guardian set")
    })

    it("should revert on VMs with duplicate non-monotonic signature indexes", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVMFixedIndex(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            1337,
            data,
            [
                testSigner1PK,
                testSigner1PK,
                testSigner1PK,
            ],
            0,
            2
        );

        try {
            await initialized.methods.parseAndVerifyVM("0x" + vm).call();
            assert.fail("accepted signature indexes being the same in a VM");
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, 'signature indices must be ascending')
        }
    })

    it("should set and enforce fees", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            //Core
            core,
            // Action 3 (Set Message Fee)
            actionMessageFee,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // Message Fee
            web3.eth.abi.encodeParameter("uint256", 1111).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        let before = await initialized.methods.messageFee().call();

        let set = await initialized.methods.submitSetMessageFee("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let after = await initialized.methods.messageFee().call();

        assert.notEqual(before, after);
        assert.equal(after, 1111);

        // test message publishing
        await initialized.methods.publishMessage(
            "0x123",
            "0x123321",
            32
        ).send({
            from: accounts[0],
            value: 1111
        })

        let failed = false;
        try {
            await initialized.methods.publishMessage(
                "0x123",
                "0x123321",
                32
            ).send({
                value: 1110,
                from: accounts[0]
            })
        } catch (e) {
            failed = true
        }

        assert.equal(failed, true);
    })

    it("should transfer out collected fees", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const receiver = "0x" + zeroPadBytes(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16), 20);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            // Core
            core,
            // Action 4 (Transfer Fees)
            actionTransferFee,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // Amount
            web3.eth.abi.encodeParameter("uint256", 11).substring(2),
            // Recipient
            web3.eth.abi.encodeParameter("address", receiver).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        let WHBefore = await web3.eth.getBalance(Wormhole.address);
        let receiverBefore = await web3.eth.getBalance(receiver);

        let set = await initialized.methods.submitTransferFees("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let WHAfter = await web3.eth.getBalance(Wormhole.address);
        let receiverAfter = await web3.eth.getBalance(receiver);

        assert.equal(WHBefore - WHAfter, 11);
        assert.equal(receiverAfter - receiverBefore, 11);
    })

    it("should revert when submitting a new guardian set with the zero address", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract;
        const zeroAddress = "0x0000000000000000000000000000000000000000";

        let oldIndex = Number(await initialized.methods.getCurrentGuardianSetIndex().call());

        data = [
            // Core
            core,
            // Action 2 (Guardian Set Upgrade)
            actionGuardianSetUpgrade,
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("uint32", oldIndex + 1).substring(2 + (64 - 8)),
            web3.eth.abi.encodeParameter("uint8", 3).substring(2 + (64 - 2)),
            web3.eth.abi.encodeParameter("address", testSigner1.address).substring(2 + (64 - 40)),
            web3.eth.abi.encodeParameter("address", testSigner2.address).substring(2 + (64 - 40)),
            web3.eth.abi.encodeParameter("address", zeroAddress).substring(2 + (64 - 40)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK
            ],
            0,
            2
        );

        // try to submit a new guardian set including the zero address
        failed = false;
        try {
            await initialized.methods.submitNewGuardianSet("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });
        } catch (e) {
            assert.equal(e.message, "Returned error: VM Exception while processing transaction: revert Invalid key");
            failed = true;
        }

        assert.ok(failed);
    })

    it("should accept a new guardian set", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        let oldIndex = Number(await initialized.methods.getCurrentGuardianSetIndex().call());

        data = [
            // Core
            core,
            // Action 2 (Guardian Set Upgrade)
            actionGuardianSetUpgrade,
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("uint32", oldIndex + 1).substring(2 + (64 - 8)),
            web3.eth.abi.encodeParameter("uint8", 3).substring(2 + (64 - 2)),
            web3.eth.abi.encodeParameter("address", testSigner1.address).substring(2 + (64 - 40)),
            web3.eth.abi.encodeParameter("address", testSigner2.address).substring(2 + (64 - 40)),
            web3.eth.abi.encodeParameter("address", testSigner3.address).substring(2 + (64 - 40)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        let set = await initialized.methods.submitNewGuardianSet("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let index = await initialized.methods.getCurrentGuardianSetIndex().call();

        assert.equal(oldIndex + 1, index);

        assert.equal(index, 1);

        let guardians = await initialized.methods.getGuardianSet(index).call();

        assert.equal(guardians.expirationTime, 0);

        assert.lengthOf(guardians[0], 3);
        assert.equal(guardians[0][0], testSigner1.address);
        assert.equal(guardians[0][1], testSigner2.address);
        assert.equal(guardians[0][2], testSigner3.address);

        let oldGuardians = await initialized.methods.getGuardianSet(oldIndex).call();

        const time = (await web3.eth.getBlock("latest")).timestamp;

        // old guardian set expiry is set
        assert.ok(
            oldGuardians.expirationTime > Number(time) + 86000
            && oldGuardians.expirationTime < Number(time) + 88000
        );
    })

    it("should accept smart contract upgrades", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            // Core
            core,
            // Action 1 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK
            ],
            1,
            2
        );

        let before = await web3.eth.getStorageAt(Wormhole.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), Implementation.address.toLowerCase());

        let set = await initialized.methods.submitContractUpgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let after = await web3.eth.getStorageAt(Wormhole.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockImplementation.abi, Wormhole.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
        lastDeployed = mock;
    })

    it("should revert recover chain ID governance packets on canonical chains (non-fork)", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            // Core
            core,
            // Action 5 (Recover Chain ID)
            actionRecoverChainId,
            // EvmChainID
            web3.eth.abi.encodeParameter("uint256", 1).substring(2),
            // NewChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK
            ],
            1,
            2
        );

        try {
            await initialized.methods.submitRecoverChainId("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });
            assert.fail("recover chain ID governance packet on supported chain accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "not a fork")
        }
    })

    it("should revert governance packets from old guardian set", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        data = [
            // Core
            core,
            // Action 4 (Transfer Fee)
            actionTransferFee,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // Amount
            web3.eth.abi.encodeParameter("uint256", 1).substring(2),
            // Recipient
            web3.eth.abi.encodeParameter("address", "0x0000000000000000000000000000000000000000").substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            0,
            0,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        let failed = false;
        try {
            await initialized.methods.submitTransferFees("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });
            assert.fail("governance packet of old guardian set accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "not signed by current guardian set")
        }
    })

    it("should time out old guardians", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = 11;
        const emitterAddress = "0x0000000000000000000000000000000000000000000000000000000000000eee"
        const data = "0xaaaaaa";

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
            ],
            0,
            2
        );

        // this should pass
        const current = await initialized.methods.parseAndVerifyVM("0x" + vm).call();

        assert.equal(current.valid, true)

        await advanceTimeAndBlock(100000);

        const expired = await initialized.methods.parseAndVerifyVM("0x" + vm).call();

        assert.equal(expired.valid, false)
    })

    it("should revert governance packets from wrong governance chain", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        data = [
            // Core
            core,
            // Action 4 (set fees)
            actionTransferFee,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // Amount
            web3.eth.abi.encodeParameter("uint256", 1).substring(2),
            // Recipient
            web3.eth.abi.encodeParameter("address", "0x0000000000000000000000000000000000000000").substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            0,
            0,
            999,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK,
            ],
            1,
            2
        );

        try {
            await initialized.methods.submitTransferFees("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });
            assert.fail("governance packet from wrong governance chain accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "wrong governance chain")
        }
    })

    it("should revert governance packets from wrong governance contract", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        data = [
            // Core
            core,
            // Action 4 (Transfer Fee)
            actionTransferFee,
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            web3.eth.abi.encodeParameter("uint256", 1).substring(2),
            web3.eth.abi.encodeParameter("address", "0x0000000000000000000000000000000000000000").substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            0,
            0,
            testGovernanceChainId,
            core,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK,
            ],
            1,
            2
        );

        try {
            await initialized.methods.submitTransferFees("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });
            assert.fail("governance packet from wrong governance contract accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "wrong governance contract")
        }
    })

    it("should revert on governance packets that already have been applied", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        data = [
            // Core
            core,
            // Action 4 (Transfer Fee)
            actionTransferFee,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // Amount
            web3.eth.abi.encodeParameter("uint256", 1).substring(2),
            // Recipient
            web3.eth.abi.encodeParameter("address", "0x0000000000000000000000000000000000000000").substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            0,
            0,
            testGovernanceChainId,
            testGovernanceContract,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK,
            ],
            1,
            2
        );

        await initialized.methods.submitTransferFees("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        try {
            await initialized.methods.submitTransferFees("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });

            assert.fail("governance packet accepted twice")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "governance action already consumed")
        }
    })

    it("should reject smart contract upgrades on forks", async function () {
        const mockInitialized = new web3.eth.Contract(MockImplementation.abi, Wormhole.address);
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        // simulate a fork
        await mockInitialized.methods.testOverwriteEVMChainId(fakeChainId, fakeEvmChainId).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const chainId = await initialized.methods.chainId().call();
        assert.equal(chainId, fakeChainId);

        const evmChainId = await initialized.methods.evmChainId().call();
        assert.equal(evmChainId, fakeEvmChainId);

        data = [
            // Core
            core,
            // Action 1 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK
            ],
            1,
            2
        );

        try {
            await initialized.methods.submitContractUpgrade("0x" + vm).send({
                value: 0,
                from: accounts[0],
                gasLimit: 1000000
            });

            assert.fail("governance packet accepted")
        } catch (e) {
            assert.equal(e.data[Object.keys(e.data)[0]].reason, "invalid fork")
        }
    })

    it("should allow recover chain ID governance packets forks", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract;

        data = [
            // Core
            core,
            // Action 5 (Recover Chain ID)
            actionRecoverChainId,
            // EvmChainID
            web3.eth.abi.encodeParameter("uint256", testEvmChainId).substring(2),
            // NewChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK
            ],
            1,
            2
        );

        await initialized.methods.submitRecoverChainId("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        const newChainId = await initialized.methods.chainId().call();
        assert.equal(newChainId, testChainId);

        const newEvmChainId = await initialized.methods.evmChainId().call();
        assert.equal(newEvmChainId, testEvmChainId);
    })

    it("should accept smart contract upgrades after chain ID has been recovered", async function () {
        const initialized = new web3.eth.Contract(ImplementationFullABI, Wormhole.address);
        const accounts = await web3.eth.getAccounts();

        const mock = await MockImplementation.new();

        const timestamp = 1000;
        const nonce = 1001;
        const emitterChainId = testGovernanceChainId;
        const emitterAddress = testGovernanceContract

        data = [
            // Core
            core,
            // Action 1 (Contract Upgrade)
            actionContractUpgrade,
            // ChainID
            web3.eth.abi.encodeParameter("uint16", testChainId).substring(2 + (64 - 4)),
            // New Contract Address
            web3.eth.abi.encodeParameter("address", mock.address).substring(2),
        ].join('')

        const vm = await signAndEncodeVM(
            timestamp,
            nonce,
            emitterChainId,
            emitterAddress,
            0,
            data,
            [
                testSigner1PK,
                testSigner2PK,
                testSigner3PK
            ],
            1,
            2
        );

        let before = await web3.eth.getStorageAt(Wormhole.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(before.toLowerCase(), lastDeployed.address.toLowerCase());

        let set = await initialized.methods.submitContractUpgrade("0x" + vm).send({
            value: 0,
            from: accounts[0],
            gasLimit: 1000000
        });

        let after = await web3.eth.getStorageAt(Wormhole.address, "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");

        assert.equal(after.toLowerCase(), mock.address.toLowerCase());

        const mockImpl = new web3.eth.Contract(MockImplementation.abi, Wormhole.address);

        let isUpgraded = await mockImpl.methods.testNewImplementationActive().call();

        assert.ok(isUpgraded);
    })
});

const signAndEncodeVM = async function (
    timestamp,
    nonce,
    emitterChainId,
    emitterAddress,
    sequence,
    data,
    signers,
    guardianSetIndex,
    consistencyLevel
) {
    const body = [
        web3.eth.abi.encodeParameter("uint32", timestamp).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint32", nonce).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint16", emitterChainId).substring(2 + (64 - 4)),
        web3.eth.abi.encodeParameter("bytes32", emitterAddress).substring(2),
        web3.eth.abi.encodeParameter("uint64", sequence).substring(2 + (64 - 16)),
        web3.eth.abi.encodeParameter("uint8", consistencyLevel).substring(2 + (64 - 2)),
        data.substr(2)
    ]

    const hash = web3.utils.soliditySha3(web3.utils.soliditySha3("0x" + body.join("")))

    let signatures = "";

    for (let i in signers) {
        const ec = new elliptic.ec("secp256k1");
        const key = ec.keyFromPrivate(signers[i]);
        const signature = key.sign(hash.substr(2), { canonical: true });

        const packSig = [
            web3.eth.abi.encodeParameter("uint8", i).substring(2 + (64 - 2)),
            zeroPadBytes(signature.r.toString(16), 32),
            zeroPadBytes(signature.s.toString(16), 32),
            web3.eth.abi.encodeParameter("uint8", signature.recoveryParam).substr(2 + (64 - 2)),
        ]

        signatures += packSig.join("")
    }

    const vm = [
        web3.eth.abi.encodeParameter("uint8", 1).substring(2 + (64 - 2)),
        web3.eth.abi.encodeParameter("uint32", guardianSetIndex).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint8", signers.length).substring(2 + (64 - 2)),

        signatures,
        body.join("")
    ].join("");

    return vm
}

const signAndEncodeVMFixedIndex = async function (
    timestamp,
    nonce,
    emitterChainId,
    emitterAddress,
    sequence,
    data,
    signers,
    guardianSetIndex,
    consistencyLevel
) {
    const body = [
        web3.eth.abi.encodeParameter("uint32", timestamp).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint32", nonce).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint16", emitterChainId).substring(2 + (64 - 4)),
        web3.eth.abi.encodeParameter("bytes32", emitterAddress).substring(2),
        web3.eth.abi.encodeParameter("uint64", sequence).substring(2 + (64 - 16)),
        web3.eth.abi.encodeParameter("uint8", consistencyLevel).substring(2 + (64 - 2)),
        data.substr(2)
    ]

    const hash = web3.utils.soliditySha3(web3.utils.soliditySha3("0x" + body.join("")))

    let signatures = "";

    for (let i in signers) {
        const ec = new elliptic.ec("secp256k1");
        const key = ec.keyFromPrivate(signers[i]);
        const signature = key.sign(hash.substr(2), { canonical: true });

        const packSig = [
            // Fixing the index to be zero to product a non-monotonic VM
            web3.eth.abi.encodeParameter("uint8", 0).substring(2 + (64 - 2)),
            zeroPadBytes(signature.r.toString(16), 32),
            zeroPadBytes(signature.s.toString(16), 32),
            web3.eth.abi.encodeParameter("uint8", signature.recoveryParam).substr(2 + (64 - 2)),
        ]

        signatures += packSig.join("")
    }

    const vm = [
        web3.eth.abi.encodeParameter("uint8", 1).substring(2 + (64 - 2)),
        web3.eth.abi.encodeParameter("uint32", guardianSetIndex).substring(2 + (64 - 8)),
        web3.eth.abi.encodeParameter("uint8", signers.length).substring(2 + (64 - 2)),

        signatures,
        body.join("")
    ].join("");

    return vm
}

function zeroPadBytes(value, length) {
    while (value.length < 2 * length) {
        value = "0" + value;
    }
    return value;
}

'''
'''--- lib/wormhole/ethereum/truffle-config.js ---
require("dotenv").config({ path: ".env" });
const HDWalletProvider = require("@truffle/hdwallet-provider");
const KLAYHDWalletProvider = require("truffle-hdwallet-provider-klaytn");
const Caver = require("caver-js");

module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 8545,
      network_id: "*",
    },
    // test network is the same as development but allows us to omit certain migrations
    test: {
      host: "127.0.0.1",
      port: 8545,
      network_id: "*",
    },
    ethereum: {
      provider: () =>
        new HDWalletProvider(process.env.MNEMONIC, "https://rpc.ankr.com/eth"),
      network_id: 1,
      confirmations: 1,
      timeoutBlocks: 200,
      skipDryRun: false,
    },
    rinkeby: {
      provider: () =>
        new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ankr.com/eth_rinkeby"
        ),
      network_id: 4,
      gas: 5500000,
      confirmations: 2,
      timeoutBlocks: 200,
      skipDryRun: true,
    },
    ethereum_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ankr.com/eth_goerli"
        );
      },
      network_id: "5",
    },
    ropsten_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ankr.com/eth_ropsten"
        );
      },
      network_id: "3",
    },
    bsc: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://bsc-dataseed.binance.org/"
        );
      },
      network_id: "56",
      gas: 70000000,
      gasPrice: 8000000000,
    },
    bsc_testnet: {
      provider: () =>
        new HDWalletProvider(
          process.env.MNEMONIC,
          "https://data-seed-prebsc-1-s1.binance.org:8545/"
        ),
      network_id: "97",
    },
    polygon: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://polygon-rpc.com"
        );
      },
      network_id: "137",
      gas: 10000000,
      gasPrice: 700000000000,
    },
    polygon_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ankr.com/polygon_mumbai"
        );
      },
      network_id: "80001",
    },
    avalanche: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://api.avax.network/ext/bc/C/rpc"
        );
      },
      network_id: "43114",
      gas: 8000000,
      gasPrice: 26000000000,
    },
    avalanche_testnet: {
      provider: () =>
        new HDWalletProvider(
          process.env.MNEMONIC,
          "https://api.avax-test.network/ext/bc/C/rpc"
        ),
      network_id: "43113",
    },
    oasis: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://emerald.oasis.dev/"
        );
      },
      network_id: 42262,
    },
    oasis_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://testnet.emerald.oasis.dev"
        );
      },
      network_id: 42261,
    },
    aurora: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://mainnet.aurora.dev"
        );
      },
      network_id: 0x4e454152,
      from: "0xE2e2d9E31d7e1CC1178Fe0d1c5950f6C809816a3",
    },
    aurora_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://testnet.aurora.dev"
        );
      },
      network_id: 0x4e454153,
      gas: 10000000,
      from: "0x3bC7f2e458aC4E55F941C458cfD8c6851a591B4F", // public key
    },
    fantom: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ftm.tools/"
        );
      },
      network_id: 250,
      gas: 8000000,
      gasPrice: 3000000000000,
      timeoutBlocks: 15000,
    },
    fantom_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.testnet.fantom.network/"
        );
      },
      network_id: 0xfa2,
    },
    karura: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          // NOTE: To use this local host, needed to run this: ENDPOINT_URL=wss://karura-rpc-1.aca-api.network npx @acala-network/eth-rpc-adapter@latest
          // "http://localhost:8545"
          "https://eth-rpc-karura.aca-api.network/"
        );
      },
      network_id: 686,
      // NOTE: run ./karura-gas-prices and update the following two values, otherwise the transactions will likely fail
      gasPrice: "0x2fad8f03ea",
      gasLimit: "0x329b140",
      gas: "0x329b140",
    },
    karura_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://karura-dev.aca-dev.network/eth/http"
        );
      },
      network_id: 596,
      gasPrice: "0x2f7e8805de",
      gasLimit: "0x329b140",
      gas: "0x329b0dc",
    },
    acala: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          // To use this local host, needed to run this: ENDPOINT_URL=wss://acala-rpc-0.aca-api.network npx @acala-network/eth-rpc-adapter@latest
          //"http://localhost:8545"
          "https://eth-rpc-acala.aca-api.network/"
        );
      },
      network_id: 787,
      gasPrice: "0x2f3e3403ea",
      gas: "0x6fc3540",
    },
    acala_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://acala-dev.aca-dev.network/eth/http"
        );
      },
      network_id: 597,
      gasPrice: "0x2ed51903ea",
      gasLimit: "0x6fc3540",
      gas: "0x329b0dc",
    },
    klaytn: {
      // Note that Klaytn works with version 5.3.14 of truffle, but not some of the newer versions.
      provider: () => {
        return new KLAYHDWalletProvider(
          process.env.MNEMONIC,
          "https://public-node-api.klaytnapi.com/v1/cypress"
        );
      },
      network_id: "8217", //Klaytn mainnet's network id
      gas: "8500000",
      gasPrice: null,
    },
    klaytn_testnet: {
      // Note that Klaytn works with version 5.3.14 of truffle, but not some of the newer versions.
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://api.baobab.klaytn.net:8651/"
        );
      },
      network_id: "1001",
      gas: "8500000",
      gasPrice: null,
    },
    celo: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://forno.celo.org"
        );
      },
      network_id: 42220,
      gas: 8000000,
      gasPrice: null,
    },
    celo_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://alfajores-forno.celo-testnet.org"
        );
      },
      network_id: 44787,
    },
    moonbeam: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.api.moonbeam.network"
          //"https://moonbeam.api.onfinality.io/public" // When the core was deployed on 7/21/2022, the one above kept timing out but this one worked.
        );
      },
      network_id: 1284,
    },
    moonbeam_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.api.moonbase.moonbeam.network"
        );
      },
      network_id: 1287,
      gasPrice: 3000000000, // 3.0 gwei
      timeoutBlocks: 15000,
    },
    neon_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://proxy.devnet.neonlabs.org/solana"
        );
      },
      network_id: "*",
      gas: 3000000000,
      gasPrice: 443065000000,
    },
    arbitrum: {
      // Note that arbitrum did not work with our standard version of truffle (5.3.14), but it did work with the latest (5.5.22)
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://arb1.arbitrum.io/rpc"
        );
      },
      network_id: 42161,
    },
    arbitrum_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://goerli-rollup.arbitrum.io/rpc"
        );
      },
      network_id: 421613,
    },
    optimism: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://mainnet.optimism.io"
        );
      },
      network_id: 10,
    },
    optimism_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.ankr.com/optimism_testnet"
          // "https://goerli.optimism.io"  <== This didn't work for testnet
        );
      },
      network_id: 420,
    },
    gnosis: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://rpc.gnosischain.com/"
        );
      },
      network_id: 100,
    },
    gnosis_testnet: {
      provider: () => {
        return new HDWalletProvider(
          process.env.MNEMONIC,
          "https://sokol.poa.network/"
        );
      },
      network_id: 77,
    },
  },

  compilers: {
    solc: {
      version: "0.8.4",
      settings: {
        optimizer: {
          enabled: true,
          runs: 200,
        },
      },
    },
  },

  plugins: ["@chainsafe/truffle-plugin-abigen", "truffle-plugin-verify"],

  api_keys: {
    etherscan: process.env.ETHERSCAN_KEY,
  },
};

'''
'''--- lib/wormhole/lp_ui/craco.config.js ---
const { addBeforeLoader, loaderByName } = require("@craco/craco");

module.exports = {
  webpack: {
    configure: (webpackConfig) => {
      const wasmExtensionRegExp = /\.wasm$/;
      webpackConfig.resolve.extensions.push(".wasm");

      webpackConfig.module.rules.forEach((rule) => {
        (rule.oneOf || []).forEach((oneOf) => {
          if (oneOf.loader && oneOf.loader.indexOf("file-loader") >= 0) {
            oneOf.exclude.push(wasmExtensionRegExp);
          }
        });
      });

      const wasmLoader = {
        test: /\.wasm$/,
        include: /node_modules\/(bridge|token-bridge)/,
        loaders: ["wasm-loader"],
      };

      addBeforeLoader(webpackConfig, loaderByName("file-loader"), wasmLoader);

      return webpackConfig;
    },
  },
};

'''
'''--- lib/wormhole/lp_ui/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- lib/wormhole/lp_ui/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- lib/wormhole/lp_ui/src/App.js ---
import Home from "./views/Home";

function App() {
  return <Home />;
}

export default App;

'''
'''--- lib/wormhole/lp_ui/src/components/ErrorBoundary.js ---
import { Typography } from "@material-ui/core";
import React from "react";

export default class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <Typography variant="h5" style={{ textAlign: "center", marginTop: 24 }}>
          "An unexpected error has occurred. Please refresh the page."
        </Typography>
      );
    }

    return this.props.children;
  }
}

'''
'''--- lib/wormhole/lp_ui/src/index.js ---
import { CssBaseline } from "@material-ui/core";
import { ThemeProvider } from "@material-ui/core/styles";
import ReactDOM from "react-dom";
import App from "./App";
import ErrorBoundary from "./components/ErrorBoundary";
import { LoggerProvider } from "./contexts/Logger";
import { SolanaWalletProvider } from "./contexts/SolanaWalletContext";
import { theme } from "./muiTheme";
import { SnackbarProvider } from "notistack";
import { EthereumProviderProvider } from "./contexts/EthereumProviderContext";
ReactDOM.render(
  <ErrorBoundary>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <SolanaWalletProvider>
        <EthereumProviderProvider>
          <SnackbarProvider maxSnack={3}>
            <LoggerProvider>
              <App />
            </LoggerProvider>
          </SnackbarProvider>
        </EthereumProviderProvider>
      </SolanaWalletProvider>
    </ThemeProvider>
  </ErrorBoundary>,
  document.getElementById("root")
);

'''
'''--- lib/wormhole/lp_ui/src/muiTheme.js ---
import { createTheme, responsiveFontSizes } from "@material-ui/core";

export const theme = responsiveFontSizes(
  createTheme({
    palette: {
      type: "dark",
      background: {
        default: "#080808",
        paper: "#020202",
      },
      divider: "#4e4e54",
      text: {
        primary: "rgba(255,255,255,0.98)",
      },
      primary: {
        main: "rgba(0, 116, 255, 0.8)", // #0074FF
      },
      secondary: {
        main: "rgb(0,239,216,0.8)", // #00EFD8
        light: "rgb(51, 242, 223, 1)",
      },
      error: {
        main: "#FD3503",
      },
    },
    typography: {
      fontFamily: "'Sora', sans-serif",
    },
    overrides: {
      MuiButton: {
        root: {
          borderRadius: 0,
          textTransform: "none",
        },
      },
    },
  })
);

'''
'''--- script/VAA.py ---
import string
from urllib.request import urlopen
import json
import argparse
import base64
from hexbytes import HexBytes

def main(args): 
    fetchVAA(args)

def fetchVAA(args):
    url = "https://wormhole-v2-testnet-api.certus.one/v1/signed_vaa/{}/{}/{}".format(args.chain, args.address, args.pos)
    response = urlopen(url)
    data_json = json.loads(response.read())
    output = base64.b64decode(data_json["vaaBytes"]).hex()
    print("0x" + output)

def parse_args(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--chain", type=str)
    parser.add_argument("--address", type=str)
    parser.add_argument("--pos", type=str)
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args() 
    main(args)
'''