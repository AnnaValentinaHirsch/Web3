*GitHub Repository "GildedHonour/antioquia_smart_contracts"*

'''--- README.md ---
# Antioquia smart contracts

## Escrow

on testnet: [escrow.antioquia.testnet](https://explorer.testnet.near.org/accounts/escrow.antioquia.testnet)

[description](escrow/README.md)

## Lottery

on testnet: [lottery.antioquia.testnet](https://explorer.testnet.near.org/accounts/lottery.antioquia.testnet)

[description](lottery/README.md)

## Donation

on testnet: [donation.antioquia.testnet](https://explorer.testnet.near.org/accounts/donation.antioquia.testnet)

[description](donation/README.md)

---

## How to compile a contract and call its methods

#### prepare
compile the smart contract
```bash
env 'RUSTFLAGS=-C link-arg=-s' 
cargo build --target wasm32-unknown-unknown --release
```

install the NEAR CLI
```bash
npm i near-cli
```

log in; your account will be created in `/home/{user123}/.near-credentials/{testnet|mainnet}/`

```bash
near login
```

deploy a contract, with the **escrow** contract as an example:
```bash

# (1)
near deploy --wasmFile target/wasm32-unknown-unknown/release/antioquia_escrow.wasm --accountId antioquia.testnet

# (2) or, from a different account
near deploy --wasmFile target/wasm32-unknown-unknown/release/antioquia_escrow.wasm --accountId escrow.antioquia.testnet

# (3) or, from a dev account which will be created in the current directory
near dev-deploy --wasmFile target/wasm32-unknown-unknown/release/antioquia_escrow.wasm

# (4) deploy and call the 'init' method (special method) at once
near deploy --wasmFile out/example.wasm --accountId example-contract.testnet --initFunction new --initArgs '{"owner_id": "example-contract.testnet", "total_supply": "10000000"}'
```

alternatively, build and deployt it by script
```bash
./deploy.sh
```

### use
call a method
```bash
near call <CONTRACT_ID> <METHOD1> '{"arg1": "val1", "arg2" : 666}' --accountId <ACCOUNT_ID>

# for example
# create a new escrow
# notice '--amount <....>' parameter
# which means that some $coins are being sent to the contract
near call escrow.antioquia.testnet new '{"escrow_id": "1aa", "funder_id": "11", "beneficiary_id": "22", "agreed_amount": 555}' --amount 0.000000000000000000000010 --accountId antioquia.testnet 

# set fees (you must be the owner/admin)
near call escrow.antioquia.testnet set_base_fee_percentage '{"new_fee": 3}' --accountId escrow.antioquia.testnet
```

call a view method
```bash
near view escrow.antioquia.testnet get_base_fee_percentage --accountId antioquia.testnet
```

---
links:

* https://docs.near.org/tools/near-cli
* https://learn.figment.io/tutorials/write-and-deploy-a-smart-contract-on-near

'''
'''--- README_RU.md ---
# Antioquia smart contracts

## Lottery
TODO

## Donations
TODO

## Escrow

testnet:

mainnet:
'''
'''--- donation/Cargo.toml ---
[package]
name = "antioquia_donation"
version = "1.0.0"
authors = ["alex maslakoff <trabajar.duro@serendipia.email>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1.1"
uint = { version = "0.9.5", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- donation/README.md ---
# Donation smart contract

---
## methods

call `init()` method to initialize escrow on the global level; use it only once

```rust
fn init(
  owner_account_id: Option<AccountId>
  base_fee_percent: Option<u128>
)

/*
wherein:
  * owner_id - an account of an owner/admin; if the value isn't not provided, the caller will become the one.
  * base_fee_percent - percent of a fee that the owner/admin will receive off each deal
*/
```

to send a donation:

```rust
#[payable]
send(
    donation_id: DonationId,
    receiver_account_id: AccountId,
    agreed_amount: Balance,
)

/*
wherein:
  * donation_id - random string that'll be ID of a donation
  * receiver_account_id - account address of the other party
  * amount - how much to send to the receiver
  * current_fee_percentage - fee percentage in this donation; if not provided, the base_fee_percentage will get used instead
*/
```

to get information about a donation:
```rust
fn get_donation(
  donation_id: DonationId
)
```
'''
'''--- donation/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- donation/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_donation'"
near deploy --accountId donation.antioquia.testnet --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_donation.wasm
'''
'''--- donation/dev-deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_donation'"
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_donation.wasm
'''
'''--- donation/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::TreeMap;
use near_sdk::{env, log, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise};
use std::collections::BTreeMap;

type DonationId = String;

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DonationItem {
    pub donation_id: DonationId,
    pub sender_account_id: AccountId,
    pub receiver_account_id: AccountId,
    pub amount: Balance,
    pub current_fee_percent: u128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Donation {
    pub owner_account_id: AccountId,
    pub base_fee_percent: u128,
    pub items: TreeMap<DonationId, DonationItem>,
}

#[near_bindgen]
impl Donation {
    const MIN_FEE_PERCENT: u128 = 0;
    const MAX_FEE_PERCENT: u128 = 100;
    const HUNDRED_PERCENT: u128 = 100;

    #[init]
    pub fn init(_owner_account_id: Option<AccountId>, base_fee_percent: Option<u128>) -> Self {
        require!(!env::state_exists(), "Already initialized");
        let owner_account_id = _owner_account_id.unwrap_or(env::signer_account_id());
        let base_fee_percent2 = base_fee_percent.unwrap_or(Self::MIN_FEE_PERCENT);
        require!(
            (base_fee_percent2 >= Self::MIN_FEE_PERCENT)
                && (base_fee_percent2 <= Self::MAX_FEE_PERCENT),
            format!(
                "base_fee_percent must be between {}..{}",
                &Self::MIN_FEE_PERCENT,
                &Self::MAX_FEE_PERCENT
            )
        );

        let items: TreeMap<DonationId, DonationItem> = TreeMap::new(b"d");
        Self {
            owner_account_id,
            base_fee_percent: base_fee_percent2,
            items,
        }
    }

    ///makes a donation transaction
    #[payable]
    pub fn send(
        &mut self,
        donation_id: DonationId,
        receiver_account_id: AccountId,
        amount: Balance,
    ) -> (Balance, Balance) {
        require!(amount > 0, "amount must be greater than 0");

        let donation = DonationItem {
            donation_id: donation_id.clone(),
            sender_account_id: env::predecessor_account_id(),
            receiver_account_id: receiver_account_id.clone(),
            amount: amount,
            current_fee_percent: self.base_fee_percent,
        };

        self.items.insert(&donation_id.clone(), &donation);

        let amount_for_receiver = donation.amount / Self::HUNDRED_PERCENT
            * (Self::HUNDRED_PERCENT - donation.current_fee_percent);
        let amount_for_owner = donation.amount - amount_for_receiver;

        let p1 = Promise::new(receiver_account_id.clone()).transfer(amount_for_receiver);
        let p2 = Promise::new(self.owner_account_id.clone()).transfer(amount_for_owner);

        (amount_for_receiver, amount_for_owner)
    }

    pub fn get_donation(&self, donation_id: DonationId) -> BTreeMap<String, String> {
        let donation = self.items.get(&donation_id).unwrap();
        let mut tree: BTreeMap<String, String> = BTreeMap::new();
        tree.insert(
            String::from("donation_id"),
            String::from(donation_id.clone()),
        );

        tree.insert(
            String::from("sender_account_id"),
            String::from(donation.sender_account_id),
        );

        tree.insert(
            String::from("receiver_account_id"),
            String::from(donation.receiver_account_id),
        );

        tree.insert(
            String::from("amount"),
            String::from(donation.amount.to_string()),
        );

        tree.insert(
            String::from("fee_percent"),
            String::from(donation.current_fee_percent.to_string()),
        );

        tree
    }
}

'''
'''--- escrow/.rustfmt.toml ---
max_width = 120
'''
'''--- escrow/Cargo.toml ---
[package]
name = "antioquia_escrow"
version = "1.0.0"
authors = ["alex maslakoff <trabajar.duro@serendipia.email>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.5", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- escrow/README.md ---
# Escrow smart contract

---
## methods

call `init()` method to initialize escrow on the global level; use it only once

```rust
fn init(
  owner_id: Option<AccountId>
  base_fee_percentage: Option<u128>
)

/*
wherein:
  * owner_id - an account of an owner/admin; if the value isn't not provided, the caller will become the one.
  * base_fee_percentage - the percentage of a fee that the owner/admin will receive off each deal
*/
```

to create a new deal, call `new()`; and attach `agreed_amount` of coins to it

```rust
#[payable]
fn new(
  escrow_id: EscrowId,
  funder_id: AccountId,
  beneficiary_id: AccountId,
  agreed_amount: Balance,
  current_fee_percentage: Option<u128>
)

/*
wherein:
  * escrow_id - random string that'll be ID of escrow
  * funder_id - account address of a funder/client
  * beneficiary_id - account address of the other party
  * agreed_amount - how much to deposit in escrow
  * current_fee_percentage - fee percentage in this escrow; if not provided, the base_fee_percentage will get used instead
*/
```

then either release escrow, if a deal has been finished successfully

```rust
fn release_deposit(
  escrow_id: EscrowId
)

/*
wherein:
  * escrow_id - escrow ID
*/
```

or reimburse the other party otherwise

```rust
fn reimburse_funder(
  escrow_id: EscrowId
)

/*
wherein:
  * escrow_id - escrow ID 
*/
```

other methods

```rust
fn get_base_fee_percentage() -> Balance
fn get_owner_id() -> AccountId
fn get_item(escrow_id: EscrowId) -> Option<EscrowItem>
fn set_base_fee_percentage(new_fee: Balance)

//withdraw all the coins of an escrow to the admin's/owner's account
//use it only when there's an urgent need to do it
fn emergency_withdraw(escrow_id: EscrowId)
```

'''
'''--- escrow/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- escrow/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_escrow'"
near deploy --accountId escrow.antioquia.testnet --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_escrow.wasm
'''
'''--- escrow/dev-deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_escrow'"
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_escrow.wasm
'''
'''--- escrow/my_notes/1.txt ---
near deploy --wasmFile target/wasm32-unknown-unknown/release/antioquia_escrow.wasm --accountId escrow.antioquia.testnet

near call escrow.antioquia.testnet get_base_fee_percentage --accountId escrow.antioquia.testnet
near view escrow.antioquia.testnet get_base_fee_percentage --accountId escrow.antioquia.testnet

'''
'''--- escrow/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::TreeMap;
use near_sdk::{env, log, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise};

type EscrowId = String;

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
pub enum Status {
    New,
    Active,
    PayedOff,
    Reimbursed,
}

//TODO add a separate status for 'EscrowFundsStatus'
//

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct EscrowItem {
    pub escrow_id: EscrowId,
    pub status: Status,
    pub funder_account_id: AccountId,
    pub beneficiary_account_id: AccountId,
    pub agreed_amount: Balance,
    pub current_amount: Balance,
    pub current_fee_percent: u128,

    // pub inserted_at: u64,
    // pub funded_at: u64,
    // pub finished_at: u64,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Escrow {
    pub owner_id: AccountId,
    pub base_fee_percent: u128,
    pub items: TreeMap<EscrowId, EscrowItem>,
}

#[near_bindgen]
impl Escrow {
    const MIN_FEE_PERCENT: u128 = 0;
    const MAX_FEE_PERCENT: u128 = 100;
    const HUNDRED_PERCENT: u128 = 100;

    /// initialize Escrow globally;
    /// it has to be called only once;
    /// * `base_fee_percent` - percent; has to be in between MIN_FEE_PERCENT and MAX_FEE_PERCENT
    #[init]
    pub fn init(_owner_id: Option<AccountId>, base_fee_percent: Option<u128>) -> Self {
        require!(!env::state_exists(), "Already initialized");
        let owner_id = _owner_id.unwrap_or(env::signer_account_id());

        let base_fee_percent2 = base_fee_percent.unwrap_or(Self::MIN_FEE_PERCENT);
        require!(
            (base_fee_percent2 >= Self::MIN_FEE_PERCENT) && (base_fee_percent2 <= Self::MAX_FEE_PERCENT),
            format!(
                "base_fee_percent must be between {}..{}",
                &Self::MIN_FEE_PERCENT,
                &Self::MAX_FEE_PERCENT
            )
        );

        let items: TreeMap<EscrowId, EscrowItem> = TreeMap::new(b"t");
        Self {
            owner_id,
            base_fee_percent: base_fee_percent2,
            items,
        }
    }

    /// returns base_fee as percent
    pub fn get_base_fee_percent(&self) -> Balance {
        self.base_fee_percent
    }

    /// returns the Id of the owner
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// set base_fee as percent
    /// it has to be in between MIN_FEE_PERCENT and MAX_FEE_PERCENT
    pub fn set_base_fee_percent(&mut self, new_fee: Balance) -> Balance {
        require!(
            self.owner_id == env::predecessor_account_id(),
            "only owner may call this method"
        );
        let cond = (new_fee >= Self::MIN_FEE_PERCENT) && (new_fee <= Self::MAX_FEE_PERCENT);
        require!(
            cond,
            format!(
                "fee_percent must to be between {} and {}",
                Self::MIN_FEE_PERCENT,
                Self::MAX_FEE_PERCENT
            )
        );
        self.base_fee_percent = new_fee;
        self.base_fee_percent
    }

    ///creates and activates a new escrow
    ///requires a payment
    #[payable]
    pub fn new(
        &mut self,
        escrow_id: EscrowId,
        funder_account_id: AccountId,
        beneficiary_account_id: AccountId,
        agreed_amount: Balance,
        current_fee_percent: Option<u128>,
    ) -> Option<EscrowId> {
        require!(agreed_amount > 0, "agreed_amount must be greater than 0");

        let actual_amount: Balance = env::attached_deposit();
        require!(
            actual_amount > 0,
            format!("expected deposit: {}; actual one: {}", agreed_amount, actual_amount)
        );
        require!(
            agreed_amount == actual_amount,
            format!(
                "agreed_amount and actual_amount must be equal: {} and {}",
                agreed_amount, actual_amount
            )
        );

        let cond = (self.owner_id == env::predecessor_account_id()) || (funder_account_id == env::predecessor_account_id());
        require!(cond, "only funder or owner of this escrow may call this method");

        //FIXME:
        //in case of any error, return the funds to the funder
        //Promise::new(env::predecessor_account_id()).transfer(env::attached_deposit());

        if !self.items.contains_key(&escrow_id) {
            let new_item = EscrowItem {
                escrow_id: escrow_id.clone(),
                agreed_amount,
                current_amount: agreed_amount,
                status: Status::Active,
                funder_account_id,
                beneficiary_account_id,
                current_fee_percent: current_fee_percent.unwrap_or(self.base_fee_percent),
            };

            self.items.insert(&escrow_id.clone(), &new_item);
            Some(escrow_id)
        } else {
            log!("escrow_id '{}' already exists; generate a new one", escrow_id);
            None
        }
    }

    /// releases funds to beneficiary:
    ///     (100 - fee %)    --> to beneficiary
    ///     (fee %)          --> to owner
    ///
    /// who may call this method
    ///     * owner
    ///     * funder
    pub fn release_deposit(&mut self, escrow_id: EscrowId) {
        match self.items.get(&escrow_id) {
            Some(mut escrow_item) => {
                require!(escrow_item.status == Status::Active, "this escrow isn't active");
                let authoriz_cond = (self.owner_id == env::predecessor_account_id())
                    || (escrow_item.funder_account_id == env::predecessor_account_id());
                require!(
                    authoriz_cond,
                    "only funder or owner of this escrow may call this method"
                );
                require!(
                    escrow_item.current_amount >= escrow_item.agreed_amount,
                    format!(
                        "the amount of the actual deposit ({}) must be equal of greater than the agreed amount ({})",
                        escrow_item.current_amount, escrow_item.agreed_amount
                    )
                );

                let amount_for_beneficiary = escrow_item.agreed_amount / Self::HUNDRED_PERCENT
                    * (Self::HUNDRED_PERCENT - escrow_item.current_fee_percent);
                let amount_for_owner = escrow_item.agreed_amount - amount_for_beneficiary;

                //due to a potential rounding error,
                //verify that there'll be enough of the funds
                let amounts_sum = amount_for_beneficiary + amount_for_owner;
                let calc_cond = escrow_item.current_amount >= amounts_sum;
                require!(calc_cond, format!("current_amount ({}) must be equal to or greater than the sum of the amounts to be released ({});", escrow_item.current_amount, amounts_sum));

                //send funds to the beneficiary
                let p1 = Promise::new(escrow_item.beneficiary_account_id.clone()).transfer(amount_for_beneficiary);
                escrow_item.current_amount -= amount_for_beneficiary;
                log!(
                    "releasing '{}' to beneficiary '{}'; escrow_id '{}'",
                    amount_for_beneficiary,
                    escrow_item.beneficiary_account_id,
                    escrow_id
                );

                //send the fees to the owner
                let p2 = Promise::new(self.owner_id.clone()).transfer(amount_for_owner);
                p1.then(p2);
                //FIXME verify that _p1 has returned successfully
                escrow_item.current_amount -= amount_for_owner;
                log!(
                    "sending commission of '{}' ({}%) to owner_id '{}'; escrow_id '{}'",
                    amount_for_owner,
                    escrow_item.current_fee_percent,
                    self.owner_id,
                    escrow_id
                );

                escrow_item.status = Status::PayedOff;
            }
            None => {
                //FIXME return None or Error
                log!("escrow_id '{}' not found", escrow_id)
            }
        }
    }

    /// reimburse the funder the funds
    /// who may call this method:
    ///     * owner
    ///     * beneficiary
    pub fn reimburse_funder(&self, escrow_id: EscrowId) {
        match self.items.get(&escrow_id) {
            Some(mut escrow_item) => {
                require!(escrow_item.status == Status::Active, "this escrow isn't active");

                let cond = (self.owner_id == env::predecessor_account_id())
                    || (escrow_item.beneficiary_account_id == env::predecessor_account_id());
                require!(cond, "only beneficiary or owner may call this method");

                //verify that there'll be enough of the funds
                let calc_cond = escrow_item.current_amount >= escrow_item.agreed_amount;
                require!(
                    calc_cond,
                    format!(
                        "current_amount ({}) must be equal to or greater than agreed_amount ({});",
                        escrow_item.current_amount, escrow_item.agreed_amount
                    )
                );

                let _p1 = Promise::new(escrow_item.funder_account_id.clone()).transfer(escrow_item.agreed_amount);
                //FIXME verify that _p1 has returned successfully
                escrow_item.status = Status::Reimbursed;
                escrow_item.current_amount = 0;
            }
            None => {
                //FIXME return None or Error
                //todo!()
                log!("escrow_id '{}' not found", escrow_id);
            }
        }
    }

    pub fn remove_item(&mut self, escrow_id: EscrowId) {
        match self.items.get(&escrow_id) {
            Some(escrow_item) => {
                require!(
                    escrow_item.status != Status::Active,
                    format!("escrow id {} is active, therefore it may not be removed", escrow_id)
                );

                require!(self.owner_id == env::predecessor_account_id(), "owner's only method");
                self.items.remove(&escrow_id);
            }
            None => {
                log!("escrow_id '{}' not found", escrow_id)
            }
        }
    }

    pub fn emergency_withdraw(&mut self, escrow_id: EscrowId) {
        match self.items.get(&escrow_id) {
            Some(mut escrow_item) => {
                require!(self.owner_id == env::predecessor_account_id(), "owner's only method");
                let _p1 = Promise::new(self.owner_id.clone()).transfer(escrow_item.current_amount);
                log!(
                    "emergency withdrawal from an escrow by owner; amount: {}, escrow_id: {}, owner_id: {}",
                    escrow_item.current_amount,
                    escrow_id,
                    self.owner_id
                );

                //FIXME
                //verify that the _p1 has finished successfully
                escrow_item.current_amount = 0;
            }
            None => {
                log!("escrow_id '{}' not found", escrow_id)
            }
        }
    }

    /// returns the balance of an EscrowItem
    pub fn get_balance(&self, escrow_id: EscrowId) -> Option<Balance> {
        match self.items.get(&escrow_id) {
            Some(item) => {
                require!(item.agreed_amount == item.current_amount);
                Some(item.agreed_amount)
            }
            None => None,
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        let account0: AccountId = "0.near".parse().unwrap();
        builder
            .current_account_id(account0)
            .signer_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .is_view(is_view);

        builder
    }

    #[test]
    fn test_init_contract() {
        let context = get_context(false);
        //TODO
        assert_eq!(true, true);
    }
}

'''
'''--- lottery/Cargo.toml ---
[package]
name = "antioquia_lottery"
version = "1.0.0"
authors = ["alex maslakoff <trabajar.duro@serendipia.email>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1.1"
uint = { version = "0.9.5", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- lottery/README.md ---
# Lottery smart contract

---
## methods

call `init()` method to initialize lottery on the global level; use it only once

```rust
fn init(
  owner_account_id: Option<AccountId>
  base_fee_percent: Option<u128>
)

/*
wherein:
  * owner_id - an account of an owner/admin; if the value isn't not provided, the caller will become the one.
  * base_fee_percent - percent of a fee that the owner/admin will receive off each deal
*/
```

to create a new lottery:

```rust
#[payable]
fn new(
    lottery_id: LotteryId,
    organiser_account_id: AccountId,
    agreed_prize_amount: Balance,
    current_fee_percent: Option<u128>,
)
/*
wherein:
  * lottery_id - random string that'll be ID of lottery
  * organiser_account_id - account address of a organiser
  * agreed_prize_amount - how much is the prize
  * current_fee_percentage - fee percentage in this escrow; if not provided, the base_fee_percentage will get used instead
*/
```

to add a new participant, or opt out an existing one:

```rust
fn add_participant(
    lottery_id: LotteryId,
    participant_account_id: AccountId
)

fn opt_out_participant(
    lottery_id: LotteryId,
    participant_account_id: AccountId
)

/*
wherein:
  * lottery_id - random string that'll be ID of lottery
  * participant_account_id - account address of a participant
*/
```

to pick a winner, randomly; or to get one:
```rust
fn pick_random_winner(
    lottery_id: LotteryId
)

fn get_winner(
    lottery_id: LotteryId
)
```

to send the prize to the winner:

```rust
fn release_prize_to_winner(
    lottery_id: LotteryId
)
```

to get a lottery info:

```rust
fn get_lottery(
    lottery_id: LotteryId
)
```

to get the current balance/prize of lottery; if the whole prize has been sent to the winner, the balance becomes 0;
```rust
fn get_current_balance(
    lottery_id: LotteryId
)
```
'''
'''--- lottery/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- lottery/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_lottery'"
near deploy --accountId lottery.antioquia.testnet --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_lottery.wasm
'''
'''--- lottery/dev-deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract 'antioquia_lottery'"
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/antioquia_lottery.wasm
'''
'''--- lottery/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::TreeMap;
use near_sdk::{env, log, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise};
use std::collections::BTreeMap;

//TODO replace with the proper type - UUID
type LotteryId = String;

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
pub enum Status {
    Draft,
    Canceled,
    New,
    // NOTE
    // when and if a need to open and close
    // registration at certain time arises,
    // uncomment this:
    //
    // RegistrationOpen,
    // RegistrationClosed,
    //
    Active,
    Over,
    Closed,
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
pub enum PrizeStatus {
    DepositPending,
    DepositFunded,
    WinnerPayedOff,
    OwnerReimbursed,
    //PartiallyPayedOffAndReimbursed,
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug, Copy, Clone)]
pub enum ParticipantStatus {
    Active,
    OptedOut,
    Suspended,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct LotteryItem {
    pub lottery_id: LotteryId,
    pub status: Status,
    pub organiser_account_id: AccountId,

    // use the standard BTreeMap in order to avoid generating 'prefix'
    // pub participants: TreeMap<AccountId, Participant>,
    pub participants: BTreeMap<AccountId, Participant>,

    pub winner: Option<AccountId>,
    pub agreed_prize_amount: Balance,
    pub current_balance: Balance,
    pub prize_status: PrizeStatus,
    pub current_fee_percent: u128,
    // pub amount_paid_off: bool,
    // pub started_at: u128
    // pub ended_at: u128
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Copy, Clone)]
pub struct Participant {
    pub status: ParticipantStatus,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Lottery {
    pub owner_account_id: AccountId,
    pub base_fee_percent: u128,
    pub items: TreeMap<LotteryId, LotteryItem>,
}

#[near_bindgen]
impl Lottery {
    const MIN_FEE_PERCENT: u128 = 0;
    const MAX_FEE_PERCENT: u128 = 100;
    const HUNDRED_PERCENT: u128 = 100;

    #[init]
    pub fn init(_owner_account_id: Option<AccountId>, base_fee_percent: Option<u128>) -> Self {
        require!(!env::state_exists(), "Already initialized");
        let owner_account_id = _owner_account_id.unwrap_or(env::signer_account_id());
        let base_fee_percent2 = base_fee_percent.unwrap_or(Self::MIN_FEE_PERCENT);
        require!(
            (base_fee_percent2 >= Self::MIN_FEE_PERCENT)
                && (base_fee_percent2 <= Self::MAX_FEE_PERCENT),
            format!(
                "base_fee_percent must be between {}..{}",
                &Self::MIN_FEE_PERCENT,
                &Self::MAX_FEE_PERCENT
            )
        );

        let items: TreeMap<LotteryId, LotteryItem> = TreeMap::new(b"t");
        Self {
            owner_account_id,
            base_fee_percent: base_fee_percent2,
            items,
        }
    }

    ///creates a new lottery
    ///and deposits funds
    #[payable]
    pub fn new(
        &mut self,
        lottery_id: LotteryId,
        organiser_account_id: AccountId,
        agreed_prize_amount: Balance,
        current_fee_percent: Option<u128>,
    ) -> Option<LotteryId> {
        require!(
            agreed_prize_amount > 0,
            "agreed_prize_amount must be greater than 0"
        );
        let attached_deposit_amount: Balance = env::attached_deposit();
        require!(
            attached_deposit_amount > 0,
            format!("attached_deposit_amount must be greater than 0")
        );

        //TODO may not be needed
        // require!(organiser_account_id == env::predecessor_account_id(), "'organiser_account_id' argument must match the account id this method is being called from");

        if !self.items.contains_key(&lottery_id) {
            require!(
                agreed_prize_amount == attached_deposit_amount,
                format!(
                    "agreed_prize_amount and attached_deposit_amount must be equal: {} and {}",
                    agreed_prize_amount, attached_deposit_amount
                )
            );

            //FIXME: generate prefixes dynamically for near_sdk::TreeMap
            // let pts: TreeMap<AccountId, Participant> = TreeMap::new(lottery_id.as_bytes());

            let pts: BTreeMap<AccountId, Participant> = BTreeMap::new();
            let new_item = LotteryItem {
                lottery_id: lottery_id.clone(),
                agreed_prize_amount,
                status: Status::New,
                prize_status: PrizeStatus::DepositFunded,
                organiser_account_id,
                current_fee_percent: current_fee_percent.unwrap_or(self.base_fee_percent),
                current_balance: attached_deposit_amount,
                participants: pts,
                winner: None,
            };

            self.items.insert(&lottery_id.clone(), &new_item);
            Some(lottery_id)
        } else {
            log!(
                "lottery_id '{}' already exists; generate a new one",
                lottery_id
            );
            None
        }
    }

    pub fn add_participant(
        &mut self,
        lottery_id: LotteryId,
        participant_account_id: AccountId,
    ) -> Option<AccountId> {
        let mut lottery = self.items.get(&lottery_id).unwrap();
        let authoriz_cond = (self.owner_account_id == env::predecessor_account_id())
            || (lottery.organiser_account_id == env::predecessor_account_id());
        require!(
            authoriz_cond,
            "only organiser or owner of this lottery may call this method"
        );

        if lottery.participants.contains_key(&participant_account_id) {
            log!(
                "participant with account_id '{}' already exists",
                participant_account_id
            );
            None
        } else {
            let new_pt = Participant {
                status: ParticipantStatus::Active,
            };

            lottery
                .participants
                .insert(participant_account_id.clone(), new_pt);

            //re-insert the current lottery item
            //this is required in order make the collection update itself
            self.items.insert(&lottery_id, &lottery);

            Some(participant_account_id.clone())
        }
    }

    pub fn opt_out_participant(
        &mut self,
        lottery_id: LotteryId,
        participant_account_id: AccountId,
    ) {
        let mut lottery = self.items.get(&lottery_id).unwrap();

        let authoriz_cond = (self.owner_account_id == env::predecessor_account_id())
            || (lottery.organiser_account_id == env::predecessor_account_id());
        require!(
            authoriz_cond,
            "only organiser or owner of this lottery may call this method"
        );

        let mut pt = lottery
            .participants
            .get_mut(&participant_account_id)
            .unwrap();
        pt.status = ParticipantStatus::OptedOut;

        //re-insert the current lottery item
        //this is required in order make the collection update itself
        self.items.insert(&lottery_id, &lottery);
    }

    //TODO: can be improved
    pub fn pick_random_winner(&mut self, lottery_id: LotteryId) -> AccountId {
        const MIDDLE: usize = 16;

        let mut lottery = self.items.get(&lottery_id).unwrap();
        let authoriz_cond = (self.owner_account_id == env::predecessor_account_id())
            || (lottery.organiser_account_id == env::predecessor_account_id());
        require!(
            authoriz_cond,
            "only organiser or owner of this lottery may call this method"
        );

        let wn = lottery.winner;
        require!(
            wn.is_none(),
            format!(
                "winner had already been chosen before: {}",
                wn.clone().unwrap()
            )
        );

        let account_ids: Vec<AccountId> = lottery
            .participants
            .iter()
            .filter(|(_, v)| v.status == ParticipantStatus::Active)
            .map(|(k, _)| (*k).clone())
            .collect();

        require!(
            account_ids.len() > 0,
            "the amount of active participants has to be greater than zero"
        );

        let rnd1 = self.random_in_range(MIDDLE, account_ids.len());
        let rnd_account_id = account_ids.get(rnd1 as usize).unwrap();
        lottery.winner = Some(rnd_account_id.clone());
        log!(
            "lottery_id: {}, random number: {}, the winner: {}",
            lottery_id,
            rnd1,
            rnd_account_id
        );

        //re-insert the current lottery item
        //this is required in order make the collection update itself
        self.items.insert(&lottery_id, &lottery);
        rnd_account_id.clone()
    }

    // returns random u8 number (0-254)
    fn random_u8(&self, index: usize) -> u8 {
        *env::random_seed().get(index).unwrap()
    }

    // returns random number from 0 to max
    fn random_in_range(&self, index: usize, max: usize) -> u32 {
        let rand_divider = 256 as f64 / (max + 1) as f64;
        let result = self.random_u8(index) as f64 / rand_divider;
        result as u32
    }

    pub fn get_lottery(&self, lottery_id: LotteryId) -> BTreeMap<String, String> {
        let lottery = self.items.get(&lottery_id).unwrap();
        let mut tree: BTreeMap<String, String> = BTreeMap::new();
        tree.insert(String::from("lottery_id"), String::from(lottery_id.clone()));

        tree.insert(
            String::from("organiser_account_id"),
            String::from(lottery_id),
        );

        tree.insert(
            String::from("status"),
            String::from(format!("{:?}", lottery.status)),
        );

        tree.insert(
            String::from("agreed_prize_amount"),
            String::from(lottery.agreed_prize_amount.to_string()),
        );

        tree.insert(
            String::from("status"),
            String::from(format!("{:?}", lottery.status)),
        );

        tree.insert(
            String::from("prize_status"),
            String::from(format!("{:?}", lottery.prize_status)),
        );

        let winner_key = String::from("winner_account_id");
        let winner_val = match lottery.winner {
            Some(acc_id) => String::from(acc_id),
            None => String::from("(null)"),
        };
        tree.insert(winner_key, winner_val);

        tree.insert(
            String::from("fee_percent"),
            String::from(lottery.current_fee_percent.to_string()),
        );

        tree.insert(
            String::from("total_participants"),
            String::from(format!("{:?}", lottery.participants.len())),
        );

        let ap_c = lottery
            .participants
            .iter()
            .filter(|(_, v)| v.status == ParticipantStatus::Active)
            .count();

        tree.insert(
            String::from("active_participants"),
            String::from(format!("{:?}", ap_c)),
        );

        tree
    }

    fn get_participant(
        &self,
        lottery_id: LotteryId,
        participant_account_id: AccountId,
    ) -> Option<Participant> {
        match self
            .items
            .get(&lottery_id)
            .unwrap()
            .participants
            .get(&participant_account_id)
        {
            Some(&pt) => Some(pt),
            None => None,
        }
    }

    pub fn get_winner(&self, lottery_id: LotteryId) -> Option<AccountId> {
        self.items.get(&lottery_id).unwrap().winner
    }

    //releases the prize to the winner
    pub fn release_prize_to_winner(&mut self, lottery_id: LotteryId) -> (Balance, Balance) {
        let mut lottery = self.items.get(&lottery_id).unwrap();
        let authoriz_cond = (self.owner_account_id == env::predecessor_account_id())
            || (lottery.organiser_account_id == env::predecessor_account_id());
        require!(
            authoriz_cond,
            "only organiser or owner of this lottery may call this method"
        );

        let amount_for_winner = lottery.agreed_prize_amount / Self::HUNDRED_PERCENT
            * (Self::HUNDRED_PERCENT - lottery.current_fee_percent);
        let amount_for_owner = lottery.agreed_prize_amount - amount_for_winner;

        //due to a potential rounding error,
        //verify that there'll be enough of the funds
        let amounts_sum = amount_for_winner + amount_for_owner;
        let calc_cond = lottery.current_balance >= amounts_sum;
        require!(calc_cond, format!("current_balance ({}) must be equal to or greater than the sum of the amounts to be released ({});", lottery.current_balance, amounts_sum));

        let winner_account_id = lottery.winner.as_ref().unwrap();

        //send funds to the winner
        let p1 = Promise::new(winner_account_id.clone()).transfer(amount_for_winner);
        lottery.current_balance -= amount_for_winner;
        log!(
            "releasing '{}' to winner '{}'; lottery_id '{}'",
            amount_for_winner,
            winner_account_id,
            lottery_id
        );

        //send the fees to the owner
        let p2 = Promise::new(self.owner_account_id.clone()).transfer(amount_for_owner);
        p1.then(p2);
        //FIXME verify that _p1 has returned successfully
        lottery.current_balance -= amount_for_owner;
        log!(
            "[lottery_id '{}'] sending commission of '{}' ({}%) to owner_account_id '{}'",
            lottery_id,
            amount_for_owner,
            lottery.current_fee_percent,
            self.owner_account_id
        );

        lottery.prize_status = PrizeStatus::WinnerPayedOff;

        //re-insert the current lottery item
        //this is required in order make the collection update itself
        self.items.insert(&lottery_id, &lottery);

        (amount_for_winner, amount_for_owner)
    }

    /// returns the current balance of a LotteryItem
    pub fn get_current_balance(&self, lottery_id: LotteryId) -> Balance {
        let item = self.items.get(&lottery_id).unwrap();
        item.current_balance
    }
}

'''