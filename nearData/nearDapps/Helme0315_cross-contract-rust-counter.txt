*GitHub Repository "Helme0315/cross-contract-rust-counter"*

'''--- README-Gitpod.md ---
Counter example in Rust - Gitpod version
==================================================

This README is specific to Gitpod and this example. For local development, please see [README.md](README.md).

## Description

In Gitpod, the counter will start automatically. Please look in the terminal for a link to follow.

This contract implements simple counter backed by storage on blockchain.
Contract in `contract/src/lib.rs` provides methods to increment / decrement counter and get it's current value or reset.

Plus and minus buttons increase and decrease value correspondingly. When button L is toggled, a little light turns on, just for fun. RS button is for reset. LE and RE buttons to let the robot wink at you.

## To Test

```
cd contract
cargo test -- --nocapture
```

## To Explore

- `contract/src/lib.rs` for the contract code
- `src/index.html` for the front-end HTML
- `src/main.js` for the JavaScript front-end code and how to integrate contracts
- `src/test.js` for the JS tests for the contract

## Data collection

By using Gitpod in this project, you agree to opt-in to basic, anonymous analytics. No personal information is transmitted. Instead, these usage statistics aid in discovering potential bugs and user flow information.

'''
'''--- README.md ---
Counter with simple Cross-Contract calls in Rust
=================================

These contracts form a basic example for performing cross-contract calls using the classic [Rust counter example](https://github.com/near-examples/rust-counter). 

## Instructions

- Deploy the modified [`counter`](./contracts/counter) found in the contract folder and specify `TEAM_MANAGER_CONTRACT_ID`.
- Deploy second contract found in the [`team-manager`](./contracts/team-manager) folder.
- The team manager contract consists of two teams - team A and team B. When you incremement the counter, the team with the least amount of players will get assigned a member. 
- When you decremement the counter, the team with the most amount of players will have a member removed. 
- If there is a tie, team A will be prioritized. 
- When you reset the counter, both teams will be reset to zero.

Original [Rust counter](https://github.com/near-examples/rust-counter) documentation:

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

## Setup
Install dependencies:

```
yarn
```

If you don't have `Rust` installed, complete the following 3 steps:

1) Install Rustup by running:

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

([Taken from official installation guide](https://www.rust-lang.org/tools/install))

2) Configure your current shell by running:

```
source $HOME/.cargo/env
```

3) Add wasm target to your toolchain by running:

```
rustup target add wasm32-unknown-unknown
```

Next, make sure you have `near-cli` by running:

```
near --version
```

If you need to install `near-cli`:

```
npm install near-cli -g
```

## To Run
Clone the repository.

```
git clone https://github.com/near-examples/cross-contract-rust-counter.git
```

## To Build
When in the root folder, you can build both contracts which will create the wasms to `out/counter.wasm` and `out/team-manager.wasm`

```
yarn build
```

## To Test
When in the root folder, you can run unit tests for both contracts using the following command.

```
yarn test:cargo
```

## To Deploy
After building, you can deploy the contracts to a dev account using the following commands:

```
near dev-deploy --wasmFile out/counter.wasm
```
And

```
near dev-deploy --wasmFile out/team-manager.wasm
```

To deploy to an existing account, login with `near-cli` by following the instructions after this command:

```
near login
```

You can then deploy to the logged in account via the following: 
```
near deploy --accountId YOUR_ACCOUNT_ID --wasmFile out/counter.wasm
```
And

```
near deploy --accountId YOUR_ACCOUNT_ID --wasmFile out/team-manager.wasm
```

## To Build the Documentation

```
cd contract
cargo doc --no-deps --open
```

'''
'''--- contracts/counter/Cargo.toml ---
[package]
name = "rust-counter-tutorial"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/counter/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/counter.wasm
'''
'''--- contracts/counter/src/lib.rs ---
//! This contract implements simple counter backed by storage on blockchain.
//!
//! The contract provides methods to [increment] / [decrement] counter and
//! [get it's current value][get_num] or [reset].
//!
//! [increment]: struct.Counter.html#method.increment
//! [decrement]: struct.Counter.html#method.decrement
//! [get_num]: struct.Counter.html#method.get_num
//! [reset]: struct.Counter.html#method.reset

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, ext_contract, near_bindgen};

near_sdk::setup_alloc!();

const TEAM_MANAGER_CONTRACT_ID: &str = "fayyr100.testnet";

#[ext_contract(ext_team_manager)]
pub trait ExtCounter {
    fn assign_to_team(&mut self);
    fn remove_from_team(&mut self);
    fn reset_teams(&mut self);
}

#[ext_contract(ext_self)]
pub trait ExtThis {
    fn on_assign_to_team(&self);
    fn on_remove_from_team(&self);
    fn on_reset_teams(&self);
}

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    val: i8, // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
}

#[near_bindgen]
impl Counter {
    /// Returns 8-bit signed integer of the counter value.
    ///
    /// This must match the type from our struct's 'val' defined above.
    ///
    /// Note, the parameter is `&self` (without being mutable) meaning it doesn't modify state.
    /// In the frontend (/src/main.js) this is added to the "viewMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near view counter.YOU.testnet get_num
    /// ```
    pub fn get_num(&self) -> i8 {
        return self.val;
    }

    /// Increment the counter.
    ///
    /// Note, the parameter is "&mut self" as this function modifies state.
    /// In the frontend (/src/main.js) this is added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet increment --accountId donation.YOU.testnet
    /// ```
    pub fn increment(&mut self) {
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_add(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
        self.val += 1;
        let log_message = format!("Increased counter to {}", self.val);
        env::log(log_message.as_bytes());

        // Invoke a method on another contract
        // This will send an ActionReceipt to the shard where the contract lives.
        ext_team_manager::assign_to_team(
            &TEAM_MANAGER_CONTRACT_ID, // contract account id
            0, // yocto NEAR to attach
            25_000_000_000_000 // gas to attach
        )
        // After the smart contract method finishes a DataReceipt will be sent back
        // .then registers a method to handle that incoming DataReceipt
        .then(ext_self::on_assign_to_team(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            25_000_000_000_000 // gas to attach to the callback
        ));
    }

    /// Decrement (subtract from) the counter.
    ///
    /// In (/src/main.js) this is also added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call counter.YOU.testnet decrement --accountId donation.YOU.testnet
    /// ```
    pub fn decrement(&mut self) {
        // note: subtracting one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_sub(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_sub
        self.val -= 1;
        let log_message = format!("Decreased counter to {}", self.val);
        env::log(log_message.as_bytes());

        // Invoke a method on another contract
        // This will send an ActionReceipt to the shard where the contract lives.
        ext_team_manager::remove_from_team(
            &TEAM_MANAGER_CONTRACT_ID, // contract account id
            0, // yocto NEAR to attach
            25_000_000_000_000 // gas to attach
        )
        // After the smart contract method finishes a DataReceipt will be sent back
        // .then registers a method to handle that incoming DataReceipt
        .then(ext_self::on_remove_from_team(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            25_000_000_000_000 // gas to attach to the callback
        ));
    }

    /// Reset to zero.
    pub fn reset(&mut self) {
        self.val = 0;
        // Another way to log is to cast a string into bytes, hence "b" below:
        env::log(b"Reset counter to zero");

        // Invoke a method on another contract
        // This will send an ActionReceipt to the shard where the contract lives.
        ext_team_manager::reset_teams(
            &TEAM_MANAGER_CONTRACT_ID, // contract account id
            0, // yocto NEAR to attach
            25_000_000_000_000 // gas to attach
        )
        // After the smart contract method finishes a DataReceipt will be sent back
        // .then registers a method to handle that incoming DataReceipt
        .then(ext_self::on_reset_teams(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            25_000_000_000_000 // gas to attach to the callback
        ));
    }

    pub fn on_assign_to_team(&self) {
        let log_message = format!("Successfully assigned member to a team!");
        env::log(log_message.as_bytes());
    }
    
    pub fn on_remove_from_team(&self) {
        let log_message = format!("Successfully removed member from a team!");
        env::log(log_message.as_bytes());
    }
    
    pub fn on_reset_teams(&self) {
        let log_message = format!("Successfully reset the teams!");
        env::log(log_message.as_bytes());
    }
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-counter-tutorial -- --nocapture
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::testing_env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::serde::export::TryFrom;

    // simple helper function to take a string literal and return a ValidAccountId
    fn to_valid_account(account: &str) -> ValidAccountId {
        ValidAccountId::try_from(account.to_string()).expect("Invalid account")
    }

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn increment() {
        // set up the mock context into the testing environment
        let context = get_context(to_valid_account("foo.near"));
        testing_env!(context.build());
        // instantiate a contract variable with the counter at zero
        let mut contract = Counter { val: 0 };
        contract.increment();
        println!("Value after increment: {}", contract.get_num());
        // confirm that we received 1 when calling get_num
        assert_eq!(1, contract.get_num());
    }

    #[test]
    fn decrement() {
        let context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Counter { val: 0 };
        contract.decrement();
        println!("Value after decrement: {}", contract.get_num());
        // confirm that we received -1 when calling get_num
        assert_eq!(-1, contract.get_num());
    }

    #[test]
    fn increment_and_reset() {
        let context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Counter { val: 0 };
        contract.increment();
        contract.reset();
        println!("Value after reset: {}", contract.get_num());
        // confirm that we received -1 when calling get_num
        assert_eq!(0, contract.get_num());
    }
}

'''
'''--- contracts/counter/tests/sim/main.rs ---
pub use near_sdk::json_types::{Base64VecU8, ValidAccountId, WrappedDuration, U64};
use near_sdk::serde_json::json;
use near_sdk_sim::{call, view, deploy, init_simulator, ContractAccount, UserAccount};
use rust_counter_tutorial::CounterContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    COUNTER_BYTES => "../../out/counter.wasm",
}

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

fn init() -> (UserAccount, ContractAccount<CounterContract>) {
    let root = init_simulator(None);

    // Deploy the compiled Wasm bytes
    let counter: ContractAccount<CounterContract> = deploy!(
         contract: CounterContract,
         contract_id: "counter".to_string(),
         bytes: &COUNTER_BYTES,
         signer_account: root
     );

    (root, counter)
}

#[test]
fn simulate_increment() {
    let (root, counter) = init();

    // Get number on account that hasn't incremented or decremented
    let mut current_num: i8 = view!(
        counter.get_num()
    ).unwrap_json();
    println!("Number before: {}", &current_num);
    assert_eq!(&current_num, &0, "Initial number should be zero.");

    // Call the increment function
    call!(
        root,
        counter.increment()
    ).assert_success();

    current_num = view!(
        counter.get_num()
    ).unwrap_json();
    println!("Number after first increment: {}", &current_num);
    assert_eq!(&current_num, &1, "After incrementing, the number should be one.");

    // Now use the non-macro approach to increment the number.
    root.call(
        counter.account_id(),
        "increment",
        &json!({})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).assert_success();

    // Similarly, use the non-macro approach to check the value.
    current_num = root.view(
        counter.account_id(),
        "get_num",
        &json!({})
            .to_string()
            .into_bytes(),
    ).unwrap_json();
    println!("Number after second increment: {}", &current_num);
    assert_eq!(&current_num, &2, "After incrementing twice, the number should be two.");
}

'''
'''--- contracts/team-manager/Cargo.toml ---
[package]
name = "rust-counter-tutorial"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/team-manager/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/team-manager.wasm
'''
'''--- contracts/team-manager/src/lib.rs ---
//! This contract implements a simple team manager counter backed by storage on blockchain.
//!
//! The contract provides methods to [assign_to_team] / [remove_from_team] counter and
//! [get their current sizes][get_team_a] / [get_team_b] or [reset_teams].

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct TeamManager {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    team_a: i8, // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
    team_b: i8, // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
}

#[near_bindgen]
impl TeamManager {
    /// Returns 8-bit signed integer of team a's value.
    ///
    /// This must match the type from our struct's 'team_a' defined above.
    ///
    /// Note, the parameter is `&self` (without being mutable) meaning it doesn't modify state.
    /// In the frontend (/src/main.js) this is added to the "viewMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near view THIS_CONTRACT.testnet get_team_a
    /// ```
    pub fn get_team_a(&self) -> i8 {
        return self.team_a;
    }

    /// Returns 8-bit signed integer of team b's value.
    ///
    /// This must match the type from our struct's 'team_b' defined above.
    ///
    /// Note, the parameter is `&self` (without being mutable) meaning it doesn't modify state.
    /// In the frontend (/src/main.js) this is added to the "viewMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near view THIS_CONTRACT.testnet get_team_b
    /// ```
    pub fn get_team_b(&self) -> i8 {
        return self.team_b;
    }

    /// Add a player to the team with the least members. If there is a tie, prioritize team A.
    ///
    /// Note, the parameter is "&mut self" as this function modifies state.
    /// In the frontend (/src/main.js) this is added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call THIS_CONTRACT.testnet assign_to_team --accountId YOU.testnet
    /// ```
    pub fn assign_to_team(&mut self) {
        if self.team_a <= self.team_b {
            self.team_a += 1;
            let log_message = format!("Team A has the least players. Adding a player. Total count is now {} players", self.team_a);
            env::log(log_message.as_bytes());
        } else {
            self.team_b += 1;
            let log_message = format!("Team B has the least players. Adding a player. Total count is now {} players", self.team_b);
            env::log(log_message.as_bytes());
        }
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_add(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
    }

    /// Remove a player (subtract) from the team with the most members. If there is a tie, prioritize team A.
    ///
    /// In (/src/main.js) this is also added to the "changeMethods" array
    /// using near-cli we can call this by:
    ///
    /// ```bash
    /// near call THIS_CONTRACT.testnet remove_from_team --accountId YOU.testnet
    /// ```
    pub fn remove_from_team(&mut self) {
        if self.team_a >= self.team_b {
            self.team_a -= 1;
            let log_message = format!("Team A has the most players. Removing a player. Total count is now {} players", self.team_a);
            env::log(log_message.as_bytes());
        } else {
            self.team_b -= 1;
            let log_message = format!("Team B has the most players. Removing a player. Total count is now {} players", self.team_b);
            env::log(log_message.as_bytes());
        }
        // note: subtracting one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_sub(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_sub
    }

    /// Reset both teams to zero.
    pub fn reset_teams(&mut self) {
        self.team_a = 0;
        self.team_b = 0;
        // Another way to log is to cast a string into bytes, hence "b" below:
        env::log(b"Reset both teams to zero");
    }
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-counter-tutorial -- --nocapture
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::testing_env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::serde::export::TryFrom;

    // simple helper function to take a string literal and return a ValidAccountId
    fn to_valid_account(account: &str) -> ValidAccountId {
        ValidAccountId::try_from(account.to_string()).expect("Invalid account")
    }

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn assign_to_team() {
        // set up the mock context into the testing environment
        let context = get_context(to_valid_account("foo.near"));
        testing_env!(context.build());
        // instantiate a contract variable with the counter at zero
        let mut contract = TeamManager { team_a: 0, team_b: 0 };
        contract.assign_to_team();
        println!("Value after assigning to team: {}", contract.get_team_a());
        // confirm that we received 1 when calling get_team_a
        assert_eq!(1, contract.get_team_a());
    }

    #[test]
    fn remove_from_team() {
        let context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = TeamManager { team_a: 0, team_b: 0 };
        contract.remove_from_team();
        println!("Value after removing from team: {}", contract.get_team_a());
        // confirm that we received -1 when calling get_team_a
        assert_eq!(-1, contract.get_team_a());
    }

    #[test]
    fn assign_and_reset() {
        let context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = TeamManager { team_a: 0, team_b: 0 };
        contract.assign_to_team();
        contract.reset_teams();
        println!("Value after reset: {}", contract.get_team_a());
        // confirm that we received -1 when calling get_team_a
        assert_eq!(0, contract.get_team_a());
    }
}

'''
'''--- contracts/team-manager/tests/sim/main.rs ---
pub use near_sdk::json_types::{Base64VecU8, ValidAccountId, WrappedDuration, U64};
use near_sdk::serde_json::json;
use near_sdk_sim::{call, view, deploy, init_simulator, ContractAccount, UserAccount};
use rust_counter_tutorial::CounterContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    COUNTER_BYTES => "../../out/team-manager.wasm",
}

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

fn init() -> (UserAccount, ContractAccount<CounterContract>) {
    let root = init_simulator(None);

    // Deploy the compiled Wasm bytes
    let counter: ContractAccount<CounterContract> = deploy!(
         contract: CounterContract,
         contract_id: "counter".to_string(),
         bytes: &COUNTER_BYTES,
         signer_account: root
     );

    (root, counter)
}

#[test]
fn simulate_increment() {
    let (root, counter) = init();

    // Get number on account that hasn't incremented or decremented
    let mut current_num: i8 = view!(
        counter.get_num()
    ).unwrap_json();
    println!("Number before: {}", &current_num);
    assert_eq!(&current_num, &0, "Initial number should be zero.");

    // Call the increment function
    call!(
        root,
        counter.increment()
    ).assert_success();

    current_num = view!(
        counter.get_num()
    ).unwrap_json();
    println!("Number after first increment: {}", &current_num);
    assert_eq!(&current_num, &1, "After incrementing, the number should be one.");

    // Now use the non-macro approach to increment the number.
    root.call(
        counter.account_id(),
        "increment",
        &json!({})
            .to_string()
            .into_bytes(),
        DEFAULT_GAS,
        0, // attached deposit
    ).assert_success();

    // Similarly, use the non-macro approach to check the value.
    current_num = root.view(
        counter.account_id(),
        "get_num",
        &json!({})
            .to_string()
            .into_bytes(),
    ).unwrap_json();
    println!("Number after second increment: {}", &current_num);
    assert_eq!(&current_num, &2, "After incrementing twice, the number should be two.");
}

'''
'''--- frontend/README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

'''
'''--- frontend/package.json ---
{
  "name": "todos-crud-web",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^11.2.7",
    "@testing-library/user-event": "^12.8.3",
    "near-react-hooks": "^1.2.3",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "4.0.3",
    "web-vitals": "^1.1.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- frontend/src/App.js ---
import 'regenerator-runtime/runtime';
import React from 'react';
import PropTypes from 'prop-types';
import Counter from './components/Counter';

const App = ({ counterContract, currentUser, nearConfig, wallet, initialCounter, initialTeamA, initialTeamB }) => {

  const signIn = () => {
    wallet.requestSignIn(
      nearConfig.counterContractName,
      'NEAR Cross-Contract Rust Counter'
    );
  };

  const signOut = () => {
    wallet.signOut();
    window.location.replace(window.location.origin + window.location.pathname);
  };
  return (
    <>
      <h1>NEAR Cross-Contract Calls Counter Example</h1>
      { currentUser
          ? <div>
              <h2>
                Account ID: {currentUser.accountId}
                {" "}
                <button onClick={signOut}>Log out</button>
              </h2>
            
              <Counter 
                counterContract={counterContract}
                teamManagerContractName={nearConfig.teamManagerContractName}
                nearConfig={nearConfig}
                initialTeamA={initialTeamA}
                initialTeamB={initialTeamB}
                initialCounter={initialCounter}
              />
            </div>
          : 
          <div>
            Sign In To Use The App: 
            {" "}
            <button onClick={signIn}>Log in</button>
          </div>
        }
    </>
  );
};

App.propTypes = {
  counterContract: PropTypes.shape({
    get_num: PropTypes.func.isRequired,
    increment: PropTypes.func.isRequired,
    decrement: PropTypes.func.isRequired,
    reset: PropTypes.func.isRequired,
  }).isRequired,
  currentUser: PropTypes.shape({
    accountId: PropTypes.string.isRequired,
    balance: PropTypes.string.isRequired
  }),
  nearConfig: PropTypes.shape({
    counterContractName: PropTypes.string.isRequired,
    teamManagerContractName: PropTypes.string.isRequired
  }).isRequired,
  wallet: PropTypes.shape({
    requestSignIn: PropTypes.func.isRequired,
    signOut: PropTypes.func.isRequired
  }).isRequired
};

export default App;
'''
'''--- frontend/src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- frontend/src/components/Counter.js ---
// src/components/TodoList.js
import { useEffect, useState } from "react";

const Counter = ({ counterContract, teamManagerContractName, nearConfig, initialTeamA, initialTeamB, initialCounter }) => {
  const [teamA, setTeamA] = useState(initialTeamA);
  const [teamB, setTeamB] = useState(initialTeamB);
  const [counter, setCounter] = useState(initialCounter);
  const [isLoading, setIsLoading] = useState(false);

  async function Increment() {
    setIsLoading(true)
    await counterContract.increment({}, "300000000000000");
    console.log("DONE INCREMENTING")
    const currentCounterValue = await counterContract.get_num({});
    setCounter(currentCounterValue)

    const currentTeamAValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_a", {});
    setTeamA(currentTeamAValue); 

    const currentTeamBValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_b", {});
    setTeamB(currentTeamBValue);
    setIsLoading(false)
  }

  async function Decrement() {
    setIsLoading(true)
    await counterContract.decrement({}, "300000000000000");
    console.log("DONE DECREMENTING")

    const currentCounterValue = await counterContract.get_num({});
    setCounter(currentCounterValue)

    const currentTeamAValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_a", {});
    setTeamA(currentTeamAValue); 

    const currentTeamBValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_b", {});
    setTeamB(currentTeamBValue);
    setIsLoading(false)
  }

  async function Reset() {
    setIsLoading(true)
    await counterContract.reset({}, "300000000000000");
    console.log("DONE RESETTING")

    const currentCounterValue = await counterContract.get_num({});
    setCounter(currentCounterValue)

    const currentTeamAValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_a", {});
    setTeamA(currentTeamAValue); 

    const currentTeamBValue = await counterContract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_b", {});
    setTeamB(currentTeamBValue);
    setIsLoading(false)
  }

  return (
    <ul>
      <div>
        <div>
          Current Counter: {counter}
        </div>
        <button onClick={Decrement}>&lt;</button>
        {" "}
        <button onClick={Increment}>&gt;</button>
        {" "}
        <button onClick={Reset}>Reset</button>
        <div>
          Team A: {teamA}
        </div>
        <div>
          Team B: {teamB}
        </div>
        {isLoading && 
        <div>
          Loading Values....
        </div>}
      </div>
    </ul>
  );
}

export default Counter;

'''
'''--- frontend/src/config.js ---
const COUNTER_CONTRACT_NAME = process.env.COUNTER_CONTRACT_NAME || 'dev-1631640334277-70325126364752';
const TEAM_MANAGER_CONTRACT_NAME = process.env.TEAM_MANAGER_CONTRACT_NAME || 'fayyr100.testnet';

function getConfig(env) {
  switch(env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        counterContractName: COUNTER_CONTRACT_NAME,
        teamManagerContractName: TEAM_MANAGER_CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;
'''
'''--- frontend/src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import getConfig from './config.js';
import * as nearAPI from 'near-api-js';

// Initializing contract
async function initContract() {
  const nearConfig = getConfig(process.env.NODE_ENV || 'testnet');

  // Initializing connection to the NEAR TestNet
  const near = await nearAPI.connect({
    deps: {
      keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore()
    },
    ...nearConfig
  });

  // Needed to access wallet
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in account data
  let currentUser;
  if(walletConnection.getAccountId()) {
    currentUser = {
      accountId: walletConnection.getAccountId(),
      balance: (await walletConnection.account().state()).amount
    };
  }

  // Initializing our contract APIs by contract name and configuration
  const contract = await new nearAPI.Contract(walletConnection.account(), nearConfig.counterContractName, {
    // View methods are read-only – they don't modify the state, but usually return some value
    viewMethods: ["get_num"],
    // Change methods can modify the state, but you don't receive the returned value when called
    changeMethods: ["increment", "decrement", "reset"],
    // Sender is the account ID to initialize transactions.
    // getAccountId() will return empty string if user is still unauthorized
    sender: walletConnection.getAccountId()
  });

  const initialTeamA = await contract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_a", {});
  const initialTeamB = await contract.account.viewFunction(nearConfig.teamManagerContractName, "get_team_b", {});
  const initialCounter = await contract.get_num({});

  return { contract, currentUser, nearConfig, walletConnection, initialTeamA, initialTeamB, initialCounter };
}

window.nearInitPromise = initContract()
  .then(({ contract, currentUser, nearConfig, walletConnection, initialTeamA, initialTeamB, initialCounter }) => {
    ReactDOM.render(
      <App
        counterContract={contract}
        currentUser={currentUser}
        nearConfig={nearConfig}
        wallet={walletConnection}
        initialTeamA={initialTeamA}
        initialTeamB={initialTeamB}
        initialCounter={initialCounter}
      />,
      document.getElementById('root')
    );
  });
'''
'''--- frontend/src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- frontend/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- frontend/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1631564333099-26063614322046
'''
'''--- package.json ---
{
  "name": "rust-counter",
  "description": "Counter Smart Contract\n\nThis project contains implementation of counter backed by blockchain, written in Rust.",
  "version": "0.0.1",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "cd contracts/counter && ./build.sh && cd .. && cd team-manager && ./build.sh && cd ../..",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d src",
    "deploy": "yarn build && yarn deploy:contract",
    "deploy:dev": "yarn build && near dev-deploy",
    "dev": "yarn deploy:dev && yarn start:dev",
    "prestart": "yarn build && yarn deploy:contract",
    "start": "parcel src/index.html",
    "start:dev": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "test:cargo": "yarn build && cd contracts/counter && cargo test -- --nocapture && cd .. && cd team-manager && cargo test -- --nocapture && cd ../..",
    "test": "yarn build && yarn test:cargo && jest"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "gh-pages": "~3.0.0",
    "jest": "~25.2.0",
    "jest-environment-node": "~26.0.1",
    "near-cli": "^1.0.1",
    "nodemon": "~2.0.4",
    "parcel-bundler": "~1.12.4"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment"
  },
  "dependencies": {
    "near-api-js": "^0.27.0",
    "regenerator-runtime": "^0.13.5"
  }
}

'''