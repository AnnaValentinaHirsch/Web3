*GitHub Repository "AgentDavid/server_prices_cryptos"*

'''--- requirements.txt ---
py-algorand-sdk==1.9.0
python-dotenv==0.19.2
pyteal==0.9.1
'''
'''--- server/app_eur.js ---
const fetch = require('cross-fetch');
const algosdk = require('algosdk');
const { encodeUint64 } = require('algosdk');
const dotenv = require('dotenv');
dotenv.config();

const { addr, sk } = algosdk.mnemonicToSecretKey(process.env.WALLET_CREATOR);

const app_id = parseInt(process.env.APP_ID_EUR);
const million = 1000000;
const server = process.env.ALGOEXPLORER_API;
const algoClient = new algosdk.Algodv2('', server, '');
const coingeckoApi =
    'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,ethereum-classic,iota,binancecoin,solana,cardano,ripple,terra-luna,polkadot,avalanche-2,dogecoin,shiba-inu,matic-network,crypto-com-chain,wrapped-bitcoin,uniswap,litecoin,chainlink,algorand,bitcoin-cash,near,tron,stellar,decentraland,axie-infinity,cosmos,vechain,ftx-token,fantom,the-sandbox,filecoin,hedera-hashgraph,bitcoin-bep2,theta-token,elrond-erd-2,internet-computer,ethereum-claiota,tezos,helium,monero,aave,leo-token,klay-token,gala,the-graph,eos,pancakeswap-token,blockstack,flow,loopring,harmony,bittorrent-2,kusama,maker,enjincoin,bitcoin-cash-sv,quant-network,amp-token,kadena,ecash&vs_currencies=eur';

const waitForConfirmation = async (algodClient, txId, timeout) => {
    if (algodClient == null || txId == null || timeout < 0) {
        throw new Error('Bad arguments');
    }

    const status = await algodClient.status().do();
    if (status === undefined) {
        console.log('Unable to get node status');
    }

    const startround = status['last-round'] + 1;
    let currentround = startround;

    while (currentround < startround + timeout) {
        const pendingInfo = await algodClient.pendingTransactionInformation(txId).do();
        if (pendingInfo !== undefined) {
            if (pendingInfo['confirmed-round'] !== null && pendingInfo['confirmed-round'] > 0) {
                //Got the completed Transaction
                return pendingInfo['confirmed-round'];
            } else {
                if (pendingInfo['pool-error'] != null && pendingInfo['pool-error'].length > 0) {
                    // If there was a pool error, then the transaction has been rejected!
                    console.log('Transaction ' + txId + ' rejected - pool error: ' + pendingInfo['pool-error']);
                }
            }
        }
        await algodClient.statusAfterBlock(currentround).do();
        currentround++;
    }

    console.log('Transaction ' + txId + ' not confirmed after ' + timeout + ' rounds!');
};

const getData = async (data) => {
    const params = await algoClient.getTransactionParams().do();
    const tx1 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_1')),
        encodeUint64(Math.trunc(data['bitcoin'].eur * million)),
        encodeUint64(Math.trunc(data['ethereum'].eur * million)),
        encodeUint64(Math.trunc(data['binancecoin'].eur * million)),
        encodeUint64(Math.trunc(data['solana'].eur * million)),
        encodeUint64(Math.trunc(data['cardano'].eur * million)),
        encodeUint64(Math.trunc(data['ripple'].eur * million)),
        encodeUint64(Math.trunc(data['terra-luna'].eur * million)),
        encodeUint64(Math.trunc(data['polkadot'].eur * million)),
        encodeUint64(Math.trunc(data['avalanche-2'].eur * million)),
        encodeUint64(Math.trunc(data['dogecoin'].eur * million)),
        encodeUint64(Math.trunc(data['shiba-inu'].eur * million)),
        encodeUint64(Math.trunc(data['matic-network'].eur * million)),
        encodeUint64(Math.trunc(data['crypto-com-chain'].eur * million)),
        encodeUint64(Math.trunc(data['wrapped-bitcoin'].eur * million)),
        encodeUint64(Math.trunc(data['uniswap'].eur * million)),
    ]);
    const tx2 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_2')),
        encodeUint64(Math.trunc(data['litecoin'].eur * million)),
        encodeUint64(Math.trunc(data['chainlink'].eur * million)),
        encodeUint64(Math.trunc(data['algorand'].eur * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash'].eur * million)),
        encodeUint64(Math.trunc(data['near'].eur * million)),
        encodeUint64(Math.trunc(data['tron'].eur * million)),
        encodeUint64(Math.trunc(data['stellar'].eur * million)),
        encodeUint64(Math.trunc(data['decentraland'].eur * million)),
        encodeUint64(Math.trunc(data['axie-infinity'].eur * million)),
        encodeUint64(Math.trunc(data['cosmos'].eur * million)),
        encodeUint64(Math.trunc(data['vechain'].eur * million)),
        encodeUint64(Math.trunc(data['ftx-token'].eur * million)),
        encodeUint64(Math.trunc(data['fantom'].eur * million)),
        encodeUint64(Math.trunc(data['the-sandbox'].eur * million)),
        encodeUint64(Math.trunc(data['filecoin'].eur * million)),
    ]);
    const tx3 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_3')),

        encodeUint64(Math.trunc(data['hedera-hashgraph'].eur * million)),
        encodeUint64(Math.trunc(data['bitcoin-bep2'].eur * million)),
        encodeUint64(Math.trunc(data['theta-token'].eur * million)),
        encodeUint64(Math.trunc(data['elrond-erd-2'].eur * million)),
        encodeUint64(Math.trunc(data['internet-computer'].eur * million)),
        encodeUint64(Math.trunc(data['ethereum-classic'].eur * million)),
        encodeUint64(Math.trunc(data['iota'].eur * million)),
        encodeUint64(Math.trunc(data['tezos'].eur * million)),
        encodeUint64(Math.trunc(data['helium'].eur * million)),
        encodeUint64(Math.trunc(data['monero'].eur * million)),
        encodeUint64(Math.trunc(data['aave'].eur * million)),
        encodeUint64(Math.trunc(data['leo-token'].eur * million)),
        encodeUint64(Math.trunc(data['klay-token'].eur * million)),
        encodeUint64(Math.trunc(data['gala'].eur * million)),
        encodeUint64(Math.trunc(data['the-graph'].eur * million)),
    ]);
    const tx4 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_4')),
        encodeUint64(Math.trunc(data['eos'].eur * million)),
        encodeUint64(Math.trunc(data['pancakeswap-token'].eur * million)),
        encodeUint64(Math.trunc(data['blockstack'].eur * million)),
        encodeUint64(Math.trunc(data['flow'].eur * million)),
        encodeUint64(Math.trunc(data['loopring'].eur * million)),
        encodeUint64(Math.trunc(data['harmony'].eur * million)),
        encodeUint64(Math.trunc(data['bittorrent-2'].eur * million)),
        encodeUint64(Math.trunc(data['kusama'].eur * million)),
        encodeUint64(Math.trunc(data['maker'].eur * million)),
        encodeUint64(Math.trunc(data['enjincoin'].eur * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash-sv'].eur * million)),
        encodeUint64(Math.trunc(data['quant-network'].eur * million)),
        encodeUint64(Math.trunc(data['amp-token'].eur * million)),
        encodeUint64(Math.trunc(data['kadena'].eur * million)),
        encodeUint64(Math.trunc(data['ecash'].eur * million)),
    ]);
    const txGroup = algosdk.assignGroupID([tx1, tx2, tx3, tx4]);
    const txn = await algoClient
        .sendRawTransaction([
            txGroup[0].signTxn(sk),
            txGroup[1].signTxn(sk),
            txGroup[2].signTxn(sk),
            txGroup[3].signTxn(sk),
        ])
        .do();
    console.log('tx send: ' + txn.txId);
    const txResolve = await waitForConfirmation(algoClient, txn.txId, 5);
    console.log('tx confirmed in round: ' + txResolve);
    main();
    return;
};

const main = async () => {
    // Get data from coingecko's API
    fetch(coingeckoApi)
        .then((response) => response.json())
        .then((data) => {
            if (data) {
                getData(data);
            } else {
                throw new Error('Undefined received from coingeko');
            }
        })
        .catch((e) => console.log(e));
};

main();

'''
'''--- server/app_gbp.js ---
const fetch = require('cross-fetch');
const algosdk = require('algosdk');
const { encodeUint64 } = require('algosdk');
const dotenv = require('dotenv');
dotenv.config();

const { addr, sk } = algosdk.mnemonicToSecretKey(process.env.WALLET_CREATOR);

const app_id = parseInt(process.env.APP_ID_GBP);
const million = 1000000;
const server = process.env.ALGOEXPLORER_API;
const algoClient = new algosdk.Algodv2('', server, '');
const coingeckoApi =
    'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,ethereum-classic,iota,binancecoin,solana,cardano,ripple,terra-luna,polkadot,avalanche-2,dogecoin,shiba-inu,matic-network,crypto-com-chain,wrapped-bitcoin,uniswap,litecoin,chainlink,algorand,bitcoin-cash,near,tron,stellar,decentraland,axie-infinity,cosmos,vechain,ftx-token,fantom,the-sandbox,filecoin,hedera-hashgraph,bitcoin-bep2,theta-token,elrond-erd-2,internet-computer,ethereum-claiota,tezos,helium,monero,aave,leo-token,klay-token,gala,the-graph,eos,pancakeswap-token,blockstack,flow,loopring,harmony,bittorrent-2,kusama,maker,enjincoin,bitcoin-cash-sv,quant-network,amp-token,kadena,ecash&vs_currencies=gbp';

const waitForConfirmation = async (algodClient, txId, timeout) => {
    if (algodClient == null || txId == null || timeout < 0) {
        throw new Error('Bad arguments');
    }

    const status = await algodClient.status().do();
    if (status === undefined) {
        console.log('Unable to get node status');
    }

    const startround = status['last-round'] + 1;
    let currentround = startround;

    while (currentround < startround + timeout) {
        const pendingInfo = await algodClient.pendingTransactionInformation(txId).do();
        if (pendingInfo !== undefined) {
            if (pendingInfo['confirmed-round'] !== null && pendingInfo['confirmed-round'] > 0) {
                //Got the completed Transaction
                return pendingInfo['confirmed-round'];
            } else {
                if (pendingInfo['pool-error'] != null && pendingInfo['pool-error'].length > 0) {
                    // If there was a pool error, then the transaction has been rejected!
                    console.log('Transaction ' + txId + ' rejected - pool error: ' + pendingInfo['pool-error']);
                }
            }
        }
        await algodClient.statusAfterBlock(currentround).do();
        currentround++;
    }

    console.log('Transaction ' + txId + ' not confirmed after ' + timeout + ' rounds!');
};

const getData = async (data) => {
    const params = await algoClient.getTransactionParams().do();
    const tx1 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_1')),
        encodeUint64(Math.trunc(data['bitcoin'].gbp * million)),
        encodeUint64(Math.trunc(data['ethereum'].gbp * million)),
        encodeUint64(Math.trunc(data['binancecoin'].gbp * million)),
        encodeUint64(Math.trunc(data['solana'].gbp * million)),
        encodeUint64(Math.trunc(data['cardano'].gbp * million)),
        encodeUint64(Math.trunc(data['ripple'].gbp * million)),
        encodeUint64(Math.trunc(data['terra-luna'].gbp * million)),
        encodeUint64(Math.trunc(data['polkadot'].gbp * million)),
        encodeUint64(Math.trunc(data['avalanche-2'].gbp * million)),
        encodeUint64(Math.trunc(data['dogecoin'].gbp * million)),
        encodeUint64(Math.trunc(data['shiba-inu'].gbp * million)),
        encodeUint64(Math.trunc(data['matic-network'].gbp * million)),
        encodeUint64(Math.trunc(data['crypto-com-chain'].gbp * million)),
        encodeUint64(Math.trunc(data['wrapped-bitcoin'].gbp * million)),
        encodeUint64(Math.trunc(data['uniswap'].gbp * million)),
    ]);
    const tx2 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_2')),
        encodeUint64(Math.trunc(data['litecoin'].gbp * million)),
        encodeUint64(Math.trunc(data['chainlink'].gbp * million)),
        encodeUint64(Math.trunc(data['algorand'].gbp * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash'].gbp * million)),
        encodeUint64(Math.trunc(data['near'].gbp * million)),
        encodeUint64(Math.trunc(data['tron'].gbp * million)),
        encodeUint64(Math.trunc(data['stellar'].gbp * million)),
        encodeUint64(Math.trunc(data['decentraland'].gbp * million)),
        encodeUint64(Math.trunc(data['axie-infinity'].gbp * million)),
        encodeUint64(Math.trunc(data['cosmos'].gbp * million)),
        encodeUint64(Math.trunc(data['vechain'].gbp * million)),
        encodeUint64(Math.trunc(data['ftx-token'].gbp * million)),
        encodeUint64(Math.trunc(data['fantom'].gbp * million)),
        encodeUint64(Math.trunc(data['the-sandbox'].gbp * million)),
        encodeUint64(Math.trunc(data['filecoin'].gbp * million)),
    ]);
    const tx3 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_3')),

        encodeUint64(Math.trunc(data['hedera-hashgraph'].gbp * million)),
        encodeUint64(Math.trunc(data['bitcoin-bep2'].gbp * million)),
        encodeUint64(Math.trunc(data['theta-token'].gbp * million)),
        encodeUint64(Math.trunc(data['elrond-erd-2'].gbp * million)),
        encodeUint64(Math.trunc(data['internet-computer'].gbp * million)),
        encodeUint64(Math.trunc(data['ethereum-classic'].gbp * million)),
        encodeUint64(Math.trunc(data['iota'].gbp * million)),
        encodeUint64(Math.trunc(data['tezos'].gbp * million)),
        encodeUint64(Math.trunc(data['helium'].gbp * million)),
        encodeUint64(Math.trunc(data['monero'].gbp * million)),
        encodeUint64(Math.trunc(data['aave'].gbp * million)),
        encodeUint64(Math.trunc(data['leo-token'].gbp * million)),
        encodeUint64(Math.trunc(data['klay-token'].gbp * million)),
        encodeUint64(Math.trunc(data['gala'].gbp * million)),
        encodeUint64(Math.trunc(data['the-graph'].gbp * million)),
    ]);
    const tx4 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_4')),
        encodeUint64(Math.trunc(data['eos'].gbp * million)),
        encodeUint64(Math.trunc(data['pancakeswap-token'].gbp * million)),
        encodeUint64(Math.trunc(data['blockstack'].gbp * million)),
        encodeUint64(Math.trunc(data['flow'].gbp * million)),
        encodeUint64(Math.trunc(data['loopring'].gbp * million)),
        encodeUint64(Math.trunc(data['harmony'].gbp * million)),
        encodeUint64(Math.trunc(data['bittorrent-2'].gbp * million)),
        encodeUint64(Math.trunc(data['kusama'].gbp * million)),
        encodeUint64(Math.trunc(data['maker'].gbp * million)),
        encodeUint64(Math.trunc(data['enjincoin'].gbp * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash-sv'].gbp * million)),
        encodeUint64(Math.trunc(data['quant-network'].gbp * million)),
        encodeUint64(Math.trunc(data['amp-token'].gbp * million)),
        encodeUint64(Math.trunc(data['kadena'].gbp * million)),
        encodeUint64(Math.trunc(data['ecash'].gbp * million)),
    ]);
    const txGroup = algosdk.assignGroupID([tx1, tx2, tx3, tx4]);
    const txn = await algoClient
        .sendRawTransaction([
            txGroup[0].signTxn(sk),
            txGroup[1].signTxn(sk),
            txGroup[2].signTxn(sk),
            txGroup[3].signTxn(sk),
        ])
        .do();
    console.log('tx send: ' + txn.txId);
    const txResolve = await waitForConfirmation(algoClient, txn.txId, 5);
    console.log('tx confirmed in round: ' + txResolve);
    main();
    return;
};

const main = async () => {
    // Get data from coingecko's API
    fetch(coingeckoApi)
        .then((response) => response.json())
        .then((data) => {
            if (data) {
                getData(data);
            } else {
                throw new Error('Undefined received from coingeko');
            }
        })
        .catch((e) => console.log(e));
};

main();

'''
'''--- server/app_usd.js ---
const fetch = require('cross-fetch');
const algosdk = require('algosdk');
const { encodeUint64 } = require('algosdk');
const dotenv = require('dotenv');
dotenv.config();

const { addr, sk } = algosdk.mnemonicToSecretKey(process.env.WALLET_CREATOR);

const app_id = parseInt(process.env.APP_ID_USD);
const million = 1000000;
const server = process.env.ALGOEXPLORER_API;
const algoClient = new algosdk.Algodv2('', server, '');
const coingeckoApi =
    'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,ethereum-classic,iota,binancecoin,solana,cardano,ripple,terra-luna,polkadot,avalanche-2,dogecoin,shiba-inu,matic-network,crypto-com-chain,wrapped-bitcoin,uniswap,litecoin,chainlink,algorand,bitcoin-cash,near,tron,stellar,decentraland,axie-infinity,cosmos,vechain,ftx-token,fantom,the-sandbox,filecoin,hedera-hashgraph,bitcoin-bep2,theta-token,elrond-erd-2,internet-computer,ethereum-claiota,tezos,helium,monero,aave,leo-token,klay-token,gala,the-graph,eos,pancakeswap-token,blockstack,flow,loopring,harmony,bittorrent-2,kusama,maker,enjincoin,bitcoin-cash-sv,quant-network,amp-token,kadena,ecash&vs_currencies=usd';

const waitForConfirmation = async (algodClient, txId, timeout) => {
    if (algodClient == null || txId == null || timeout < 0) {
        throw new Error('Bad arguments');
    }

    const status = await algodClient.status().do();
    if (status === undefined) {
        console.log('Unable to get node status');
    }

    const startround = status['last-round'] + 1;
    let currentround = startround;

    while (currentround < startround + timeout) {
        const pendingInfo = await algodClient.pendingTransactionInformation(txId).do();
        if (pendingInfo !== undefined) {
            if (pendingInfo['confirmed-round'] !== null && pendingInfo['confirmed-round'] > 0) {
                //Got the completed Transaction
                return pendingInfo['confirmed-round'];
            } else {
                if (pendingInfo['pool-error'] != null && pendingInfo['pool-error'].length > 0) {
                    // If there was a pool error, then the transaction has been rejected!
                    console.log('Transaction ' + txId + ' rejected - pool error: ' + pendingInfo['pool-error']);
                }
            }
        }
        await algodClient.statusAfterBlock(currentround).do();
        currentround++;
    }

    console.log('Transaction ' + txId + ' not confirmed after ' + timeout + ' rounds!');
};

const getData = async (data) => {
    const params = await algoClient.getTransactionParams().do();
    const tx1 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_1')),
        encodeUint64(Math.trunc(data['bitcoin'].usd * million)),
        encodeUint64(Math.trunc(data['ethereum'].usd * million)),
        encodeUint64(Math.trunc(data['binancecoin'].usd * million)),
        encodeUint64(Math.trunc(data['solana'].usd * million)),
        encodeUint64(Math.trunc(data['cardano'].usd * million)),
        encodeUint64(Math.trunc(data['ripple'].usd * million)),
        encodeUint64(Math.trunc(data['terra-luna'].usd * million)),
        encodeUint64(Math.trunc(data['polkadot'].usd * million)),
        encodeUint64(Math.trunc(data['avalanche-2'].usd * million)),
        encodeUint64(Math.trunc(data['dogecoin'].usd * million)),
        encodeUint64(Math.trunc(data['shiba-inu'].usd * million)),
        encodeUint64(Math.trunc(data['matic-network'].usd * million)),
        encodeUint64(Math.trunc(data['crypto-com-chain'].usd * million)),
        encodeUint64(Math.trunc(data['wrapped-bitcoin'].usd * million)),
        encodeUint64(Math.trunc(data['uniswap'].usd * million)),
    ]);
    const tx2 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_2')),
        encodeUint64(Math.trunc(data['litecoin'].usd * million)),
        encodeUint64(Math.trunc(data['chainlink'].usd * million)),
        encodeUint64(Math.trunc(data['algorand'].usd * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash'].usd * million)),
        encodeUint64(Math.trunc(data['near'].usd * million)),
        encodeUint64(Math.trunc(data['tron'].usd * million)),
        encodeUint64(Math.trunc(data['stellar'].usd * million)),
        encodeUint64(Math.trunc(data['decentraland'].usd * million)),
        encodeUint64(Math.trunc(data['axie-infinity'].usd * million)),
        encodeUint64(Math.trunc(data['cosmos'].usd * million)),
        encodeUint64(Math.trunc(data['vechain'].usd * million)),
        encodeUint64(Math.trunc(data['ftx-token'].usd * million)),
        encodeUint64(Math.trunc(data['fantom'].usd * million)),
        encodeUint64(Math.trunc(data['the-sandbox'].usd * million)),
        encodeUint64(Math.trunc(data['filecoin'].usd * million)),
    ]);
    const tx3 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_3')),

        encodeUint64(Math.trunc(data['hedera-hashgraph'].usd * million)),
        encodeUint64(Math.trunc(data['bitcoin-bep2'].usd * million)),
        encodeUint64(Math.trunc(data['theta-token'].usd * million)),
        encodeUint64(Math.trunc(data['elrond-erd-2'].usd * million)),
        encodeUint64(Math.trunc(data['internet-computer'].usd * million)),
        encodeUint64(Math.trunc(data['ethereum-classic'].usd * million)),
        encodeUint64(Math.trunc(data['iota'].usd * million)),
        encodeUint64(Math.trunc(data['tezos'].usd * million)),
        encodeUint64(Math.trunc(data['helium'].usd * million)),
        encodeUint64(Math.trunc(data['monero'].usd * million)),
        encodeUint64(Math.trunc(data['aave'].usd * million)),
        encodeUint64(Math.trunc(data['leo-token'].usd * million)),
        encodeUint64(Math.trunc(data['klay-token'].usd * million)),
        encodeUint64(Math.trunc(data['gala'].usd * million)),
        encodeUint64(Math.trunc(data['the-graph'].usd * million)),
    ]);
    const tx4 = algosdk.makeApplicationNoOpTxn(addr, params, app_id, [
        new Uint8Array(Buffer.from('update_slot_4')),
        encodeUint64(Math.trunc(data['eos'].usd * million)),
        encodeUint64(Math.trunc(data['pancakeswap-token'].usd * million)),
        encodeUint64(Math.trunc(data['blockstack'].usd * million)),
        encodeUint64(Math.trunc(data['flow'].usd * million)),
        encodeUint64(Math.trunc(data['loopring'].usd * million)),
        encodeUint64(Math.trunc(data['harmony'].usd * million)),
        encodeUint64(Math.trunc(data['bittorrent-2'].usd * million)),
        encodeUint64(Math.trunc(data['kusama'].usd * million)),
        encodeUint64(Math.trunc(data['maker'].usd * million)),
        encodeUint64(Math.trunc(data['enjincoin'].usd * million)),
        encodeUint64(Math.trunc(data['bitcoin-cash-sv'].usd * million)),
        encodeUint64(Math.trunc(data['quant-network'].usd * million)),
        encodeUint64(Math.trunc(data['amp-token'].usd * million)),
        encodeUint64(Math.trunc(data['kadena'].usd * million)),
        encodeUint64(Math.trunc(data['ecash'].usd * million)),
    ]);
    const txGroup = algosdk.assignGroupID([tx1, tx2, tx3, tx4]);
    const txn = await algoClient
        .sendRawTransaction([
            txGroup[0].signTxn(sk),
            txGroup[1].signTxn(sk),
            txGroup[2].signTxn(sk),
            txGroup[3].signTxn(sk),
        ])
        .do();
    console.log('tx send: ' + txn.txId);
    const txResolve = await waitForConfirmation(algoClient, txn.txId, 5);
    console.log('tx confirmed in round: ' + txResolve);
    main();
    return;
};

const main = async () => {
    // Get data from coingecko's API
    fetch(coingeckoApi)
        .then((response) => response.json())
        .then((data) => {
            if (data) {
                getData(data);
            } else {
                throw new Error('Undefined received from coingeko');
            }
        })
        .catch((e) => console.log(e));
};

main();

'''
'''--- server/get_prices_algoclient.js ---
const algosdk = require('algosdk');
const dotenv = require('dotenv');

dotenv.config();

const app_id = parseInt(process.env.APP_ID_USD);
const server = process.env.ALGOEXPLORER_INDEXER_API;
const algoIndexer = new algosdk.Indexer('', server, '');

const getCRypto = async () => {
    let values = {};
    const accountInfoResponse = await algoIndexer.lookupApplications(app_id).do();

    for (let i = 0; i < accountInfoResponse['application']['params']['global-state'].length; i++) {
        const var_name = Buffer.from(
            accountInfoResponse['application']['params']['global-state'][i][`key`],
            'base64',
        ).toString();
        if (accountInfoResponse['application']['params']['global-state'][i]['value']['type'] === 2) {
            values[var_name] =
                accountInfoResponse['application']['params']['global-state'][i]['value']['uint'] / 1000000;
        }
    }

    console.log(values);
    console.log("Bitcoin's price is " + values['BTC'] + ' USD');
};

getCRypto();

'''
'''--- smartcontract/__init__.py ---

'''
'''--- smartcontract/crypto_price.py ---
from pyteal import *

def approval_program():
    on_creation = Seq([
        App.globalPut(Bytes("Creator"), Txn.sender()),
        Assert(Txn.application_args.length() == Int(0)),
        Approve()
    ])

    update_slot_1 = Seq([
        Assert(Txn.sender() == App.globalGet(Bytes("Creator"))),
        Assert(Txn.application_args.length() == Int(16)),
        App.globalPut(Bytes("BTC"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("ETH"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("BNB"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("SOL"), Btoi(Txn.application_args[4])),
        App.globalPut(Bytes("ADA"), Btoi(Txn.application_args[5])),
        App.globalPut(Bytes("XRP"), Btoi(Txn.application_args[6])),
        App.globalPut(Bytes("LUNA"), Btoi(Txn.application_args[7])),
        App.globalPut(Bytes("DOT"), Btoi(Txn.application_args[8])),
        App.globalPut(Bytes("AVAX"), Btoi(Txn.application_args[9])),
        App.globalPut(Bytes("DOGE"), Btoi(Txn.application_args[10])),
        App.globalPut(Bytes("SHIB"), Btoi(Txn.application_args[11])),
        App.globalPut(Bytes("MATIC"), Btoi(Txn.application_args[12])),
        App.globalPut(Bytes("CRO"), Btoi(Txn.application_args[13])),
        App.globalPut(Bytes("WBTC"), Btoi(Txn.application_args[14])),
        App.globalPut(Bytes("UNI"), Btoi(Txn.application_args[15])),
        Approve()
    ])

    update_slot_2 = Seq([
        Assert(Txn.sender() == App.globalGet(Bytes("Creator"))),
        Assert(Txn.application_args.length() == Int(16)),
        App.globalPut(Bytes("LTC"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("LINK"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("ALGO"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("BCH"), Btoi(Txn.application_args[4])),
        App.globalPut(Bytes("NEAR"), Btoi(Txn.application_args[5])),
        App.globalPut(Bytes("TRX"), Btoi(Txn.application_args[6])),
        App.globalPut(Bytes("XML"), Btoi(Txn.application_args[7])),
        App.globalPut(Bytes("MANA"), Btoi(Txn.application_args[8])),
        App.globalPut(Bytes("AXS"), Btoi(Txn.application_args[9])),
        App.globalPut(Bytes("ATOM"), Btoi(Txn.application_args[10])),
        App.globalPut(Bytes("VET"), Btoi(Txn.application_args[11])),
        App.globalPut(Bytes("FTT"), Btoi(Txn.application_args[12])),
        App.globalPut(Bytes("FTM"), Btoi(Txn.application_args[13])),
        App.globalPut(Bytes("SAND"), Btoi(Txn.application_args[14])),
        App.globalPut(Bytes("FIL"), Btoi(Txn.application_args[15])),
        Approve()
    ])

    update_slot_3 = Seq([
        Assert(Txn.sender() == App.globalGet(Bytes("Creator"))),
        Assert(Txn.application_args.length() == Int(16)),
        App.globalPut(Bytes("HBAR"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("BTCB"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("THETA"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("EGLD"), Btoi(Txn.application_args[4])),
        App.globalPut(Bytes("ICP"), Btoi(Txn.application_args[5])),
        App.globalPut(Bytes("ETC"), Btoi(Txn.application_args[6])),
        App.globalPut(Bytes("MIOTA"), Btoi(Txn.application_args[7])),
        App.globalPut(Bytes("XTZ"), Btoi(Txn.application_args[8])),
        App.globalPut(Bytes("HNT"), Btoi(Txn.application_args[9])),
        App.globalPut(Bytes("XMR"), Btoi(Txn.application_args[10])),
        App.globalPut(Bytes("AAVE"), Btoi(Txn.application_args[11])),
        App.globalPut(Bytes("LEO"), Btoi(Txn.application_args[12])),
        App.globalPut(Bytes("KLAY"), Btoi(Txn.application_args[13])),
        App.globalPut(Bytes("GALA"), Btoi(Txn.application_args[14])),
        App.globalPut(Bytes("GRT"), Btoi(Txn.application_args[15])),
        Approve()
    ])

    update_slot_4 = Seq([
        Assert(Txn.sender() == App.globalGet(Bytes("Creator"))),
        Assert(Txn.application_args.length() == Int(16)),
        App.globalPut(Bytes("EOS"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("CAKE"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("STX"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("FLOW"), Btoi(Txn.application_args[4])),
        App.globalPut(Bytes("LRC"), Btoi(Txn.application_args[5])),
        App.globalPut(Bytes("ONE"), Btoi(Txn.application_args[6])),
        App.globalPut(Bytes("BTT"), Btoi(Txn.application_args[7])),
        App.globalPut(Bytes("KSM"), Btoi(Txn.application_args[8])),
        App.globalPut(Bytes("MKR"), Btoi(Txn.application_args[9])),
        App.globalPut(Bytes("ENJ"), Btoi(Txn.application_args[10])),
        App.globalPut(Bytes("BSV"), Btoi(Txn.application_args[11])),
        App.globalPut(Bytes("QNT"), Btoi(Txn.application_args[12])),
        App.globalPut(Bytes("AMP"), Btoi(Txn.application_args[13])),
        App.globalPut(Bytes("KDA"), Btoi(Txn.application_args[14])),
        App.globalPut(Bytes("XEC"), Btoi(Txn.application_args[15])),
        Approve()
    ])

    only_admin = Seq([
        Assert(Txn.sender() == App.globalGet(Bytes("Creator"))),
        Approve()
    ])

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.OptIn, only_admin],
        [Txn.on_completion() == OnComplete.UpdateApplication, only_admin],
        [Txn.on_completion() == OnComplete.DeleteApplication, only_admin],
        [Txn.on_completion() == OnComplete.ClearState, only_admin],
        [Txn.application_args[0] == Bytes("update_slot_1"), update_slot_1],
        [Txn.application_args[0] == Bytes("update_slot_2"), update_slot_2],
        [Txn.application_args[0] == Bytes("update_slot_3"), update_slot_3],
        [Txn.application_args[0] == Bytes("update_slot_4"), update_slot_4],
    )

    return program

def clear_state_program():
    return Int(0)

'''