*GitHub Repository "nearprotocol/near-node-debug"*

'''--- prometheus/core.py ---
import math
import time
from random import randint, random
from threading import Thread

import networkx as nx
import numpy as np
import requests

NETWORK_INFO = 'network_info'
STATUS = 'status'
SLEEP_TIME = 5

class Fetcher(Thread):
    def __init__(self, bootstrap, data_callback):
        self._all_nodes = [bootstrap]
        self._callback = data_callback
        super().__init__()

    def populate(self, active_peers):
        new_node = False
        for peer in active_peers:
            ip, port = peer['addr'].split(':')
            if ip == '127.0.0.1':
                port = 3030 + int(port) - 24567
            else:
                port = 3030
            addr = f"http://{ip}:{port}"

            if addr not in self._all_nodes:
                self._all_nodes.append(addr)
                new_node = True
        return new_node

    def run(self):
        while True:
            new_node = False

            for node in list(self._all_nodes):
                # Fetch all data
                res_network_info = requests.get(
                    node + "/" + NETWORK_INFO).json()
                me = res_network_info['metric_recorder']['me']
                res_status = requests.get(node + "/" + STATUS).json()

                # Build dictionary with all data and execute callback
                info = {
                    NETWORK_INFO: res_network_info,
                    STATUS: res_status
                }
                self._callback(me, info)

                # Populate all nodes
                new_node |= self.populate(
                    active_peers=res_network_info['active_peers'])

            if not new_node:
                time.sleep(SLEEP_TIME)

class Api:
    def __init__(self, bootstrap, handle_callback):
        self._handle_callback = handle_callback
        self.fetcher = Fetcher(bootstrap, self.handle)
        self.fetcher.start()
        self.nodes = {}

    def heights(self):
        answer = []
        for _, node in self.nodes.items():
            answer.append(node[STATUS]['sync_info']['latest_block_height'])
        return answer

    def stats_per_type_of_message(self):
        data = {}
        for _, node in self.nodes.items():
            for key, value in node[NETWORK_INFO]['metric_recorder']['per_type'].items():
                if not key in data:
                    # Sent count sum / Sent count max / Sent bytes sum / Sent bytes max
                    data[key] = [0, 0, 0, 0]
                count = value['sent']['count']
                size = value['sent']['bytes']

                data[key][0] += count
                data[key][1] = max(data[key][1], count)
                data[key][2] += size
                data[key][3] = max(data[key][3], size)
        return data

    def validators(self):
        if len(self.nodes) == 0:
            return 0
        _, node = next(iter(self.nodes.items()))
        return len(node[STATUS]['validators'])

    def handle(self, me, info):
        self.nodes[me] = info
        self._handle_callback(self, me)

    def num_nodes(self):
        return len(self.nodes)

    def diameter(self):
        return nx.diameter(self.get_graph())

    def node_ix(self):
        return {node_id: ix for (
            ix, node_id) in enumerate(sorted(self.nodes))}

    def get_graph(self):
        G = nx.Graph()
        n = self.num_nodes()

        for u in range(n):
            G.add_node(u)
            G.nodes[u]['pos'] = (math.cos(u / n * 2 * math.pi),
                                 math.sin(u / n * 2 * math.pi))

        node_ix = self.node_ix()

        if len(self.nodes):
            graph = next(iter(self.nodes.items()))[
                1]['metric_recorder']['graph']
            for (u, v) in graph:
                u = node_ix[u]
                v = node_ix[v]
                G.add_edge(u, v)

        return G

    def get_latency_heatmap(self):
        n = self.num_nodes()
        node_ix = self.node_ix()

        lat = np.zeros((n, n))
        t = float('inf')

        for u, data in self.nodes.items():
            u = node_ix.get(u)
            for (v, l) in data[NETWORK_INFO]['metric_recorder']['latencies'].items():
                v = node_ix.get(v, -1)
                if v == -1:
                    continue
                lat[u][v] = l['mean_latency']
                t = min(t, lat[u][v])

        for i in range(n):
            lat[i][i] = t

        return lat

    def get_transfer_bytes_heatmap(self):
        n = self.num_nodes()
        node_ix = self.node_ix()

        res = np.zeros((n, n))
        t = float('inf')

        for u, data in self.nodes.items():
            u = node_ix.get(u)
            for (v, l) in data[NETWORK_INFO]['metric_recorder']['per_peer'].items():
                v = node_ix.get(v, -1)
                if v == -1:
                    continue
                res[u][v] = l['received']['bytes']
                t = min(t, res[u][v])

        for i in range(n):
            res[i][i] = t

        return res

    def get_transfer_count_heatmap(self):
        n = self.num_nodes()
        node_ix = self.node_ix()

        res = np.zeros((n, n))
        t = float('inf')

        for u, data in self.nodes.items():
            u = node_ix.get(u)
            for (v, l) in data[NETWORK_INFO]['metric_recorder']['per_peer'].items():
                v = node_ix.get(v, -1)
                if v == -1:
                    continue
                res[u][v] = l['received']['count']
                t = min(t, res[u][v])

        for i in range(n):
            res[i][i] = t

        return res

    def get_received_type(self):
        size, total, labels = [], [], []
        for (label, data) in next(iter(self.nodes.items()))[1]['metric_recorder']['per_type'].items():
            labels.append(label)
            size.append(data[NETWORK_INFO]['received']['bytes'])
            total.append(data[NETWORK_INFO]['received']['count'])
        return size, total, labels

    def get_received_peer(self):
        size, total, labels = [], [], []
        for (label, data) in next(iter(self.nodes.items()))[1]['metric_recorder']['per_peer'].items():
            labels.append(label)
            size.append(data[NETWORK_INFO]['received']['bytes'])
            total.append(data[NETWORK_INFO]['received']['count'])
        return size, total, labels

    def summary(self):
        g = self.get_graph()
        header = ["Node ID", "Active peers"]
        values = [[], []]

        for u, node_id in enumerate(self.nodes):
            values[0].append(node_id)
            values[1].append(len(g[u]))

        return header, values

'''
'''--- prometheus/prometheus.py ---

import random
import threading
import time
from collections import deque
from wsgiref.simple_server import make_server

from prometheus_client import (Counter, Gauge, Histogram, Summary,
                               make_wsgi_app, start_http_server)

import core

class GaugeWithDelta:
    def __init__(self, name, doc, interval):
        self.main = Gauge(f"{name}", f"{doc}")
        self.delta = Gauge(
            f"{name}_delta", f"Delta from the last {interval} seconds from {doc}")
        self.deq_size = Gauge(
            f"{name}_deq_size", f"Size of the deque internally from {doc}")
        self.deq = deque()
        self.interval = interval

    def add(self, value):
        self.main.set(value)
        now = time.time()
        self.deq.append((now, value))
        while now - self.deq[0][0] > self.interval:
            self.deq.popleft()
        if self.deq[0][1] == self.deq[-1][1]:
            g_per_interval = 1. / self.interval
        else:
            g_per_interval = (self.deq[-1][1] -
                              self.deq[0][1] - 1) / (self.deq[-1][0] - self.deq[0][0])
        self.delta.set(g_per_interval)
        self.deq_size.set(len(self.deq))

handle_calls = Counter("handle_message_calls",
                       "All calls to handle message so far.")

highest_block = GaugeWithDelta("highest_block", "Latest block", 60)

validators = Gauge("validators", "Validators")

all_messages = {}

def handle_message(api, node):
    handle_calls.inc()
    # Record heights
    heights = api.heights()
    highest_block.add(max(heights))

    stats = api.stats_per_type_of_message()

    validators.set(api.validators())
    for key, stat in stats.items():
        if not key in all_messages:
            all_messages[key] = [GaugeWithDelta(
                f"{key}_{name}", f"{doc} {key}", 60) for (name, doc) in
                [("count_sum", "Count sum of"),
                 ("count_max", "Count max of"),
                 ("bytes_sum", "Bytes sum of"),
                 ("bytes_max", "Bytes max of")]
            ]

        for val, g in zip(stat, all_messages[key]):
            g.add(val)

if __name__ == '__main__':
    api = core.Api('http://localhost:3030', handle_message)

    app = make_wsgi_app()
    httpd = make_server('', 8000, app)
    httpd.serve_forever()

'''
'''--- requirements.txt ---
dash
networkx
matplotlib
plotly

'''
'''--- simple_dashboard/README.md ---
# Network dashboard

Install dependency using:
```bash
pip install -r requirements.txt
```

## Start dashboard

```bash
python3 app.py https://<node_ip>:<rpc_port>
```

If you are running network locally using:

```bash
python3 app.py https://127.0.0.1:3030
```

'''
'''--- simple_dashboard/app.py ---
#!/usr/bin/python3
import datetime
import sys

import dash
import dash_core_components as dcc
import dash_html_components as html
import networkx as nx
import plotly
import plotly.graph_objects as go
from dash.dependencies import Input, Output

from core import Api

try:
    api = Api(sys.argv[1])
except:
    print("Specify ip of one node.")
    print("python3 app.py http://127.0.0.1:3030")
    exit(1)

app = dash.Dash(__name__, routes_pathname_prefix="/near/")
app.layout = html.Div(
    html.Div([
        html.H1('Near Network | Dashboard'),
        html.Div(id='general-info'),
        dcc.Graph(id='network-layout'),
        dcc.Graph(id='heatmap-info'),
        dcc.Graph(id='received-type'),
        dcc.Graph(id='received-peer'),
        dcc.Graph(id='summary'),
        dcc.Interval(
            id='interval-component',
            interval=5*1000,  # in milliseconds
            n_intervals=0
        )
    ])
)

@app.callback(Output('general-info', 'children'), [Input('interval-component', 'n_intervals')])
def update_general_info(n):
    style = {'padding': '5px', 'fontSize': '16px'}
    return [
        html.Span(f'Number of nodes: {api.num_nodes()}', style=style),
        html.Span(f'Diameter: {api.diameter()}', style=style),
    ]

@app.callback(Output('network-layout', 'figure'), [Input('interval-component', 'n_intervals')])
def update_graph_live(n):
    G = api.get_graph()

    # G = nx.random_geometric_graph(200, 0.125)

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = G.nodes[edge[0]]['pos']
        x1, y1 = G.nodes[edge[1]]['pos']
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines')

    node_x = []
    node_y = []
    for node in G.nodes():
        x, y = G.nodes[node]['pos']
        node_x.append(x)
        node_y.append(y)

    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            showscale=False,
            colorscale='YlGnBu',
            reversescale=True,
            color=[],
            size=10,
            colorbar=dict(
                thickness=15,
                title='Node Connections',
                xanchor='left',
                titleside='right'
            ),
            line_width=2))

    node_adjacencies = []
    node_text = []
    for node, adjacencies in enumerate(G.adjacency()):
        node_adjacencies.append(len(adjacencies[1]))
        node_text.append('# of connections: '+str(len(adjacencies[1])))

    node_trace.marker.color = node_adjacencies
    node_trace.text = node_text

    fig = go.Figure(data=[edge_trace, node_trace],
                    layout=go.Layout(
                    title='Network Layout',
                    titlefont_size=16,
                    showlegend=False,
                    hovermode='closest',
                    margin=dict(b=20, l=5, r=5, t=40),
                    annotations=[dict(
                        text="",
                        showarrow=False,
                        xref="paper", yref="paper",
                        x=0.005, y=-0.002)],
                    xaxis=dict(showgrid=False, zeroline=False,
                               showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                    )

    return fig

@app.callback(Output('heatmap-info', 'figure'), [Input('interval-component', 'n_intervals')])
def update_graph_live(n):
    fig = plotly.subplots.make_subplots(
        rows=1, cols=3, subplot_titles=("Latency", "Bytes", "Total"))

    fig.add_heatmap(z=api.get_latency_heatmap(), row=1,
                    col=1, showscale=False, colorscale='MAGMA_r')
    fig.add_heatmap(z=api.get_transfer_bytes_heatmap(),
                    row=1, col=2, showscale=False, colorscale='MAGMA_r')
    fig.add_heatmap(z=api.get_transfer_count_heatmap() * 100,
                    row=1, col=3, showscale=False, colorscale='MAGMA_r')

    return fig

@app.callback(Output('received-type', 'figure'), [Input('interval-component', 'n_intervals')])
def update_received_type(n):
    fig = plotly.subplots.make_subplots(
        rows=1, cols=2, subplot_titles=["Bytes", "Total"], specs=[[{'type': 'domain'}, {'type': 'domain'}]])
    size, total, labels = api.get_received_type()
    fig.add_trace(go.Pie(labels=labels, values=size), 1, 1)
    fig.add_trace(go.Pie(labels=labels, values=total), 1, 2)
    fig.update_traces(textposition='inside')
    fig.update_layout(uniformtext_minsize=12, uniformtext_mode='hide')
    return fig

@app.callback(Output('received-peer', 'figure'), [Input('interval-component', 'n_intervals')])
def update_received_peer(n):
    fig = plotly.subplots.make_subplots(
        rows=1, cols=2, subplot_titles=["Bytes", "Total"], specs=[[{'type': 'domain'}, {'type': 'domain'}]])
    size, total, labels = api.get_received_peer()

    fig.add_trace(go.Pie(labels=labels, values=size), 1, 1)
    fig.add_trace(go.Pie(labels=labels, values=total), 1, 2)
    fig.update_traces(textposition='inside')
    fig.update_layout(uniformtext_minsize=12, uniformtext_mode='hide')
    return fig

@app.callback(Output('summary', 'figure'), [Input('interval-component', 'n_intervals')])
def update_received_peer(n):
    header, values = api.summary()
    fig = go.Figure(data=[go.Table(header=dict(values=header),
                                   cells=dict(values=values))
                          ])
    return fig

if __name__ == '__main__':
    app.run_server(debug=False)

'''
'''--- simple_dashboard/start.sh ---
#!/bin/bash
nohup python3 app.py http://34.80.180.137:3030 > app.out &
child_pid=$!
echo Start process at $child_pid
echo $child_pid > app.pid

'''
'''--- simple_dashboard/stop.sh ---
#!/bin/bash
kill -9 $(cat app.pid)
rm app.pid

'''