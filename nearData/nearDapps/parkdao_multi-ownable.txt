*GitHub Repository "parkdao/multi-ownable"*

'''--- Cargo.toml ---
[workspace]
members = [
  "multi-ownable",
  "test-contract"
]
'''
'''--- README.md ---
# multi-ownable

A NEAR plugin enables multiple Accounts to share ownership of a contract.
Calls are stored in hashed form, so storage requirements are very low.

### test

cargo test -- --nocapture

### usage

`multi-ownable` can be addeded to your contract via a macro:

```rust
// Arguments:
// 1. name of your contract
// 2. name of the field where the multi ownable state is stored
// 3. enum type for possible multisig calls
// 4. callback function to process completed multisig calls
crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);
```

Here is a full working example of how to use `multi-ownable`

```rust
// import "impl_multi_ownable" and "MultiOwnableData"
use multi_ownable::{impl_multi_ownable, MultiOwnableData};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  multi_ownable: MultiOwnableData, // add this to the Contract
  number: u64,
}
#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  Owners,
  MultiOwnableCalls,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(owner_id: AccountId) -> Self {
    let mut this = Self {
      number: 0,
      multi_ownable: MultiOwnableData::new(StorageKey::Owners, StorageKey::MultiOwnableCalls),
    };
    // initialize multi_ownable in the "new" func of your Contract
    this.init_multi_ownable(vec![owner_id.clone()], 1);
    this
  }

  pub fn get_number(&self) -> u64 {
    self.number
  }

  // arguments are received as a json string
  fn on_call(&mut self, call_name: MultiOwnableCall, arguments: &str) {
    match call_name {
      MultiOwnableCall::UpdateNumber => self._update_number(arguments),
      MultiOwnableCall::DoSomethingElse => self._do_something_else(arguments),
    }
  }

  #[private]
  fn _update_number(&mut self, args: &str) {
    // first, deserialize your arguments
    let UpdateNumberArgs { number } =
      near_sdk::serde_json::from_str(&args).expect("Invalid SetRewardRateArgs");
    self.number = number;
  }

  #[private]
  fn _do_something_else(&self, _args: &str) {
    // do something else
  }
}

// an argument struct for "update_number" call
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UpdateNumberArgs {
  pub number: u64,
}

// create an enum to match possible multisig calls
// make sure to both "rename" and "alias" your fields to be snake_case
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MultiOwnableCall {
  #[serde(rename = "update_number", alias = "update_number")]
  UpdateNumber,
  #[serde(rename = "do_something_else", alias = "do_something_else")]
  DoSomethingElse,
}

crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);

```
'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
source flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./out/
'''
'''--- flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- multi-ownable/Cargo.toml ---
[package]
name = "multi-ownable"
description = "NEAR plugin for sharing ownership of a contract between multiple accounts"
version = "0.1.2"
edition = "2021"
authors = ["middlew4y <middlew4y@protonmail.com>"]
keywords = ["near", "multisig", "ownable"]
categories = ["no-std", "wasm"]
license = "MIT"
repository = "https://github.com/parkdao/multi-ownable"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
sha2 = "0.10.1"

'''
'''--- multi-ownable/README.md ---
# multi-ownable

A NEAR plugin enables multiple Accounts to share ownership of a contract.
Calls are stored in hashed form, so storage requirements are very low.

### test

cargo test -- --nocapture

### usage

`multi-ownable` can be addeded to your contract via a macro:

```rust
// Arguments:
// 1. name of your contract
// 2. name of the field where the multi ownable state is stored
// 3. enum type for possible multisig calls
// 4. callback function to process completed multisig calls
crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);
```

Here is a full working example of how to use `multi-ownable`

```rust
// import "impl_multi_ownable" and "MultiOwnableData"
use multi_ownable::{impl_multi_ownable, MultiOwnableData};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  multi_ownable: MultiOwnableData, // add this to the Contract
  number: u64,
}
#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  Owners,
  MultiOwnableCalls,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(owner_id: AccountId) -> Self {
    let mut this = Self {
      number: 0,
      multi_ownable: MultiOwnableData::new(StorageKey::Owners, StorageKey::MultiOwnableCalls),
    };
    // initialize multi_ownable in the "new" func of your Contract
    this.init_multi_ownable(vec![owner_id.clone()], 1);
    this
  }

  pub fn get_number(&self) -> u64 {
    self.number
  }

  // arguments are received as a json string
  fn on_call(&mut self, call_name: MultiOwnableCall, arguments: &str) {
    match call_name {
      MultiOwnableCall::UpdateNumber => self._update_number(arguments),
      MultiOwnableCall::DoSomethingElse => self._do_something_else(arguments),
    }
  }

  #[private]
  fn _update_number(&mut self, args: &str) {
    // first, deserialize your arguments
    let UpdateNumberArgs { number } =
      near_sdk::serde_json::from_str(&args).expect("Invalid SetRewardRateArgs");
    self.number = number;
  }

  #[private]
  fn _do_something_else(&self, _args: &str) {
    // do something else
  }
}

// an argument struct for "update_number" call
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UpdateNumberArgs {
  pub number: u64,
}

// create an enum to match possible multisig calls
// make sure to both "rename" and "alias" your fields to be snake_case
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MultiOwnableCall {
  #[serde(rename = "update_number", alias = "update_number")]
  UpdateNumber,
  #[serde(rename = "do_something_else", alias = "do_something_else")]
  DoSomethingElse,
}

crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);

```
'''
'''--- multi-ownable/src/lib.rs ---
//! # multi-ownable
//!
//! A NEAR plugin enables multiple Accounts to share ownership of a contract.
//! Calls are stored in hashed form, so storage requirements are very low.
//!
//! ### test
//!
//! cargo test -- --nocapture
//!
//! ### usage
//!
//! `multi-ownable` can be addeded to your contract via a macro:
//!
//! ```rust
//! // Arguments:
//! // 1. name of your contract
//! // 2. name of the field where the multi ownable state is stored
//! // 3. enum type for possible multisig calls
//! // 4. callback function to process completed multisig calls
//! crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);
//! ```
//!
//! Example:
//!
//! ```rust
//! // import "impl_multi_ownable" and "MultiOwnableData"
//! use multi_ownable::{impl_multi_ownable, MultiOwnableData};
//! use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
//! use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault};
//!
//! #[near_bindgen]
//! #[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
//! pub struct Contract {
//!   multi_ownable: MultiOwnableData, // add this to the Contract
//!   number: u64,
//! }
//! #[derive(BorshSerialize, BorshStorageKey)]
//! enum StorageKey {
//!   Owners,
//!   MultiOwnableCalls,
//! }
//!
//! #[near_bindgen]
//! impl Contract {
//!   #[init]
//!   pub fn new(owner_id: AccountId) -> Self {
//!     let mut this = Self {
//!       number: 0,
//!       multi_ownable: MultiOwnableData::new(StorageKey::Owners, StorageKey::MultiOwnableCalls),
//!     };
//!     // initialize multi_ownable in the "new" func of your Contract
//!     this.init_multi_ownable(vec![owner_id.clone()], 1);
//!     this
//!   }
//!
//!   pub fn get_number(&self) -> u64 {
//!     self.number
//!   }
//!
//!   // arguments are received as a json string
//!   fn on_call(&mut self, call_name: MultiOwnableCall, arguments: &str) {
//!     match call_name {
//!       MultiOwnableCall::UpdateNumber => self._update_number(arguments),
//!       MultiOwnableCall::DoSomethingElse => self._do_something_else(arguments),
//!     }
//!   }
//!
//!   #[private]
//!   fn _update_number(&mut self, args: &str) {
//!     // deserialize your arguments
//!     let UpdateNumberArgs { number } =
//!       near_sdk::serde_json::from_str(&args).expect("Invalid SetRewardRateArgs");
//!     self.number = number;
//!   }
//!
//!   #[private]
//!   fn _do_something_else(&self, _args: &str) {
//!     // do something else
//!   }
//! }
//!
//! // an argument struct for "update_number" call
//! #[derive(Serialize, Deserialize, Clone)]
//! #[serde(crate = "near_sdk::serde")]
//! pub struct UpdateNumberArgs {
//!   pub number: u64,
//! }
//!
//! // create an enum to match possible multisig calls
//! // make sure to both "rename" and "alias" your fields to be snake_case
//! #[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
//! #[serde(crate = "near_sdk::serde")]
//! pub enum MultiOwnableCall {
//!   #[serde(rename = "update_number", alias = "update_number")]
//!   UpdateNumber,
//!   #[serde(rename = "do_something_else", alias = "do_something_else")]
//!   DoSomethingElse,
//! }
//!
//! crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);
//!
//! ```

pub mod macros;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::{AccountId, IntoStorageKey};
pub use sha2;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultiOwnableData {
  pub owners: UnorderedSet<AccountId>,
  pub threshold: u32,
  pub calls: UnorderedMap<Vec<u8>, Vec<AccountId>>,
}

impl MultiOwnableData {
  pub fn new<S, T>(owners_key: S, calls_key: T) -> Self
  where
    S: IntoStorageKey,
    T: IntoStorageKey,
  {
    Self {
      threshold: 0,
      owners: UnorderedSet::new(owners_key),
      calls: UnorderedMap::new(calls_key),
    }
  }
}

'''
'''--- multi-ownable/src/macros.rs ---
#[macro_export]
macro_rules! impl_multi_ownable {
  ($contract: ident, $state: ident, $allowed_calls_enum: ty $(, $on_call:ident)?) => {

    use near_sdk::serde::{Deserialize, Serialize};
    use near_sdk::serde_json;
    use near_sdk::serde_json::json;

    #[derive(Serialize, Deserialize)]
    #[serde(crate = "near_sdk::serde")]
    struct UpdateDto {
      threshold: u32,
      owners: Vec<AccountId>,
    }

    const UPDATE_KEY: &str = "_";
    // const PENDING_KEY: &str = "/"
    // const CLAIM_KEY: &str = "|";

    #[near_bindgen]
    impl $contract {
      pub fn init_multi_ownable(&mut self, owners: Vec<AccountId>, threshold: u32) {
        self.assert_valid_args(owners.clone(), threshold);
        self._set_multi_ownable_data(owners, threshold);
      }
      /// get_owners view method
      pub fn get_owners(&self) -> Vec<AccountId> {
        self.$state.owners.to_vec()
      }
      /// get_owners view method
      pub fn get_threshold(&self) -> u32 {
        self.$state.threshold
      }
      /// change the owners and threshold
      pub fn update_multi_ownable(&mut self, owners: Vec<AccountId>, threshold: u32) -> bool {
        self.assert_is_owner();
        self.assert_valid_args(owners.clone(), threshold);
        let mut signers = owners.clone();
        signers.sort();
        let args = serde_json::to_string(&UpdateDto{
          owners: signers,
          threshold: threshold,
        }).expect("could not serialze args");
        if self._multi_ownable_call(UPDATE_KEY, args.as_str()) {
          // "true" result means threshold has been reached
          self._set_multi_ownable_data(owners, threshold);
          // remove all pending calls when ownership changes
          self.$state.calls.clear();
          return true;
        }
        false
      }
      /// make a call as one of the owners
      pub fn multi_ownable_call(&mut self, call_name: String, arguments: String) -> bool {
        self.assert_is_owner();
        self.assert_allowed_call(call_name.as_str());
        self._multi_ownable_call(call_name.as_str(), arguments.as_str())
      }
      /// remove your own call, if it exists
      pub fn revoke_multi_ownable_call(&mut self, call_name: String, arguments: String) -> bool {
        self.assert_is_owner();
        self.assert_allowed_call(call_name.as_str());
        let res = self._sha2_hash(call_name + &arguments);
        let caller = env::predecessor_account_id();
        match self.$state.calls.get(&res) {
          Some(existing) => {
            // remove your own call
            let signers = existing.into_iter().filter(|s| s != &caller).collect();
            self.$state.calls.insert(&res, &signers);
            return true;
          }
          None => (),
        }
        false
      }
      #[private]
      fn(crate) assert_is_owner(&self) {
        let caller = env::predecessor_account_id();
        let is_owner = self.$state.owners.contains(&caller);
        require!(is_owner, "predecessor must be an owner");
      }
      #[private]
      fn assert_valid_args(&self, owners: Vec<AccountId>, threshold: u32) {
        require!(owners.len() > 0, "too few owners");
        require!(threshold > 0, "threshold must be at least 1");
        require!((owners.len() as u32) <= threshold, "owners must be less than or equal to threshold");
      }
      #[private]
      fn assert_allowed_call(&self, call_name: &str) -> $allowed_calls_enum {
        let call: $allowed_calls_enum = serde_json::from_value(json!(call_name)).expect(format!("invalid call name {}", call_name).as_str());
        call
      }
      #[private]
      fn _set_multi_ownable_data(&mut self, owners: Vec<AccountId>, threshold: u32) {
        for o in owners.iter() {
          self.$state.owners.insert(o);
        }
        self.$state.threshold = threshold;
      }
      #[private]
      fn _trigger_on_call(&mut self, call_name: &str, arguments: &str) {
        // ok to fail call_name deserialization, might be UPDATE_KEY
        match serde_json::from_value(json!(call_name)) {
          Ok(call) => {
            $(self.$on_call(call, arguments);)?
          }
          Err(_) => ()
        };
      }
      #[private]
      fn _multi_ownable_call(&mut self, call_name: &str, arguments: &str) -> bool {
        let res = self._sha2_hash(call_name.to_string() + arguments);
        let caller = env::predecessor_account_id();
        if self.$state.threshold == 1 {
          // success!
          self._trigger_on_call(call_name, arguments);
          return true;
        } else {
          match self.$state.calls.get(&res) {
            Some(existing) => {
              if (existing.len() + 1) as u32 >= self.$state.threshold {
                // success!
                self._trigger_on_call(call_name, arguments);
                self.$state.calls.remove(&res);
                return true;
              } else {
                let mut signers = existing.clone();
                if existing.contains(&caller) {
                  signers.push(caller);
                  self.$state.calls.insert(&res, &signers);
                }
              }
            }
            None => {
              self.$state.calls.insert(&res, &vec![caller]);
            }
          }
        }
        false
      }
      #[private]
      fn _sha2_hash(&self, input: String) -> Vec<u8> {
        use $crate::sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        hasher.finalize().to_vec()
      }
    }
  };
}

'''
'''--- out/README.md ---
# Folder that contains wasm files
'''
'''--- test-contract/Cargo.toml ---
[package]
name = "test-contract"
version = "0.0.1"
authors = ["middlew4y <middlew4y@protonmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"
multi-ownable = { path = "../multi-ownable" }

[dev-dependencies]
tokio = { version = "1.10.0", features = ["full"] }
workspaces = "0.1" 
anyhow = "1.0"
'''
'''--- test-contract/src/lib.rs ---
use multi_ownable::{impl_multi_ownable, MultiOwnableData};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  multi_ownable: MultiOwnableData,
  number: u64,
}
#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  Owners,
  MultiOwnableCalls,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(owner_id: AccountId) -> Self {
    let mut this = Self {
      number: 0,
      multi_ownable: MultiOwnableData::new(StorageKey::Owners, StorageKey::MultiOwnableCalls),
    };
    this.init_multi_ownable(vec![owner_id.clone()], 1);
    this
  }

  pub fn get_number(&self) -> u64 {
    self.number
  }

  fn on_call(&mut self, call_name: MultiOwnableCall, arguments: &str) {
    match call_name {
      MultiOwnableCall::UpdateNumber => self._update_number(arguments),
      MultiOwnableCall::DoSomethingElse => self._do_something_else(arguments),
    }
  }

  #[private]
  fn _update_number(&mut self, args: &str) {
    let UpdateNumberArgs { number } =
      near_sdk::serde_json::from_str(&args).expect("Invalid SetRewardRateArgs");
    self.number = number;
  }

  #[private]
  fn _do_something_else(&self, _args: &str) {
    // do something else
  }
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UpdateNumberArgs {
  pub number: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MultiOwnableCall {
  #[serde(rename = "update_number", alias = "update_number")]
  UpdateNumber,
  #[serde(rename = "do_something_else", alias = "do_something_else")]
  DoSomethingElse,
}

crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);

'''
'''--- test-contract/tests/test_multi_ownable.rs ---
use near_sdk::serde_json::{json, Value};
use workspaces::prelude::*;
use workspaces::{Account, AccountId, Contract, Network, Worker};

const MULTI_OWNABLE_FILEPATH: &str = "../out/test_contract.wasm";

#[tokio::test]
async fn test_multi_ownable() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();

    let root = worker.root_account();

    let alice = worker.dev_create_account().await?;

    let wasm2 = std::fs::read(MULTI_OWNABLE_FILEPATH)?;
    let contract = worker.dev_deploy(wasm2).await?;
    init(&worker, &contract, &root).await?;

    let number_1 = 123;
    let number_args = json!({ "number": number_1 }).to_string();
    multi_ownable_call(
        &worker,
        &contract,
        &root,
        "update_number",
        number_args.as_str(),
    )
    .await?;

    let owners = get_owners(&worker, &contract).await?;
    println!("OWNERS {:?}", owners);
    assert!(owners.len()==1, "wrong number of owners");

    let thresh = get_threshold(&worker, &contract).await?;
    println!("THRESHOLD {:?}", thresh);

    let rr = get_number(&worker, &contract).await?;
    println!("NUMBER {:?}", rr);
    assert_eq!(number_1, rr, "wrong number");

    update_multi_ownable(
        &worker,
        &contract,
        &root,
        vec![root.id().clone(), alice.id().clone()],
        2,
    )
    .await?;

    let owners = get_owners(&worker, &contract).await?;
    println!("OWNERS 2 {:?}", owners);
    assert!(owners.len()==2, "wrong number of owners");

    let number_2 = 246;
    let number_args = json!({ "number": number_2 }).to_string();
    // root updates
    multi_ownable_call(
        &worker,
        &contract,
        &root,
        "update_number",
        number_args.as_str(),
    )
    .await?;

    let rr = get_number(&worker, &contract).await?;
    println!("NUMBER {:?}", rr);
    assert_eq!(number_1, rr, "wrong number");
    // alice updates
    multi_ownable_call(
        &worker,
        &contract,
        &alice,
        "update_number",
        number_args.as_str(),
    )
    .await?;

    let rr = get_number(&worker, &contract).await?;
    println!("RR {:?}", rr);
    assert_eq!(number_2, rr, "wrong number");

    Ok(())
}
pub async fn multi_ownable_call(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
    call: &str,
    args: &str,
) -> anyhow::Result<()> {
    let outcome = account
        .call(&worker, park.id().clone(), "multi_ownable_call")
        .args_json(json!({ "call_name": call, "arguments": args }))?
        .transact()
        .await?;
    println!("park multi_ownable_call: {:#?}", outcome);
    Ok(())
}

pub async fn update_multi_ownable(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
    new_owners: Vec<AccountId>,
    threshold: u16,
) -> anyhow::Result<()> {
    let outcome = account
        .call(&worker, park.id().clone(), "update_multi_ownable")
        .args_json(json!({ "owners": new_owners, "threshold": threshold }))?
        .transact()
        .await?;
    println!("park update_multi_ownable: {:#?}", outcome);
    Ok(())
}

async fn get_threshold(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<Value> {
    let rr: Value = worker
        .view(park.id().clone(), "get_threshold", Vec::new())
        .await?
        .json()?;
    Ok(rr)
}

async fn get_owners(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<Vec<String>> {
    let rr: Vec<String> = worker
        .view(park.id().clone(), "get_owners", Vec::new())
        .await?
        .json()?;
    Ok(rr)
}

async fn get_number(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<u16> {
    let rr: u16 = worker
        .view(park.id().clone(), "get_number", Vec::new())
        .await?
        .json()?;
    Ok(rr)
}

pub async fn init(
    worker: &Worker<impl Network>,
    park: &Contract,
    root: &Account,
) -> anyhow::Result<()> {
    let outcome = root
        .call(&worker, park.id().clone(), "new")
        .args_json(json!({
            "owner_id": root.id(),
        }))?
        .transact()
        .await?;
    println!("new: {:#?}", outcome);

    Ok(())
}
'''