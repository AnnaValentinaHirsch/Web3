*GitHub Repository "lewisgit/toy_amm"*

'''--- README.md ---
# Toy AMM
This project introduces a demonstration of a simple Automated Market Making (AMM) contract implemented in Rust on the NEAR blockchain platform. The demonstration, ToyAMM, is based on the XYK model, similar to [UniswapV2](https://github.com/Uniswap/v2-core). It is initialized with two Fungible Tokens and allows for users to swap between them using the `swap_for_token` function. For simplicity, only the owner of the ToyAMM Contract is permitted to add liquidity, and extra rewards for liquidity providers are not included.

To use ToyAMM, please follow the instructions provided in this document.

# About Storing Fungbile Token Metadata
After some considerations, I don't think it is necessary to store FT's metadata, because we can retrieve metadata simply by call `ft_metadata` of the FT contract. I think it is not a good idea to do cross-contract call in init function. And a little bit redundant to call another function to store metadata. Additionally, AMM only cares about its reserves in u128, exchange formula doesn't involve decimals. Decimals, ticker, and symbols are irrelevant information. So to keep the contract clear and simple, I didn't implement functions for getting Fungible Token's metadata on my ToyAMM.

# Prerequisite
## Environment Setup

### Rust
* Version: rustc 1.66.0 (69f9c33d7 2022-12-12)
* Toolchain: wasm32-unknown-unknown
* follow [Near Official Doc](https://docs.near.org/develop/contracts/introduction#rust-and-wasm)

### NodeJS
* install [Node](https://github.com/nvm-sh/nvm) version v16.19.0
* install yarn
```
npm install -g yarn
```
### Deployment Tools
* install [NEAR CLI](https://docs.near.org/tools/near-cli#near-deploy)

### Dependencies
For Ubuntu Users
run the following
```shell
apt install git pkg-config libssl-dev
```
For MacOS Users
```shell
brew install git
```

# Testnet Deployment
## Contract Building
1. clone this project
```shell
git clone https://github.com/lewisgit/toy_amm.git
```
2. build contract
```shell
cd toy_amm/amm
./build.sh
```
compiled contract file will locate in release folder

## Contract Deployment
deploy AMM contract
```shell
near dev-deploy --wasmFile amm/release/toy_amm.wasm --helperUrl https://near-contract-helper.onrender.com
```
Set the AMM acount id `export AMM=dev-1671796804763-30061579106765`. Add create a subaccount as contract owner by running:
```shell
near create-account owner.$AMM --masterAccount $AMM --initialBalance 20
```
Set Owner account id `export OWNER=owner.dev-1671796804763-30061579106765`.
## Fungible Token Deployment
`Make sure every contract you deploy has differenct account id.`
deploy Fungible Token(You can refer to deployment steps in details by directing to [FT](https://github.com/near-examples/FT))
1. use project [FT](https://github.com/near-examples/FT) from [near-example](https://github.com/near-examples). In the root directory of this project, run:
```shell
git clone https://github.com/near-examples/FT.git
```
2. Deploy Fungible Token
```shell
cd FT
near dev-deploy --wasmFile FT/res/fungible_token.wasm --helperUrl https://near-contract-helper.onrender.com
```
3. Deploy Fungible Token Twice and make sure Contracts are deployed to different account. FT0 and FT1 are used here to represent different Fungbile Token Contract.
run `export FT0=dev-1671796926050-32416921021565` and `export FT1=dev-1671797065250-44306645033899` to store the Fungbile Tokens' account id.
4. Initialize FT0 and FT1
run the following commands for FT0 and FT1 respectively.
```shell
near call $FT new '{"owner_id": "'$OWNER'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": $DECIMAL }}' --accountId $FT
```
replace `$DECIMAL` with your preferred one, and use correct `$FT`. Here, `$OWNER` is used as your contract owner account, you can also change it to another account.
Register ToyAMM in FT0 and FT1:
```shell
near call $FT storage_deposit '' --amount 0.00125 --accountId $AMM
```
replace $FT with `$FT0` and `$FT1` respectively.

## AMM Contract Initialization
1. After Fungible Tokens are deployed, initialize ToyAMM Contract by running:
```shell
near call $AMM new '{"owner": "'$OWNER'", "token0": "'$FT0'", "token1": "'$FT1'"}' --accountId $AMM
```

## Add Liquidity
1. Call Contract FT0 and FT1's `tf_transfer_call` to deposit tokens in ToyAMM. Run:
```shell
near call $FT0 ft_transfer_call '{"receiver_id": "'$AMM'", "amount": "30000", "msg": "0"}' --accountId $OWNER --depositYocto "1" --gas "200000000000000"
```
```shell
near call $FT1 ft_transfer_call '{"receiver_id": "'$AMM'", "amount": "70000", "msg": "0"}' --accountId $OWNER --depositYocto "1" --gas "200000000000000"
```
without calling `ft_transfer_call` on both tokens, `add_liquidity` will fail to execute.
2. Call AMM `add_liquidity`:
```shell
near call $AMM add_liquidity '{"token0_account": "'$FT0'","amount0_in": "30000", "token1_account": "'$FT1'", "amount1_in": "70000"}' --accountId $OWNER 
```
after running `add_liquidity`, ToyAMM can be used for token exchange.

## Token Swap
1. create an user Alice:
```shell
near create-account alice.$AMM --masterAccount $AMM --initialBalance 20
```
add save it in env variable `export ALICE=alice.$AMM`.
2. Register Alice for FT0 and FT1:
```shell
near call $FT storage_deposit '' --amount 0.00125 --accountId $ALICE
```
replace $FT with `$FT0` and `$FT1` respectively.
3. Transfer enough FT0 tokens to Alice.
```shell
near call $FT0 ft_transfer '{"receiver_id": "'$ALICE'", "amount": "20", "msg": "0"}' --accountId $OWNER --depositYocto "1" --gas "200000000000000"
```
4. Deposit token FT0 to ToyAMM.
```shell
near call $FT0 ft_transfer_call '{"receiver_id": "'$AMM'", "amount": "20", "msg": "0"}' --accountId $ALICE --depositYocto "1" --gas "200000000000000"
```
5. call ToyAMM `swap_for_token` method:
```shell
near call $AMM swap_for_token '{"token_in": "'$FT0'", "token_out": "'$FT1'", "amount_in": "20"}' --accountId $ALICE 
```
6. Check FT1 balance of Alice
```shell
near view $FT1 ft_balance_of '{"account_id": "'$ALICE'"}'
```
the terminal will print '46', which means by depositing 20\*10^-$DECIMALS_FT0 FT0, Alice exachange 46\*10^-$DECIMALS_FT1 FT1 through ToyAMM.

`All balance are calculated in U128, therefore no need for special treatment of Tokens with arbitrary decimals`.

the example account ids are all deployed on testnet, feel free to explore more about this project as you like.

# Contract Testing
Contract testing covers essential parts of ToyAMM, comprehensive testing is listed in TODO.
## Unit Test
In the root directory of this project, run:
```shell
cd amm
cargo test
```
unit test will test functions of ToyAMM Contract.

## Rust Integration Test
In the root directory of this project, run:
```shell
cd integration-tests/rs
cargo run --example integration-tests
```
## TS Integration Test
In the root directory of this project, run:
```shell
cd integration-tests/ts
yarn install
yarn test
```
running TS Integration Test using node v18.12.0 will fail. (ref:https://github.com/near/workspaces-js/issues/168)
integration tests will test cross contract call and add_liquidity funtion and swap_for_token function.

# TODO
1. Comprehensive Contract Testing
2. Storage Management
3. Liquidity provider shares
4. AMM factory for convenient AMM contruction

# FAQ
1. near-workspaces-js failure

    check your node version, make sure not version=v16.19.0, version >= v18 will cause bugs in near-workspaces.

2. run `NEAR CLI` timeout
  
    better do deployment on a server that locates in US.

# References
1. Uniswap V2: https://github.com/Uniswap/v2-core
2. Near FT Tutorial: https://github.com/near-examples/ft-tutorial
3. Ref Finance: https://github.com/ref-finance
4. Fungible Token on NEAR: https://docs.near.org/develop/relevant-contracts/ft
  
# LICENSE
[LICENSE](LICENSE)

'''
'''--- amm/Cargo.toml ---
[package]
name = "toy_amm"
version = "0.1.0"
author = "sudolewis@gmail.com"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type=["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1.1"
near-contract-standards = "4.1.1"
uint = { version = "0.9.5", default-features = false }

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "s"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- amm/build.sh ---
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/toy_amm.wasm release 
'''
'''--- amm/src/constants.rs ---

use near_sdk::Gas;

pub const TGAS: Gas = Gas(1_000_000_000_000);
'''
'''--- amm/src/ft_core.rs ---

use near_sdk::{AccountId, ext_contract, PromiseOrValue};
use near_sdk::json_types::{U128};

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    fn ft_total_supply(&self) -> U128;

    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}
'''
'''--- amm/src/internal.rs ---
use near_sdk::{log, Gas, AccountId, Balance};
use near_sdk::collections::{LookupMap};

use crate::ToyAMM;
use crate::ft_core::*;
use crate::constants::*;

impl ToyAMM {

  #[inline]
  pub(crate) fn assert_liquidity(&self) {
    let (reserve0, reserve1) = self.get_reserves();
    assert!(reserve0.0 > 0 && reserve1.0 > 0, "ToyAMM: INSUFFICIENT_LIQUIDITY");
  }

  #[inline]
  pub(crate) fn assert_owner(&self, user: &AccountId) {
    assert!(user == &self.owner, "ToyAMM: ONLY_OWNER_ALLOWED");
  }

  #[inline]
  pub(crate) fn get_deposit(&mut self, token_id: &AccountId) -> &mut LookupMap<AccountId, Balance>{
    if token_id == &self.token0 {
      &mut self.deposit0
    } else if token_id == &self.token1 {
      &mut self.deposit1
    } else {
      panic!("ToyAMM: INVALID_TOKEN_ID");
    }
  }

  #[inline]
  pub(crate) fn remove_deposit(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
    let deposit = self.get_deposit(&token);
    let balance = deposit.get(account_id).unwrap_or(0);
    assert!(balance >= amount, "ToyAMM: INSUFFICIENT_DEPOSIT");
    deposit.insert(&account_id, &(balance - amount));
  }

  pub(crate) fn update(&mut self, token0: &AccountId, token1: &AccountId, reserve0: &u128, reserve1: &u128) {
    self.reserves.insert(token0, reserve0);
    self.reserves.insert(token1, reserve1);
  }

  pub(crate) fn deposit_token(&mut self, sender_id: &AccountId, token_id: &AccountId, amount: u128) {
    let deposit = self.get_deposit(token_id);
    let balance = deposit.get(sender_id).unwrap_or(0);
    deposit.insert(&sender_id, &(balance+amount));
  }

  pub(crate) fn withdraw_token(&mut self, to: &AccountId, token_id: &AccountId, amount: u128) {
    let deposit = self.get_deposit(token_id);
    let balance = deposit.get(to).unwrap_or(0);
    assert!(balance >= amount, "ToyAMM: INSUFFICIENT_DEPOSIT");
    deposit.insert(token_id, &(balance-amount));

    log!("withdraw to: {}, token: {}, amount: {}", to, token_id, amount);

    ext_ft_core::ext(token_id.clone())
      .with_attached_deposit(1)
      .with_static_gas(Gas(5*TGAS.0))
      .ft_transfer(to.clone(), amount.into(), None);

  }

}
'''
'''--- amm/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap};
use near_sdk::json_types::{U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;

mod ft_core;
mod constants;
mod utils;
mod internal;

use crate::utils::*;

/**
 * ToyAMM demostrate a simple AMM of 2 tokens
 * In this contract, only the owner of the contract can add liquidity
 * users can swap token for another token
 * users cannot set the minimum amount of token to receive
 */

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ToyAMM{

  // owner of this contract
  pub owner: AccountId,

  // token0 of this AMM
  pub token0: AccountId,

  // token1 of this AMM
  pub token1: AccountId,

  // token reserves of token0 and token1
  pub reserves: LookupMap<AccountId, Balance>,

  // store users' deposit on token0
  pub deposit0: LookupMap<AccountId, Balance>,

  // store users' deposit on token1
  pub deposit1: LookupMap<AccountId, Balance>,

}

#[near_bindgen]
impl ToyAMM {
  
  #[init]
  #[private]
  pub fn new(owner: AccountId, token0: AccountId, token1: AccountId) -> Self {
    assert!(env::is_valid_account_id(owner.as_bytes()), "ToyAMM: OWNER_ACCOUNT_ID_INVALID");
    assert!(!env::state_exists(), "ToyAMM: ALREADY_INITIALIZED");

    let mut reserves = LookupMap::new(b"r".to_vec());
    reserves.insert(&token0, &0u128);
    reserves.insert(&token1, &0u128);

    Self {
      owner,
      token0,
      token1,
      reserves,
      deposit0: LookupMap::new(b"d0".to_vec()),
      deposit1: LookupMap::new(b"d1".to_vec()),
    }
  }

  /**
   * get user deposit on token
   */ 
  pub fn get_user_deposit(&self, token: AccountId, user: AccountId) -> U128{
    if token == self.token0 {
      U128(self.deposit0.get(&user).unwrap_or(0))
    } else if token == self.token1 {
      U128(self.deposit1.get(&user).unwrap_or(0))
    } else {
      panic!("ToyAMM: INVALID_TOKEN_ID");
    }
  }

  pub fn get_reserves(&self) -> (U128, U128) {
    (self.reserves.get(&self.token0).unwrap().into(), self.reserves.get(&self.token1).unwrap().into())
  }
  
  /**
   * only owner can add liquidity for ToyAMM
   * currently there is no reward to liquidity providers
   */
  pub fn add_liquidity(&mut self, token0_account: AccountId, amount0_in: U128, token1_account: AccountId, amount1_in: U128) {
    self.assert_owner(&env::predecessor_account_id());

    self.remove_deposit(&env::predecessor_account_id(), &token0_account, amount0_in.into());
    self.remove_deposit(&env::predecessor_account_id(), &token1_account, amount1_in.into());

    let reserve0_new = self.reserves.get(&token0_account).unwrap_or(0) + amount0_in.0;
    let reserve1_new = self.reserves.get(&token1_account).unwrap_or(0) + amount1_in.0;
    self.reserves.insert(&token0_account, &reserve0_new);
    self.reserves.insert(&token1_account, &reserve1_new);
  }
   
  /**
   * swap for token
   * before swap, user should have enough deposit greater than amount
   */ 
  #[payable]
  pub fn swap_for_token(&mut self, token_in: AccountId, token_out: AccountId, amount_in: U128) -> U128 {
    
    self.assert_liquidity();
    
    let reserve_in = self.reserves.get(&token_in).unwrap();
    let reserve_out = self.reserves.get(&token_out).unwrap();
    
    let amount_out = get_amount_out(amount_in.0, reserve_in, reserve_out);

    let user = env::predecessor_account_id();
    
    self.remove_deposit(&user, &token_in, amount_in.0);
    self.deposit_token(&user, &token_out, amount_out);

    self.withdraw_token(&user, &token_out, amount_out);

    self.update(&token_in, &token_out, &(amount_in.0 + reserve_in), &(reserve_out - amount_out));

    amount_out.into()
  }

}

#[near_bindgen]
impl FungibleTokenReceiver for ToyAMM {

  /**
   * add user transfer tokens to deposit
   */
  #[allow(unused_variables)]
  fn ft_on_transfer(
    &mut self,
    sender_id: AccountId,
    amount: U128,
    msg: String
  ) -> PromiseOrValue<U128> {
    let token_id= env::predecessor_account_id();

    log!("ToyAMM: transfer receiver. token_id: {} sender_id: {} amount: {}",
        token_id, sender_id, amount.0);

    self.deposit_token(&sender_id, &token_id, amount.0);

    PromiseOrValue::Value(U128(0))
  }

}

#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::{testing_env};
  use near_sdk::test_utils::{accounts, VMContextBuilder};

  /// 1 NEAR in yocto = 1e24
  pub const NDENOM: u128 = 1_000_000_000_000_000_000_000_000;

  fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
        .current_account_id(accounts(0))
        .signer_account_id(predecessor_account_id.clone())
        .predecessor_account_id(predecessor_account_id);
    builder
  }

  #[test]
  #[should_panic(expected = "ToyAMM: INSUFFICIENT_DEPOSIT")]
  fn owner_add_liquidity_without_deposit() {
      let token0 = accounts(4);
      let token1 = accounts(5);
      let mut context = get_context(accounts(1));
      testing_env!(context
        .build()
      );
      let mut contract = ToyAMM::new(accounts(1), token0.clone(), token1.clone());
      contract.add_liquidity(
        token0,
        (100 * NDENOM).into(),
        token1,
        (300 * NDENOM).into(),
      );
  }

  #[test]
  fn owner_add_liquidity() {
      let token0 = accounts(4);
      let token1 = accounts(5);
      let user = accounts(2);
      let mut context = get_context(accounts(1));
      testing_env!(context
        .build()
      );
      let mut c= ToyAMM::new(accounts(1), token0.clone(), token1.clone());
      c.deposit_token(&accounts(1), &token0, (100 * NDENOM).into());
      c.deposit_token(&accounts(1), &token1, (300 * NDENOM).into());
      c.add_liquidity(
        token0,
        (100 * NDENOM).into(),
        token1,
        (300 * NDENOM).into(),
      );
      let (reserve0, reserve1) = c.get_reserves();
      assert_eq!(reserve0.0, 100*NDENOM, "reserve0 should be equal to amount0_in");
      assert_eq!(reserve1.0, 300*NDENOM, "reserve1 should be equal to amount1_in");
  }

  #[test]
  #[should_panic(expected = "ToyAMM: INSUFFICIENT_LIQUIDITY")]
  fn swap_for_token_no_liquidity() {
      let token0 = accounts(4);
      let token1 = accounts(5);
      let user = accounts(2);
      let mut context = get_context(accounts(1));
      testing_env!(context
        .build()
      );
      let mut c= ToyAMM::new(accounts(1), token0.clone(), token1.clone());
      testing_env!(context
        .predecessor_account_id(user.clone())
        .build()
      );
      let amount_in = 1*NDENOM;
      let (reserve0, reserve1) = c.get_reserves();
      println!("reserve0: {}, reserve1: {}", reserve0.0, reserve1.0);
      c.deposit_token(&user, &token0, amount_in.into());
      let amount_out = c.swap_for_token(token0, token1, amount_in.into());
  }

  #[test]
  fn swap_for_token() {
      let token0 = accounts(4);
      let token1 = accounts(5);
      let user = accounts(2);
      let owner = accounts(1);
      let mut context = get_context(owner.clone());
      testing_env!(context
        .build()
      );
      let mut c= ToyAMM::new(owner.clone(), token0.clone(), token1.clone());
      testing_env!(context
        .predecessor_account_id(owner.clone())
        .build()
      );

      let add_amount0 = (100*NDENOM);
      let add_amount1 = (300*NDENOM);

      c.deposit_token(&owner, &token0, add_amount0.into());
      c.deposit_token(&owner, &token1, add_amount1.into());
      
      c.add_liquidity(token0.clone(), add_amount0.into(), token1.clone(), add_amount1.into());

      testing_env!(context
        .predecessor_account_id(user.clone())
        .build()
      );

      let amount_in = 1*NDENOM;
      let (reserve0, reserve1) = c.get_reserves();
      println!("reserve0: {}, reserve1: {}", reserve0.0, reserve1.0);
      c.deposit_token(&user, &token0, amount_in.into());
      let amount_out = c.swap_for_token(token0, token1, amount_in.into());
      let (new_reserve0, new_reserve1) = c.get_reserves();
      assert!(amount_out.0 + new_reserve1.0 == reserve1.0, "reserve1 does not match");
      assert!(new_reserve0.0 - amount_in == reserve0.0, "reserve0 does not match");
  }
}

'''
'''--- amm/src/utils.rs ---
use uint::construct_uint;

construct_uint! {
  /// 256-bit unsigned integer.
  pub struct u256(4);
}

/*
 * formula for calculating amount out with 0.3% fee;
 * Yout = Y x Xi x 997 / (X * 1000 + Xi * 997)
 */
pub fn get_amount_out(amount_in: u128, reserve_in: u128, reserve_out: u128) -> u128 {
    let amount_in_with_fee = u256::from(amount_in) * u256::from(997);
    let numerator = amount_in_with_fee * u256::from(reserve_out);
    let denominator = u256::from(reserve_in) * u256::from(1000) + amount_in_with_fee;
    let amount_out = numerator / denominator;
    amount_out.as_u128()
}

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "amm-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.7.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"
'''
'''--- integration-tests/rs/src/tests.rs ---
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const AMM_WASM_FILEPATH: &str = "../../amm/release/toy_amm.wasm";
const FT_WASM_FILEPATH: &str = "../../FT/res/fungible_token.wasm"; 

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    println!("reading {}", AMM_WASM_FILEPATH);
    let amm_wasm = std::fs::read(AMM_WASM_FILEPATH)?;
    println!("reading {}", FT_WASM_FILEPATH);
    let ft_wasm = std::fs::read(FT_WASM_FILEPATH)?;
    let amm_contract = worker.dev_deploy(&amm_wasm).await?;
    let ft0_contract = worker.dev_deploy(&ft_wasm).await?;
    let ft1_contract = worker.dev_deploy(&ft_wasm).await?;

    // create accounts
    let owner = worker.root_account()?;
    println!("owner: {}", owner.id());
    println!("ft0_contract: {}", ft0_contract.id());
    println!("ft1_contract: {}", ft1_contract.id());
    let alice = owner
        .create_subaccount("alice")
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    // initialize ft0
    ft0_contract
        .call("new")
        .args_json(serde_json::json!({
            "owner_id": owner.id(),
            "total_supply": parse_near!("100000000 N").to_string(),
            "metadata": {
                "spec": "ft-1.0.0",
                "name": "Fungible Token 0",
                "symbol": "FT0",
                "decimals": 24
            }
        }))
        .transact()
        .await?
        .into_result()?;

    // initialize ft1
    ft1_contract
        .call("new")
        .args_json(serde_json::json!({
            "owner_id": owner.id(),
            "total_supply": parse_near!("100000000 N").to_string(),
            "metadata": {
                "spec": "ft-1.0.0",
                "name": "Fungible Token 1",
                "symbol": "FT1",
                "decimals": 20
            }
        }))
        .transact()
        .await?
        .into_result()?;

    // initialize amm contract
    amm_contract
        .call("new")
        .args_json(serde_json::json!({
            "owner": owner.id(),
            "token0": ft0_contract.id(),
            "token1": ft1_contract.id(),
        }))
        .transact()
        .await?
        .into_result()?;
    
    // register ft accounts for AMM contract
    println!("owner call ft0: storage_deposit to amm");
    owner 
        .call(ft0_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
               "account_id": amm_contract.id(),
        }))
        .deposit(parse_near!("0.00125 N"))
        .transact()
        .await?
        .into_result()?;

    println!("owner call ft1: storage_deposit to amm");
    owner 
        .call(ft1_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
               "account_id": amm_contract.id(),
        }))
        .deposit(parse_near!("0.00125 N"))
        .transact()
        .await?
        .into_result()?;

    println!("alice call ft0: storage_deposit");
    alice 
        .call(ft0_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
               "account_id": alice.id(),
        }))
        .deposit(parse_near!("0.00125 N"))
        .transact()
        .await?
        .into_result()?;

    println!("alice call ft1: storage_deposit");
    alice 
        .call(ft1_contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
            "account_id": alice.id(),
        }))
        .deposit(parse_near!("0.00125 N"))
        .transact()
        .await?
        .into_result()?;
    
    // prepare some funds for later test
    println!("owner call ft0: ft_transfer to alice");
    owner
        .call(ft0_contract.id(), "ft_transfer")
        .args_json(serde_json::json!({
            "receiver_id": alice.id(),
            "amount": parse_near!("10 N").to_string(),
        }))
        .deposit(1)
        .transact()
        .await?
        .into_result()?;

    println!("owner call ft1: ft_transfer to alice");
    owner
        .call(ft1_contract.id(), "ft_transfer")
        .args_json(serde_json::json!({
            "receiver_id": alice.id(),
            "amount": parse_near!("10 N").to_string(),
        }))
        .deposit(1)
        .transact()
        .await?
        .into_result()?;
    
    let balance: String = worker
    .view(ft1_contract.id(), "ft_balance_of")
    .args_json(serde_json::json!({
        "account_id": alice.id(),
    }))
    .await?.json()?;

    println!("FT1 Balance of alice: {}", balance);

    
    let result =
    owner
        .call(ft0_contract.id(), "ft_transfer_call")
        .args_json(serde_json::json!({
            "receiver_id": amm_contract.id(),
            "amount": parse_near!("300 N").to_string(),
            "msg": "0",
        }))
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("owner transfer ft0: {:?}", result.logs());

    owner
        .call(ft1_contract.id(), "ft_transfer_call")
        .args_json(serde_json::json!({
            "receiver_id": amm_contract.id(),
            "amount": parse_near!("700 N").to_string(),
            "msg": "0",
        }))
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?
        .into_result()?;

    let deposit0: String = worker
    .view(amm_contract.id(), "get_user_deposit")
    .args_json(serde_json::json!({
        "token": ft0_contract.id(),
        "user": owner.id(),
    }))
    .await?.json()?;

    println!("Deposit0 of owner: {}", deposit0);
    
    println!("add liquidity");
    owner
        .call(amm_contract.id(), "add_liquidity")
        .args_json(serde_json::json!({
            "token0_account": ft0_contract.id(),
            "amount0_in": parse_near!("300 N").to_string(),
            "token1_account": ft1_contract.id(),
            "amount1_in": parse_near!("700 N").to_string(),
        }))
        .transact()
        .await?
        .into_result()?;

    println!("alice call ft0: ft_transfer_call to amm");
    alice 
        .call(ft0_contract.id(), "ft_transfer_call")
        .args_json(serde_json::json!({
            "receiver_id": amm_contract.id(),
            "amount": parse_near!("2 N").to_string(),
            "msg": "0",
        }))
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?
        .into_result()?;

    println!("alice call amm: swap_for_token ");

    let swap_result = alice 
        .call(amm_contract.id(), "swap_for_token")
        .args_json(serde_json::json!({
            "token_in": ft0_contract.id(),
            "token_out": ft1_contract.id(),
            "amount_in": parse_near!("2 N").to_string(),
        }))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("swap result: {:?}", swap_result.logs());
        
    let balance_after: String = worker
    .view(ft1_contract.id(), "ft_balance_of")
    .args_json(serde_json::json!({
        "account_id": alice.id(),
    }))
    .await?.json()?;
    println!("After token swap");
    println!("FT1 Balance of alice: {}", balance_after);

    Ok(())

}

'''
'''--- integration-tests/ts/ava.config.js ---
require('util').inspect.defaultOptions.depth = 5; // Increase AVA's printing depth

module.exports = {
  timeout: '300000',
  files: ['**/*.ava.ts', '**/*.ava.js'],
  failWithoutAssertions: false,
  extensions: [
    'ts',
    'js',
  ],
  require: [
    'ts-node/register',
  ],
};
'''
'''--- integration-tests/ts/package.json ---
{
  "name": "amm-integration-tests",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/node": "^18.6.2",
    "ava": "^4.2.0",
    "near-workspaces": "^3.2.1",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "dependencies": {}
}
'''
'''--- integration-tests/ts/src/main.ava.ts ---
import { Worker, NearAccount, NEAR, BN } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';

const STORAGE_BYTE_COST = '1.5 mN';
const INITIAL_SUPPLY = "1000000000 N";

const AMM_WASM_FILEPATH = "../../amm/release/toy_amm.wasm";
const FT_WASM_FILEPATH = "../../FT/res/fungible_token.wasm";

async function registerUser(ft: NearAccount, user: NearAccount) {
  await user.call(
      ft,
      'storage_deposit',
      { account_id: user },
      // Deposit pulled from ported sim test
      { attachedDeposit: STORAGE_BYTE_COST },
  );
}

async function ft_balance_of(ft: NearAccount, user: NearAccount): Promise<BN> {
  return new BN(await ft.view('ft_balance_of', { account_id: user }));
}

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.before(async t => {
  const worker = await Worker.init();
  const root = worker.rootAccount;

  console.log("deploying FT0");
  const ft0 = await root.devDeploy(FT_WASM_FILEPATH, {
      initialBalance: NEAR.parse('100 N').toJSON(),
      method: "new",
      args: {
          owner_id: root,
          total_supply: NEAR.parse(INITIAL_SUPPLY).toJSON(),
          metadata: {
                spec: "ft-1.0.0",
                name: "Fungible Token 0",
                symbol: "FT0",
                decimals: 24
            }
      }
  });
  console.log("deploying FT1");
  const ft1 = await root.devDeploy(FT_WASM_FILEPATH, {
      initialBalance: NEAR.parse('100 N').toJSON(),
      method: "new",
      args: {
          owner_id: root,
          total_supply: NEAR.parse(INITIAL_SUPPLY).toJSON(),
          metadata: {
                spec: "ft-1.0.0",
                name: "Fungible Token 1",
                symbol: "FT1",
                decimals: 20
            }
      }
  });

  console.log("FT0 and FT1 Deployed.");

  console.log("deploying AMM");
  const amm = await root.devDeploy(AMM_WASM_FILEPATH, {
      initialBalance: NEAR.parse('100 N').toJSON(),
  })
  await amm.call(
    amm,
    'new',
    {
      owner: root,
      token0: ft0,
      token1: ft1,
    }
  );
  console.log("AMM Deployed");

  console.log("creating Alice");
  const alice = await root.createSubAccount('ali', {
    initialBalance: NEAR.parse('100 N').toJSON(),
  });

  console.log("registering alice and amm on ft0 ft1");
  await registerUser(ft0, amm);
  await registerUser(ft1, amm);
  await registerUser(ft0, alice);
  await registerUser(ft1, alice);

  console.log("root transfer ft0 to alice");
  await root.call(
    ft0,
    'ft_transfer',
    {
      receiver_id: alice,
      amount: NEAR.parse('1000 N').toJSON(),
    },
    {attachedDeposit: '1'}
    )

  console.log("root transfer ft1 to alice");
  await root.call(
    ft1,
    'ft_transfer',
    {
      receiver_id: alice,
      amount: NEAR.parse('1000 N').toJSON(),
    },
    {attachedDeposit: '1'}
    )
  
  console.log("getting balance of alice");
  let balance_ft0 = await ft_balance_of(ft0, alice);
  let balance_ft1 = await ft_balance_of(ft1, alice);

  console.log("alice ft0 balance: ", balance_ft0.toString());
  console.log("alice ft1 balance: ", balance_ft1.toString());

  t.context.worker = worker;
  t.context.accounts = {root, ft0, ft1, amm, alice};
  
})

test.serial.before(async t => {
    await t.context.accounts.root.call(
      t.context.accounts.ft0,
      'ft_transfer_call',
      {
        receiver_id: t.context.accounts.amm,
        amount: NEAR.parse('300 N').toJSON(),
        msg: "0",
      },
      {
        attachedDeposit: '1',
        gas: '200 Tgas',
      },
    );
    await t.context.accounts.root.call(
      t.context.accounts.ft1,
      'ft_transfer_call',
      {
        receiver_id: t.context.accounts.amm,
        amount: NEAR.parse('700 N').toJSON(),
        msg: "0",
      },
      {
        attachedDeposit: '1',
        gas: '200 Tgas',
      },
    );
    await t.context.accounts.root.call(
      t.context.accounts.amm,
      'add_liquidity',
      {
        token0_account: t.context.accounts.ft0,
        amount0_in: NEAR.parse("300 N").toJSON(),
        token1_account: t.context.accounts.ft1,
        amount1_in: NEAR.parse("700 N").toJSON(),
      },
      {
        gas: '200 Tgas',
      },
    );

    let reserves = await t.context.accounts.amm.view(
      'get_reserves',
    );

    console.log("reserves: ", reserves);
})

test('Swap Token', async t => {
    await t.context.accounts.alice.call(
      t.context.accounts.ft0,
      'ft_transfer_call',
      {
        receiver_id: t.context.accounts.amm,
        amount: NEAR.parse('2 N').toJSON(),
        msg: "0",
      },
      {
        attachedDeposit: '1',
        gas: '200 Tgas',
      },
    );

    await t.context.accounts.alice.call(
      t.context.accounts.amm,
      'swap_for_token',
      {
        token_in: t.context.accounts.ft0,
        token_out: t.context.accounts.ft1,
        amount_in: NEAR.parse("2 N").toJSON(),
      },
      {
        gas: '200 Tgas',
      },
    );

    let balance = await ft_balance_of(t.context.accounts.ft1, t.context.accounts.alice);

    console.log("ft1 balance of alice: ", balance.toString());
})

test.after(async t => {
  await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
  });
});
'''