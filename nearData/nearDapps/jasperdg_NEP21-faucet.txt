*GitHub Repository "jasperdg/NEP21-faucet"*

'''--- Cargo.toml ---
[package]
name = "nep21-faucet"
version = "0.1.0"
authors = ["jasperdg <jasperdegooijer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

[dev-dependencies]
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }
lazy_static = "1.4.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- scripts/build.sh ---
RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/nep21_faucet.wasm ./res/

'''
'''--- scripts/deploy.sh ---
near deploy --wasmFile res/nep21_faucet.wasm --accountId $1 --masterAccount $2
'''
'''--- scripts/test.sh ---
bash ./scripts/build.sh 
cargo +nightly test -p nep21-faucet -- --nocapture
'''
'''--- src/lib.rs ---
use near_sdk::json_types::{
    U128, 
};
use near_sdk::borsh::{
    self, 
    BorshDeserialize, 
    BorshSerialize
};
use near_sdk::{
    ext_contract,
    env,
    near_bindgen,
    Promise,
    init,
    AccountId
};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

const CLAIM_AMOUNT: u128 = 1_000_000_000_000_000_000_000_000;
const TRANSFER_GAS: u64 = 100_000_000_000_000;

#[ext_contract]
trait FaucetToken {
    fn transfer(&mut self, new_owner_id: String, amount: U128);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
struct Nep21Faucet {
    pub token_account_id: AccountId
}

impl Default for Nep21Faucet {
    fn default() -> Self{
        panic!("Contract needs to be initialized before usage")
    }
}

#[near_bindgen]
impl Nep21Faucet {
    #[init]
    pub fn init(token_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initted");
        Self {
            token_account_id
        }
    }

    /* TODO: Add some minimal sybil resistence where accounts can only claim every 30 minutes */
    pub fn claim(&self) -> Promise {
        return faucet_token::transfer(
            env::predecessor_account_id(), 
            U128(CLAIM_AMOUNT), 
            &self.token_account_id, 
            0, 
            TRANSFER_GAS
        );
    }

    pub fn get_token_account_id(&self) -> &AccountId {
        return &self.token_account_id;
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
	use super::*;
	mod test_utils;
	use test_utils::{ExternalUser, init_markets_contract, ntoy, token_account_id, faucet_account_id};
    use near_sdk::MockedBlockchain;
    use near_sdk::{VMContext, testing_env};
	use near_runtime_standalone::{RuntimeStandalone};
    use near_primitives::transaction::{ExecutionStatus, ExecutionOutcome};

    fn init_runtime_env() -> (RuntimeStandalone, ExternalUser, Vec<ExternalUser>) {
		let (mut runtime, root) = init_markets_contract();

		let mut accounts: Vec<ExternalUser> = vec![];
		for acc_no in 0..2 {
			let acc = if let Ok(acc) =
				root.create_external(&mut runtime, format!("account_{}", acc_no), ntoy(100))
			{
				acc
			} else {
				break;
			};
			accounts.push(acc);
		}

		return (runtime, root, accounts);
    }
    
    #[test]
    fn test_mockchain() {
        let (runtime, root, accounts) = init_runtime_env();
        assert_eq!(root.get_account_id(), "flux-dev".to_string());
    }
    
    #[test]
    fn test_deposit_and_claim() {
        let (mut runtime, root, accounts) = init_runtime_env();
        root.transfer(&mut runtime, faucet_account_id(), U128(CLAIM_AMOUNT * 5));
        let faucet_contract_balance = root.get_balance(&mut runtime, faucet_account_id());
        assert_eq!(faucet_contract_balance, U128(CLAIM_AMOUNT * 5));
        
        accounts[0].claim(&mut runtime);
        
        let faucet_contract_balance = root.get_balance(&mut runtime, faucet_account_id());
        assert_eq!(faucet_contract_balance, U128(CLAIM_AMOUNT * 4));
        let claimer_balance = root.get_balance(&mut runtime, accounts[0].get_account_id());
        assert_eq!(claimer_balance, U128(CLAIM_AMOUNT));        
    }
}
'''
'''--- src/tests/test_utils.rs ---
use super::*;
use near_sdk::MockedBlockchain;
use near_sdk::{VMContext, testing_env};
use near_crypto::{InMemorySigner, KeyType, Signer};
use near_runtime_standalone::{init_runtime_and_signer, RuntimeStandalone};
use near_primitives::{
    account::{AccessKey},
    errors::{RuntimeError, TxExecutionError},
    hash::CryptoHash,
    transaction::{ExecutionOutcome, ExecutionStatus, Transaction},
    types::{AccountId, Balance},
};
use std::collections::{HashMap};

use near_sdk::serde_json;
use near_sdk::serde_json::json;
use near_sdk::json_types::{U128, U64};

const GAS_STANDARD: u64 = 300000000000000;

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

pub fn faucet_account_id() -> String {
	return "fun_token_faucet".to_string();
}

pub fn token_account_id() -> String {
	return "token_account_id".to_string();
}

type TxResult = Result<ExecutionOutcome, ExecutionOutcome>;

lazy_static::lazy_static! {
    static ref FAUCET_BYTES: &'static [u8] = include_bytes!("../../res/nep21_faucet.wasm").as_ref();
    static ref FUNGIBLE_TOKEN_BYTES: &'static [u8] = include_bytes!("../../res/fungible_token.wasm").as_ref();
}

fn outcome_into_result(outcome: ExecutionOutcome) -> TxResult {
    match outcome.status {
        ExecutionStatus::SuccessValue(_) => Ok(outcome),
        ExecutionStatus::Failure(_) => Err(outcome),
        ExecutionStatus::SuccessReceiptId(_) => panic!("Unresolved ExecutionOutcome run runtime.resolve(tx) to resolve the final outcome of tx"),
        ExecutionStatus::Unknown => unreachable!()
    }
}

pub struct ExternalUser {
    account_id: AccountId,
    signer: InMemorySigner,
}

impl ExternalUser {
	pub fn new(account_id: AccountId, signer: InMemorySigner) -> Self {
        Self { account_id, signer }
    }

    pub fn get_account_id(&self) -> AccountId {
        return self.account_id.to_string();
    }

    pub fn deploy_faucet(&self, runtime: &mut RuntimeStandalone) -> TxResult {
        let args = json!({
            "token_account_id": token_account_id(),
        }).to_string().as_bytes().to_vec();

        let tx = self
        .new_tx(runtime, faucet_account_id())
        .create_account()
        .transfer(99994508400000000000000000)
        .deploy_contract(FAUCET_BYTES.to_vec())
        .function_call("init".into(), args, GAS_STANDARD, 0)
        .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        let ans = outcome_into_result(res);
        return ans;
    }

    pub fn deploy_token(&self, runtime: &mut RuntimeStandalone, owner_account_id: String, total_supply: U128) -> TxResult {
        // let args = json!({}).to_string().as_bytes().to_vec();
        let args = json!({
            "owner_id": owner_account_id,
            "total_supply": total_supply
        }).to_string().as_bytes().to_vec();

        let tx = self
        .new_tx(runtime, token_account_id())
        .create_account()
        .transfer(99994508400000000000000000)
        .deploy_contract(FUNGIBLE_TOKEN_BYTES.to_vec())
        .function_call("new".into(), args, GAS_STANDARD, 0)
        .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        let ans = outcome_into_result(res);
        return ans;
    }

    fn new_tx(&self, runtime: &RuntimeStandalone, receiver_id: AccountId) -> Transaction {
        let nonce = runtime
        .view_access_key(&self.account_id, &self.signer.public_key())
        .unwrap()
        .nonce
        + 1;
        Transaction::new(
            self.account_id.clone(),
            self.signer.public_key(),
            receiver_id,
            nonce,
            CryptoHash::default(),
        )
    }

	pub fn create_external(
        &self,
        runtime: &mut RuntimeStandalone,
        new_account_id: AccountId,
        amount: Balance,
    ) -> Result<ExternalUser, ExecutionOutcome> {
        let new_signer = InMemorySigner::from_seed(&new_account_id, KeyType::ED25519, &new_account_id);
        let tx = self
        .new_tx(runtime, new_account_id.clone())
        .create_account()
        .add_key(new_signer.public_key(), AccessKey::full_access())
        .transfer(amount)
        .sign(&self.signer);

        let res = runtime.resolve_tx(tx);

        // TODO: this temporary hack, must be rewritten
        if let Err(err) = res.clone() {
            if let RuntimeError::InvalidTxError(tx_err) = err {
                let mut out = ExecutionOutcome::default();
                out.status = ExecutionStatus::Failure(TxExecutionError::InvalidTxError(tx_err));
                return Err(out);
            } else {
                unreachable!();
            }
        } else {
            outcome_into_result(res.unwrap())?;
            runtime.process_all().unwrap();
            Ok(ExternalUser {
                account_id: new_account_id,
                signer: new_signer,
            })
        }
	}

	pub fn claim(
        &self,
        runtime: &mut RuntimeStandalone,
    ) -> TxResult {
        let args = json!({})
        .to_string()
        .as_bytes()
        .to_vec();
        let tx = self
        .new_tx(runtime, faucet_account_id())
        .function_call("claim".into(), args, GAS_STANDARD, 0)
        .sign(&self.signer);
        let res = runtime.resolve_tx(tx).expect("resolving tx failed");
        runtime.process_all().expect("processing tx failed");
        let ans = outcome_into_result(res);
        return ans;
    }

    pub fn transfer(
        &self,
        runtime: &mut RuntimeStandalone,
        new_owner_id: AccountId,
        amount: U128
    ) -> TxResult {
        let args = json!({
            "new_owner_id": new_owner_id,
            "amount": amount,
        })
        .to_string()
        .as_bytes()
        .to_vec();
        let tx = self
        .new_tx(runtime, token_account_id())
        .function_call("transfer".into(), args, GAS_STANDARD, 0)
        .sign(&self.signer);
        let res = runtime.resolve_tx(tx).expect("resolving tx failed");
        runtime.process_all().expect("processing tx failed");
        let ans = outcome_into_result(res);
        return ans;
    }

    pub fn get_token_account_id(
        &self,
        runtime: &mut RuntimeStandalone
    ) -> U128 {
        let market_price_json = runtime
        .view_method_call(
            &(faucet_account_id()),
            "get_token_account_id",
            json!({})
            .to_string()
            .as_bytes(),
        )
        .unwrap()
        .0;

        let data: serde_json::Value = serde_json::from_slice(market_price_json.as_slice()).unwrap();
        let res = serde_json::from_value(serde_json::to_value(data).unwrap()).unwrap();

        return res;
    }
    
    pub fn get_balance(
        &self,
        runtime: &mut RuntimeStandalone,
        account_id: String,
    ) -> U128 {
        let market_price_json = runtime
        .view_method_call(
            &(token_account_id()),
            "get_balance",
            json!({
                "owner_id": account_id
            })
            .to_string()
            .as_bytes(),
        )
        .unwrap()
        .0;

        let data: serde_json::Value = serde_json::from_slice(market_price_json.as_slice()).unwrap();
        let res = serde_json::from_value(serde_json::to_value(data).unwrap()).unwrap();

        return res;
    }
}

pub fn init_markets_contract() -> (RuntimeStandalone, ExternalUser) {
    let (mut runtime, signer) = init_runtime_and_signer(&"flux-dev".into());
    let root = ExternalUser::new("flux-dev".into(), signer);

    root.deploy_faucet(&mut runtime).unwrap();
    root.deploy_token(&mut runtime, "flux-dev".to_string(), U128(100000000000000000000000000000000)).unwrap();
    
    return (runtime, root);
}
'''