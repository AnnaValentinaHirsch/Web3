*GitHub Repository "neariotfoundation/neariot_contract"*

'''--- .github/dependabot.yml ---
version: 2
updates:
- package-ecosystem: cargo
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10

'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: 
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Install modules
        run: yarn
      - name: Run unit tests
        run: yarn test:unit
      - name: Run integration tests
        run: yarn test:integration

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for all branches in this repo (defaults to false)
    branches: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli && nvm use default
    init: yarn && yarn dev
    command: source ~/.bashrc; gp open README-Gitpod.md && yarn dev

vscode:
  extensions:
    - hbenl.vscode-test-explorer@2.15.0:koqDUMWDPJzELp/hdS/lWw==
    - Swellaby.vscode-rust-test-adapter@0.11.0:Xg+YeZZQiVpVUsIkH+uiiw==
    - bungcip.better-toml@0.3.2:3QfgGxxYtGHfJKQU7H0nEw==

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12.0
os:
  - linux
  - osx
  - windows
before_install:
  - curl https://sh.rustup.rs -sSf -m 60 | sh -s -- -y -v --default-toolchain stable
  - if [[ "$TRAVIS_OS_NAME" == "windows" ]]; then HOME="/c/Users/travis"; fi
  - export PATH="$HOME/.cargo/bin:$PATH"
  - rustup target add wasm32-unknown-unknown
script:
  - npm run build
  - cargo test --package status-message -- --nocapture
'''
'''--- Cargo.toml ---
[package]
name = "neariot_contract"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
bs58 = "0.4.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README-Gitpod.md ---
Status Message in Rust - Gitpod version
=======================================

This smart contract saves and records the status messages of NEAR accounts that call it.

**Note**: this README is specific to Gitpod and this example. For local development, please see [README.md](README.md).

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

In the project root, login with `near-cli` by following the instructions after this command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

If all is successful the app should be live at `localhost:1234`!

### CLI

In Gitpod, a process has automatically created a new NEAR account that's useful for a quick (and likely temporary) usage.
We've set an environment variable in Gitpod with the account name. At the bottom of this screen there's a Terminal.

You may see the NEAR account by running this command:
```bash
echo $CONTRACT_NAME
```

The next command will call the contract's `set_status` method:

```bash
near call $CONTRACT_NAME set_status '{"message": "aloha!"}' --accountId $CONTRACT_NAME
```

To retrieve the message from the contract, call `get_status` with the following:

```bash
near view $CONTRACT_NAME get_status '{"account_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```

Note that these status messages are stored per account in a `HashMap`. See `src/lib.rs` for the code. We can try the same steps with another account to verify.
**Note**: we're adding `NEW_ACCOUNT_NAME` for the next couple steps.

There are two ways to create a new account:
 - the NEAR Wallet (as we did before)
 - `near create_account NEW_ACCOUNT_NAME --masterAccount $CONTRACT_NAME`

Now call the contract on the first account (where it's deployed):

```bash
near call $CONTRACT_NAME set_status '{"message": "bonjour"}' --accountId NEW_ACCOUNT_NAME
```

```bash
near view $CONTRACT_NAME get_status '{"account_id": "NEW_ACCOUNT_NAME"}'
```

Returns `bonjour`.

Make sure the original status remains:

```bash
near view $CONTRACT_NAME get_status '{"account_id": "$CONTRACT_NAME"}'
```

Now that you've seen this working in Gitpod, feel free to clone this repository and use it as a starting point for your own project.

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

## Data collection
By using Gitpod in this project, you agree to opt-in to basic, anonymous analytics. No personal information is transmitted. Instead, these usage statistics aid in discovering potential bugs and user flow information.

'''
'''--- README-Windows.md ---
Status Message
==============

This smart contract saves and records the status messages of NEAR accounts that call it.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

## Prerequisites
Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

Ensure `Rust` is installed by running:

```
rustc --version
```

If needed, install `Rust`:

```
curl https://sh.rustup.rs -sSf | sh
```

Install dependencies

```
npm install
```

## Building this contract
To make the build process compatible with multiple operating systems, the build process exists as a script in `package.json`.
There are a number of special flags used to compile the smart contract into the wasm file.
Run this command to build and place the wasm file in the `res` directory:
```bash
npm run build
```

**Note**: Instead of `npm`, users of [yarn](https://yarnpkg.com) may run:
```bash
yarn build
```

### Important
If you encounter an error similar to:
>note: the `wasm32-unknown-unknown` target may not be installed

Then run:

```bash
rustup target add wasm32-unknown-unknown
```

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

If all is successful the app should be live at `localhost:1234`!

### Quickest deploy
Build and deploy this smart contract to an development account. This development account will be created automatically and is not intended to be permanent. Please see the "Standard deploy" section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/status_message.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing the key to the account, located at `neardev/dev-account.env`. To make the next few steps easier, we're going to set an environment variable containing this development account id and use that when copy/pasting commands.

If the account name is not immediately visible on the Command Prompt, you may find it by running:

```bash
type neardev\dev-account.env
```

It will display something similar to `CONTRACT_NAME=dev-12345678901234`.
Please set the Windows environment variable by copying that value and running `set` like so:

```bash
set CONTRACT_NAME=dev-12345678901234
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo %CONTRACT_NAME%
```

The next command will call the contract's `set_status` method:

```bash
near call %CONTRACT_NAME% set_status "{\"message\": \"aloha!\"}" --accountId %CONTRACT_NAME%
```

**Note**: at the time of this writing, Windows does not handle single quotes `'` well, so these commands must use escaped double-quotes `\"` which, as you may know, equates to a regular double quote `"` when parsed. Apologies for some of the unsightly commands, but it's out of necessity.

To retrieve the message from the contract, call `get_status` with the following:

```bash
near view %CONTRACT_NAME% get_status "{\"account_id\": \""%CONTRACT_NAME%"\"}" --accountId %CONTRACT_NAME%
```

### Standard deploy
In this option, the smart contract will get deployed to a specific account created with the NEAR Wallet.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Set a status for your account:

```bash
near call YOUR_ACCOUNT_NAME set_status "{\"message\": \"aloha friend\"}" --accountId YOUR_ACCOUNT_NAME
```

Get the status:

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"YOUR_ACCOUNT_NAME\"}"
```

Note that these status messages are stored per account in a `HashMap`. See `src/lib.rs` for the code. We can try the same steps with another account to verify.
**Note**: we're adding `NEW_ACCOUNT_NAME` for the next couple steps.

There are two ways to create a new account:
 - the NEAR Wallet (as we did before)
 - `near create_account NEW_ACCOUNT_NAME --masterAccount YOUR_ACCOUNT_NAME`

Now call the contract on the first account (where it's deployed):

```bash
near call YOUR_ACCOUNT_NAME set_status "{\"message\": \"bonjour\"}" --accountId NEW_ACCOUNT_NAME
```

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"NEW_ACCOUNT_NAME\"}"
```

Returns `bonjour`.

Make sure the original status remains:

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"YOUR_ACCOUNT_NAME\"}"
```

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

'''
'''--- README.md ---
Neariot
==============

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

Neariot Smart Contract.

Windows users: please visit the [Windows-specific README file](README-Windows.md).

## Prerequisites
Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

Ensure `Rust` is installed by running:

```
rustc --version
```

If needed, install `Rust`:

```
curl https://sh.rustup.rs -sSf | sh
```

Install dependencies

```
npm install
```

Log to console:
```rs
env::log_str(&format!("User Data: {:?}", user_data));
```

## Quick Start
To run this project locally:

1. Prerequisites: Make sure you have Node.js ≥ 12 installed (https://nodejs.org), then use it to install yarn: `npm install --global yarn` (or just `npm i -g yarn`)
2. Run the local development server: `yarn && yarn dev` (see package.json for a full list of scripts you can run with yarn)
Now you'll have a local development environment backed by the NEAR TestNet! Running yarn dev will tell you the URL you can visit in your browser to see the app.

## Building this contract
To make the build process compatible with multiple operating systems, the build process exists as a script in `package.json`.
There are a number of special flags used to compile the smart contract into the wasm file.
Run this command to build and place the wasm file in the `res` directory:
```bash
npm run build
```

**Note**: Instead of `npm`, users of [yarn](https://yarnpkg.com) may run:
```bash
yarn build
```

### Important
If you encounter an error similar to:
>note: the `wasm32-unknown-unknown` target may not be installed

Then run:

```bash
rustup target add wasm32-unknown-unknown
```

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

### Quickest deploy
Build and deploy this smart contract to an development account. This development account will be created automatically and is not intended to be permanent. Please see the "Standard deploy" section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/status_message.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing the key to the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME

```

### Standard deploy
In this option, the smart contract will get deployed to a specific account created with the NEAR Wallet.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Build and Deploy the contract:

```bash
yarn build && near deploy --wasmFile res/neariot_contract.wasm --accountId ${ACCOUNT_ID}
```

Initialize the contract:

```bash
near call ${CONTRACT_NAME} new "{}" --accountId ${CONTRACT_NAME}
```

# Contract Method
## User
- [User] Get User Information by AccountId
```rs
pub fn get_user(&mut self, user_id: AccountId) -> ProjectUser
```
- [User] Get Project Information by Creator AccountId
```rs
pub fn get_user_projects_created(&mut self, id: AccountId) -> Project
```
- [User] Get list of projects that user funded
```rs
pub fn get_projects_funded(&self) -> Vec<Project>
```
- [User] Get list of projects that user watched
```rs
pub fn get_projects_watched(&self) -> Vec<Project>
```

## Project
- [Project] Get Project Information by ProjectId
```rs
pub fn get_project(&mut self, id: ProjectId) -> Project
```
- [Project] Create Project. Each user can only create one project
```rs
pub fn create_project(&mut self, metadata: String) -> Project
```
- [Project] Add Offer to Project
```rs
pub fn add_project_offer(
        &mut self,
        id: ProjectId,
        price: Balance,
        expires_at: u64,
        metadata: String,
    ) -> Vec<Offer>
```
- [Project] Remove Offer from Project
```rs
pub fn remove_project_offer(&mut self, id: ProjectId, offer_id: String) -> Vec<Offer>
```
- [Project] Update project metadata
```rs
pub fn update_project(&mut self, id: ProjectId, metadata: String) -> Project
```
- [Project] Buy Offer
```rs
pub fn buy_offer(&mut self, project_id: ProjectId, offer_id: String) -> Void
```
- [Project] Approve Project, Release all money to project owner
```rs
pub fn approve_project(&mut self, id: ProjectId, rate: u32, metadata: String) -> Void
```
- [Project] Reject Project, Cashback remain money to pledger
```rs
pub fn reject_project(&mut self, id: ProjectId, rate: u32, metadata: String) -> Void
```
- [Project] Add Project to watchlist
```rs
pub fn add_to_watchlist(&mut self, id: ProjectId) -> Void
```
- [Project] Remove Project from watchlist
```rs
pub fn remove_from_watchlist(&mut self, id: ProjectId) -> Void
```
- [Project] Get all bought offers of a project
```rs
pub fn get_bought_offers(&self, id: ProjectId) -> Vec<BoughtOffer>
```
- [Project] Get list of pledgers of a project
```rs
pub fn get_pledgers(&self, id: ProjectId) -> Vec<ProjectUser>
```
- [Project] Get list of watcher of a project
```rs
pub fn get_watchers(&self, id: ProjectId) -> Vec<ProjectUser>
```
- [Project] Get list of recommends project (last 20 new projects)
```rs
pub fn get_rcm_projects(&self) -> Vec<Project>
```
- [Project] Set milestone of a project
```rs
pub fn set_milestone(&self, id: ProjectId, milestones: String) -> Vec<Project>
```
- [Project] Get milestone of a project
```rs
pub fn get_milestone(&self, id: ProjectId) -> Vec<Project>
```
'''
'''--- borsh.js ---
const borsh = require("borsh");

class Assignable {
  constructor(properties) {
    Object.keys(properties).map((key) => {
      this[key] = properties[key];
    });
  }
}

class StatusMessage extends Assignable {}

class Record extends Assignable {}

const schema = new Map([
  [StatusMessage, { kind: "struct", fields: [["records", [Record]]] }],
  [
    Record,
    {
      kind: "struct",
      fields: [
        ["k", "string"],
        ["v", "string"],
      ],
    },
  ],
]);

const stateKey = "U1RBVEU=";
console.log(Buffer.from(stateKey, "base64"));
console.log(Buffer.from(stateKey, "base64").toString());
const stateValue =
  "AgAAAA8AAABhbGljZS50ZXN0Lm5lYXIFAAAAaGVsbG8NAAAAYm9iLnRlc3QubmVhcgUAAAB3b3JsZA==";
const stateValueBuffer = Buffer.from(stateValue, "base64");
let statusMessage = borsh.deserialize(schema, StatusMessage, stateValueBuffer);
console.log(statusMessage);

console.log(
  Buffer.from(borsh.serialize(schema, statusMessage)).toString("base64")
);
statusMessage.records.push(new Record({ k: "alice.near", v: "hello world" }));
console.log(statusMessage);

console.log(
  Buffer.from(borsh.serialize(schema, statusMessage)).toString("base64")
);

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "rust-status-message-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.2.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/rs/src/tests.rs ---
use serde_json::json;
use near_units::parse_near;
use workspaces::prelude::*; 
use workspaces::{network::Sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../../res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let owner = worker.root_account();
    let alice = owner
    .create_subaccount(&worker, "alice")
    .initial_balance(parse_near!("30 N"))
    .transact()
    .await?
    .into_result()?;

    // begin tests  
    test_set_message(&owner, &alice, &contract, &worker).await?;
    test_null_messages(&owner, &alice, &contract, &worker).await?;
    test_differing_statuses(&owner, &alice, &contract, &worker).await?;
    Ok(())
}   

async fn test_set_message(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    user
        .call(&worker, contract.id(), "set_status")
        .args_json(json!({ "message": "hello" }))?
        .transact()
        .await?;

    let alice_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": user.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(alice_status, "hello");
    println!("      Passed ✅ set get message");
    Ok(())
}

async fn test_null_messages(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let owner_status: Option<String> = user
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": owner.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(owner_status, None);
    println!("      Passed ✅ get nonexistent message");
    Ok(())
}

async fn test_differing_statuses(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, contract.id(), "set_status")
        .args_json(json!({ "message": "world" }))?
        .transact()
        .await?;

    let alice_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": user.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(alice_status, "hello");

    let owner_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": owner.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(owner_status, "world");
    println!("      Passed ✅ root and alice have different statuses");
    Ok(())
}
'''
'''--- integration-tests/ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // deploy contract
  const root = worker.rootAccount;
  const contract = await root.createAndDeploy(
    root.getSubAccount("rust-counter").accountId,
    "./res/status_message.wasm",
    { initialBalance: NEAR.parse("30 N").toJSON() }
  );

  // some test accounts
  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const charlie = await root.createSubAccount("charlie", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, alice, bob, charlie };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("set get message", async (t) => {
  const { root, contract, alice, bob, charlie } = t.context.accounts;
  await alice.call(contract, "set_status", { message: "hello" });
  const aliceStatus = await contract.view("get_status", { account_id: alice });
  t.is(aliceStatus, "hello");
});

test("get nonexistent message", async (t) => {
  const { root, contract, alice, bob, charlie } = t.context.accounts;
  const message: null = await contract.view("get_status", {
    account_id: root,
  });
  t.is(message, null);
});

test("root and alice have different statuses", async (t) => {
  const { root, contract, alice } = t.context.accounts;
  await root.call(contract, "set_status", { message: "world" });
  const rootStatus = await contract.view("get_status", { account_id: root });
  t.is(rootStatus, "world");
  const aliceStatus = await contract.view("get_status", { account_id: alice });
  t.is(aliceStatus, null);
});

'''
'''--- package.json ---
{
  "name": "neariot_contract",
  "version": "1.0.0",
  "scripts": {
    "build": "rustup target add wasm32-unknown-unknown && cargo build --target wasm32-unknown-unknown --release",
    "postbuild": "cp ./target/wasm32-unknown-unknown/release/neariot_contract.wasm ./res/"
  }
}

'''
'''--- src/actions_of_cluster.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    // #[payable]
    pub fn new_cluster(&mut self, name: String, description: String) -> ClusterId {
        let owner: AccountId = env::predecessor_account_id().into();
        let cluster = Cluster {
            owner_id: owner.clone(),
        };

        let metadata = ClusterMetaData::new(name, description);
        let cluster_id = metadata.clone().id;
        self.cluster.insert(&cluster_id, &cluster);
        self.cluster_metadata.insert(&cluster_id, &metadata);

        // Add cluster to owner
        let mut owner_clusters =
            self.cluster_per_owner
                .get(&owner.clone())
                .unwrap_or(UnorderedSet::new(StorageKey::ClusterPerOwnerInner {
                    id: owner.clone(),
                }));
        owner_clusters.insert(&cluster_id);
        self.cluster_per_owner.insert(&owner,&owner_clusters);
        return cluster_id;
    }
    
}

'''
'''--- src/cluster.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Cluster {
    pub owner_id: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ClusterMetaData {
    pub owner: AccountId,
    pub id: String,
    pub name: String,
    pub description: String,
    pub apikey_hash: String,
    pub data: String,
    pub create_at:u64,
    pub update_at:u64,
}

impl ClusterMetaData {
    pub fn new(name: String, description: String) -> Self {
        Self {
            owner: env::signer_account_id(),
            id: gen_cluster_id(),
            name: name,
            description: description,
            apikey_hash: String::from(""),
            data: String::from(""),
            create_at:env::block_timestamp(),
            update_at:env::block_timestamp(),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_clusters(&mut self) -> Vec<ClusterMetaData> {
        let owner = env::predecessor_account_id();

        let clusters_for_owner_set = self.cluster_per_owner.get(&owner);
        let clusters = if let Some(clusters_for_owner_set) = clusters_for_owner_set {
            clusters_for_owner_set
        } else {
            return vec![];
        };
        return clusters
            .iter()
            .skip(0 as usize)
            .take(50 as usize)
            .map(|cluster_id| self.cluster_metadata.get(&cluster_id).unwrap())
            .collect();
    }

    pub fn get_cluster(&mut self, id: String) -> Cluster {
        let cluster = self.cluster.get(&id);

        assert!(cluster.is_some(), "Cluster is not exist!");

        assert!(
            cluster.as_ref().unwrap().owner_id.to_string() == env::signer_account_id().to_string(),
            "This cluster is not belong to you"
        );

        return cluster.unwrap();
    }

    pub fn set_cluster(
        &mut self,
        id: String,
        name: String,
        description: String,
    ) -> ClusterMetaData {
        let cluster = self.cluster.get(&id);

        assert!(cluster.is_some(), "Cluster is not exist!");

        assert!(
            cluster.as_ref().unwrap().owner_id.to_string() == env::signer_account_id().to_string(),
            "This cluster is not belong to you"
        );

        let mut metadata = self.cluster_metadata.get(&id).unwrap();
        metadata.name = name;
        metadata.description = description;
        self.cluster_metadata.insert(&id, &metadata);
        return metadata;
    }

    pub fn remove_cluster(&mut self, id: String) -> String {
        let cluster = self.cluster.get(&id);
        let owner = env::signer_account_id();

        assert!(cluster.is_some(), "Cluster is not exist!");

        assert!(
            cluster.as_ref().unwrap().owner_id.to_string() == env::signer_account_id().to_string(),
            "This cluster is not belong to you"
        );
        self.cluster.remove(&id);
        self.cluster_metadata.remove(&id);
        let mut clusters_for_owner_set = self.cluster_per_owner.get(&owner).unwrap();
        clusters_for_owner_set.remove(&id);
        self.cluster_per_owner
            .insert(&owner, &clusters_for_owner_set);
        return String::from("Successfull");
    }

    pub fn get_apikey_hash(&mut self, id: String) -> String {
        let cluster = self.cluster.get(&id);

        assert!(cluster.is_some(), "Cluster is not exist!");

        return self.cluster_metadata.get(&id).unwrap().apikey_hash;
    }

    pub fn set_apikey_hash(&mut self, id: String, apikey_hash: String) -> ClusterMetaData {
        let cluster = self.cluster.get(&id);

        assert!(cluster.is_some(), "Cluster is not exist!");

        assert!(
            cluster.as_ref().unwrap().owner_id.to_string() == env::signer_account_id().to_string(),
            "This cluster is not belong to you"
        );

        let mut metadata = self.cluster_metadata.get(&id).unwrap();
        metadata.apikey_hash = apikey_hash;
        self.cluster_metadata.insert(&id, &metadata);
        return metadata;
    }

    pub fn get_cluster_data(&mut self, id: String) -> ClusterMetaData {
        let cluster = self.cluster.get(&id);

        assert!(cluster.is_some(), "Cluster is not exist!");

        assert!(
            cluster.as_ref().unwrap().owner_id.to_string() == env::signer_account_id().to_string(),
            "This cluster is not belong to you"
        );

        return self.cluster_metadata.get(&id).unwrap();
    }
}

'''
'''--- src/constants.rs ---
use crate::*;
use near_sdk::{Gas};

pub const DEFAULT_GAS_FEE: Gas = Gas(20_000_000_000_000);
pub const NEAR_DECIMAL: Balance = 1_000_000_000_000_000_000_000_000;
pub const INVESTOR_PROTECT_PERCENT: u128 = 70; // Amount of pledge locked for investor
pub const OFFER_FEES_PERCENT: u128 = 1; // Amount of fee percenr for offer
pub type ClusterId = String;
pub type ProjectId = String;
pub type OfferId = String;

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    ClusterPerOwner,
    Cluster,
    ClusterMetadata,
    ClusterPerOwnerInner { id: AccountId },
    Project,
    User,
}

'''
'''--- src/lib.rs ---
pub use crate::actions_of_cluster::*;
pub use crate::cluster::*;
pub use crate::constants::*;
pub use crate::sandbox::*;
pub use crate::utils::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault};

mod actions_of_cluster;
mod cluster;
mod constants;
mod sandbox;
mod utils;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub cluster_per_owner: LookupMap<AccountId, UnorderedSet<ClusterId>>,
    pub cluster: LookupMap<ClusterId, Cluster>,
    pub cluster_metadata: UnorderedMap<ClusterId, ClusterMetaData>,
    pub projects: UnorderedMap<ProjectId, Project>,
    pub users: UnorderedMap<AccountId, ProjectUser>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            owner_id: env::predecessor_account_id(),
            cluster_per_owner: LookupMap::new(StorageKey::ClusterPerOwner),
            cluster: LookupMap::new(StorageKey::Cluster),
            cluster_metadata: UnorderedMap::new(StorageKey::ClusterMetadata),
            projects: UnorderedMap::new(StorageKey::Project),
            users: UnorderedMap::new(StorageKey::User),
        }
    }
}

'''
'''--- src/sandbox.rs ---
use std::num::Wrapping;

use near_sdk::Promise;
// use near_sdk::{json_types::U128, near_bindgen, AccountId};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Offer {
    pub id: String,
    pub price: Balance,
    pub created_at: u64,
    pub expires_at: u64,
    pub metadata: String,
}

impl Offer {
    pub fn new(id: String, price: Balance, expires_at: u64, metadata: String) -> Self {
        Self {
            id: id,
            price: price,
            created_at: env::block_timestamp(),
            expires_at: expires_at,
            metadata: metadata,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct BoughtOffer {
    pub id: String,
    pub created_at: u64,
    pub metadata: String,
    pub buyer: AccountId,
    pub rate: u32,
}

impl BoughtOffer {
    pub fn new(id: String, metadata: String, buyer: AccountId) -> Self {
        Self {
            id: id,
            created_at: env::block_timestamp(),
            metadata: metadata,
            buyer: buyer,
            rate: 0,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Project {
    pub owner: AccountId,
    pub id: ProjectId,
    pub avg_rate: u32,
    pub metadata: String,
    // Offer need to conver to Base64 before
    pub offers: Vec<Offer>,
    pub created_at: u64,
    pub pledgers: Vec<AccountId>,
    pub watchers: Vec<AccountId>,
    pub total_pledge: Balance, // Total pledge amount, include all pledge amount of all offers
    pub total_pledge_locked: Balance, // Total pledge amount locked, include all pledge amount locked of all offers
    pub total_offers_bought: u32,     // Total offers bought
    pub total_offers_completed: u32,  // Total offers completed
    pub total_offers_cancled: u32,    // Total offers cancled
    pub bought_offers: Vec<BoughtOffer>,
    pub milestones: String,
}

impl Project {
    pub fn new() -> Self {
        Self {
            owner: env::signer_account_id(),
            id: gen_project_id(),
            avg_rate: 0,
            metadata: String::from(""),
            offers: vec![],
            created_at: env::block_timestamp(),
            pledgers: vec![],
            watchers: vec![],
            total_pledge: 0,
            total_pledge_locked: 0,
            total_offers_bought: 0,
            total_offers_completed: 0,
            total_offers_cancled: 0,
            bought_offers: vec![],
            milestones: String::from(""),
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ProjectUser {
    pub id: AccountId,
    pub total_spent: Balance,
    pub projects_funded: Vec<ProjectId>,
    pub projects_completed: Vec<ProjectId>,
    pub projects_watched: Vec<ProjectId>,
    pub projects_created: ProjectId,
}

impl ProjectUser {
    pub fn new() -> Self {
        Self {
            id: env::signer_account_id(),
            total_spent: 0,
            projects_funded: vec![],
            projects_completed: vec![],
            projects_watched: vec![],
            projects_created: String::from(""),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn join(&mut self) {
        let user_id = env::signer_account_id();
        let existed_user = self.users.get(&user_id);
        if existed_user.is_none() {
            let user = ProjectUser::new();
            self.users.insert(&user_id, &user);
        }
    }
    // Get User Information by AccountId
    pub fn get_user(&mut self, user_id: AccountId) -> ProjectUser {
        let user = self.users.get(&user_id).expect("User not found!");
        return user;
    }
    // Get Project Information by ProjectId
    pub fn get_project(&mut self, id: ProjectId) -> Project {
        let project = self.projects.get(&id);

        assert!(project.is_some(), "Project is not exist!");

        return project.unwrap();
    }
    // Get Project Information by Creator AccountId
    pub fn get_user_projects_created(&mut self, id: AccountId) -> Project {
        let user = self.users.get(&id);

        assert!(user.is_some(), "User is not exist!");

        let user = user.unwrap();

        let project_id = user.projects_created;

        assert!(project_id.len() > 0, "User has not created any project!");

        let project = self.projects.get(&project_id);

        assert!(
            project.is_some(),
            "SB00006: Something went wrong, project is not exist!"
        );

        return project.unwrap();
    }

    // Create Project. Each user can only create one project
    pub fn create_project(&mut self, metadata: String) -> Project {
        let mut user = self.users.get(&env::signer_account_id());
        if !user.is_some() {
            self.users
                .insert(&env::signer_account_id(), &ProjectUser::new());
            user = self.users.get(&env::signer_account_id());
        }
        let mut user_data = user.unwrap();
        assert!(
            user_data.projects_created.len() == 0,
            "User has already created a project!"
        );
        let mut project = Project::new();
        user_data.projects_created = project.id.clone();
        project.metadata = metadata;
        project.owner = env::signer_account_id();
        self.projects.insert(&project.id, &project);
        self.users.insert(&env::signer_account_id(), &user_data);
        return project;
    }

    // Add Offer to Project
    pub fn add_project_offer(
        &mut self,
        id: ProjectId,
        price: u32,
        expires_at: u64,
        metadata: String,
    ) -> Vec<Offer> {
        let balance_price = u128::from(price) * NEAR_DECIMAL;
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner == env::signer_account_id(),
            "You are not the owner of this project!"
        );
        let mut offer_id = String::from("OF_");
        offer_id.push_str(&env::block_timestamp().to_string());
        let new_offer = Offer::new(offer_id, balance_price, expires_at, metadata);
        project_data.offers.push(new_offer);
        self.projects.insert(&id, &project_data);
        return project_data.offers;
    }

    // Remove Offer from Project
    pub fn remove_project_offer(&mut self, id: ProjectId, offer_id: String) -> Vec<Offer> {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner == env::signer_account_id(),
            "You are not the owner of this project!"
        );
        let mut offers = project_data.offers;
        let mut index = 0;
        for offer in offers.iter() {
            if offer.id == offer_id {
                break;
            }
            index += 1;
        }
        if index >= offers.len() {
            assert!(false, "Offer is not exist!");
        }
        offers.remove(index);
        project_data.offers = offers;
        self.projects.insert(&id, &project_data);
        return project_data.offers;
    }

    // Update project metadata
    pub fn update_project(&mut self, id: ProjectId, metadata: String) -> Project {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner == env::signer_account_id(),
            "You are not the owner of this project!"
        );
        project_data.metadata = metadata;
        self.projects.insert(&id, &project_data);
        return project_data;
    }

    // Buy Offer
    #[payable]
    pub fn buy_offer(&mut self, project_id: ProjectId, offer_id: String) {
        // Get Project Information
        let project = self.projects.get(&project_id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        // Get Offer Information
        let offers = project_data.offers;
        let mut index = 0;
        for offer in offers.iter() {
            if offer.id == offer_id {
                break;
            }
            index += 1;
        }
        if index >= offers.len() {
            assert!(false, "Offer is not exist!");
        }
        // Validate Offer and User role
        let offer = offers.get(index).unwrap();
        assert!(
            offer.expires_at < env::block_timestamp(),
            "Offer is expired!"
        );
        assert!(
            &env::signer_account_id() != &project_data.owner,
            "You are the owner of this projecty!"
        );
        // Check if user's deposite is enough
        if env::attached_deposit() < offer.price {
            assert!(false, "Not enough money!");
        }
        // Update User Info
        let mut user = self.users.get(&env::signer_account_id());
        if !user.is_some() {
            self.users
                .insert(&env::signer_account_id(), &ProjectUser::new());
            user = self.users.get(&env::signer_account_id());
        }
        let mut user_data = user.unwrap();
        let mut user_projects_funded = user_data.projects_funded;
        user_projects_funded.push(project_id.clone());
        user_data.projects_funded = user_projects_funded;
        // Transfer a part of money to project owner
        let project_owner = project_data.owner.clone();
        let money = Wrapping(offer.price * (100 - INVESTOR_PROTECT_PERCENT) / 100);
        user_data.total_spent = (Wrapping(user_data.total_spent) + money.clone()).0;
        Promise::new(project_owner).transfer(money.0);
        // Update Project Info
        let bought_offer = BoughtOffer::new(offer_id, String::from(""), env::signer_account_id());
        project_data.bought_offers.push(bought_offer);
        project_data.pledgers.push(env::signer_account_id());
        project_data.total_pledge += offer.price;
        project_data.total_pledge_locked = (Wrapping(project_data.total_pledge_locked) + Wrapping(offer.price * INVESTOR_PROTECT_PERCENT / 100)).0;
        project_data.total_offers_bought += 1;
        project_data.offers = offers;
        self.users.insert(&env::signer_account_id(), &user_data);
        self.projects.insert(&project_id, &project_data);
    }

    // Approve Project, Release all money to project owner
    #[payable]
    pub fn approve_project(&mut self, id: ProjectId, rate: u32, metadata: String) {
        assert!(
            rate >= 1,
            "Minimum rate is 1, please check your rate again!"
        );
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner != env::signer_account_id(),
            "You are the owner of this project!"
        );
        // Get offer Information
        // Check if project sender is pledged to this project
        let user = self.users.get(&env::signer_account_id());
        assert!(user.is_some(), "User is not exist!");
        let mut user_data = user.unwrap();
        let mut index = 0;
        for data in project_data.bought_offers.iter() {
            if data.buyer == user_data.id {
                break;
            }
            index += 1;
        }
        // Update Bought offer and project Rate
        let mut bought_offer = project_data.bought_offers.get(index).unwrap().clone();
        assert!(
            bought_offer.rate == 0,
            "This offer has been completed!"
        );
        bought_offer.rate = rate;
        bought_offer.metadata = metadata;
        project_data.bought_offers[index] = bought_offer.clone();
        project_data.total_offers_completed += 1;
        // Calculate rate for project
        let mut total_rate = 0;
        for offer in project_data.bought_offers.iter() {
            total_rate += offer.rate;
        }
        project_data.avg_rate = total_rate / project_data.bought_offers.len() as u32;
        // Get Offer Information
        let offers = project_data.offers.clone();
        let mut index = 0;
        for offer in offers.iter() {
            if offer.id == bought_offer.id {
                break;
            }
            index += 1;
        }
        if index >= offers.len() {
            // Offer is exist in Bought offer but not exist in Offer
            assert!(false, "SB0001, Something went wrong!");
        }
        // Calculate money for project owner
        let offer = offers.get(index).unwrap();
        let money = Wrapping(offer.price * (INVESTOR_PROTECT_PERCENT - OFFER_FEES_PERCENT) / 100);
        project_data.total_pledge_locked = (Wrapping(project_data.total_pledge_locked) - money).0;
        user_data.total_spent += money.clone().0;
        // Release remaining money to project
        let project_owner = project_data.owner.clone();
        Promise::new(project_owner).transfer(money.0);
        // Update Project and User Infor
        self.users.insert(&env::signer_account_id(), &user_data);
        self.projects.insert(&id, &project_data);
    }

    // Reject Project, Cashback remain money to pledger
    #[payable]
    pub fn reject_project(&mut self, id: ProjectId, rate: u32, metadata: String) {
        assert!(
            rate >= 1,
            "Minimum rate is 1, please check your rate again!"
        );
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner != env::signer_account_id(),
            "You are the owner of this project!"
        );
        // Get offer Information
        // Check if project sender pledged to this project
        let user = self.users.get(&env::signer_account_id());
        assert!(user.is_some(), "User is not exist!");
        let mut user_data = user.unwrap();
        let mut index = 0;
        for data in project_data.bought_offers.iter() {
            if data.buyer == user_data.id {
                break;
            }
            index += 1;
        }
        if index >= project_data.bought_offers.len() {
            // User ID is not exist in pledged list
            assert!(false, "User is not exist in pledged list!");
        }
        // Update Bought offer and project Rate
        let mut bought_offer = project_data.bought_offers.get(index).unwrap().clone();
        assert!(
            bought_offer.rate == 0,
            "This offer has been completed!"
        );
        // Get Offer Information, check if bought offer is not exists in offer list
        let offers = project_data.offers.clone();
        let mut index = 0;
        for offer in offers.iter() {
            if offer.id == bought_offer.id {
                break;
            }
            index += 1;
        }
        if index >= offers.len() {
            // Offer is exist in Bought offer but not exist in Offer
            assert!(false, "SB00005, Something went wrong!");
        }
        bought_offer.rate = rate;
        bought_offer.metadata = metadata;
        project_data.bought_offers[index] = bought_offer.clone();
        // Calculate rate for project
        let mut total_rate = 0;
        for offer in project_data.bought_offers.iter() {
            total_rate += offer.rate;
        }
        project_data.avg_rate = total_rate / project_data.bought_offers.len() as u32;
        project_data.total_offers_cancled += 1;
        // Calculate money for project owner
        let offer = offers.get(index).unwrap();
        // let money = (offer.price * (INVESTOR_PROTECT_PERCENT - 1)) / 100;
        // project_data.total_pledge_locked -= money.clone();
        let money = Wrapping(offer.price * (INVESTOR_PROTECT_PERCENT - 1) / 100);
        project_data.total_pledge_locked = (Wrapping(project_data.total_pledge_locked) - money).0;
        user_data.projects_completed.push(id.clone());
        // Cashback remaining money to pledger
        Promise::new(env::signer_account_id()).transfer(money.0);
        // Update Project Infor
        self.projects.insert(&id, &project_data);
        self.users.insert(&env::signer_account_id(), &user_data);
        // Update user information
    }

    // Add Project to watchlist
    pub fn add_to_watchlist(&mut self, id: ProjectId) {
        let mut user = self.users.get(&env::signer_account_id());
        // assert!(user.is_some(), "User is not exist!");
        if !user.is_some() {
            // Create new user
            let new_user = ProjectUser::new();
            self.users.insert(&env::signer_account_id(), &new_user);
            user = self.users.get(&env::signer_account_id());
        }
        let mut user_data = user.unwrap();
        for project in user_data.projects_watched.iter() {
            if project == &id {
                assert!(false, "Project is already in watchlist!");
            }
        }
        user_data.projects_watched.push(id.clone());
        // Add watcher list to project
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        project_data.watchers.push(env::signer_account_id());
        self.users.insert(&env::signer_account_id(), &user_data);
        self.projects.insert(&id, &project_data);
    }

    // Get all bought offers of a project
    pub fn get_bought_offers(&self, id: ProjectId) -> Vec<BoughtOffer> {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let project_data = project.unwrap();
        return project_data.bought_offers;
    }

    // Get list of projects that user funded
    pub fn get_projects_funded(&self) -> Vec<Project> {
        let user = self.users.get(&env::signer_account_id());
        assert!(user.is_some(), "User did not pledge any project!");
        let user_data = user.unwrap();
        let mut projects = vec![];
        for id in user_data.projects_funded.iter() {
            let project = self.projects.get(id);
            if project.is_some() {
                projects.push(project.unwrap());
            }
        }
        return projects;
    }

    // Get list of projects that user watched
    pub fn get_projects_watched(&self) -> Vec<Project> {
        let user = self.users.get(&env::signer_account_id());
        assert!(user.is_some(), "User is not watching any project!");
        let user_data = user.unwrap();
        let mut projects = vec![];
        for id in user_data.projects_watched.iter() {
            let project = self.projects.get(id);
            if project.is_some() {
                projects.push(project.unwrap());
            }
        }
        return projects;
    }

    // Get list of pledgers of a project

    pub fn get_pledgers(&self, id: ProjectId) -> Vec<ProjectUser> {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let project_data = project.unwrap();
        let mut pledgers = vec![];
        for id in project_data.pledgers.iter() {
            let pledger = self.users.get(id);
            if pledger.is_some() {
                pledgers.push(pledger.unwrap());
            }
        }
        return pledgers;
    }

    // Get list of watcher of a project
    pub fn get_watchers(&self, id: ProjectId) -> Vec<ProjectUser> {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let project_data = project.unwrap();
        let mut watchers = vec![];
        for id in project_data.watchers.iter() {
            let watcher = self.users.get(id);
            if watcher.is_some() {
                watchers.push(watcher.unwrap());
            }
        }
        return watchers;
    }

    // Remove Project from watchlist
    pub fn remove_from_watchlist(&mut self, id: ProjectId) {
        let user = self.users.get(&env::signer_account_id());
        assert!(user.is_some(), "User is not exist!");
        let mut user_data = user.unwrap();
        let mut index = 0;
        for data in user_data.projects_watched.iter() {
            if data == &id {
                break;
            }
            index += 1;
        }
        if index >= user_data.projects_watched.len() {
            // Project is not exist in watchlist
            assert!(false, "Project is not exist in watchlist!");
        }
        user_data.projects_watched.remove(index);
        self.users.insert(&env::signer_account_id(), &user_data);
        // Remove watcher list from project
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        let mut index = 0;
        for data in project_data.watchers.iter() {
            if data == &env::signer_account_id() {
                break;
            }
            index += 1;
        }
        if index >= project_data.watchers.len() {
            // Project is not exist in watchlist
            assert!(false, "Project is not exist in watchlist!");
        }
        project_data.watchers.remove(index);
        self.projects.insert(&id, &project_data);
    }

    pub fn get_rcm_projects(&self) -> Vec<Project> {
        let mut projects = vec![];
        let list_projects = self.projects.to_vec();
        for i in 0..(list_projects.len()) {
            if projects.len() > 20 {
                break;
            }
            projects.push(list_projects[list_projects.len() - i - 1].1.clone());
        }
        return projects;
    }

    pub fn get_milestone(&self, id: ProjectId) -> String {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let project_data = project.unwrap();
        return project_data.milestones;
    }

    pub fn set_milestone(&mut self, id: ProjectId, milestones: String) {
        let project = self.projects.get(&id);
        assert!(project.is_some(), "Project is not exist!");
        let mut project_data = project.unwrap();
        assert!(
            project_data.owner == env::signer_account_id(),
            "You are not the owner of this project!"
        );
        project_data.milestones = milestones;
        self.projects.insert(&id, &project_data);
    }
}

'''
'''--- src/utils.rs ---
use near_sdk::{json_types::Base64VecU8, serde_json};
use crate::*;

pub fn gen_cluster_id() -> ClusterId {
    return generate_id(String::from("cluster"));
}

pub fn gen_project_id() -> ProjectId {
    return generate_id(String::from("project"));
}

fn generate_id(text: String) -> String {
    let account_id = env::signer_account_id();
    let mut raw_id = account_id.to_owned().to_string();
    raw_id.push_str("_");
    raw_id.push_str(&text);
    raw_id.push_str("_");
    raw_id.push_str(&(&env::block_timestamp().to_string()));
    let u8_id = raw_id.as_bytes();
    let vec_id: Vec<u8> = u8_id.iter().cloned().collect();
    let encode = <Base64VecU8 as From<Vec<u8>>>::from(vec_id);
    let enc_vec = <Base64VecU8 as From<Base64VecU8>>::from(encode);
    let enc_str: String = serde_json::to_string(&enc_vec).unwrap().replace('"', "");
    return enc_str;
}

'''
'''--- test_cmd.sh ---
yarn build && near deploy --wasmFile res/neariot_contract.wasm --accountId neariot_contract.testnet

near call ciuz.testnet new "{}" --accountId ciuz.testnet

near call ciuz.testnet new_cluster '{"name":"aloha","description":"Hello World"}' --accountId ciuz.testnet

near call neariot.testnet get_clusters --accountId neariot.testnet

near call neariot.testnet get_cluster '{"id":"bmVhcmlvdC50ZXN0bmV0XzE2NTg1NzE0NDUyODc1MTc4Mzc="}' --accountId neariot.testnet

near call neariot.testnet get_cluster_data '{"id":"bmVhcmlvdC50ZXN0bmV0XzE2NTg1NzE0NDUyODc1MTc4Mzc="}' --accountId neariot.testnet

near call ciuz.testnet set_cluster '{"id":"Y2l1ei50ZXN0bmV0XzE2NTczNzYxNzc0Mzc2NTg5MTg=","name":"abc","description":"abc"}' --accountId ciuz.testnet

near call ciuz.testnet remove_cluster '{"id":"Y2l1ei50ZXN0bmV0XzE2NTczNzYxNzc0Mzc2NTg5MTg="}' --accountId ciuz.testnet

neariot_test2.testnet
hieutest1.testnet

near call neariot_contract.testnet new "{}" --accountId neariot_contract.testnet
near call neariot_contract.testnet join "{}" --accountId hieutest1.testnet
near call neariot_contract.testnet get_user '{"user_id": "hieutest1.testnet"}' --accountId hieutest1.testnet 
near call neariot_contract.testnet create_project '{"metadata": "HAHJDGSJAgjsafghjasgdjasgdjghajkdjksahdjaskdj"}' --accountId hieutest1.testnet 
near call neariot_contract.testnet get_user_projects_created '{"id": "hieutest1.testnet"}' --accountId neariot_contract.testnet 
near call neariot_contract.testnet get_project '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet add_project_offer '{"id":"aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY4MTc3NTA0ODUyNjI2NzIx", "price":1, "expires_at":1664014557681,"metadata":"1"}' --accountId hieutest1.testnet
near call neariot_contract.testnet remove_project_offer '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2", "offer_id": "OF_1664017845791869975"}' --accountId hieutest1.testnet 
near call neariot_contract.testnet update_project '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2", "metadata": "Mot con vit xoe ra hai cai canh"}' --accountId hieutest1.testnet 

neariot_contract.testnet
neutrinotest1.testnet
hieutest1.testnet 
lottery_game.testnet

near call neariot_contract.testnet new "{}" --accountId neariot_contract.testnet

near call neariot_contract.testnet get_projects_funded "{}" --accountId neariot_test2.testnet
near call neariot_contract.testnet get_projects_watched "{}" --accountId neariot_test2.testnet
near call neariot_contract.testnet add_to_watchlist '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy"}' --accountId neutrino.testnet 
near call neariot_contract.testnet get_user '{"user_id": "neariot_test2.testnet"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet buy_offer '{"project_id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy", "offer_id": "OF_1668351578412975745"}' --accountId hieutest1.testnet --deposit 1
near call neariot_contract.testnet approve_project '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy", "rate": 5, "metadata":"Approve Project, Release all money to project owner"}' --accountId hieutest1.testnet
near call neariot_contract.testnet reject_project '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy", "rate": 5, "metadata":"Reject Project, Cashback remain money to pledger"}' --accountId neariot_test2.testnet
near call neariot_contract.testnet get_bought_offers '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet get_pledgers '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet get_watchers '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet remove_from_watchlist '{"id": "aGlldXRlc3QxLnRlc3RuZXRfcHJvamVjdF8xNjY3MzkzODM2Njc5OTE0ODY2"}' --accountId neariot_test2.testnet 
near call neariot_contract.testnet get_rcm_projects "{}" --accountId neariot_contract.testnet

near call neariot_contract.testnet get_milestone '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy"}' --accountId neariot_t.testnet
near call neariot_contract.testnet set_milestone '{"id": "bmVhcmlvdF90LnRlc3RuZXRfcHJvamVjdF8xNjY4MTc2ODk3MjM5MDU4MDUy", "milestones": "1668187084700"}' --accountId neariot_t.testnet
'''
'''--- test_code/main.rs ---
#[path = "things/hello.rs"]
mod things;

fn main() {
    let output = things::foo();
    return output;
}

'''
'''--- test_code/things/hello.rs ---
pub fn foo() -> str {
    println!("Haluuuuu");
    return "Worldd";
}

'''