*GitHub Repository "iamalperen/NCD.L1.sample--nearly-neighbors"*

'''--- Cargo.toml ---
# [package]
# name = "nearly-neighbors"
# version = "0.0.0"
# authors = ["Near Inc <hello@nearprotocol.com>"]
# edition = "2018"

[workspace]
members = [
  "simulation"
]

'''
'''--- README.md ---
# Nearly Neighbors

A family of smart contracts developed for NEAR Protocol to enable crowd-sourced civic development. Think Kickstarter for neighborhood projects.

## ⚠️ Warning

Any content produced by NEAR, or developer resources that NEAR provides, are for educational and inspiration purposes only.  NEAR does not encourage, induce or sanction the deployment of any such applications in violation of applicable laws or regulations.

## Concept

The contracts provided here enable users to propose neighborhood development projects and crowd-source funding for them.

Think of it like Kickstarter, but instead of funding your roommate's sister's math rock band, you'd propose and fund projects like a new local park, grocery store, or community center. And the whole thing is powered by the NEAR protocol, so identity and financial tools are built in.

### Example Story

For the sake of this explanation, we'll assume three users: Alice, Bob, and Carol.

1. Alice notices that there isn't a good grocery store in her neighborhood, so she creates a new [proposal](#proposal) and sets a target funding goal of 10 NEAR tokens.
2. Bob lives nearby and also would like to have fresh produce, so he pledges 5 NEAR tokens to Alice's proposal with a geographic radius of 1km from his home.
3. Carol lives farther away, but she would still like to have a grocery store even if it is a longer walk, so she pledges another 5 NEAR to Alice's proposal with an allowed radius of 5km.
4. Now that the proposal is _fully funded_, it is transformed into a [project](#project). A new project account is created, and Bob and Carol's pledged NEAR tokens are transferred over. This project's geographic location is set to the area of overlap between Bob and Carol's specified radii.
5. Alice, as the project owner, now has access to the project funds to hire a contractor and build her grocery store!

- [Getting Started](#getting-started)
  - [Installation](#installation)
  - [Commands](#commands)
  - [Who This Is For](#who-this-is-for)
- [UI Wireframes](#ui-wireframes)
- [File Structure](#file-structure)
- [Contracts](#contracts)
  - [Proposal](#proposal)
  - [Project](#project)
  - [Factory](#factory)
- [Deploying](#deploying)
- [Contributing](#contributing)
  - [Future Development](#future-development)
  - [Key Contributors](#key-contributors)

---
## Getting Started

This repository is an example of a **dApp seed** project. **dApp seed** projects provide a stable foundation for developers to build a distributed application on top of. This includes:

- One or more [smart contracts](https://docs.near.org/docs/roles/developer/contracts/intro)
- [Unit tests](https://docs.near.org/docs/roles/developer/contracts/test-contracts#unit-tests) and [simulation tests](https://docs.near.org/docs/roles/developer/contracts/test-contracts#simulation-tests) for the contract(s)
- Wireframes and/or mockups for a potential dApp UI
- Utilities for building, testing, and deploying contracts (facilitated by the [NEAR CLI](https://docs.near.org/docs/development/near-cli))

### Installation

1. clone this repo
2. run `yarn install` (or `npm install`)
3. run `yarn build` (or `npm run build`)
4. run `yarn test` (or `npm run test`)
5. explore the contents of `src/`

See below for more convenience scripts ...

### Commands

**Compile source to WebAssembly**

```sh
yarn build                    # asb --target debug
yarn build:release            # asb
```

**Run unit tests**

```sh
yarn test:unit                # asp --verbose --nologo -f unit.spec
```

**Run simulation tests**

These tests can be run from within VSCode (or any Rust-compatible IDE) or from the command line.

_NOTE: Rust is required_

```sh
yarn test:simulate            # yarn build:release && cargo test -- --nocapture
```

**Run all tests**

```sh
yarn test                     # yarn test:unit && test:simulate
```

### Who This Is For

- Novice/intermediate Web3 devs looking for projects to practice on
- Developers new to the NEAR Protocol looking for a learning sandbox
- NEAR developers looking for inspiration

## UI Wireframes

More wireframes can be found in the `wireframes/` folder. Here are some examples showing how we envision the basic user interface elements.

**Create a Proposal**

![create-proposal](wireframes/create_proposal.png)

**Supporting a Proposal**

![support-project-proposal](wireframes/support_proposal_modal.png)

**Map of Projects**

![project-map](wireframes/project_map.png)

## File Structure

This contract is designed to be self-contained and so may be extracted into your own projects and used as a starting point.  If you do decide to use this code, please pay close attention to all top level files including:

- NodeJS artifacts
  - `package.json`: JavaScript project dependencies and several useful scripts

- AssemblyScript artifacts
  - `asconfig.json`: AssemblyScript project (and per contract) configuration including workspace configuration
  - `as-pect.config.js`: as-pect unit testing dependency
  - `src/tsconfig.json`: load TypeScript types
  - `src/as_types.ts`: AssemblyScript types header file
  - `src/as-pect.d.ts`: as-pect unit testing types header file

- Rust artifacts
  - `Cargo.toml`: Rust project dependencies and configuration
  - `Cargo.lock`: version-locked list of Rust project dependencies

The core file structure:

```
nearly-neighbors
├── README.md                           <-- this file
├── build                               <-- compiled contracts (WASM)
│   ├── debug
│   └── release
├── simulation
│   ├── Cargo.toml                      <-- simulation test config
│   └── src                             <-- simulation tests
│       ├── factory.rs
│       ├── lib.rs
│       ├── project.rs
│       └── proposal.rs
├── src
│   ├── factory                         <-- factory contract with:
│   │   ├── asconfig.json
│   │   ├── assembly                    <--   source code
│   │   │   └── index.ts
│   │   └── __tests__                   <--   unit tests
│   │       └── index.unit.spec.ts
│   ├── project                         <-- project contract with:
│   │   ├── asconfig.json
│   │   ├── assembly                    <--   source code
│   │   │   └── index.ts
│   │   └── __tests__                   <--   unit tests
│   │       └── index.unit.spec.ts
│   ├── proposal                        <-- proposal contract with:
│   │   ├── asconfig.json
│   │   ├── assembly                    <--   source code
│   │   │   └── index.ts
│   │   └── __tests__                   <--   unit tests
│   │       └── index.unit.spec.ts
│   └── utils.ts
└── wireframes                          <-- wireframe images
```

## Contracts

There are three contracts that make up this project.

By breaking out the logic into multiple contracts, we are employing NEAR development best practices which will make the code more secure (through rigorous testing of separated concerns) and robust (enabling complex features through [cross-contract calls](https://docs.near.org/docs/tutorials/how-to-write-contracts-that-talk-to-each-other)).

### Proposal

The proposal contract represents a user's proposed idea for a development project.

Proposals are created by users (mediated by the [factory](#factory)) and hold data like:

- Project details (what, where, why)
- Funding parameters (target amount, minimum pledge, due date)

The proposal accepts funding from _supporters_.

If proposals are fully funded by their due date, then they are closed and converted to a [project](#project) (with all funds transferred to the new project's account).
If proposals do not meet their funding goals, then they are closed and all funds are returned to the supporters.

### Project

The project contract represents a fully-funded proposal. It is managed by a _project owner_, who is authorized to access the project's NEAR tokens so that they can put those funds into use by actually executing on the real-world project.

Projects are created automatically by the [factory](#factory) from a fully-funded [proposal](#proposal). Projects maintain a reference to their original proposal for proper record-keeping.

Projects track their own real-world progress by reporting on key stats like:

- Amount of funds used
- % progress towards completion

### Factory

The factory is a behind-the-scenes contract which takes care of the creation and setup of [proposals](#proposal) and [projects](#project). Instead of human users creating proposal and project contracts directly, they instead send requests to the factory which handles the necessary tasks for them.

This is a pattern you'll see frequently in NEAR (and other blockchain) development: designating a contract with the responsibility for managing the lifecycle of other contracts. It helps abstract out the routine tasks of contract initialization and setup, limiting tedious user interactions and thus avoiding potential for user error.

## Deploying

TODO: Add referral to resources for deploying

## Contributing

There are two main ways you can contribute to this project:

1. **Build off of it**: we made this so that developers like you can build dApps more quickly and easily. Try building out a Web3 app on top of the provided [contracts](#contracts), using the wireframes as your guide.
2. **Enhance this dApp seed**: if you find a bug or an opportunity to enhance this repository, please submit an [issue](https://github.com/Learn-NEAR/nearly-neighbors/issues) and/or open a [pull request](https://github.com/Learn-NEAR/nearly-neighbors/pulls).

Interested in creating your own **dApp seed** and earning rewards for your efforts? Learn more: [TODO: ADD LINK / MORE COPY].

### Future Development

Some ideas for future feature development:

- Heatmaps showing the concentration of funding in particular geographic areas
- Notifications for proposal/project owners and supporters
- Algorithm for identifying ideal locations for a project, weighting the locations specified by supporters with their funding amount (i.e. more funding == more likely to use specified location)

### Key Contributors

- [Sherif Abushadi - @amgando](https://github.com/amgando)
- [Tanner Welsh - @tannerwelsh](https://github.com/tannerwelsh)

'''
'''--- _config.yml ---
theme: jekyll-theme-minimal
logo: "https://repository-images.githubusercontent.com/333836769/4f4bf780-6162-11eb-91f9-e0cf17d3a4a1"
show_downloads: true

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/factory",
    "src/proposal",
    "src/project"
  ]
}

'''
'''--- package.json ---
{
  "name": "nearly-neighbors",
  "version": "0.0.1",
  "description": "A family of NEAR contracts to enable crowd-sourced civic development.",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn test:unit && yarn test:simulate",
    "test:simulate": "yarn build:release && cargo test -- --nocapture",
    "clean": "rm -rf ./build",
    "test:debug": "node --inspect-brk ./node_modules/.bin/asp"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "2.2.4"
  }
}

'''
'''--- simulation/Cargo.toml ---
[package]
name = "simulation-nearly-neighbors"
version = "0.1.0"
authors = ["NEAR Inc <hello@near.org>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", tag = "2.2.0" }
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", tag = "2.2.0"}

'''
'''--- simulation/src/factory.rs ---

'''
'''--- simulation/src/lib.rs ---
#![allow(dead_code, unused_variables, unused_imports, non_snake_case)]
mod proposal;
pub use proposal::*;

#[cfg(test)]
mod test {
    use near_sdk::{json_types::Base58PublicKey, serde_json::json}; //, U128};
    use near_sdk_sim::near_crypto::{InMemorySigner, KeyType};
    use std::convert::TryInto;

    use super::*;
    use near_sdk_sim::{call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount};

    // Load in contract bytes
    near_sdk_sim::lazy_static! {
    //   static ref FACTORY_WASM_BYTES: &'static [u8] = include_bytes!("../../../../build/debug/factory.wasm").as_ref();
      static ref PROPOSAL_WASM_BYTES: &'static [u8] = include_bytes!("../../build/release/proposal.wasm").as_ref();
    }

    fn init() -> (UserAccount, ContractAccount<ProposalContract>) {
        let master_account = init_simulator(None);
        // uses default values for deposit and gas
        let proposal_contract = deploy!(
            // Contract Proxy
            contract: ProposalContract,
            // Contract account id
            contract_id: "proposal",
            // Bytes of contract
            bytes: &PROPOSAL_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account
        );

        // a supporter will be interested in funding this account
        let supporter_account_id = "alice".to_string();
        let alice = InMemorySigner::from_seed(
            &supporter_account_id,
            KeyType::ED25519,
            &supporter_account_id,
        );

        (master_account, proposal_contract)
    }

    #[test]
    fn test_initialize() {
        let (master_account, proposal) = init();

        let factory_account_id = "proposal".to_string();
        let factory2 =
            InMemorySigner::from_seed(&factory_account_id, KeyType::ED25519, &factory_account_id);

        let factory = proposal.user_account.switch_signer(factory2.into());
        // a factory account will generate this proposal.  we can pretend this happens here

        let res = call!(factory, proposal.initialize(), deposit = to_yocto("3"));
        // println!("{:#?}\n{:#?}\n{:#?}\n", res, res.promise_results(), res.unwrap_json::<String>());
        println!("{:#?}\n", res);
        // res.assert_success()
    }

    #[test]
    fn test_factory() {
        let (master_account, proposal) = init();

        call!(
            master_account,
            proposal.initialize(),
            deposit = to_yocto("3")
        );

        let res = call!(master_account, proposal.get_factory());
        // println!("{:#?}\n", res.unwrap_json_value());
        assert!(res.unwrap_json_value().eq("root"));
    }

    #[test]
    fn test_add_supporter() {
        let (master_account, proposal) = init();

        // master_account.account().
        // let account = runtime.view_account(&"root").unwrap();
        // println!("{:#?}\n", account);

        call!(
            master_account,
            proposal.initialize(),
            deposit = to_yocto("3")
        );

        call!(
            master_account,
            proposal.configure(
                "some proposal",
                "really tho",
                to_yocto("10").into(),
                to_yocto("3").into()
            )
        );

        call!(
            master_account,
            proposal.add_supporter(),
            deposit = to_yocto("5")
        );

        let added = call!(
            master_account,
            proposal.add_supporter(),
            deposit = to_yocto("6")
        );

        println!("{:#?}\n", added);

        let total = call!(master_account, proposal.get_funding_total());
        println!("{:#?}\n", total);

        // println!("{:#?}\n", res.unwrap_json_value());
        // assert!(res.unwrap_json_value().eq("root"));
    }
}

'''
'''--- simulation/src/project.rs ---

'''
'''--- simulation/src/proposal.rs ---
use near_sdk::json_types::U128;
use near_sdk::near_bindgen;

#[near_bindgen]
pub struct Proposal {}

#[near_bindgen]
impl Proposal {
    pub fn initialize() {}

    pub fn is_configured() {}

    pub fn configure(title: &str, description: &str, goal: U128, min_deposit: U128) {}

    pub fn toString() {}

    // pub fn add_supporter(coordinates: &str) {}
    pub fn add_supporter() {}

    // pub fn list_supporters(): PersistentVector<Supporter>

    pub fn get_factory() {}

    // pub fn get_proposal()
    pub fn get_funding_total() {}
    // pub fn is_fully_funded()
}

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/factory/__tests__/index.unit.spec.ts ---

'''
'''--- src/factory/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/factory/assembly/index.ts ---
import { context, PersistentSet } from "near-sdk-as"

type AccountId = string

@nearBindgen
class Proposal {
  constructor(
    public title: string,
    public description: string,
    public author: AccountId
  ) {}
}

const proposals = new PersistentSet<AccountId>("p")

export function create_project(proposal: Proposal): void {
  // confirm that project is in the original list of projects created by this factory
  assert(proposals.has(context.predecessor), "Unkown proposal account")
  
  // create a project for this proposal using xcc and reasonable naming convention
  const funding = context.attachedDeposit
  
  // xcc here  
}

export function create_proposal(): void {
  // create a proposal using xcc and reasonable naming convention
  const proposal = "some_new_account"
  
  // add to proposal set
  proposals.add(proposal)
}
'''
'''--- src/project/__tests__/index.unit.spec.ts ---
import { VMContext, u128 } from 'near-sdk-as';
import * as contract from '../assembly';
import { toYocto, MIN_ACCOUNT_BALANCE } from '../../utils';

/**
 * == CONFIG VALUES ============================================================
 */
const TITLE = 'common grounds';
const DESCRIPTION = 'your neighborhood coffee spot';
const PROPOSAL_ACCOUNT_ID = 'neighbors.proposal';
const FACTORY_ACCOUNT_ID = 'neighbors.factory';
const CONTRIBUTOR_ACCOUNT_ID = 'dawn';

/**
 * == HELPER FUNCTIONS =========================================================
 */
const useFactoryAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(FACTORY_ACCOUNT_ID);
};

const setCurrentAccount = (): void => {
  VMContext.setCurrent_account_id('alice');
};

const zeroOutBalance = (): void => {
  VMContext.setAccount_balance(u128.Zero);
};

const attachMinBalance = (): void => {
  VMContext.setAttached_deposit(MIN_ACCOUNT_BALANCE);
};

const doInitialize = (): void => {
  contract.initialize(PROPOSAL_ACCOUNT_ID);
};

const doConfigure = (): void => {
  contract.configure(TITLE, DESCRIPTION);
};

const initAndConfig = (): void => {
  zeroOutBalance();
  attachMinBalance();
  doInitialize();
  doConfigure();
};

describe('project', () => {
  beforeEach(setCurrentAccount);
  beforeEach(useFactoryAsPredecessor);

  describe('initialize(proposal: AccountId): void', () => {
    it('creates a new project, storing the factory and proposal IDs', () => {
      attachMinBalance();
      contract.initialize(PROPOSAL_ACCOUNT_ID);

      expect(contract.get_factory()).toBe(FACTORY_ACCOUNT_ID);
      expect(contract.get_proposal()).toBe(PROPOSAL_ACCOUNT_ID);
    });
  });

  describe('configure(title, description): void', () => {
    beforeEach(attachMinBalance);
    beforeEach(doInitialize);

    it('adds details and funding data to project', () => {
      doConfigure();

      const project = contract.get_project();
      expect(project.details).not.toBeNull();
      expect(project.details!.title).toBe(TITLE);
      expect(project.details!.description).toBe(DESCRIPTION);

      expect(project.funding).not.toBeNull();
      expect(project.funding!.total).not.toBeNull();
      expect(project.funding!.spent).not.toBeNull();
    });

    it('switches is_configured() to true', () => {
      expect(contract.is_configured()).toBe(false);
      doConfigure();
      expect(contract.is_configured()).toBe(true);
    });
  });

  describe('add_funds(): void', () => {
    beforeEach(initAndConfig);

    it('adds attached deposit to the account and updates funding total', () => {
      expect(contract.get_remaining_budget()).toBe(u128.Zero);

      VMContext.setAttached_deposit(toYocto(7));
      contract.add_funds();

      expect(contract.get_remaining_budget()).toBe(toYocto(7));
    });
  });

  describe('add_contributor(account: AccountId, contribution: Contribution): void', () => {
    beforeEach(initAndConfig);

    it('assigns an additional contributor to the contributors map', () => {
      expect(
        contract.get_contributors().get(CONTRIBUTOR_ACCOUNT_ID, null)
      ).toBeNull();

      const contribution = new contract.Contribution(
        CONTRIBUTOR_ACCOUNT_ID,
        'Build out the counter',
        toYocto(10)
      );

      contract.add_contributor(CONTRIBUTOR_ACCOUNT_ID, contribution);

      const contributors = contract.get_contributors();
      const contributor = contributors.get(CONTRIBUTOR_ACCOUNT_ID, null);
      expect(contributor).not.toBeNull();
      expect(contributor!.account).toBe(CONTRIBUTOR_ACCOUNT_ID);
      expect(contributor!.task).toBe('Build out the counter');
      expect(contributor!.amount).toBe(toYocto(10));
      expect(contributor!.status).toBe(1 as i8);
    });
  });

  describe('add_expense(label, tags, amount): void', () => {
    beforeEach(initAndConfig);

    it('adds a new expense', () => {
      expect(contract.get_expenses().length).toBe(0);

      const label = 'roaster';
      const amount = toYocto(4);

      contract.add_expense(label, amount);

      expect(contract.get_expenses().length).toBe(1);

      const expense = contract.get_expenses()[0];
      expect(expense).not.toBeNull();
      expect(expense.label).toBe(label);
      expect(expense.amount).toBe(amount);
    });

    it('updates the remaining budget by counting towards the spent funding', () => {
      VMContext.setAttached_deposit(toYocto(10));
      contract.add_funds();
      expect(contract.get_remaining_budget()).toBe(toYocto(10));
      contract.add_expense('x', toYocto(4));
      expect(contract.get_remaining_budget()).toBe(toYocto(6));
    });
  });

  describe('get_project(): Project', () => {
    beforeEach(initAndConfig);

    it('returns the project object with details and funding', () => {
      const project = contract.get_project();

      expect(project.details).not.toBeNull();
      expect(project.funding).not.toBeNull();
    });
  });

  describe('get_factory(): AccountId', () => {
    beforeEach(initAndConfig);

    it('returns the factory account ID', () => {
      expect(contract.get_factory()).toBe(FACTORY_ACCOUNT_ID);
    });
  });

  describe('get_proposal(): AccountId', () => {
    beforeEach(initAndConfig);

    it('returns the proposal account ID', () => {
      expect(contract.get_proposal()).toBe(PROPOSAL_ACCOUNT_ID);
    });
  });

  describe('get_remaining_budget(): u128', () => {
    beforeEach(initAndConfig);

    it('returns zero when funding total is equal to MIN_ACCOUNT_BALANCE', () => {
      expect(contract.get_remaining_budget()).toBe(u128.Zero);
    });

    it('returns the difference of the total funding and amount spent', () => {
      VMContext.setAttached_deposit(toYocto(10))
      contract.add_funds();
      expect(contract.get_remaining_budget()).toBe(toYocto(10));
      contract.add_expense('x', toYocto(4));
      expect(contract.get_remaining_budget()).toBe(toYocto(6));
    });
  });

  describe('get_expenses(): [Expense]', () => {
    beforeEach(initAndConfig);

    it('returns the list of expenses', () => {
      contract.add_expense('x', toYocto(4));

      expect(contract.get_expenses().length).toBe(1);

      const expense = contract.get_expenses()[0];
      expect(expense).not.toBeNull();
      expect(expense.label).toBe('x');
      expect(expense.amount).toBe(toYocto(4));
    });
  });

  describe('get_contributors(): {[AccountId]: Contribution}', () => {
    beforeEach(initAndConfig);

    it('returns the map of contributors', () => {
      const contribution = new contract.Contribution('a', 'x', toYocto(2));
      contract.add_contributor('a', contribution);

      const contributor = contract.get_contributors().get('a', null);
      expect(contributor).not.toBeNull();
      expect(contributor!.account).toBe('a');
      expect(contributor!.task).toBe('x');
      expect(contributor!.amount).toBe(toYocto(2));
    });
  });
});

'''
'''--- src/project/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/project/assembly/index.ts ---
// @nearfile out
import {
  u128,
  context,
  storage,
  PersistentVector,
  PersistentMap,
} from 'near-sdk-as';

import { MIN_ACCOUNT_BALANCE, AccountId } from '../../utils';

/**
 * >>>>> Project Contract <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 *
 * The intent of a project is to realize a proposal.
 *
 * Once a proposal is fully funded, it is automatically converted to a project and all funds
 * transferred (except minimum storage staking for proposal contract persistence).
 *
 * Actually tracking project progress is outside the scope of this work and would fall to
 * an oracle or DAO.
 */

/**
 * == CONSTANTS ================================================================
 *
 * PROJECT_KEY = key used to identify project object in storage
 */
const PROJECT_KEY = 'state';

/**
 * == TYPES & STRUCTS ==========================================================
 *
 * Types & data models used by the contract.
 */

/**
 * @class Project
 * @property factory      - account ID of factory contract
 * @property proposal     - account ID of proposal that lead to funding this project
 * @property details      - general info about the project
 * @property funding      - funds and expense tracking
 * @property contributors - list of contributors to the project
 *
 * Top-level object for storing project data. Stored on-chain with `storage`.
 */
@nearBindgen
class Project {
  constructor(
    public factory: AccountId,
    public proposal: AccountId,
    public details: ProjectDetails | null = null,
    public funding: ProjectFunding | null = null,
    public contributors: PersistentMap<
      AccountId,
      Contribution
    > = new PersistentMap<AccountId, Contribution>('c')
  ) {}
}

/**
 * @class ProjectFunding
 * @property total     - total funding available to realize this project
 * @property spent     - total spent to date
 * @property expenses  - list of expenses
 *
 * Funds and expense tracking for a project.
 */
@nearBindgen
class ProjectFunding {
  constructor(
    public total: u128 = u128.Zero,
    public spent: u128 = u128.Zero,
    public expenses: PersistentVector<Expense> = new PersistentVector<Expense>(
      'e'
    )
  ) {}
}

/**
 * @class Expense
 * @property label  - descriptive name for expense
 * @property amount - default to zero for expense notes
 */
@nearBindgen
class Expense {
  constructor(
    public label: string,
    public amount: u128 = u128.Zero
  ) {}
}

/**
 * @class ProjectDetails
 * @property title        - project name
 * @property description  - more detailed explanation of the project
 * @property owner        - account ID of project owner
 */
@nearBindgen
class ProjectDetails {
  constructor(
    public title: string,
    public description: string,
    public owner: AccountId
  ) {}
}

/**
 * @class Contribution
 * @property account  - account ID of contributor
 * @property task     - task description and details assigned to this contributor
 * @property amount   - budget for this contribution
 * @property status   - status of the contribution
 *
 * TODO: answer: how do contributions affect the overall project budget? Do their amounts
 *  get counted towards the 'spent' when status = COMPLETED?
 */
@nearBindgen
export class Contribution {
  constructor(
    public account: AccountId,
    public task: string,
    public amount: u128 = u128.Zero,
    public status: TaskStatus = TaskStatus.ASSIGNED
  ) {}
}

enum TaskStatus {
  BLOCKED = 0 as i8,
  ASSIGNED = 1 as i8,
  IN_PROGRESS = 2 as i8,
  COMPLETED = 4 as i8,
}

/**
 * == PUBLIC METHODS ===========================================================
 *
 * The contract's public API.
 */

/**
 * @function initialize
 *
 * Sets up and stores new Project.
 */
export function initialize(proposal: AccountId): void {
  assert(!is_initialized(), 'Contract is already initialized.');
  assert(
    u128.ge(context.attachedDeposit, MIN_ACCOUNT_BALANCE),
    'MIN_ACCOUNT_BALANCE must be attached to initialize (3 NEAR)'
  );

  const project = new Project(context.predecessor, proposal);

  resave_project(project);
}

/**
 * @function configure
 * @param title        - project name
 * @param description  - more detailed explanation of the project
 *
 * Configures basic data for ProjectDetails and ProjectFunding.
 */
export function configure(title: string, description: string): void {
  assert_initialized();

  const project = get_project();
  project.details = new ProjectDetails(title, description, context.sender);
  project.funding = new ProjectFunding(
    u128.sub(context.accountBalance, MIN_ACCOUNT_BALANCE)
  );

  resave_project(project);
}

/**
 * @function add_funds
 *
 * Updates funding total with attached deposit.
 */
export function add_funds(): void {
  assert_configured();

  const funds = context.attachedDeposit;
  const project = get_project();
  project.funding!.total = u128.add(project.funding!.total, funds);

  resave_project(project);
}

/**
 * @function add_contributor
 * @param account {AccountId}         - contributor account
 * @param contribution {Contribution} - contribution object
 *
 * Add a contributor to the project.
 *
 * TODO: why do we need to include the account param here, if it is already embedded within
 *  the contribution object?
 */
export function add_contributor(
  account: AccountId,
  contribution: Contribution
): void {
  assert_configured();

  const project = get_project();
  const contributors = project.contributors;
  contributors.set(account, contribution);
  project.contributors = contributors;

  resave_project(project);
}

/**
 * @function add_expense
 * @param label {string} - expense label
 * @param amount  - expense amount
 *
 * Track an expense.
 *
 * TODO: find out if it is better to decompose types into the contract interface like this
 *  to save on serde costs... or better to keep the custom types exposed like in add_contributor()
 *  for better readability?
 */
export function add_expense(
  label: string,
  amount: u128 = u128.Zero
): void {
  assert_configured();

  const project = get_project();
  const expense = new Expense(label, amount);
  project.funding!.expenses.push(expense);
  project.funding!.spent = u128.add(project.funding!.spent, amount);

  resave_project(project);
}

/**
 * @function get_project
 * @returns {Project}
 *
 * Gets the project from storage.
 */
export function get_project(): Project {
  assert_initialized();

  return storage.getSome<Project>(PROJECT_KEY);
}

/**
 * Block UX from project details page until fully configured
 */
export function is_configured(): bool {
  assert_initialized();

  return !!get_project().details;
}

/**
 * @function get_factory
 * @returns {AccountId}
 *
 * The account ID of the factory that created this project.
 */
export function get_factory(): AccountId {
  assert_initialized();

  return get_project().factory;
}

/**
 * @function get_proposal
 * @returns {AccountId}
 *
 * The account ID of the proposal for this project.
 */
export function get_proposal(): AccountId {
  assert_initialized();

  return get_project().proposal;
}

/**
 * @function get_remaining_budget
 * @returns {u128}
 *
 * The amount of funding still availale for the project (total - spent).
 */
export function get_remaining_budget(): u128 {
  assert_configured();

  const project = get_project();
  return u128.sub(project.funding!.total, project.funding!.spent);
}

/**
 * @function get_expenses
 * @returns {[Expense]}
 *
 * All expenses logged for this project.
 */
export function get_expenses(): PersistentVector<Expense> {
  assert_configured();

  const project = get_project();
  return project.funding!.expenses;
}

/**
 * @function get_contributors
 * @returns {{[AccountId]: Contribution}}
 *
 * Map of all contributors's accounts to their contribution.
 */
export function get_contributors(): PersistentMap<AccountId, Contribution> {
  assert_configured();

  const project = get_project();
  return project.contributors;
}

/**
 * == PRIVATE FUNCTIONS ========================================================
 *
 * Not to be called outside of this proposal.
 */

/**
 * Whether or not the project has been initialized.
 */
function is_initialized(): bool {
  return !!storage.hasKey(PROJECT_KEY);
}

/**
 * Updates the proposal data in storage.
 */
function resave_project(project: Project): void {
  storage.set(PROJECT_KEY, project);
}

/**
 * Guard against contract not having been initialized.
 */
function assert_initialized(): void {
  assert(is_initialized(), 'Contract must be initialized first.');
}

/**
 * Guard against contract not having been configured.
 */
function assert_configured(): void {
  assert(is_configured(), 'Contract must be configured first.');
}

'''
'''--- src/proposal/__tests__/index.unit.spec.ts ---
import { VMContext, u128 } from 'near-sdk-as';
import * as contract from '../assembly';
import { toYocto } from '../../utils';

/**
 * == CONFIG VALUES ============================================================
 */
const TITLE = 'common grounds';
const DESCRIPTION = 'your neighborhood coffee spot';
const GOAL = toYocto(50);
const MIN_DEPOSIT = toYocto(3);
const FACTORY_ACCOUNT_ID = 'neighbors.factory';

/**
 * == HELPER FUNCTIONS =========================================================
 */
const useFactoryAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(FACTORY_ACCOUNT_ID);
};

const setCurrentAccount = (): void => {
  VMContext.setCurrent_account_id('alice');
};

const attachDeposit = (deposit: number): void => {
  VMContext.setAttached_deposit(toYocto(deposit));
};

const attachMinDeposit = (): void => {
  VMContext.setAttached_deposit(MIN_DEPOSIT);
};

const doInitialize = (): void => {
  contract.initialize();
};

const doConfigure = (): void => {
  contract.configure(TITLE, DESCRIPTION, GOAL, MIN_DEPOSIT);
};

const initAndConfig = (): void => {
  attachMinDeposit();
  doInitialize();
  doConfigure();
};

describe('proposal', () => {
  beforeEach(setCurrentAccount);
  beforeEach(useFactoryAsPredecessor);

  describe('initialize(): void', () => {
    it('creates a new proposal, storing the factory account ID (predecessor)', () => {
      attachMinDeposit();
      contract.initialize();
      expect(contract.get_factory()).toBe(FACTORY_ACCOUNT_ID);
    });

    it('requires a minimum deposit be attached', () => {
      expect(() => {
        contract.initialize();
      }).toThrow();
    });
  });

  describe('configure(title, description, goal, min_deposit): void', () => {
    beforeEach(attachMinDeposit);

    it('adds details and funding data to proposal', () => {
      doInitialize();

      expect(() => {
        contract.get_funding_total();
      }).toThrow();

      doConfigure();

      const proposal = contract.get_proposal();
      expect(proposal.details).not.toBeNull();
      expect(proposal.details!.title).toBe(TITLE);
      expect(proposal.details!.description).toBe(DESCRIPTION);
      expect(proposal.details!.author).toBe('bob');

      expect(proposal.funding!.goal).toBe(GOAL);
      expect(proposal.funding!.min_deposit).toBe(MIN_DEPOSIT);
    });

    it('switches is_configured() to true', () => {
      doInitialize();

      expect(contract.is_configured()).toBe(false);
      doConfigure();
      expect(contract.is_configured()).toBe(true);
    });
  });

  describe('add_supporter(): void', () => {
    beforeEach(initAndConfig);

    it('adds the signer + deposit to the list of supporters', () => {
      expect(contract.list_supporters().length).toBe(0);

      attachDeposit(4);
      VMContext.setSigner_account_id('cc');
      contract.add_supporter();

      const supporters = contract.list_supporters();
      expect(supporters.length).toBe(1);
      expect(supporters[0].account).toBe('cc');
      expect(supporters[0].amount).toBe(toYocto(4));
    });

    it('updates the funding total', () => {
      expect(contract.list_supporters().length).toBe(0);
      expect(contract.get_funding_total()).toBe(u128.from(0));

      attachDeposit(5);
      VMContext.setSigner_account_id('carol');
      contract.add_supporter();

      expect(contract.list_supporters().length).toBe(1);
      expect(contract.get_funding_total()).toBe(toYocto(5));
    });
  });

  describe('get_proposal(): Proposal', () => {
    beforeEach(initAndConfig);

    it('returns the proposal object with factory, details, and funding', () => {
      const proposal = contract.get_proposal();

      expect(proposal.factory).not.toBeNull();
      expect(proposal.details).not.toBeNull();
      expect(proposal.funding).not.toBeNull();
    });
  });

  describe('get_factory(): Proposal', () => {
    beforeEach(useFactoryAsPredecessor);
    beforeEach(initAndConfig);

    it('returns factory account id', () => {
      expect(contract.get_factory()).toBe(FACTORY_ACCOUNT_ID);
    });
  });

  describe('get_funding_total(): u128', () => {
    beforeEach(initAndConfig);

    it('returns the current funding amount (accounting for MIN_ACCOUNT_BALANCE)', () => {
      expect(contract.get_funding_total()).toBe(u128.from(0));
    });
  });

  describe('list_supporters(): [Supporter]', () => {
    beforeEach(initAndConfig);

    it('returns an array of supporters', () => {
      expect(contract.list_supporters().length).toBe(0);

      attachDeposit(4);
      VMContext.setSigner_account_id('carol');
      contract.add_supporter();

      const supporters = contract.list_supporters();
      expect(supporters.length).toBe(1);
      expect(supporters[0].account).toBe('carol');
      expect(supporters[0].amount).toBe(toYocto(4));
    });
  });

  describe('is_fully_funded(): bool', () => {
    beforeEach(initAndConfig);

    it('returns true when funding total is greater than or equal to the goal', () => {
      expect(contract.is_fully_funded()).toBe(false);

      attachDeposit(50);
      VMContext.setSigner_account_id('carol');
      contract.add_supporter();

      expect(contract.is_fully_funded()).toBe(true);
    });
  });

  describe('resave_proposal(Proposal): void', () => {
    beforeEach(initAndConfig);

    it('updates the stored proposal data', () => {
      const proposal = contract.get_proposal();

      expect(proposal.details!.title).toBe(TITLE);
      const newTotal = toYocto(4);
      proposal.details!.title = 'new title';
      proposal.funding!.total = newTotal;

      expect(contract.get_proposal().details!.title).not.toBe('new title');
      expect(contract.get_proposal().funding!.total).not.toBe(newTotal);
      contract.resave_proposal(proposal);
      expect(contract.get_proposal().funding!.total).toBe(newTotal);
      expect(contract.get_proposal().details!.title).toBe('new title');
      expect(contract.get_funding_total()).toBe(newTotal);
    });
  });

  describe('when not initialized', () => {
    beforeEach(attachMinDeposit);

    it('initialize() is idempotent; will throw if already initialized', () => {
      contract.initialize();

      expect(() => {
        contract.initialize();
      }).toThrow();
    });

    it('configure() throws', () => {
      expect(doConfigure).toThrow();
    });
  });

  describe('when not configured', () => {
    beforeEach(attachMinDeposit);
    beforeEach(doInitialize);

    it('get_funding_total() throws', () => {
      expect(() => {
        contract.get_funding_total();
      }).toThrow();
    });

    it('is_fully_funded() throws', () => {
      expect(() => {
        contract.is_fully_funded();
      }).toThrow();
    });

    it('toString() throws', () => {
      expect(() => {
        contract.toString();
      }).toThrow();
    });

    it('add_supporter() throws', () => {
      expect(() => {
        contract.add_supporter();
      }).toThrow();
    });

    it('list_supporters() throws', () => {
      expect(() => {
        contract.list_supporters();
      }).toThrow();
    });
  });
});

'''
'''--- src/proposal/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/proposal/assembly/index.ts ---
// @nearfile out
import {
  u128,
  context,
  storage,
  PersistentVector,
  ContractPromise,
} from 'near-sdk-as';

import { XCC_GAS, MIN_ACCOUNT_BALANCE, AccountId, asNEAR } from '../../utils';

/**
 * >>>>> Proposal Contract <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 *
 * The proposal contract represents a user's proposed idea for a development project.
 *
 * Proposals have details and funding data (goal, current total, minimum deposit), and they accept
 * funding from supporters.
 *
 * If proposals are fully funded by their due date, then they are closed and converted to a
 * project contract (with all funds transferred to the new project's account).
 *
 * Otherwise, then they are closed and all funds are returned to the supporters.
 *
 * TODO: implement & update remaining methods
 * - [ ] implement cancelProposal() - if not funded by due date, then abort
 * - [ ] implement reimburseFunds() - return funds to supporters
 * - [ ] implement transferFunds() - move all funding to created project
 * - [ ] update create_project() to call transfer_funds()
 */

/**
 * == CONSTANTS ================================================================
 *
 * PROPOSAL_KEY = key used to identify proposal object in storage
 */
const PROPOSAL_KEY = 'nn';

/**
 * == TYPES & STRUCTS ==========================================================
 *
 * Types & data models used by the contract.
 */

/**
 * @class Proposal
 * @property factory  - account ID of factory contract
 * @property funding  - funding configuration & state
 * @property details  - general info about the proposal
 *
 * Top-level object for storing proposal information. Stored on-chain with `storage`.
 */
@nearBindgen
class Proposal {
  constructor(
    public factory: AccountId,
    public funding: ProposalFunding | null = null,
    public details: ProposalDetails | null = null
  ) {}
}

/**
 * @class ProposalFunding
 * @property goal         - target funding amount
 * @property min_deposit  - minimum required deposit for supporters to pledge
 * @property total        - current total funding accumulated
 * @property funded       - whether or not total is at or above the goal
 */
@nearBindgen
class ProposalFunding {
  constructor(
    public goal: u128,
    public min_deposit: u128 = MIN_ACCOUNT_BALANCE,
    public total: u128 = u128.Zero,
    public funded: bool = false
  ) {}
}

/**
 * @class ProposalDetails
 * @property title        - proposal name
 * @property description  - more detailed explanation of the proposal
 * @property author       - account ID of proposal creator
 */
@nearBindgen
class ProposalDetails {
  constructor(
    public title: string,
    public description: string,
    public author: AccountId
  ) {}
}

/**
 * @class Supporter
 * @property account - supporter's account ID
 * @property amount  - amount pledged to proposal by supporter
 *
 * Represents a single proposal supporter, along with the amount they've pledged.
 */
@nearBindgen
class Supporter {
  constructor(public account: AccountId, public amount: u128) {}
}

/**
 * == PUBLIC METHODS ===========================================================
 *
 * The contract's public API.
 */

/**
 * @function initialize
 *
 * Sets up and stores new Proposal.
 */
export function initialize(): void {
  assert(!is_initialized(), 'Contract is already initialized.');
  assert(
    u128.ge(context.attachedDeposit, MIN_ACCOUNT_BALANCE),
    'MIN_ACCOUNT_BALANCE must be attached to initialize (3 NEAR)'
  );

  const proposal = new Proposal(context.predecessor);

  resave_proposal(proposal);
}

/**
 * @function configure
 * @param title        - proposal name
 * @param description  - more detailed explanation of the proposal
 * @param goal         - target funding amount
 * @param min_deposit  - minimum required deposit for supporters to pledge
 *
 * Configures basic data for ProposalDetails and ProposalFunding.
 */
export function configure(
  title: string,
  description: string,
  goal: u128,
  min_deposit: u128
): void {
  assert_initialized();

  const proposal = get_proposal();
  proposal.details = new ProposalDetails(title, description, context.sender);
  proposal.funding = new ProposalFunding(goal, min_deposit);

  resave_proposal(proposal);
}

/**
 * @function add_supporter
 *
 * Makes the sender a supporter of the proposal, using the attached NEAR as their pledge.
 * Will fail unless the attached deposit for the transaction is more than the configured
 * minimum deposit.
 */
export function add_supporter(): void {
  assert_configured();
  assert(!is_fully_funded(), 'Proposal is already fully funded.');

  const amount = context.attachedDeposit;
  const account = context.sender;

  const proposal = get_proposal();
  assert(
    u128.ge(context.attachedDeposit, proposal.funding!.min_deposit),
    'Please attach minimum deposit of [' +
      asNEAR(proposal.funding!.min_deposit) +
      '] NEAR'
  );

  const supporters = new PersistentVector<Supporter>('s');
  const supporter = new Supporter(account, amount);
  supporters.push(supporter);
  add_funding(amount);
}

/**
 * @function get_proposal
 * @returns {Proposal}
 *
 * Gets the proposal from storage.
 */
export function get_proposal(): Proposal {
  assert_initialized();

  return storage.getSome<Proposal>(PROPOSAL_KEY);
}

/**
 * @function get_factory
 * @returns {AccountId}
 *
 * The account ID of the factory that created this proposal.
 */
export function get_factory(): AccountId {
  assert_initialized();

  return get_proposal().factory;
}

/**
 * @function get_funding_total
 * @returns {u128}
 *
 * The current total funding accumulated.
 */
export function get_funding_total(): u128 {
  assert_configured();

  const proposal = storage.get<Proposal>(PROPOSAL_KEY)!;
  return proposal.funding!.total;
}

/**
 * @function list_supporters
 * @returns {[Supporter]}
 *
 * All current supporters of the proposal.
 */
export function list_supporters(): PersistentVector<Supporter> {
  assert_configured();

  const supporters = new PersistentVector<Supporter>('s');
  return supporters;
}

/**
 * @function is_configured
 * @returns {bool}
 *
 * True if configure() has already been successfully called, otherwise false.
 * Allows UX to block proposal details page until fully configured.
 */
export function is_configured(): bool {
  assert_initialized();

  return !!get_proposal().details;
}

/**
 * @function is_fully_funded
 * @returns {bool}
 *
 * Whether or not total is at or above the goal.
 */
export function is_fully_funded(): bool {
  assert_configured();

  const funding = get_funding_total();
  const goal = get_proposal().funding!.goal;
  return u128.ge(funding, goal);
}

/**
 * @function to_string
 * @returns {string}
 *
 * A friendly URI-like string identifying the proposal. Eventually this may look like:
 *
 *   '<project title>.<proposal|project>.neighborly.<testnet|mainnet>'
 *
 * Examples:
 *
 *   'lulus-cafe.proposal.neighborly.testnet'
 *   'common-grounds.project.neighborly.testnet'
 */
export function toString(): string {
  assert_configured();

  const proposal = get_proposal();
  return 'title: [' + proposal.details!.title + ']';
}

/**
 * == PRIVATE FUNCTIONS ========================================================
 *
 * Not to be called outside of this proposal.
 */

/**
 * Updates the funding total by amount given.
 *
 * If this puts the total over goal, then this will call out to create_project().
 */
function add_funding(amount: u128): void {
  const current_total = get_funding_total();
  const new_amount = u128.add(amount, current_total);

  const proposal = get_proposal();
  const funding = proposal.funding!;

  funding.total = new_amount;
  funding.funded = u128.ge(funding.total, funding.goal);

  resave_proposal(proposal);

  if (funding.funded) {
    create_project();
  }
}

/**
 * Calls out to the factory contract to create a project from this proposal.
 *
 * Having the factory handle this work makes it easier to version.
 */
function create_project(): void {
  const proposal = get_proposal();
  // const projectBudget = u128.sub(context.accountBalance, MIN_ACCOUNT_BALANCE);

  ContractPromise.create(
    proposal.factory, // target contract account name
    'create_project', // target method name
    proposal.details, // target method arguments
    XCC_GAS // gas attached to the call
    // projectBudget             // deposit attached to the call
  );
}

/**
 * Updates the proposal data in storage.
 */
export function resave_proposal(proposal: Proposal): void {
  storage.set(PROPOSAL_KEY, proposal);
}

/**
 * Whether or not the project has been initialized.
 */
function is_initialized(): bool {
  return storage.hasKey(PROPOSAL_KEY);
}

/**
 * Guard against contract not having been initialized.
 */
function assert_initialized(): void {
  assert(is_initialized(), 'Contract must be initialized first.');
}

/**
 * Guard against contract not having been configured.
 */
function assert_configured(): void {
  assert(is_configured(), 'Contract must be configured first.');
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from 'near-sdk-as';

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */
export const ONE_NEAR = u128.from('1000000000000000000000000');
export const XCC_GAS = 5000000000000;
export const MIN_ACCOUNT_BALANCE = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''