*GitHub Repository "halremawa/dono-contract"*

'''--- asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/index.ts ---
import { Cause, Comment,Transaction,User,listedCauses,listedComments,listedTransactions,listedUsers } from './models';
import { ContractPromiseBatch, context, u128 } from 'near-sdk-as';

//functions - cause

export function addCause(cause: Cause): void {
    const storedCause = listedCauses.get(cause.id);
    if (storedCause !== null) {
        throw new Error(`a cause with ${cause.id} already exists`);
    }
    const c=Cause.fromPayload(cause);
    c.timeStamp=context.blockTimestamp;
    listedCauses.set(cause.id, c);
}

export function updateCause(cause: Cause): void {
    const storedCause = listedCauses.get(cause.id);
    if (storedCause === null) {
        throw new Error(`cause with ${cause.id} does not exist`);
    }
    if(storedCause.owner !== context.sender) {
        throw new Error(`you are not the owner of this cause`);
    }
    const c=Cause.fromPayload(cause);
    c.editTimeStamp=context.blockTimestamp;
    c.isEdited=true;
    listedCauses.set(cause.id, c);
}

export function getCause(id: string): Cause | null {
    const storedCause = listedCauses.get(id);
    if (storedCause === null) {
        throw new Error(`cause with ${id} does not exist`);
    }
    return storedCause;
}

export function getCauses(): Cause[] {
    const causes= listedCauses.values();
    //sort causes by descending timeStamp
    causes.sort((a,b) => b.timeStamp - a.timeStamp);
    return causes;
}
//functions - transaction

export function addTransaction(transaction: Transaction): void {
    
    const c=Transaction.fromPayload(transaction);
    const cause=listedCauses.get(transaction.causeId);
    if(cause===null) {
        throw new Error(`cause with ${transaction.causeId} does not exist`);
    }

    ContractPromiseBatch.create(transaction.causeId).transfer(context.attachedDeposit);
    c.timeStamp=context.blockTimestamp;
    listedTransactions.set(transaction.id, c);

    cause.totDonated= u128.add(cause.totDonated,context.attachedDeposit);
    const causeTransactions=getTransactionsForCause(transaction.causeId);
    //get the unique amount of donors from the cause transactions
    const uniqueDonors=causeTransactions.map(t=>t.owner).filter((v,i,a)=>a.indexOf(v)===i);
    cause.totNoOfDonors=uniqueDonors.length;

}

export function getTransaction(id: string): Transaction | null {
    const storedTransaction = listedTransactions.get(id);
    if (storedTransaction === null) {
        throw new Error(`transaction with ${id} does not exist`);
    }
    return storedTransaction;
}

export function getTransactions(): Transaction[] {
    const transactions= listedTransactions.values();
    //sort transactions by descending timeStamp
    transactions.sort((a,b) => b.timeStamp - a.timeStamp);
    return transactions;
}

export function getTransactionsForCause(causeId:string): Transaction[] {
    const transactions= listedTransactions.values().filter(t=>t.causeId===causeId);
    //sort transactions by descending timeStamp
    transactions.sort((a,b) => b.timeStamp - a.timeStamp);
    return transactions;
}

export function getTransactionsForUser(userId:string): Transaction[] {
    const transactions= listedTransactions.values().filter(t=>t.owner===userId);
    //sort transactions by descending timeStamp
    transactions.sort((a,b) => b.timeStamp - a.timeStamp);
    return transactions;
}

//functions - comment

export function addComment(comment: Comment): void {
    let storedComment = listedComments.get(comment.id);
    if (storedComment !== null) {
        throw new Error(`a comment with ${comment.id} already exists`);
    }
    
    //check if user has already commented on this cause
    const comments= listedComments.values();
    for(let i=0;i<comments.length;i++){
        if(comments[i].causeId===comment.causeId && comments[i].owner===context.sender){
            throw new Error(`you have already commented on this cause`);
        }
    }
    listedComments.set(comment.id, Comment.fromPayload(comment));
}

export function updateComment(comment: Comment): void {
    let storedComment = listedComments.get(comment.id);
    if (storedComment === null) {
        throw new Error(`comment with ${comment.id} does not exist`);
    }
    if(storedComment.owner !== context.sender) {
        throw new Error(`you are not the owner of this comment`);
    }
    listedComments.set(comment.id, Comment.fromPayload(comment));
}

export function getComment(id: string): Comment | null {
    let storedComment = listedComments.get(id);
    if (storedComment === null) {
        throw new Error(`comment with ${id} does not exist`);
    }
    return storedComment;
}

export function getComments(): Comment[] {
    let comments= listedComments.values();
    //sort comments by descending timeStamp
    comments.sort((a,b) => b.timeStamp - a.timeStamp);
    return comments;
}

export function buyProduct(productId: string): void {
    const product = getProduct(productId);
    if (product == null) {
        throw new Error("product not found");
    }
    if (product.price.toString() != context.attachedDeposit.toString()) {
        throw new Error("attached deposit should equal to the product's price");
    }
    ContractPromiseBatch.create(product.owner).transfer(context.attachedDeposit);
    product.incrementSoldAmount();
    listedProducts.set(product.id, product);
}

// export function deleteProduct(productId: string): void {
//     const product = getProduct(productId);
//     if (product == null) {
//         throw new Error("product not found");
//     }
//     listedProducts.delete(productId);
// }
'''
'''--- assembly/models.ts ---
import { PersistentUnorderedMap, u128, context } from "near-sdk-as";

@nearBindgen
export class Cause {
    //id should be wallet id
    id: string;
    name: string;
    description: string;
    summary: string;
    image: string;
    location: string;
    totDonated: u128;
    owner: string;
    totNoOfDonors: u32;
    totNoOfComments: u32;
    avgRating: u32;
    timeStamp: u64;
    isEdited: boolean;
    editTimeStamp: u64;
    public static fromPayload(payload: Cause): Cause {
        const cause = new Cause();
        cause.id = payload.id;
        cause.name = payload.name;
        cause.description = payload.description;
        cause.image = payload.image;
        cause.location = payload.location;
        cause.avgRating = payload.avgRating;
        cause.summary = payload.summary;
        cause.owner = context.sender;
        cause.timeStamp = payload.timeStamp;
        cause.totDonated = payload.totDonated;
        cause.totNoOfComments = payload.totNoOfComments;
        cause.totNoOfDonors = payload.totNoOfDonors;
        cause.timeStamp = payload.timeStamp;
        cause.isEdited = payload.isEdited;
        return cause;
    }
    public incrementSoldAmount(): void {
        this.sold = this.sold + 1;
    }
}

export const listedCauses = new PersistentUnorderedMap<string, Cause>("LISTED_CAUSES");

@nearBindgen
export class Comment {
    id: string;
    comment: string;
    totDonated: u128;
    owner: string;
    rating: u32;
    causeId: string;
    isEdited: boolean;
    timeStamp: u64;
    editTimeStamp: u64;
    public static fromPayload(payload: Comment): Comment {
        const comment = new Comment();
        comment.id = payload.id;
        comment.causeId = payload.causeId;
        comment.comment = payload.comment;
        comment.editTimeStamp = payload.editTimeStamp;
        comment.isEdited = payload.isEdited;
        comment.rating = payload.rating;
        comment.timeStamp = payload.timeStamp;
        comment.owner = context.sender;
        comment.totDonated = payload.totDonated;
        return comment;
    }
    public incrementSoldAmount(): void {
        this.sold = this.sold + 1;
    }
}

export const listedComments = new PersistentUnorderedMap<string, Comment>("LISTED_COMMENTS");

@nearBindgen
export class Transaction {
    //this is id of transaction as given by near
    id: string;
    causeId: string;
    //causeWalletId: string;
    causeName: string;
    totDonated: u128;
    owner: string;
    timeStamp: u64;
    public static fromPayload(payload: Transaction): Transaction {
        const transaction = new Transaction();
        transaction.id = payload.id;
        transaction.causeId = payload.causeId;
        transaction.totDonated = payload.totDonated;
        transaction.timeStamp = payload.timeStamp;
        transaction.causeName = payload.causeName;
        //transaction.causeWalletId = payload.causeWalletId;
        transaction.owner = context.sender;
        return transaction;
    }
    public incrementSoldAmount(): void {
        this.sold = this.sold + 1;
    }
}

export const listedTransactions = new PersistentUnorderedMap<string, Transaction>("LISTED_TRANSACTIONS");

@nearBindgen
export class User {
    //this is id of transaction as given by near
    id: string;
    totDonated: u128;
    totDonations: u32;
    public static fromPayload(payload: User): User {
        const user = new User();
        user.id = payload.id;
        user.totDonated = payload.totDonated;
        user.totDonations = payload.totDonations;
        return user;
    }
    public incrementSoldAmount(): void {
        this.sold = this.sold + 1;
    }
}

export const listedUsers = new PersistentUnorderedMap<string, Cause>("LISTED_USERS");
'''
'''--- assembly/tsconfig.json ---
{
    "extends": "../node_modules/assemblyscript/std/assembly.json",
    "include": [
      "./**/*.ts"
    ]
  }
'''
'''--- package.json ---
{
  "name": "dono-contract",
  "version": "1.0.0",
  "description": "Make donations!",
  "main": "index.js",
  "author": "Halilu Remawa",
  "license": "MIT",
  "devDependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''