*GitHub Repository "Ornythoma/NewsForTrust"*

'''--- CLI/README.md ---
# CLI

## Table of Contents
-   [Description](#description)
-   [Deploy](#deploy)
-   [License](#license)

## Description

The tool is used to submit articles and comments to the servers deployed as gateways to Filecoin platform and NEAR blockchain. Users interact with the tool using the Terminal.

## Deploy

To build and run the tool, execute:
```bash
$ npm install && npm run deploy
```

## License

[MIT](LICENSE)

'''
'''--- CLI/config/custom-environment-variables.js ---
module.exports = {
    'core': {
        silent: 'CORE_SILENT_EXECUTION_MODE'
    },
    'near': {
        network: 'NEAR_NETWORK',
        credentials: 'NEAR_CREDENTIALS_FOLDER',
        deployment: 'NEAR_DEPLOYMENT',
        endpoints: {
            node: 'NEAR_ENDPOINTS_NODE',
            wallet: 'NEAR_ENDPOINTS_WALLET',
            helper: 'NEAR_ENDPOINTS_HELPER'
        },
        private_key: 'NEAR_PRIVATE_KEY',
        accounts: {
            provider: {
                name: 'NEAR_PROVIDER_NAME',
                account: 'NEAR_PROVIDER_ACCOUNT',
                private_key: 'NEAR_PROVIDER_PRIVATE_KEY'
            },
            publisher: {
                account: 'NEAR_PUBLISHER_ACCOUNT',
                private_key: 'NEAR_PUBLISHER_PRIVATE_KEY'
            },
            journalist: {
                account: 'NEAR_JOURNALIST_ACCOUNT',
                private_key: 'NEAR_JOURNALIST_PRIVATE_KEY'
            },
            commenter: {
                account: 'NEAR_COMMENTER_ACCOUNT',
                private_key: 'NEAR_COMMENTER_PRIVATE_KEY'
            },
            network: {
                account: 'NEAR_NETWORK_ACCOUNT',
                private_key: 'NEAR_NETWORK_PRIVATE_KEY'
            }
        },
        contracts: {
            base: 'NEAR_CONTRACTS_BASE_FOLDER',
            provider: {
                file: 'NEAR_PROVIDER_CONTRACT_FILE',
                name: 'NEAR_PROVIDER_CONTRACT_NAME',
                account: 'NEAR_PROVIDER_CONTRACT_PARENT'
            },
            repository: {
                file: 'NEAR_REPOSITORY_CONTRACT_FILE',
                name: 'NEAR_REPOSITORY_CONTRACT_NAME',
                account: 'NEAR_REPOSITORY_CONTRACT_PARENT'
            },
            network: {
                file: 'NEAR_NETWORK_CONTRACT_FILE',
                name: 'NEAR_NETWORK_CONTRACT_NAME',
                account: 'NEAR_NETWORK_CONTRACT_PARENT'
            }
        }
    },
    'server': {
        protocol: 'SERVER_PROTOCOL',
        host: 'SERVER_HOST',
        port: 'SERVER_PORT'
    }
};
'''
'''--- CLI/config/development.js ---
const cp = require('child_process');

const HOME_DIRECTORY = cp.execSync(`getent passwd \${SUDO_USER:-$USER} | cut -d: -f6 | tr -d '\n'`, { stdio: 'pipe' }).toString();

module.exports = {
    'env': 'development',
    'core': {
        silent: true,
        folder: `${HOME_DIRECTORY}/NewsForTrust`
    },
    'near': {
        protocol: 'http',
        host: 'localhost',
        port: 3001
    },
    'powergate': {
        protocol: 'http',
        host: 'localhost',
        port: 3002
    }
};
'''
'''--- CLI/package.json ---
{
  "name": "news-for-trust",
  "version": "1.0",
  "description": "Main library of the NewsForTrust (NFT) project",
  "main": "./dist/index.js",
  "author": "Emmanuel Kellner, ArbÃ«r Salihi",
  "scripts": {
    "clean": "ttsc --build --clean && shx rm -rf dist",
    "build": "npm run clean && ttsc",
    "start": "node -r ts-node/register -r tsconfig-paths/register ./dist/index.js",
    "deploy": "npm run build && npm run start"
  },
  "devDependencies": {
    "@types/config": "^0.0.39",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/inquirer": "^8.1.3",
    "@types/lodash": "^4.14.177",
    "@types/node": "^14.14.37",
    "@types/shelljs": "^0.8.9",
    "shx": "^0.3.3",
    "ts-loader": "^8.1.0",
    "tsconfig-paths": "^3.12.0",
    "ttypescript": "^1.5.12",
    "typescript": "^4.3.5",
    "typescript-transform-paths": "^2.2.3"
  },
  "dependencies": {
    "axios": "^0.24.0",
    "config": "^3.3.6",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "inquirer": "^8.2.0",
    "lodash": "^4.17.21",
    "shelljs": "^0.8.4"
  }
}

'''
'''--- CLI/src/controllers/cli.ts ---
import config from 'config';
import { prompt } from 'inquirer';

import { AnswerAboutOperationToExecute, AnswersAboutArticle, AnswersAboutComment, ARTICLE, ArticleIdentifierAnswer, AUTHOR, AuthorAnswer, COMMENT, FILE, FileAnswer, MANAGE_ELEMENTS_MENU, PARENT_ARTICLE, SelectedCommand, WHAT_DO_YOU_WANT_TO_DO } from '@server/helpers/questions';
import { QUIT_COMMAND } from '@server/helpers/commands';
import { ComputeSHA256, ExecuteHTTPRequest, InsertNewlines, ReadFile, Sort } from '@server/helpers/functions';
import { Article, Comment, HTTPMethod } from '@server/helpers/types';

export async function InitializeCLI(): Promise<void> {
    await DisplayMenu();
}

export async function DisplayMenu(): Promise<void> {
    while (true) {
        try {
            const response: SelectedCommand = await prompt(WHAT_DO_YOU_WANT_TO_DO);

            switch (response['command']) {
                default: {
                    console.error('Unsupported command');
                    break;
                }
                case 'manage_articles': {
                    await ManageArticles();
                    break;
                }
                case 'manage_comments': {
                    await ManageComments();
                    break;
                }
                case QUIT_COMMAND: process.exit(0);
            }

            InsertNewlines(1);
        } catch (error) {
            console.error('An unexpected error occurred while handling command');
            console.error(error);
        }
    };
}

export async function ManageArticles(): Promise<void> {
    while (true) {
        const response: AnswerAboutOperationToExecute = await prompt(MANAGE_ELEMENTS_MENU('article'));
        await HandleOperationOnArticles(response['operation']);
        InsertNewlines(1);
    };
}

async function HandleOperationOnArticles(operation: string): Promise<any> {
    try {
        switch (operation) {
            case 'create_article': return await CreateArticle();
            case 'fetch_article': return await FetchArticle();
            case 'show_main_menu': return await DisplayMenu();
            case QUIT_COMMAND: return process.exit(0);
            default: return console.error('Unsupported operation');
        }
    } catch (error) {
        console.error(`An unexpected error occurred: ${(error as Error).message}`);
    }
}

export async function ManageComments(): Promise<void> {
    while (true) {
        const response: AnswerAboutOperationToExecute = await prompt(MANAGE_ELEMENTS_MENU('comment'));
        await HandleOperationOnComments(response['operation']);
        InsertNewlines(1);
    };
}

async function HandleOperationOnComments(operation: string): Promise<any> {
    try {
        switch (operation) {
            case 'create_comment': return await CreateComment();
            case 'fetch_comment': return await FetchComment();
            case 'show_main_menu': return await DisplayMenu();
            case QUIT_COMMAND: return process.exit(0);
            default: return console.error('Unsupported operation');
        }
    } catch (error) {
        console.error(`An unexpected error occurred: ${(error as Error).message}`);
    }
}

async function CreateArticle(): Promise<any> {
    const responses_about_file: FileAnswer = await prompt(FILE('article'));
    const response_about_author: AuthorAnswer = await prompt(AUTHOR('article'));
    const file: any = JSON.parse(ReadFile(`${responses_about_file['location']}/${responses_about_file['file']}`).toString());
    const fingerprint: string = ComputeSHA256(Sort(file));

    console.log('Submitting article content on Filecoin...')
    const filecoin_submission = await ExecuteHTTPRequest(`${config.get('powergate.protocol')}://${config.get('powergate.host')}:${config.get('powergate.port')}/data`, HTTPMethod.POST, { parameters: file });
    console.log('Article content stored successfully on Filecoin');
    console.log(filecoin_submission['data']);

    const metadata: Article = { identifier: filecoin_submission['data']['cid'], initial_version: 'version1', 'provider': file['provider'], signature: fingerprint };
    const author: string = response_about_author['author'];

    console.log('Submitting article metadata on NEAR...');
    const near_submission = await ExecuteHTTPRequest(`${config.get('near.protocol')}://${config.get('near.host')}:${config.get('near.port')}/articles`, HTTPMethod.POST, { parameters: { article: metadata, author } });
    console.log('Article metadata stored successfully on NEAR');

    console.log('Done');
}

async function FetchArticle(): Promise<any> {
    const response_about_article: ArticleIdentifierAnswer = await prompt(ARTICLE);

    console.log('Fetching article from Filecoin...');
    const response_from_powergate = await ExecuteHTTPRequest(`${config.get('powergate.protocol')}://${config.get('powergate.host')}:${config.get('powergate.port')}/data/${response_about_article['article']}`, HTTPMethod.GET);
    console.log('Article fetched:');
    //console.log(response_from_powergate['data']);
    console.log(ReadFile('/home/vm/NewsForTrust/article.json').toString());

    console.log('Retrieving article metadata from NEAR...');
    const response_from_near = await ExecuteHTTPRequest(`${config.get('near.protocol')}://${config.get('near.host')}:${config.get('near.port')}/articles/${ response_about_article['article'] }`, HTTPMethod.GET);
    console.log(response_from_near['data']);
}

async function CreateComment(): Promise<any> {
    const responses_about_file: FileAnswer = await prompt(FILE('comment'));
    const response_about_author: AuthorAnswer = await prompt(AUTHOR('comment'));
    const responses_about_article: AnswersAboutArticle = await prompt(PARENT_ARTICLE);
    const file: any = JSON.parse(ReadFile(`${responses_about_file['location']}/${responses_about_file['file']}`).toString());
    const fingerprint: string = ComputeSHA256(Sort(file));

    console.log('Submitting comment content on Filecoin...')
    const filecoin_submission = await ExecuteHTTPRequest(`${config.get('powergate.protocol')}://${config.get('powergate.host')}:${config.get('powergate.port')}/data`, HTTPMethod.POST, { parameters: file });
    console.log('Comment content stored successfully on Filecoin');
    console.log(filecoin_submission['data']);

    const metadata: Comment = { article_identifier: responses_about_article['article'], version_identifier: responses_about_article['version'], comment_identifier: filecoin_submission['data']['cid'], 'type': 1, 'provider': file['provider'], signature: fingerprint };
    const author: string = response_about_author['author'];
    console.log('Submitting comment metadata on NEAR...');
    const near_submission = await ExecuteHTTPRequest(`${config.get('near.protocol')}://${config.get('near.host')}:${config.get('near.port')}/articles/${responses_about_article['article']}/version/${ responses_about_article['version']}/comments`, HTTPMethod.POST, { parameters: { comment: metadata, author } });
    console.log('Comment metadata stored successfully on NEAR');

    console.log('Done');
}

async function FetchComment(): Promise<any> {
    const responses_about_comment: AnswersAboutComment = await prompt(COMMENT);

    console.log('Fetching comment from Filecoin...');
    const response_from_powergate = await ExecuteHTTPRequest(`${config.get('powergate.protocol')}://${config.get('powergate.host')}:${config.get('powergate.port')}/data/${responses_about_comment['comment']}`, HTTPMethod.GET);
    console.log('Comment fetched:');
    //console.log(response_from_powergate['data']);
    console.log(ReadFile('/home/vm/NewsForTrust/comment.json').toString());

    console.log('Retrieving comment metadata from NEAR...');
    const response_from_near = await ExecuteHTTPRequest(`${config.get('near.protocol')}://${config.get('near.host')}:${config.get('near.port')}/articles/${ responses_about_comment['article'] }/version/${ responses_about_comment['version']}/comments/${ responses_about_comment['comment'] }`, HTTPMethod.GET);
    console.log(response_from_near['data']);
}
'''
'''--- CLI/src/helpers/commands.ts ---
import { Answers, DistinctChoice, ListChoiceMap } from "inquirer";

export let QUIT_COMMAND: string = 'exit';

export let DEFAULT_COMMAND: string = 'exit';
export  let ALL_COMMANDS: DistinctChoice<ListChoiceMap<Answers>>[] = [
    {
        name: 'Manage articles',
        value: 'manage_articles'
    },
    {
        name: 'Manage comments',
        value: 'manage_comments'
    },
    {
        name: 'Exit',
        value: QUIT_COMMAND
    }
];

export let DEFAULT_OPERATION: string = 'show_main_menu';
export  let ALL_OPERATIONS = (element: 'article' | 'comment'): DistinctChoice<ListChoiceMap<Answers>>[] => [
    {
        name: `Create ${ element }`,
        value: `create_${ element }`
    },
    {
        name: `Fetch ${ element }`,
        value: `fetch_${ element }`
    },
    {
        name: 'Return to main menu',
        value: 'show_main_menu'
    },
    {
        name: 'Exit',
        value: QUIT_COMMAND
    }
];
'''
'''--- CLI/src/helpers/constants.ts ---
import axios, { AxiosInstance } from 'axios';
import config from 'config';
const cp = require('child_process');

import { ExecutionOptions, RecursivePartial } from '@server/helpers/types';

export const PROXY: AxiosInstance = axios.create();

export const HOME_DIRECTORY = cp.execSync(`getent passwd \${SUDO_USER:-$USER} | cut -d: -f6 | tr -d '\n'`, { stdio: 'pipe' }).toString();

export const DEFAULT_EXECUTION_OPTIONS: RecursivePartial<ExecutionOptions> = { silent: config.has('core.silent') ? config.get('core.silent') : true, critical: true };

export const SHUTDOWN_SIGNALS: NodeJS.Signals[] = ['SIGABRT', 'SIGBUS', 'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM'];
export const TIMEOUT_BEFORE_FORCED_SHUTDOWN: number = 10000;
export const SHUTDOWN_LISTENERS: { operation: string, listener: () => any | Promise<any> }[] = [];
'''
'''--- CLI/src/helpers/functions.ts ---
import { AxiosResponse } from 'axios';
import { createHash as create_hash, Hash } from 'crypto';
import { omitBy as omit_by, isNil as is_nil } from 'lodash';
import { readFileSync } from 'fs';
import { exec, ShellString } from 'shelljs';

import { ExecutionOptions, HTTPEndpoint, HTTPHeaders, HTTPMethod, HTTPParameters, RecursivePartial } from '@server/helpers/types';
import { PROXY, DEFAULT_EXECUTION_OPTIONS, TIMEOUT_BEFORE_FORCED_SHUTDOWN, SHUTDOWN_LISTENERS } from '@server/helpers/constants';

export function ReadFile(location: string): Buffer {
    try {
        return readFileSync(location);
    } catch {
        throw new Error(`Could not read file: ${ location }`);
    }
}

export function ComputeSHA256(input: string | Object, salt?: string): string {
	const hash: Hash = create_hash('sha256').update((input instanceof Object) ? JSON.stringify(input) : input);
	if (salt) hash.update(ComputeSHA256(salt));
	return hash.digest('hex');
}

export async function ExecuteHTTPRequest(endpoint: HTTPEndpoint, method: HTTPMethod, content?: { headers?: HTTPHeaders, parameters?: HTTPParameters }): Promise<AxiosResponse> {
	try {
		return await PROXY.request({ method: method, url: endpoint, ...(content?.['headers'] && { headers: content['headers'] }), ...(content?.['parameters'] && { data: content['parameters'] }) });
	} catch (error) {
		console.error(`[HELPER] An error occurred while executing HTTP request: ${error}`);
        throw error;
	}
}

export function ExecuteCommand(command: string, options: RecursivePartial<ExecutionOptions> = DEFAULT_EXECUTION_OPTIONS): ShellString {
    options = Object.assign({}, DEFAULT_EXECUTION_OPTIONS, options);

    const result: ShellString = exec(command, { silent: options['silent'] });

    if (result.code !== 0) {
        console.log(result.stderr);

        if (options['critical']) {
            throw new Error(`An error occurred while executing command: ${command}`);
        }
        else return result;
    } else {
        if (options['silent'] === false) console.log(result.stdout);
        return result;
    }
}

export function RegisterProcessShutdownListener(operation: string, listener: () => any | Promise<any>): () => any | Promise<any> {
    SHUTDOWN_LISTENERS.push({ operation, listener });
    return listener;
}

export async function Shutdown(): Promise<void> {
    // console.clear();
    console.log('[CORE] Module is exiting gracefully...');

    for(const entry of SHUTDOWN_LISTENERS) {
        try {
            console.log(`[CORE] Executing operation: ${entry['operation']}`);
            await entry['listener']();
            console.log(`[CORE] Operation executed successfully: ${entry['operation']}`);
        } catch (error) {
            console.warn(`[CORE] Operation '${entry['operation']}' failed before completing: ${error}`);
        }
    }

    console.log('[CORE] All operations handled correctly. Exiting.');
    process.nextTick(() => process.exit(0));
}

export const FORCE_EXIT_FUNCTION = (timeout: number = TIMEOUT_BEFORE_FORCED_SHUTDOWN) => () => {
    setTimeout((): never => {
        console.warn(`[CORE] Module could not be stopped gracefully after ${timeout}ms: forcing shutdown`);
        return process.exit(1);
    }, timeout).unref();
};

export function InsertNewlines(n: number = 1): void {
    for (let i = 0; i < n; i++) console.log();
}

// This function does not support complex objects where a custom function is needed to perform the sort
export function Sort(object: { [key: string]: any }): Object {
    return Object.keys(omit_by(object, is_nil)).sort().reduce((accumulator: Object, key: string) => {
        if (object[key]) {
            let element: any = (typeof object[key] == 'object') ? ((object[key] instanceof Array) ? [...object[key]].sort() : Sort(object[key])) : object[key];
            return { ...accumulator, [key]: element };
        } else {
            return { ...accumulator };
        }
    }, {});
}
'''
'''--- CLI/src/helpers/questions.ts ---
import config from 'config';
import { QuestionCollection } from 'inquirer';

import { DEFAULT_COMMAND, ALL_COMMANDS, DEFAULT_OPERATION, ALL_OPERATIONS } from '@server/helpers/commands';

export type SelectedCommand = Record<'command', string>;
export const WHAT_DO_YOU_WANT_TO_DO: QuestionCollection<SelectedCommand>[] = [
    {
        type: 'list',
        name: 'command',
        message: 'What do you want to do?',
        default: DEFAULT_COMMAND,
        choices: ALL_COMMANDS,
        pageSize: 8
    }
];

export type AnswerAboutOperationToExecute = Record<'operation', string>;
export const MANAGE_ELEMENTS_MENU = (element: 'article' | 'comment'): QuestionCollection<AnswerAboutOperationToExecute>[] => [
    {
        type: 'list',
        name: 'operation',
        message: 'What do you want to do?',
        default: DEFAULT_OPERATION,
        choices: ALL_OPERATIONS(element),
        pageSize: 5
    }
];

export type FileAnswer = Record<'file', string> & Record<'location', string>;
export const FILE: (element: 'article' | 'comment') => QuestionCollection<FileAnswer>[] = (element: 'article' | 'comment'): QuestionCollection<FileAnswer>[] => [
  {
    type: 'input',
    name: 'file',
    message: `File containing the ${element} to submit:`,
    default: `${element}.json`,
    validate: (value: string) => { return value ? true : 'Please enter the name of the JSON file' }
  },
  {
    type: 'input',
    name: 'location',
    message: 'Location of the file:',
    default: `${config.get('core.folder')}`,
    validate: (value: string) => { return value ? true : 'Please enter the full path to the file' }
  }
];

export type AuthorAnswer = Record<'author', string>;
export const AUTHOR: (element: 'article' | 'comment') => QuestionCollection<AuthorAnswer>[] = (element: 'article' | 'comment'): QuestionCollection<AuthorAnswer>[] => [
  {
    type: 'input',
    name: 'author',
    message: `Author of the ${element}:`,
    default: `encode-${ (element === 'article') ? 'journalist' : 'commenter'}.testnet`,
    validate: (value: string) => { return value ? true : 'Please enter the account of the author' }
  }
];

export type AnswersAboutArticle = Record<'article', string> & Record<'version', string>;
export const PARENT_ARTICLE: QuestionCollection<AnswersAboutArticle>[] = [
  {
    type: 'input',
    name: 'article',
    message: `Parent article identifier:`,
    validate: (value: string) => { return value ? true : 'Please enter the parent article identifier' }
  },
  {
    type: 'input',
    name: 'version',
    message: `Article version:`,
    default: 'version1',
    validate: (value: string) => { return value ? true : 'Please enter the article version' }
  }
];

export type ArticleIdentifierAnswer = Record<'article', string>;
export const ARTICLE: QuestionCollection<ArticleIdentifierAnswer>[] = [
  {
    type: 'input',
    name: 'article',
    message: `Article identifier:`,
    validate: (value: string) => { return value ? true : 'Please enter the article identifier' }
  }
];

export type AnswersAboutComment = Record<'article', string> & Record<'version', string> & Record<'comment', string>;
export const COMMENT: QuestionCollection<AnswersAboutComment>[] = [
  {
    type: 'input',
    name: 'article',
    message: `Article identifier:`,
    validate: (value: string) => { return value ? true : 'Please enter the article identifier' }
  },
  {
    type: 'input',
    name: 'version',
    message: `Article version:`,
    default: 'version1',
    validate: (value: string) => { return value ? true : 'Please enter the article version' }
  },
  {
    type: 'input',
    name: 'comment',
    message: `Comment identifier:`,
    validate: (value: string) => { return value ? true : 'Please enter the comment identifier' }
  }
];
'''
'''--- CLI/src/helpers/types.ts ---
export type RecursivePartial<T> = { [P in keyof T]?: RecursivePartial<T[P]> };
export type ExecutionOptions = { silent: boolean, critical: boolean };
export type Failure = { success: false, errors?: string[] };
export type Success<T> = { success: true, response: T };
export type Response<T> = Failure | Success<T>;

export type HTTPEndpoint = string;
export enum HTTPMethod { GET = 'get', POST = 'post' };
export type HTTPHeaders = { [key: string]: any };
export type HTTPParameters = { [key: string]: any };

export type Article = { 'identifier': string, 'initial_version': string, 'signature': string, 'provider': string };
export type Comment = { 'article_identifier': string, 'version_identifier': string, 'comment_identifier': string, 'type': number, 'signature': string, 'provider': string };
'''
'''--- CLI/src/index.ts ---
import { SHUTDOWN_SIGNALS } from '@server/helpers/constants';
import { RegisterProcessShutdownListener, Shutdown, FORCE_EXIT_FUNCTION } from '@server/helpers/functions';
import { InitializeCLI } from '@server/controllers/cli';

async function Initialize(): Promise<void> {
    try {
        console.log('NEWS FOR TRUST (NFT)');
        console.log('********************');
        RegisterShutdownEvents();
        RegisterShutdownListeners();
        await InitializeCLI();
    } catch(error) {
        console.error('AN ERROR OCCURRED DURING INITIALIZATION');
		console.error(error);
		return await Shutdown();
    }
}

function RegisterShutdownEvents(): void {
    console.log('Registering shutdown events...');

    SHUTDOWN_SIGNALS.forEach((signal: NodeJS.Signals) => {
        process.on(signal, FORCE_EXIT_FUNCTION());
        process.on(signal, Shutdown);
    });

    process.on('beforeExit', FORCE_EXIT_FUNCTION());
    process.on('beforeExit', Shutdown);

    console.log('Shutdown events registered successfully');
}

function RegisterShutdownListeners(): void {
    console.log('Registering shutdown listeners...');
    // Add shutdown listeners here
    console.log('Shutdown listeners registered successfully');
}

Initialize();
'''
'''--- CLI/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2015",
    "module": "commonjs",
    "lib": ["ES2021", "dom"],
    "outDir": "./dist",
    "strict": true,
    "baseUrl": "./src",
    "paths": {"@server/*": ["*"]},
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "transform": "typescript-transform-paths"
      },
      {
        "transform": "typescript-transform-paths",
        "afterDeclarations": true
      }
    ]
  }
}

'''
'''--- CommentSubmission/index.html ---
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="#">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <title>Comment demo page</title>

  </head>
  <body>
    <h1>ChainedTrust :: Comment Demo Page</h1>

<section style="background-color: #eee;">
  <div class="container my-5 py-5">
    <div class="row d-flex justify-content-center">
      <div class="col-md-12 col-lg-10 col-xl-8">
        <div class="card">
          <div class="card-body">
            <div class="d-flex flex-start align-items-center">
              <img
                class="rounded-circle shadow-1-strong me-3"
                src="https://previews.123rf.com/images/cundrawan703/cundrawan7031207/cundrawan703120700008/14519717-dog-avatar-cartoon-character-icon.jpg"
                alt="avatar"
                width="60"
                height="60"
              />
              <div>
                <h6 class="fw-bold text-primary mb-1">Anne Onymous</h6>
                <p class="text-muted small mb-0">Unidentified contributor - Shared publicly - Nov 21</p>
              </div>
            </div>

            <p class="mt-3 mb-2 pb-2">
              I was today at the Geneva hospital, and there was NO ONE treated for COVID! I looked everywhere, not a single one. A nurse told me most of the doctors resigned because they would be forced to get jabbed to stay. And then they force us to wear masks? And get jabbed with a microchip for population control... Watch out, sheeple, Big G is coming for you.
            </p>
            <div class="small d-flex justify-content-start">
              <a href="#!" class="d-flex align-items-center me-3">
                <i class="far fa-thumbs-up me-2"></i>
                <p class="mb-4">Like</p>
              </a>
              <a href="#!" class="d-flex align-items-center me-3">
                <i class="far fa-comment-dots me-2"></i>
                <p class="mb-4">Comment</p>
              </a>
              <a href="#!" class="d-flex align-items-center me-3">
                <i class="fas fa-share me-2"></i>
                <p class="mb-4">Share</p>
              </a>
            </div>

            <div>
                <h6 class="fw-bold">We need your input on this, are you qualified?</h6>
            </div>

          <form onsubmit="post()">

            <div class="input-group">
                <button class="btn btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">Keys</button>
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item" href="#">Head of ICU, HUG</a></li>
                    <li><a class="dropdown-item" href="#">MD, HUG</a></li>
                    <li><a class="dropdown-item" href="#">Employee, HUG</a></li>
                </ul>
                <input type="text" class="form-control" id="exampleKey" placeholder="Identification Key...">
            </div>

            <div class="form-group">
                <label for="exampleComment"></label>
                <textarea class="form-control" id="exampleComment" rows="3" placeholder="Comment..."></textarea>
            </div>

            <div class="float-end mt-2 pt-1">
              <button type="submit" id="postComment" class="btn btn-primary btn-sm">Submit</button>
              <button type="button" class="btn btn-outline-primary btn-sm">Cancel</button>
            </div>

          </form>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
    -->

    <!--
    <script type="module" src="main.js"></script>
    <script nomodule src="main.js"></script>
    -->

    <script>
        function post() {
            let key = document.getElementById("exampleKey").value;
            let comment = document.getElementById("exampleComment").value;
            console.log(key,comment);
            return false;
        }
    </script>
  </body>
</html>

'''
'''--- CommentSubmission/main.js ---

/*
import { connect, WalletConnection } from "near-api-js";
import { init } from "@textile/near-storage";

function near() {
// Defaults to Testnet: https://near.github.io/near-api-js/modules/browserconnect.html
const near = await connect({ ... });

// Need to access wallet
const wallet = new WalletConnection(near, null);
// Request to sign into your amazing near smart-contract!
await wallet.requestSignIn({ contractId: "mycontract.testnet" });

const storage = init(wallet.account());

const blob = new Blob(["Hello, world!"], { type: "text/plain" });
const file = new File([blob], "welcome.txt", {
  type: "text/plain",
  lastModified: new Date().getTime(),
});

await storage.addDeposit();

const { id, cid } = await storage.store(file);

const { request, deals } = await storage.status(id)
console.log(request.status_code)
console.log([...deals])

await wallet.signOut();
}
*/

'''
'''--- CommentSubmission/package.json ---
{
  "dependencies": {
    "@textile/near-storage": "^8.0.0",
    "bootstrap": "^5.1.3",
    "lite-server": "^2.6.1",
    "near-api-js": "^0.42.0"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "lite-server"
  }
}

'''
'''--- Filecoin/Server/README.md ---
# Server

## Table of Contents

-   [Build](#build)
-   [Deploy](#deploy)
-   [Configuration](#configuration)
-   [Endpoints](#endpoints)
-   [License](#license)

## Build

To build this server, install npm packages:
```bash
$ npm install
```

Then start this script:
```bash
$ npm run build
```

## Deploy

You should first run a local network of Filecoin. This can be done by executing, from the __powergate__ folder:
```bash
$ make localnet
```

Then, deploy the server:
```bash
$ npm install && npm run deploy
```

## Endpoints
Two main endpoints are available.

The first one is:
```bash
$ GET http://<host>:<port>/data/:cid
```
(where :cid is the unique identifier of the content hosted on Filecoin)

The second one is:
```bash
$ POST http://<host>:<port>/data
```
(where the submitted data as part of the HTTP request is the content to be hosted on Filecoin)

## Configuration

A configuration file is available in __config/development.js__. Here, you can specify the endpoint used to connect to Powergate, itself connected to your Filecoin network running locally.

It is also possible to specify the endpoint of the server.

## License

[MIT](LICENSE)

'''
'''--- Filecoin/Server/config/custom-environment-variables.js ---
module.exports = {
    'core': {
        silent: 'CORE_SILENT_EXECUTION_MODE'
    },
    'powergate': {
        protocol: 'POWERGATE_PROTOCOL',
        host: 'POWERGATE_HOST',
        port: 'POWERGATE_PORT'
    },
    'server': {
        protocol: 'SERVER_PROTOCOL',
        host: 'SERVER_HOST',
        port: 'SERVER_PORT'
    }
};
'''
'''--- Filecoin/Server/config/development.js ---
module.exports = {
    'env': 'development',
    'core': {
        'silent': true
    },
    'powergate': {
        protocol: 'http',
        host: '0.0.0.0',
        port: 6002
    },
    'server': {
        protocol: 'http',
        host: 'localhost',
        port: 3002,
        authorized_clients: []
    }
};
'''
'''--- Filecoin/Server/package.json ---
{
  "name": "filecoin-storage-server",
  "version": "1.0",
  "description": "Filecoin server to store and retrieve data",
  "main": "./dist/index.js",
  "author": "Emmanuel Kellner, ArbÃ«r Salihi",
  "scripts": {
    "clean": "ttsc --build --clean && shx rm -rf dist",
    "build": "npm run clean && ttsc",
    "start": "node -r ts-node/register -r tsconfig-paths/register ./dist/index.js",
    "deploy": "npm run build && npm run start"
  },
  "devDependencies": {
    "@types/config": "^0.0.39",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/lodash": "^4.14.177",
    "@types/node": "^14.14.37",
    "@types/shelljs": "^0.8.9",
    "shx": "^0.3.3",
    "ts-loader": "^8.1.0",
    "tsconfig-paths": "^3.12.0",
    "ttypescript": "^1.5.12",
    "typescript": "^4.3.5",
    "typescript-transform-paths": "^2.2.3"
  },
  "dependencies": {
    "@textile/powergate-client": "0.1.0-beta.10",
    "config": "^3.3.6",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "lodash": "^4.17.21",
    "shelljs": "^0.8.4"
  }
}

'''
'''--- Filecoin/Server/src/controllers/orchestrator.ts ---
import { POWERGATE_INSTANCE, WatchJob } from '@server/controllers/powergate';

export async function AddContentToFilecoin(buffer: Uint8Array): Promise<string> {
    const { cid } = await POWERGATE_INSTANCE.ffs.addToHot(buffer);
    const { job } = await POWERGATE_INSTANCE.ffs.pushConfig(cid);
    await WatchJob(job);
    return cid;
}

export async function RetrieveContentFromFilecoin(cid: string): Promise<Buffer> {
    return await POWERGATE_INSTANCE.ffs.get(cid);
}
'''
'''--- Filecoin/Server/src/controllers/powergate.ts ---
import config from 'config';
import { createPow as create_powergate_instance, ffs } from '@textile/powergate-client';

export let POWERGATE_INSTANCE: any;

export async function InitializePowergate(): Promise<void> {
    console.log('Initializing Powergate instance...');
    const host: string = config.has('powergate.protocol') && config.has('powergate.host') && config.has('powergate.port') ? `${config.get('powergate.protocol')}://${config.get('powergate.host')}:${config.get('powergate.port')}` : 'http://0.0.0.0:6002';
    console.log(`Host: ${ host }`);
    POWERGATE_INSTANCE = create_powergate_instance({ host, debug: true });
    const { token } = await POWERGATE_INSTANCE.ffs.create();
    console.log('Powergate instance created');
    console.log('Setting token...')
    POWERGATE_INSTANCE.setToken(token);
    console.log('Powergate instance successfully initialized');
}

export async function WatchJob(identifier: string): Promise<void> {
    if(POWERGATE_INSTANCE) {
        return new Promise((resolve: () => void, reject: () => void) => {
            POWERGATE_INSTANCE.ffs.watchJobs((job: ffs.Job.AsObject) => {
                if (job.status === ffs.JobStatus.JOB_STATUS_CANCELED) {
                  console.warn(`[POWERGATE] Job canceled: ${identifier}`);
                  reject();
                } else if (job.status === ffs.JobStatus.JOB_STATUS_FAILED) {
                    console.error(`[POWERGATE] Job failed: ${identifier}`);
                    reject();
                } else if (job.status === ffs.JobStatus.JOB_STATUS_SUCCESS) {
                    console.log(`[POWERGATE] Job succeeded: ${identifier}`);
                    resolve();
                }
              }, identifier);
        }); 
    } else {
        throw new Error('Powergate instance not initialized');
    }
}
'''
'''--- Filecoin/Server/src/helpers/constants.ts ---
import config from 'config';

import { ExecutionOptions, RecursivePartial } from '@server/helpers/types';

export const DEFAULT_EXECUTION_OPTIONS: RecursivePartial<ExecutionOptions> = { silent: config.has('core.silent') ? config.get('core.silent') : true, critical: true };

export const SERVER_ENDPOINT: string = `${config.get('server.protocol')}://${config.get('server.host')}:${config.get('server.port')}`;

export const SHUTDOWN_SIGNALS: NodeJS.Signals[] = ['SIGABRT', 'SIGBUS', 'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM'];
export const TIMEOUT_BEFORE_FORCED_SHUTDOWN: number = 10000;
export const SHUTDOWN_LISTENERS: { operation: string, listener: () => any | Promise<any> }[] = [];
'''
'''--- Filecoin/Server/src/helpers/functions.ts ---
import { readFileSync } from 'fs';
import { omitBy as omit_by, isNil as is_nil } from 'lodash';
import { exec, ShellString } from 'shelljs';

import { ExecutionOptions, RecursivePartial } from '@server/helpers/types';
import { DEFAULT_EXECUTION_OPTIONS, TIMEOUT_BEFORE_FORCED_SHUTDOWN, SHUTDOWN_LISTENERS } from '@server/helpers/constants';

export function ExecuteCommand(command: string, options: RecursivePartial<ExecutionOptions> = DEFAULT_EXECUTION_OPTIONS): ShellString {
    options = Object.assign({}, DEFAULT_EXECUTION_OPTIONS, options);

    const result: ShellString = exec(command, { silent: options['silent'] });

    if (result.code !== 0) {
        console.log(result.stderr);

        if (options['critical']) {
            throw new Error(`An error occurred while executing command: ${command}`);
        }
        else return result;
    } else {
        if (options['silent'] === false) console.log(result.stdout);
        return result;
    }
}

export function RegisterProcessShutdownListener(operation: string, listener: () => any | Promise<any>): () => any | Promise<any> {
    SHUTDOWN_LISTENERS.push({ operation, listener });
    return listener;
}

export async function Shutdown(): Promise<void> {
    // console.clear();
    console.log('[CORE] Module is exiting gracefully...');

    for(const entry of SHUTDOWN_LISTENERS) {
        try {
            console.log(`[CORE] Executing operation: ${entry['operation']}`);
            await entry['listener']();
            console.log(`[CORE] Operation executed successfully: ${entry['operation']}`);
        } catch (error) {
            console.warn(`[CORE] Operation '${entry['operation']}' failed before completing: ${error}`);
        }
    }

    console.log('[CORE] All operations handled correctly. Exiting.');
    process.nextTick(() => process.exit(0));
}

export const FORCE_EXIT_FUNCTION = (timeout: number = TIMEOUT_BEFORE_FORCED_SHUTDOWN) => () => {
    setTimeout((): never => {
        console.warn(`[CORE] Module could not be stopped gracefully after ${timeout}ms: forcing shutdown`);
        return process.exit(1);
    }, timeout).unref();
};

export function ReadFile(location: string): Buffer {
    try {
        return readFileSync(location);
    } catch {
        throw new Error(`Could not read file: ${ location }`);
    }
}

// This function does not support complex objects where a custom function is needed to perform the sort
export function Sort(object: { [key: string]: any }): Object {
    return Object.keys(omit_by(object, is_nil)).sort().reduce((accumulator: Object, key: string) => {
        if (object[key]) {
            let element: any = (typeof object[key] == 'object') ? ((object[key] instanceof Array) ? [...object[key]].sort() : Sort(object[key])) : object[key];
            return { ...accumulator, [key]: element };
        } else {
            return { ...accumulator };
        }
    }, {});
}
'''
'''--- Filecoin/Server/src/helpers/types.ts ---
export type RecursivePartial<T> = { [P in keyof T]?: RecursivePartial<T[P]> };
export type ExecutionOptions = { silent: boolean, critical: boolean };
export type Failure = { success: false, errors?: string[] };
export type Success<T> = { success: true, response: T };
export type Response<T> = Failure | Success<T>;
'''
'''--- Filecoin/Server/src/index.ts ---
import { SHUTDOWN_SIGNALS } from '@server/helpers/constants';
import { RegisterProcessShutdownListener, Shutdown, FORCE_EXIT_FUNCTION } from '@server/helpers/functions';
import { InitializePowergate } from '@server/controllers/powergate';
import { Server, InitializeServer } from '@server/server/server';

async function Initialize(): Promise<void> {
    try {
        console.log('FILECOIN SERVER');
        console.log('***************');
        RegisterShutdownEvents();
        RegisterShutdownListeners();
        await InitializePowergate();
        await InitializeServer();
    } catch(error) {
        console.error('AN ERROR OCCURRED DURING INITIALIZATION');
		console.error(error);
		return await Shutdown();
    }
}

function RegisterShutdownEvents(): void {
    console.log('Registering shutdown events...');

    SHUTDOWN_SIGNALS.forEach((signal: NodeJS.Signals) => {
        process.on(signal, FORCE_EXIT_FUNCTION());
        process.on(signal, Shutdown);
    });

    process.on('beforeExit', FORCE_EXIT_FUNCTION());
    process.on('beforeExit', Shutdown);

    console.log('Shutdown events registered successfully');
}

function RegisterShutdownListeners(): void {
    console.log('Registering shutdown listeners...');

    RegisterProcessShutdownListener('server shutdown', async () => Server.close());

    console.log('Shutdown listeners registered successfully');
}

Initialize();
'''
'''--- Filecoin/Server/src/server/cors.ts ---
import config from 'config';
import cors = require('cors');

export const CORS_STRATEGY = cors({
	origin: (origin: string | undefined, callback: (error: Error | null, allow?: boolean) => void) => {
		if (!origin) callback(null, false);
		else VerifyCORS(origin, callback);
	}, credentials: true
});

const AUTHORIZED_ENDPOINTS: string[] = config.has('server.authorized_clients') ? config.get('server.authorized_clients') : [];

function VerifyCORS(origin: string, callback: (error: any, success: boolean) => void): void {
    if (AUTHORIZED_ENDPOINTS.includes(origin!)) {
        callback(null, true);
    } else {
        callback(null, false);
    };
}
'''
'''--- Filecoin/Server/src/server/express.ts ---
import express from 'express';

import { CORS_STRATEGY } from '@server/server/cors';
import { Router as LocalRouter } from '@server/server/router';

const server: express.Express = express();

server.use(express.urlencoded({ extended: true }));
server.use(express.urlencoded({ extended: false }));
server.use(express.json());
server.use(CORS_STRATEGY);
server.use('/', LocalRouter);

export { server as ExpressServer };
'''
'''--- Filecoin/Server/src/server/router.ts ---
import { Router } from 'express';

import { Routes } from '@server/server/routes';

const router: Router = Router({ mergeParams: true });

router.use('/', Routes);

export { router as Router };
'''
'''--- Filecoin/Server/src/server/routes.ts ---
import { AddContentToFilecoin, RetrieveContentFromFilecoin } from '@server/controllers/orchestrator';
import { NextFunction, Request, Response, Router } from 'express';

const router: Router = Router({ mergeParams: true });

router.get('/data/:cid', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const cid: string = req.params['cid'];

	try {
		const buffer: Buffer = await RetrieveContentFromFilecoin(cid);
		res.status(200).send(JSON.parse(buffer.toString()));
	} catch(error) {
		console.error(`[SERVER] Error while retrieving data from Filecoin: ${ error }`);
		res.status(500).send('An internal error occurred while retrieving data from Filecoin');
	}
});

router.post('/data', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const data: any = req.body;

	if(!data['content']) {
		res.status(404).send('Malformed request');
	} else {
		try {
			const cid: string = await AddContentToFilecoin(Buffer.from(JSON.stringify(data['content'])));
			res.status(200).send({ cid });
		} catch(error) {
			console.error(`[SERVER] Error while storing data on Filecoin: ${ error }`);
			res.status(500).send('An internal error occurred while registering data on Filecoin');
		}
	}
});

export { router as Routes };
'''
'''--- Filecoin/Server/src/server/server.ts ---
import config from 'config';
import { Server } from 'http';

import { ExpressServer } from '@server/server/express';
import { SERVER_ENDPOINT } from '@server/helpers/constants';

const server: Server = new Server(ExpressServer);

export async function InitializeServer(): Promise<void> {
    console.log('Initializing server...');
    server.listen(config.get('server.port'), () => { console.log(`Server started: ${SERVER_ENDPOINT}`) });
}

export { server as Server };
'''
'''--- Filecoin/Server/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2015",
    "module": "commonjs",
    "lib": ["ES2021", "dom"],
    "outDir": "./dist",
    "strict": true,
    "baseUrl": "./src",
    "paths": {"@server/*": ["*"]},
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "transform": "typescript-transform-paths"
      },
      {
        "transform": "typescript-transform-paths",
        "afterDeclarations": true
      }
    ]
  }
}

'''
'''--- Filecoin/powergate/CONTRIBUTING.md ---
# Contributing guidelines

'''
'''--- Filecoin/powergate/README.md ---
# Powergate

[![Made by Textile](https://img.shields.io/badge/made%20by-Textile-informational.svg?style=popout-square)](https://textile.io)
[![Chat on Slack](https://img.shields.io/badge/slack-slack.textile.io-informational.svg?style=popout-square)](https://slack.textile.io)
[![GitHub license](https://img.shields.io/github/license/textileio/filecoin.svg?style=popout-square)](./LICENSE)
[![Go Report Card](https://goreportcard.com/badge/github.com/textileio/powergate?style=flat-square)](https://goreportcard.com/report/github.com/textileio/powergate?style=flat-square)
[![GitHub action](https://github.com/textileio/powergate/workflows/Tests/badge.svg?style=popout-square)](https://github.com/textileio/powergate/actions)

Powergate is a multitiered file storage API built on Filecoin and IPFS, and an index builder for Filecoin data. It's designed to be modular and extensible.

Join us on our [public Slack channel](https://slack.textile.io/) for news, discussions, and status updates. [Check out our blog](https://medium.com/textileio) for the latest posts and announcements.

*Warning* This project is still **pre-release** and is not ready for production usage.

## Table of Contents

-   [Prerequisites](#prerequisites)
-   [Design](#design)
-   [Installation](#installation)
-   [Localnet mode](#localnet-mode)
-   [Production setup](#production-setup)
-   [Tests](#tests)
-   [Benchmark](#benchmark)
-   [Contributing](#contributing)
-   [Changelog](#changelog)
-   [License](#license)

## Prerequisites

To build from source, you need to have Go 1.14 or newer installed.

## Design

Powergate is composed of different modules which can be used independently, and compose together to provide other higher-level modules.

Here's a high-level overview of the main components, and how Powergate interacts with IPFS and a Filecoin client:
![Powergate Design](https://user-images.githubusercontent.com/6136245/86490337-6dbd5200-bd3d-11ea-9895-3689dd1c8a8f.png)

Note in the diagram that the Lotus and Filecoin client node _doesn't need_ to be in the same host where Powergate is running. They can, but isn't necessary.

### ð¢ Deals module
The Deals module provides a lower layer of abstraction to a Filecoin client node. It provides simple APIs to store, watch, and retrieve data in the Filecoin network. Currently, it interacts with the Lotus client but we have plans to support other Filecoin clients.

### ð· Indices and Reputation scoring
Powergate builds three indexes related to on-chain and off-chain data.

The _Miners index_ provides processed data regarding registered miners (on-chain and off-chain), such as: total miner power, relative power, online status, geolocation, and more!

The _Ask index_ provides a fast-retrieval up to date snapshot of miner's asking prices for data storage.

The _Faults index_ provides history data about miners faults while proving their storage on-chain. 

Built on top of the previous indexes, a _Reputation_ module constructs a weighted-scoring system that allows to sort miners considering multiple on-chain and off-chain data, such as: compared price to the median of the market, low storage-fault history, power on network, and external sources (soon!).

###  â¡ FFS
This module provides a multitiered file storage API built on Filecoin and IPFS. Storing data on IPFS and Filecoin is as easy as expressing your desired configuration for storing a Cid.

Want to know more about this Powergate module? Check out the [FFS design document](https://github.com/textileio/powergate/blob/master/ffs/Design.md) and our presentation and demo at the _IPFS Pinning Summit_:

[![Video](https://img.youtube.com/vi/aiOTSkz_6aY/0.jpg)](https://youtu.be/aiOTSkz_6aY)

### ð« API + CLI

Powergate exposes an API built from the various modules through gRPC endpoints. 
You can explore our [`.proto` files](https://github.com/textileio/powergate/tree/master/proto/powergate) to generate your clients, or take advange of a ready-to-use Powergate Go and [JS client](https://github.com/textileio/js-powergate-client). ð

We have a CLI that supports most of Powergate features.

To build and install the CLI, run:
```bash
$ make install-pow
```
The binary will be placed automatically in `$GOPATH/bin`. You may have to set the Path variables using the below commands
```bash
$ export PATH=$PATH:$(go env GOPATH)/bin
$ export GOPATH=$(go env GOPATH)
```
You can then run `pow` in your terminal.

You can read the [generated CLI docs](https://github.com/textileio/powergate/blob/master/cli-docs/pow/pow.md) in this repo, or run `pow` with the `--help` flag to see the available commands:

```
$ pow --help
A client for storage and retreival of powergate data

Usage:
  pow [flags]
  pow [command]

Available Commands:
  admin        Provides admin commands
  config       Provides commands to interact with cid storage configs
  data         Provides commands to interact with general data APIs
  deals        Provides commands to view Filecoin deal information
  help         Help about any command
  id           Returns the user id
  storage-jobs Provides commands to query for storage jobs in various states
  version      Display version information for pow and the connected server
  wallet       Provides commands about filecoin wallets

Flags:
  -h, --help                   help for pow
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
  -v, --version                display version information for pow and the connected server

Use "pow [command] --help" for more information about a command.
```

## Installation

Powergate installation involves running external dependencies, and wiring them correctly with Powergate.

### External dependencies
Powergate needs external dependencies in order to provide full functionality, in particular a synced Filecoin client and a IPFS node.

#### Filecoin client
Currently, we support the Lotus Filecoin client but we plan to support other clients.

All described modules of Powergate need to comunicate with Lotus to build indices data, and provide storing and retrieving features in FFS. To install Lotus refer to its [official](https://lotu.sh/) documentation, taking special attention to [its dependencies](https://docs.lotu.sh/en+install-lotus-ubuntu). 

Fully syncing a Lotus node can take time, so be sure to check you're fully synced doing `./lotus sync status`.

We also automatically generate a public Docker image targeting the `master` branch of Lotus. This image is a pristine version of Lotus, with a sidecar reverse proxy to provide external access to the containerized API. For more information, refer to [textileio/lotus-build](https://github.com/textileio/lotus-build) and its [Dockerhub repository](https://hub.docker.com/repository/docker/textile/lotus).

In short, a fully-synced Lotus node should be available with its API (`127.0.0.1:1234`, by default) port accessible to Powergate.

### IPFS node
A running IPFS node is needed if you plan to use the FFS module.

If that's the case, you can refer [here](https://docs.ipfs.io/guides/guides/install/) for installation instructions, or its [Dockerhub repository](https://hub.docker.com/r/ipfs/go-ipfs) if you want to run a contanerized version. Currently we're supporting v0.5.1. The API endpoint should be accessible to Powergate (port 5001, by default). 

Since FFS _HotStorage_ is pinning Cids in the IPFS node, Powergate should be the only party controlling the pinset of the node. Other systems can share the same IPFS node if can  **guarantee** not unpinning Cids pinned by Powergate FFS instances. 

### Geolite database
Powergate needs an offline geo-location database to resolve miners country using their IP address. The same folder in which `powd` is executing, should have the Geolite2 database file `GeoLite2-City.mmdb` or you can pass the `--maxminddbfolder` flag to `powd` to specify the path of the folder containing `GeoLite2-City.mmdb`.
You can copy this file from the GitHub repo at `iplocation/maxmind/GeoLite2-City.mmdb`. If you run Powergate using Docker, this database is bundeled in the image so isn't necessary to have extra considerations.

### Server
To build and install the Powergate server, run:
```bash
make install-powd
```
You can run the `-h` flag to see the configurable flags:
```bash
$ powd -h 
Usage of powd:
      --askindexmaxparallel string       Max parallel query ask to execute while updating index (default "3")
      --askindexqueryasktimeout string   Timeout in seconds for a query ask (default "15")
      --askindexrefreshinterval string   Refresh interval measured in minutes (default "60")
      --askindexrefreshonstart           If true it will refresh the index on start
      --autocreatemasteraddr             Automatically creates & funds a master address if none is provided.
      --dealwatchpollduration string     Poll interval in seconds used by Deals Module watch to detect state changes (default "900")
      --debug                            Enable debug log level in all loggers.
      --devnet                           Indicate that will be running on an ephemeral devnet. --repopath will be autocleaned on exit.
      --disableindices                   Disable all indices updates, useful to help Lotus syncing process
      --disablenoncompliantapis          Disable APIs that may not easily comply with US law
      --ffsadmintoken string             FFS admin token for authorized APIs. If empty, the APIs will be open to the public.
      --ffsdealfinalitytimeout string    Deadline in minutes in which a deal must prove liveness changing status before considered abandoned (default "4320")
      --ffsminerselector string          Miner selector to be used by FFS: 'sr2', 'reputation' (default "sr2")
      --ffsminerselectorparams string    Miner selector configuration parameter, depends on --ffsminerselector (default "https://raw.githubusercontent.com/filecoin-project/slingshot/master/miners.json")
      --ffsminimumpiecesize string       Minimum piece size in bytes allowed to be stored in Filecoin (default "67108864")
      --ffsschedmaxparallel string       Maximum amount of Jobs executed in parallel (default "1000")
      --ffsusemasteraddr                 Use the master address as the initial address for all new FFS instances instead of creating a new unique addess for each new FFS instance.
      --gatewaybasepath string           Gateway base path. (default "/")
      --gatewayhostaddr string           Gateway host listening address. (default "0.0.0.0:7000")
      --grpchostaddr string              gRPC host listening address. (default "/ip4/0.0.0.0/tcp/5002")
      --grpcwebproxyaddr string          gRPC webproxy listening address. (default "0.0.0.0:6002")
      --ipfsapiaddr string               IPFS API endpoint multiaddress. (Optional, only needed if FFS is used) (default "/ip4/127.0.0.1/tcp/5001")
      --lotushost string                 Lotus client API endpoint multiaddress. (default "/ip4/127.0.0.1/tcp/1234")
      --lotusmasteraddr string           Existing wallet address in Lotus to be used as source of funding for new FFS instances. (Optional)
      --lotustoken string                Lotus API authorization token. This flag or --lotustoken file are mandatory.
      --lotustokenfile string            Path of a file that contains the Lotus API authorization token.
      --maxminddbfolder string           Path of the folder containing GeoLite2-City.mmdb (default ".")
      --mongodb string                   Mongo database name. (if --mongouri is used, is mandatory
      --mongouri string                  Mongo URI to connect to MongoDB database. (Optional: if empty, will use Badger)
      --repopath string                  Path of the repository where Powergate state will be saved. (default "~/.powergate")
      --walletinitialfund int            FFS initial funding transaction amount in attoFIL received by --lotusmasteraddr. (if set) (default 250000000000000000)
```

## Localnet mode

Having a fully synced Lotus node can take a considerable amount of time and effort to mantain. We have built [lotus-devnet](https://github.com/textileio/lotus-devnet) which runs a local network with a _sectorbuilder_ mock. This provides a fast way to spinup a local network where the sealing process if mocked, but the rest of the node logic is the same as production The _localnet_ supports both 2Kib and 512Kib sectors, and the speed of block production is configurable. Refer to [lotus-devnet](https://github.com/textileio/lotus-devnet) readme for more information.

If you're interested in running Powergate and experiment with the CLI, the fastest way is to replace the Lotus client dependency with a running localnet, which runs a local Lotus client connected to a network with local miners. 

A simple docker-compose setup is available that will run Powergate connected to a Lotus local network with 512Mib sectors and allows to use the gRPC API or CLI without any extra config flags! ð  Note: you will first need to [install Docker compose](https://docs.docker.com/compose/install/) in order to get started.
```bash
cd docker
make localnet
```
This will build Powergate `powd`, a Lotus local network with `BIGSECTORS=true` by default, an IPFS node and wire them correctly to be ready to use.

**Note**: Running `BIGSECTORS=false make localnet` will create the Lotus devent using 2Kib sectors. This may be more appropriate for certain development or testing scenarios. 

Here is a full example of using the local network:
Terminal 1:
```bash
cd docker
make localnet
```

Wait for seeing logs about the height of the chain increase in a regular cadence.

Terminal 2:
```bash
make build
â¯ head -c 700 </dev/urandom > myfile
â¯ pow admin user create
{
  "user":  {
    "id":  "c06382e0-2021-4234-be53-6e07a8d40065",
    "token":  "883f57b1-4e66-47f8-b291-7cf8b10f6370"
  }
}
â¯ pow data stage -t 883f57b1-4e66-47f8-b291-7cf8b10f6370 myfile
{
  "cid":  "QmQJxVtp61Y7UrdjUKuWvse3TxGHaPDyA7RobrBhFwqcBM"
}
â¯ pow config apply -w -t 883f57b1-4e66-47f8-b291-7cf8b10f6370 QmYaAK8SSsKJsJdtahCbUe7MZzQdkPBybFCcQJJ3dKZpfm
{
  "jobId":  "b4110048-5367-4ae5-8508-709bf7969748"
}
                 JOB ID                |       STATUS       | MINER  |  PRICE   |    DEAL STATUS     
---------------------------------------+--------------------+--------+----------+--------------------
  b4110048-5367-4ae5-8508-709bf7969748 | JOB_STATUS_SUCCESS |        |          |                    
                                       |                    | f01000 | 62500000 | StorageDealActive
â¯ pow data get -t 883f57b1-4e66-47f8-b291-7cf8b10f6370 QmYaAK8SSsKJsJdtahCbUe7MZzQdkPBybFCcQJJ3dKZpfm myfile2
> Success! Data written to myfile2
```

In this example we created a random 700 bytes file for the test, but since the localnet supports 512Mib sectors you can store store bigger files.

## Production setup

A production setup is also provided in the `docker` folder. It launches `powd` connected to `lotus` and `ipfs`, plus a set of monitoring components:
- _Prometheus_, which is the backend for metrics processing.
- _Grafana_, for metrics dashboard.
- _cAdvisor_, for container metrics.
- _Lotus_, node running on the current mainnet.
- _IPFS_, node running to back Powergate FFS.
- _Powergate_, wired with all of above components.

Depending on which network you want to connect to, you have to run different commands:
- `make up`, to connect to `mainnet`.

Remember that you should wait for _Lotus_ to be fully-synced which might take a long time; you can check your current node sync status running `lotus sync status` inside the Lotus container. We also provide automatically generated Dockerhub images of Powergate server, see [textile/powergate](https://hub.docker.com/r/textile/powergate).

If you're interested in a more detailed explanation about Powergate installation, please refer to the [installation docs](docs/manual_installation.md).

## Tests
We have a big set of tests for covering most important Powergate features.

For integration tests, we leverage our `textileio/lotus-devnet` configured with 2Kib sectors to provide fast iteration and CI runs.

If you want to run tests locally:
```bash
make test
```
It will auto-download any necessary dependencies and run all tests.

## Benchmark
There's a dedicated binary to run benchmarks against a Powergate server. For more information see the [specific README](cmd/powbench/README.md). 

Soon we'll add benchmark results against real miners in mainnet, so stay tuned. â 

## Contributing

This project is a work in progress. As such, there's a few things you can do right now to help out:

-   **Ask questions**! We'll try to help. Be sure to drop a note (on the above issue) if there is anything you'd like to work on and we'll update the issue to let others know. Also [get in touch](https://slack.textile.io) on Slack.
-   **Open issues**, [file issues](https://github.com/textileio/powergate/issues), submit pull requests!
-   **Perform code reviews**. More eyes will help a) speed the project along b) ensure quality and c) reduce possible future bugs.
-   **Take a look at the code**. Contributions here that would be most helpful are **top-level comments** about how it should look based on your understanding. Again, the more eyes the better.
-   **Add tests**. There can never be enough tests.

Before you get started, be sure to read our [contributors guide](./CONTRIBUTING.md) and our [contributor covenant code of conduct](./CODE_OF_CONDUCT.md).

## Changelog

[Changelog is published to Releases.](https://github.com/textileio/powergate/releases)

## License

[MIT](LICENSE)

'''
'''--- Filecoin/powergate/api/client/admin/admin.go ---
package admin

import (
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// Admin provides access to Powergate admin APIs.
type Admin struct {
	StorageJobs *StorageJobs
	StorageInfo *StorageInfo
	Users       *Users
	Wallet      *Wallet
	Data        *Data
	Records     *Records
	Indices     *Indices
}

// NewAdmin creates a new admin API.
func NewAdmin(client adminPb.AdminServiceClient) *Admin {
	return &Admin{
		StorageJobs: &StorageJobs{client: client},
		StorageInfo: &StorageInfo{client: client},
		Users:       &Users{client: client},
		Wallet:      &Wallet{client: client},
		Data:        &Data{client: client},
		Records:     &Records{client: client},
		Indices:     &Indices{client: client},
	}
}

'''
'''--- Filecoin/powergate/api/client/admin/data.go ---
package admin

import (
	"context"

	proto "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// Data provides access to Powergate data admin APIs.
type Data struct {
	client proto.AdminServiceClient
}

// GCStaged unpins staged data not related to queued or executing jobs.
func (w *Data) GCStaged(ctx context.Context) (*proto.GCStagedResponse, error) {
	return w.client.GCStaged(ctx, &proto.GCStagedRequest{})
}

// PinnedCids returns pinned cids information of hot-storage.
func (w *Data) PinnedCids(ctx context.Context) (*proto.PinnedCidsResponse, error) {
	return w.client.PinnedCids(ctx, &proto.PinnedCidsRequest{})
}

'''
'''--- Filecoin/powergate/api/client/admin/indices.go ---
package admin

import (
	"context"
	"fmt"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// Indices provides APIs to fetch indices data.
type Indices struct {
	client adminPb.AdminServiceClient
}

// GetMiners return a list of miner addresses that satisfies the provided filters.
func (i *Indices) GetMiners(ctx context.Context, opts ...GetMinersOption) (*adminPb.GetMinersResponse, error) {
	cfg := defaultCfgGetMiners
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			return nil, fmt.Errorf("applying configuration option: %s", err)
		}
	}
	req := &adminPb.GetMinersRequest{
		WithPower: cfg.withPower,
	}

	return i.client.GetMiners(ctx, req)
}

// GetMinerInfo returns all known indices data for the provider miner addresses.
func (i *Indices) GetMinerInfo(ctx context.Context, miners ...string) (*adminPb.GetMinerInfoResponse, error) {
	req := &adminPb.GetMinerInfoRequest{
		Miners: miners,
	}

	return i.client.GetMinerInfo(ctx, req)
}

'''
'''--- Filecoin/powergate/api/client/admin/options.go ---
package admin

var (
	defaultCfgGetMiners = cfgGetMiners{
		withPower: true,
	}
)

type cfgGetMiners struct {
	withPower bool
}

// GetMinersOption configures filters for getting miners.
type GetMinersOption func(*cfgGetMiners) error

// WithPowerGreaterThanZero filters miners that have power greater
// than zero.
func WithPowerGreaterThanZero(withPower bool) GetMinersOption {
	return func(cfg *cfgGetMiners) error {
		cfg.withPower = withPower
		return nil
	}
}

'''
'''--- Filecoin/powergate/api/client/admin/records.go ---
package admin

import (
	"context"
	"time"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// Records provides APIs to fetch generated records from the deals module.
type Records struct {
	client adminPb.AdminServiceClient
}

// GetUpdatedRetrievalRecordsSince returns the retrieval records that
// were created or modified since the specified date.
func (c *Records) GetUpdatedRetrievalRecordsSince(ctx context.Context, since time.Time, limit int) (*adminPb.GetUpdatedRetrievalRecordsSinceResponse, error) {
	req := &adminPb.GetUpdatedRetrievalRecordsSinceRequest{
		Since: timestamppb.New(since),
		Limit: int32(limit),
	}
	return c.client.GetUpdatedRetrievalRecordsSince(ctx, req)
}

// GetUpdatedStorageDealRecordsSince returns the storage-deal records that
// were created or modified since the specified date.
func (c *Records) GetUpdatedStorageDealRecordsSince(ctx context.Context, since time.Time, limit int) (*adminPb.GetUpdatedStorageDealRecordsSinceResponse, error) {
	req := &adminPb.GetUpdatedStorageDealRecordsSinceRequest{
		Since: timestamppb.New(since),
		Limit: int32(limit),
	}
	return c.client.GetUpdatedStorageDealRecordsSince(ctx, req)
}

'''
'''--- Filecoin/powergate/api/client/admin/storageinfo.go ---
package admin

import (
	"context"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// StorageInfo provides access to Powergate storage indo APIs.
type StorageInfo struct {
	client adminPb.AdminServiceClient
}

// Get returns the information about a stored Cid. If no information is available,
// since the Cid was never stored, it returns an error with codes.NotFound.
func (s *StorageInfo) Get(ctx context.Context, userID, cid string) (*adminPb.StorageInfoResponse, error) {
	return s.client.StorageInfo(ctx, &adminPb.StorageInfoRequest{UserId: userID, Cid: cid})
}

// List returns a list of information about all stored cids, filtered by user ids and cids if provided.
func (s *StorageInfo) List(ctx context.Context, userIDs, cids []string) (*adminPb.ListStorageInfoResponse, error) {
	return s.client.ListStorageInfo(ctx, &adminPb.ListStorageInfoRequest{UserIds: userIDs, Cids: cids})
}

'''
'''--- Filecoin/powergate/api/client/admin/storagejobs.go ---
package admin

import (
	"context"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

// StorageJobs provides access to Powergate jobs admin APIs.
type StorageJobs struct {
	client adminPb.AdminServiceClient
}

// ListSelect specifies which StorageJobs to list.
type ListSelect int32

const (
	// All lists all StorageJobs and is the default.
	All ListSelect = iota
	// Queued lists queued StorageJobs.
	Queued
	// Executing lists executing StorageJobs.
	Executing
	// Final lists final StorageJobs.
	Final
)

// ListConfig controls the behavior for listing StorageJobs.
type ListConfig struct {
	// UserIDFilter filters StorageJobs list to the specified user ID. Defaults to no filter.
	UserIDFilter string
	// CidFilter filters StorageJobs list to the specified cid. Defaults to no filter.
	CidFilter string
	// Limit limits the number of StorageJobs returned. Defaults to no limit.
	Limit uint64
	// Ascending returns the StorageJobs ascending by time. Defaults to false, descending.
	Ascending bool
	// Select specifies to return StorageJobs in the specified state.
	Select ListSelect
	// NextPageToken sets the slug from which to start building the next page of results.
	NextPageToken string
}

type summaryConfig struct {
	userID string
	cid    string
}

// SummaryOption configures a storageJobsConfig.
type SummaryOption = func(*summaryConfig)

// WithUserID filters the results to the specified user.
func WithUserID(userID string) SummaryOption {
	return func(conf *summaryConfig) {
		conf.userID = userID
	}
}

// WithCid filters the results to the specified data cid.
func WithCid(cid string) SummaryOption {
	return func(conf *summaryConfig) {
		conf.cid = cid
	}
}

// List lists StorageJobs according to the provided ListConfig.
func (j *StorageJobs) List(ctx context.Context, config ListConfig) (*adminPb.ListStorageJobsResponse, error) {
	sel := userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED
	switch config.Select {
	case All:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_ALL
	case Queued:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_QUEUED
	case Executing:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_EXECUTING
	case Final:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_FINAL
	}
	req := &adminPb.ListStorageJobsRequest{
		CidFilter:     config.CidFilter,
		Limit:         config.Limit,
		Ascending:     config.Ascending,
		NextPageToken: config.NextPageToken,
		Selector:      sel,
	}
	return j.client.ListStorageJobs(ctx, req)
}

// Summary returns a summary of storage jobs.
func (j *StorageJobs) Summary(ctx context.Context, opts ...SummaryOption) (*adminPb.StorageJobsSummaryResponse, error) {
	conf := &summaryConfig{}
	for _, opt := range opts {
		opt(conf)
	}
	req := &adminPb.StorageJobsSummaryRequest{
		UserId: conf.userID,
		Cid:    conf.cid,
	}
	return j.client.StorageJobsSummary(ctx, req)
}

'''
'''--- Filecoin/powergate/api/client/admin/users.go ---
package admin

import (
	"context"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// Users provides access to Powergate admin users APIs.
type Users struct {
	client adminPb.AdminServiceClient
}

// Create creates a new Powergate user, returning the user ID and auth token.
func (p *Users) Create(ctx context.Context) (*adminPb.CreateUserResponse, error) {
	return p.client.CreateUser(ctx, &adminPb.CreateUserRequest{})
}

// RegenerateAuth invalidates an existing token replacing it with a new one.
func (p *Users) RegenerateAuth(ctx context.Context, token string) (*adminPb.RegenerateAuthResponse, error) {
	return p.client.RegenerateAuth(ctx, &adminPb.RegenerateAuthRequest{Token: token})
}

// List returns a list of existing users.
func (p *Users) List(ctx context.Context) (*adminPb.UsersResponse, error) {
	return p.client.Users(ctx, &adminPb.UsersRequest{})
}

'''
'''--- Filecoin/powergate/api/client/admin/wallet.go ---
package admin

import (
	"context"
	"math/big"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// Wallet provides access to Powergate wallet admin APIs.
type Wallet struct {
	client adminPb.AdminServiceClient
}

// NewAddress creates a new address.
func (w *Wallet) NewAddress(ctx context.Context, addrType string) (*adminPb.NewAddressResponse, error) {
	req := &adminPb.NewAddressRequest{
		AddressType: addrType,
	}
	return w.client.NewAddress(ctx, req)
}

// Addresses lists all addresses associated with this Powergate.
func (w *Wallet) Addresses(ctx context.Context) (*adminPb.AddressesResponse, error) {
	return w.client.Addresses(ctx, &adminPb.AddressesRequest{})
}

// SendFil sends FIL from an address associated with this Powergate to any other address.
func (w *Wallet) SendFil(ctx context.Context, from, to string, amount *big.Int) (*adminPb.SendFilResponse, error) {
	req := &adminPb.SendFilRequest{
		From:   from,
		To:     to,
		Amount: amount.String(),
	}
	return w.client.SendFil(ctx, req)
}

'''
'''--- Filecoin/powergate/api/client/admin_test.go ---
package client

import (
	"context"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/api/client/admin"
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	ctx = context.Background()
)

func TestCreate(t *testing.T) {
	t.Run("WithoutAdminToken", func(t *testing.T) {
		a, done := setupAdmin(t, "")
		defer done()

		resp, err := a.Users.Create(ctx)
		require.NoError(t, err)
		require.NotEmpty(t, resp.User.Id)
		require.NotEmpty(t, resp.User.Token)
	})

	t.Run("WithAdminToken", func(t *testing.T) {
		authToken := uuid.New().String()
		a, done := setupAdmin(t, authToken)
		defer done()

		t.Run("UnauthorizedEmpty", func(t *testing.T) {
			resp, err := a.Users.Create(ctx)
			require.Error(t, err)
			require.Nil(t, resp)
		})

		t.Run("UnauthorizedWrong", func(t *testing.T) {
			wrongAuths := []string{
				"",      // Empty
				"wrong", // Non-empty
			}
			for _, auth := range wrongAuths {
				ctx := context.WithValue(ctx, AdminKey, auth)
				resp, err := a.Users.Create(ctx)
				st, ok := status.FromError(err)
				require.True(t, ok)
				require.Equal(t, codes.PermissionDenied, st.Code())
				require.Nil(t, resp)
			}
		})
		t.Run("Authorized", func(t *testing.T) {
			ctx := context.WithValue(ctx, AdminKey, authToken)
			resp, err := a.Users.Create(ctx)
			require.NoError(t, err)
			require.NotEmpty(t, resp.User.Id)
			require.NotEmpty(t, resp.User.Token)
		})
	})
}

func setupAdmin(t *testing.T, adminAuthToken string) (*admin.Admin, func()) {
	defConfig := defaultServerConfig(t)
	if adminAuthToken != "" {
		defConfig.FFSAdminToken = adminAuthToken
	}
	serverDone := setupServer(t, defConfig)
	conn, done := setupConnection(t, defConfig.GrpcHostAddress)
	return admin.NewAdmin(adminPb.NewAdminServiceClient(conn)), func() {
		done()
		serverDone()
	}
}

'''
'''--- Filecoin/powergate/api/client/client.go ---
package client

import (
	"context"
	"crypto/tls"
	"strings"

	"github.com/textileio/powergate/v2/api/client/admin"
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
)

// Client provides the client api.
type Client struct {
	StorageConfig *StorageConfig
	Data          *Data
	Wallet        *Wallet
	Deals         *Deals
	StorageInfo   *StorageInfo
	StorageJobs   *StorageJobs
	Admin         *admin.Admin
	conn          *grpc.ClientConn
	client        userPb.UserServiceClient
}

type ctxKey string

// AuthKey is the key that should be used to set the auth token in a Context.
const AuthKey = ctxKey("ffstoken")

// AdminKey is the key that should be used to set the admin auth token in a Context.
const AdminKey = ctxKey("admintoken")

// TokenAuth provides token based auth.
type TokenAuth struct {
	Secure bool
}

// GetRequestMetadata returns request metadata that includes the auth token.
func (t TokenAuth) GetRequestMetadata(ctx context.Context, _ ...string) (map[string]string, error) {
	md := map[string]string{}

	token, ok := ctx.Value(AuthKey).(string)
	if ok && token != "" {
		md["X-ffs-Token"] = token
	}

	adminToken, ok := ctx.Value(AdminKey).(string)
	if ok && adminToken != "" {
		md["X-pow-admin-token"] = adminToken
	}

	return md, nil
}

// RequireTransportSecurity specifies if the connection should be secure.
func (t TokenAuth) RequireTransportSecurity() bool {
	return t.Secure
}

// CreateClientConn creates a gRPC connection with sensible defaults and the provided overrides.
func CreateClientConn(target string, optsOverrides ...grpc.DialOption) (*grpc.ClientConn, error) {
	var creds credentials.TransportCredentials
	if strings.Contains(target, "443") {
		creds = credentials.NewTLS(&tls.Config{})
	}

	auth := TokenAuth{}
	var opts []grpc.DialOption
	if creds != nil {
		opts = append(opts, grpc.WithTransportCredentials(creds))
		auth.Secure = true
	} else {
		opts = append(opts, grpc.WithInsecure())
	}

	opts = append(opts, grpc.WithPerRPCCredentials(auth))
	opts = append(opts, optsOverrides...)

	conn, err := grpc.Dial(target, opts...)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// NewClient creates a client.
func NewClient(host string, optsOverrides ...grpc.DialOption) (*Client, error) {
	conn, err := CreateClientConn(host, optsOverrides...)
	if err != nil {
		return nil, err
	}
	client := userPb.NewUserServiceClient(conn)
	return &Client{
		StorageConfig: &StorageConfig{client: client},
		Data:          &Data{client: client},
		Wallet:        &Wallet{client: client},
		Deals:         &Deals{client: client},
		StorageInfo:   &StorageInfo{client: client},
		StorageJobs:   &StorageJobs{client: client},
		Admin:         admin.NewAdmin(adminPb.NewAdminServiceClient(conn)),
		conn:          conn,
		client:        client,
	}, nil
}

// Host returns the client host address.
func (c *Client) Host() string {
	return c.conn.Target()
}

// BuildInfo returns build info about the server.
func (c *Client) BuildInfo(ctx context.Context) (*userPb.BuildInfoResponse, error) {
	return c.client.BuildInfo(ctx, &userPb.BuildInfoRequest{})
}

// UserID returns the user id.
func (c *Client) UserID(ctx context.Context) (*userPb.UserIdentifierResponse, error) {
	return c.client.UserIdentifier(ctx, &userPb.UserIdentifierRequest{})
}

// Close closes the client's grpc connection and cancels any active requests.
func (c *Client) Close() error {
	return c.conn.Close()
}

'''
'''--- Filecoin/powergate/api/client/client_test.go ---
package client

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestClient(t *testing.T) {
	done := setupServer(t, defaultServerConfig(t))
	defer done()

	client, err := NewClient("127.0.0.1:5002")
	require.NoError(t, err)
	err = client.Close()
	require.NoError(t, err)
}

'''
'''--- Filecoin/powergate/api/client/data.go ---
package client

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	files "github.com/ipfs/go-ipfs-files"
	httpapi "github.com/ipfs/go-ipfs-http-client"
	"github.com/ipfs/interface-go-ipfs-core/options"
	ipfspath "github.com/ipfs/interface-go-ipfs-core/path"
	"github.com/multiformats/go-multiaddr"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Data provides access to Powergate general data APIs.
type Data struct {
	client userPb.UserServiceClient
}

// WatchLogsOption is a function that changes GetLogsConfig.
type WatchLogsOption func(r *userPb.WatchLogsRequest)

// WithJobIDFilter filters only log messages of a Cid related to
// the Job with id jid.
func WithJobIDFilter(jobID string) WatchLogsOption {
	return func(r *userPb.WatchLogsRequest) {
		r.JobId = jobID
	}
}

// WithHistory indicates that prior history logs should
// be sent in the channel before getting real time logs.
func WithHistory(enabled bool) WatchLogsOption {
	return func(r *userPb.WatchLogsRequest) {
		r.History = enabled
	}
}

// WatchLogsEvent represents an event for watching cid logs.
type WatchLogsEvent struct {
	Res *userPb.WatchLogsResponse
	Err error
}

// Stage allows to temporarily stage data in hot storage in preparation for pushing a cid storage config.
func (d *Data) Stage(ctx context.Context, data io.Reader) (*userPb.StageResponse, error) {
	stream, err := d.client.Stage(ctx)
	if err != nil {
		return nil, err
	}

	buffer := make([]byte, 1024*32) // 32KB
	for {
		bytesRead, err := data.Read(buffer)
		if err != nil && err != io.EOF {
			return nil, err
		}
		sendErr := stream.Send(&userPb.StageRequest{Chunk: buffer[:bytesRead]})
		if sendErr != nil {
			if sendErr == io.EOF {
				var noOp interface{}
				return nil, stream.RecvMsg(noOp)
			}
			return nil, sendErr
		}
		if err == io.EOF {
			break
		}
	}
	return stream.CloseAndRecv()
}

// StageFolder allows to temporarily stage a folder in hot storage in preparation for pushing a cid storage config.
func (d *Data) StageFolder(ctx context.Context, ipfsRevProxyAddr string, folderPath string) (string, error) {
	ffsToken := ctx.Value(AuthKey).(string)

	ipfs, err := newDecoratedIPFSAPI(ipfsRevProxyAddr, ffsToken)
	if err != nil {
		return "", fmt.Errorf("creating IPFS HTTP client: %s", err)
	}

	stat, err := os.Lstat(folderPath)
	if err != nil {
		return "", err
	}
	ff, err := files.NewSerialFile(folderPath, false, stat)
	if err != nil {
		return "", err
	}
	defer func() { _ = ff.Close() }()
	opts := []options.UnixfsAddOption{
		options.Unixfs.CidVersion(1),
		options.Unixfs.Pin(true),
	}
	pth, err := ipfs.Unixfs().Add(context.Background(), files.ToDir(ff), opts...)
	if err != nil {
		return "", err
	}

	_, err = d.client.StageCid(ctx, &userPb.StageCidRequest{Cid: pth.Cid().String()})
	if err != nil {
		return "", fmt.Errorf("stage pinning cid: %s", err)
	}

	return pth.Cid().String(), nil
}

// ReplaceData pushes a StorageConfig for c2 equal to that of c1, and removes c1. This operation
// is more efficient than manually removing and adding in two separate operations.
func (d *Data) ReplaceData(ctx context.Context, cid1, cid2 string) (*userPb.ReplaceDataResponse, error) {
	return d.client.ReplaceData(ctx, &userPb.ReplaceDataRequest{Cid1: cid1, Cid2: cid2})
}

// Get returns an io.Reader for reading a stored Cid from hot storage.
func (d *Data) Get(ctx context.Context, cid string) (io.Reader, error) {
	stream, err := d.client.Get(ctx, &userPb.GetRequest{
		Cid: cid,
	})
	if err != nil {
		return nil, err
	}
	reader, writer := io.Pipe()
	go func() {
		for {
			res, err := stream.Recv()
			if err == io.EOF {
				_ = writer.Close()
				break
			} else if err != nil {
				_ = writer.CloseWithError(err)
				break
			}
			_, err = writer.Write(res.GetChunk())
			if err != nil {
				_ = writer.CloseWithError(err)
				break
			}
		}
	}()

	return reader, nil
}

// GetFolder retrieves to outputDir a Cid which corresponds to a folder.
func (d *Data) GetFolder(ctx context.Context, ipfsRevProxyAddr, cid, outputDir string) error {
	token := ctx.Value(AuthKey).(string)
	ipfs, err := newDecoratedIPFSAPI(ipfsRevProxyAddr, token)
	if err != nil {
		return fmt.Errorf("creating decorated IPFS client: %s", err)
	}
	ci, err := util.CidFromString(cid)
	if err != nil {
		return fmt.Errorf("decoding cid: %s", err)
	}
	n, err := ipfs.Unixfs().Get(ctx, ipfspath.IpfsPath(ci))
	if err != nil {
		return fmt.Errorf("getting folder DAG from IPFS: %s", err)
	}
	err = files.WriteTo(n, outputDir)
	if err != nil {
		return fmt.Errorf("saving folder DAG to output folder: %s", err)
	}
	return nil
}

// WatchLogs pushes human-friendly messages about Cid executions. The method is blocking
// and will continue to send messages until the context is canceled. The provided channel
// is owned by the method and must not be closed.
func (d *Data) WatchLogs(ctx context.Context, ch chan<- WatchLogsEvent, cid string, opts ...WatchLogsOption) error {
	r := &userPb.WatchLogsRequest{Cid: cid}
	for _, opt := range opts {
		opt(r)
	}
	stream, err := d.client.WatchLogs(ctx, r)
	if err != nil {
		return err
	}
	go func() {
		for {
			res, err := stream.Recv()
			if err == io.EOF || status.Code(err) == codes.Canceled {
				close(ch)
				break
			}
			if err != nil {
				ch <- WatchLogsEvent{Err: err}
				close(ch)
				break
			}
			ch <- WatchLogsEvent{Res: res}
		}
	}()
	return nil
}

// CidSummary gives a summary of the storage and jobs state of the specified cid.
func (d *Data) CidSummary(ctx context.Context, cids ...string) (*userPb.CidSummaryResponse, error) {
	return d.client.CidSummary(ctx, &userPb.CidSummaryRequest{Cids: cids})
}

// CidInfo returns information about a cid stored by the user.
func (d *Data) CidInfo(ctx context.Context, cid string) (*userPb.CidInfoResponse, error) {
	return d.client.CidInfo(ctx, &userPb.CidInfoRequest{Cid: cid})
}

func newDecoratedIPFSAPI(proxyAddr, ffsToken string) (*httpapi.HttpApi, error) {
	ipport := strings.Split(proxyAddr, ":")
	if len(ipport) != 2 {
		return nil, fmt.Errorf("ipfs addr is invalid")
	}
	cm, err := multiaddr.NewComponent("dns4", ipport[0])
	if err != nil {
		return nil, err
	}
	cp, err := multiaddr.NewComponent("tcp", ipport[1])
	if err != nil {
		return nil, err
	}
	useHTTPS := ipport[1] == "443"
	ipfsMaddr := cm.Encapsulate(cp)
	customClient := http.DefaultClient
	customClient.Transport = newFFSHeaderDecorator(ffsToken, useHTTPS)
	ipfs, err := httpapi.NewApiWithClient(ipfsMaddr, customClient)
	if err != nil {
		return nil, err
	}
	return ipfs, nil
}

type ffsHeaderDecorator struct {
	ffsToken string
	useHTTPS bool
}

func newFFSHeaderDecorator(ffsToken string, useHTTPS bool) *ffsHeaderDecorator {
	return &ffsHeaderDecorator{
		ffsToken: ffsToken,
		useHTTPS: useHTTPS,
	}
}

func (fhd ffsHeaderDecorator) RoundTrip(req *http.Request) (*http.Response, error) {
	req.Header["x-ipfs-ffs-auth"] = []string{fhd.ffsToken}
	if fhd.useHTTPS {
		req.URL.Scheme = "https"
	}

	return http.DefaultTransport.RoundTrip(req)
}

'''
'''--- Filecoin/powergate/api/client/deals.go ---
package client

import (
	"context"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

// Deals provides access to Powergate deals APIs.
type Deals struct {
	client userPb.UserServiceClient
}

// DealRecordsOption updates a ListDealRecordsConfig.
type DealRecordsOption func(*userPb.DealRecordsConfig)

// WithFromAddrs limits the results deals initiated from the provided wallet addresses.
// If WithDataCids is also provided, this is an AND operation.
func WithFromAddrs(addrs ...string) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.FromAddrs = addrs
	}
}

// WithDataCids limits the results to deals for the provided data cids.
// If WithFromAddrs is also provided, this is an AND operation.
func WithDataCids(cids ...string) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.DataCids = cids
	}
}

// WithIncludePending specifies whether or not to include pending deals in the results. Default is false.
// Ignored for ListRetrievalDealRecords.
func WithIncludePending(includePending bool) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.IncludePending = includePending
	}
}

// WithIncludeFinal specifies whether or not to include final deals in the results. Default is false.
// Ignored for ListRetrievalDealRecords.
func WithIncludeFinal(includeFinal bool) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.IncludeFinal = includeFinal
	}
}

// WithIncludeFailed specifies if failed records will be included in the output.
func WithIncludeFailed(includeFailed bool) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.IncludeFailed = includeFailed
	}
}

// WithAscending specifies to sort the results in ascending order. Default is descending order.
// Records are sorted by timestamp.
func WithAscending(ascending bool) DealRecordsOption {
	return func(c *userPb.DealRecordsConfig) {
		c.Ascending = ascending
	}
}

// StorageDealRecords returns a list of storage deals for the user according to the provided options.
func (d *Deals) StorageDealRecords(ctx context.Context, opts ...DealRecordsOption) (*userPb.StorageDealRecordsResponse, error) {
	conf := &userPb.DealRecordsConfig{}
	for _, opt := range opts {
		opt(conf)
	}
	return d.client.StorageDealRecords(ctx, &userPb.StorageDealRecordsRequest{Config: conf})
}

// RetrievalDealRecords returns a list of retrieval deals for the user according to the provided options.
func (d *Deals) RetrievalDealRecords(ctx context.Context, opts ...DealRecordsOption) (*userPb.RetrievalDealRecordsResponse, error) {
	conf := &userPb.DealRecordsConfig{}
	for _, opt := range opts {
		opt(conf)
	}
	return d.client.RetrievalDealRecords(ctx, &userPb.RetrievalDealRecordsRequest{Config: conf})
}

'''
'''--- Filecoin/powergate/api/client/storageconfig.go ---
package client

import (
	"context"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

// StorageConfig provides access to Powergate storage config APIs.
type StorageConfig struct {
	client userPb.UserServiceClient
}

// ApplyOption mutates a push request.
type ApplyOption func(r *userPb.ApplyStorageConfigRequest)

// WithStorageConfig overrides the Api default Cid configuration.
func WithStorageConfig(c *userPb.StorageConfig) ApplyOption {
	return func(r *userPb.ApplyStorageConfigRequest) {
		r.HasConfig = true
		r.Config = c
	}
}

// WithOverride allows a new push configuration to override an existing one.
// It's used as an extra security measure to avoid unwanted configuration changes.
func WithOverride(override bool) ApplyOption {
	return func(r *userPb.ApplyStorageConfigRequest) {
		r.HasOverrideConfig = true
		r.OverrideConfig = override
	}
}

// WithImportDealIDs allows to import active on-chain deals to the Cid deals information.
func WithImportDealIDs(dealIDs []uint64) ApplyOption {
	return func(r *userPb.ApplyStorageConfigRequest) {
		r.ImportDealIds = dealIDs
	}
}

// WithNoExec allows to configure if a Job should ensure the new storage configuration.
func WithNoExec(noExec bool) ApplyOption {
	return func(r *userPb.ApplyStorageConfigRequest) {
		r.NoExec = noExec
	}
}

// Default returns the default storage config.
func (s *StorageConfig) Default(ctx context.Context) (*userPb.DefaultStorageConfigResponse, error) {
	return s.client.DefaultStorageConfig(ctx, &userPb.DefaultStorageConfigRequest{})
}

// SetDefault sets the default storage config.
func (s *StorageConfig) SetDefault(ctx context.Context, config *userPb.StorageConfig) (*userPb.SetDefaultStorageConfigResponse, error) {
	req := &userPb.SetDefaultStorageConfigRequest{
		Config: config,
	}
	return s.client.SetDefaultStorageConfig(ctx, req)
}

// Apply push a new configuration for the Cid in hot and cold storage.
func (s *StorageConfig) Apply(ctx context.Context, cid string, opts ...ApplyOption) (*userPb.ApplyStorageConfigResponse, error) {
	req := &userPb.ApplyStorageConfigRequest{Cid: cid}
	for _, opt := range opts {
		opt(req)
	}
	return s.client.ApplyStorageConfig(ctx, req)
}

// Remove removes a Cid from being tracked as an active storage. The Cid should have
// both Hot and Cold storage disabled, if that isn't the case it will return ErrActiveInStorage.
func (s *StorageConfig) Remove(ctx context.Context, cid string) (*userPb.RemoveResponse, error) {
	return s.client.Remove(ctx, &userPb.RemoveRequest{Cid: cid})
}

'''
'''--- Filecoin/powergate/api/client/storageinfo.go ---
package client

import (
	"context"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

// StorageInfo provides access to Powergate storage indo APIs.
type StorageInfo struct {
	client userPb.UserServiceClient
}

// Get returns the information about a stored Cid. If no information is available,
// since the Cid was never stored, it returns an error with codes.NotFound.
func (s *StorageInfo) Get(ctx context.Context, cid string) (*userPb.StorageInfoResponse, error) {
	return s.client.StorageInfo(ctx, &userPb.StorageInfoRequest{Cid: cid})
}

// List returns a list of information about all stored cids, filtered by cids if provided.
func (s *StorageInfo) List(ctx context.Context, cids ...string) (*userPb.ListStorageInfoResponse, error) {
	return s.client.ListStorageInfo(ctx, &userPb.ListStorageInfoRequest{Cids: cids})
}

'''
'''--- Filecoin/powergate/api/client/storagejobs.go ---
package client

import (
	"context"
	"io"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// StorageJobs provides access to Powergate jobs APIs.
type StorageJobs struct {
	client userPb.UserServiceClient
}

// ListSelect specifies which StorageJobs to list.
type ListSelect int32

const (
	// All lists all StorageJobs and is the default.
	All ListSelect = iota
	// Queued lists queued StorageJobs.
	Queued
	// Executing lists executing StorageJobs.
	Executing
	// Final lists final StorageJobs.
	Final
)

// ListConfig controls the behavior for listing StorageJobs.
type ListConfig struct {
	// CidFilter filters StorageJobs list to the specified cid. Defaults to no filter.
	CidFilter string
	// Limit limits the number of StorageJobs returned. Defaults to no limit.
	Limit uint64
	// Ascending returns the StorageJobs ascending by time. Defaults to false, descending.
	Ascending bool
	// Select specifies to return StorageJobs in the specified state.
	Select ListSelect
	// NextPageToken sets the slug from which to start building the next page of results.
	NextPageToken string
}

type summaryConfig struct {
	cid string
}

// SummaryOption configures a storageJobsConfig.
type SummaryOption = func(*summaryConfig)

// WithCid filters the results to the specified data cid.
func WithCid(cid string) SummaryOption {
	return func(conf *summaryConfig) {
		conf.cid = cid
	}
}

// WatchStorageJobsEvent represents an event for Watching a job.
type WatchStorageJobsEvent struct {
	Res *userPb.WatchStorageJobsResponse
	Err error
}

// Get returns the current state of the specified job.
func (j *StorageJobs) Get(ctx context.Context, jobID string) (*userPb.StorageJobResponse, error) {
	return j.client.StorageJob(ctx, &userPb.StorageJobRequest{JobId: jobID})
}

// StorageConfig returns the StorageConfig associated with the specified job.
func (j *StorageJobs) StorageConfig(ctx context.Context, jobID string) (*userPb.StorageConfigForJobResponse, error) {
	return j.client.StorageConfigForJob(ctx, &userPb.StorageConfigForJobRequest{JobId: jobID})
}

// List lists StorageJobs according to the provided ListConfig.
func (j *StorageJobs) List(ctx context.Context, config ListConfig) (*userPb.ListStorageJobsResponse, error) {
	sel := userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED
	switch config.Select {
	case All:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_ALL
	case Queued:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_QUEUED
	case Executing:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_EXECUTING
	case Final:
		sel = userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_FINAL
	}
	req := &userPb.ListStorageJobsRequest{
		CidFilter:     config.CidFilter,
		Limit:         config.Limit,
		Ascending:     config.Ascending,
		NextPageToken: config.NextPageToken,
		Selector:      sel,
	}
	return j.client.ListStorageJobs(ctx, req)
}

// Summary returns a summary of storage jobs.
func (j *StorageJobs) Summary(ctx context.Context, opts ...SummaryOption) (*userPb.StorageJobsSummaryResponse, error) {
	conf := &summaryConfig{}
	for _, opt := range opts {
		opt(conf)
	}
	req := &userPb.StorageJobsSummaryRequest{
		Cid: conf.cid,
	}
	return j.client.StorageJobsSummary(ctx, req)
}

// Watch pushes JobEvents to the provided channel. The provided channel will be owned
// by the client after the call, so it shouldn't be closed by the client. To stop receiving
// events, the provided ctx should be canceled. If an error occurs, it will be returned
// in the Err field of JobEvent and the channel will be closed.
func (j *StorageJobs) Watch(ctx context.Context, ch chan<- WatchStorageJobsEvent, jobIDs ...string) error {
	stream, err := j.client.WatchStorageJobs(ctx, &userPb.WatchStorageJobsRequest{JobIds: jobIDs})
	if err != nil {
		return err
	}
	go func() {
		for {
			res, err := stream.Recv()
			if err == io.EOF || status.Code(err) == codes.Canceled {
				close(ch)
				break
			}
			if err != nil {
				ch <- WatchStorageJobsEvent{Err: err}
				close(ch)
				break
			}
			ch <- WatchStorageJobsEvent{Res: res}
		}
	}()
	return nil
}

// Cancel signals that the executing Job with JobID jid should be
// canceled.
func (j *StorageJobs) Cancel(ctx context.Context, jobID string) (*userPb.CancelStorageJobResponse, error) {
	return j.client.CancelStorageJob(ctx, &userPb.CancelStorageJobRequest{JobId: jobID})
}

'''
'''--- Filecoin/powergate/api/client/utils_test.go ---
package client

import (
	"fmt"
	"math/big"
	"testing"
	"time"

	"github.com/multiformats/go-multiaddr"
	"github.com/phayes/freeport"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/api/server"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc"
)

var ()

func defaultServerConfig(t *testing.T) server.Config {
	grpcHostNetwork := "tcp"
	grpcHostAddress := fmt.Sprintf("/ip4/127.0.0.1/tcp/%d", freePort(t))
	grpcWebProxyAddress := fmt.Sprintf("127.0.0.1:%d", freePort(t))
	gatewayHostAddr := fmt.Sprintf("0.0.0.0:%d", freePort(t))
	indexRawJSONHostAddr := fmt.Sprintf("0.0.0.0:%d", freePort(t))

	repoPath := t.TempDir()
	dipfs, cls := tests.LaunchIPFSDocker(t)
	t.Cleanup(func() { cls() })

	ipfsAddrStr := "/ip4/127.0.0.1/tcp/" + dipfs.GetPort("5001/tcp")
	ipfsAddr := util.MustParseAddr(ipfsAddrStr)

	devnet := tests.LaunchDevnetDocker(t, 1, 300, ipfsAddrStr, false)
	devnetAddr := util.MustParseAddr("/ip4/127.0.0.1/tcp/" + devnet.GetPort("7777/tcp"))

	grpcMaddr := util.MustParseAddr(grpcHostAddress)
	conf := server.Config{
		WalletInitialFunds:            *big.NewInt(int64(4000000000)),
		IpfsAPIAddr:                   ipfsAddr,
		LotusAddress:                  devnetAddr,
		LotusAuthToken:                "",
		LotusMasterAddr:               "",
		LotusConnectionRetries:        5,
		Devnet:                        true,
		GrpcHostNetwork:               grpcHostNetwork,
		GrpcHostAddress:               grpcMaddr,
		GrpcWebProxyAddress:           grpcWebProxyAddress,
		RepoPath:                      repoPath,
		GatewayHostAddr:               gatewayHostAddr,
		IndexRawJSONHostAddr:          indexRawJSONHostAddr,
		MaxMindDBFolder:               "../../iplocation/maxmind",
		MinerSelector:                 "reputation",
		FFSDealFinalityTimeout:        time.Minute * 30,
		FFSMaxParallelDealPreparing:   1,
		FFSGCAutomaticGCInterval:      0,
		FFSRetrievalNextEventTimeout:  time.Hour,
		DealWatchPollDuration:         time.Second * 15,
		SchedMaxParallel:              10,
		AskIndexQueryAskTimeout:       time.Second * 3,
		AskIndexRefreshInterval:       time.Second * 3,
		AskIndexRefreshOnStart:        true,
		AskindexMaxParallel:           2,
		IndexMinersRefreshOnStart:     false,
		IndexMinersOnChainMaxParallel: 1,
		IndexMinersOnChainFrequency:   time.Minute,
	}
	return conf
}

func setupServer(t *testing.T, conf server.Config) func() {
	server, err := server.NewServer(conf)
	require.NoError(t, err)

	return func() {
		server.Close()
	}
}

func freePort(t *testing.T) int {
	fp, err := freeport.GetFreePort()
	require.NoError(t, err)
	return fp
}

func setupConnection(t *testing.T, grpcHostAddress multiaddr.Multiaddr) (*grpc.ClientConn, func()) {
	auth := TokenAuth{}
	addr, err := util.TCPAddrFromMultiAddr(grpcHostAddress)
	require.NoError(t, err)
	conn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithPerRPCCredentials(auth))
	require.NoError(t, err)
	return conn, func() {
		require.NoError(t, conn.Close())
	}
}

'''
'''--- Filecoin/powergate/api/client/wallet.go ---
package client

import (
	"context"
	"math/big"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

// Wallet provides an API for managing filecoin wallets.
type Wallet struct {
	client userPb.UserServiceClient
}

// NewAddressOption is a function that changes a NewAddressConfig.
type NewAddressOption func(r *userPb.NewAddressRequest)

// WithMakeDefault specifies if the new address should become the default.
func WithMakeDefault(makeDefault bool) NewAddressOption {
	return func(r *userPb.NewAddressRequest) {
		r.MakeDefault = makeDefault
	}
}

// WithAddressType specifies the type of address to create.
func WithAddressType(addressType string) NewAddressOption {
	return func(r *userPb.NewAddressRequest) {
		r.AddressType = addressType
	}
}

// Balance gets a filecoin wallet's balance.
func (w *Wallet) Balance(ctx context.Context, address string) (*userPb.BalanceResponse, error) {
	return w.client.Balance(ctx, &userPb.BalanceRequest{Address: address})
}

// NewAddress creates a new wallet address managed by the user.
func (w *Wallet) NewAddress(ctx context.Context, name string, options ...NewAddressOption) (*userPb.NewAddressResponse, error) {
	r := &userPb.NewAddressRequest{Name: name}
	for _, opt := range options {
		opt(r)
	}
	return w.client.NewAddress(ctx, r)
}

// Addresses returns a list of addresses managed by the user. Each addresses *could* have
// verified-client information. If VerifiedClientInfo is nil, then the address isn't verified.
func (w *Wallet) Addresses(ctx context.Context) (*userPb.AddressesResponse, error) {
	return w.client.Addresses(ctx, &userPb.AddressesRequest{})
}

// SendFil sends fil from a managed address to any another address, returns immediately but funds are sent asynchronously.
func (w *Wallet) SendFil(ctx context.Context, from string, to string, amount *big.Int) (*userPb.SendFilResponse, error) {
	req := &userPb.SendFilRequest{
		From:   from,
		To:     to,
		Amount: amount.String(),
	}
	return w.client.SendFil(ctx, req)
}

// SignMessage signs a message with a user wallet address.
func (w *Wallet) SignMessage(ctx context.Context, address string, message []byte) (*userPb.SignMessageResponse, error) {
	r := &userPb.SignMessageRequest{Address: address, Message: message}
	return w.client.SignMessage(ctx, r)
}

// VerifyMessage verifies a message signature from a wallet address.
func (w *Wallet) VerifyMessage(ctx context.Context, address string, message, signature []byte) (*userPb.VerifyMessageResponse, error) {
	r := &userPb.VerifyMessageRequest{Address: address, Message: message, Signature: signature}
	return w.client.VerifyMessage(ctx, r)
}

'''
'''--- Filecoin/powergate/api/client/wallet_test.go ---
package client

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestFoo(t *testing.T) {
	require.True(t, true)
}

// func TestNewWallet(t *testing.T) {
// 	w, done := setupWallet(t)
// 	defer done()

// 	res, err := w.NewAddress(ctx, "bls")
// 	require.NoError(t, err)
// 	require.Greater(t, len(res.Address), 0)
// }

// func TestList(t *testing.T) {
// 	w, done := setupWallet(t)
// 	defer done()

// 	res, err := w.List(ctx)
// 	require.NoError(t, err)
// 	require.Greater(t, len(res.Addresses), 0)
// }

// func TestWalletBalance(t *testing.T) {
// 	w, done := setupWallet(t)
// 	defer done()

// 	newAddressRes, err := w.NewAddress(ctx, "bls")
// 	require.NoError(t, err)

// 	_, err = w.Balance(ctx, newAddressRes.Address)
// 	require.NoError(t, err)
// }

// func setupWallet(t *testing.T) (*Wallet, func()) {
// 	serverDone := setupServer(t, defaultServerConfig(t))
// 	conn, done := setupConnection(t)
// 	return &Wallet{walletClient: rpc.NewRPCServiceClient(conn), powergateClient: proto.NewPowergateServiceClient(conn)}, func() {
// 		done()
// 		serverDone()
// 	}
// }

'''
'''--- Filecoin/powergate/api/gen/powergate/admin/v1/admin.pb.go ---
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.17.3
// source: powergate/admin/v1/admin.proto

package adminPb

import (
	proto "github.com/golang/protobuf/proto"
	v1 "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Wallet
type NewAddressRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AddressType string `protobuf:"bytes,1,opt,name=address_type,json=addressType,proto3" json:"address_type,omitempty"`
}

func (x *NewAddressRequest) Reset() {
	*x = NewAddressRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressRequest) ProtoMessage() {}

func (x *NewAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressRequest.ProtoReflect.Descriptor instead.
func (*NewAddressRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{0}
}

func (x *NewAddressRequest) GetAddressType() string {
	if x != nil {
		return x.AddressType
	}
	return ""
}

type NewAddressResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *NewAddressResponse) Reset() {
	*x = NewAddressResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressResponse) ProtoMessage() {}

func (x *NewAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressResponse.ProtoReflect.Descriptor instead.
func (*NewAddressResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{1}
}

func (x *NewAddressResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type AddressesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *AddressesRequest) Reset() {
	*x = AddressesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressesRequest) ProtoMessage() {}

func (x *AddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressesRequest.ProtoReflect.Descriptor instead.
func (*AddressesRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{2}
}

type AddressesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Addresses []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
}

func (x *AddressesResponse) Reset() {
	*x = AddressesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressesResponse) ProtoMessage() {}

func (x *AddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressesResponse.ProtoReflect.Descriptor instead.
func (*AddressesResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{3}
}

func (x *AddressesResponse) GetAddresses() []string {
	if x != nil {
		return x.Addresses
	}
	return nil
}

type SendFilRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To     string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *SendFilRequest) Reset() {
	*x = SendFilRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendFilRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendFilRequest) ProtoMessage() {}

func (x *SendFilRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendFilRequest.ProtoReflect.Descriptor instead.
func (*SendFilRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{4}
}

func (x *SendFilRequest) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *SendFilRequest) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *SendFilRequest) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type SendFilResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *SendFilResponse) Reset() {
	*x = SendFilResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendFilResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendFilResponse) ProtoMessage() {}

func (x *SendFilResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendFilResponse.ProtoReflect.Descriptor instead.
func (*SendFilResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{5}
}

func (x *SendFilResponse) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{6}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type CreateUserRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *CreateUserRequest) Reset() {
	*x = CreateUserRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateUserRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateUserRequest) ProtoMessage() {}

func (x *CreateUserRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateUserRequest.ProtoReflect.Descriptor instead.
func (*CreateUserRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{7}
}

type CreateUserResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *CreateUserResponse) Reset() {
	*x = CreateUserResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateUserResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateUserResponse) ProtoMessage() {}

func (x *CreateUserResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateUserResponse.ProtoReflect.Descriptor instead.
func (*CreateUserResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{8}
}

func (x *CreateUserResponse) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

type RegenerateAuthRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *RegenerateAuthRequest) Reset() {
	*x = RegenerateAuthRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegenerateAuthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegenerateAuthRequest) ProtoMessage() {}

func (x *RegenerateAuthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegenerateAuthRequest.ProtoReflect.Descriptor instead.
func (*RegenerateAuthRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{9}
}

func (x *RegenerateAuthRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type RegenerateAuthResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NewToken string `protobuf:"bytes,1,opt,name=new_token,json=newToken,proto3" json:"new_token,omitempty"`
}

func (x *RegenerateAuthResponse) Reset() {
	*x = RegenerateAuthResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegenerateAuthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegenerateAuthResponse) ProtoMessage() {}

func (x *RegenerateAuthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegenerateAuthResponse.ProtoReflect.Descriptor instead.
func (*RegenerateAuthResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{10}
}

func (x *RegenerateAuthResponse) GetNewToken() string {
	if x != nil {
		return x.NewToken
	}
	return ""
}

type UsersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *UsersRequest) Reset() {
	*x = UsersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UsersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsersRequest) ProtoMessage() {}

func (x *UsersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsersRequest.ProtoReflect.Descriptor instead.
func (*UsersRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{11}
}

type UsersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Users []*User `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (x *UsersResponse) Reset() {
	*x = UsersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UsersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsersResponse) ProtoMessage() {}

func (x *UsersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsersResponse.ProtoReflect.Descriptor instead.
func (*UsersResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{12}
}

func (x *UsersResponse) GetUsers() []*User {
	if x != nil {
		return x.Users
	}
	return nil
}

type StorageInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Cid    string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StorageInfoRequest) Reset() {
	*x = StorageInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfoRequest) ProtoMessage() {}

func (x *StorageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfoRequest.ProtoReflect.Descriptor instead.
func (*StorageInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{13}
}

func (x *StorageInfoRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *StorageInfoRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StorageInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageInfo *v1.StorageInfo `protobuf:"bytes,1,opt,name=storage_info,json=storageInfo,proto3" json:"storage_info,omitempty"`
}

func (x *StorageInfoResponse) Reset() {
	*x = StorageInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfoResponse) ProtoMessage() {}

func (x *StorageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfoResponse.ProtoReflect.Descriptor instead.
func (*StorageInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{14}
}

func (x *StorageInfoResponse) GetStorageInfo() *v1.StorageInfo {
	if x != nil {
		return x.StorageInfo
	}
	return nil
}

type ListStorageInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserIds []string `protobuf:"bytes,1,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	Cids    []string `protobuf:"bytes,2,rep,name=cids,proto3" json:"cids,omitempty"`
}

func (x *ListStorageInfoRequest) Reset() {
	*x = ListStorageInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageInfoRequest) ProtoMessage() {}

func (x *ListStorageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageInfoRequest.ProtoReflect.Descriptor instead.
func (*ListStorageInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{15}
}

func (x *ListStorageInfoRequest) GetUserIds() []string {
	if x != nil {
		return x.UserIds
	}
	return nil
}

func (x *ListStorageInfoRequest) GetCids() []string {
	if x != nil {
		return x.Cids
	}
	return nil
}

type ListStorageInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageInfo []*v1.StorageInfo `protobuf:"bytes,1,rep,name=storage_info,json=storageInfo,proto3" json:"storage_info,omitempty"`
}

func (x *ListStorageInfoResponse) Reset() {
	*x = ListStorageInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageInfoResponse) ProtoMessage() {}

func (x *ListStorageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageInfoResponse.ProtoReflect.Descriptor instead.
func (*ListStorageInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{16}
}

func (x *ListStorageInfoResponse) GetStorageInfo() []*v1.StorageInfo {
	if x != nil {
		return x.StorageInfo
	}
	return nil
}

type ListStorageJobsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserIdFilter  string                 `protobuf:"bytes,1,opt,name=user_id_filter,json=userIdFilter,proto3" json:"user_id_filter,omitempty"`
	CidFilter     string                 `protobuf:"bytes,2,opt,name=cid_filter,json=cidFilter,proto3" json:"cid_filter,omitempty"`
	Limit         uint64                 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Ascending     bool                   `protobuf:"varint,4,opt,name=ascending,proto3" json:"ascending,omitempty"`
	NextPageToken string                 `protobuf:"bytes,5,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	Selector      v1.StorageJobsSelector `protobuf:"varint,6,opt,name=selector,proto3,enum=powergate.user.v1.StorageJobsSelector" json:"selector,omitempty"`
}

func (x *ListStorageJobsRequest) Reset() {
	*x = ListStorageJobsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageJobsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageJobsRequest) ProtoMessage() {}

func (x *ListStorageJobsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageJobsRequest.ProtoReflect.Descriptor instead.
func (*ListStorageJobsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{17}
}

func (x *ListStorageJobsRequest) GetUserIdFilter() string {
	if x != nil {
		return x.UserIdFilter
	}
	return ""
}

func (x *ListStorageJobsRequest) GetCidFilter() string {
	if x != nil {
		return x.CidFilter
	}
	return ""
}

func (x *ListStorageJobsRequest) GetLimit() uint64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListStorageJobsRequest) GetAscending() bool {
	if x != nil {
		return x.Ascending
	}
	return false
}

func (x *ListStorageJobsRequest) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

func (x *ListStorageJobsRequest) GetSelector() v1.StorageJobsSelector {
	if x != nil {
		return x.Selector
	}
	return v1.StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED
}

type ListStorageJobsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageJobs   []*v1.StorageJob `protobuf:"bytes,1,rep,name=storage_jobs,json=storageJobs,proto3" json:"storage_jobs,omitempty"`
	More          bool             `protobuf:"varint,2,opt,name=more,proto3" json:"more,omitempty"`
	NextPageToken string           `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (x *ListStorageJobsResponse) Reset() {
	*x = ListStorageJobsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageJobsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageJobsResponse) ProtoMessage() {}

func (x *ListStorageJobsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageJobsResponse.ProtoReflect.Descriptor instead.
func (*ListStorageJobsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{18}
}

func (x *ListStorageJobsResponse) GetStorageJobs() []*v1.StorageJob {
	if x != nil {
		return x.StorageJobs
	}
	return nil
}

func (x *ListStorageJobsResponse) GetMore() bool {
	if x != nil {
		return x.More
	}
	return false
}

func (x *ListStorageJobsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type StorageJobsSummaryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Cid    string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StorageJobsSummaryRequest) Reset() {
	*x = StorageJobsSummaryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobsSummaryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobsSummaryRequest) ProtoMessage() {}

func (x *StorageJobsSummaryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobsSummaryRequest.ProtoReflect.Descriptor instead.
func (*StorageJobsSummaryRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{19}
}

func (x *StorageJobsSummaryRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *StorageJobsSummaryRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StorageJobsSummaryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	QueuedStorageJobs    []string `protobuf:"bytes,1,rep,name=queued_storage_jobs,json=queuedStorageJobs,proto3" json:"queued_storage_jobs,omitempty"`
	ExecutingStorageJobs []string `protobuf:"bytes,2,rep,name=executing_storage_jobs,json=executingStorageJobs,proto3" json:"executing_storage_jobs,omitempty"`
	FinalStorageJobs     []string `protobuf:"bytes,3,rep,name=final_storage_jobs,json=finalStorageJobs,proto3" json:"final_storage_jobs,omitempty"`
}

func (x *StorageJobsSummaryResponse) Reset() {
	*x = StorageJobsSummaryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobsSummaryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobsSummaryResponse) ProtoMessage() {}

func (x *StorageJobsSummaryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobsSummaryResponse.ProtoReflect.Descriptor instead.
func (*StorageJobsSummaryResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{20}
}

func (x *StorageJobsSummaryResponse) GetQueuedStorageJobs() []string {
	if x != nil {
		return x.QueuedStorageJobs
	}
	return nil
}

func (x *StorageJobsSummaryResponse) GetExecutingStorageJobs() []string {
	if x != nil {
		return x.ExecutingStorageJobs
	}
	return nil
}

func (x *StorageJobsSummaryResponse) GetFinalStorageJobs() []string {
	if x != nil {
		return x.FinalStorageJobs
	}
	return nil
}

type GCStagedRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GCStagedRequest) Reset() {
	*x = GCStagedRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GCStagedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCStagedRequest) ProtoMessage() {}

func (x *GCStagedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCStagedRequest.ProtoReflect.Descriptor instead.
func (*GCStagedRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{21}
}

type GCStagedResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UnpinnedCids []string `protobuf:"bytes,1,rep,name=unpinned_cids,json=unpinnedCids,proto3" json:"unpinned_cids,omitempty"`
}

func (x *GCStagedResponse) Reset() {
	*x = GCStagedResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GCStagedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCStagedResponse) ProtoMessage() {}

func (x *GCStagedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCStagedResponse.ProtoReflect.Descriptor instead.
func (*GCStagedResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{22}
}

func (x *GCStagedResponse) GetUnpinnedCids() []string {
	if x != nil {
		return x.UnpinnedCids
	}
	return nil
}

type PinnedCidsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *PinnedCidsRequest) Reset() {
	*x = PinnedCidsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PinnedCidsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PinnedCidsRequest) ProtoMessage() {}

func (x *PinnedCidsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PinnedCidsRequest.ProtoReflect.Descriptor instead.
func (*PinnedCidsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{23}
}

type PinnedCidsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cids []*HSPinnedCid `protobuf:"bytes,1,rep,name=cids,proto3" json:"cids,omitempty"`
}

func (x *PinnedCidsResponse) Reset() {
	*x = PinnedCidsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PinnedCidsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PinnedCidsResponse) ProtoMessage() {}

func (x *PinnedCidsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PinnedCidsResponse.ProtoReflect.Descriptor instead.
func (*PinnedCidsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{24}
}

func (x *PinnedCidsResponse) GetCids() []*HSPinnedCid {
	if x != nil {
		return x.Cids
	}
	return nil
}

type HSPinnedCid struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid   string             `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	Users []*HSPinnedCidUser `protobuf:"bytes,2,rep,name=users,proto3" json:"users,omitempty"`
}

func (x *HSPinnedCid) Reset() {
	*x = HSPinnedCid{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HSPinnedCid) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HSPinnedCid) ProtoMessage() {}

func (x *HSPinnedCid) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HSPinnedCid.ProtoReflect.Descriptor instead.
func (*HSPinnedCid) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{25}
}

func (x *HSPinnedCid) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *HSPinnedCid) GetUsers() []*HSPinnedCidUser {
	if x != nil {
		return x.Users
	}
	return nil
}

type HSPinnedCidUser struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId    string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Staged    bool   `protobuf:"varint,2,opt,name=staged,proto3" json:"staged,omitempty"`
	CreatedAt int64  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *HSPinnedCidUser) Reset() {
	*x = HSPinnedCidUser{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HSPinnedCidUser) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HSPinnedCidUser) ProtoMessage() {}

func (x *HSPinnedCidUser) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HSPinnedCidUser.ProtoReflect.Descriptor instead.
func (*HSPinnedCidUser) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{26}
}

func (x *HSPinnedCidUser) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *HSPinnedCidUser) GetStaged() bool {
	if x != nil {
		return x.Staged
	}
	return false
}

func (x *HSPinnedCidUser) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

type GetUpdatedStorageDealRecordsSinceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Since *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=since,proto3" json:"since,omitempty"`
	Limit int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *GetUpdatedStorageDealRecordsSinceRequest) Reset() {
	*x = GetUpdatedStorageDealRecordsSinceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetUpdatedStorageDealRecordsSinceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUpdatedStorageDealRecordsSinceRequest) ProtoMessage() {}

func (x *GetUpdatedStorageDealRecordsSinceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUpdatedStorageDealRecordsSinceRequest.ProtoReflect.Descriptor instead.
func (*GetUpdatedStorageDealRecordsSinceRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{27}
}

func (x *GetUpdatedStorageDealRecordsSinceRequest) GetSince() *timestamppb.Timestamp {
	if x != nil {
		return x.Since
	}
	return nil
}

func (x *GetUpdatedStorageDealRecordsSinceRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type GetUpdatedStorageDealRecordsSinceResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Records []*v1.StorageDealRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *GetUpdatedStorageDealRecordsSinceResponse) Reset() {
	*x = GetUpdatedStorageDealRecordsSinceResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetUpdatedStorageDealRecordsSinceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUpdatedStorageDealRecordsSinceResponse) ProtoMessage() {}

func (x *GetUpdatedStorageDealRecordsSinceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUpdatedStorageDealRecordsSinceResponse.ProtoReflect.Descriptor instead.
func (*GetUpdatedStorageDealRecordsSinceResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{28}
}

func (x *GetUpdatedStorageDealRecordsSinceResponse) GetRecords() []*v1.StorageDealRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type GetUpdatedRetrievalRecordsSinceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Since *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=since,proto3" json:"since,omitempty"`
	Limit int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *GetUpdatedRetrievalRecordsSinceRequest) Reset() {
	*x = GetUpdatedRetrievalRecordsSinceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetUpdatedRetrievalRecordsSinceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUpdatedRetrievalRecordsSinceRequest) ProtoMessage() {}

func (x *GetUpdatedRetrievalRecordsSinceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUpdatedRetrievalRecordsSinceRequest.ProtoReflect.Descriptor instead.
func (*GetUpdatedRetrievalRecordsSinceRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{29}
}

func (x *GetUpdatedRetrievalRecordsSinceRequest) GetSince() *timestamppb.Timestamp {
	if x != nil {
		return x.Since
	}
	return nil
}

func (x *GetUpdatedRetrievalRecordsSinceRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type GetUpdatedRetrievalRecordsSinceResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Records []*v1.RetrievalDealRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *GetUpdatedRetrievalRecordsSinceResponse) Reset() {
	*x = GetUpdatedRetrievalRecordsSinceResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetUpdatedRetrievalRecordsSinceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUpdatedRetrievalRecordsSinceResponse) ProtoMessage() {}

func (x *GetUpdatedRetrievalRecordsSinceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUpdatedRetrievalRecordsSinceResponse.ProtoReflect.Descriptor instead.
func (*GetUpdatedRetrievalRecordsSinceResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{30}
}

func (x *GetUpdatedRetrievalRecordsSinceResponse) GetRecords() []*v1.RetrievalDealRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type GetMinersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	WithPower bool `protobuf:"varint,1,opt,name=with_power,json=withPower,proto3" json:"with_power,omitempty"`
}

func (x *GetMinersRequest) Reset() {
	*x = GetMinersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMinersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMinersRequest) ProtoMessage() {}

func (x *GetMinersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMinersRequest.ProtoReflect.Descriptor instead.
func (*GetMinersRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{31}
}

func (x *GetMinersRequest) GetWithPower() bool {
	if x != nil {
		return x.WithPower
	}
	return false
}

type GetMinersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Miners []*FilecoinMiner `protobuf:"bytes,1,rep,name=miners,proto3" json:"miners,omitempty"`
}

func (x *GetMinersResponse) Reset() {
	*x = GetMinersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMinersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMinersResponse) ProtoMessage() {}

func (x *GetMinersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMinersResponse.ProtoReflect.Descriptor instead.
func (*GetMinersResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{32}
}

func (x *GetMinersResponse) GetMiners() []*FilecoinMiner {
	if x != nil {
		return x.Miners
	}
	return nil
}

type FilecoinMiner struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *FilecoinMiner) Reset() {
	*x = FilecoinMiner{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilecoinMiner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilecoinMiner) ProtoMessage() {}

func (x *FilecoinMiner) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilecoinMiner.ProtoReflect.Descriptor instead.
func (*FilecoinMiner) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{33}
}

func (x *FilecoinMiner) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type GetMinerInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Miners []string `protobuf:"bytes,1,rep,name=miners,proto3" json:"miners,omitempty"`
}

func (x *GetMinerInfoRequest) Reset() {
	*x = GetMinerInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMinerInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMinerInfoRequest) ProtoMessage() {}

func (x *GetMinerInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMinerInfoRequest.ProtoReflect.Descriptor instead.
func (*GetMinerInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{34}
}

func (x *GetMinerInfoRequest) GetMiners() []string {
	if x != nil {
		return x.Miners
	}
	return nil
}

type GetMinerInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MinersInfo []*MinerInfo `protobuf:"bytes,1,rep,name=miners_info,json=minersInfo,proto3" json:"miners_info,omitempty"`
}

func (x *GetMinerInfoResponse) Reset() {
	*x = GetMinerInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMinerInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMinerInfoResponse) ProtoMessage() {}

func (x *GetMinerInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMinerInfoResponse.ProtoReflect.Descriptor instead.
func (*GetMinerInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{35}
}

func (x *GetMinerInfoResponse) GetMinersInfo() []*MinerInfo {
	if x != nil {
		return x.MinersInfo
	}
	return nil
}

type MinerInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address          string  `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	RelativePower    float64 `protobuf:"fixed64,2,opt,name=relative_power,json=relativePower,proto3" json:"relative_power,omitempty"`
	AskPrice         string  `protobuf:"bytes,4,opt,name=ask_price,json=askPrice,proto3" json:"ask_price,omitempty"`
	AskVerifiedPrice string  `protobuf:"bytes,5,opt,name=ask_verified_price,json=askVerifiedPrice,proto3" json:"ask_verified_price,omitempty"`
	MinPieceSize     uint64  `protobuf:"varint,6,opt,name=min_piece_size,json=minPieceSize,proto3" json:"min_piece_size,omitempty"`
	MaxPieceSize     uint64  `protobuf:"varint,7,opt,name=max_piece_size,json=maxPieceSize,proto3" json:"max_piece_size,omitempty"`
	SectorSize       uint64  `protobuf:"varint,8,opt,name=sector_size,json=sectorSize,proto3" json:"sector_size,omitempty"`
	SectorsActive    uint64  `protobuf:"varint,9,opt,name=sectors_active,json=sectorsActive,proto3" json:"sectors_active,omitempty"`
	SectorsLive      uint64  `protobuf:"varint,10,opt,name=sectors_live,json=sectorsLive,proto3" json:"sectors_live,omitempty"`
	SectorsFaulty    uint64  `protobuf:"varint,11,opt,name=sectors_faulty,json=sectorsFaulty,proto3" json:"sectors_faulty,omitempty"`
	Location         string  `protobuf:"bytes,12,opt,name=location,proto3" json:"location,omitempty"`
}

func (x *MinerInfo) Reset() {
	*x = MinerInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_admin_v1_admin_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MinerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MinerInfo) ProtoMessage() {}

func (x *MinerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_admin_v1_admin_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MinerInfo.ProtoReflect.Descriptor instead.
func (*MinerInfo) Descriptor() ([]byte, []int) {
	return file_powergate_admin_v1_admin_proto_rawDescGZIP(), []int{36}
}

func (x *MinerInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *MinerInfo) GetRelativePower() float64 {
	if x != nil {
		return x.RelativePower
	}
	return 0
}

func (x *MinerInfo) GetAskPrice() string {
	if x != nil {
		return x.AskPrice
	}
	return ""
}

func (x *MinerInfo) GetAskVerifiedPrice() string {
	if x != nil {
		return x.AskVerifiedPrice
	}
	return ""
}

func (x *MinerInfo) GetMinPieceSize() uint64 {
	if x != nil {
		return x.MinPieceSize
	}
	return 0
}

func (x *MinerInfo) GetMaxPieceSize() uint64 {
	if x != nil {
		return x.MaxPieceSize
	}
	return 0
}

func (x *MinerInfo) GetSectorSize() uint64 {
	if x != nil {
		return x.SectorSize
	}
	return 0
}

func (x *MinerInfo) GetSectorsActive() uint64 {
	if x != nil {
		return x.SectorsActive
	}
	return 0
}

func (x *MinerInfo) GetSectorsLive() uint64 {
	if x != nil {
		return x.SectorsLive
	}
	return 0
}

func (x *MinerInfo) GetSectorsFaulty() uint64 {
	if x != nil {
		return x.SectorsFaulty
	}
	return 0
}

func (x *MinerInfo) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

var File_powergate_admin_v1_admin_proto protoreflect.FileDescriptor

var file_powergate_admin_v1_admin_proto_rawDesc = []byte{
	0x0a, 0x1e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2f, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x12, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2e, 0x76, 0x31, 0x1a, 0x1c, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2f,
	0x75, 0x73, 0x65, 0x72, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0x36, 0x0a, 0x11, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65, 0x22, 0x2e, 0x0a, 0x12, 0x4e,
	0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x12, 0x0a, 0x10, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22,
	0x31, 0x0a, 0x11, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x73, 0x22, 0x4c, 0x0a, 0x0e, 0x53, 0x65, 0x6e, 0x64, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x22, 0x23, 0x0a, 0x0f, 0x53, 0x65, 0x6e, 0x64, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0x2c, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a,
	0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a,
	0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x22, 0x13, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65,
	0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x42, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c,
	0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x2d, 0x0a, 0x15,
	0x52, 0x65, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x35, 0x0a, 0x16, 0x52,
	0x65, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x5f, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x65, 0x77, 0x54, 0x6f, 0x6b,
	0x65, 0x6e, 0x22, 0x0e, 0x0a, 0x0c, 0x55, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x22, 0x3f, 0x0a, 0x0d, 0x55, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x18, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61,
	0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73,
	0x65, 0x72, 0x73, 0x22, 0x3f, 0x0a, 0x12, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65,
	0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72,
	0x49, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x03, 0x63, 0x69, 0x64, 0x22, 0x58, 0x0a, 0x13, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x0c, 0x73,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x47,
	0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72,
	0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x75, 0x73, 0x65, 0x72,
	0x49, 0x64, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x04, 0x63, 0x69, 0x64, 0x73, 0x22, 0x5c, 0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x41, 0x0a, 0x0c, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67,
	0x65, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0xfd, 0x01, 0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x24, 0x0a, 0x0e, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64,
	0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x69, 0x64, 0x5f, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x69, 0x64, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x61,
	0x73, 0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09,
	0x61, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x26, 0x0a, 0x0f, 0x6e, 0x65, 0x78,
	0x74, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0d, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65,
	0x6e, 0x12, 0x42, 0x0a, 0x08, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x73, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x08, 0x73, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x22, 0x97, 0x01, 0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x40, 0x0a, 0x0c, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x04, 0x6d, 0x6f, 0x72, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x6e, 0x65, 0x78, 0x74, 0x5f,
	0x70, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0d, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22,
	0x46, 0x0a, 0x19, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75,
	0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07,
	0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75,
	0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0xb0, 0x01, 0x0a, 0x1a, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x13, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64,
	0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x11, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x34, 0x0a, 0x16, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
	0x69, 0x6e, 0x67, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x14, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e,
	0x67, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x2c, 0x0a, 0x12,
	0x66, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f,
	0x62, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x10, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x22, 0x11, 0x0a, 0x0f, 0x47, 0x43,
	0x53, 0x74, 0x61, 0x67, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x37, 0x0a,
	0x10, 0x47, 0x43, 0x53, 0x74, 0x61, 0x67, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x23, 0x0a, 0x0d, 0x75, 0x6e, 0x70, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x5f, 0x63, 0x69,
	0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x75, 0x6e, 0x70, 0x69, 0x6e, 0x6e,
	0x65, 0x64, 0x43, 0x69, 0x64, 0x73, 0x22, 0x13, 0x0a, 0x11, 0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64,
	0x43, 0x69, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x49, 0x0a, 0x12, 0x50,
	0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x33, 0x0a, 0x04, 0x63, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1f, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x53, 0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64,
	0x52, 0x04, 0x63, 0x69, 0x64, 0x73, 0x22, 0x5a, 0x0a, 0x0b, 0x48, 0x53, 0x50, 0x69, 0x6e, 0x6e,
	0x65, 0x64, 0x43, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12, 0x39, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x53, 0x50, 0x69,
	0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73, 0x65,
	0x72, 0x73, 0x22, 0x61, 0x0a, 0x0f, 0x48, 0x53, 0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69,
	0x64, 0x55, 0x73, 0x65, 0x72, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x16,
	0x0a, 0x06, 0x73, 0x74, 0x61, 0x67, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
	0x73, 0x74, 0x61, 0x67, 0x65, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x72, 0x0a, 0x28, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x30, 0x0a, 0x05, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x05, 0x73, 0x69,
	0x6e, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x6b, 0x0a, 0x29, 0x47, 0x65, 0x74,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65,
	0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x72,
	0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x70, 0x0a, 0x26, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x64, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x30, 0x0a, 0x05, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x05, 0x73, 0x69, 0x6e,
	0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x6b, 0x0a, 0x27, 0x47, 0x65, 0x74, 0x55,
	0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x52,
	0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76,
	0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x72, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x31, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65,
	0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x77, 0x69, 0x74,
	0x68, 0x5f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x77,
	0x69, 0x74, 0x68, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x22, 0x4e, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x4d,
	0x69, 0x6e, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39, 0x0a,
	0x06, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x63, 0x6f, 0x69, 0x6e, 0x4d, 0x69, 0x6e, 0x65, 0x72,
	0x52, 0x06, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x22, 0x29, 0x0a, 0x0d, 0x46, 0x69, 0x6c, 0x65,
	0x63, 0x6f, 0x69, 0x6e, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x22, 0x2d, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x69,
	0x6e, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x69, 0x6e, 0x65,
	0x72, 0x73, 0x22, 0x56, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x0b, 0x6d, 0x69,
	0x6e, 0x65, 0x72, 0x73, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0a,
	0x6d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x91, 0x03, 0x0a, 0x09, 0x4d,
	0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x72, 0x65, 0x6c, 0x61,
	0x74, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x61, 0x73, 0x6b,
	0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x61, 0x73,
	0x6b, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x61, 0x73, 0x6b, 0x5f, 0x76, 0x65,
	0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x10, 0x61, 0x73, 0x6b, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x50,
	0x72, 0x69, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x69, 0x65, 0x63,
	0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x6d, 0x69,
	0x6e, 0x50, 0x69, 0x65, 0x63, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x24, 0x0a, 0x0e, 0x6d, 0x61,
	0x78, 0x5f, 0x70, 0x69, 0x65, 0x63, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0c, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x65, 0x63, 0x65, 0x53, 0x69, 0x7a, 0x65,
	0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x53, 0x69, 0x7a,
	0x65, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x5f, 0x61, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x73, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x73, 0x5f, 0x6c, 0x69, 0x76, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b,
	0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x4c, 0x69, 0x76, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x73,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x79, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0d, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x46, 0x61, 0x75, 0x6c,
	0x74, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x32, 0xab,
	0x0d, 0x0a, 0x0c, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
	0x5d, 0x0a, 0x0a, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x25, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5a,
	0x0a, 0x09, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x24, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x54, 0x0a, 0x07, 0x53, 0x65,
	0x6e, 0x64, 0x46, 0x69, 0x6c, 0x12, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6e, 0x64, 0x46,
	0x69, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x53,
	0x65, 0x6e, 0x64, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x5d, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x25,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x69, 0x0a, 0x0e, 0x52, 0x65, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74,
	0x68, 0x12, 0x29, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
	0x65, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x52, 0x65, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x68,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4e, 0x0a, 0x05, 0x55, 0x73,
	0x65, 0x72, 0x73, 0x12, 0x20, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x60, 0x0a, 0x0b, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x27, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x6c, 0x0a, 0x0f,
	0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x2a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x6c, 0x0a, 0x0f, 0x4c, 0x69,
	0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x2a, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f,
	0x62, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x75, 0x0a, 0x12, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x2d,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53,
	0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2e, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75,
	0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0xa2, 0x01, 0x0a, 0x21, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73,
	0x53, 0x69, 0x6e, 0x63, 0x65, 0x12, 0x3c, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c,
	0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x3d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x9c, 0x01, 0x0a, 0x1f, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x64, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x12, 0x3a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65,
	0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61,
	0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x3b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x64, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x57, 0x0a, 0x08, 0x47, 0x43, 0x53, 0x74, 0x61, 0x67, 0x65, 0x64, 0x12,
	0x23, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x43, 0x53, 0x74, 0x61, 0x67, 0x65, 0x64, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x43, 0x53, 0x74, 0x61, 0x67,
	0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5d, 0x0a, 0x0a,
	0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64, 0x73, 0x12, 0x25, 0x2e, 0x70, 0x6f, 0x77,
	0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x69, 0x64,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5a, 0x0a, 0x09, 0x47,
	0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x12, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65,
	0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x63, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x4d, 0x69,
	0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x27, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74,
	0x4d, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x28, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x61, 0x64, 0x6d,
	0x69, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x46, 0x5a, 0x44,
	0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x69,
	0x6c, 0x65, 0x69, 0x6f, 0x2f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2f, 0x76,
	0x32, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2f, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2f, 0x76, 0x31, 0x3b, 0x61, 0x64, 0x6d,
	0x69, 0x6e, 0x50, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_powergate_admin_v1_admin_proto_rawDescOnce sync.Once
	file_powergate_admin_v1_admin_proto_rawDescData = file_powergate_admin_v1_admin_proto_rawDesc
)

func file_powergate_admin_v1_admin_proto_rawDescGZIP() []byte {
	file_powergate_admin_v1_admin_proto_rawDescOnce.Do(func() {
		file_powergate_admin_v1_admin_proto_rawDescData = protoimpl.X.CompressGZIP(file_powergate_admin_v1_admin_proto_rawDescData)
	})
	return file_powergate_admin_v1_admin_proto_rawDescData
}

var file_powergate_admin_v1_admin_proto_msgTypes = make([]protoimpl.MessageInfo, 37)
var file_powergate_admin_v1_admin_proto_goTypes = []interface{}{
	(*NewAddressRequest)(nil),                         // 0: powergate.admin.v1.NewAddressRequest
	(*NewAddressResponse)(nil),                        // 1: powergate.admin.v1.NewAddressResponse
	(*AddressesRequest)(nil),                          // 2: powergate.admin.v1.AddressesRequest
	(*AddressesResponse)(nil),                         // 3: powergate.admin.v1.AddressesResponse
	(*SendFilRequest)(nil),                            // 4: powergate.admin.v1.SendFilRequest
	(*SendFilResponse)(nil),                           // 5: powergate.admin.v1.SendFilResponse
	(*User)(nil),                                      // 6: powergate.admin.v1.User
	(*CreateUserRequest)(nil),                         // 7: powergate.admin.v1.CreateUserRequest
	(*CreateUserResponse)(nil),                        // 8: powergate.admin.v1.CreateUserResponse
	(*RegenerateAuthRequest)(nil),                     // 9: powergate.admin.v1.RegenerateAuthRequest
	(*RegenerateAuthResponse)(nil),                    // 10: powergate.admin.v1.RegenerateAuthResponse
	(*UsersRequest)(nil),                              // 11: powergate.admin.v1.UsersRequest
	(*UsersResponse)(nil),                             // 12: powergate.admin.v1.UsersResponse
	(*StorageInfoRequest)(nil),                        // 13: powergate.admin.v1.StorageInfoRequest
	(*StorageInfoResponse)(nil),                       // 14: powergate.admin.v1.StorageInfoResponse
	(*ListStorageInfoRequest)(nil),                    // 15: powergate.admin.v1.ListStorageInfoRequest
	(*ListStorageInfoResponse)(nil),                   // 16: powergate.admin.v1.ListStorageInfoResponse
	(*ListStorageJobsRequest)(nil),                    // 17: powergate.admin.v1.ListStorageJobsRequest
	(*ListStorageJobsResponse)(nil),                   // 18: powergate.admin.v1.ListStorageJobsResponse
	(*StorageJobsSummaryRequest)(nil),                 // 19: powergate.admin.v1.StorageJobsSummaryRequest
	(*StorageJobsSummaryResponse)(nil),                // 20: powergate.admin.v1.StorageJobsSummaryResponse
	(*GCStagedRequest)(nil),                           // 21: powergate.admin.v1.GCStagedRequest
	(*GCStagedResponse)(nil),                          // 22: powergate.admin.v1.GCStagedResponse
	(*PinnedCidsRequest)(nil),                         // 23: powergate.admin.v1.PinnedCidsRequest
	(*PinnedCidsResponse)(nil),                        // 24: powergate.admin.v1.PinnedCidsResponse
	(*HSPinnedCid)(nil),                               // 25: powergate.admin.v1.HSPinnedCid
	(*HSPinnedCidUser)(nil),                           // 26: powergate.admin.v1.HSPinnedCidUser
	(*GetUpdatedStorageDealRecordsSinceRequest)(nil),  // 27: powergate.admin.v1.GetUpdatedStorageDealRecordsSinceRequest
	(*GetUpdatedStorageDealRecordsSinceResponse)(nil), // 28: powergate.admin.v1.GetUpdatedStorageDealRecordsSinceResponse
	(*GetUpdatedRetrievalRecordsSinceRequest)(nil),    // 29: powergate.admin.v1.GetUpdatedRetrievalRecordsSinceRequest
	(*GetUpdatedRetrievalRecordsSinceResponse)(nil),   // 30: powergate.admin.v1.GetUpdatedRetrievalRecordsSinceResponse
	(*GetMinersRequest)(nil),                          // 31: powergate.admin.v1.GetMinersRequest
	(*GetMinersResponse)(nil),                         // 32: powergate.admin.v1.GetMinersResponse
	(*FilecoinMiner)(nil),                             // 33: powergate.admin.v1.FilecoinMiner
	(*GetMinerInfoRequest)(nil),                       // 34: powergate.admin.v1.GetMinerInfoRequest
	(*GetMinerInfoResponse)(nil),                      // 35: powergate.admin.v1.GetMinerInfoResponse
	(*MinerInfo)(nil),                                 // 36: powergate.admin.v1.MinerInfo
	(*v1.StorageInfo)(nil),                            // 37: powergate.user.v1.StorageInfo
	(v1.StorageJobsSelector)(0),                       // 38: powergate.user.v1.StorageJobsSelector
	(*v1.StorageJob)(nil),                             // 39: powergate.user.v1.StorageJob
	(*timestamppb.Timestamp)(nil),                     // 40: google.protobuf.Timestamp
	(*v1.StorageDealRecord)(nil),                      // 41: powergate.user.v1.StorageDealRecord
	(*v1.RetrievalDealRecord)(nil),                    // 42: powergate.user.v1.RetrievalDealRecord
}
var file_powergate_admin_v1_admin_proto_depIdxs = []int32{
	6,  // 0: powergate.admin.v1.CreateUserResponse.user:type_name -> powergate.admin.v1.User
	6,  // 1: powergate.admin.v1.UsersResponse.users:type_name -> powergate.admin.v1.User
	37, // 2: powergate.admin.v1.StorageInfoResponse.storage_info:type_name -> powergate.user.v1.StorageInfo
	37, // 3: powergate.admin.v1.ListStorageInfoResponse.storage_info:type_name -> powergate.user.v1.StorageInfo
	38, // 4: powergate.admin.v1.ListStorageJobsRequest.selector:type_name -> powergate.user.v1.StorageJobsSelector
	39, // 5: powergate.admin.v1.ListStorageJobsResponse.storage_jobs:type_name -> powergate.user.v1.StorageJob
	25, // 6: powergate.admin.v1.PinnedCidsResponse.cids:type_name -> powergate.admin.v1.HSPinnedCid
	26, // 7: powergate.admin.v1.HSPinnedCid.users:type_name -> powergate.admin.v1.HSPinnedCidUser
	40, // 8: powergate.admin.v1.GetUpdatedStorageDealRecordsSinceRequest.since:type_name -> google.protobuf.Timestamp
	41, // 9: powergate.admin.v1.GetUpdatedStorageDealRecordsSinceResponse.records:type_name -> powergate.user.v1.StorageDealRecord
	40, // 10: powergate.admin.v1.GetUpdatedRetrievalRecordsSinceRequest.since:type_name -> google.protobuf.Timestamp
	42, // 11: powergate.admin.v1.GetUpdatedRetrievalRecordsSinceResponse.records:type_name -> powergate.user.v1.RetrievalDealRecord
	33, // 12: powergate.admin.v1.GetMinersResponse.miners:type_name -> powergate.admin.v1.FilecoinMiner
	36, // 13: powergate.admin.v1.GetMinerInfoResponse.miners_info:type_name -> powergate.admin.v1.MinerInfo
	0,  // 14: powergate.admin.v1.AdminService.NewAddress:input_type -> powergate.admin.v1.NewAddressRequest
	2,  // 15: powergate.admin.v1.AdminService.Addresses:input_type -> powergate.admin.v1.AddressesRequest
	4,  // 16: powergate.admin.v1.AdminService.SendFil:input_type -> powergate.admin.v1.SendFilRequest
	7,  // 17: powergate.admin.v1.AdminService.CreateUser:input_type -> powergate.admin.v1.CreateUserRequest
	9,  // 18: powergate.admin.v1.AdminService.RegenerateAuth:input_type -> powergate.admin.v1.RegenerateAuthRequest
	11, // 19: powergate.admin.v1.AdminService.Users:input_type -> powergate.admin.v1.UsersRequest
	13, // 20: powergate.admin.v1.AdminService.StorageInfo:input_type -> powergate.admin.v1.StorageInfoRequest
	15, // 21: powergate.admin.v1.AdminService.ListStorageInfo:input_type -> powergate.admin.v1.ListStorageInfoRequest
	17, // 22: powergate.admin.v1.AdminService.ListStorageJobs:input_type -> powergate.admin.v1.ListStorageJobsRequest
	19, // 23: powergate.admin.v1.AdminService.StorageJobsSummary:input_type -> powergate.admin.v1.StorageJobsSummaryRequest
	27, // 24: powergate.admin.v1.AdminService.GetUpdatedStorageDealRecordsSince:input_type -> powergate.admin.v1.GetUpdatedStorageDealRecordsSinceRequest
	29, // 25: powergate.admin.v1.AdminService.GetUpdatedRetrievalRecordsSince:input_type -> powergate.admin.v1.GetUpdatedRetrievalRecordsSinceRequest
	21, // 26: powergate.admin.v1.AdminService.GCStaged:input_type -> powergate.admin.v1.GCStagedRequest
	23, // 27: powergate.admin.v1.AdminService.PinnedCids:input_type -> powergate.admin.v1.PinnedCidsRequest
	31, // 28: powergate.admin.v1.AdminService.GetMiners:input_type -> powergate.admin.v1.GetMinersRequest
	34, // 29: powergate.admin.v1.AdminService.GetMinerInfo:input_type -> powergate.admin.v1.GetMinerInfoRequest
	1,  // 30: powergate.admin.v1.AdminService.NewAddress:output_type -> powergate.admin.v1.NewAddressResponse
	3,  // 31: powergate.admin.v1.AdminService.Addresses:output_type -> powergate.admin.v1.AddressesResponse
	5,  // 32: powergate.admin.v1.AdminService.SendFil:output_type -> powergate.admin.v1.SendFilResponse
	8,  // 33: powergate.admin.v1.AdminService.CreateUser:output_type -> powergate.admin.v1.CreateUserResponse
	10, // 34: powergate.admin.v1.AdminService.RegenerateAuth:output_type -> powergate.admin.v1.RegenerateAuthResponse
	12, // 35: powergate.admin.v1.AdminService.Users:output_type -> powergate.admin.v1.UsersResponse
	14, // 36: powergate.admin.v1.AdminService.StorageInfo:output_type -> powergate.admin.v1.StorageInfoResponse
	16, // 37: powergate.admin.v1.AdminService.ListStorageInfo:output_type -> powergate.admin.v1.ListStorageInfoResponse
	18, // 38: powergate.admin.v1.AdminService.ListStorageJobs:output_type -> powergate.admin.v1.ListStorageJobsResponse
	20, // 39: powergate.admin.v1.AdminService.StorageJobsSummary:output_type -> powergate.admin.v1.StorageJobsSummaryResponse
	28, // 40: powergate.admin.v1.AdminService.GetUpdatedStorageDealRecordsSince:output_type -> powergate.admin.v1.GetUpdatedStorageDealRecordsSinceResponse
	30, // 41: powergate.admin.v1.AdminService.GetUpdatedRetrievalRecordsSince:output_type -> powergate.admin.v1.GetUpdatedRetrievalRecordsSinceResponse
	22, // 42: powergate.admin.v1.AdminService.GCStaged:output_type -> powergate.admin.v1.GCStagedResponse
	24, // 43: powergate.admin.v1.AdminService.PinnedCids:output_type -> powergate.admin.v1.PinnedCidsResponse
	32, // 44: powergate.admin.v1.AdminService.GetMiners:output_type -> powergate.admin.v1.GetMinersResponse
	35, // 45: powergate.admin.v1.AdminService.GetMinerInfo:output_type -> powergate.admin.v1.GetMinerInfoResponse
	30, // [30:46] is the sub-list for method output_type
	14, // [14:30] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_powergate_admin_v1_admin_proto_init() }
func file_powergate_admin_v1_admin_proto_init() {
	if File_powergate_admin_v1_admin_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_powergate_admin_v1_admin_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewAddressRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewAddressResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendFilRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendFilResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateUserRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateUserResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegenerateAuthRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegenerateAuthResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UsersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UsersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageJobsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageJobsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobsSummaryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobsSummaryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GCStagedRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GCStagedResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PinnedCidsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PinnedCidsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HSPinnedCid); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HSPinnedCidUser); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetUpdatedStorageDealRecordsSinceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetUpdatedStorageDealRecordsSinceResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetUpdatedRetrievalRecordsSinceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetUpdatedRetrievalRecordsSinceResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMinersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMinersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilecoinMiner); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMinerInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMinerInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_admin_v1_admin_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MinerInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_powergate_admin_v1_admin_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   37,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_powergate_admin_v1_admin_proto_goTypes,
		DependencyIndexes: file_powergate_admin_v1_admin_proto_depIdxs,
		MessageInfos:      file_powergate_admin_v1_admin_proto_msgTypes,
	}.Build()
	File_powergate_admin_v1_admin_proto = out.File
	file_powergate_admin_v1_admin_proto_rawDesc = nil
	file_powergate_admin_v1_admin_proto_goTypes = nil
	file_powergate_admin_v1_admin_proto_depIdxs = nil
}

'''
'''--- Filecoin/powergate/api/gen/powergate/admin/v1/admin_grpc.pb.go ---
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package adminPb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// AdminServiceClient is the client API for AdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminServiceClient interface {
	// Wallet
	NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	Addresses(ctx context.Context, in *AddressesRequest, opts ...grpc.CallOption) (*AddressesResponse, error)
	SendFil(ctx context.Context, in *SendFilRequest, opts ...grpc.CallOption) (*SendFilResponse, error)
	// Users
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	RegenerateAuth(ctx context.Context, in *RegenerateAuthRequest, opts ...grpc.CallOption) (*RegenerateAuthResponse, error)
	Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// Storage Info
	StorageInfo(ctx context.Context, in *StorageInfoRequest, opts ...grpc.CallOption) (*StorageInfoResponse, error)
	ListStorageInfo(ctx context.Context, in *ListStorageInfoRequest, opts ...grpc.CallOption) (*ListStorageInfoResponse, error)
	// Storage Jobs
	ListStorageJobs(ctx context.Context, in *ListStorageJobsRequest, opts ...grpc.CallOption) (*ListStorageJobsResponse, error)
	StorageJobsSummary(ctx context.Context, in *StorageJobsSummaryRequest, opts ...grpc.CallOption) (*StorageJobsSummaryResponse, error)
	// Updated Records
	GetUpdatedStorageDealRecordsSince(ctx context.Context, in *GetUpdatedStorageDealRecordsSinceRequest, opts ...grpc.CallOption) (*GetUpdatedStorageDealRecordsSinceResponse, error)
	GetUpdatedRetrievalRecordsSince(ctx context.Context, in *GetUpdatedRetrievalRecordsSinceRequest, opts ...grpc.CallOption) (*GetUpdatedRetrievalRecordsSinceResponse, error)
	GCStaged(ctx context.Context, in *GCStagedRequest, opts ...grpc.CallOption) (*GCStagedResponse, error)
	PinnedCids(ctx context.Context, in *PinnedCidsRequest, opts ...grpc.CallOption) (*PinnedCidsResponse, error)
	// Indices
	GetMiners(ctx context.Context, in *GetMinersRequest, opts ...grpc.CallOption) (*GetMinersResponse, error)
	GetMinerInfo(ctx context.Context, in *GetMinerInfoRequest, opts ...grpc.CallOption) (*GetMinerInfoResponse, error)
}

type adminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminServiceClient(cc grpc.ClientConnInterface) AdminServiceClient {
	return &adminServiceClient{cc}
}

func (c *adminServiceClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/NewAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) Addresses(ctx context.Context, in *AddressesRequest, opts ...grpc.CallOption) (*AddressesResponse, error) {
	out := new(AddressesResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/Addresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) SendFil(ctx context.Context, in *SendFilRequest, opts ...grpc.CallOption) (*SendFilResponse, error) {
	out := new(SendFilResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/SendFil", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) RegenerateAuth(ctx context.Context, in *RegenerateAuthRequest, opts ...grpc.CallOption) (*RegenerateAuthResponse, error) {
	out := new(RegenerateAuthResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/RegenerateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/Users", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) StorageInfo(ctx context.Context, in *StorageInfoRequest, opts ...grpc.CallOption) (*StorageInfoResponse, error) {
	out := new(StorageInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/StorageInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListStorageInfo(ctx context.Context, in *ListStorageInfoRequest, opts ...grpc.CallOption) (*ListStorageInfoResponse, error) {
	out := new(ListStorageInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/ListStorageInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListStorageJobs(ctx context.Context, in *ListStorageJobsRequest, opts ...grpc.CallOption) (*ListStorageJobsResponse, error) {
	out := new(ListStorageJobsResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/ListStorageJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) StorageJobsSummary(ctx context.Context, in *StorageJobsSummaryRequest, opts ...grpc.CallOption) (*StorageJobsSummaryResponse, error) {
	out := new(StorageJobsSummaryResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/StorageJobsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetUpdatedStorageDealRecordsSince(ctx context.Context, in *GetUpdatedStorageDealRecordsSinceRequest, opts ...grpc.CallOption) (*GetUpdatedStorageDealRecordsSinceResponse, error) {
	out := new(GetUpdatedStorageDealRecordsSinceResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/GetUpdatedStorageDealRecordsSince", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetUpdatedRetrievalRecordsSince(ctx context.Context, in *GetUpdatedRetrievalRecordsSinceRequest, opts ...grpc.CallOption) (*GetUpdatedRetrievalRecordsSinceResponse, error) {
	out := new(GetUpdatedRetrievalRecordsSinceResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/GetUpdatedRetrievalRecordsSince", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GCStaged(ctx context.Context, in *GCStagedRequest, opts ...grpc.CallOption) (*GCStagedResponse, error) {
	out := new(GCStagedResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/GCStaged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) PinnedCids(ctx context.Context, in *PinnedCidsRequest, opts ...grpc.CallOption) (*PinnedCidsResponse, error) {
	out := new(PinnedCidsResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/PinnedCids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetMiners(ctx context.Context, in *GetMinersRequest, opts ...grpc.CallOption) (*GetMinersResponse, error) {
	out := new(GetMinersResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/GetMiners", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetMinerInfo(ctx context.Context, in *GetMinerInfoRequest, opts ...grpc.CallOption) (*GetMinerInfoResponse, error) {
	out := new(GetMinerInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.admin.v1.AdminService/GetMinerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServiceServer is the server API for AdminService service.
// All implementations must embed UnimplementedAdminServiceServer
// for forward compatibility
type AdminServiceServer interface {
	// Wallet
	NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error)
	Addresses(context.Context, *AddressesRequest) (*AddressesResponse, error)
	SendFil(context.Context, *SendFilRequest) (*SendFilResponse, error)
	// Users
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	RegenerateAuth(context.Context, *RegenerateAuthRequest) (*RegenerateAuthResponse, error)
	Users(context.Context, *UsersRequest) (*UsersResponse, error)
	// Storage Info
	StorageInfo(context.Context, *StorageInfoRequest) (*StorageInfoResponse, error)
	ListStorageInfo(context.Context, *ListStorageInfoRequest) (*ListStorageInfoResponse, error)
	// Storage Jobs
	ListStorageJobs(context.Context, *ListStorageJobsRequest) (*ListStorageJobsResponse, error)
	StorageJobsSummary(context.Context, *StorageJobsSummaryRequest) (*StorageJobsSummaryResponse, error)
	// Updated Records
	GetUpdatedStorageDealRecordsSince(context.Context, *GetUpdatedStorageDealRecordsSinceRequest) (*GetUpdatedStorageDealRecordsSinceResponse, error)
	GetUpdatedRetrievalRecordsSince(context.Context, *GetUpdatedRetrievalRecordsSinceRequest) (*GetUpdatedRetrievalRecordsSinceResponse, error)
	GCStaged(context.Context, *GCStagedRequest) (*GCStagedResponse, error)
	PinnedCids(context.Context, *PinnedCidsRequest) (*PinnedCidsResponse, error)
	// Indices
	GetMiners(context.Context, *GetMinersRequest) (*GetMinersResponse, error)
	GetMinerInfo(context.Context, *GetMinerInfoRequest) (*GetMinerInfoResponse, error)
	mustEmbedUnimplementedAdminServiceServer()
}

// UnimplementedAdminServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAdminServiceServer struct {
}

func (UnimplementedAdminServiceServer) NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewAddress not implemented")
}
func (UnimplementedAdminServiceServer) Addresses(context.Context, *AddressesRequest) (*AddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Addresses not implemented")
}
func (UnimplementedAdminServiceServer) SendFil(context.Context, *SendFilRequest) (*SendFilResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFil not implemented")
}
func (UnimplementedAdminServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedAdminServiceServer) RegenerateAuth(context.Context, *RegenerateAuthRequest) (*RegenerateAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegenerateAuth not implemented")
}
func (UnimplementedAdminServiceServer) Users(context.Context, *UsersRequest) (*UsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Users not implemented")
}
func (UnimplementedAdminServiceServer) StorageInfo(context.Context, *StorageInfoRequest) (*StorageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageInfo not implemented")
}
func (UnimplementedAdminServiceServer) ListStorageInfo(context.Context, *ListStorageInfoRequest) (*ListStorageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageInfo not implemented")
}
func (UnimplementedAdminServiceServer) ListStorageJobs(context.Context, *ListStorageJobsRequest) (*ListStorageJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageJobs not implemented")
}
func (UnimplementedAdminServiceServer) StorageJobsSummary(context.Context, *StorageJobsSummaryRequest) (*StorageJobsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageJobsSummary not implemented")
}
func (UnimplementedAdminServiceServer) GetUpdatedStorageDealRecordsSince(context.Context, *GetUpdatedStorageDealRecordsSinceRequest) (*GetUpdatedStorageDealRecordsSinceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpdatedStorageDealRecordsSince not implemented")
}
func (UnimplementedAdminServiceServer) GetUpdatedRetrievalRecordsSince(context.Context, *GetUpdatedRetrievalRecordsSinceRequest) (*GetUpdatedRetrievalRecordsSinceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpdatedRetrievalRecordsSince not implemented")
}
func (UnimplementedAdminServiceServer) GCStaged(context.Context, *GCStagedRequest) (*GCStagedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GCStaged not implemented")
}
func (UnimplementedAdminServiceServer) PinnedCids(context.Context, *PinnedCidsRequest) (*PinnedCidsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PinnedCids not implemented")
}
func (UnimplementedAdminServiceServer) GetMiners(context.Context, *GetMinersRequest) (*GetMinersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMiners not implemented")
}
func (UnimplementedAdminServiceServer) GetMinerInfo(context.Context, *GetMinerInfoRequest) (*GetMinerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMinerInfo not implemented")
}
func (UnimplementedAdminServiceServer) mustEmbedUnimplementedAdminServiceServer() {}

// UnsafeAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServiceServer will
// result in compilation errors.
type UnsafeAdminServiceServer interface {
	mustEmbedUnimplementedAdminServiceServer()
}

func RegisterAdminServiceServer(s grpc.ServiceRegistrar, srv AdminServiceServer) {
	s.RegisterService(&_AdminService_serviceDesc, srv)
}

func _AdminService_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).NewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/NewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).NewAddress(ctx, req.(*NewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_Addresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).Addresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/Addresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).Addresses(ctx, req.(*AddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_SendFil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendFilRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).SendFil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/SendFil",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).SendFil(ctx, req.(*SendFilRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_RegenerateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegenerateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).RegenerateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/RegenerateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).RegenerateAuth(ctx, req.(*RegenerateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_Users_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).Users(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/Users",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).Users(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_StorageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).StorageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/StorageInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).StorageInfo(ctx, req.(*StorageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListStorageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStorageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListStorageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/ListStorageInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListStorageInfo(ctx, req.(*ListStorageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListStorageJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStorageJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListStorageJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/ListStorageJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListStorageJobs(ctx, req.(*ListStorageJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_StorageJobsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageJobsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).StorageJobsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/StorageJobsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).StorageJobsSummary(ctx, req.(*StorageJobsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetUpdatedStorageDealRecordsSince_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUpdatedStorageDealRecordsSinceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetUpdatedStorageDealRecordsSince(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/GetUpdatedStorageDealRecordsSince",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetUpdatedStorageDealRecordsSince(ctx, req.(*GetUpdatedStorageDealRecordsSinceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetUpdatedRetrievalRecordsSince_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUpdatedRetrievalRecordsSinceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetUpdatedRetrievalRecordsSince(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/GetUpdatedRetrievalRecordsSince",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetUpdatedRetrievalRecordsSince(ctx, req.(*GetUpdatedRetrievalRecordsSinceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GCStaged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GCStagedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GCStaged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/GCStaged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GCStaged(ctx, req.(*GCStagedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_PinnedCids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PinnedCidsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).PinnedCids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/PinnedCids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).PinnedCids(ctx, req.(*PinnedCidsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetMiners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMinersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetMiners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/GetMiners",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetMiners(ctx, req.(*GetMinersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetMinerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMinerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetMinerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.admin.v1.AdminService/GetMinerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetMinerInfo(ctx, req.(*GetMinerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdminService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "powergate.admin.v1.AdminService",
	HandlerType: (*AdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewAddress",
			Handler:    _AdminService_NewAddress_Handler,
		},
		{
			MethodName: "Addresses",
			Handler:    _AdminService_Addresses_Handler,
		},
		{
			MethodName: "SendFil",
			Handler:    _AdminService_SendFil_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _AdminService_CreateUser_Handler,
		},
		{
			MethodName: "RegenerateAuth",
			Handler:    _AdminService_RegenerateAuth_Handler,
		},
		{
			MethodName: "Users",
			Handler:    _AdminService_Users_Handler,
		},
		{
			MethodName: "StorageInfo",
			Handler:    _AdminService_StorageInfo_Handler,
		},
		{
			MethodName: "ListStorageInfo",
			Handler:    _AdminService_ListStorageInfo_Handler,
		},
		{
			MethodName: "ListStorageJobs",
			Handler:    _AdminService_ListStorageJobs_Handler,
		},
		{
			MethodName: "StorageJobsSummary",
			Handler:    _AdminService_StorageJobsSummary_Handler,
		},
		{
			MethodName: "GetUpdatedStorageDealRecordsSince",
			Handler:    _AdminService_GetUpdatedStorageDealRecordsSince_Handler,
		},
		{
			MethodName: "GetUpdatedRetrievalRecordsSince",
			Handler:    _AdminService_GetUpdatedRetrievalRecordsSince_Handler,
		},
		{
			MethodName: "GCStaged",
			Handler:    _AdminService_GCStaged_Handler,
		},
		{
			MethodName: "PinnedCids",
			Handler:    _AdminService_PinnedCids_Handler,
		},
		{
			MethodName: "GetMiners",
			Handler:    _AdminService_GetMiners_Handler,
		},
		{
			MethodName: "GetMinerInfo",
			Handler:    _AdminService_GetMinerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "powergate/admin/v1/admin.proto",
}

'''
'''--- Filecoin/powergate/api/gen/powergate/user/v1/user.pb.go ---
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.17.3
// source: powergate/user/v1/user.proto

package userPb

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type JobStatus int32

const (
	JobStatus_JOB_STATUS_UNSPECIFIED JobStatus = 0
	JobStatus_JOB_STATUS_QUEUED      JobStatus = 1
	JobStatus_JOB_STATUS_EXECUTING   JobStatus = 2
	JobStatus_JOB_STATUS_FAILED      JobStatus = 3
	JobStatus_JOB_STATUS_CANCELED    JobStatus = 4
	JobStatus_JOB_STATUS_SUCCESS     JobStatus = 5
)

// Enum value maps for JobStatus.
var (
	JobStatus_name = map[int32]string{
		0: "JOB_STATUS_UNSPECIFIED",
		1: "JOB_STATUS_QUEUED",
		2: "JOB_STATUS_EXECUTING",
		3: "JOB_STATUS_FAILED",
		4: "JOB_STATUS_CANCELED",
		5: "JOB_STATUS_SUCCESS",
	}
	JobStatus_value = map[string]int32{
		"JOB_STATUS_UNSPECIFIED": 0,
		"JOB_STATUS_QUEUED":      1,
		"JOB_STATUS_EXECUTING":   2,
		"JOB_STATUS_FAILED":      3,
		"JOB_STATUS_CANCELED":    4,
		"JOB_STATUS_SUCCESS":     5,
	}
)

func (x JobStatus) Enum() *JobStatus {
	p := new(JobStatus)
	*p = x
	return p
}

func (x JobStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (JobStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_powergate_user_v1_user_proto_enumTypes[0].Descriptor()
}

func (JobStatus) Type() protoreflect.EnumType {
	return &file_powergate_user_v1_user_proto_enumTypes[0]
}

func (x JobStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use JobStatus.Descriptor instead.
func (JobStatus) EnumDescriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{0}
}

type StorageJobsSelector int32

const (
	StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED StorageJobsSelector = 0
	StorageJobsSelector_STORAGE_JOBS_SELECTOR_ALL         StorageJobsSelector = 1
	StorageJobsSelector_STORAGE_JOBS_SELECTOR_QUEUED      StorageJobsSelector = 2
	StorageJobsSelector_STORAGE_JOBS_SELECTOR_EXECUTING   StorageJobsSelector = 3
	StorageJobsSelector_STORAGE_JOBS_SELECTOR_FINAL       StorageJobsSelector = 4
)

// Enum value maps for StorageJobsSelector.
var (
	StorageJobsSelector_name = map[int32]string{
		0: "STORAGE_JOBS_SELECTOR_UNSPECIFIED",
		1: "STORAGE_JOBS_SELECTOR_ALL",
		2: "STORAGE_JOBS_SELECTOR_QUEUED",
		3: "STORAGE_JOBS_SELECTOR_EXECUTING",
		4: "STORAGE_JOBS_SELECTOR_FINAL",
	}
	StorageJobsSelector_value = map[string]int32{
		"STORAGE_JOBS_SELECTOR_UNSPECIFIED": 0,
		"STORAGE_JOBS_SELECTOR_ALL":         1,
		"STORAGE_JOBS_SELECTOR_QUEUED":      2,
		"STORAGE_JOBS_SELECTOR_EXECUTING":   3,
		"STORAGE_JOBS_SELECTOR_FINAL":       4,
	}
)

func (x StorageJobsSelector) Enum() *StorageJobsSelector {
	p := new(StorageJobsSelector)
	*p = x
	return p
}

func (x StorageJobsSelector) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageJobsSelector) Descriptor() protoreflect.EnumDescriptor {
	return file_powergate_user_v1_user_proto_enumTypes[1].Descriptor()
}

func (StorageJobsSelector) Type() protoreflect.EnumType {
	return &file_powergate_user_v1_user_proto_enumTypes[1]
}

func (x StorageJobsSelector) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageJobsSelector.Descriptor instead.
func (StorageJobsSelector) EnumDescriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{1}
}

type BuildInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *BuildInfoRequest) Reset() {
	*x = BuildInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BuildInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildInfoRequest) ProtoMessage() {}

func (x *BuildInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildInfoRequest.ProtoReflect.Descriptor instead.
func (*BuildInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{0}
}

type BuildInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	GitCommit  string `protobuf:"bytes,1,opt,name=git_commit,json=gitCommit,proto3" json:"git_commit,omitempty"`
	GitBranch  string `protobuf:"bytes,2,opt,name=git_branch,json=gitBranch,proto3" json:"git_branch,omitempty"`
	GitState   string `protobuf:"bytes,3,opt,name=git_state,json=gitState,proto3" json:"git_state,omitempty"`
	GitSummary string `protobuf:"bytes,4,opt,name=git_summary,json=gitSummary,proto3" json:"git_summary,omitempty"`
	BuildDate  string `protobuf:"bytes,5,opt,name=build_date,json=buildDate,proto3" json:"build_date,omitempty"`
	Version    string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *BuildInfoResponse) Reset() {
	*x = BuildInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BuildInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildInfoResponse) ProtoMessage() {}

func (x *BuildInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildInfoResponse.ProtoReflect.Descriptor instead.
func (*BuildInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{1}
}

func (x *BuildInfoResponse) GetGitCommit() string {
	if x != nil {
		return x.GitCommit
	}
	return ""
}

func (x *BuildInfoResponse) GetGitBranch() string {
	if x != nil {
		return x.GitBranch
	}
	return ""
}

func (x *BuildInfoResponse) GetGitState() string {
	if x != nil {
		return x.GitState
	}
	return ""
}

func (x *BuildInfoResponse) GetGitSummary() string {
	if x != nil {
		return x.GitSummary
	}
	return ""
}

func (x *BuildInfoResponse) GetBuildDate() string {
	if x != nil {
		return x.BuildDate
	}
	return ""
}

func (x *BuildInfoResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

type UserIdentifierRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *UserIdentifierRequest) Reset() {
	*x = UserIdentifierRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserIdentifierRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserIdentifierRequest) ProtoMessage() {}

func (x *UserIdentifierRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserIdentifierRequest.ProtoReflect.Descriptor instead.
func (*UserIdentifierRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{2}
}

type UserIdentifierResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *UserIdentifierResponse) Reset() {
	*x = UserIdentifierResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserIdentifierResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserIdentifierResponse) ProtoMessage() {}

func (x *UserIdentifierResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserIdentifierResponse.ProtoReflect.Descriptor instead.
func (*UserIdentifierResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{3}
}

func (x *UserIdentifierResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DefaultStorageConfigRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *DefaultStorageConfigRequest) Reset() {
	*x = DefaultStorageConfigRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DefaultStorageConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefaultStorageConfigRequest) ProtoMessage() {}

func (x *DefaultStorageConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefaultStorageConfigRequest.ProtoReflect.Descriptor instead.
func (*DefaultStorageConfigRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{4}
}

type DefaultStorageConfigResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DefaultStorageConfig *StorageConfig `protobuf:"bytes,1,opt,name=default_storage_config,json=defaultStorageConfig,proto3" json:"default_storage_config,omitempty"`
}

func (x *DefaultStorageConfigResponse) Reset() {
	*x = DefaultStorageConfigResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DefaultStorageConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefaultStorageConfigResponse) ProtoMessage() {}

func (x *DefaultStorageConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefaultStorageConfigResponse.ProtoReflect.Descriptor instead.
func (*DefaultStorageConfigResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{5}
}

func (x *DefaultStorageConfigResponse) GetDefaultStorageConfig() *StorageConfig {
	if x != nil {
		return x.DefaultStorageConfig
	}
	return nil
}

type SetDefaultStorageConfigRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Config *StorageConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (x *SetDefaultStorageConfigRequest) Reset() {
	*x = SetDefaultStorageConfigRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetDefaultStorageConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetDefaultStorageConfigRequest) ProtoMessage() {}

func (x *SetDefaultStorageConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetDefaultStorageConfigRequest.ProtoReflect.Descriptor instead.
func (*SetDefaultStorageConfigRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{6}
}

func (x *SetDefaultStorageConfigRequest) GetConfig() *StorageConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetDefaultStorageConfigResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SetDefaultStorageConfigResponse) Reset() {
	*x = SetDefaultStorageConfigResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetDefaultStorageConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetDefaultStorageConfigResponse) ProtoMessage() {}

func (x *SetDefaultStorageConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetDefaultStorageConfigResponse.ProtoReflect.Descriptor instead.
func (*SetDefaultStorageConfigResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{7}
}

type StageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
}

func (x *StageRequest) Reset() {
	*x = StageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StageRequest) ProtoMessage() {}

func (x *StageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StageRequest.ProtoReflect.Descriptor instead.
func (*StageRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{8}
}

func (x *StageRequest) GetChunk() []byte {
	if x != nil {
		return x.Chunk
	}
	return nil
}

type StageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StageResponse) Reset() {
	*x = StageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StageResponse) ProtoMessage() {}

func (x *StageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StageResponse.ProtoReflect.Descriptor instead.
func (*StageResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{9}
}

func (x *StageResponse) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StageCidRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StageCidRequest) Reset() {
	*x = StageCidRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StageCidRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StageCidRequest) ProtoMessage() {}

func (x *StageCidRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StageCidRequest.ProtoReflect.Descriptor instead.
func (*StageCidRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{10}
}

func (x *StageCidRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StageCidResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *StageCidResponse) Reset() {
	*x = StageCidResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StageCidResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StageCidResponse) ProtoMessage() {}

func (x *StageCidResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StageCidResponse.ProtoReflect.Descriptor instead.
func (*StageCidResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{11}
}

type ApplyStorageConfigRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid               string         `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	Config            *StorageConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	HasConfig         bool           `protobuf:"varint,3,opt,name=has_config,json=hasConfig,proto3" json:"has_config,omitempty"`
	OverrideConfig    bool           `protobuf:"varint,4,opt,name=override_config,json=overrideConfig,proto3" json:"override_config,omitempty"`
	HasOverrideConfig bool           `protobuf:"varint,5,opt,name=has_override_config,json=hasOverrideConfig,proto3" json:"has_override_config,omitempty"`
	ImportDealIds     []uint64       `protobuf:"varint,6,rep,packed,name=import_deal_ids,json=importDealIds,proto3" json:"import_deal_ids,omitempty"`
	NoExec            bool           `protobuf:"varint,7,opt,name=no_exec,json=noExec,proto3" json:"no_exec,omitempty"`
}

func (x *ApplyStorageConfigRequest) Reset() {
	*x = ApplyStorageConfigRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApplyStorageConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyStorageConfigRequest) ProtoMessage() {}

func (x *ApplyStorageConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyStorageConfigRequest.ProtoReflect.Descriptor instead.
func (*ApplyStorageConfigRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{12}
}

func (x *ApplyStorageConfigRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *ApplyStorageConfigRequest) GetConfig() *StorageConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *ApplyStorageConfigRequest) GetHasConfig() bool {
	if x != nil {
		return x.HasConfig
	}
	return false
}

func (x *ApplyStorageConfigRequest) GetOverrideConfig() bool {
	if x != nil {
		return x.OverrideConfig
	}
	return false
}

func (x *ApplyStorageConfigRequest) GetHasOverrideConfig() bool {
	if x != nil {
		return x.HasOverrideConfig
	}
	return false
}

func (x *ApplyStorageConfigRequest) GetImportDealIds() []uint64 {
	if x != nil {
		return x.ImportDealIds
	}
	return nil
}

func (x *ApplyStorageConfigRequest) GetNoExec() bool {
	if x != nil {
		return x.NoExec
	}
	return false
}

type ApplyStorageConfigResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (x *ApplyStorageConfigResponse) Reset() {
	*x = ApplyStorageConfigResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApplyStorageConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyStorageConfigResponse) ProtoMessage() {}

func (x *ApplyStorageConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyStorageConfigResponse.ProtoReflect.Descriptor instead.
func (*ApplyStorageConfigResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{13}
}

func (x *ApplyStorageConfigResponse) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

type ReplaceDataRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid1 string `protobuf:"bytes,1,opt,name=cid1,proto3" json:"cid1,omitempty"`
	Cid2 string `protobuf:"bytes,2,opt,name=cid2,proto3" json:"cid2,omitempty"`
}

func (x *ReplaceDataRequest) Reset() {
	*x = ReplaceDataRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReplaceDataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceDataRequest) ProtoMessage() {}

func (x *ReplaceDataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceDataRequest.ProtoReflect.Descriptor instead.
func (*ReplaceDataRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{14}
}

func (x *ReplaceDataRequest) GetCid1() string {
	if x != nil {
		return x.Cid1
	}
	return ""
}

func (x *ReplaceDataRequest) GetCid2() string {
	if x != nil {
		return x.Cid2
	}
	return ""
}

type ReplaceDataResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (x *ReplaceDataResponse) Reset() {
	*x = ReplaceDataResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReplaceDataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceDataResponse) ProtoMessage() {}

func (x *ReplaceDataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceDataResponse.ProtoReflect.Descriptor instead.
func (*ReplaceDataResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{15}
}

func (x *ReplaceDataResponse) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

type GetRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{16}
}

func (x *GetRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type GetResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{17}
}

func (x *GetResponse) GetChunk() []byte {
	if x != nil {
		return x.Chunk
	}
	return nil
}

type RemoveRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *RemoveRequest) Reset() {
	*x = RemoveRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveRequest) ProtoMessage() {}

func (x *RemoveRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveRequest.ProtoReflect.Descriptor instead.
func (*RemoveRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{18}
}

func (x *RemoveRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type RemoveResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RemoveResponse) Reset() {
	*x = RemoveResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoveResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveResponse) ProtoMessage() {}

func (x *RemoveResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveResponse.ProtoReflect.Descriptor instead.
func (*RemoveResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{19}
}

type WatchLogsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid     string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	JobId   string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	History bool   `protobuf:"varint,3,opt,name=history,proto3" json:"history,omitempty"`
}

func (x *WatchLogsRequest) Reset() {
	*x = WatchLogsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WatchLogsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchLogsRequest) ProtoMessage() {}

func (x *WatchLogsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchLogsRequest.ProtoReflect.Descriptor instead.
func (*WatchLogsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{20}
}

func (x *WatchLogsRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *WatchLogsRequest) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *WatchLogsRequest) GetHistory() bool {
	if x != nil {
		return x.History
	}
	return false
}

type WatchLogsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LogEntry *LogEntry `protobuf:"bytes,1,opt,name=log_entry,json=logEntry,proto3" json:"log_entry,omitempty"`
}

func (x *WatchLogsResponse) Reset() {
	*x = WatchLogsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WatchLogsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchLogsResponse) ProtoMessage() {}

func (x *WatchLogsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchLogsResponse.ProtoReflect.Descriptor instead.
func (*WatchLogsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{21}
}

func (x *WatchLogsResponse) GetLogEntry() *LogEntry {
	if x != nil {
		return x.LogEntry
	}
	return nil
}

type CidSummaryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cids []string `protobuf:"bytes,1,rep,name=cids,proto3" json:"cids,omitempty"`
}

func (x *CidSummaryRequest) Reset() {
	*x = CidSummaryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidSummaryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidSummaryRequest) ProtoMessage() {}

func (x *CidSummaryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidSummaryRequest.ProtoReflect.Descriptor instead.
func (*CidSummaryRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{22}
}

func (x *CidSummaryRequest) GetCids() []string {
	if x != nil {
		return x.Cids
	}
	return nil
}

type CidSummaryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CidSummary []*CidSummary `protobuf:"bytes,1,rep,name=cid_summary,json=cidSummary,proto3" json:"cid_summary,omitempty"`
}

func (x *CidSummaryResponse) Reset() {
	*x = CidSummaryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidSummaryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidSummaryResponse) ProtoMessage() {}

func (x *CidSummaryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidSummaryResponse.ProtoReflect.Descriptor instead.
func (*CidSummaryResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{23}
}

func (x *CidSummaryResponse) GetCidSummary() []*CidSummary {
	if x != nil {
		return x.CidSummary
	}
	return nil
}

type CidInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *CidInfoRequest) Reset() {
	*x = CidInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidInfoRequest) ProtoMessage() {}

func (x *CidInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidInfoRequest.ProtoReflect.Descriptor instead.
func (*CidInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{24}
}

func (x *CidInfoRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type CidInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CidInfo *CidInfo `protobuf:"bytes,1,opt,name=cid_info,json=cidInfo,proto3" json:"cid_info,omitempty"`
}

func (x *CidInfoResponse) Reset() {
	*x = CidInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidInfoResponse) ProtoMessage() {}

func (x *CidInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidInfoResponse.ProtoReflect.Descriptor instead.
func (*CidInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{25}
}

func (x *CidInfoResponse) GetCidInfo() *CidInfo {
	if x != nil {
		return x.CidInfo
	}
	return nil
}

type BalanceRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *BalanceRequest) Reset() {
	*x = BalanceRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BalanceRequest) ProtoMessage() {}

func (x *BalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BalanceRequest.ProtoReflect.Descriptor instead.
func (*BalanceRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{26}
}

func (x *BalanceRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type BalanceResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Balance string `protobuf:"bytes,1,opt,name=balance,proto3" json:"balance,omitempty"`
}

func (x *BalanceResponse) Reset() {
	*x = BalanceResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BalanceResponse) ProtoMessage() {}

func (x *BalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BalanceResponse.ProtoReflect.Descriptor instead.
func (*BalanceResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{27}
}

func (x *BalanceResponse) GetBalance() string {
	if x != nil {
		return x.Balance
	}
	return ""
}

type NewAddressRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AddressType string `protobuf:"bytes,2,opt,name=address_type,json=addressType,proto3" json:"address_type,omitempty"`
	MakeDefault bool   `protobuf:"varint,3,opt,name=make_default,json=makeDefault,proto3" json:"make_default,omitempty"`
}

func (x *NewAddressRequest) Reset() {
	*x = NewAddressRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressRequest) ProtoMessage() {}

func (x *NewAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressRequest.ProtoReflect.Descriptor instead.
func (*NewAddressRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{28}
}

func (x *NewAddressRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *NewAddressRequest) GetAddressType() string {
	if x != nil {
		return x.AddressType
	}
	return ""
}

func (x *NewAddressRequest) GetMakeDefault() bool {
	if x != nil {
		return x.MakeDefault
	}
	return false
}

type NewAddressResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *NewAddressResponse) Reset() {
	*x = NewAddressResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressResponse) ProtoMessage() {}

func (x *NewAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressResponse.ProtoReflect.Descriptor instead.
func (*NewAddressResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{29}
}

func (x *NewAddressResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type AddressesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *AddressesRequest) Reset() {
	*x = AddressesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressesRequest) ProtoMessage() {}

func (x *AddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressesRequest.ProtoReflect.Descriptor instead.
func (*AddressesRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{30}
}

type AddressesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Addresses []*AddrInfo `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
}

func (x *AddressesResponse) Reset() {
	*x = AddressesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressesResponse) ProtoMessage() {}

func (x *AddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressesResponse.ProtoReflect.Descriptor instead.
func (*AddressesResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{31}
}

func (x *AddressesResponse) GetAddresses() []*AddrInfo {
	if x != nil {
		return x.Addresses
	}
	return nil
}

type SendFilRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To     string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *SendFilRequest) Reset() {
	*x = SendFilRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendFilRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendFilRequest) ProtoMessage() {}

func (x *SendFilRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendFilRequest.ProtoReflect.Descriptor instead.
func (*SendFilRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{32}
}

func (x *SendFilRequest) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *SendFilRequest) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *SendFilRequest) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type SendFilResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *SendFilResponse) Reset() {
	*x = SendFilResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendFilResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendFilResponse) ProtoMessage() {}

func (x *SendFilResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendFilResponse.ProtoReflect.Descriptor instead.
func (*SendFilResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{33}
}

func (x *SendFilResponse) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type SignMessageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Message []byte `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SignMessageRequest) Reset() {
	*x = SignMessageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SignMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignMessageRequest) ProtoMessage() {}

func (x *SignMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignMessageRequest.ProtoReflect.Descriptor instead.
func (*SignMessageRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{34}
}

func (x *SignMessageRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *SignMessageRequest) GetMessage() []byte {
	if x != nil {
		return x.Message
	}
	return nil
}

type SignMessageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (x *SignMessageResponse) Reset() {
	*x = SignMessageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SignMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignMessageResponse) ProtoMessage() {}

func (x *SignMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignMessageResponse.ProtoReflect.Descriptor instead.
func (*SignMessageResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{35}
}

func (x *SignMessageResponse) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type VerifyMessageRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address   string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Message   []byte `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (x *VerifyMessageRequest) Reset() {
	*x = VerifyMessageRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VerifyMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyMessageRequest) ProtoMessage() {}

func (x *VerifyMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyMessageRequest.ProtoReflect.Descriptor instead.
func (*VerifyMessageRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{36}
}

func (x *VerifyMessageRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *VerifyMessageRequest) GetMessage() []byte {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *VerifyMessageRequest) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type VerifyMessageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (x *VerifyMessageResponse) Reset() {
	*x = VerifyMessageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VerifyMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyMessageResponse) ProtoMessage() {}

func (x *VerifyMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyMessageResponse.ProtoReflect.Descriptor instead.
func (*VerifyMessageResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{37}
}

func (x *VerifyMessageResponse) GetOk() bool {
	if x != nil {
		return x.Ok
	}
	return false
}

type StorageInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StorageInfoRequest) Reset() {
	*x = StorageInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfoRequest) ProtoMessage() {}

func (x *StorageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfoRequest.ProtoReflect.Descriptor instead.
func (*StorageInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{38}
}

func (x *StorageInfoRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StorageInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageInfo *StorageInfo `protobuf:"bytes,1,opt,name=storage_info,json=storageInfo,proto3" json:"storage_info,omitempty"`
}

func (x *StorageInfoResponse) Reset() {
	*x = StorageInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfoResponse) ProtoMessage() {}

func (x *StorageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfoResponse.ProtoReflect.Descriptor instead.
func (*StorageInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{39}
}

func (x *StorageInfoResponse) GetStorageInfo() *StorageInfo {
	if x != nil {
		return x.StorageInfo
	}
	return nil
}

type ListStorageInfoRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cids []string `protobuf:"bytes,1,rep,name=cids,proto3" json:"cids,omitempty"`
}

func (x *ListStorageInfoRequest) Reset() {
	*x = ListStorageInfoRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageInfoRequest) ProtoMessage() {}

func (x *ListStorageInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageInfoRequest.ProtoReflect.Descriptor instead.
func (*ListStorageInfoRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{40}
}

func (x *ListStorageInfoRequest) GetCids() []string {
	if x != nil {
		return x.Cids
	}
	return nil
}

type ListStorageInfoResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageInfo []*StorageInfo `protobuf:"bytes,1,rep,name=storage_info,json=storageInfo,proto3" json:"storage_info,omitempty"`
}

func (x *ListStorageInfoResponse) Reset() {
	*x = ListStorageInfoResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageInfoResponse) ProtoMessage() {}

func (x *ListStorageInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageInfoResponse.ProtoReflect.Descriptor instead.
func (*ListStorageInfoResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{41}
}

func (x *ListStorageInfoResponse) GetStorageInfo() []*StorageInfo {
	if x != nil {
		return x.StorageInfo
	}
	return nil
}

type CancelStorageJobRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (x *CancelStorageJobRequest) Reset() {
	*x = CancelStorageJobRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CancelStorageJobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelStorageJobRequest) ProtoMessage() {}

func (x *CancelStorageJobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelStorageJobRequest.ProtoReflect.Descriptor instead.
func (*CancelStorageJobRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{42}
}

func (x *CancelStorageJobRequest) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

type CancelStorageJobResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *CancelStorageJobResponse) Reset() {
	*x = CancelStorageJobResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CancelStorageJobResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelStorageJobResponse) ProtoMessage() {}

func (x *CancelStorageJobResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelStorageJobResponse.ProtoReflect.Descriptor instead.
func (*CancelStorageJobResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{43}
}

type StorageJobRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (x *StorageJobRequest) Reset() {
	*x = StorageJobRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobRequest) ProtoMessage() {}

func (x *StorageJobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobRequest.ProtoReflect.Descriptor instead.
func (*StorageJobRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{44}
}

func (x *StorageJobRequest) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

type StorageJobResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageJob *StorageJob `protobuf:"bytes,1,opt,name=storage_job,json=storageJob,proto3" json:"storage_job,omitempty"`
}

func (x *StorageJobResponse) Reset() {
	*x = StorageJobResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobResponse) ProtoMessage() {}

func (x *StorageJobResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobResponse.ProtoReflect.Descriptor instead.
func (*StorageJobResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{45}
}

func (x *StorageJobResponse) GetStorageJob() *StorageJob {
	if x != nil {
		return x.StorageJob
	}
	return nil
}

type StorageConfigForJobRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (x *StorageConfigForJobRequest) Reset() {
	*x = StorageConfigForJobRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageConfigForJobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageConfigForJobRequest) ProtoMessage() {}

func (x *StorageConfigForJobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageConfigForJobRequest.ProtoReflect.Descriptor instead.
func (*StorageConfigForJobRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{46}
}

func (x *StorageConfigForJobRequest) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

type StorageConfigForJobResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageConfig *StorageConfig `protobuf:"bytes,1,opt,name=storage_config,json=storageConfig,proto3" json:"storage_config,omitempty"`
}

func (x *StorageConfigForJobResponse) Reset() {
	*x = StorageConfigForJobResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[47]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageConfigForJobResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageConfigForJobResponse) ProtoMessage() {}

func (x *StorageConfigForJobResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[47]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageConfigForJobResponse.ProtoReflect.Descriptor instead.
func (*StorageConfigForJobResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{47}
}

func (x *StorageConfigForJobResponse) GetStorageConfig() *StorageConfig {
	if x != nil {
		return x.StorageConfig
	}
	return nil
}

type ListStorageJobsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CidFilter     string              `protobuf:"bytes,1,opt,name=cid_filter,json=cidFilter,proto3" json:"cid_filter,omitempty"`
	Limit         uint64              `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Ascending     bool                `protobuf:"varint,3,opt,name=ascending,proto3" json:"ascending,omitempty"`
	NextPageToken string              `protobuf:"bytes,4,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	Selector      StorageJobsSelector `protobuf:"varint,5,opt,name=selector,proto3,enum=powergate.user.v1.StorageJobsSelector" json:"selector,omitempty"`
}

func (x *ListStorageJobsRequest) Reset() {
	*x = ListStorageJobsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[48]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageJobsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageJobsRequest) ProtoMessage() {}

func (x *ListStorageJobsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[48]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageJobsRequest.ProtoReflect.Descriptor instead.
func (*ListStorageJobsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{48}
}

func (x *ListStorageJobsRequest) GetCidFilter() string {
	if x != nil {
		return x.CidFilter
	}
	return ""
}

func (x *ListStorageJobsRequest) GetLimit() uint64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListStorageJobsRequest) GetAscending() bool {
	if x != nil {
		return x.Ascending
	}
	return false
}

func (x *ListStorageJobsRequest) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

func (x *ListStorageJobsRequest) GetSelector() StorageJobsSelector {
	if x != nil {
		return x.Selector
	}
	return StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED
}

type ListStorageJobsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageJobs   []*StorageJob `protobuf:"bytes,1,rep,name=storage_jobs,json=storageJobs,proto3" json:"storage_jobs,omitempty"`
	More          bool          `protobuf:"varint,2,opt,name=more,proto3" json:"more,omitempty"`
	NextPageToken string        `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (x *ListStorageJobsResponse) Reset() {
	*x = ListStorageJobsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[49]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListStorageJobsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStorageJobsResponse) ProtoMessage() {}

func (x *ListStorageJobsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[49]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStorageJobsResponse.ProtoReflect.Descriptor instead.
func (*ListStorageJobsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{49}
}

func (x *ListStorageJobsResponse) GetStorageJobs() []*StorageJob {
	if x != nil {
		return x.StorageJobs
	}
	return nil
}

func (x *ListStorageJobsResponse) GetMore() bool {
	if x != nil {
		return x.More
	}
	return false
}

func (x *ListStorageJobsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type StorageJobsSummaryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (x *StorageJobsSummaryRequest) Reset() {
	*x = StorageJobsSummaryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[50]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobsSummaryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobsSummaryRequest) ProtoMessage() {}

func (x *StorageJobsSummaryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[50]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobsSummaryRequest.ProtoReflect.Descriptor instead.
func (*StorageJobsSummaryRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{50}
}

func (x *StorageJobsSummaryRequest) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type StorageJobsSummaryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	QueuedStorageJobs    []string `protobuf:"bytes,1,rep,name=queued_storage_jobs,json=queuedStorageJobs,proto3" json:"queued_storage_jobs,omitempty"`
	ExecutingStorageJobs []string `protobuf:"bytes,2,rep,name=executing_storage_jobs,json=executingStorageJobs,proto3" json:"executing_storage_jobs,omitempty"`
	FinalStorageJobs     []string `protobuf:"bytes,3,rep,name=final_storage_jobs,json=finalStorageJobs,proto3" json:"final_storage_jobs,omitempty"`
}

func (x *StorageJobsSummaryResponse) Reset() {
	*x = StorageJobsSummaryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[51]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJobsSummaryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJobsSummaryResponse) ProtoMessage() {}

func (x *StorageJobsSummaryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[51]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJobsSummaryResponse.ProtoReflect.Descriptor instead.
func (*StorageJobsSummaryResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{51}
}

func (x *StorageJobsSummaryResponse) GetQueuedStorageJobs() []string {
	if x != nil {
		return x.QueuedStorageJobs
	}
	return nil
}

func (x *StorageJobsSummaryResponse) GetExecutingStorageJobs() []string {
	if x != nil {
		return x.ExecutingStorageJobs
	}
	return nil
}

func (x *StorageJobsSummaryResponse) GetFinalStorageJobs() []string {
	if x != nil {
		return x.FinalStorageJobs
	}
	return nil
}

type WatchStorageJobsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobIds []string `protobuf:"bytes,1,rep,name=job_ids,json=jobIds,proto3" json:"job_ids,omitempty"`
}

func (x *WatchStorageJobsRequest) Reset() {
	*x = WatchStorageJobsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[52]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WatchStorageJobsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchStorageJobsRequest) ProtoMessage() {}

func (x *WatchStorageJobsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[52]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchStorageJobsRequest.ProtoReflect.Descriptor instead.
func (*WatchStorageJobsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{52}
}

func (x *WatchStorageJobsRequest) GetJobIds() []string {
	if x != nil {
		return x.JobIds
	}
	return nil
}

type WatchStorageJobsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StorageJob *StorageJob `protobuf:"bytes,1,opt,name=storage_job,json=storageJob,proto3" json:"storage_job,omitempty"`
}

func (x *WatchStorageJobsResponse) Reset() {
	*x = WatchStorageJobsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[53]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WatchStorageJobsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchStorageJobsResponse) ProtoMessage() {}

func (x *WatchStorageJobsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[53]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchStorageJobsResponse.ProtoReflect.Descriptor instead.
func (*WatchStorageJobsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{53}
}

func (x *WatchStorageJobsResponse) GetStorageJob() *StorageJob {
	if x != nil {
		return x.StorageJob
	}
	return nil
}

type StorageDealRecordsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Config *DealRecordsConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (x *StorageDealRecordsRequest) Reset() {
	*x = StorageDealRecordsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[54]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageDealRecordsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageDealRecordsRequest) ProtoMessage() {}

func (x *StorageDealRecordsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[54]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageDealRecordsRequest.ProtoReflect.Descriptor instead.
func (*StorageDealRecordsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{54}
}

func (x *StorageDealRecordsRequest) GetConfig() *DealRecordsConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type StorageDealRecordsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Records []*StorageDealRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *StorageDealRecordsResponse) Reset() {
	*x = StorageDealRecordsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[55]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageDealRecordsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageDealRecordsResponse) ProtoMessage() {}

func (x *StorageDealRecordsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[55]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageDealRecordsResponse.ProtoReflect.Descriptor instead.
func (*StorageDealRecordsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{55}
}

func (x *StorageDealRecordsResponse) GetRecords() []*StorageDealRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type RetrievalDealRecordsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Config *DealRecordsConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (x *RetrievalDealRecordsRequest) Reset() {
	*x = RetrievalDealRecordsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[56]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RetrievalDealRecordsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetrievalDealRecordsRequest) ProtoMessage() {}

func (x *RetrievalDealRecordsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[56]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetrievalDealRecordsRequest.ProtoReflect.Descriptor instead.
func (*RetrievalDealRecordsRequest) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{56}
}

func (x *RetrievalDealRecordsRequest) GetConfig() *DealRecordsConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type RetrievalDealRecordsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Records []*RetrievalDealRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *RetrievalDealRecordsResponse) Reset() {
	*x = RetrievalDealRecordsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[57]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RetrievalDealRecordsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetrievalDealRecordsResponse) ProtoMessage() {}

func (x *RetrievalDealRecordsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[57]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetrievalDealRecordsResponse.ProtoReflect.Descriptor instead.
func (*RetrievalDealRecordsResponse) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{57}
}

func (x *RetrievalDealRecordsResponse) GetRecords() []*RetrievalDealRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type AddrInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name               string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Address            string                       `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Type               string                       `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Balance            string                       `protobuf:"bytes,4,opt,name=balance,proto3" json:"balance,omitempty"`
	VerifiedClientInfo *AddrInfo_VerifiedClientInfo `protobuf:"bytes,5,opt,name=verified_client_info,json=verifiedClientInfo,proto3" json:"verified_client_info,omitempty"`
}

func (x *AddrInfo) Reset() {
	*x = AddrInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[58]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddrInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddrInfo) ProtoMessage() {}

func (x *AddrInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[58]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddrInfo.ProtoReflect.Descriptor instead.
func (*AddrInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{58}
}

func (x *AddrInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AddrInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *AddrInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *AddrInfo) GetBalance() string {
	if x != nil {
		return x.Balance
	}
	return ""
}

func (x *AddrInfo) GetVerifiedClientInfo() *AddrInfo_VerifiedClientInfo {
	if x != nil {
		return x.VerifiedClientInfo
	}
	return nil
}

type CidSummary struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid          string   `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	Stored       bool     `protobuf:"varint,2,opt,name=stored,proto3" json:"stored,omitempty"`
	QueuedJobs   []string `protobuf:"bytes,3,rep,name=queued_jobs,json=queuedJobs,proto3" json:"queued_jobs,omitempty"`
	ExecutingJob string   `protobuf:"bytes,4,opt,name=executing_job,json=executingJob,proto3" json:"executing_job,omitempty"`
}

func (x *CidSummary) Reset() {
	*x = CidSummary{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[59]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidSummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidSummary) ProtoMessage() {}

func (x *CidSummary) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[59]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidSummary.ProtoReflect.Descriptor instead.
func (*CidSummary) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{59}
}

func (x *CidSummary) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *CidSummary) GetStored() bool {
	if x != nil {
		return x.Stored
	}
	return false
}

func (x *CidSummary) GetQueuedJobs() []string {
	if x != nil {
		return x.QueuedJobs
	}
	return nil
}

func (x *CidSummary) GetExecutingJob() string {
	if x != nil {
		return x.ExecutingJob
	}
	return ""
}

type IpfsConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AddTimeout int64 `protobuf:"varint,1,opt,name=add_timeout,json=addTimeout,proto3" json:"add_timeout,omitempty"`
}

func (x *IpfsConfig) Reset() {
	*x = IpfsConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[60]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpfsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpfsConfig) ProtoMessage() {}

func (x *IpfsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[60]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpfsConfig.ProtoReflect.Descriptor instead.
func (*IpfsConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{60}
}

func (x *IpfsConfig) GetAddTimeout() int64 {
	if x != nil {
		return x.AddTimeout
	}
	return 0
}

type HotConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Enabled          bool        `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	AllowUnfreeze    bool        `protobuf:"varint,2,opt,name=allow_unfreeze,json=allowUnfreeze,proto3" json:"allow_unfreeze,omitempty"`
	UnfreezeMaxPrice uint64      `protobuf:"varint,3,opt,name=unfreeze_max_price,json=unfreezeMaxPrice,proto3" json:"unfreeze_max_price,omitempty"`
	Ipfs             *IpfsConfig `protobuf:"bytes,4,opt,name=ipfs,proto3" json:"ipfs,omitempty"`
}

func (x *HotConfig) Reset() {
	*x = HotConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[61]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HotConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HotConfig) ProtoMessage() {}

func (x *HotConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[61]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HotConfig.ProtoReflect.Descriptor instead.
func (*HotConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{61}
}

func (x *HotConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *HotConfig) GetAllowUnfreeze() bool {
	if x != nil {
		return x.AllowUnfreeze
	}
	return false
}

func (x *HotConfig) GetUnfreezeMaxPrice() uint64 {
	if x != nil {
		return x.UnfreezeMaxPrice
	}
	return 0
}

func (x *HotConfig) GetIpfs() *IpfsConfig {
	if x != nil {
		return x.Ipfs
	}
	return nil
}

type FilRenew struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Enabled   bool  `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Threshold int64 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (x *FilRenew) Reset() {
	*x = FilRenew{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[62]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilRenew) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilRenew) ProtoMessage() {}

func (x *FilRenew) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[62]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilRenew.ProtoReflect.Descriptor instead.
func (*FilRenew) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{62}
}

func (x *FilRenew) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *FilRenew) GetThreshold() int64 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

type FilConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ReplicationFactor int64     `protobuf:"varint,1,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	DealMinDuration   int64     `protobuf:"varint,2,opt,name=deal_min_duration,json=dealMinDuration,proto3" json:"deal_min_duration,omitempty"`
	ExcludedMiners    []string  `protobuf:"bytes,3,rep,name=excluded_miners,json=excludedMiners,proto3" json:"excluded_miners,omitempty"`
	TrustedMiners     []string  `protobuf:"bytes,4,rep,name=trusted_miners,json=trustedMiners,proto3" json:"trusted_miners,omitempty"`
	CountryCodes      []string  `protobuf:"bytes,5,rep,name=country_codes,json=countryCodes,proto3" json:"country_codes,omitempty"`
	Renew             *FilRenew `protobuf:"bytes,6,opt,name=renew,proto3" json:"renew,omitempty"`
	Address           string    `protobuf:"bytes,7,opt,name=address,proto3" json:"address,omitempty"`
	MaxPrice          uint64    `protobuf:"varint,8,opt,name=max_price,json=maxPrice,proto3" json:"max_price,omitempty"`
	FastRetrieval     bool      `protobuf:"varint,9,opt,name=fast_retrieval,json=fastRetrieval,proto3" json:"fast_retrieval,omitempty"`
	DealStartOffset   int64     `protobuf:"varint,10,opt,name=deal_start_offset,json=dealStartOffset,proto3" json:"deal_start_offset,omitempty"`
	VerifiedDeal      bool      `protobuf:"varint,11,opt,name=verified_deal,json=verifiedDeal,proto3" json:"verified_deal,omitempty"`
}

func (x *FilConfig) Reset() {
	*x = FilConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[63]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilConfig) ProtoMessage() {}

func (x *FilConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[63]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilConfig.ProtoReflect.Descriptor instead.
func (*FilConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{63}
}

func (x *FilConfig) GetReplicationFactor() int64 {
	if x != nil {
		return x.ReplicationFactor
	}
	return 0
}

func (x *FilConfig) GetDealMinDuration() int64 {
	if x != nil {
		return x.DealMinDuration
	}
	return 0
}

func (x *FilConfig) GetExcludedMiners() []string {
	if x != nil {
		return x.ExcludedMiners
	}
	return nil
}

func (x *FilConfig) GetTrustedMiners() []string {
	if x != nil {
		return x.TrustedMiners
	}
	return nil
}

func (x *FilConfig) GetCountryCodes() []string {
	if x != nil {
		return x.CountryCodes
	}
	return nil
}

func (x *FilConfig) GetRenew() *FilRenew {
	if x != nil {
		return x.Renew
	}
	return nil
}

func (x *FilConfig) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *FilConfig) GetMaxPrice() uint64 {
	if x != nil {
		return x.MaxPrice
	}
	return 0
}

func (x *FilConfig) GetFastRetrieval() bool {
	if x != nil {
		return x.FastRetrieval
	}
	return false
}

func (x *FilConfig) GetDealStartOffset() int64 {
	if x != nil {
		return x.DealStartOffset
	}
	return 0
}

func (x *FilConfig) GetVerifiedDeal() bool {
	if x != nil {
		return x.VerifiedDeal
	}
	return false
}

type ColdConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Enabled  bool       `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Filecoin *FilConfig `protobuf:"bytes,2,opt,name=filecoin,proto3" json:"filecoin,omitempty"`
}

func (x *ColdConfig) Reset() {
	*x = ColdConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[64]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ColdConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ColdConfig) ProtoMessage() {}

func (x *ColdConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[64]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ColdConfig.ProtoReflect.Descriptor instead.
func (*ColdConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{64}
}

func (x *ColdConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ColdConfig) GetFilecoin() *FilConfig {
	if x != nil {
		return x.Filecoin
	}
	return nil
}

type StorageConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Hot        *HotConfig  `protobuf:"bytes,1,opt,name=hot,proto3" json:"hot,omitempty"`
	Cold       *ColdConfig `protobuf:"bytes,2,opt,name=cold,proto3" json:"cold,omitempty"`
	Repairable bool        `protobuf:"varint,3,opt,name=repairable,proto3" json:"repairable,omitempty"`
}

func (x *StorageConfig) Reset() {
	*x = StorageConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[65]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageConfig) ProtoMessage() {}

func (x *StorageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[65]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageConfig.ProtoReflect.Descriptor instead.
func (*StorageConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{65}
}

func (x *StorageConfig) GetHot() *HotConfig {
	if x != nil {
		return x.Hot
	}
	return nil
}

func (x *StorageConfig) GetCold() *ColdConfig {
	if x != nil {
		return x.Cold
	}
	return nil
}

func (x *StorageConfig) GetRepairable() bool {
	if x != nil {
		return x.Repairable
	}
	return false
}

type IpfsHotInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Created int64 `protobuf:"varint,1,opt,name=created,proto3" json:"created,omitempty"`
}

func (x *IpfsHotInfo) Reset() {
	*x = IpfsHotInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[66]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IpfsHotInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpfsHotInfo) ProtoMessage() {}

func (x *IpfsHotInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[66]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpfsHotInfo.ProtoReflect.Descriptor instead.
func (*IpfsHotInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{66}
}

func (x *IpfsHotInfo) GetCreated() int64 {
	if x != nil {
		return x.Created
	}
	return 0
}

type HotInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Enabled bool         `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Size    int64        `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Ipfs    *IpfsHotInfo `protobuf:"bytes,3,opt,name=ipfs,proto3" json:"ipfs,omitempty"`
}

func (x *HotInfo) Reset() {
	*x = HotInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[67]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HotInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HotInfo) ProtoMessage() {}

func (x *HotInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[67]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HotInfo.ProtoReflect.Descriptor instead.
func (*HotInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{67}
}

func (x *HotInfo) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *HotInfo) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *HotInfo) GetIpfs() *IpfsHotInfo {
	if x != nil {
		return x.Ipfs
	}
	return nil
}

type FilStorage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DealId     int64  `protobuf:"varint,1,opt,name=deal_id,json=dealId,proto3" json:"deal_id,omitempty"`
	Renewed    bool   `protobuf:"varint,2,opt,name=renewed,proto3" json:"renewed,omitempty"`
	Duration   int64  `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	StartEpoch uint64 `protobuf:"varint,4,opt,name=start_epoch,json=startEpoch,proto3" json:"start_epoch,omitempty"`
	Miner      string `protobuf:"bytes,5,opt,name=miner,proto3" json:"miner,omitempty"`
	EpochPrice uint64 `protobuf:"varint,6,opt,name=epoch_price,json=epochPrice,proto3" json:"epoch_price,omitempty"`
	PieceCid   string `protobuf:"bytes,7,opt,name=piece_cid,json=pieceCid,proto3" json:"piece_cid,omitempty"`
}

func (x *FilStorage) Reset() {
	*x = FilStorage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[68]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilStorage) ProtoMessage() {}

func (x *FilStorage) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[68]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilStorage.ProtoReflect.Descriptor instead.
func (*FilStorage) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{68}
}

func (x *FilStorage) GetDealId() int64 {
	if x != nil {
		return x.DealId
	}
	return 0
}

func (x *FilStorage) GetRenewed() bool {
	if x != nil {
		return x.Renewed
	}
	return false
}

func (x *FilStorage) GetDuration() int64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *FilStorage) GetStartEpoch() uint64 {
	if x != nil {
		return x.StartEpoch
	}
	return 0
}

func (x *FilStorage) GetMiner() string {
	if x != nil {
		return x.Miner
	}
	return ""
}

func (x *FilStorage) GetEpochPrice() uint64 {
	if x != nil {
		return x.EpochPrice
	}
	return 0
}

func (x *FilStorage) GetPieceCid() string {
	if x != nil {
		return x.PieceCid
	}
	return ""
}

type FilInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DataCid   string        `protobuf:"bytes,1,opt,name=data_cid,json=dataCid,proto3" json:"data_cid,omitempty"`
	Size      uint64        `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Proposals []*FilStorage `protobuf:"bytes,3,rep,name=proposals,proto3" json:"proposals,omitempty"`
}

func (x *FilInfo) Reset() {
	*x = FilInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[69]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FilInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilInfo) ProtoMessage() {}

func (x *FilInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[69]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilInfo.ProtoReflect.Descriptor instead.
func (*FilInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{69}
}

func (x *FilInfo) GetDataCid() string {
	if x != nil {
		return x.DataCid
	}
	return ""
}

func (x *FilInfo) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FilInfo) GetProposals() []*FilStorage {
	if x != nil {
		return x.Proposals
	}
	return nil
}

type ColdInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Enabled  bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Filecoin *FilInfo `protobuf:"bytes,2,opt,name=filecoin,proto3" json:"filecoin,omitempty"`
}

func (x *ColdInfo) Reset() {
	*x = ColdInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[70]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ColdInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ColdInfo) ProtoMessage() {}

func (x *ColdInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[70]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ColdInfo.ProtoReflect.Descriptor instead.
func (*ColdInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{70}
}

func (x *ColdInfo) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ColdInfo) GetFilecoin() *FilInfo {
	if x != nil {
		return x.Filecoin
	}
	return nil
}

type StorageInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JobId   string    `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Cid     string    `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
	Created int64     `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
	Hot     *HotInfo  `protobuf:"bytes,4,opt,name=hot,proto3" json:"hot,omitempty"`
	Cold    *ColdInfo `protobuf:"bytes,5,opt,name=cold,proto3" json:"cold,omitempty"`
}

func (x *StorageInfo) Reset() {
	*x = StorageInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[71]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfo) ProtoMessage() {}

func (x *StorageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[71]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfo.ProtoReflect.Descriptor instead.
func (*StorageInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{71}
}

func (x *StorageInfo) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *StorageInfo) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *StorageInfo) GetCreated() int64 {
	if x != nil {
		return x.Created
	}
	return 0
}

func (x *StorageInfo) GetHot() *HotInfo {
	if x != nil {
		return x.Hot
	}
	return nil
}

func (x *StorageInfo) GetCold() *ColdInfo {
	if x != nil {
		return x.Cold
	}
	return nil
}

type CidInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid                       string         `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	LatestPushedStorageConfig *StorageConfig `protobuf:"bytes,2,opt,name=latest_pushed_storage_config,json=latestPushedStorageConfig,proto3" json:"latest_pushed_storage_config,omitempty"`
	CurrentStorageInfo        *StorageInfo   `protobuf:"bytes,3,opt,name=current_storage_info,json=currentStorageInfo,proto3" json:"current_storage_info,omitempty"`
	QueuedStorageJobs         []*StorageJob  `protobuf:"bytes,4,rep,name=queued_storage_jobs,json=queuedStorageJobs,proto3" json:"queued_storage_jobs,omitempty"`
	ExecutingStorageJob       *StorageJob    `protobuf:"bytes,5,opt,name=executing_storage_job,json=executingStorageJob,proto3" json:"executing_storage_job,omitempty"`
}

func (x *CidInfo) Reset() {
	*x = CidInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[72]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CidInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CidInfo) ProtoMessage() {}

func (x *CidInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[72]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CidInfo.ProtoReflect.Descriptor instead.
func (*CidInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{72}
}

func (x *CidInfo) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *CidInfo) GetLatestPushedStorageConfig() *StorageConfig {
	if x != nil {
		return x.LatestPushedStorageConfig
	}
	return nil
}

func (x *CidInfo) GetCurrentStorageInfo() *StorageInfo {
	if x != nil {
		return x.CurrentStorageInfo
	}
	return nil
}

func (x *CidInfo) GetQueuedStorageJobs() []*StorageJob {
	if x != nil {
		return x.QueuedStorageJobs
	}
	return nil
}

func (x *CidInfo) GetExecutingStorageJob() *StorageJob {
	if x != nil {
		return x.ExecutingStorageJob
	}
	return nil
}

type DealInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ProposalCid     string `protobuf:"bytes,1,opt,name=proposal_cid,json=proposalCid,proto3" json:"proposal_cid,omitempty"`
	StateId         uint64 `protobuf:"varint,2,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	StateName       string `protobuf:"bytes,3,opt,name=state_name,json=stateName,proto3" json:"state_name,omitempty"`
	Miner           string `protobuf:"bytes,4,opt,name=miner,proto3" json:"miner,omitempty"`
	PieceCid        string `protobuf:"bytes,5,opt,name=piece_cid,json=pieceCid,proto3" json:"piece_cid,omitempty"`
	Size            uint64 `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	PricePerEpoch   uint64 `protobuf:"varint,7,opt,name=price_per_epoch,json=pricePerEpoch,proto3" json:"price_per_epoch,omitempty"`
	StartEpoch      uint64 `protobuf:"varint,8,opt,name=start_epoch,json=startEpoch,proto3" json:"start_epoch,omitempty"`
	Duration        uint64 `protobuf:"varint,9,opt,name=duration,proto3" json:"duration,omitempty"`
	DealId          uint64 `protobuf:"varint,10,opt,name=deal_id,json=dealId,proto3" json:"deal_id,omitempty"`
	ActivationEpoch int64  `protobuf:"varint,11,opt,name=activation_epoch,json=activationEpoch,proto3" json:"activation_epoch,omitempty"`
	Message         string `protobuf:"bytes,12,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *DealInfo) Reset() {
	*x = DealInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[73]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DealInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DealInfo) ProtoMessage() {}

func (x *DealInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[73]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DealInfo.ProtoReflect.Descriptor instead.
func (*DealInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{73}
}

func (x *DealInfo) GetProposalCid() string {
	if x != nil {
		return x.ProposalCid
	}
	return ""
}

func (x *DealInfo) GetStateId() uint64 {
	if x != nil {
		return x.StateId
	}
	return 0
}

func (x *DealInfo) GetStateName() string {
	if x != nil {
		return x.StateName
	}
	return ""
}

func (x *DealInfo) GetMiner() string {
	if x != nil {
		return x.Miner
	}
	return ""
}

func (x *DealInfo) GetPieceCid() string {
	if x != nil {
		return x.PieceCid
	}
	return ""
}

func (x *DealInfo) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *DealInfo) GetPricePerEpoch() uint64 {
	if x != nil {
		return x.PricePerEpoch
	}
	return 0
}

func (x *DealInfo) GetStartEpoch() uint64 {
	if x != nil {
		return x.StartEpoch
	}
	return 0
}

func (x *DealInfo) GetDuration() uint64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *DealInfo) GetDealId() uint64 {
	if x != nil {
		return x.DealId
	}
	return 0
}

func (x *DealInfo) GetActivationEpoch() int64 {
	if x != nil {
		return x.ActivationEpoch
	}
	return 0
}

func (x *DealInfo) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type StorageJob struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id         string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ApiId      string       `protobuf:"bytes,2,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	Cid        string       `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
	Status     JobStatus    `protobuf:"varint,4,opt,name=status,proto3,enum=powergate.user.v1.JobStatus" json:"status,omitempty"`
	ErrorCause string       `protobuf:"bytes,5,opt,name=error_cause,json=errorCause,proto3" json:"error_cause,omitempty"`
	DealInfo   []*DealInfo  `protobuf:"bytes,6,rep,name=deal_info,json=dealInfo,proto3" json:"deal_info,omitempty"`
	DealErrors []*DealError `protobuf:"bytes,7,rep,name=deal_errors,json=dealErrors,proto3" json:"deal_errors,omitempty"`
	CreatedAt  int64        `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *StorageJob) Reset() {
	*x = StorageJob{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[74]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageJob) ProtoMessage() {}

func (x *StorageJob) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[74]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageJob.ProtoReflect.Descriptor instead.
func (*StorageJob) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{74}
}

func (x *StorageJob) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *StorageJob) GetApiId() string {
	if x != nil {
		return x.ApiId
	}
	return ""
}

func (x *StorageJob) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *StorageJob) GetStatus() JobStatus {
	if x != nil {
		return x.Status
	}
	return JobStatus_JOB_STATUS_UNSPECIFIED
}

func (x *StorageJob) GetErrorCause() string {
	if x != nil {
		return x.ErrorCause
	}
	return ""
}

func (x *StorageJob) GetDealInfo() []*DealInfo {
	if x != nil {
		return x.DealInfo
	}
	return nil
}

func (x *StorageJob) GetDealErrors() []*DealError {
	if x != nil {
		return x.DealErrors
	}
	return nil
}

func (x *StorageJob) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

type DealError struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ProposalCid string `protobuf:"bytes,1,opt,name=proposal_cid,json=proposalCid,proto3" json:"proposal_cid,omitempty"`
	Miner       string `protobuf:"bytes,2,opt,name=miner,proto3" json:"miner,omitempty"`
	Message     string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *DealError) Reset() {
	*x = DealError{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[75]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DealError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DealError) ProtoMessage() {}

func (x *DealError) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[75]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DealError.ProtoReflect.Descriptor instead.
func (*DealError) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{75}
}

func (x *DealError) GetProposalCid() string {
	if x != nil {
		return x.ProposalCid
	}
	return ""
}

func (x *DealError) GetMiner() string {
	if x != nil {
		return x.Miner
	}
	return ""
}

func (x *DealError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type LogEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Cid     string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	JobId   string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Time    int64  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *LogEntry) Reset() {
	*x = LogEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[76]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogEntry) ProtoMessage() {}

func (x *LogEntry) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[76]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{76}
}

func (x *LogEntry) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *LogEntry) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *LogEntry) GetTime() int64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogEntry) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type DealRecordsConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FromAddrs      []string `protobuf:"bytes,1,rep,name=from_addrs,json=fromAddrs,proto3" json:"from_addrs,omitempty"`
	DataCids       []string `protobuf:"bytes,2,rep,name=data_cids,json=dataCids,proto3" json:"data_cids,omitempty"`
	IncludePending bool     `protobuf:"varint,3,opt,name=include_pending,json=includePending,proto3" json:"include_pending,omitempty"`
	IncludeFinal   bool     `protobuf:"varint,4,opt,name=include_final,json=includeFinal,proto3" json:"include_final,omitempty"`
	Ascending      bool     `protobuf:"varint,5,opt,name=ascending,proto3" json:"ascending,omitempty"`
	IncludeFailed  bool     `protobuf:"varint,6,opt,name=include_failed,json=includeFailed,proto3" json:"include_failed,omitempty"`
}

func (x *DealRecordsConfig) Reset() {
	*x = DealRecordsConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[77]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DealRecordsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DealRecordsConfig) ProtoMessage() {}

func (x *DealRecordsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[77]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DealRecordsConfig.ProtoReflect.Descriptor instead.
func (*DealRecordsConfig) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{77}
}

func (x *DealRecordsConfig) GetFromAddrs() []string {
	if x != nil {
		return x.FromAddrs
	}
	return nil
}

func (x *DealRecordsConfig) GetDataCids() []string {
	if x != nil {
		return x.DataCids
	}
	return nil
}

func (x *DealRecordsConfig) GetIncludePending() bool {
	if x != nil {
		return x.IncludePending
	}
	return false
}

func (x *DealRecordsConfig) GetIncludeFinal() bool {
	if x != nil {
		return x.IncludeFinal
	}
	return false
}

func (x *DealRecordsConfig) GetAscending() bool {
	if x != nil {
		return x.Ascending
	}
	return false
}

func (x *DealRecordsConfig) GetIncludeFailed() bool {
	if x != nil {
		return x.IncludeFailed
	}
	return false
}

type StorageDealInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ProposalCid     string `protobuf:"bytes,1,opt,name=proposal_cid,json=proposalCid,proto3" json:"proposal_cid,omitempty"`
	StateId         uint64 `protobuf:"varint,2,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	StateName       string `protobuf:"bytes,3,opt,name=state_name,json=stateName,proto3" json:"state_name,omitempty"`
	Miner           string `protobuf:"bytes,4,opt,name=miner,proto3" json:"miner,omitempty"`
	PieceCid        string `protobuf:"bytes,5,opt,name=piece_cid,json=pieceCid,proto3" json:"piece_cid,omitempty"`
	Size            uint64 `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	PricePerEpoch   uint64 `protobuf:"varint,7,opt,name=price_per_epoch,json=pricePerEpoch,proto3" json:"price_per_epoch,omitempty"`
	StartEpoch      uint64 `protobuf:"varint,8,opt,name=start_epoch,json=startEpoch,proto3" json:"start_epoch,omitempty"`
	Duration        uint64 `protobuf:"varint,9,opt,name=duration,proto3" json:"duration,omitempty"`
	DealId          uint64 `protobuf:"varint,10,opt,name=deal_id,json=dealId,proto3" json:"deal_id,omitempty"`
	ActivationEpoch int64  `protobuf:"varint,11,opt,name=activation_epoch,json=activationEpoch,proto3" json:"activation_epoch,omitempty"`
	Message         string `protobuf:"bytes,12,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *StorageDealInfo) Reset() {
	*x = StorageDealInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[78]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageDealInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageDealInfo) ProtoMessage() {}

func (x *StorageDealInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[78]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageDealInfo.ProtoReflect.Descriptor instead.
func (*StorageDealInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{78}
}

func (x *StorageDealInfo) GetProposalCid() string {
	if x != nil {
		return x.ProposalCid
	}
	return ""
}

func (x *StorageDealInfo) GetStateId() uint64 {
	if x != nil {
		return x.StateId
	}
	return 0
}

func (x *StorageDealInfo) GetStateName() string {
	if x != nil {
		return x.StateName
	}
	return ""
}

func (x *StorageDealInfo) GetMiner() string {
	if x != nil {
		return x.Miner
	}
	return ""
}

func (x *StorageDealInfo) GetPieceCid() string {
	if x != nil {
		return x.PieceCid
	}
	return ""
}

func (x *StorageDealInfo) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *StorageDealInfo) GetPricePerEpoch() uint64 {
	if x != nil {
		return x.PricePerEpoch
	}
	return 0
}

func (x *StorageDealInfo) GetStartEpoch() uint64 {
	if x != nil {
		return x.StartEpoch
	}
	return 0
}

func (x *StorageDealInfo) GetDuration() uint64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *StorageDealInfo) GetDealId() uint64 {
	if x != nil {
		return x.DealId
	}
	return 0
}

func (x *StorageDealInfo) GetActivationEpoch() int64 {
	if x != nil {
		return x.ActivationEpoch
	}
	return 0
}

func (x *StorageDealInfo) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type StorageDealRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RootCid           string                 `protobuf:"bytes,1,opt,name=root_cid,json=rootCid,proto3" json:"root_cid,omitempty"`
	Address           string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Time              int64                  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	Pending           bool                   `protobuf:"varint,4,opt,name=pending,proto3" json:"pending,omitempty"`
	DealInfo          *StorageDealInfo       `protobuf:"bytes,5,opt,name=deal_info,json=dealInfo,proto3" json:"deal_info,omitempty"`
	TransferSize      int64                  `protobuf:"varint,6,opt,name=transfer_size,json=transferSize,proto3" json:"transfer_size,omitempty"`
	DataTransferStart *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=data_transfer_start,json=dataTransferStart,proto3" json:"data_transfer_start,omitempty"`
	DataTransferEnd   *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=data_transfer_end,json=dataTransferEnd,proto3" json:"data_transfer_end,omitempty"`
	SealingStart      *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=sealing_start,json=sealingStart,proto3" json:"sealing_start,omitempty"`
	SealingEnd        *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=sealing_end,json=sealingEnd,proto3" json:"sealing_end,omitempty"`
	ErrMsg            string                 `protobuf:"bytes,11,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
	UpdatedAt         *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *StorageDealRecord) Reset() {
	*x = StorageDealRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[79]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StorageDealRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageDealRecord) ProtoMessage() {}

func (x *StorageDealRecord) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[79]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageDealRecord.ProtoReflect.Descriptor instead.
func (*StorageDealRecord) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{79}
}

func (x *StorageDealRecord) GetRootCid() string {
	if x != nil {
		return x.RootCid
	}
	return ""
}

func (x *StorageDealRecord) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *StorageDealRecord) GetTime() int64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *StorageDealRecord) GetPending() bool {
	if x != nil {
		return x.Pending
	}
	return false
}

func (x *StorageDealRecord) GetDealInfo() *StorageDealInfo {
	if x != nil {
		return x.DealInfo
	}
	return nil
}

func (x *StorageDealRecord) GetTransferSize() int64 {
	if x != nil {
		return x.TransferSize
	}
	return 0
}

func (x *StorageDealRecord) GetDataTransferStart() *timestamppb.Timestamp {
	if x != nil {
		return x.DataTransferStart
	}
	return nil
}

func (x *StorageDealRecord) GetDataTransferEnd() *timestamppb.Timestamp {
	if x != nil {
		return x.DataTransferEnd
	}
	return nil
}

func (x *StorageDealRecord) GetSealingStart() *timestamppb.Timestamp {
	if x != nil {
		return x.SealingStart
	}
	return nil
}

func (x *StorageDealRecord) GetSealingEnd() *timestamppb.Timestamp {
	if x != nil {
		return x.SealingEnd
	}
	return nil
}

func (x *StorageDealRecord) GetErrMsg() string {
	if x != nil {
		return x.ErrMsg
	}
	return ""
}

func (x *StorageDealRecord) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

type RetrievalDealInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RootCid                 string `protobuf:"bytes,1,opt,name=root_cid,json=rootCid,proto3" json:"root_cid,omitempty"`
	Size                    uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	MinPrice                uint64 `protobuf:"varint,3,opt,name=min_price,json=minPrice,proto3" json:"min_price,omitempty"`
	PaymentInterval         uint64 `protobuf:"varint,4,opt,name=payment_interval,json=paymentInterval,proto3" json:"payment_interval,omitempty"`
	PaymentIntervalIncrease uint64 `protobuf:"varint,5,opt,name=payment_interval_increase,json=paymentIntervalIncrease,proto3" json:"payment_interval_increase,omitempty"`
	Miner                   string `protobuf:"bytes,6,opt,name=miner,proto3" json:"miner,omitempty"`
	MinerPeerId             string `protobuf:"bytes,7,opt,name=miner_peer_id,json=minerPeerId,proto3" json:"miner_peer_id,omitempty"`
}

func (x *RetrievalDealInfo) Reset() {
	*x = RetrievalDealInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[80]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RetrievalDealInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetrievalDealInfo) ProtoMessage() {}

func (x *RetrievalDealInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[80]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetrievalDealInfo.ProtoReflect.Descriptor instead.
func (*RetrievalDealInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{80}
}

func (x *RetrievalDealInfo) GetRootCid() string {
	if x != nil {
		return x.RootCid
	}
	return ""
}

func (x *RetrievalDealInfo) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *RetrievalDealInfo) GetMinPrice() uint64 {
	if x != nil {
		return x.MinPrice
	}
	return 0
}

func (x *RetrievalDealInfo) GetPaymentInterval() uint64 {
	if x != nil {
		return x.PaymentInterval
	}
	return 0
}

func (x *RetrievalDealInfo) GetPaymentIntervalIncrease() uint64 {
	if x != nil {
		return x.PaymentIntervalIncrease
	}
	return 0
}

func (x *RetrievalDealInfo) GetMiner() string {
	if x != nil {
		return x.Miner
	}
	return ""
}

func (x *RetrievalDealInfo) GetMinerPeerId() string {
	if x != nil {
		return x.MinerPeerId
	}
	return ""
}

type RetrievalDealRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address           string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Time              int64                  `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	DealInfo          *RetrievalDealInfo     `protobuf:"bytes,3,opt,name=deal_info,json=dealInfo,proto3" json:"deal_info,omitempty"`
	DataTransferStart *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=data_transfer_start,json=dataTransferStart,proto3" json:"data_transfer_start,omitempty"`
	DataTransferEnd   *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=data_transfer_end,json=dataTransferEnd,proto3" json:"data_transfer_end,omitempty"`
	ErrMsg            string                 `protobuf:"bytes,6,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
	UpdatedAt         *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Id                string                 `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
	BytesReceived     uint64                 `protobuf:"varint,9,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
}

func (x *RetrievalDealRecord) Reset() {
	*x = RetrievalDealRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[81]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RetrievalDealRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetrievalDealRecord) ProtoMessage() {}

func (x *RetrievalDealRecord) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[81]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetrievalDealRecord.ProtoReflect.Descriptor instead.
func (*RetrievalDealRecord) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{81}
}

func (x *RetrievalDealRecord) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *RetrievalDealRecord) GetTime() int64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *RetrievalDealRecord) GetDealInfo() *RetrievalDealInfo {
	if x != nil {
		return x.DealInfo
	}
	return nil
}

func (x *RetrievalDealRecord) GetDataTransferStart() *timestamppb.Timestamp {
	if x != nil {
		return x.DataTransferStart
	}
	return nil
}

func (x *RetrievalDealRecord) GetDataTransferEnd() *timestamppb.Timestamp {
	if x != nil {
		return x.DataTransferEnd
	}
	return nil
}

func (x *RetrievalDealRecord) GetErrMsg() string {
	if x != nil {
		return x.ErrMsg
	}
	return ""
}

func (x *RetrievalDealRecord) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *RetrievalDealRecord) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *RetrievalDealRecord) GetBytesReceived() uint64 {
	if x != nil {
		return x.BytesReceived
	}
	return 0
}

type AddrInfo_VerifiedClientInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RemainingDatacapBytes string `protobuf:"bytes,1,opt,name=remaining_datacap_bytes,json=remainingDatacapBytes,proto3" json:"remaining_datacap_bytes,omitempty"`
}

func (x *AddrInfo_VerifiedClientInfo) Reset() {
	*x = AddrInfo_VerifiedClientInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_powergate_user_v1_user_proto_msgTypes[82]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddrInfo_VerifiedClientInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddrInfo_VerifiedClientInfo) ProtoMessage() {}

func (x *AddrInfo_VerifiedClientInfo) ProtoReflect() protoreflect.Message {
	mi := &file_powergate_user_v1_user_proto_msgTypes[82]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddrInfo_VerifiedClientInfo.ProtoReflect.Descriptor instead.
func (*AddrInfo_VerifiedClientInfo) Descriptor() ([]byte, []int) {
	return file_powergate_user_v1_user_proto_rawDescGZIP(), []int{58, 0}
}

func (x *AddrInfo_VerifiedClientInfo) GetRemainingDatacapBytes() string {
	if x != nil {
		return x.RemainingDatacapBytes
	}
	return ""
}

var File_powergate_user_v1_user_proto protoreflect.FileDescriptor

var file_powergate_user_v1_user_proto_rawDesc = []byte{
	0x0a, 0x1c, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2f, 0x75, 0x73, 0x65, 0x72,
	0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0x12, 0x0a, 0x10, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xc8, 0x01, 0x0a, 0x11, 0x42, 0x75, 0x69, 0x6c, 0x64,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1d, 0x0a, 0x0a,
	0x67, 0x69, 0x74, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x09, 0x67, 0x69, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x67,
	0x69, 0x74, 0x5f, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x09, 0x67, 0x69, 0x74, 0x42, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x69,
	0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x67,
	0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x67, 0x69, 0x74, 0x5f, 0x73,
	0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x67, 0x69,
	0x74, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x1d, 0x0a, 0x0a, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x5f, 0x64, 0x61, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x62, 0x75,
	0x69, 0x6c, 0x64, 0x44, 0x61, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x22, 0x17, 0x0a, 0x15, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66,
	0x69, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x28, 0x0a, 0x16, 0x55, 0x73,
	0x65, 0x72, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x22, 0x1d, 0x0a, 0x1b, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x22, 0x76, 0x0a, 0x1c, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x56, 0x0a, 0x16, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x73,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x14, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x5a, 0x0a, 0x1e, 0x53,
	0x65, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x38, 0x0a,
	0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,
	0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x21, 0x0a, 0x1f, 0x53, 0x65, 0x74, 0x44, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x24, 0x0a, 0x0c, 0x53, 0x74,
	0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x68,
	0x75, 0x6e, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b,
	0x22, 0x21, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x63, 0x69, 0x64, 0x22, 0x23, 0x0a, 0x0f, 0x53, 0x74, 0x61, 0x67, 0x65, 0x43, 0x69, 0x64, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0x12, 0x0a, 0x10, 0x53, 0x74, 0x61, 0x67,
	0x65, 0x43, 0x69, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0xa0, 0x02, 0x0a,
	0x19, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12, 0x38, 0x0a, 0x06,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x68, 0x61, 0x73, 0x5f, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x68, 0x61, 0x73, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64,
	0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e,
	0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2e,
	0x0a, 0x13, 0x68, 0x61, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x68, 0x61, 0x73,
	0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x26,
	0x0a, 0x0f, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64,
	0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x04, 0x52, 0x0d, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x44,
	0x65, 0x61, 0x6c, 0x49, 0x64, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x5f, 0x65, 0x78, 0x65,
	0x63, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6e, 0x6f, 0x45, 0x78, 0x65, 0x63, 0x22,
	0x33, 0x0a, 0x1a, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x15, 0x0a,
	0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a,
	0x6f, 0x62, 0x49, 0x64, 0x22, 0x3c, 0x0a, 0x12, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x44,
	0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69,
	0x64, 0x31, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x64, 0x31, 0x12, 0x12,
	0x0a, 0x04, 0x63, 0x69, 0x64, 0x32, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69,
	0x64, 0x32, 0x22, 0x2c, 0x0a, 0x13, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x44, 0x61, 0x74,
	0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64,
	0x22, 0x1e, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10,
	0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64,
	0x22, 0x23, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x14, 0x0a, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05,
	0x63, 0x68, 0x75, 0x6e, 0x6b, 0x22, 0x21, 0x0a, 0x0d, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0x10, 0x0a, 0x0e, 0x52, 0x65, 0x6d, 0x6f,
	0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x55, 0x0a, 0x10, 0x57, 0x61,
	0x74, 0x63, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10,
	0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64,
	0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x68, 0x69, 0x73, 0x74, 0x6f,
	0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72,
	0x79, 0x22, 0x4d, 0x0a, 0x11, 0x57, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x09, 0x6c, 0x6f, 0x67, 0x5f, 0x65, 0x6e,
	0x74, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f,
	0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x6c, 0x6f, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x22, 0x27, 0x0a, 0x11, 0x43, 0x69, 0x64, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x64, 0x73, 0x22, 0x54, 0x0a, 0x12, 0x43, 0x69, 0x64,
	0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x3e, 0x0a, 0x0b, 0x63, 0x69, 0x64, 0x5f, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x64, 0x53, 0x75, 0x6d, 0x6d,
	0x61, 0x72, 0x79, 0x52, 0x0a, 0x63, 0x69, 0x64, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x22,
	0x22, 0x0a, 0x0e, 0x43, 0x69, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x63, 0x69, 0x64, 0x22, 0x48, 0x0a, 0x0f, 0x43, 0x69, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x63, 0x69, 0x64, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x64,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x07, 0x63, 0x69, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x2a, 0x0a,
	0x0e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x2b, 0x0a, 0x0f, 0x42, 0x61, 0x6c,
	0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07,
	0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62,
	0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x22, 0x6d, 0x0a, 0x11, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x21, 0x0a, 0x0c, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x6d, 0x61, 0x6b, 0x65, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x6d, 0x61, 0x6b, 0x65, 0x44, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x22, 0x2e, 0x0a, 0x12, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x12, 0x0a, 0x10, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x4e, 0x0a, 0x11, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39,
	0x0a, 0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x09,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x22, 0x4c, 0x0a, 0x0e, 0x53, 0x65, 0x6e,
	0x64, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12,
	0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x6f, 0x12,
	0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x23, 0x0a, 0x0f, 0x53, 0x65, 0x6e, 0x64, 0x46,
	0x69, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0x48, 0x0a, 0x12,
	0x53, 0x69, 0x67, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x18, 0x0a, 0x07,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x33, 0x0a, 0x13, 0x53, 0x69, 0x67, 0x6e, 0x4d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1c, 0x0a,
	0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0x68, 0x0a, 0x14, 0x56,
	0x65, 0x72, 0x69, 0x66, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61,
	0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0x27, 0x0a, 0x15, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x4d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e,
	0x0a, 0x02, 0x6f, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x02, 0x6f, 0x6b, 0x22, 0x26,
	0x0a, 0x12, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0x58, 0x0a, 0x13, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67,
	0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a,
	0x0c, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x22, 0x2c, 0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x69,
	0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x63, 0x69, 0x64, 0x73, 0x22, 0x5c,
	0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x0c, 0x73, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x30, 0x0a, 0x17,
	0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64, 0x22, 0x1a,
	0x0a, 0x18, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x2a, 0x0a, 0x11, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64, 0x22, 0x54, 0x0a, 0x12, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67,
	0x65, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x0b,
	0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x52, 0x0a, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x22, 0x33, 0x0a, 0x1a,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x46, 0x6f, 0x72,
	0x4a, 0x6f, 0x62, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f,
	0x62, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49,
	0x64, 0x22, 0x66, 0x0a, 0x1b, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x46, 0x6f, 0x72, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x47, 0x0a, 0x0e, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x73, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xd7, 0x01, 0x0a, 0x16, 0x4c, 0x69,
	0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x69, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x69, 0x64, 0x46, 0x69, 0x6c,
	0x74, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x61, 0x73, 0x63,
	0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x61, 0x73,
	0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x26, 0x0a, 0x0f, 0x6e, 0x65, 0x78, 0x74, 0x5f,
	0x70, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0d, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x42, 0x0a, 0x08, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x73, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x08, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x22, 0x97, 0x01, 0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x40, 0x0a, 0x0c, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67,
	0x65, 0x4a, 0x6f, 0x62, 0x52, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x73, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x6f, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x04, 0x6d, 0x6f, 0x72, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x70, 0x61,
	0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d,
	0x6e, 0x65, 0x78, 0x74, 0x50, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x2d, 0x0a,
	0x19, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d,
	0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x22, 0xb0, 0x01, 0x0a,
	0x1a, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d,
	0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x13, 0x71,
	0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f,
	0x62, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x34, 0x0a, 0x16, 0x65,
	0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x14, 0x65, 0x78, 0x65,
	0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x73, 0x12, 0x2c, 0x0a, 0x12, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x10, 0x66,
	0x69, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x22,
	0x32, 0x0a, 0x17, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6a, 0x6f,
	0x62, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x6a, 0x6f, 0x62,
	0x49, 0x64, 0x73, 0x22, 0x5a, 0x0a, 0x18, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x3e, 0x0a, 0x0b, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f, 0x62, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x4a, 0x6f, 0x62, 0x52, 0x0a, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x22,
	0x59, 0x0a, 0x19, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3c, 0x0a, 0x06,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x5c, 0x0a, 0x1a, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52,
	0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x5b, 0x0a, 0x1b, 0x52, 0x65, 0x74, 0x72,
	0x69, 0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3c, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x61, 0x6c,
	0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x60, 0x0a, 0x1c, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76,
	0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x74, 0x72, 0x69,
	0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07,
	0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x96, 0x02, 0x0a, 0x08, 0x41, 0x64, 0x64, 0x72,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x12, 0x60, 0x0a, 0x14, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x5f, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x56, 0x65, 0x72, 0x69,
	0x66, 0x69, 0x65, 0x64, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x12,
	0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e,
	0x66, 0x6f, 0x1a, 0x4c, 0x0a, 0x12, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x43, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x36, 0x0a, 0x17, 0x72, 0x65, 0x6d, 0x61,
	0x69, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x63, 0x61, 0x70, 0x5f, 0x62, 0x79,
	0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x72, 0x65, 0x6d, 0x61, 0x69,
	0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61, 0x63, 0x61, 0x70, 0x42, 0x79, 0x74, 0x65, 0x73,
	0x22, 0x7c, 0x0a, 0x0a, 0x43, 0x69, 0x64, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64,
	0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x06, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x71, 0x75, 0x65, 0x75,
	0x65, 0x64, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x71,
	0x75, 0x65, 0x75, 0x65, 0x64, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x78, 0x65,
	0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x6a, 0x6f, 0x62, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x4a, 0x6f, 0x62, 0x22, 0x2d,
	0x0a, 0x0a, 0x49, 0x70, 0x66, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1f, 0x0a, 0x0b,
	0x61, 0x64, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0a, 0x61, 0x64, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x22, 0xad, 0x01,
	0x0a, 0x09, 0x48, 0x6f, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e,
	0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x75,
	0x6e, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x61,
	0x6c, 0x6c, 0x6f, 0x77, 0x55, 0x6e, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x12, 0x2c, 0x0a, 0x12,
	0x75, 0x6e, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x69,
	0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x10, 0x75, 0x6e, 0x66, 0x72, 0x65, 0x65,
	0x7a, 0x65, 0x4d, 0x61, 0x78, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x31, 0x0a, 0x04, 0x69, 0x70,
	0x66, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x70, 0x66,
	0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x69, 0x70, 0x66, 0x73, 0x22, 0x42, 0x0a,
	0x08, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61,
	0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62,
	0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c,
	0x64, 0x22, 0xbd, 0x03, 0x0a, 0x09, 0x46, 0x69, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x2d, 0x0a, 0x12, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66,
	0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x11, 0x72, 0x65, 0x70,
	0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x2a,
	0x0a, 0x11, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x6d, 0x69, 0x6e, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x64, 0x65, 0x61, 0x6c, 0x4d,
	0x69, 0x6e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x0a, 0x0f, 0x65, 0x78,
	0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x5f, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x0e, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x4d, 0x69, 0x6e,
	0x65, 0x72, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x72, 0x75, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x6d,
	0x69, 0x6e, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x74, 0x72, 0x75,
	0x73, 0x74, 0x65, 0x64, 0x4d, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x0c, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x73, 0x12,
	0x31, 0x0a, 0x05, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x6e, 0x65, 0x77, 0x52, 0x05, 0x72, 0x65, 0x6e,
	0x65, 0x77, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1b, 0x0a, 0x09,
	0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x08, 0x6d, 0x61, 0x78, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x66, 0x61, 0x73,
	0x74, 0x5f, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x0d, 0x66, 0x61, 0x73, 0x74, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c,
	0x12, 0x2a, 0x0a, 0x11, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x64, 0x65, 0x61,
	0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x23, 0x0a, 0x0d,
	0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x5f, 0x64, 0x65, 0x61, 0x6c, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0c, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x44, 0x65, 0x61,
	0x6c, 0x22, 0x60, 0x0a, 0x0a, 0x43, 0x6f, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x38, 0x0a, 0x08, 0x66, 0x69, 0x6c,
	0x65, 0x63, 0x6f, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x46, 0x69, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x63,
	0x6f, 0x69, 0x6e, 0x22, 0x92, 0x01, 0x0a, 0x0d, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2e, 0x0a, 0x03, 0x68, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75,
	0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x6f, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x52, 0x03, 0x68, 0x6f, 0x74, 0x12, 0x31, 0x0a, 0x04, 0x63, 0x6f, 0x6c, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x52, 0x04, 0x63, 0x6f, 0x6c, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x72, 0x65, 0x70, 0x61,
	0x69, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x72, 0x65,
	0x70, 0x61, 0x69, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x27, 0x0a, 0x0b, 0x49, 0x70, 0x66, 0x73,
	0x48, 0x6f, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x22, 0x6b, 0x0a, 0x07, 0x48, 0x6f, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07,
	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x32, 0x0a, 0x04, 0x69, 0x70,
	0x66, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x70, 0x66,
	0x73, 0x48, 0x6f, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x69, 0x70, 0x66, 0x73, 0x22, 0xd0,
	0x01, 0x0a, 0x0a, 0x46, 0x69, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x17, 0x0a,
	0x07, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06,
	0x64, 0x65, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x65,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x65, 0x64,
	0x12, 0x1a, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x14, 0x0a,
	0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x69,
	0x6e, 0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x5f, 0x70, 0x72, 0x69,
	0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x50,
	0x72, 0x69, 0x63, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x69, 0x65, 0x63, 0x65, 0x5f, 0x63, 0x69,
	0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x69, 0x65, 0x63, 0x65, 0x43, 0x69,
	0x64, 0x22, 0x75, 0x0a, 0x07, 0x46, 0x69, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x19, 0x0a, 0x08,
	0x64, 0x61, 0x74, 0x61, 0x5f, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x64, 0x61, 0x74, 0x61, 0x43, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x3b, 0x0a, 0x09, 0x70,
	0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x09, 0x70,
	0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x73, 0x22, 0x5c, 0x0a, 0x08, 0x43, 0x6f, 0x6c, 0x64,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x36,
	0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x63, 0x6f, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x66, 0x69,
	0x6c, 0x65, 0x63, 0x6f, 0x69, 0x6e, 0x22, 0xaf, 0x01, 0x0a, 0x0b, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64, 0x12, 0x10, 0x0a,
	0x03, 0x63, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12,
	0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x2c, 0x0a, 0x03, 0x68, 0x6f, 0x74,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x6f, 0x74, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x03, 0x68, 0x6f, 0x74, 0x12, 0x2f, 0x0a, 0x04, 0x63, 0x6f, 0x6c, 0x64, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6c, 0x64, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x04, 0x63, 0x6f, 0x6c, 0x64, 0x22, 0xf2, 0x02, 0x0a, 0x07, 0x43, 0x69, 0x64,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12, 0x61, 0x0a, 0x1c, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74,
	0x5f, 0x70, 0x75, 0x73, 0x68, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x19,
	0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x50, 0x75, 0x73, 0x68, 0x65, 0x64, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x50, 0x0a, 0x14, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66,
	0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x12, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x4d, 0x0a, 0x13, 0x71,
	0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x6a, 0x6f,
	0x62, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x11, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x51, 0x0a, 0x15, 0x65, 0x78,
	0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f,
	0x6a, 0x6f, 0x62, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x13, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
	0x69, 0x6e, 0x67, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x22, 0xf1, 0x02,
	0x0a, 0x08, 0x44, 0x65, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x72,
	0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x5f, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0b, 0x70, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x43, 0x69, 0x64, 0x12, 0x19, 0x0a,
	0x08, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x07, 0x73, 0x74, 0x61, 0x74, 0x65, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74,
	0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x74,
	0x61, 0x74, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x12, 0x1b, 0x0a,
	0x09, 0x70, 0x69, 0x65, 0x63, 0x65, 0x5f, 0x63, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x70, 0x69, 0x65, 0x63, 0x65, 0x43, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69,
	0x7a, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x26,
	0x0a, 0x0f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x65, 0x70, 0x6f, 0x63,
	0x68, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x70, 0x72, 0x69, 0x63, 0x65, 0x50, 0x65,
	0x72, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f,
	0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x64, 0x65, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x29, 0x0a, 0x10,
	0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x65, 0x70, 0x6f, 0x63, 0x68,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x45, 0x70, 0x6f, 0x63, 0x68, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x22, 0xb4, 0x02, 0x0a, 0x0a, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x15, 0x0a, 0x06, 0x61, 0x70, 0x69, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x61, 0x70, 0x69, 0x49, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12, 0x34, 0x0a, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4a, 0x6f,
	0x62, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12,
	0x1f, 0x0a, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x61, 0x75, 0x73, 0x65, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x61, 0x75, 0x73, 0x65,
	0x12, 0x38, 0x0a, 0x09, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x06, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x08, 0x64, 0x65, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x3d, 0x0a, 0x0b, 0x64, 0x65,
	0x61, 0x6c, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x0a, 0x64,
	0x65, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x5e, 0x0a, 0x09, 0x44, 0x65, 0x61, 0x6c,
	0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61,
	0x6c, 0x5f, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f,
	0x70, 0x6f, 0x73, 0x61, 0x6c, 0x43, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x69, 0x6e, 0x65,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x12, 0x18,
	0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x61, 0x0a, 0x08, 0x4c, 0x6f, 0x67, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x63, 0x69, 0x64, 0x12, 0x15, 0x0a, 0x06, 0x6a, 0x6f, 0x62, 0x5f, 0x69, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6a, 0x6f, 0x62, 0x49, 0x64, 0x12, 0x12, 0x0a,
	0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x74, 0x69, 0x6d,
	0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0xe2, 0x01, 0x0a, 0x11,
	0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x66, 0x72, 0x6f, 0x6d, 0x41, 0x64, 0x64, 0x72, 0x73,
	0x12, 0x1b, 0x0a, 0x09, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x63, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x43, 0x69, 0x64, 0x73, 0x12, 0x27, 0x0a,
	0x0f, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x50,
	0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x23, 0x0a, 0x0d, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64,
	0x65, 0x5f, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x69,
	0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x12, 0x1c, 0x0a, 0x09, 0x61,
	0x73, 0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09,
	0x61, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x25, 0x0a, 0x0e, 0x69, 0x6e, 0x63,
	0x6c, 0x75, 0x64, 0x65, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x0d, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64,
	0x22, 0xf8, 0x02, 0x0a, 0x0f, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c,
	0x5f, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x70,
	0x6f, 0x73, 0x61, 0x6c, 0x43, 0x69, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x73, 0x74, 0x61, 0x74, 0x65,
	0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x73, 0x74, 0x61, 0x74, 0x65,
	0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x69, 0x65, 0x63, 0x65,
	0x5f, 0x63, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x69, 0x65, 0x63,
	0x65, 0x43, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x70, 0x72, 0x69, 0x63,
	0x65, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0d, 0x70, 0x72, 0x69, 0x63, 0x65, 0x50, 0x65, 0x72, 0x45, 0x70, 0x6f, 0x63, 0x68,
	0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x45, 0x70, 0x6f, 0x63,
	0x68, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x17, 0x0a,
	0x07, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,
	0x64, 0x65, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x29, 0x0a, 0x10, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x70, 0x6f, 0x63,
	0x68, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x0c, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0xc2, 0x04, 0x0a, 0x11,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72,
	0x64, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x6f, 0x74, 0x5f, 0x63, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x6f, 0x6f, 0x74, 0x43, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x65,
	0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x70, 0x65, 0x6e,
	0x64, 0x69, 0x6e, 0x67, 0x12, 0x3f, 0x0a, 0x09, 0x64, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x66,
	0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x64, 0x65, 0x61,
	0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x23, 0x0a, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x74, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x4a, 0x0a, 0x13, 0x64, 0x61,
	0x74, 0x61, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x11, 0x64, 0x61, 0x74, 0x61, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x46, 0x0a, 0x11, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0f, 0x64,
	0x61, 0x74, 0x61, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x45, 0x6e, 0x64, 0x12, 0x3f,
	0x0a, 0x0d, 0x73, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x0c, 0x73, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12,
	0x3b, 0x0a, 0x0b, 0x73, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x0a, 0x73, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x64, 0x12, 0x17, 0x0a, 0x07,
	0x65, 0x72, 0x72, 0x5f, 0x6d, 0x73, 0x67, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65,
	0x72, 0x72, 0x4d, 0x73, 0x67, 0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x5f, 0x61, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
	0x22, 0x80, 0x02, 0x0a, 0x11, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x44, 0x65,
	0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x6f, 0x74, 0x5f, 0x63,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x6f, 0x6f, 0x74, 0x43, 0x69,
	0x64, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x72, 0x69,
	0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x50, 0x72, 0x69,
	0x63, 0x65, 0x12, 0x29, 0x0a, 0x10, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x70, 0x61,
	0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x3a, 0x0a,
	0x19, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x5f, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x17, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x69, 0x6e,
	0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x12,
	0x22, 0x0a, 0x0d, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x65, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6d, 0x69, 0x6e, 0x65, 0x72, 0x50, 0x65, 0x65,
	0x72, 0x49, 0x64, 0x22, 0xa5, 0x03, 0x0a, 0x13, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61,
	0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x41, 0x0a, 0x09, 0x64, 0x65, 0x61,
	0x6c, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x08, 0x64, 0x65, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x4a, 0x0a, 0x13,
	0x64, 0x61, 0x74, 0x61, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x11, 0x64, 0x61, 0x74, 0x61, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x46, 0x0a, 0x11, 0x64, 0x61, 0x74, 0x61,
	0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
	0x0f, 0x64, 0x61, 0x74, 0x61, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x45, 0x6e, 0x64,
	0x12, 0x17, 0x0a, 0x07, 0x65, 0x72, 0x72, 0x5f, 0x6d, 0x73, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x65, 0x72, 0x72, 0x4d, 0x73, 0x67, 0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x64, 0x41, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x62, 0x79,
	0x74, 0x65, 0x73, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2a, 0xa0, 0x01, 0x0a, 0x09,
	0x4a, 0x6f, 0x62, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x16, 0x4a, 0x4f, 0x42,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
	0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x4a, 0x4f, 0x42, 0x5f, 0x53, 0x54, 0x41,
	0x54, 0x55, 0x53, 0x5f, 0x51, 0x55, 0x45, 0x55, 0x45, 0x44, 0x10, 0x01, 0x12, 0x18, 0x0a, 0x14,
	0x4a, 0x4f, 0x42, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55,
	0x54, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x4a, 0x4f, 0x42, 0x5f, 0x53, 0x54,
	0x41, 0x54, 0x55, 0x53, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x12, 0x17, 0x0a,
	0x13, 0x4a, 0x4f, 0x42, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x43, 0x41, 0x4e, 0x43,
	0x45, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x16, 0x0a, 0x12, 0x4a, 0x4f, 0x42, 0x5f, 0x53, 0x54,
	0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x05, 0x2a, 0xc3,
	0x01, 0x0a, 0x13, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x25, 0x0a, 0x21, 0x53, 0x54, 0x4f, 0x52, 0x41, 0x47,
	0x45, 0x5f, 0x4a, 0x4f, 0x42, 0x53, 0x5f, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x4f, 0x52, 0x5f,
	0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a,
	0x19, 0x53, 0x54, 0x4f, 0x52, 0x41, 0x47, 0x45, 0x5f, 0x4a, 0x4f, 0x42, 0x53, 0x5f, 0x53, 0x45,
	0x4c, 0x45, 0x43, 0x54, 0x4f, 0x52, 0x5f, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x20, 0x0a, 0x1c,
	0x53, 0x54, 0x4f, 0x52, 0x41, 0x47, 0x45, 0x5f, 0x4a, 0x4f, 0x42, 0x53, 0x5f, 0x53, 0x45, 0x4c,
	0x45, 0x43, 0x54, 0x4f, 0x52, 0x5f, 0x51, 0x55, 0x45, 0x55, 0x45, 0x44, 0x10, 0x02, 0x12, 0x23,
	0x0a, 0x1f, 0x53, 0x54, 0x4f, 0x52, 0x41, 0x47, 0x45, 0x5f, 0x4a, 0x4f, 0x42, 0x53, 0x5f, 0x53,
	0x45, 0x4c, 0x45, 0x43, 0x54, 0x4f, 0x52, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x49, 0x4e,
	0x47, 0x10, 0x03, 0x12, 0x1f, 0x0a, 0x1b, 0x53, 0x54, 0x4f, 0x52, 0x41, 0x47, 0x45, 0x5f, 0x4a,
	0x4f, 0x42, 0x53, 0x5f, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x4f, 0x52, 0x5f, 0x46, 0x49, 0x4e,
	0x41, 0x4c, 0x10, 0x04, 0x32, 0xeb, 0x16, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x12, 0x58, 0x0a, 0x09, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66,
	0x6f, 0x12, 0x23, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x75, 0x69, 0x6c, 0x64,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x67,
	0x0a, 0x0e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
	0x12, 0x28, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66,
	0x69, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x29, 0x2e, 0x70, 0x6f, 0x77,
	0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x55,
	0x73, 0x65, 0x72, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x79, 0x0a, 0x14, 0x44, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x2e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x2f, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x82, 0x01, 0x0a, 0x17, 0x53, 0x65, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c,
	0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x31,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x53, 0x65, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x32, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x73, 0x0a, 0x12, 0x41, 0x70, 0x70, 0x6c, 0x79,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2c, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x41, 0x70, 0x70, 0x6c, 0x79, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4f, 0x0a, 0x06,
	0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x20, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76,
	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6d,
	0x6f, 0x76, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4e, 0x0a,
	0x05, 0x53, 0x74, 0x61, 0x67, 0x65, 0x12, 0x1f, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x67, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x61, 0x67,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x28, 0x01, 0x12, 0x55, 0x0a,
	0x08, 0x53, 0x74, 0x61, 0x67, 0x65, 0x43, 0x69, 0x64, 0x12, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74,
	0x61, 0x67, 0x65, 0x43, 0x69, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x53, 0x74, 0x61, 0x67, 0x65, 0x43, 0x69, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x5e, 0x0a, 0x0b, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x44,
	0x61, 0x74, 0x61, 0x12, 0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x44,
	0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77,
	0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52,
	0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x48, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x12, 0x1d, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x70, 0x6f, 0x77,
	0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x47,
	0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x5a,
	0x0a, 0x09, 0x57, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x12, 0x23, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x57, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x6f, 0x67, 0x73, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x5b, 0x0a, 0x0a, 0x43, 0x69,
	0x64, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x24, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x64,
	0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x43, 0x69, 0x64, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x07, 0x43, 0x69, 0x64, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x21, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75,
	0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74,
	0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x64, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x07, 0x42,
	0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x21, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e,
	0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x5b, 0x0a, 0x0a, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x24, 0x2e,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x77, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x58, 0x0a, 0x09,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x23, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x07, 0x53, 0x65, 0x6e, 0x64, 0x46, 0x69,
	0x6c, 0x12, 0x21, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6e, 0x64, 0x46, 0x69, 0x6c, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x6e, 0x64, 0x46, 0x69, 0x6c,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5e, 0x0a, 0x0b, 0x53, 0x69,
	0x67, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65,
	0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x69,
	0x67, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x64, 0x0a, 0x0d, 0x56, 0x65,
	0x72, 0x69, 0x66, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x27, 0x2e, 0x70, 0x6f,
	0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x4d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x5e, 0x0a, 0x0b, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x6a, 0x0a, 0x0f, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x29, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2a,
	0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5b, 0x0a, 0x0a,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x12, 0x24, 0x2e, 0x70, 0x6f, 0x77,
	0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53,
	0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x25, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x76, 0x0a, 0x13, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x46, 0x6f, 0x72, 0x4a, 0x6f, 0x62,
	0x12, 0x2d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x46, 0x6f, 0x72, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x2e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x46, 0x6f, 0x72, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x12, 0x6a, 0x0a, 0x0f, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x4a, 0x6f, 0x62, 0x73, 0x12, 0x29, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65,
	0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x2a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x73, 0x0a,
	0x12, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d,
	0x61, 0x72, 0x79, 0x12, 0x2c, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a,
	0x6f, 0x62, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x2d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62,
	0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x6f, 0x0a, 0x10, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x12, 0x2a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x61, 0x74, 0x63, 0x68,
	0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75,
	0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x74, 0x6f, 0x72,
	0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x30, 0x01, 0x12, 0x6d, 0x0a, 0x10, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x12, 0x2a, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67,
	0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6e, 0x63,
	0x65, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e,
	0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x74,
	0x6f, 0x72, 0x61, 0x67, 0x65, 0x4a, 0x6f, 0x62, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x73, 0x0a, 0x12, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61,
	0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x12, 0x2c, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f,
	0x72, 0x61, 0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61,
	0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x61,
	0x67, 0x65, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x79, 0x0a, 0x14, 0x52, 0x65, 0x74, 0x72, 0x69,
	0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61, 0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x12,
	0x2e, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61,
	0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x2f, 0x2e, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x61, 0x6c, 0x44, 0x65, 0x61,
	0x6c, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x42, 0x44, 0x5a, 0x42, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x74, 0x65, 0x78, 0x74, 0x69, 0x6c, 0x65, 0x69, 0x6f, 0x2f, 0x70, 0x6f, 0x77, 0x65, 0x72,
	0x67, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x32, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x2f,
	0x70, 0x6f, 0x77, 0x65, 0x72, 0x67, 0x61, 0x74, 0x65, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x76,
	0x31, 0x3b, 0x75, 0x73, 0x65, 0x72, 0x50, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_powergate_user_v1_user_proto_rawDescOnce sync.Once
	file_powergate_user_v1_user_proto_rawDescData = file_powergate_user_v1_user_proto_rawDesc
)

func file_powergate_user_v1_user_proto_rawDescGZIP() []byte {
	file_powergate_user_v1_user_proto_rawDescOnce.Do(func() {
		file_powergate_user_v1_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_powergate_user_v1_user_proto_rawDescData)
	})
	return file_powergate_user_v1_user_proto_rawDescData
}

var file_powergate_user_v1_user_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_powergate_user_v1_user_proto_msgTypes = make([]protoimpl.MessageInfo, 83)
var file_powergate_user_v1_user_proto_goTypes = []interface{}{
	(JobStatus)(0),                          // 0: powergate.user.v1.JobStatus
	(StorageJobsSelector)(0),                // 1: powergate.user.v1.StorageJobsSelector
	(*BuildInfoRequest)(nil),                // 2: powergate.user.v1.BuildInfoRequest
	(*BuildInfoResponse)(nil),               // 3: powergate.user.v1.BuildInfoResponse
	(*UserIdentifierRequest)(nil),           // 4: powergate.user.v1.UserIdentifierRequest
	(*UserIdentifierResponse)(nil),          // 5: powergate.user.v1.UserIdentifierResponse
	(*DefaultStorageConfigRequest)(nil),     // 6: powergate.user.v1.DefaultStorageConfigRequest
	(*DefaultStorageConfigResponse)(nil),    // 7: powergate.user.v1.DefaultStorageConfigResponse
	(*SetDefaultStorageConfigRequest)(nil),  // 8: powergate.user.v1.SetDefaultStorageConfigRequest
	(*SetDefaultStorageConfigResponse)(nil), // 9: powergate.user.v1.SetDefaultStorageConfigResponse
	(*StageRequest)(nil),                    // 10: powergate.user.v1.StageRequest
	(*StageResponse)(nil),                   // 11: powergate.user.v1.StageResponse
	(*StageCidRequest)(nil),                 // 12: powergate.user.v1.StageCidRequest
	(*StageCidResponse)(nil),                // 13: powergate.user.v1.StageCidResponse
	(*ApplyStorageConfigRequest)(nil),       // 14: powergate.user.v1.ApplyStorageConfigRequest
	(*ApplyStorageConfigResponse)(nil),      // 15: powergate.user.v1.ApplyStorageConfigResponse
	(*ReplaceDataRequest)(nil),              // 16: powergate.user.v1.ReplaceDataRequest
	(*ReplaceDataResponse)(nil),             // 17: powergate.user.v1.ReplaceDataResponse
	(*GetRequest)(nil),                      // 18: powergate.user.v1.GetRequest
	(*GetResponse)(nil),                     // 19: powergate.user.v1.GetResponse
	(*RemoveRequest)(nil),                   // 20: powergate.user.v1.RemoveRequest
	(*RemoveResponse)(nil),                  // 21: powergate.user.v1.RemoveResponse
	(*WatchLogsRequest)(nil),                // 22: powergate.user.v1.WatchLogsRequest
	(*WatchLogsResponse)(nil),               // 23: powergate.user.v1.WatchLogsResponse
	(*CidSummaryRequest)(nil),               // 24: powergate.user.v1.CidSummaryRequest
	(*CidSummaryResponse)(nil),              // 25: powergate.user.v1.CidSummaryResponse
	(*CidInfoRequest)(nil),                  // 26: powergate.user.v1.CidInfoRequest
	(*CidInfoResponse)(nil),                 // 27: powergate.user.v1.CidInfoResponse
	(*BalanceRequest)(nil),                  // 28: powergate.user.v1.BalanceRequest
	(*BalanceResponse)(nil),                 // 29: powergate.user.v1.BalanceResponse
	(*NewAddressRequest)(nil),               // 30: powergate.user.v1.NewAddressRequest
	(*NewAddressResponse)(nil),              // 31: powergate.user.v1.NewAddressResponse
	(*AddressesRequest)(nil),                // 32: powergate.user.v1.AddressesRequest
	(*AddressesResponse)(nil),               // 33: powergate.user.v1.AddressesResponse
	(*SendFilRequest)(nil),                  // 34: powergate.user.v1.SendFilRequest
	(*SendFilResponse)(nil),                 // 35: powergate.user.v1.SendFilResponse
	(*SignMessageRequest)(nil),              // 36: powergate.user.v1.SignMessageRequest
	(*SignMessageResponse)(nil),             // 37: powergate.user.v1.SignMessageResponse
	(*VerifyMessageRequest)(nil),            // 38: powergate.user.v1.VerifyMessageRequest
	(*VerifyMessageResponse)(nil),           // 39: powergate.user.v1.VerifyMessageResponse
	(*StorageInfoRequest)(nil),              // 40: powergate.user.v1.StorageInfoRequest
	(*StorageInfoResponse)(nil),             // 41: powergate.user.v1.StorageInfoResponse
	(*ListStorageInfoRequest)(nil),          // 42: powergate.user.v1.ListStorageInfoRequest
	(*ListStorageInfoResponse)(nil),         // 43: powergate.user.v1.ListStorageInfoResponse
	(*CancelStorageJobRequest)(nil),         // 44: powergate.user.v1.CancelStorageJobRequest
	(*CancelStorageJobResponse)(nil),        // 45: powergate.user.v1.CancelStorageJobResponse
	(*StorageJobRequest)(nil),               // 46: powergate.user.v1.StorageJobRequest
	(*StorageJobResponse)(nil),              // 47: powergate.user.v1.StorageJobResponse
	(*StorageConfigForJobRequest)(nil),      // 48: powergate.user.v1.StorageConfigForJobRequest
	(*StorageConfigForJobResponse)(nil),     // 49: powergate.user.v1.StorageConfigForJobResponse
	(*ListStorageJobsRequest)(nil),          // 50: powergate.user.v1.ListStorageJobsRequest
	(*ListStorageJobsResponse)(nil),         // 51: powergate.user.v1.ListStorageJobsResponse
	(*StorageJobsSummaryRequest)(nil),       // 52: powergate.user.v1.StorageJobsSummaryRequest
	(*StorageJobsSummaryResponse)(nil),      // 53: powergate.user.v1.StorageJobsSummaryResponse
	(*WatchStorageJobsRequest)(nil),         // 54: powergate.user.v1.WatchStorageJobsRequest
	(*WatchStorageJobsResponse)(nil),        // 55: powergate.user.v1.WatchStorageJobsResponse
	(*StorageDealRecordsRequest)(nil),       // 56: powergate.user.v1.StorageDealRecordsRequest
	(*StorageDealRecordsResponse)(nil),      // 57: powergate.user.v1.StorageDealRecordsResponse
	(*RetrievalDealRecordsRequest)(nil),     // 58: powergate.user.v1.RetrievalDealRecordsRequest
	(*RetrievalDealRecordsResponse)(nil),    // 59: powergate.user.v1.RetrievalDealRecordsResponse
	(*AddrInfo)(nil),                        // 60: powergate.user.v1.AddrInfo
	(*CidSummary)(nil),                      // 61: powergate.user.v1.CidSummary
	(*IpfsConfig)(nil),                      // 62: powergate.user.v1.IpfsConfig
	(*HotConfig)(nil),                       // 63: powergate.user.v1.HotConfig
	(*FilRenew)(nil),                        // 64: powergate.user.v1.FilRenew
	(*FilConfig)(nil),                       // 65: powergate.user.v1.FilConfig
	(*ColdConfig)(nil),                      // 66: powergate.user.v1.ColdConfig
	(*StorageConfig)(nil),                   // 67: powergate.user.v1.StorageConfig
	(*IpfsHotInfo)(nil),                     // 68: powergate.user.v1.IpfsHotInfo
	(*HotInfo)(nil),                         // 69: powergate.user.v1.HotInfo
	(*FilStorage)(nil),                      // 70: powergate.user.v1.FilStorage
	(*FilInfo)(nil),                         // 71: powergate.user.v1.FilInfo
	(*ColdInfo)(nil),                        // 72: powergate.user.v1.ColdInfo
	(*StorageInfo)(nil),                     // 73: powergate.user.v1.StorageInfo
	(*CidInfo)(nil),                         // 74: powergate.user.v1.CidInfo
	(*DealInfo)(nil),                        // 75: powergate.user.v1.DealInfo
	(*StorageJob)(nil),                      // 76: powergate.user.v1.StorageJob
	(*DealError)(nil),                       // 77: powergate.user.v1.DealError
	(*LogEntry)(nil),                        // 78: powergate.user.v1.LogEntry
	(*DealRecordsConfig)(nil),               // 79: powergate.user.v1.DealRecordsConfig
	(*StorageDealInfo)(nil),                 // 80: powergate.user.v1.StorageDealInfo
	(*StorageDealRecord)(nil),               // 81: powergate.user.v1.StorageDealRecord
	(*RetrievalDealInfo)(nil),               // 82: powergate.user.v1.RetrievalDealInfo
	(*RetrievalDealRecord)(nil),             // 83: powergate.user.v1.RetrievalDealRecord
	(*AddrInfo_VerifiedClientInfo)(nil),     // 84: powergate.user.v1.AddrInfo.VerifiedClientInfo
	(*timestamppb.Timestamp)(nil),           // 85: google.protobuf.Timestamp
}
var file_powergate_user_v1_user_proto_depIdxs = []int32{
	67, // 0: powergate.user.v1.DefaultStorageConfigResponse.default_storage_config:type_name -> powergate.user.v1.StorageConfig
	67, // 1: powergate.user.v1.SetDefaultStorageConfigRequest.config:type_name -> powergate.user.v1.StorageConfig
	67, // 2: powergate.user.v1.ApplyStorageConfigRequest.config:type_name -> powergate.user.v1.StorageConfig
	78, // 3: powergate.user.v1.WatchLogsResponse.log_entry:type_name -> powergate.user.v1.LogEntry
	61, // 4: powergate.user.v1.CidSummaryResponse.cid_summary:type_name -> powergate.user.v1.CidSummary
	74, // 5: powergate.user.v1.CidInfoResponse.cid_info:type_name -> powergate.user.v1.CidInfo
	60, // 6: powergate.user.v1.AddressesResponse.addresses:type_name -> powergate.user.v1.AddrInfo
	73, // 7: powergate.user.v1.StorageInfoResponse.storage_info:type_name -> powergate.user.v1.StorageInfo
	73, // 8: powergate.user.v1.ListStorageInfoResponse.storage_info:type_name -> powergate.user.v1.StorageInfo
	76, // 9: powergate.user.v1.StorageJobResponse.storage_job:type_name -> powergate.user.v1.StorageJob
	67, // 10: powergate.user.v1.StorageConfigForJobResponse.storage_config:type_name -> powergate.user.v1.StorageConfig
	1,  // 11: powergate.user.v1.ListStorageJobsRequest.selector:type_name -> powergate.user.v1.StorageJobsSelector
	76, // 12: powergate.user.v1.ListStorageJobsResponse.storage_jobs:type_name -> powergate.user.v1.StorageJob
	76, // 13: powergate.user.v1.WatchStorageJobsResponse.storage_job:type_name -> powergate.user.v1.StorageJob
	79, // 14: powergate.user.v1.StorageDealRecordsRequest.config:type_name -> powergate.user.v1.DealRecordsConfig
	81, // 15: powergate.user.v1.StorageDealRecordsResponse.records:type_name -> powergate.user.v1.StorageDealRecord
	79, // 16: powergate.user.v1.RetrievalDealRecordsRequest.config:type_name -> powergate.user.v1.DealRecordsConfig
	83, // 17: powergate.user.v1.RetrievalDealRecordsResponse.records:type_name -> powergate.user.v1.RetrievalDealRecord
	84, // 18: powergate.user.v1.AddrInfo.verified_client_info:type_name -> powergate.user.v1.AddrInfo.VerifiedClientInfo
	62, // 19: powergate.user.v1.HotConfig.ipfs:type_name -> powergate.user.v1.IpfsConfig
	64, // 20: powergate.user.v1.FilConfig.renew:type_name -> powergate.user.v1.FilRenew
	65, // 21: powergate.user.v1.ColdConfig.filecoin:type_name -> powergate.user.v1.FilConfig
	63, // 22: powergate.user.v1.StorageConfig.hot:type_name -> powergate.user.v1.HotConfig
	66, // 23: powergate.user.v1.StorageConfig.cold:type_name -> powergate.user.v1.ColdConfig
	68, // 24: powergate.user.v1.HotInfo.ipfs:type_name -> powergate.user.v1.IpfsHotInfo
	70, // 25: powergate.user.v1.FilInfo.proposals:type_name -> powergate.user.v1.FilStorage
	71, // 26: powergate.user.v1.ColdInfo.filecoin:type_name -> powergate.user.v1.FilInfo
	69, // 27: powergate.user.v1.StorageInfo.hot:type_name -> powergate.user.v1.HotInfo
	72, // 28: powergate.user.v1.StorageInfo.cold:type_name -> powergate.user.v1.ColdInfo
	67, // 29: powergate.user.v1.CidInfo.latest_pushed_storage_config:type_name -> powergate.user.v1.StorageConfig
	73, // 30: powergate.user.v1.CidInfo.current_storage_info:type_name -> powergate.user.v1.StorageInfo
	76, // 31: powergate.user.v1.CidInfo.queued_storage_jobs:type_name -> powergate.user.v1.StorageJob
	76, // 32: powergate.user.v1.CidInfo.executing_storage_job:type_name -> powergate.user.v1.StorageJob
	0,  // 33: powergate.user.v1.StorageJob.status:type_name -> powergate.user.v1.JobStatus
	75, // 34: powergate.user.v1.StorageJob.deal_info:type_name -> powergate.user.v1.DealInfo
	77, // 35: powergate.user.v1.StorageJob.deal_errors:type_name -> powergate.user.v1.DealError
	80, // 36: powergate.user.v1.StorageDealRecord.deal_info:type_name -> powergate.user.v1.StorageDealInfo
	85, // 37: powergate.user.v1.StorageDealRecord.data_transfer_start:type_name -> google.protobuf.Timestamp
	85, // 38: powergate.user.v1.StorageDealRecord.data_transfer_end:type_name -> google.protobuf.Timestamp
	85, // 39: powergate.user.v1.StorageDealRecord.sealing_start:type_name -> google.protobuf.Timestamp
	85, // 40: powergate.user.v1.StorageDealRecord.sealing_end:type_name -> google.protobuf.Timestamp
	85, // 41: powergate.user.v1.StorageDealRecord.updated_at:type_name -> google.protobuf.Timestamp
	82, // 42: powergate.user.v1.RetrievalDealRecord.deal_info:type_name -> powergate.user.v1.RetrievalDealInfo
	85, // 43: powergate.user.v1.RetrievalDealRecord.data_transfer_start:type_name -> google.protobuf.Timestamp
	85, // 44: powergate.user.v1.RetrievalDealRecord.data_transfer_end:type_name -> google.protobuf.Timestamp
	85, // 45: powergate.user.v1.RetrievalDealRecord.updated_at:type_name -> google.protobuf.Timestamp
	2,  // 46: powergate.user.v1.UserService.BuildInfo:input_type -> powergate.user.v1.BuildInfoRequest
	4,  // 47: powergate.user.v1.UserService.UserIdentifier:input_type -> powergate.user.v1.UserIdentifierRequest
	6,  // 48: powergate.user.v1.UserService.DefaultStorageConfig:input_type -> powergate.user.v1.DefaultStorageConfigRequest
	8,  // 49: powergate.user.v1.UserService.SetDefaultStorageConfig:input_type -> powergate.user.v1.SetDefaultStorageConfigRequest
	14, // 50: powergate.user.v1.UserService.ApplyStorageConfig:input_type -> powergate.user.v1.ApplyStorageConfigRequest
	20, // 51: powergate.user.v1.UserService.Remove:input_type -> powergate.user.v1.RemoveRequest
	10, // 52: powergate.user.v1.UserService.Stage:input_type -> powergate.user.v1.StageRequest
	12, // 53: powergate.user.v1.UserService.StageCid:input_type -> powergate.user.v1.StageCidRequest
	16, // 54: powergate.user.v1.UserService.ReplaceData:input_type -> powergate.user.v1.ReplaceDataRequest
	18, // 55: powergate.user.v1.UserService.Get:input_type -> powergate.user.v1.GetRequest
	22, // 56: powergate.user.v1.UserService.WatchLogs:input_type -> powergate.user.v1.WatchLogsRequest
	24, // 57: powergate.user.v1.UserService.CidSummary:input_type -> powergate.user.v1.CidSummaryRequest
	26, // 58: powergate.user.v1.UserService.CidInfo:input_type -> powergate.user.v1.CidInfoRequest
	28, // 59: powergate.user.v1.UserService.Balance:input_type -> powergate.user.v1.BalanceRequest
	30, // 60: powergate.user.v1.UserService.NewAddress:input_type -> powergate.user.v1.NewAddressRequest
	32, // 61: powergate.user.v1.UserService.Addresses:input_type -> powergate.user.v1.AddressesRequest
	34, // 62: powergate.user.v1.UserService.SendFil:input_type -> powergate.user.v1.SendFilRequest
	36, // 63: powergate.user.v1.UserService.SignMessage:input_type -> powergate.user.v1.SignMessageRequest
	38, // 64: powergate.user.v1.UserService.VerifyMessage:input_type -> powergate.user.v1.VerifyMessageRequest
	40, // 65: powergate.user.v1.UserService.StorageInfo:input_type -> powergate.user.v1.StorageInfoRequest
	42, // 66: powergate.user.v1.UserService.ListStorageInfo:input_type -> powergate.user.v1.ListStorageInfoRequest
	46, // 67: powergate.user.v1.UserService.StorageJob:input_type -> powergate.user.v1.StorageJobRequest
	48, // 68: powergate.user.v1.UserService.StorageConfigForJob:input_type -> powergate.user.v1.StorageConfigForJobRequest
	50, // 69: powergate.user.v1.UserService.ListStorageJobs:input_type -> powergate.user.v1.ListStorageJobsRequest
	52, // 70: powergate.user.v1.UserService.StorageJobsSummary:input_type -> powergate.user.v1.StorageJobsSummaryRequest
	54, // 71: powergate.user.v1.UserService.WatchStorageJobs:input_type -> powergate.user.v1.WatchStorageJobsRequest
	44, // 72: powergate.user.v1.UserService.CancelStorageJob:input_type -> powergate.user.v1.CancelStorageJobRequest
	56, // 73: powergate.user.v1.UserService.StorageDealRecords:input_type -> powergate.user.v1.StorageDealRecordsRequest
	58, // 74: powergate.user.v1.UserService.RetrievalDealRecords:input_type -> powergate.user.v1.RetrievalDealRecordsRequest
	3,  // 75: powergate.user.v1.UserService.BuildInfo:output_type -> powergate.user.v1.BuildInfoResponse
	5,  // 76: powergate.user.v1.UserService.UserIdentifier:output_type -> powergate.user.v1.UserIdentifierResponse
	7,  // 77: powergate.user.v1.UserService.DefaultStorageConfig:output_type -> powergate.user.v1.DefaultStorageConfigResponse
	9,  // 78: powergate.user.v1.UserService.SetDefaultStorageConfig:output_type -> powergate.user.v1.SetDefaultStorageConfigResponse
	15, // 79: powergate.user.v1.UserService.ApplyStorageConfig:output_type -> powergate.user.v1.ApplyStorageConfigResponse
	21, // 80: powergate.user.v1.UserService.Remove:output_type -> powergate.user.v1.RemoveResponse
	11, // 81: powergate.user.v1.UserService.Stage:output_type -> powergate.user.v1.StageResponse
	13, // 82: powergate.user.v1.UserService.StageCid:output_type -> powergate.user.v1.StageCidResponse
	17, // 83: powergate.user.v1.UserService.ReplaceData:output_type -> powergate.user.v1.ReplaceDataResponse
	19, // 84: powergate.user.v1.UserService.Get:output_type -> powergate.user.v1.GetResponse
	23, // 85: powergate.user.v1.UserService.WatchLogs:output_type -> powergate.user.v1.WatchLogsResponse
	25, // 86: powergate.user.v1.UserService.CidSummary:output_type -> powergate.user.v1.CidSummaryResponse
	27, // 87: powergate.user.v1.UserService.CidInfo:output_type -> powergate.user.v1.CidInfoResponse
	29, // 88: powergate.user.v1.UserService.Balance:output_type -> powergate.user.v1.BalanceResponse
	31, // 89: powergate.user.v1.UserService.NewAddress:output_type -> powergate.user.v1.NewAddressResponse
	33, // 90: powergate.user.v1.UserService.Addresses:output_type -> powergate.user.v1.AddressesResponse
	35, // 91: powergate.user.v1.UserService.SendFil:output_type -> powergate.user.v1.SendFilResponse
	37, // 92: powergate.user.v1.UserService.SignMessage:output_type -> powergate.user.v1.SignMessageResponse
	39, // 93: powergate.user.v1.UserService.VerifyMessage:output_type -> powergate.user.v1.VerifyMessageResponse
	41, // 94: powergate.user.v1.UserService.StorageInfo:output_type -> powergate.user.v1.StorageInfoResponse
	43, // 95: powergate.user.v1.UserService.ListStorageInfo:output_type -> powergate.user.v1.ListStorageInfoResponse
	47, // 96: powergate.user.v1.UserService.StorageJob:output_type -> powergate.user.v1.StorageJobResponse
	49, // 97: powergate.user.v1.UserService.StorageConfigForJob:output_type -> powergate.user.v1.StorageConfigForJobResponse
	51, // 98: powergate.user.v1.UserService.ListStorageJobs:output_type -> powergate.user.v1.ListStorageJobsResponse
	53, // 99: powergate.user.v1.UserService.StorageJobsSummary:output_type -> powergate.user.v1.StorageJobsSummaryResponse
	55, // 100: powergate.user.v1.UserService.WatchStorageJobs:output_type -> powergate.user.v1.WatchStorageJobsResponse
	45, // 101: powergate.user.v1.UserService.CancelStorageJob:output_type -> powergate.user.v1.CancelStorageJobResponse
	57, // 102: powergate.user.v1.UserService.StorageDealRecords:output_type -> powergate.user.v1.StorageDealRecordsResponse
	59, // 103: powergate.user.v1.UserService.RetrievalDealRecords:output_type -> powergate.user.v1.RetrievalDealRecordsResponse
	75, // [75:104] is the sub-list for method output_type
	46, // [46:75] is the sub-list for method input_type
	46, // [46:46] is the sub-list for extension type_name
	46, // [46:46] is the sub-list for extension extendee
	0,  // [0:46] is the sub-list for field type_name
}

func init() { file_powergate_user_v1_user_proto_init() }
func file_powergate_user_v1_user_proto_init() {
	if File_powergate_user_v1_user_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_powergate_user_v1_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BuildInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BuildInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserIdentifierRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserIdentifierResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DefaultStorageConfigRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DefaultStorageConfigResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetDefaultStorageConfigRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetDefaultStorageConfigResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StageCidRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StageCidResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApplyStorageConfigRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApplyStorageConfigResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReplaceDataRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReplaceDataResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoveResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WatchLogsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WatchLogsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidSummaryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidSummaryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BalanceRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BalanceResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewAddressRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewAddressResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendFilRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendFilResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SignMessageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SignMessageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VerifyMessageRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VerifyMessageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageInfoRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageInfoResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CancelStorageJobRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CancelStorageJobResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageConfigForJobRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageConfigForJobResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageJobsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListStorageJobsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobsSummaryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJobsSummaryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WatchStorageJobsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WatchStorageJobsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageDealRecordsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[55].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageDealRecordsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RetrievalDealRecordsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[57].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RetrievalDealRecordsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[58].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddrInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[59].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidSummary); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[60].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpfsConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[61].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HotConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[62].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilRenew); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[63].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[64].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ColdConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[65].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[66].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IpfsHotInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[67].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HotInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[68].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilStorage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[69].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FilInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[70].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ColdInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[71].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[72].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CidInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[73].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DealInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[74].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageJob); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[75].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DealError); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[76].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[77].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DealRecordsConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[78].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageDealInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[79].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StorageDealRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[80].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RetrievalDealInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[81].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RetrievalDealRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_powergate_user_v1_user_proto_msgTypes[82].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddrInfo_VerifiedClientInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_powergate_user_v1_user_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   83,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_powergate_user_v1_user_proto_goTypes,
		DependencyIndexes: file_powergate_user_v1_user_proto_depIdxs,
		EnumInfos:         file_powergate_user_v1_user_proto_enumTypes,
		MessageInfos:      file_powergate_user_v1_user_proto_msgTypes,
	}.Build()
	File_powergate_user_v1_user_proto = out.File
	file_powergate_user_v1_user_proto_rawDesc = nil
	file_powergate_user_v1_user_proto_goTypes = nil
	file_powergate_user_v1_user_proto_depIdxs = nil
}

'''
'''--- Filecoin/powergate/api/gen/powergate/user/v1/user_grpc.pb.go ---
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package userPb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Top level
	BuildInfo(ctx context.Context, in *BuildInfoRequest, opts ...grpc.CallOption) (*BuildInfoResponse, error)
	UserIdentifier(ctx context.Context, in *UserIdentifierRequest, opts ...grpc.CallOption) (*UserIdentifierResponse, error)
	// Storage config
	DefaultStorageConfig(ctx context.Context, in *DefaultStorageConfigRequest, opts ...grpc.CallOption) (*DefaultStorageConfigResponse, error)
	SetDefaultStorageConfig(ctx context.Context, in *SetDefaultStorageConfigRequest, opts ...grpc.CallOption) (*SetDefaultStorageConfigResponse, error)
	ApplyStorageConfig(ctx context.Context, in *ApplyStorageConfigRequest, opts ...grpc.CallOption) (*ApplyStorageConfigResponse, error)
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	// Data
	Stage(ctx context.Context, opts ...grpc.CallOption) (UserService_StageClient, error)
	StageCid(ctx context.Context, in *StageCidRequest, opts ...grpc.CallOption) (*StageCidResponse, error)
	ReplaceData(ctx context.Context, in *ReplaceDataRequest, opts ...grpc.CallOption) (*ReplaceDataResponse, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (UserService_GetClient, error)
	WatchLogs(ctx context.Context, in *WatchLogsRequest, opts ...grpc.CallOption) (UserService_WatchLogsClient, error)
	CidSummary(ctx context.Context, in *CidSummaryRequest, opts ...grpc.CallOption) (*CidSummaryResponse, error)
	CidInfo(ctx context.Context, in *CidInfoRequest, opts ...grpc.CallOption) (*CidInfoResponse, error)
	// Wallet
	Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	Addresses(ctx context.Context, in *AddressesRequest, opts ...grpc.CallOption) (*AddressesResponse, error)
	SendFil(ctx context.Context, in *SendFilRequest, opts ...grpc.CallOption) (*SendFilResponse, error)
	SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)
	VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error)
	// Storage Info
	StorageInfo(ctx context.Context, in *StorageInfoRequest, opts ...grpc.CallOption) (*StorageInfoResponse, error)
	ListStorageInfo(ctx context.Context, in *ListStorageInfoRequest, opts ...grpc.CallOption) (*ListStorageInfoResponse, error)
	// Storage Jobs
	StorageJob(ctx context.Context, in *StorageJobRequest, opts ...grpc.CallOption) (*StorageJobResponse, error)
	StorageConfigForJob(ctx context.Context, in *StorageConfigForJobRequest, opts ...grpc.CallOption) (*StorageConfigForJobResponse, error)
	ListStorageJobs(ctx context.Context, in *ListStorageJobsRequest, opts ...grpc.CallOption) (*ListStorageJobsResponse, error)
	StorageJobsSummary(ctx context.Context, in *StorageJobsSummaryRequest, opts ...grpc.CallOption) (*StorageJobsSummaryResponse, error)
	WatchStorageJobs(ctx context.Context, in *WatchStorageJobsRequest, opts ...grpc.CallOption) (UserService_WatchStorageJobsClient, error)
	CancelStorageJob(ctx context.Context, in *CancelStorageJobRequest, opts ...grpc.CallOption) (*CancelStorageJobResponse, error)
	// Deals
	StorageDealRecords(ctx context.Context, in *StorageDealRecordsRequest, opts ...grpc.CallOption) (*StorageDealRecordsResponse, error)
	RetrievalDealRecords(ctx context.Context, in *RetrievalDealRecordsRequest, opts ...grpc.CallOption) (*RetrievalDealRecordsResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) BuildInfo(ctx context.Context, in *BuildInfoRequest, opts ...grpc.CallOption) (*BuildInfoResponse, error) {
	out := new(BuildInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/BuildInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserIdentifier(ctx context.Context, in *UserIdentifierRequest, opts ...grpc.CallOption) (*UserIdentifierResponse, error) {
	out := new(UserIdentifierResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/UserIdentifier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DefaultStorageConfig(ctx context.Context, in *DefaultStorageConfigRequest, opts ...grpc.CallOption) (*DefaultStorageConfigResponse, error) {
	out := new(DefaultStorageConfigResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/DefaultStorageConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SetDefaultStorageConfig(ctx context.Context, in *SetDefaultStorageConfigRequest, opts ...grpc.CallOption) (*SetDefaultStorageConfigResponse, error) {
	out := new(SetDefaultStorageConfigResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/SetDefaultStorageConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ApplyStorageConfig(ctx context.Context, in *ApplyStorageConfigRequest, opts ...grpc.CallOption) (*ApplyStorageConfigResponse, error) {
	out := new(ApplyStorageConfigResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/ApplyStorageConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Stage(ctx context.Context, opts ...grpc.CallOption) (UserService_StageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserService_serviceDesc.Streams[0], "/powergate.user.v1.UserService/Stage", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceStageClient{stream}
	return x, nil
}

type UserService_StageClient interface {
	Send(*StageRequest) error
	CloseAndRecv() (*StageResponse, error)
	grpc.ClientStream
}

type userServiceStageClient struct {
	grpc.ClientStream
}

func (x *userServiceStageClient) Send(m *StageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userServiceStageClient) CloseAndRecv() (*StageResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) StageCid(ctx context.Context, in *StageCidRequest, opts ...grpc.CallOption) (*StageCidResponse, error) {
	out := new(StageCidResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StageCid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ReplaceData(ctx context.Context, in *ReplaceDataRequest, opts ...grpc.CallOption) (*ReplaceDataResponse, error) {
	out := new(ReplaceDataResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/ReplaceData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (UserService_GetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserService_serviceDesc.Streams[1], "/powergate.user.v1.UserService/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserService_GetClient interface {
	Recv() (*GetResponse, error)
	grpc.ClientStream
}

type userServiceGetClient struct {
	grpc.ClientStream
}

func (x *userServiceGetClient) Recv() (*GetResponse, error) {
	m := new(GetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) WatchLogs(ctx context.Context, in *WatchLogsRequest, opts ...grpc.CallOption) (UserService_WatchLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserService_serviceDesc.Streams[2], "/powergate.user.v1.UserService/WatchLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceWatchLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserService_WatchLogsClient interface {
	Recv() (*WatchLogsResponse, error)
	grpc.ClientStream
}

type userServiceWatchLogsClient struct {
	grpc.ClientStream
}

func (x *userServiceWatchLogsClient) Recv() (*WatchLogsResponse, error) {
	m := new(WatchLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) CidSummary(ctx context.Context, in *CidSummaryRequest, opts ...grpc.CallOption) (*CidSummaryResponse, error) {
	out := new(CidSummaryResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/CidSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CidInfo(ctx context.Context, in *CidInfoRequest, opts ...grpc.CallOption) (*CidInfoResponse, error) {
	out := new(CidInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/CidInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	out := new(BalanceResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/Balance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/NewAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Addresses(ctx context.Context, in *AddressesRequest, opts ...grpc.CallOption) (*AddressesResponse, error) {
	out := new(AddressesResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/Addresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SendFil(ctx context.Context, in *SendFilRequest, opts ...grpc.CallOption) (*SendFilResponse, error) {
	out := new(SendFilResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/SendFil", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {
	out := new(SignMessageResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/SignMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {
	out := new(VerifyMessageResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/VerifyMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) StorageInfo(ctx context.Context, in *StorageInfoRequest, opts ...grpc.CallOption) (*StorageInfoResponse, error) {
	out := new(StorageInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StorageInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListStorageInfo(ctx context.Context, in *ListStorageInfoRequest, opts ...grpc.CallOption) (*ListStorageInfoResponse, error) {
	out := new(ListStorageInfoResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/ListStorageInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) StorageJob(ctx context.Context, in *StorageJobRequest, opts ...grpc.CallOption) (*StorageJobResponse, error) {
	out := new(StorageJobResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StorageJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) StorageConfigForJob(ctx context.Context, in *StorageConfigForJobRequest, opts ...grpc.CallOption) (*StorageConfigForJobResponse, error) {
	out := new(StorageConfigForJobResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StorageConfigForJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListStorageJobs(ctx context.Context, in *ListStorageJobsRequest, opts ...grpc.CallOption) (*ListStorageJobsResponse, error) {
	out := new(ListStorageJobsResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/ListStorageJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) StorageJobsSummary(ctx context.Context, in *StorageJobsSummaryRequest, opts ...grpc.CallOption) (*StorageJobsSummaryResponse, error) {
	out := new(StorageJobsSummaryResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StorageJobsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) WatchStorageJobs(ctx context.Context, in *WatchStorageJobsRequest, opts ...grpc.CallOption) (UserService_WatchStorageJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserService_serviceDesc.Streams[3], "/powergate.user.v1.UserService/WatchStorageJobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceWatchStorageJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserService_WatchStorageJobsClient interface {
	Recv() (*WatchStorageJobsResponse, error)
	grpc.ClientStream
}

type userServiceWatchStorageJobsClient struct {
	grpc.ClientStream
}

func (x *userServiceWatchStorageJobsClient) Recv() (*WatchStorageJobsResponse, error) {
	m := new(WatchStorageJobsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) CancelStorageJob(ctx context.Context, in *CancelStorageJobRequest, opts ...grpc.CallOption) (*CancelStorageJobResponse, error) {
	out := new(CancelStorageJobResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/CancelStorageJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) StorageDealRecords(ctx context.Context, in *StorageDealRecordsRequest, opts ...grpc.CallOption) (*StorageDealRecordsResponse, error) {
	out := new(StorageDealRecordsResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/StorageDealRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RetrievalDealRecords(ctx context.Context, in *RetrievalDealRecordsRequest, opts ...grpc.CallOption) (*RetrievalDealRecordsResponse, error) {
	out := new(RetrievalDealRecordsResponse)
	err := c.cc.Invoke(ctx, "/powergate.user.v1.UserService/RetrievalDealRecords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	// Top level
	BuildInfo(context.Context, *BuildInfoRequest) (*BuildInfoResponse, error)
	UserIdentifier(context.Context, *UserIdentifierRequest) (*UserIdentifierResponse, error)
	// Storage config
	DefaultStorageConfig(context.Context, *DefaultStorageConfigRequest) (*DefaultStorageConfigResponse, error)
	SetDefaultStorageConfig(context.Context, *SetDefaultStorageConfigRequest) (*SetDefaultStorageConfigResponse, error)
	ApplyStorageConfig(context.Context, *ApplyStorageConfigRequest) (*ApplyStorageConfigResponse, error)
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	// Data
	Stage(UserService_StageServer) error
	StageCid(context.Context, *StageCidRequest) (*StageCidResponse, error)
	ReplaceData(context.Context, *ReplaceDataRequest) (*ReplaceDataResponse, error)
	Get(*GetRequest, UserService_GetServer) error
	WatchLogs(*WatchLogsRequest, UserService_WatchLogsServer) error
	CidSummary(context.Context, *CidSummaryRequest) (*CidSummaryResponse, error)
	CidInfo(context.Context, *CidInfoRequest) (*CidInfoResponse, error)
	// Wallet
	Balance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error)
	Addresses(context.Context, *AddressesRequest) (*AddressesResponse, error)
	SendFil(context.Context, *SendFilRequest) (*SendFilResponse, error)
	SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)
	VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error)
	// Storage Info
	StorageInfo(context.Context, *StorageInfoRequest) (*StorageInfoResponse, error)
	ListStorageInfo(context.Context, *ListStorageInfoRequest) (*ListStorageInfoResponse, error)
	// Storage Jobs
	StorageJob(context.Context, *StorageJobRequest) (*StorageJobResponse, error)
	StorageConfigForJob(context.Context, *StorageConfigForJobRequest) (*StorageConfigForJobResponse, error)
	ListStorageJobs(context.Context, *ListStorageJobsRequest) (*ListStorageJobsResponse, error)
	StorageJobsSummary(context.Context, *StorageJobsSummaryRequest) (*StorageJobsSummaryResponse, error)
	WatchStorageJobs(*WatchStorageJobsRequest, UserService_WatchStorageJobsServer) error
	CancelStorageJob(context.Context, *CancelStorageJobRequest) (*CancelStorageJobResponse, error)
	// Deals
	StorageDealRecords(context.Context, *StorageDealRecordsRequest) (*StorageDealRecordsResponse, error)
	RetrievalDealRecords(context.Context, *RetrievalDealRecordsRequest) (*RetrievalDealRecordsResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) BuildInfo(context.Context, *BuildInfoRequest) (*BuildInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildInfo not implemented")
}
func (UnimplementedUserServiceServer) UserIdentifier(context.Context, *UserIdentifierRequest) (*UserIdentifierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIdentifier not implemented")
}
func (UnimplementedUserServiceServer) DefaultStorageConfig(context.Context, *DefaultStorageConfigRequest) (*DefaultStorageConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultStorageConfig not implemented")
}
func (UnimplementedUserServiceServer) SetDefaultStorageConfig(context.Context, *SetDefaultStorageConfigRequest) (*SetDefaultStorageConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultStorageConfig not implemented")
}
func (UnimplementedUserServiceServer) ApplyStorageConfig(context.Context, *ApplyStorageConfigRequest) (*ApplyStorageConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyStorageConfig not implemented")
}
func (UnimplementedUserServiceServer) Remove(context.Context, *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedUserServiceServer) Stage(UserService_StageServer) error {
	return status.Errorf(codes.Unimplemented, "method Stage not implemented")
}
func (UnimplementedUserServiceServer) StageCid(context.Context, *StageCidRequest) (*StageCidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StageCid not implemented")
}
func (UnimplementedUserServiceServer) ReplaceData(context.Context, *ReplaceDataRequest) (*ReplaceDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceData not implemented")
}
func (UnimplementedUserServiceServer) Get(*GetRequest, UserService_GetServer) error {
	return status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUserServiceServer) WatchLogs(*WatchLogsRequest, UserService_WatchLogsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchLogs not implemented")
}
func (UnimplementedUserServiceServer) CidSummary(context.Context, *CidSummaryRequest) (*CidSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CidSummary not implemented")
}
func (UnimplementedUserServiceServer) CidInfo(context.Context, *CidInfoRequest) (*CidInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CidInfo not implemented")
}
func (UnimplementedUserServiceServer) Balance(context.Context, *BalanceRequest) (*BalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Balance not implemented")
}
func (UnimplementedUserServiceServer) NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewAddress not implemented")
}
func (UnimplementedUserServiceServer) Addresses(context.Context, *AddressesRequest) (*AddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Addresses not implemented")
}
func (UnimplementedUserServiceServer) SendFil(context.Context, *SendFilRequest) (*SendFilResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFil not implemented")
}
func (UnimplementedUserServiceServer) SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessage not implemented")
}
func (UnimplementedUserServiceServer) VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMessage not implemented")
}
func (UnimplementedUserServiceServer) StorageInfo(context.Context, *StorageInfoRequest) (*StorageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageInfo not implemented")
}
func (UnimplementedUserServiceServer) ListStorageInfo(context.Context, *ListStorageInfoRequest) (*ListStorageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageInfo not implemented")
}
func (UnimplementedUserServiceServer) StorageJob(context.Context, *StorageJobRequest) (*StorageJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageJob not implemented")
}
func (UnimplementedUserServiceServer) StorageConfigForJob(context.Context, *StorageConfigForJobRequest) (*StorageConfigForJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageConfigForJob not implemented")
}
func (UnimplementedUserServiceServer) ListStorageJobs(context.Context, *ListStorageJobsRequest) (*ListStorageJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageJobs not implemented")
}
func (UnimplementedUserServiceServer) StorageJobsSummary(context.Context, *StorageJobsSummaryRequest) (*StorageJobsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageJobsSummary not implemented")
}
func (UnimplementedUserServiceServer) WatchStorageJobs(*WatchStorageJobsRequest, UserService_WatchStorageJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchStorageJobs not implemented")
}
func (UnimplementedUserServiceServer) CancelStorageJob(context.Context, *CancelStorageJobRequest) (*CancelStorageJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelStorageJob not implemented")
}
func (UnimplementedUserServiceServer) StorageDealRecords(context.Context, *StorageDealRecordsRequest) (*StorageDealRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorageDealRecords not implemented")
}
func (UnimplementedUserServiceServer) RetrievalDealRecords(context.Context, *RetrievalDealRecordsRequest) (*RetrievalDealRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrievalDealRecords not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_BuildInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).BuildInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/BuildInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).BuildInfo(ctx, req.(*BuildInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserIdentifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdentifierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserIdentifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/UserIdentifier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserIdentifier(ctx, req.(*UserIdentifierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DefaultStorageConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultStorageConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DefaultStorageConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/DefaultStorageConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DefaultStorageConfig(ctx, req.(*DefaultStorageConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SetDefaultStorageConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultStorageConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SetDefaultStorageConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/SetDefaultStorageConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SetDefaultStorageConfig(ctx, req.(*SetDefaultStorageConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ApplyStorageConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyStorageConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ApplyStorageConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/ApplyStorageConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ApplyStorageConfig(ctx, req.(*ApplyStorageConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Stage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserServiceServer).Stage(&userServiceStageServer{stream})
}

type UserService_StageServer interface {
	SendAndClose(*StageResponse) error
	Recv() (*StageRequest, error)
	grpc.ServerStream
}

type userServiceStageServer struct {
	grpc.ServerStream
}

func (x *userServiceStageServer) SendAndClose(m *StageResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userServiceStageServer) Recv() (*StageRequest, error) {
	m := new(StageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UserService_StageCid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StageCidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StageCid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StageCid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StageCid(ctx, req.(*StageCidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ReplaceData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ReplaceData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/ReplaceData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ReplaceData(ctx, req.(*ReplaceDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServiceServer).Get(m, &userServiceGetServer{stream})
}

type UserService_GetServer interface {
	Send(*GetResponse) error
	grpc.ServerStream
}

type userServiceGetServer struct {
	grpc.ServerStream
}

func (x *userServiceGetServer) Send(m *GetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserService_WatchLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServiceServer).WatchLogs(m, &userServiceWatchLogsServer{stream})
}

type UserService_WatchLogsServer interface {
	Send(*WatchLogsResponse) error
	grpc.ServerStream
}

type userServiceWatchLogsServer struct {
	grpc.ServerStream
}

func (x *userServiceWatchLogsServer) Send(m *WatchLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserService_CidSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CidSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CidSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/CidSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CidSummary(ctx, req.(*CidSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CidInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CidInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CidInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/CidInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CidInfo(ctx, req.(*CidInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/Balance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Balance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).NewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/NewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).NewAddress(ctx, req.(*NewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Addresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Addresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/Addresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Addresses(ctx, req.(*AddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SendFil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendFilRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SendFil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/SendFil",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SendFil(ctx, req.(*SendFilRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/SignMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SignMessage(ctx, req.(*SignMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/VerifyMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyMessage(ctx, req.(*VerifyMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_StorageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StorageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StorageInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StorageInfo(ctx, req.(*StorageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListStorageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStorageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListStorageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/ListStorageInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListStorageInfo(ctx, req.(*ListStorageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_StorageJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StorageJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StorageJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StorageJob(ctx, req.(*StorageJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_StorageConfigForJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageConfigForJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StorageConfigForJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StorageConfigForJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StorageConfigForJob(ctx, req.(*StorageConfigForJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListStorageJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStorageJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListStorageJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/ListStorageJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListStorageJobs(ctx, req.(*ListStorageJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_StorageJobsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageJobsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StorageJobsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StorageJobsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StorageJobsSummary(ctx, req.(*StorageJobsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_WatchStorageJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchStorageJobsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServiceServer).WatchStorageJobs(m, &userServiceWatchStorageJobsServer{stream})
}

type UserService_WatchStorageJobsServer interface {
	Send(*WatchStorageJobsResponse) error
	grpc.ServerStream
}

type userServiceWatchStorageJobsServer struct {
	grpc.ServerStream
}

func (x *userServiceWatchStorageJobsServer) Send(m *WatchStorageJobsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserService_CancelStorageJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStorageJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CancelStorageJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/CancelStorageJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CancelStorageJob(ctx, req.(*CancelStorageJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_StorageDealRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageDealRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).StorageDealRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/StorageDealRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).StorageDealRecords(ctx, req.(*StorageDealRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RetrievalDealRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrievalDealRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RetrievalDealRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powergate.user.v1.UserService/RetrievalDealRecords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RetrievalDealRecords(ctx, req.(*RetrievalDealRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "powergate.user.v1.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuildInfo",
			Handler:    _UserService_BuildInfo_Handler,
		},
		{
			MethodName: "UserIdentifier",
			Handler:    _UserService_UserIdentifier_Handler,
		},
		{
			MethodName: "DefaultStorageConfig",
			Handler:    _UserService_DefaultStorageConfig_Handler,
		},
		{
			MethodName: "SetDefaultStorageConfig",
			Handler:    _UserService_SetDefaultStorageConfig_Handler,
		},
		{
			MethodName: "ApplyStorageConfig",
			Handler:    _UserService_ApplyStorageConfig_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _UserService_Remove_Handler,
		},
		{
			MethodName: "StageCid",
			Handler:    _UserService_StageCid_Handler,
		},
		{
			MethodName: "ReplaceData",
			Handler:    _UserService_ReplaceData_Handler,
		},
		{
			MethodName: "CidSummary",
			Handler:    _UserService_CidSummary_Handler,
		},
		{
			MethodName: "CidInfo",
			Handler:    _UserService_CidInfo_Handler,
		},
		{
			MethodName: "Balance",
			Handler:    _UserService_Balance_Handler,
		},
		{
			MethodName: "NewAddress",
			Handler:    _UserService_NewAddress_Handler,
		},
		{
			MethodName: "Addresses",
			Handler:    _UserService_Addresses_Handler,
		},
		{
			MethodName: "SendFil",
			Handler:    _UserService_SendFil_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _UserService_SignMessage_Handler,
		},
		{
			MethodName: "VerifyMessage",
			Handler:    _UserService_VerifyMessage_Handler,
		},
		{
			MethodName: "StorageInfo",
			Handler:    _UserService_StorageInfo_Handler,
		},
		{
			MethodName: "ListStorageInfo",
			Handler:    _UserService_ListStorageInfo_Handler,
		},
		{
			MethodName: "StorageJob",
			Handler:    _UserService_StorageJob_Handler,
		},
		{
			MethodName: "StorageConfigForJob",
			Handler:    _UserService_StorageConfigForJob_Handler,
		},
		{
			MethodName: "ListStorageJobs",
			Handler:    _UserService_ListStorageJobs_Handler,
		},
		{
			MethodName: "StorageJobsSummary",
			Handler:    _UserService_StorageJobsSummary_Handler,
		},
		{
			MethodName: "CancelStorageJob",
			Handler:    _UserService_CancelStorageJob_Handler,
		},
		{
			MethodName: "StorageDealRecords",
			Handler:    _UserService_StorageDealRecords_Handler,
		},
		{
			MethodName: "RetrievalDealRecords",
			Handler:    _UserService_RetrievalDealRecords_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stage",
			Handler:       _UserService_Stage_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Get",
			Handler:       _UserService_Get_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchLogs",
			Handler:       _UserService_WatchLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchStorageJobs",
			Handler:       _UserService_WatchStorageJobs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "powergate/user/v1/user.proto",
}

'''
'''--- Filecoin/powergate/api/server/admin/hs.go ---
package admin

import (
	"context"

	adminProto "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// GCStaged runs a unpinning garbage collection and returns the unpinned cids.
func (a *Service) GCStaged(ctx context.Context, req *adminProto.GCStagedRequest) (*adminProto.GCStagedResponse, error) {
	cids, err := a.s.GCStaged(ctx)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "running FFS GC: %v", err)
	}

	cidsStr := make([]string, len(cids))
	for i := range cids {
		cidsStr[i] = cids[i].String()
	}

	return &adminProto.GCStagedResponse{
		UnpinnedCids: cidsStr,
	}, nil
}

// PinnedCids returns all the pinned cids in Hot-Storage.
func (a *Service) PinnedCids(ctx context.Context, req *adminProto.PinnedCidsRequest) (*adminProto.PinnedCidsResponse, error) {
	pcids, err := a.s.PinnedCids(ctx)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting pinned cids: %v", err)
	}

	res := &adminProto.PinnedCidsResponse{
		Cids: make([]*adminProto.HSPinnedCid, len(pcids)),
	}

	for i, pc := range pcids {
		hspc := &adminProto.HSPinnedCid{
			Cid:   pc.Cid.String(),
			Users: make([]*adminProto.HSPinnedCidUser, len(pc.APIIDs)),
		}

		for j, up := range pc.APIIDs {
			upr := &adminProto.HSPinnedCidUser{
				UserId:    up.ID.String(),
				Staged:    up.Staged,
				CreatedAt: up.CreatedAt,
			}
			hspc.Users[j] = upr
		}
		res.Cids[i] = hspc
	}

	return res, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/indices.go ---
package admin

import (
	"context"
	"strconv"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
)

// GetMiners returns all miner addresses that satisfy the provided filters.
func (s *Service) GetMiners(ctx context.Context, req *adminPb.GetMinersRequest) (*adminPb.GetMinersResponse, error) {
	info := s.mi.Get()

	var resMiners []*adminPb.FilecoinMiner
	for addr, info := range info.OnChain.Miners {
		if req.WithPower && info.Power == 0 {
			continue
		}
		resMiners = append(resMiners, &adminPb.FilecoinMiner{
			Address: addr,
		})
	}

	res := &adminPb.GetMinersResponse{
		Miners: resMiners,
	}

	return res, nil
}

// GetMinerInfo return indices information for the provider miners.
func (s *Service) GetMinerInfo(ctx context.Context, req *adminPb.GetMinerInfoRequest) (*adminPb.GetMinerInfoResponse, error) {
	res := &adminPb.GetMinerInfoResponse{}

	mi := s.mi.Get()
	ai := s.ai.Get()
	for _, minerAddr := range req.Miners {
		onchain, ok := mi.OnChain.Miners[minerAddr]
		if !ok {
			continue
		}

		var minerLocation string
		meta, ok := mi.Meta.Info[minerAddr]
		if ok {
			minerLocation = meta.Location.Country
		}

		lastAsk := ai.Storage[minerAddr]
		res.MinersInfo = append(res.MinersInfo, &adminPb.MinerInfo{
			Address:          minerAddr,
			AskPrice:         strconv.FormatUint(lastAsk.Price, 10),
			AskVerifiedPrice: strconv.FormatUint(lastAsk.VerifiedPrice, 10),
			MaxPieceSize:     lastAsk.MaxPieceSize,
			MinPieceSize:     lastAsk.MinPieceSize,
			RelativePower:    onchain.RelativePower,
			SectorSize:       onchain.SectorSize,
			SectorsLive:      onchain.SectorsLive,
			SectorsFaulty:    onchain.SectorsFaulty,
			SectorsActive:    onchain.SectorsActive,
			Location:         minerLocation,
		})
	}

	return res, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/jobs.go ---
package admin

import (
	"context"

	"github.com/ipfs/go-cid"
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	su "github.com/textileio/powergate/v2/api/server/util"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// ListStorageJobs lists StorageJobs according to the provided request parameters.
func (a *Service) ListStorageJobs(ctx context.Context, req *adminPb.ListStorageJobsRequest) (*adminPb.ListStorageJobsResponse, error) {
	var selector scheduler.Select
	switch req.Selector {
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_ALL:
		selector = scheduler.All
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_EXECUTING:
		selector = scheduler.Executing
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_FINAL:
		selector = scheduler.Final
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_QUEUED:
		selector = scheduler.Queued
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED:
		selector = scheduler.All
	}
	conf := scheduler.ListStorageJobsConfig{
		APIIDFilter:   ffs.APIID(req.UserIdFilter),
		Limit:         req.Limit,
		Ascending:     req.Ascending,
		NextPageToken: req.NextPageToken,
		Select:        selector,
	}
	if req.CidFilter != "" {
		c, err := cid.Decode(req.CidFilter)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "parsing cid filter: %v", err)
		}
		conf.CidFilter = c
	}
	jobs, more, next, err := a.s.ListStorageJobs(conf)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing storage jobs: %v", err)
	}
	protoJobs, err := su.ToProtoStorageJobs(jobs)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "converting jobs to protos: %v", err)
	}
	res := &adminPb.ListStorageJobsResponse{
		StorageJobs:   protoJobs,
		More:          more,
		NextPageToken: next,
	}
	return res, nil
}

// StorageJobsSummary returns a summary of all storage jobs.
func (a *Service) StorageJobsSummary(ctx context.Context, req *adminPb.StorageJobsSummaryRequest) (*adminPb.StorageJobsSummaryResponse, error) {
	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
	}

	queuedJobs, _, _, err := a.s.ListStorageJobs(scheduler.ListStorageJobsConfig{Select: scheduler.Queued, APIIDFilter: ffs.APIID(req.UserId), CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing queued jobs: %v", err)
	}
	executingJobs, _, _, err := a.s.ListStorageJobs(scheduler.ListStorageJobsConfig{Select: scheduler.Executing, APIIDFilter: ffs.APIID(req.UserId), CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing executing jobs: %v", err)
	}
	finalJobs, _, _, err := a.s.ListStorageJobs(scheduler.ListStorageJobsConfig{Select: scheduler.Final, APIIDFilter: ffs.APIID(req.UserId), CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing final jobs: %v", err)
	}

	var queuedJobIDs []string
	for _, job := range queuedJobs {
		queuedJobIDs = append(queuedJobIDs, job.ID.String())
	}
	var executingJobIDs []string
	for _, job := range executingJobs {
		executingJobIDs = append(executingJobIDs, job.ID.String())
	}
	var finalJobIDs []string
	for _, job := range finalJobs {
		finalJobIDs = append(finalJobIDs, job.ID.String())
	}

	return &adminPb.StorageJobsSummaryResponse{
		QueuedStorageJobs:    queuedJobIDs,
		ExecutingStorageJobs: executingJobIDs,
		FinalStorageJobs:     finalJobIDs,
	}, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/records.go ---
package admin

import (
	"context"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"github.com/textileio/powergate/v2/api/server/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// GetUpdatedStorageDealRecordsSince returns all the storage deal records that got created or updated
// since a provided point in time.
func (a *Service) GetUpdatedStorageDealRecordsSince(ctx context.Context, req *adminPb.GetUpdatedStorageDealRecordsSinceRequest) (*adminPb.GetUpdatedStorageDealRecordsSinceResponse, error) {
	rs, err := a.dm.GetUpdatedStorageDealRecordsSince(req.Since.AsTime(), int(req.Limit))
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting updated storage deal records: %s", err)
	}

	return &adminPb.GetUpdatedStorageDealRecordsSinceResponse{Records: util.ToRPCStorageDealRecords(rs)}, nil
}

// GetUpdatedRetrievalRecordsSince returns all the retrieval records that got created or updated
// since a provided point in time.
func (a *Service) GetUpdatedRetrievalRecordsSince(ctx context.Context, req *adminPb.GetUpdatedRetrievalRecordsSinceRequest) (*adminPb.GetUpdatedRetrievalRecordsSinceResponse, error) {
	rs, err := a.dm.GetUpdatedRetrievalRecordsSince(req.Since.AsTime(), int(req.Limit))
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting updated retrieval records: %s", err)
	}

	return &adminPb.GetUpdatedRetrievalRecordsSinceResponse{Records: util.ToRPCRetrievalDealRecords(rs)}, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/service.go ---
package admin

import (
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	dealsModule "github.com/textileio/powergate/v2/deals/module"
	"github.com/textileio/powergate/v2/ffs/manager"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	askIndex "github.com/textileio/powergate/v2/index/ask/runner"
	minerIndex "github.com/textileio/powergate/v2/index/miner/lotusidx"
	"github.com/textileio/powergate/v2/wallet"
)

// Service implements the Admin API.
type Service struct {
	adminPb.UnimplementedAdminServiceServer
	m  *manager.Manager
	s  *scheduler.Scheduler
	wm wallet.Module
	dm *dealsModule.Module
	mi *minerIndex.Index
	ai *askIndex.Runner
}

// New creates a new AdminService.
func New(m *manager.Manager, s *scheduler.Scheduler, wm wallet.Module, dm *dealsModule.Module, mi *minerIndex.Index, ai *askIndex.Runner) *Service {
	return &Service{
		m:  m,
		s:  s,
		wm: wm,
		dm: dm,
		mi: mi,
		ai: ai,
	}
}

'''
'''--- Filecoin/powergate/api/server/admin/storageinfo.go ---
package admin

import (
	"context"

	"github.com/ipfs/go-cid"
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	su "github.com/textileio/powergate/v2/api/server/util"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// StorageInfo returns the information about a stored Cid. If no information is available,
// since the Cid was never stored, it returns an error with codes.NotFound.
func (a *Service) StorageInfo(ctx context.Context, req *adminPb.StorageInfoRequest) (*adminPb.StorageInfoResponse, error) {
	iid := ffs.APIID(req.UserId)
	cid, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
	}
	info, err := a.s.GetStorageInfo(iid, cid)
	if err == api.ErrNotFound {
		return nil, status.Errorf(codes.NotFound, "getting storage info: %v", err)
	}
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting storage info: %v", err)
	}
	pbInfo := su.ToRPCStorageInfo(info)
	return &adminPb.StorageInfoResponse{StorageInfo: pbInfo}, nil
}

// ListStorageInfo returns a list of information about all stored cids, filtered by user ids and cids if provided.
func (a *Service) ListStorageInfo(ctx context.Context, req *adminPb.ListStorageInfoRequest) (*adminPb.ListStorageInfoResponse, error) {
	iids := make([]ffs.APIID, len(req.UserIds))
	for i, id := range req.UserIds {
		iids[i] = ffs.APIID(id)
	}
	cids := make([]cid.Cid, len(req.Cids))
	for i, s := range req.Cids {
		c, err := util.CidFromString(s)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
		}
		cids[i] = c
	}
	infos, err := a.s.ListStorageInfo(iids, cids)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "querying storage info: %v", err)
	}
	res := make([]*userPb.StorageInfo, len(infos))
	for i, info := range infos {
		res[i] = su.ToRPCStorageInfo(info)
	}
	return &adminPb.ListStorageInfoResponse{StorageInfo: res}, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/users.go ---
package admin

import (
	"context"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// CreateUser creates a new managed instance.
func (a *Service) CreateUser(ctx context.Context, req *adminPb.CreateUserRequest) (*adminPb.CreateUserResponse, error) {
	auth, err := a.m.Create(ctx)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "creating instance: %v", err)
	}
	return &adminPb.CreateUserResponse{
		User: &adminPb.User{
			Id:    auth.APIID.String(),
			Token: auth.Token,
		},
	}, nil
}

// RegenerateAuth invalidates an existing token replacing it with a new one.
func (a *Service) RegenerateAuth(ctx context.Context, req *adminPb.RegenerateAuthRequest) (*adminPb.RegenerateAuthResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "request is nil")
	}
	if req.Token == "" {
		return nil, status.Errorf(codes.InvalidArgument, "token can't be empty")
	}

	newToken, err := a.m.RegenerateAuthToken(req.Token)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "creating instance: %v", err)
	}

	return &adminPb.RegenerateAuthResponse{
		NewToken: newToken,
	}, nil
}

// Users lists all managed instances.
func (a *Service) Users(ctx context.Context, req *adminPb.UsersRequest) (*adminPb.UsersResponse, error) {
	lst, err := a.m.List()
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing users: %v", err)
	}
	ins := make([]*adminPb.User, len(lst))
	for i, v := range lst {
		ins[i] = &adminPb.User{
			Id:    v.APIID.String(),
			Token: v.Token,
		}
	}
	return &adminPb.UsersResponse{
		Users: ins,
	}, nil
}

'''
'''--- Filecoin/powergate/api/server/admin/wallet.go ---
package admin

import (
	"context"
	"math/big"

	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// NewAddress creates a new address.
func (a *Service) NewAddress(ctx context.Context, req *adminPb.NewAddressRequest) (*adminPb.NewAddressResponse, error) {
	addr, err := a.wm.NewAddress(ctx, req.AddressType)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "creating address: %v", err)
	}
	return &adminPb.NewAddressResponse{
		Address: addr,
	}, nil
}

// Addresses lists all addresses associated with this Powergate.
func (a *Service) Addresses(ctx context.Context, req *adminPb.AddressesRequest) (*adminPb.AddressesResponse, error) {
	addrs, err := a.wm.List(ctx)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing addrs: %v", err)
	}
	return &adminPb.AddressesResponse{
		Addresses: addrs,
	}, nil
}

// SendFil sends FIL from an address associated with this Powergate to any other address.
func (a *Service) SendFil(ctx context.Context, req *adminPb.SendFilRequest) (*adminPb.SendFilResponse, error) {
	amt, ok := new(big.Int).SetString(req.Amount, 10)
	if !ok {
		return nil, status.Errorf(codes.InvalidArgument, "parsing amount %v", req.Amount)
	}
	cid, err := a.wm.SendFil(ctx, req.From, req.To, amt)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "sending fil: %v", err)
	}
	return &adminPb.SendFilResponse{
		Cid: cid.String(),
	}, nil
}

'''
'''--- Filecoin/powergate/api/server/server.go ---
package server

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/lotus/api"
	grpcm "github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/util/metautils"
	"github.com/improbable-eng/grpc-web/go/grpcweb"
	"github.com/ipfs/go-datastore"
	kt "github.com/ipfs/go-datastore/keytransform"
	badger "github.com/ipfs/go-ds-badger2"
	httpapi "github.com/ipfs/go-ipfs-http-client"
	logging "github.com/ipfs/go-log/v2"
	ma "github.com/multiformats/go-multiaddr"
	measure "github.com/textileio/go-ds-measure"
	mongods "github.com/textileio/go-ds-mongo"
	adminPb "github.com/textileio/powergate/v2/api/gen/powergate/admin/v1"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/api/server/admin"
	"github.com/textileio/powergate/v2/api/server/user"
	"github.com/textileio/powergate/v2/deals"
	dealsModule "github.com/textileio/powergate/v2/deals/module"
	"github.com/textileio/powergate/v2/fchost"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/coreipfs"
	"github.com/textileio/powergate/v2/ffs/filcold"
	"github.com/textileio/powergate/v2/ffs/joblogger"
	"github.com/textileio/powergate/v2/ffs/manager"
	"github.com/textileio/powergate/v2/ffs/minerselector/reptop"
	"github.com/textileio/powergate/v2/ffs/minerselector/sr2"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	"github.com/textileio/powergate/v2/filchain"
	"github.com/textileio/powergate/v2/gateway"
	ask "github.com/textileio/powergate/v2/index/ask/runner"
	faultsModule "github.com/textileio/powergate/v2/index/faults/module"
	minerIndex "github.com/textileio/powergate/v2/index/miner/lotusidx"
	"github.com/textileio/powergate/v2/iplocation/maxmind"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/migration"
	"github.com/textileio/powergate/v2/reputation"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
	"github.com/textileio/powergate/v2/util"
	lotusWallet "github.com/textileio/powergate/v2/wallet/lotuswallet"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const (
	datastoreFolderName = "datastore"
)

var (
	log = logging.Logger("server")

	nonCompliantAPIs = []string{
		"/ffs.rpc.RPCService/SendFil",
	}

	// Migrations contains the list of supported migrations.
	Migrations = map[int]migration.Migration{
		1: migration.V1MultitenancyMigration,
		2: migration.V2StorageInfoDealIDs,
		3: migration.V3StorageJobsIndexMigration,
		4: migration.V4RecordsMigration,
		5: migration.V5DeleteOldMinerIndex,
	}
)

// Server represents the configured lotus client and filecoin grpc server.
type Server struct {
	ds datastore.TxnDatastore

	mm *maxmind.MaxMind
	ai *ask.Runner
	mi *minerIndex.Index
	fi *faultsModule.Index
	dm *dealsModule.Module
	wm *lotusWallet.Module
	rm *reputation.Module

	ffsManager *manager.Manager
	sched      *scheduler.Scheduler
	hs         ffs.HotStorage
	l          *joblogger.Logger

	grpcServer *grpc.Server

	webProxy *http.Server

	gateway     *gateway.Gateway
	indexServer *http.Server
}

// Config specifies server settings.
type Config struct {
	RepoPath        string
	MaxMindDBFolder string
	Devnet          bool
	IpfsAPIAddr     ma.Multiaddr

	LotusAddress           ma.Multiaddr
	LotusAuthToken         string
	LotusMasterAddr        string
	LotusConnectionRetries int

	GrpcHostNetwork     string
	GrpcHostAddress     ma.Multiaddr
	GrpcServerOpts      []grpc.ServerOption
	GrpcWebProxyAddress string

	GatewayBasePath      string
	GatewayHostAddr      string
	IndexRawJSONHostAddr string

	MongoURI string
	MongoDB  string

	FFSAdminToken                string
	FFSUseMasterAddr             bool
	FFSDealFinalityTimeout       time.Duration
	FFSMinimumPieceSize          uint64
	FFSRetrievalNextEventTimeout time.Duration
	FFSMaxParallelDealPreparing  int
	FFSGCAutomaticGCInterval     time.Duration
	FFSGCStageGracePeriod        time.Duration
	SchedMaxParallel             int
	MinerSelector                string
	MinerSelectorParams          string
	DealWatchPollDuration        time.Duration
	AutocreateMasterAddr         bool
	WalletInitialFunds           big.Int

	AskIndexQueryAskTimeout time.Duration
	AskindexMaxParallel     int
	AskIndexRefreshInterval time.Duration
	AskIndexRefreshOnStart  bool

	IndexMinersRefreshOnStart     bool
	IndexMinersOnChainMaxParallel int
	IndexMinersOnChainFrequency   time.Duration

	DisableIndices bool

	DisableNonCompliantAPIs bool
}

// NewServer starts and returns a new server with the given configuration.
func NewServer(conf Config) (*Server, error) {
	if conf.FFSUseMasterAddr && !conf.Devnet && !(len(conf.LotusMasterAddr) > 0 || conf.AutocreateMasterAddr) {
		return nil, fmt.Errorf("FFSUseMasterAddr requires LotusMasterAddr or AutocreateMasterAddr to be provided")
	}

	var err error
	clientBuilder, err := lotus.NewBuilder(conf.LotusAddress, conf.LotusAuthToken, conf.LotusConnectionRetries)
	if err != nil {
		return nil, fmt.Errorf("creating lotus client builder: %s", err)
	}
	lsm, err := lotus.NewSyncMonitor(clientBuilder)
	if err != nil {
		return nil, fmt.Errorf("creating lotus sync monitor: %s", err)
	}

	c, cls, err := clientBuilder(context.Background())
	if err != nil {
		return nil, fmt.Errorf("connecting to lotus node: %s", err)
	}

	masterAddr, err := evaluateMasterAddr(conf, c)
	if err != nil {
		return nil, fmt.Errorf("evaluating ffs master addr: %s", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	network, err := c.StateNetworkName(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting Lotus network name: %s", err)
	}
	cls()

	networkName := string(network)
	log.Infof("Detected Lotus node connected to network: %s", networkName)

	fchost, err := fchost.New(networkName, !conf.Devnet)
	if err != nil {
		return nil, fmt.Errorf("creating filecoin host: %s", err)
	}
	if !conf.Devnet {
		if err := fchost.Bootstrap(); err != nil {
			return nil, fmt.Errorf("bootstrapping filecoin host: %s", err)
		}
	}

	if err := runMigrations(conf); err != nil {
		return nil, fmt.Errorf("running migrations: %s", err)
	}

	ds, err := createDatastore(conf, false)
	if err != nil {
		return nil, fmt.Errorf("creating datastore: %s", err)
	}

	log.Info("Wiring internal components...")
	mm, err := maxmind.New(filepath.Join(conf.MaxMindDBFolder, "GeoLite2-City.mmdb"))
	if err != nil {
		return nil, fmt.Errorf("opening maxmind database: %s", err)
	}
	askIdxConf := ask.Config{
		Disable:         conf.DisableIndices,
		QueryAskTimeout: conf.AskIndexQueryAskTimeout,
		MaxParallel:     conf.AskindexMaxParallel,
		RefreshInterval: conf.AskIndexRefreshInterval,
		RefreshOnStart:  conf.Devnet || conf.AskIndexRefreshOnStart,
	}
	log.Info("Starting ask index...")
	ai, err := ask.New(txndstr.Wrap(ds, "index/ask"), clientBuilder, askIdxConf)
	if err != nil {
		return nil, fmt.Errorf("creating ask index: %s", err)
	}

	log.Info("Starting miner index...")
	minerIdxConf := minerIndex.Config{
		RefreshOnStart:     conf.IndexMinersRefreshOnStart,
		Disable:            conf.DisableIndices,
		OnChainMaxParallel: conf.IndexMinersOnChainMaxParallel,
		OnChainFrequency:   conf.IndexMinersOnChainFrequency,
	}
	mi, err := minerIndex.New(kt.Wrap(ds, kt.PrefixTransform{Prefix: datastore.NewKey("index/miner")}), clientBuilder, fchost, mm, minerIdxConf)
	if err != nil {
		return nil, fmt.Errorf("creating miner index: %s", err)
	}

	log.Info("Starting faults index...")
	si, err := faultsModule.New(txndstr.Wrap(ds, "index/faults"), clientBuilder, conf.DisableIndices)
	if err != nil {
		return nil, fmt.Errorf("creating faults index: %s", err)
	}
	if conf.Devnet {
		conf.DealWatchPollDuration = time.Second
	}

	log.Info("Starting deals module...")
	dm, err := dealsModule.New(txndstr.Wrap(ds, "deals"), clientBuilder, conf.DealWatchPollDuration, conf.FFSDealFinalityTimeout, deals.WithImportPath(filepath.Join(conf.RepoPath, "imports")))
	if err != nil {
		return nil, fmt.Errorf("creating deal module: %s", err)
	}

	log.Info("Starting wallet module...")
	wm, err := lotusWallet.New(clientBuilder, masterAddr, conf.WalletInitialFunds, conf.AutocreateMasterAddr, networkName)
	if err != nil {
		return nil, fmt.Errorf("creating wallet module: %s", err)
	}
	rm := reputation.New(txndstr.Wrap(ds, "reputation"), mi, si, ai)

	ipfs, err := httpapi.NewApi(conf.IpfsAPIAddr)
	if err != nil {
		return nil, fmt.Errorf("creating ipfs client: %s", err)
	}

	chain := filchain.New(clientBuilder)

	ms, err := getMinerSelector(conf, rm, ai, clientBuilder)
	if err != nil {
		return nil, fmt.Errorf("creating miner selector: %s", err)
	}

	l := joblogger.New(txndstr.Wrap(ds, "ffs/joblogger_v2"))
	if conf.Devnet {
		conf.FFSMinimumPieceSize = 0
	}
	cs := filcold.New(ms, dm, wm, ipfs, chain, l, lsm, conf.FFSMinimumPieceSize, conf.FFSMaxParallelDealPreparing, conf.FFSRetrievalNextEventTimeout)
	hs, err := coreipfs.New(txndstr.Wrap(ds, "ffs/coreipfs"), ipfs, l)
	if err != nil {
		return nil, fmt.Errorf("creating coreipfs: %s", err)
	}

	log.Info("Starting FFS scheduler...")
	var sr2rf func() (int, error)
	if ms, ok := ms.(*sr2.MinerSelector); ok {
		sr2rf = ms.GetReplicationFactor
	}
	gcConfig := scheduler.GCConfig{StageGracePeriod: conf.FFSGCStageGracePeriod, AutoGCInterval: conf.FFSGCAutomaticGCInterval}
	sched, err := scheduler.New(txndstr.Wrap(ds, "ffs/scheduler"), l, hs, cs, conf.SchedMaxParallel, conf.FFSDealFinalityTimeout, sr2rf, gcConfig)
	if err != nil {
		return nil, fmt.Errorf("creating scheduler: %s", err)
	}

	ffsManager, err := manager.New(txndstr.Wrap(ds, "ffs/manager"), wm, dm, sched, conf.FFSUseMasterAddr, conf.Devnet)
	if err != nil {
		return nil, fmt.Errorf("creating ffs instance: %s", err)
	}

	log.Info("Starting gRPC, gateway and index HTTP servers...")

	unaryInterceptors := []grpc.UnaryServerInterceptor{adminAuth(conf)}
	if conf.DisableNonCompliantAPIs {
		unaryInterceptors = append(unaryInterceptors, nonCompliantAPIsInterceptor(nonCompliantAPIs))
	}
	unaryInterceptorChain := grpcm.WithUnaryServerChain(unaryInterceptors...)

	opts := append(conf.GrpcServerOpts, unaryInterceptorChain)
	grpcServer := grpc.NewServer(opts...)
	wrappedGRPCServer := wrapGRPCServer(grpcServer)
	httpFFSAuthInterceptor, err := newHTTPFFSAuthInterceptor(conf, ffsManager)
	if err != nil {
		return nil, fmt.Errorf("creating ffsHTTPAuth: %s", err)
	}
	webProxy := createProxyServer(wrappedGRPCServer, httpFFSAuthInterceptor, conf.GrpcWebProxyAddress)

	gateway := gateway.NewGateway(conf.GatewayHostAddr, ai, mi, si, rm)
	gateway.Start(conf.GatewayBasePath)

	s := &Server{
		ds: ds,

		mm: mm,

		ai: ai,
		mi: mi,
		fi: si,
		dm: dm,
		wm: wm,
		rm: rm,

		ffsManager: ffsManager,
		sched:      sched,
		hs:         hs,
		l:          l,

		grpcServer: grpcServer,
		webProxy:   webProxy,
		gateway:    gateway,
	}

	if err := startGRPCServices(grpcServer, webProxy, s, conf.GrpcHostNetwork, conf.GrpcHostAddress); err != nil {
		return nil, fmt.Errorf("starting GRPC services: %s", err)
	}

	s.indexServer = startIndexHTTPServer(s, conf.IndexRawJSONHostAddr)

	log.Info("Starting finished, serving requests")

	return s, nil
}

type ffsHTTPAuth struct {
	cont       http.Handler
	ffsManager *manager.Manager
}

func newHTTPFFSAuthInterceptor(conf Config, m *manager.Manager) (*ffsHTTPAuth, error) {
	log.Info("Starting IPFS reverse proxy...")
	ipfsIP, err := util.TCPAddrFromMultiAddr(conf.IpfsAPIAddr)
	if err != nil {
		return nil, fmt.Errorf("converting IPFS multiaddr to tcp addr: %s", err)
	}

	urlIPFS, err := url.Parse("http://" + ipfsIP)
	if err != nil {
		return nil, fmt.Errorf("generating IPFS URL for reverse proxy: %s", err)
	}
	rph := httputil.NewSingleHostReverseProxy(urlIPFS)
	rph.FlushInterval = -1
	fha := &ffsHTTPAuth{
		cont:       rph,
		ffsManager: m,
	}
	return fha, nil
}

func (fha *ffsHTTPAuth) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	authFFS := r.Header.Get("x-ipfs-ffs-auth")
	_, err := fha.ffsManager.GetByAuthToken(authFFS)
	if authFFS == "" || err == manager.ErrAuthTokenNotFound {
		http.Error(rw, "FFS token required", http.StatusUnauthorized)
		return
	}
	fha.cont.ServeHTTP(rw, r)
}

func (fha *ffsHTTPAuth) IsIPFSRequest(r *http.Request) bool {
	return len(r.Header.Get("x-ipfs-ffs-auth")) > 0
}

func createProxyServer(wrappedGRPCServer *grpcweb.WrappedGrpcServer, fha *ffsHTTPAuth, webProxyAddr string) *http.Server {
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if fha.IsIPFSRequest(r) {
			fha.ServeHTTP(w, r)
		} else if wrappedGRPCServer.IsGrpcWebRequest(r) ||
			wrappedGRPCServer.IsAcceptableGrpcCorsRequest(r) ||
			wrappedGRPCServer.IsGrpcWebSocketRequest(r) {
			wrappedGRPCServer.ServeHTTP(w, r)
		} else {
			http.NotFound(w, r)
		}
	})
	webProxy := &http.Server{
		Addr:    webProxyAddr,
		Handler: handler,
	}
	return webProxy
}

func wrapGRPCServer(grpcServer *grpc.Server) *grpcweb.WrappedGrpcServer {
	wrappedServer := grpcweb.WrapServer(
		grpcServer,
		grpcweb.WithOriginFunc(func(origin string) bool {
			return true
		}),
		grpcweb.WithAllowedRequestHeaders([]string{"*"}),
		grpcweb.WithWebsockets(true),
		grpcweb.WithWebsocketOriginFunc(func(req *http.Request) bool {
			return true
		}),
	)

	return wrappedServer
}

func startGRPCServices(server *grpc.Server, webProxy *http.Server, s *Server, hostNetwork string, hostAddress ma.Multiaddr) error {
	userService := user.New(s.ffsManager, s.wm, s.hs)
	adminService := admin.New(s.ffsManager, s.sched, s.wm, s.dm, s.mi, s.ai)

	hostAddr, err := util.TCPAddrFromMultiAddr(hostAddress)
	if err != nil {
		return fmt.Errorf("parsing host multiaddr: %s", err)
	}
	listener, err := net.Listen(hostNetwork, hostAddr)
	if err != nil {
		return fmt.Errorf("listening to grpc: %s", err)
	}
	go func() {
		userPb.RegisterUserServiceServer(server, userService)
		adminPb.RegisterAdminServiceServer(server, adminService)
		if err := server.Serve(listener); err != nil {
			log.Errorf("serving grpc endpoint: %s", err)
		}
	}()

	go func() {
		if err := webProxy.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Errorf("starting proxy: %v", err)
		}
	}()
	return nil
}

func startIndexHTTPServer(s *Server, addr string) *http.Server {
	mux := http.NewServeMux()
	mux.HandleFunc("/index/ask", func(w http.ResponseWriter, r *http.Request) {
		index := s.ai.Get()
		buf, err := json.MarshalIndent(index, "", "  ")
		if err != nil {
			http.Error(w, "Error", http.StatusInternalServerError)
			return
		}
		if _, err := w.Write(buf); err != nil {
			log.Errorf("writing response body: %s", err)
		}
	})
	mux.HandleFunc("/index/miners", func(w http.ResponseWriter, r *http.Request) {
		index := s.mi.Get()
		buf, err := json.MarshalIndent(index, "", "  ")
		if err != nil {
			http.Error(w, "Error", http.StatusInternalServerError)
			return
		}
		if _, err := w.Write(buf); err != nil {
			log.Errorf("writing response body: %s", err)
		}
	})
	mux.HandleFunc("/index/faults", func(w http.ResponseWriter, r *http.Request) {
		index := s.fi.Get()
		buf, err := json.MarshalIndent(index, "", "  ")
		if err != nil {
			http.Error(w, "Error", http.StatusInternalServerError)
			return
		}
		if _, err := w.Write(buf); err != nil {
			log.Errorf("writing response body: %s", err)
		}
	})

	srv := &http.Server{Addr: addr, Handler: mux}
	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("serving index http: %v", err)
		}
	}()
	return srv
}

// Close shuts down the server.
func (s *Server) Close() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	if err := s.indexServer.Shutdown(ctx); err != nil {
		log.Errorf("closing down index server: %s", err)
	}

	log.Info("closing gRPC endpoints...")
	ctx, cancel = context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	if err := s.webProxy.Shutdown(ctx); err != nil {
		log.Errorf("closing down proxy: %s", err)
	}
	stopped := make(chan struct{})
	go func() {
		s.grpcServer.GracefulStop()
		close(stopped)
	}()
	t := time.NewTimer(10 * time.Second)
	select {
	case <-t.C:
		s.grpcServer.Stop()
	case <-stopped:
		t.Stop()
	}
	log.Info("gRPC endpoints closed")

	if err := s.ffsManager.Close(); err != nil {
		log.Errorf("closing ffs manager: %s", err)
	}
	if err := s.sched.Close(); err != nil {
		log.Errorf("closing ffs scheduler: %s", err)
	}
	if err := s.l.Close(); err != nil {
		log.Errorf("closing joblogger: %s", err)
	}
	if err := s.dm.Close(); err != nil {
		log.Errorf("closing deal module: %s", err)
	}
	if err := s.rm.Close(); err != nil {
		log.Errorf("closing reputation module: %s", err)
	}
	if err := s.ai.Close(); err != nil {
		log.Errorf("closing ask index: %s", err)
	}
	if err := s.mi.Close(); err != nil {
		log.Errorf("closing miner index: %s", err)
	}
	if err := s.fi.Close(); err != nil {
		log.Errorf("closing faults index: %s", err)
	}

	log.Info("closing datastore...")
	if err := s.ds.Close(); err != nil {
		log.Errorf("closing datastore: %s", err)
	}
	log.Info("datastore closed")

	if err := s.gateway.Stop(); err != nil {
		log.Errorf("closing gateway: %s", err)
	}
	if err := s.mm.Close(); err != nil {
		log.Errorf("closing maxmind: %s", err)
	}
}

func createDatastore(conf Config, longTimeout bool) (datastore.TxnDatastore, error) {
	var ds datastore.TxnDatastore
	var err error

	if conf.MongoURI != "" {
		log.Info("Opening Mongo database...")
		mongoCtx, cancel := context.WithTimeout(context.Background(), time.Second*10)
		defer cancel()
		if conf.MongoDB == "" {
			return nil, fmt.Errorf("mongo database name is empty")
		}
		var opts []mongods.Option
		if longTimeout {
			opts = []mongods.Option{mongods.WithOpTimeout(time.Hour), mongods.WithTxnTimeout(time.Hour)}
		}
		ds, err = mongods.New(mongoCtx, conf.MongoURI, conf.MongoDB, opts...)
		if err != nil {
			return nil, fmt.Errorf("opening mongo datastore: %s", err)
		}
	} else {
		log.Info("Opening badger database...")
		path := filepath.Join(conf.RepoPath, datastoreFolderName)
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			return nil, fmt.Errorf("creating repo folder: %s", err)
		}
		opts := &badger.DefaultOptions
		ds, err = badger.NewDatastore(path, opts)
		if err != nil {
			return nil, fmt.Errorf("opening badger datastore: %s", err)
		}
	}

	return measure.New("powergate.datastore", ds), nil
}

func getMinerSelector(conf Config, rm *reputation.Module, ai *ask.Runner, cb lotus.ClientBuilder) (ffs.MinerSelector, error) {
	if conf.Devnet {
		return reptop.New(cb, rm, ai), nil
	}
	var ms ffs.MinerSelector
	var err error

	switch conf.MinerSelector {
	case "reputation":
		ms = reptop.New(cb, rm, ai)
	case "sr2":
		ms, err = sr2.New(conf.MinerSelectorParams, cb)
		if err != nil {
			return nil, fmt.Errorf("creating sr2 miner selector: %s", err)
		}
	default:
		return nil, fmt.Errorf("unknown miner selector: %s", conf.MinerSelector)
	}

	return ms, nil
}

func evaluateMasterAddr(conf Config, c *api.FullNodeStruct) (address.Address, error) {
	var res address.Address
	if conf.Devnet {
		// Wait for the devnet to bootstrap completely and generate at least 1 block.
		time.Sleep(time.Second * 6)
		res, err := c.WalletDefaultAddress(context.Background())
		if err != nil {
			return address.Address{}, fmt.Errorf("getting default wallet addr as masteraddr: %s", err)
		}
		return res, nil
	}
	res, err := address.NewFromString(conf.LotusMasterAddr)
	if err != nil {
		return address.Address{}, fmt.Errorf("parsing masteraddr: %s", err)
	}
	return res, nil
}
func adminAuth(conf Config) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		if conf.FFSAdminToken == "" {
			return handler(ctx, req)
		}

		adminServicePrefix := "/powergate.admin.v1.AdminService"

		method, _ := grpc.Method(ctx)

		if !strings.HasPrefix(method, adminServicePrefix) {
			return handler(ctx, req)
		}

		adminToken := metautils.ExtractIncoming(ctx).Get("X-pow-admin-token")
		if adminToken != conf.FFSAdminToken {
			return nil, status.Error(codes.PermissionDenied, "Method requires admin permission")
		}
		return handler(ctx, req)
	}
}

func nonCompliantAPIsInterceptor(nonCompliantAPIs []string) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		method, _ := grpc.Method(ctx)
		for _, nonCompliantAPI := range nonCompliantAPIs {
			if method == nonCompliantAPI {
				return nil, status.Error(codes.PermissionDenied, "method disabled by powergate administrators")
			}
		}
		return handler(ctx, req)
	}
}

func runMigrations(conf Config) error {
	log.Infof("Ensuring migrations...")
	ds, err := createDatastore(conf, true)
	if err != nil {
		return fmt.Errorf("creating migration datastore: %s", err)
	}
	defer func() {
		if err := ds.Close(); err != nil {
			log.Errorf("closing migration datastore: %s", err)
		}
	}()

	m := migration.New(ds, Migrations)
	if err := m.Ensure(); err != nil {
		return fmt.Errorf("running migrations: %s", err)
	}
	log.Infof("Migrations ensured")

	return nil
}

'''
'''--- Filecoin/powergate/api/server/user/data.go ---
package user

import (
	"context"
	"fmt"
	"io"
	"sort"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	su "github.com/textileio/powergate/v2/api/server/util"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Stage allows to stage-pin a stream of data in Hot-Storage in preparation for pushing a storage configuration.
func (s *Service) Stage(srv userPb.UserService_StageServer) error {
	// check that an API instance exists so not just anyone can add data to the hot layer
	fapi, err := s.getInstanceByToken(srv.Context())
	if err != nil {
		return err
	}

	reader, writer := io.Pipe()
	defer func() {
		if err := reader.Close(); err != nil {
			log.Errorf("closing reader: %s", err)
		}
	}()

	go receiveFile(srv, writer)

	c, err := s.hot.Stage(srv.Context(), fapi.ID(), reader)
	if err != nil {
		return fmt.Errorf("adding data to hot storage: %s", err)
	}

	return srv.SendAndClose(&userPb.StageResponse{Cid: util.CidToString(c)})
}

// StageCid allows to stage-pin a cid in Hot-Storage in preparation for pushing a storage configuration.
func (s *Service) StageCid(ctx context.Context, req *userPb.StageCidRequest) (*userPb.StageCidResponse, error) {
	// check that an API instance exists so not just anyone can add data to the hot layer
	fapi, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, fmt.Errorf("parsing cid: %s", err)
	}

	err = s.hot.StageCid(ctx, fapi.ID(), c)
	if err != nil {
		return nil, fmt.Errorf("stage pinning cid in hot-storage: %s", err)
	}

	return &userPb.StageCidResponse{}, nil
}

// ReplaceData calls ffs.Replace.
func (s *Service) ReplaceData(ctx context.Context, req *userPb.ReplaceDataRequest) (*userPb.ReplaceDataResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	c1, err := util.CidFromString(req.Cid1)
	if err != nil {
		return nil, err
	}
	c2, err := util.CidFromString(req.Cid2)
	if err != nil {
		return nil, err
	}

	jid, err := i.Replace(c1, c2)
	if err != nil {
		return nil, err
	}

	return &userPb.ReplaceDataResponse{JobId: jid.String()}, nil
}

// Get gets the data for a stored Cid.
func (s *Service) Get(req *userPb.GetRequest, srv userPb.UserService_GetServer) error {
	i, err := s.getInstanceByToken(srv.Context())
	if err != nil {
		return err
	}
	c, err := util.CidFromString(req.GetCid())
	if err != nil {
		return err
	}
	r, err := i.Get(srv.Context(), c)
	if err != nil {
		return err
	}

	buffer := make([]byte, 1024*32)
	for {
		bytesRead, err := r.Read(buffer)
		if err != nil && err != io.EOF {
			return err
		}
		if sendErr := srv.Send(&userPb.GetResponse{Chunk: buffer[:bytesRead]}); sendErr != nil {
			return sendErr
		}
		if err == io.EOF {
			return nil
		}
	}
}

// WatchLogs returns a stream of human-readable messages related to executions of a Cid.
// The listener is automatically unsubscribed when the client closes the stream.
func (s *Service) WatchLogs(req *userPb.WatchLogsRequest, srv userPb.UserService_WatchLogsServer) error {
	i, err := s.getInstanceByToken(srv.Context())
	if err != nil {
		return err
	}

	opts := []api.GetLogsOption{api.WithHistory(req.History)}
	if req.JobId != ffs.EmptyJobID.String() {
		opts = append(opts, api.WithJidFilter(ffs.JobID(req.JobId)))
	}

	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return err
	}
	ch := make(chan ffs.LogEntry, 100)
	go func() {
		err = i.WatchLogs(srv.Context(), ch, c, opts...)
		close(ch)
	}()
	for l := range ch {
		reply := &userPb.WatchLogsResponse{
			LogEntry: &userPb.LogEntry{
				Cid:     util.CidToString(c),
				JobId:   l.Jid.String(),
				Time:    l.Timestamp.Unix(),
				Message: l.Msg,
			},
		}
		if err := srv.Send(reply); err != nil {
			return err
		}
	}
	if err != nil {
		return err
	}

	return nil
}

// CidSummary gives a summary of the storage and jobs state of the specified cid.
func (s *Service) CidSummary(ctx context.Context, req *userPb.CidSummaryRequest) (*userPb.CidSummaryResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	cids, err := su.FromProtoCids(req.Cids)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cids: %v", err)
	}

	storageConfigs, err := i.GetStorageConfigs(cids...)
	if err != nil {
		code := codes.Internal
		if err == api.ErrNotFound {
			code = codes.NotFound
		}
		return nil, status.Errorf(code, "getting storage configs: %v", err)
	}

	type source struct {
		cid            string
		currentStorage *ffs.StorageInfo
		queuedJobs     []ffs.StorageJob
		executingJob   *ffs.StorageJob
	}

	var sources []source

	for cid := range storageConfigs {
		d := source{cid: cid.String()}

		info, err := i.StorageInfo(cid)
		if err != nil && err != api.ErrNotFound {
			return nil, status.Errorf(codes.Internal, "getting storage info: %v", err)
		} else if err == nil {
			d.currentStorage = &info
		}

		queuedJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Queued, CidFilter: cid})
		if err != nil {
			return nil, status.Errorf(codes.Internal, "listing queued storage jobs: %v", err)
		}
		d.queuedJobs = queuedJobs

		executingJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Executing, CidFilter: cid})
		if err != nil {
			return nil, status.Errorf(codes.Internal, "listing executing storage jobs: %v", err)
		}
		if len(executingJobs) == 1 {
			// There is exactly one job in the slice because we specified a cid
			// and there can be only one executing job per cid at a time.
			d.executingJob = &executingJobs[0]
		} else if len(executingJobs) > 1 {
			msg := fmt.Sprintf("received %d executing jobs when there should be 1", len(executingJobs))
			log.Error(msg)
			return nil, status.Error(codes.Internal, msg)
		}

		sources = append(sources, d)
	}

	extractJobTime := func(d source) int64 {
		var time int64
		if d.executingJob != nil {
			time = d.executingJob.CreatedAt
		}
		for _, job := range d.queuedJobs {
			if job.CreatedAt > time {
				time = job.CreatedAt
			}
		}
		return time
	}

	extractCurrentStorageTime := func(d source) int64 {
		var time int64
		if d.currentStorage != nil {
			return d.currentStorage.Created.Unix()
		}
		return time
	}

	sort.Slice(sources, func(a, b int) bool {
		jobTimeA := extractJobTime(sources[a])
		jobTimeB := extractJobTime(sources[b])
		if jobTimeA > jobTimeB {
			return true
		}
		if jobTimeA < jobTimeB {
			return false
		}
		currentStorageTimeA := extractCurrentStorageTime(sources[a])
		currentStorageTimeB := extractCurrentStorageTime(sources[b])
		return currentStorageTimeA > currentStorageTimeB
	})

	summaries := make([]*userPb.CidSummary, len(sources))
	for i, source := range sources {
		summaries[i] = &userPb.CidSummary{
			Cid:    source.cid,
			Stored: source.currentStorage != nil,
		}
		if source.executingJob != nil {
			summaries[i].ExecutingJob = source.executingJob.ID.String()
		}
		if len(source.queuedJobs) > 0 {
			queuedIds := make([]string, len(source.queuedJobs))
			for j, job := range source.queuedJobs {
				queuedIds[j] = job.ID.String()
			}
			summaries[i].QueuedJobs = queuedIds
		}
	}

	return &userPb.CidSummaryResponse{CidSummary: summaries}, nil
}

// CidInfo returns information about cids managed by the FFS instance.
func (s *Service) CidInfo(ctx context.Context, req *userPb.CidInfoRequest) (*userPb.CidInfoResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	cid, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
	}

	storageConfigs, err := i.GetStorageConfigs(cid)
	if err != nil {
		code := codes.Internal
		if err == api.ErrNotFound {
			code = codes.NotFound
		}
		return nil, status.Errorf(code, "getting storage configs: %v", err)
	}
	config, ok := storageConfigs[cid]
	if !ok {
		log.Warnf("didn't find storage config for cid %s", cid.String())
		return nil, status.Errorf(codes.Internal, "didn't find storage config for cid %s", cid.String())
	}

	rpcConfig := toRPCStorageConfig(config)
	cidInfo := &userPb.CidInfo{
		Cid:                       cid.String(),
		LatestPushedStorageConfig: rpcConfig,
	}
	info, err := i.StorageInfo(cid)
	if err != nil && err != api.ErrNotFound {
		return nil, status.Errorf(codes.Internal, "getting storage info: %v", err)
	} else if err == nil {
		cidInfo.CurrentStorageInfo = su.ToRPCStorageInfo(info)
	}
	queuedJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Queued, CidFilter: cid})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing queued jobs: %v", err)
	}
	rpcQueudJobs := make([]*userPb.StorageJob, len(queuedJobs))
	for i, job := range queuedJobs {
		rpcJob, err := su.ToRPCJob(job)
		if err != nil {
			return nil, status.Errorf(codes.Internal, "converting job to rpc job: %v", err)
		}
		rpcQueudJobs[i] = rpcJob
	}
	cidInfo.QueuedStorageJobs = rpcQueudJobs
	executingJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Executing, CidFilter: cid})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing executing jobs: %v", err)
	}
	if len(executingJobs) == 1 {
		// There is exactly one job in the slice because we specified a cid
		// and there can be only one executing job per cid at a time.
		rpcJob, err := su.ToRPCJob(executingJobs[0])
		if err != nil {
			return nil, status.Errorf(codes.Internal, "converting job to rpc job: %v", err)
		}
		cidInfo.ExecutingStorageJob = rpcJob
	} else if len(executingJobs) > 1 {
		msg := fmt.Sprintf("received %d executing jobs when there should be 1", len(executingJobs))
		log.Error(msg)
		return nil, status.Error(codes.Internal, msg)
	}
	return &userPb.CidInfoResponse{CidInfo: cidInfo}, nil
}

func receiveFile(srv userPb.UserService_StageServer, writer *io.PipeWriter) {
	for {
		req, err := srv.Recv()
		if err == io.EOF {
			_ = writer.Close()
			break
		} else if err != nil {
			_ = writer.CloseWithError(err)
			break
		}
		_, writeErr := writer.Write(req.GetChunk())
		if writeErr != nil {
			if err := writer.CloseWithError(writeErr); err != nil {
				log.Errorf("closing with error: %s", err)
			}
		}
	}
}

'''
'''--- Filecoin/powergate/api/server/user/deals.go ---
package user

import (
	"context"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/api/server/util"
)

// StorageDealRecords calls ffs.ListStorageDealRecords.
func (s *Service) StorageDealRecords(ctx context.Context, req *userPb.StorageDealRecordsRequest) (*userPb.StorageDealRecordsResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	records, err := i.StorageDealRecords(buildListDealRecordsOptions(req.Config)...)
	if err != nil {
		return nil, err
	}
	return &userPb.StorageDealRecordsResponse{Records: util.ToRPCStorageDealRecords(records)}, nil
}

// RetrievalDealRecords calls ffs.ListRetrievalDealRecords.
func (s *Service) RetrievalDealRecords(ctx context.Context, req *userPb.RetrievalDealRecordsRequest) (*userPb.RetrievalDealRecordsResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	records, err := i.RetrievalDealRecords(buildListDealRecordsOptions(req.Config)...)
	if err != nil {
		return nil, err
	}
	return &userPb.RetrievalDealRecordsResponse{Records: util.ToRPCRetrievalDealRecords(records)}, nil
}

'''
'''--- Filecoin/powergate/api/server/user/service.go ---
package user

import (
	"context"

	"github.com/grpc-ecosystem/go-grpc-middleware/util/metautils"
	logger "github.com/ipfs/go-log/v2"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/buildinfo"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/ffs/manager"
	"github.com/textileio/powergate/v2/wallet"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	log = logger.Logger("user-service")
)

// Service implements the Powergate API.
type Service struct {
	userPb.UnimplementedUserServiceServer
	m   *manager.Manager
	w   wallet.Module
	hot ffs.HotStorage
}

// New creates a new powergate Service.
func New(m *manager.Manager, w wallet.Module, hot ffs.HotStorage) *Service {
	return &Service{
		m:   m,
		w:   w,
		hot: hot,
	}
}

// BuildInfo returns information about the powergate build.
func (s *Service) BuildInfo(ctx context.Context, req *userPb.BuildInfoRequest) (*userPb.BuildInfoResponse, error) {
	return &userPb.BuildInfoResponse{
		BuildDate:  buildinfo.BuildDate,
		GitBranch:  buildinfo.GitBranch,
		GitCommit:  buildinfo.GitCommit,
		GitState:   buildinfo.GitState,
		GitSummary: buildinfo.GitSummary,
		Version:    buildinfo.Version,
	}, nil
}

// UserIdentifier returns the API instance id.
func (s *Service) UserIdentifier(ctx context.Context, req *userPb.UserIdentifierRequest) (*userPb.UserIdentifierResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	id := i.ID()
	return &userPb.UserIdentifierResponse{Id: id.String()}, nil
}

func (s *Service) getInstanceByToken(ctx context.Context) (*api.API, error) {
	token := metautils.ExtractIncoming(ctx).Get("X-ffs-Token")
	if token == "" {
		return nil, status.Errorf(codes.PermissionDenied, "auth token can't be empty")
	}
	i, err := s.m.GetByAuthToken(token)
	if err != nil {
		code := codes.Internal
		if err == manager.ErrAuthTokenNotFound {
			code = codes.PermissionDenied
		}
		return nil, status.Errorf(code, "getting instance: %v", err)
	}
	return i, nil
}

'''
'''--- Filecoin/powergate/api/server/user/storageconfig.go ---
package user

import (
	"context"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/util"
)

// DefaultStorageConfig calls ffs.DefaultStorageConfig.
func (s *Service) DefaultStorageConfig(ctx context.Context, req *userPb.DefaultStorageConfigRequest) (*userPb.DefaultStorageConfigResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	conf := i.DefaultStorageConfig()
	return &userPb.DefaultStorageConfigResponse{
		DefaultStorageConfig: toRPCStorageConfig(conf),
	}, nil
}

// SetDefaultStorageConfig sets a new config to be used by default.
func (s *Service) SetDefaultStorageConfig(ctx context.Context, req *userPb.SetDefaultStorageConfigRequest) (*userPb.SetDefaultStorageConfigResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	defaultConfig := ffs.StorageConfig{
		Repairable: req.Config.Repairable,
		Hot:        fromRPCHotConfig(req.Config.Hot),
		Cold:       fromRPCColdConfig(req.Config.Cold),
	}
	if err := i.SetDefaultStorageConfig(defaultConfig); err != nil {
		return nil, err
	}
	return &userPb.SetDefaultStorageConfigResponse{}, nil
}

// ApplyStorageConfig applies the provided cid storage config.
func (s *Service) ApplyStorageConfig(ctx context.Context, req *userPb.ApplyStorageConfigRequest) (*userPb.ApplyStorageConfigResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, err
	}

	options := []api.PushStorageConfigOption{}

	if req.HasConfig {
		config := ffs.StorageConfig{
			Repairable: req.Config.Repairable,
			Hot:        fromRPCHotConfig(req.Config.Hot),
			Cold:       fromRPCColdConfig(req.Config.Cold),
		}
		options = append(options, api.WithStorageConfig(config))
	}

	if req.HasOverrideConfig {
		options = append(options, api.WithOverride(req.OverrideConfig))
	}

	if len(req.ImportDealIds) > 0 {
		options = append(options, api.WithDealImport(req.ImportDealIds))
	}
	if req.NoExec {
		options = append(options, api.WithNoExec(true))
	}

	jid, err := i.PushStorageConfig(c, options...)
	if err != nil {
		return nil, err
	}

	return &userPb.ApplyStorageConfigResponse{
		JobId: jid.String(),
	}, nil
}

// Remove calls ffs.Remove.
func (s *Service) Remove(ctx context.Context, req *userPb.RemoveRequest) (*userPb.RemoveResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, err
	}

	if err := i.Remove(c); err != nil {
		return nil, err
	}

	return &userPb.RemoveResponse{}, nil
}

'''
'''--- Filecoin/powergate/api/server/user/storageinfo.go ---
package user

import (
	"context"

	"github.com/ipfs/go-cid"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	su "github.com/textileio/powergate/v2/api/server/util"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// StorageInfo returns the information about a stored Cid. If no information is available,
// since the Cid was never stored, it returns an error with codes.NotFound.
func (s *Service) StorageInfo(ctx context.Context, req *userPb.StorageInfoRequest) (*userPb.StorageInfoResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, status.Errorf(codes.PermissionDenied, "getting instance: %v", err)
	}
	cid, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
	}
	info, err := i.StorageInfo(cid)
	if err == api.ErrNotFound {
		return nil, status.Errorf(codes.NotFound, "getting storage info: %v", err)
	}
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting storage info: %v", err)
	}
	pbInfo := su.ToRPCStorageInfo(info)
	return &userPb.StorageInfoResponse{StorageInfo: pbInfo}, nil
}

// ListStorageInfo returns a list of information about all stored cids, filtered by cids if provided.
func (s *Service) ListStorageInfo(ctx context.Context, req *userPb.ListStorageInfoRequest) (*userPb.ListStorageInfoResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, status.Errorf(codes.PermissionDenied, "getting instance: %v", err)
	}
	cids := make([]cid.Cid, len(req.Cids))
	for i, s := range req.Cids {
		c, err := util.CidFromString(s)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
		}
		cids[i] = c
	}
	infos, err := i.ListStorageInfo(cids...)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "querying storage info: %v", err)
	}
	res := make([]*userPb.StorageInfo, len(infos))
	for i, info := range infos {
		res[i] = su.ToRPCStorageInfo(info)
	}
	return &userPb.ListStorageInfoResponse{StorageInfo: res}, nil
}

'''
'''--- Filecoin/powergate/api/server/user/storagejobs.go ---
package user

import (
	"context"

	"github.com/ipfs/go-cid"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	su "github.com/textileio/powergate/v2/api/server/util"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// StorageJob calls API.GetStorageJob.
func (s *Service) StorageJob(ctx context.Context, req *userPb.StorageJobRequest) (*userPb.StorageJobResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	jid := ffs.JobID(req.JobId)
	job, err := i.GetStorageJob(jid)
	if err != nil {
		return nil, err
	}
	rpcJob, err := su.ToRPCJob(job)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "building job response: %v", err.Error())
	}
	return &userPb.StorageJobResponse{
		StorageJob: rpcJob,
	}, nil
}

// StorageConfigForJob returns the StorageConfig associated with the job id.
func (s *Service) StorageConfigForJob(ctx context.Context, req *userPb.StorageConfigForJobRequest) (*userPb.StorageConfigForJobResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	sc, err := i.StorageConfigForJob(ffs.JobID(req.JobId))
	if err != nil {
		code := codes.Internal
		if err == api.ErrNotFound {
			code = codes.NotFound
		}
		return nil, status.Errorf(code, "getting storage config for job: %v", err)
	}
	res := toRPCStorageConfig(sc)
	return &userPb.StorageConfigForJobResponse{StorageConfig: res}, nil
}

// ListStorageJobs lists StorageJobs according to the provided request parameters.
func (s *Service) ListStorageJobs(ctx context.Context, req *userPb.ListStorageJobsRequest) (*userPb.ListStorageJobsResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	var selector api.ListStorageJobsSelect
	switch req.Selector {
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_ALL:
		selector = api.All
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_EXECUTING:
		selector = api.Executing
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_FINAL:
		selector = api.Final
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_QUEUED:
		selector = api.Queued
	case userPb.StorageJobsSelector_STORAGE_JOBS_SELECTOR_UNSPECIFIED:
		selector = api.All
	}
	conf := api.ListStorageJobsConfig{
		Limit:         req.Limit,
		Ascending:     req.Ascending,
		NextPageToken: req.NextPageToken,
		Select:        selector,
	}
	if req.CidFilter != "" {
		c, err := cid.Decode(req.CidFilter)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "parsing cid filter: %v", err)
		}
		conf.CidFilter = c
	}
	jobs, more, next, err := i.ListStorageJobs(conf)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing storage jobs: %v", err)
	}
	protoJobs, err := su.ToProtoStorageJobs(jobs)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "converting jobs to protos: %v", err)
	}
	res := &userPb.ListStorageJobsResponse{
		StorageJobs:   protoJobs,
		More:          more,
		NextPageToken: next,
	}
	return res, nil
}

// StorageJobsSummary returns a summary of all storage jobs.
func (s *Service) StorageJobsSummary(ctx context.Context, req *userPb.StorageJobsSummaryRequest) (*userPb.StorageJobsSummaryResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	c, err := util.CidFromString(req.Cid)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing cid: %v", err)
	}

	queuedJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Queued, CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing queued jobs: %v", err)
	}
	executingJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Executing, CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing executing jobs: %v", err)
	}
	finalJobs, _, _, err := i.ListStorageJobs(api.ListStorageJobsConfig{Select: api.Final, CidFilter: c})
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing final jobs: %v", err)
	}

	var queuedJobIDs []string
	for _, job := range queuedJobs {
		queuedJobIDs = append(queuedJobIDs, job.ID.String())
	}
	var executingJobIDs []string
	for _, job := range executingJobs {
		executingJobIDs = append(executingJobIDs, job.ID.String())
	}
	var finalJobIDs []string
	for _, job := range finalJobs {
		finalJobIDs = append(finalJobIDs, job.ID.String())
	}

	return &userPb.StorageJobsSummaryResponse{
		QueuedStorageJobs:    queuedJobIDs,
		ExecutingStorageJobs: executingJobIDs,
		FinalStorageJobs:     finalJobIDs,
	}, nil
}

// WatchStorageJobs calls API.WatchJobs.
func (s *Service) WatchStorageJobs(req *userPb.WatchStorageJobsRequest, srv userPb.UserService_WatchStorageJobsServer) error {
	i, err := s.getInstanceByToken(srv.Context())
	if err != nil {
		return err
	}

	jids := make([]ffs.JobID, len(req.JobIds))
	for i, jid := range req.JobIds {
		jids[i] = ffs.JobID(jid)
	}

	ch := make(chan ffs.StorageJob, 100)
	go func() {
		err = i.WatchJobs(srv.Context(), ch, jids...)
		close(ch)
	}()
	for job := range ch {
		rpcJob, err := su.ToRPCJob(job)
		if err != nil {
			return err
		}
		reply := &userPb.WatchStorageJobsResponse{
			StorageJob: rpcJob,
		}
		if err := srv.Send(reply); err != nil {
			return err
		}
	}
	if err != nil {
		return err
	}
	return nil
}

// CancelStorageJob calls API.CancelJob.
func (s *Service) CancelStorageJob(ctx context.Context, req *userPb.CancelStorageJobRequest) (*userPb.CancelStorageJobResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	jid := ffs.JobID(req.JobId)
	if err := i.CancelJob(jid); err != nil {
		return nil, err
	}
	return &userPb.CancelStorageJobResponse{}, nil
}

'''
'''--- Filecoin/powergate/api/server/user/util.go ---
package user

import (
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
)

func toRPCStorageConfig(config ffs.StorageConfig) *userPb.StorageConfig {
	return &userPb.StorageConfig{
		Repairable: config.Repairable,
		Hot:        toRPCHotConfig(config.Hot),
		Cold:       toRPCColdConfig(config.Cold),
	}
}

func toRPCHotConfig(config ffs.HotConfig) *userPb.HotConfig {
	return &userPb.HotConfig{
		Enabled:          config.Enabled,
		AllowUnfreeze:    config.AllowUnfreeze,
		UnfreezeMaxPrice: config.UnfreezeMaxPrice,
		Ipfs: &userPb.IpfsConfig{
			AddTimeout: int64(config.Ipfs.AddTimeout),
		},
	}
}

func toRPCColdConfig(config ffs.ColdConfig) *userPb.ColdConfig {
	return &userPb.ColdConfig{
		Enabled: config.Enabled,
		Filecoin: &userPb.FilConfig{
			ReplicationFactor: int64(config.Filecoin.RepFactor),
			DealMinDuration:   config.Filecoin.DealMinDuration,
			ExcludedMiners:    config.Filecoin.ExcludedMiners,
			TrustedMiners:     config.Filecoin.TrustedMiners,
			CountryCodes:      config.Filecoin.CountryCodes,
			Renew: &userPb.FilRenew{
				Enabled:   config.Filecoin.Renew.Enabled,
				Threshold: int64(config.Filecoin.Renew.Threshold),
			},
			Address:         config.Filecoin.Addr,
			MaxPrice:        config.Filecoin.MaxPrice,
			FastRetrieval:   config.Filecoin.FastRetrieval,
			DealStartOffset: config.Filecoin.DealStartOffset,
			VerifiedDeal:    config.Filecoin.VerifiedDeal,
		},
	}
}

func fromRPCHotConfig(config *userPb.HotConfig) ffs.HotConfig {
	res := ffs.HotConfig{}
	if config != nil {
		res.Enabled = config.Enabled
		res.AllowUnfreeze = config.AllowUnfreeze
		res.UnfreezeMaxPrice = config.UnfreezeMaxPrice
		if config.Ipfs != nil {
			ipfs := ffs.IpfsConfig{
				AddTimeout: int(config.Ipfs.AddTimeout),
			}
			res.Ipfs = ipfs
		}
	}
	return res
}

func fromRPCColdConfig(config *userPb.ColdConfig) ffs.ColdConfig {
	res := ffs.ColdConfig{}
	if config != nil {
		res.Enabled = config.Enabled
		if config.Filecoin != nil {
			filecoin := ffs.FilConfig{
				RepFactor:       int(config.Filecoin.ReplicationFactor),
				DealMinDuration: config.Filecoin.DealMinDuration,
				ExcludedMiners:  config.Filecoin.ExcludedMiners,
				CountryCodes:    config.Filecoin.CountryCodes,
				TrustedMiners:   config.Filecoin.TrustedMiners,
				Addr:            config.Filecoin.Address,
				MaxPrice:        config.Filecoin.MaxPrice,
				FastRetrieval:   config.Filecoin.FastRetrieval,
				DealStartOffset: config.Filecoin.DealStartOffset,
				VerifiedDeal:    config.Filecoin.VerifiedDeal,
			}
			if config.Filecoin.Renew != nil {
				renew := ffs.FilRenew{
					Enabled:   config.Filecoin.Renew.Enabled,
					Threshold: int(config.Filecoin.Renew.Threshold),
				}
				filecoin.Renew = renew
			}
			res.Filecoin = filecoin
		}
	}
	return res
}

func buildListDealRecordsOptions(conf *userPb.DealRecordsConfig) []deals.DealRecordsOption {
	var opts []deals.DealRecordsOption
	if conf != nil {
		opts = []deals.DealRecordsOption{
			deals.WithAscending(conf.Ascending),
			deals.WithDataCids(conf.DataCids...),
			deals.WithFromAddrs(conf.FromAddrs...),
			deals.WithIncludePending(conf.IncludePending),
			deals.WithIncludeFinal(conf.IncludeFinal),
			deals.WithIncludeFailed(conf.IncludeFailed),
		}
	}
	return opts
}

'''
'''--- Filecoin/powergate/api/server/user/wallet.go ---
package user

import (
	"context"
	"fmt"
	"math/big"

	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/wallet"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Balance returns the balance for an address.
func (s *Service) Balance(ctx context.Context, req *userPb.BalanceRequest) (*userPb.BalanceResponse, error) {
	bal, err := s.w.Balance(ctx, req.Address)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "getting balance: %v", err)
	}
	return &userPb.BalanceResponse{Balance: bal.String()}, nil
}

// NewAddress calls ffs.NewAddr.
func (s *Service) NewAddress(ctx context.Context, req *userPb.NewAddressRequest) (*userPb.NewAddressResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}

	var opts []api.NewAddressOption
	if req.AddressType != "" {
		opts = append(opts, api.WithAddressType(req.AddressType))
	}
	if req.MakeDefault {
		opts = append(opts, api.WithMakeDefault(req.MakeDefault))
	}

	addr, err := i.NewAddr(ctx, req.Name, opts...)
	if err != nil {
		return nil, err
	}
	return &userPb.NewAddressResponse{Address: addr}, nil
}

// Addresses calls ffs.Addrs.
func (s *Service) Addresses(ctx context.Context, req *userPb.AddressesRequest) (*userPb.AddressesResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	addrs := i.Addrs()
	res := make([]*userPb.AddrInfo, len(addrs))
	for i, addr := range addrs {
		bal, err := s.w.Balance(ctx, addr.Addr)
		if err != nil {
			return nil, status.Errorf(codes.Internal, "getting address balance: %v", err)
		}
		ai := &userPb.AddrInfo{
			Name:    addr.Name,
			Address: addr.Addr,
			Type:    addr.Type,
			Balance: bal.String(),
		}
		vc, err := s.w.GetVerifiedClientInfo(ctx, addr.Addr)
		if err != nil && err != wallet.ErrNoVerifiedClient {
			return nil, status.Errorf(codes.Internal, "getting verified-client wallet address information: %s", err)
		}
		if err == nil {
			ai.VerifiedClientInfo = &userPb.AddrInfo_VerifiedClientInfo{
				RemainingDatacapBytes: vc.RemainingDatacapBytes.String(),
			}
		}

		res[i] = ai
	}
	return &userPb.AddressesResponse{Addresses: res}, nil
}

// SendFil sends fil from a managed address to any other address.
func (s *Service) SendFil(ctx context.Context, req *userPb.SendFilRequest) (*userPb.SendFilResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	amt, ok := new(big.Int).SetString(req.Amount, 10)
	if !ok {
		return nil, status.Errorf(codes.InvalidArgument, "parsing amount %v", req.Amount)
	}
	cid, err := i.SendFil(ctx, req.From, req.To, amt)
	if err != nil {
		return nil, err
	}

	return &userPb.SendFilResponse{
		Cid: cid.String(),
	}, nil
}

// SignMessage calls ffs.SignMessage.
func (s *Service) SignMessage(ctx context.Context, req *userPb.SignMessageRequest) (*userPb.SignMessageResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	signature, err := i.SignMessage(ctx, req.Address, req.Message)
	if err != nil {
		return nil, fmt.Errorf("signing message: %s", err)
	}

	return &userPb.SignMessageResponse{Signature: signature}, nil
}

// VerifyMessage calls ffs.VerifyMessage.
func (s *Service) VerifyMessage(ctx context.Context, req *userPb.VerifyMessageRequest) (*userPb.VerifyMessageResponse, error) {
	i, err := s.getInstanceByToken(ctx)
	if err != nil {
		return nil, err
	}
	ok, err := i.VerifyMessage(ctx, req.Address, req.Message, req.Signature)
	if err != nil {
		return nil, fmt.Errorf("verifying signature: %s", err)
	}

	return &userPb.VerifyMessageResponse{Ok: ok}, nil
}

'''
'''--- Filecoin/powergate/api/server/util/util.go ---
package util

import (
	"fmt"
	"time"

	"github.com/ipfs/go-cid"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ToRPCStorageInfo converts a StorageInfo to the proto version.
func ToRPCStorageInfo(info ffs.StorageInfo) *userPb.StorageInfo {
	storageInfo := &userPb.StorageInfo{
		JobId:   info.JobID.String(),
		Cid:     util.CidToString(info.Cid),
		Created: info.Created.UnixNano(),
		Hot: &userPb.HotInfo{
			Enabled: info.Hot.Enabled,
			Size:    int64(info.Hot.Size),
			Ipfs: &userPb.IpfsHotInfo{
				Created: info.Hot.Ipfs.Created.UnixNano(),
			},
		},
		Cold: &userPb.ColdInfo{
			Enabled: info.Cold.Enabled,
			Filecoin: &userPb.FilInfo{
				DataCid:   util.CidToString(info.Cold.Filecoin.DataCid),
				Size:      info.Cold.Filecoin.Size,
				Proposals: make([]*userPb.FilStorage, len(info.Cold.Filecoin.Proposals)),
			},
		},
	}
	for i, p := range info.Cold.Filecoin.Proposals {
		var strPieceCid string
		if p.PieceCid.Defined() {
			strPieceCid = util.CidToString(p.PieceCid)
		}
		storageInfo.Cold.Filecoin.Proposals[i] = &userPb.FilStorage{
			DealId:     int64(p.DealID),
			PieceCid:   strPieceCid,
			Renewed:    p.Renewed,
			Duration:   p.Duration,
			StartEpoch: p.StartEpoch,
			Miner:      p.Miner,
			EpochPrice: p.EpochPrice,
		}
	}
	return storageInfo
}

// ToProtoStorageJobs converts a slice of ffs.StorageJobs to proto Jobs.
func ToProtoStorageJobs(jobs []ffs.StorageJob) ([]*userPb.StorageJob, error) {
	var res []*userPb.StorageJob
	for _, job := range jobs {
		j, err := ToRPCJob(job)
		if err != nil {
			return nil, err
		}
		res = append(res, j)
	}
	return res, nil
}

// ToRPCJob converts a job to a proto job.
func ToRPCJob(job ffs.StorageJob) (*userPb.StorageJob, error) {
	var dealInfo []*userPb.DealInfo
	for _, item := range job.DealInfo {
		info := &userPb.DealInfo{
			ActivationEpoch: item.ActivationEpoch,
			DealId:          item.DealID,
			Duration:        item.Duration,
			Message:         item.Message,
			Miner:           item.Miner,
			PieceCid:        item.PieceCID.String(),
			PricePerEpoch:   item.PricePerEpoch,
			ProposalCid:     item.ProposalCid.String(),
			Size:            item.Size,
			StartEpoch:      item.StartEpoch,
			StateId:         item.StateID,
			StateName:       item.StateName,
		}
		dealInfo = append(dealInfo, info)
	}

	var status userPb.JobStatus
	switch job.Status {
	case ffs.Unspecified:
		status = userPb.JobStatus_JOB_STATUS_UNSPECIFIED
	case ffs.Queued:
		status = userPb.JobStatus_JOB_STATUS_QUEUED
	case ffs.Executing:
		status = userPb.JobStatus_JOB_STATUS_EXECUTING
	case ffs.Failed:
		status = userPb.JobStatus_JOB_STATUS_FAILED
	case ffs.Canceled:
		status = userPb.JobStatus_JOB_STATUS_CANCELED
	case ffs.Success:
		status = userPb.JobStatus_JOB_STATUS_SUCCESS
	default:
		return nil, fmt.Errorf("unknown job status: %v", job.Status)
	}
	return &userPb.StorageJob{
		Id:         job.ID.String(),
		ApiId:      job.APIID.String(),
		Cid:        util.CidToString(job.Cid),
		Status:     status,
		ErrorCause: job.ErrCause,
		DealErrors: toRPCDealErrors(job.DealErrors),
		CreatedAt:  job.CreatedAt,
		DealInfo:   dealInfo,
	}, nil
}

func toRPCDealErrors(des []ffs.DealError) []*userPb.DealError {
	ret := make([]*userPb.DealError, len(des))
	for i, de := range des {
		var strProposalCid string
		if de.ProposalCid.Defined() {
			strProposalCid = util.CidToString(de.ProposalCid)
		}
		ret[i] = &userPb.DealError{
			ProposalCid: strProposalCid,
			Miner:       de.Miner,
			Message:     de.Message,
		}
	}
	return ret
}

// FromProtoCids converts string cids to cid.Cids.
func FromProtoCids(cids []string) ([]cid.Cid, error) {
	var res []cid.Cid
	for _, cid := range cids {
		cid, err := util.CidFromString(cid)
		if err != nil {
			return nil, err
		}
		res = append(res, cid)
	}
	return res, nil
}

// ToRPCStorageDealRecords transforms a StorageDealRecord slice to the proto version.
func ToRPCStorageDealRecords(records []deals.StorageDealRecord) []*userPb.StorageDealRecord {
	ret := make([]*userPb.StorageDealRecord, len(records))
	for i, r := range records {
		ret[i] = &userPb.StorageDealRecord{
			RootCid: util.CidToString(r.RootCid),
			Address: r.Addr,
			Time:    r.Time,
			Pending: r.Pending,
			DealInfo: &userPb.StorageDealInfo{
				ProposalCid:     util.CidToString(r.DealInfo.ProposalCid),
				StateId:         r.DealInfo.StateID,
				StateName:       r.DealInfo.StateName,
				Miner:           r.DealInfo.Miner,
				PieceCid:        util.CidToString(r.DealInfo.PieceCID),
				Size:            r.DealInfo.Size,
				PricePerEpoch:   r.DealInfo.PricePerEpoch,
				StartEpoch:      r.DealInfo.StartEpoch,
				Duration:        r.DealInfo.Duration,
				DealId:          r.DealInfo.DealID,
				ActivationEpoch: r.DealInfo.ActivationEpoch,
				Message:         r.DealInfo.Message,
			},
			TransferSize:      r.TransferSize,
			DataTransferStart: timestamppb.New(time.Unix(r.DataTransferStart, 0)),
			DataTransferEnd:   timestamppb.New(time.Unix(r.DataTransferEnd, 0)),
			SealingStart:      timestamppb.New(time.Unix(r.SealingStart, 0)),
			SealingEnd:        timestamppb.New(time.Unix(r.SealingEnd, 0)),
			ErrMsg:            r.ErrMsg,
			UpdatedAt:         timestamppb.New(time.Unix(0, r.UpdatedAt)),
		}
	}
	return ret
}

// ToRPCRetrievalDealRecords converts a RetrievalDealRecord slice to the proto version.
func ToRPCRetrievalDealRecords(records []deals.RetrievalDealRecord) []*userPb.RetrievalDealRecord {
	ret := make([]*userPb.RetrievalDealRecord, len(records))
	for i, r := range records {
		ret[i] = &userPb.RetrievalDealRecord{
			Id:      r.ID,
			Address: r.Addr,
			Time:    r.Time,
			DealInfo: &userPb.RetrievalDealInfo{
				RootCid:                 util.CidToString(r.DealInfo.RootCid),
				Size:                    r.DealInfo.Size,
				MinPrice:                r.DealInfo.MinPrice,
				PaymentInterval:         r.DealInfo.PaymentInterval,
				PaymentIntervalIncrease: r.DealInfo.PaymentIntervalIncrease,
				Miner:                   r.DealInfo.Miner,
				MinerPeerId:             r.DealInfo.MinerPeerID,
			},
			DataTransferStart: timestamppb.New(time.Unix(r.DataTransferStart, 0)),
			DataTransferEnd:   timestamppb.New(time.Unix(r.DataTransferEnd, 0)),
			BytesReceived:     r.BytesReceived,
			ErrMsg:            r.ErrMsg,
			UpdatedAt:         timestamppb.New(time.Unix(0, r.UpdatedAt)),
		}
	}
	return ret
}

'''
'''--- Filecoin/powergate/buildinfo/buildinfo.go ---
package buildinfo

import "fmt"

var (
	// GitCommit is set by govvv at build time.
	GitCommit = "n/a"
	// GitBranch  is set by govvv at build time.
	GitBranch = "n/a"
	// GitState  is set by govvv at build time.
	GitState = "n/a"
	// GitSummary is set by govvv at build time.
	GitSummary = "n/a"
	// BuildDate  is set by govvv at build time.
	BuildDate = "n/a"
	// Version  is set by govvv at build time.
	Version = "n/a"
)

// Summary prints a summary of all build info.
func Summary() string {
	return fmt.Sprintf(
		"\tversion:\t%s\n\tbuild date:\t%s\n\tgit summary:\t%s\n\tgit branch:\t%s\n\tgit commit:\t%s\n\tgit state:\t%s",
		Version,
		BuildDate,
		GitSummary,
		GitBranch,
		GitCommit,
		GitState,
	)
}

'''
'''--- Filecoin/powergate/chainstore/chainstore.go ---
package chainstore

import (
	"context"
	"encoding/json"
	"fmt"
	"math/bits"
	"sort"
	"strconv"
	"sync"

	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
)

const (
	maxCheckpoints = 10
)

var (
	log      = logging.Logger("chainstore")
	dsNsData = datastore.NewKey("/data")
	dsNsID   = datastore.NewKey("/id")
)

// TipsetOrderer resolves ordering information between TipSets.
type TipsetOrderer interface {
	Precedes(ctx context.Context, from, to types.TipSetKey) (bool, error)
}

type checkpoint struct {
	id uint64
	ts types.TipSetKey
}

// Store allows to save snapshoted state.
type Store struct {
	fr TipsetOrderer

	lock        sync.Mutex
	ds          datastore.TxnDatastore
	checkpoints []checkpoint
	lastID      uint64
}

// New returns a new Store.
func New(ds datastore.TxnDatastore, fr TipsetOrderer) (*Store, error) {
	s := &Store{
		ds: ds,
		fr: fr,
	}
	if err := s.loadCheckpoints(); err != nil {
		return nil, err
	}
	return s, nil
}

// GetLastCheckpoint returns the most recent saved state, and its TipSetKey.
// In case none exist, it will return a nil TipSetKey.
func (s *Store) GetLastCheckpoint(v interface{}) (*types.TipSetKey, error) {
	s.lock.Lock()
	defer s.lock.Unlock()
	if len(s.checkpoints) == 0 {
		return nil, nil
	}
	chk := s.checkpoints[len(s.checkpoints)-1]
	if err := s.load(chk.ts, v); err != nil {
		log.Warnf("loading last checkpoint with base %s: %s", chk.ts, err)
		// On error, just assume there's no previous checkpoint.
		return nil, nil
	}
	return &chk.ts, nil
}

// LoadAndPrune loads into value the last saved state before the currHead tipset branch,
// and returns the TipSetKey of that state. If currHead invalidates saved checkpoints
// those will be deleted (auto-pruning).
func (s *Store) LoadAndPrune(ctx context.Context, currHead types.TipSetKey, value interface{}) (*types.TipSetKey, error) {
	s.lock.Lock()
	defer s.lock.Unlock()
	var base *types.TipSetKey
	for i := len(s.checkpoints) - 1; i >= 0 && base == nil; i-- {
		c := s.checkpoints[i]
		ok, err := s.fr.Precedes(ctx, c.ts, currHead)
		if err != nil {
			return nil, err
		}
		if !ok {
			if err := s.delete(c); err != nil {
				return nil, err
			}
			s.checkpoints = s.checkpoints[:i]
			continue
		}
		base = &c.ts
	}
	if base == nil {
		return nil, nil
	}
	if err := s.load(*base, value); err != nil {
		log.Warnf("loading base %s: %s", *base, err)
		// On error, just assume there's no previous checkpoint.
		return nil, nil
	}
	return base, nil
}

func (s *Store) load(tsk types.TipSetKey, v interface{}) error {
	key := toKeyData(tsk)
	buf, err := s.ds.Get(key)
	if err != nil {
		return fmt.Errorf("error getting key %s: %s", key, err)
	}
	if err := json.Unmarshal(buf, v); err != nil {
		log.Warnf("corrupted checkpoint: %s", buf)
		return fmt.Errorf("unmarshaling checkpoint: %s", err)
	}
	return nil
}

// Save saves a new current state which should be a child of the last known checkpoint.
func (s *Store) Save(ctx context.Context, ts types.TipSetKey, state interface{}) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	if len(s.checkpoints) > 0 {
		last := s.checkpoints[len(s.checkpoints)-1]
		ok, err := s.fr.Precedes(ctx, last.ts, ts)
		if err != nil {
			return err
		}
		if !ok {
			return fmt.Errorf("new state should be on the same chain as last checkpoint")
		}
	}
	if err := s.save(ts, state); err != nil {
		return err
	}
	return nil
}

func (s *Store) save(ts types.TipSetKey, state interface{}) error {
	txn, err := s.ds.NewTransaction(false)
	if err != nil {
		return nil
	}
	defer txn.Discard()
	buf, err := json.Marshal(state)
	if err != nil {
		return err
	}
	c := checkpoint{id: s.lastID + 1, ts: ts}
	if err := txn.Put(toKeyData(c.ts), buf); err != nil {
		return err
	}
	if err := txn.Put(toKeyID(c.id), c.ts.Bytes()); err != nil {
		return err
	}
	if err := txn.Commit(); err != nil {
		return err
	}

	s.checkpoints = append(s.checkpoints, c)
	if len(s.checkpoints) > maxCheckpoints {
		dc := s.checkpoints[0]
		if err := s.delete(dc); err != nil {
			return err
		}
		copy(s.checkpoints, s.checkpoints[1:])
		s.checkpoints = s.checkpoints[:len(s.checkpoints)-1]
	}
	s.lastID++

	return nil
}

func (s *Store) delete(c checkpoint) error {
	txn, err := s.ds.NewTransaction(false)
	if err != nil {
		return err
	}
	defer txn.Discard()

	if err := txn.Delete(toKeyData(c.ts)); err != nil {
		return err
	}
	if err := txn.Delete(toKeyID(c.id)); err != nil {
		return err
	}
	return txn.Commit()
}

func toKeyData(ts types.TipSetKey) datastore.Key {
	return dsNsData.ChildString(string(ts.Bytes()))
}

func toKeyID(id uint64) datastore.Key {
	return dsNsID.ChildString(strconv.FormatUint(id, 10))
}

func (s *Store) loadCheckpoints() error {
	res, err := s.ds.Query(query.Query{Prefix: dsNsID.String()})
	if err != nil {
		return err
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()
	es, err := res.Rest()
	if err != nil {
		return err
	}
	lst := make([]checkpoint, len(es))
	for i, e := range es {
		ts, err := types.TipSetKeyFromBytes(e.Value)
		if err != nil {
			return err
		}
		id, err := strconv.ParseUint(datastore.RawKey(e.Key).List()[1], 10, bits.UintSize)
		if err != nil {
			return err
		}
		lst[i] = checkpoint{
			id: id,
			ts: ts,
		}
	}
	sort.Slice(lst, func(i, j int) bool {
		return lst[i].id < lst[j].id
	})
	if len(lst) > 0 {
		s.lastID = lst[len(lst)-1].id
	}
	s.checkpoints = lst
	return nil
}

'''
'''--- Filecoin/powergate/chainstore/chainstore_test.go ---
package chainstore

import (
	"context"
	"crypto/rand"
	"testing"

	"github.com/filecoin-project/lotus/chain/types"
	"github.com/google/go-cmp/cmp"
	"github.com/ipfs/go-cid"
	"github.com/multiformats/go-multihash"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

type data struct {
	Tipset string
	Nested extraData
}

type extraData struct {
	Pos int
}

func TestLoadFromEmpty(t *testing.T) {
	ctx := context.Background()
	cs, err := New(tests.NewTxMapDatastore(), newMockTipsetOrderer())
	require.NoError(t, err)

	var d data
	target := types.NewTipSetKey(cid.Undef)
	ts, err := cs.LoadAndPrune(ctx, target, &d)
	require.NoError(t, err)

	require.Nil(t, ts, "base tipset should be nil")

	require.Equal(t, data{}, d, "state should be the default value")
}

func TestSaveSingle(t *testing.T) {
	ctx := context.Background()
	mto := newMockTipsetOrderer()

	cs, err := New(tests.NewTxMapDatastore(), mto)
	require.NoError(t, err)

	ts, v := mto.next(t)
	err = cs.Save(ctx, ts, &v)
	require.NoError(t, err)

	var v2 data
	bts, err := cs.LoadAndPrune(ctx, ts, &v2)
	require.NoError(t, err)

	if !cmp.Equal(v, v2) || *bts != ts {
		t.Fatalf("saved and loaded state from same tipset should be equal")
	}
}

func TestSaveMultiple(t *testing.T) {
	ctx := context.Background()
	mto := newMockTipsetOrderer()

	cs, err := New(tests.NewTxMapDatastore(), mto)
	require.NoError(t, err)

	generateTotal := 100
	for i := 0; i < generateTotal; i++ {
		ts, v := mto.next(t)
		err := cs.Save(ctx, ts, &v)
		require.NoError(t, err)
	}

	// Check that we're capping # of checkpoints to maxCheckpoints
	if len(cs.checkpoints) != maxCheckpoints {
		t.Fatalf("there should be exactly maxCheckpoints saved")
	}
	// Check saved ones are the last maxCheckpoint ones
	expectedTipsets := mto.list[generateTotal-maxCheckpoints:]
	for i, c := range cs.checkpoints {
		require.Equal(t, expectedTipsets[i], c.ts, "saved tipset doesn't correspond with expected one")
	}

	for i := len(expectedTipsets) - 1; i >= 0; i-- {
		ts := expectedTipsets[i]
		var v data
		bts, err := cs.LoadAndPrune(ctx, ts, &v)
		require.NoError(t, err)
		if *bts != ts || v.Nested.Pos != generateTotal-maxCheckpoints+i {
			t.Fatalf("elem %d doesn't seem to be loaded from correct tipset", i)
		}
	}
}

func TestSaveInvalid(t *testing.T) {
	ctx := context.Background()
	mto := newMockTipsetOrderer()
	cs, err := New(tests.NewTxMapDatastore(), mto)
	require.NoError(t, err)

	ts1, v1 := mto.next(t)
	ts2, v2 := mto.next(t)

	err = cs.Save(ctx, ts2, &v2)
	require.NoError(t, err)

	err = cs.Save(ctx, ts1, &v1)
	require.Error(t, err, "Save must not allow to save state on an older tipset that last known")
}

// Most interesting test.
// Create 10 happy-chain tipset saves. Load from new tipset (tsFork) that forks from
// 6th saved tipset. The Load should delete checkpoints 7, 8, 9 and 10 since tsFork
// doesnt Precede() from any of them, and return state of checkpoint 6.
// Saying it differently, Load should return the last state from the most recent
// checkpoint that precedes the target tipset.
func TestLoadForkedCheckpoint(t *testing.T) {
	ctx := context.Background()
	mto := newMockTipsetOrderer()

	cs, err := New(tests.NewTxMapDatastore(), mto)
	require.NoError(t, err)

	for i := 0; i < 10; i++ {
		ts, v := mto.next(t)
		err := cs.Save(ctx, ts, &v)
		require.NoError(t, err)
	}

	fts := mto.fork(t, 5)
	var v data
	bts, err := cs.LoadAndPrune(ctx, fts, &v)
	require.NoError(t, err)

	if *bts != mto.list[5] {
		t.Fatalf("returned base tipset state should be from the 6th checkpoint")
	}
	if v.Nested.Pos != 5 {
		t.Fatalf("state return doesn't seem to correspond to the 6th checkpoint")
	}
}

func TestLoadSavedState(t *testing.T) {
	ctx := context.Background()
	mto := newMockTipsetOrderer()
	ds := tests.NewTxMapDatastore()
	cs, err := New(ds, mto)
	require.NoError(t, err)

	generateTotal := 100
	for i := 0; i < generateTotal; i++ {
		ts, v := mto.next(t)
		err := cs.Save(ctx, ts, &v)
		require.NoError(t, err)
	}

	cs, err = New(ds, mto)
	require.NoError(t, err)
	if len(cs.checkpoints) != maxCheckpoints {
		t.Fatalf("checkpoints are missing")
	}

	offset := 3
	savedTipset := mto.list[len(mto.list)-offset]
	var v data
	bts, err := cs.LoadAndPrune(ctx, savedTipset, &v)
	require.NoError(t, err)
	if *bts != savedTipset || v.Tipset != savedTipset.String() || v.Nested.Pos != generateTotal-offset {
		t.Fatalf("returned state is wrong")
	}
}

type mockTipsetOrderer struct {
	forks map[string]string
	list  []types.TipSetKey
}

func newMockTipsetOrderer() *mockTipsetOrderer {
	return &mockTipsetOrderer{
		forks: make(map[string]string),
	}
}

func (mto *mockTipsetOrderer) Precedes(ctx context.Context, from, to types.TipSetKey) (bool, error) {
	if forkedTs, ok := mto.forks[from.String()]; ok {
		if forkedTs == to.String() {
			return true, nil
		}
	}

	var foundFrom bool
	for _, v := range mto.list {
		foundFrom = foundFrom || from == v
		if foundFrom && to == v {
			return true, nil
		}
	}
	return false, nil
}

func (mto *mockTipsetOrderer) next(t *testing.T) (types.TipSetKey, data) {
	ts := randomTipsetkey(t)
	mto.list = append(mto.list, ts)

	return ts, data{Tipset: ts.String(), Nested: extraData{
		Pos: len(mto.list) - 1,
	}}
}

func (mto *mockTipsetOrderer) fork(t *testing.T, i int) types.TipSetKey {
	fork := randomTipsetkey(t)
	mto.forks[mto.list[i].String()] = fork.String()
	return fork
}

func randomTipsetkey(t *testing.T) types.TipSetKey {
	r := make([]byte, 16)
	_, err := rand.Read(r)
	require.NoError(t, err)

	mh, err := multihash.Sum(r, multihash.IDENTITY, -1)
	require.NoError(t, err)
	return types.NewTipSetKey(cid.NewCidV1(cid.Raw, mh))
}

'''
'''--- Filecoin/powergate/chainsync/chainsync.go ---
package chainsync

import (
	"context"
	"fmt"

	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/textileio/powergate/v2/lotus"
)

const (
	hcApply = "apply"
	// For completeness:
	// hcRevert = "revert".
	// hcCurrent = "current".
)

// ChainSync provides methods to resolve chain syncing situations.
type ChainSync struct {
	clientBuilder lotus.ClientBuilder
}

// New returns a new ChainSync.
func New(clientBuilder lotus.ClientBuilder) *ChainSync {
	return &ChainSync{
		clientBuilder: clientBuilder,
	}
}

// Precedes returns true if from and to don't live in different chain forks, and
// from is at a lower epoch than to.
func (cs *ChainSync) Precedes(ctx context.Context, from, to types.TipSetKey) (bool, error) {
	client, cls, err := cs.clientBuilder(ctx)
	if err != nil {
		return false, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	fpath, err := client.ChainGetPath(ctx, from, to)
	if err != nil {
		return false, fmt.Errorf("getting path from %v to %v: %s", from.Cids(), to.Cids(), err)
	}
	if len(fpath) == 0 {
		return true, nil
	}
	norevert := fpath[0].Type == hcApply
	return norevert, nil
}

// ResolveBase returns the base TipSetKey that both left and right TipSetKey share,
// plus a Revert/Apply set of operations to get from last to new.
func ResolveBase(ctx context.Context, api *api.FullNodeStruct, left *types.TipSetKey, right types.TipSetKey) (*types.TipSetKey, []*types.TipSet, error) {
	var path []*types.TipSet
	if left == nil {
		genesis, err := api.ChainGetGenesis(ctx)
		if err != nil {
			return nil, nil, fmt.Errorf("getting genesis tipset: %s", err)
		}
		path = append(path, genesis)
		gtsk := types.NewTipSetKey(genesis.Cids()...)
		left = &gtsk
	}

	fpath, err := api.ChainGetPath(ctx, *left, right)
	if err != nil {
		return nil, nil, err
	}

	var base *types.TipSetKey
	for _, ts := range fpath {
		if ts.Type == hcApply {
			if base == nil {
				b := types.NewTipSetKey(ts.Val.Blocks()[0].Parents...)
				base = &b
			}
			path = append(path, ts.Val)
		}
	}
	return base, path, nil
}

'''
'''--- Filecoin/powergate/chainsync/chainsync_test.go ---
package chainsync

import (
	"context"
	"os"
	"testing"
	"time"

	"github.com/filecoin-project/lotus/chain/types"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

func TestMain(m *testing.M) {
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestPrecede(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	time.Sleep(time.Second * 5) // Give time for at least 1 block to be mined.
	ctx := context.Background()
	c, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()

	h, err := c.ChainHead(ctx)
	checkErr(t, err)

	csync := New(clientBuilder)
	head := h.Key()
	prevhead := types.NewTipSetKey(h.Blocks()[0].Parents...)
	yes, err := csync.Precedes(ctx, prevhead, head)
	checkErr(t, err)
	if !yes {
		t.Fatal("parent of head should precedes head")
	}

	yes, err = csync.Precedes(ctx, head, prevhead)
	checkErr(t, err)
	if yes {
		t.Fatal("head shouldn't preced parent of head")
	}
}

func checkErr(t *testing.T, err error) {
	t.Helper()
	if err != nil {
		t.Fatal(err)
	}
}

'''
'''--- Filecoin/powergate/cli-docs/pow/pow.md ---
## pow

A client for storage and retreival of powergate data

### Synopsis

A client for storage and retreival of powergate data

```
pow [flags]
```

### Options

```
  -h, --help                   help for pow
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
  -v, --version                display version information for pow and the connected server
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow config](pow_config.md)	 - Provides commands to interact with cid storage configs
* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs
* [pow deals](pow_deals.md)	 - Provides commands to view Filecoin deal information
* [pow id](pow_id.md)	 - Returns the user id
* [pow offline](pow_offline.md)	 - Provides commands to prepare data for Filecoin onbarding
* [pow storage-info](pow_storage-info.md)	 - Provides commands to get and query cid storage info.
* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states
* [pow version](pow_version.md)	 - Display version information for pow and the connected server
* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin.md ---
## pow admin

Provides admin commands

### Synopsis

Provides admin commands

### Options

```
      --admin-token string   admin auth token
  -h, --help                 help for admin
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow admin data](pow_admin_data.md)	 - Provides admin data commands
* [pow admin storage-info](pow_admin_storage-info.md)	 - Provides admin storage info commands
* [pow admin storage-jobs](pow_admin_storage-jobs.md)	 - Provides admin jobs commands
* [pow admin users](pow_admin_users.md)	 - Provides admin users commands
* [pow admin wallet](pow_admin_wallet.md)	 - Provides admin wallet commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_data.md ---
## pow admin data

Provides admin data commands

### Synopsis

Provides admin data commands

### Options

```
  -h, --help   help for data
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow admin data gcstaged](pow_admin_data_gcstaged.md)	 - Unpins unused staged data.
* [pow admin data pinnedcids](pow_admin_data_pinnedcids.md)	 - List pinned cids information in hot-storage.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_data_gcstaged.md ---
## pow admin data gcstaged

Unpins unused staged data.

### Synopsis

Unpins staged data not used by queued or executing jobs.

```
pow admin data gcstaged [flags]
```

### Options

```
  -h, --help   help for gcstaged
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin data](pow_admin_data.md)	 - Provides admin data commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_data_pinnedcids.md ---
## pow admin data pinnedcids

List pinned cids information in hot-storage.

### Synopsis

List pinned cids information in hot-storage.

```
pow admin data pinnedcids [flags]
```

### Options

```
  -h, --help   help for pinnedcids
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin data](pow_admin_data.md)	 - Provides admin data commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-info.md ---
## pow admin storage-info

Provides admin storage info commands

### Synopsis

Provides admin storage info commands

### Options

```
  -h, --help   help for storage-info
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow admin storage-info get](pow_admin_storage-info_get.md)	 - Returns the information about a stored cid.
* [pow admin storage-info list](pow_admin_storage-info_list.md)	 - Returns a list of information about all stored cids, filtered by user ids and cids if provided.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-info_get.md ---
## pow admin storage-info get

Returns the information about a stored cid.

### Synopsis

Returns the information about a stored cid.

```
pow admin storage-info get [user-id] [cid] [flags]
```

### Options

```
  -h, --help   help for get
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin storage-info](pow_admin_storage-info.md)	 - Provides admin storage info commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-info_list.md ---
## pow admin storage-info list

Returns a list of information about all stored cids, filtered by user ids and cids if provided.

### Synopsis

Returns a list of information about all stored cids, filtered by user ids and cids if provided.

```
pow admin storage-info list [flags]
```

### Options

```
      --cids strings       filter results by provided cids.
  -h, --help               help for list
      --user-ids strings   filter results by provided user ids.
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin storage-info](pow_admin_storage-info.md)	 - Provides admin storage info commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-jobs.md ---
## pow admin storage-jobs

Provides admin jobs commands

### Synopsis

Provides admin jobs commands

### Options

```
  -h, --help   help for storage-jobs
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow admin storage-jobs list](pow_admin_storage-jobs_list.md)	 - List storage jobs according to query flag options.
* [pow admin storage-jobs summary](pow_admin_storage-jobs_summary.md)	 - Give a summary of storage jobs in all states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-jobs_list.md ---
## pow admin storage-jobs list

List storage jobs according to query flag options.

### Synopsis

List storage jobs according to query flag options.

```
pow admin storage-jobs list [flags]
```

### Options

```
  -a, --ascending       sort results ascending by time
  -c, --cid string      return results only for the specified cid
  -h, --help            help for list
  -l, --limit uint      limit the number of results returned
  -s, --select string   return only results using the specified selector: all, queued, executing, final (default "all")
  -u, --user string     return results only for the specified user id
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin storage-jobs](pow_admin_storage-jobs.md)	 - Provides admin jobs commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_storage-jobs_summary.md ---
## pow admin storage-jobs summary

Give a summary of storage jobs in all states

### Synopsis

Give a summary of storage jobs in all states

```
pow admin storage-jobs summary [flags]
```

### Options

```
  -c, --cid string       optional cid filter to apply
  -h, --help             help for summary
  -u, --user-id string   optional user id filter to apply
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin storage-jobs](pow_admin_storage-jobs.md)	 - Provides admin jobs commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_users.md ---
## pow admin users

Provides admin users commands

### Synopsis

Provides admin users commands

### Options

```
  -h, --help   help for users
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow admin users create](pow_admin_users_create.md)	 - Create a Powergate user.
* [pow admin users list](pow_admin_users_list.md)	 - List all Powergate users.
* [pow admin users regenerate](pow_admin_users_regenerate.md)	 - Invalidates an existing token and replaces it with a new one.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_users_create.md ---
## pow admin users create

Create a Powergate user.

### Synopsis

Create a Powergate user.

```
pow admin users create [flags]
```

### Options

```
  -h, --help   help for create
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin users](pow_admin_users.md)	 - Provides admin users commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_users_list.md ---
## pow admin users list

List all Powergate users.

### Synopsis

List all Powergate users.

```
pow admin users list [flags]
```

### Options

```
  -h, --help   help for list
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin users](pow_admin_users.md)	 - Provides admin users commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_users_regenerate.md ---
## pow admin users regenerate

Invalidates an existing token and replaces it with a new one.

### Synopsis

Invalidates an existing token and replaces it with a new one.

```
pow admin users regenerate [token-to-regenerate] [flags]
```

### Options

```
  -h, --help   help for regenerate
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin users](pow_admin_users.md)	 - Provides admin users commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_wallet.md ---
## pow admin wallet

Provides admin wallet commands

### Synopsis

Provides admin wallet commands

### Options

```
  -h, --help   help for wallet
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin](pow_admin.md)	 - Provides admin commands
* [pow admin wallet addrs](pow_admin_wallet_addrs.md)	 - List all addresses associated with this Powergate.
* [pow admin wallet new](pow_admin_wallet_new.md)	 - Creates a new walllet address.
* [pow admin wallet send](pow_admin_wallet_send.md)	 - Sends FIL from an address associated with this Powergate to any other address.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_wallet_addrs.md ---
## pow admin wallet addrs

List all addresses associated with this Powergate.

### Synopsis

List all addresses associated with this Powergate.

```
pow admin wallet addrs [flags]
```

### Options

```
  -h, --help   help for addrs
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin wallet](pow_admin_wallet.md)	 - Provides admin wallet commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_wallet_new.md ---
## pow admin wallet new

Creates a new walllet address.

### Synopsis

Creates a new wallet address.

```
pow admin wallet new [flags]
```

### Options

```
  -f, --format string   Optionally specify address format bls or secp256k1 (default "bls")
  -h, --help            help for new
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin wallet](pow_admin_wallet.md)	 - Provides admin wallet commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_admin_wallet_send.md ---
## pow admin wallet send

Sends FIL from an address associated with this Powergate to any other address.

### Synopsis

Sends FIL from an address associated with this Powergate to any other address.

```
pow admin wallet send [from] [to] [amount] [flags]
```

### Options

```
  -h, --help   help for send
```

### Options inherited from parent commands

```
      --admin-token string     admin auth token
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow admin wallet](pow_admin_wallet.md)	 - Provides admin wallet commands

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_config.md ---
## pow config

Provides commands to interact with cid storage configs

### Synopsis

Provides commands to interact with cid storage configs

### Options

```
  -h, --help   help for config
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow config apply](pow_config_apply.md)	 - Apply the default or provided storage config to the specified cid
* [pow config default](pow_config_default.md)	 - Returns the default storage config
* [pow config remove](pow_config_remove.md)	 - Removes a Cid from being tracked as an active storage
* [pow config set-default](pow_config_set-default.md)	 - Sets the default storage config from stdin or a file

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_config_apply.md ---
## pow config apply

Apply the default or provided storage config to the specified cid

### Synopsis

Apply the default or provided storage config to the specified cid

```
pow config apply [cid] [flags]
```

### Options

```
  -c, --conf string            Optional path to a file containing storage config json, falls back to stdin, uses the user default by default
  -h, --help                   help for apply
  -i, --import-deals strings   Comma-separated list of deal ids to import
  -e, --noexec                 If set, it doesn't create a job to ensure the new configuration
  -o, --override               If set, override any pre-existing storage configuration for the cid
  -w, --watch                  Watch the progress of the resulting job
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow config](pow_config.md)	 - Provides commands to interact with cid storage configs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_config_default.md ---
## pow config default

Returns the default storage config

### Synopsis

Returns the default storage config

```
pow config default [flags]
```

### Options

```
  -h, --help   help for default
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow config](pow_config.md)	 - Provides commands to interact with cid storage configs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_config_remove.md ---
## pow config remove

Removes a Cid from being tracked as an active storage

### Synopsis

Removes a Cid from being tracked as an active storage. The Cid should have both Hot and Cold storage disabled, if that isn't the case it will return ErrActiveInStorage

```
pow config remove [cid] [flags]
```

### Options

```
  -h, --help   help for remove
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow config](pow_config.md)	 - Provides commands to interact with cid storage configs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_config_set-default.md ---
## pow config set-default

Sets the default storage config from stdin or a file

### Synopsis

Sets the default storage config from stdin or a file

```
pow config set-default [optional file] [flags]
```

### Options

```
  -h, --help   help for set-default
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow config](pow_config.md)	 - Provides commands to interact with cid storage configs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data.md ---
## pow data

Provides commands to interact with general data APIs

### Synopsis

Provides commands to interact with general data APIs

### Options

```
  -h, --help   help for data
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow data get](pow_data_get.md)	 - Get data stored by the user by cid
* [pow data info](pow_data_info.md)	 - Get information about the current storage state of a cid
* [pow data log](pow_data_log.md)	 - Display logs for specified cid
* [pow data replace](pow_data_replace.md)	 - Applies a StorageConfig for c2 equal to that of c1, and removes c1
* [pow data stage](pow_data_stage.md)	 - Temporarily stage data in Hot Storage in preparation for applying a cid storage config
* [pow data summary](pow_data_summary.md)	 - Get a summary about the current storage and jobs state of cids

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_get.md ---
## pow data get

Get data stored by the user by cid

### Synopsis

Get data stored by the user by cid

```
pow data get [cid] [output file path] [flags]
```

### Options

```
  -f, --folder                Indicates that the retrieved Cid is a folder
  -h, --help                  help for get
      --ipfsrevproxy string   Powergate IPFS reverse proxy DNS address. If port 443, is assumed is a HTTPS endpoint. (default "localhost:6002")
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_info.md ---
## pow data info

Get information about the current storage state of a cid

### Synopsis

Get information about the current storage state of a cid

```
pow data info cid [flags]
```

### Options

```
  -h, --help   help for info
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_log.md ---
## pow data log

Display logs for specified cid

### Synopsis

Display logs for specified cid

```
pow data log [cid] [flags]
```

### Options

```
  -h, --help         help for log
  -j, --jid string   Display information for only this job id
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_replace.md ---
## pow data replace

Applies a StorageConfig for c2 equal to that of c1, and removes c1

### Synopsis

Applies a StorageConfig for c2 equal to that of c1, and removes c1. This operation is more efficient than manually removing and adding in two separate operations

```
pow data replace [cid1] [cid2] [flags]
```

### Options

```
  -h, --help    help for replace
  -w, --watch   Watch the progress of the resulting job
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_stage.md ---
## pow data stage

Temporarily stage data in Hot Storage in preparation for applying a cid storage config

### Synopsis

Temporarily stage data in Hot Storage in preparation for applying a cid storage config

```
pow data stage [path|url] [flags]
```

### Options

```
  -h, --help                  help for stage
      --ipfsrevproxy string   Powergate IPFS reverse proxy multiaddr (default "127.0.0.1:6002")
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_data_summary.md ---
## pow data summary

Get a summary about the current storage and jobs state of cids

### Synopsis

Get a summary about the current storage and jobs state of cids

```
pow data summary [optional cid1,cid2,...] [flags]
```

### Options

```
  -h, --help   help for summary
  -j, --json   output data in raw json instead of an interactive ui
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow data](pow_data.md)	 - Provides commands to interact with general data APIs

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_deals.md ---
## pow deals

Provides commands to view Filecoin deal information

### Synopsis

Provides commands to view Filecoin deal information

### Options

```
  -h, --help   help for deals
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow deals retrievals](pow_deals_retrievals.md)	 - List retrieval deal records for the user
* [pow deals storage](pow_deals_storage.md)	 - List storage deal records for the user

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_deals_retrievals.md ---
## pow deals retrievals

List retrieval deal records for the user

### Synopsis

List retrieval deal records for the user

```
pow deals retrievals [flags]
```

### Options

```
      --addrs strings    limit the records to deals initiated from  the specified wallet addresses
  -a, --ascending        sort records ascending, default is descending
      --cids strings     limit the records to deals for the specified data cids
  -h, --help             help for retrievals
  -e, --include-failed   include failed retrievals
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow deals](pow_deals.md)	 - Provides commands to view Filecoin deal information

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_deals_storage.md ---
## pow deals storage

List storage deal records for the user

### Synopsis

List storage deal records for the user

```
pow deals storage [flags]
```

### Options

```
      --addrs strings     limit the records to deals initiated from  the specified wallet addresses, treated as and AND operation if --cids is also provided
  -a, --ascending         sort records ascending, default is sort descending
      --cids strings      limit the records to deals for the specified data cids, treated as and AND operation if --addrs is also provided
  -h, --help              help for storage
  -e, --include-failed    include failed deals
  -f, --include-final     include final deals
  -p, --include-pending   include pending deals
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow deals](pow_deals.md)	 - Provides commands to view Filecoin deal information

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_id.md ---
## pow id

Returns the user id

### Synopsis

Returns the user id

```
pow id [flags]
```

### Options

```
  -h, --help   help for id
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_offline.md ---
## pow offline

Provides commands to prepare data for Filecoin onbarding

### Synopsis

Provides commands to prepare data for Filecoin onbarding

### Options

```
  -h, --help   help for offline
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow offline car](pow_offline_car.md)	 - car generates a CAR file from the data
* [pow offline commp](pow_offline_commp.md)	 - commP calculates the piece size and cid for a CAR file
* [pow offline prepare](pow_offline_prepare.md)	 - prepare generates a CAR file for data

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_offline_car.md ---
## pow offline car

car generates a CAR file from the data

### Synopsis

Generates a CAR file from the data source. This data-source can be a file/folder path or a Cid.

If a file/folder path is provided, this command will DAGify the data and generate the CAR file.
If a Cid is provided, an extra --ipfs-api flag should be provided to connect to the IPFS node that contains this Cid data.

```
pow offline car [path | cid] [output path] [flags]
```

### Options

```
      --aggregate         aggregates a folder of files
  -h, --help              help for car
      --ipfs-api string   IPFS HTTP API multiaddress that stores the cid (only for Cid processing instead of file/folder path)
      --quiet             avoid pretty output
      --tmpdir string     path of folder where a temporal blockstore is created for processing data (default "/tmp")
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow offline](pow_offline.md)	 - Provides commands to prepare data for Filecoin onbarding

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_offline_commp.md ---
## pow offline commp

commP calculates the piece size and cid for a CAR file

### Synopsis

commP calculates the piece-size and PieceCID for a CAR file.

This command calculates the piece-size and piece-cid (CommP) from a CAR file.
This command only makes sense to run for a CAR file, so it does some quick check if the input file *seems* to be well-formated. 
You can use the --skip-car-validation, but usually shouldn't be done unless you know what you're doing (e.g.: benchmarks, or other tests)

```
pow offline commp [path] [flags]
```

### Options

```
  -h, --help                  help for commp
      --json                  avoid pretty output and use json formatting
      --skip-car-validation   skips CAR validation when processing a path
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow offline](pow_offline.md)	 - Provides commands to prepare data for Filecoin onbarding

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_offline_prepare.md ---
## pow offline prepare

prepare generates a CAR file for data

### Synopsis

Prepares a data source generating all needed to execute an offline deal.
The data source can be a file/folder path or a Cid.

If a file/folder path is provided, this command will DAGify the data and generate the CAR file.
If a Cid is provided, an extra --ipfs-api flag should be provided to connect to the IPFS node that contains this Cid data.

This command prepares data in a more efficiently than running car+commp subcommands, since it already starts calculating CommP at the same time that the CAR file is being generated.

By default prints to stdout the generated CAR file. You can provide a second argument to
specify the output file path, or simply pipe the stdout result.

The piece-size and piece-cid are printed to stderr. For scripting usage, its recommended to use the --json flag.

```
pow offline prepare [cid | path] [output CAR file path] [flags]
```

### Options

```
      --aggregate         aggregates a folder of files
  -h, --help              help for prepare
      --ipfs-api string   IPFS HTTP API multiaddress that stores the cid (only for Cid processing instead of file/folder path)
      --json              avoid pretty output and use json formatting
      --tmpdir string     path of folder where a temporal blockstore is created for processing data (default "/tmp")
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow offline](pow_offline.md)	 - Provides commands to prepare data for Filecoin onbarding

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-info.md ---
## pow storage-info

Provides commands to get and query cid storage info.

### Synopsis

Provides commands to get and query cid storage info.

### Options

```
  -h, --help   help for storage-info
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow storage-info get](pow_storage-info_get.md)	 - Returns the information about a stored cid.
* [pow storage-info list](pow_storage-info_list.md)	 - Returns a list of information about all stored cids, filtered by cids if provided.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-info_get.md ---
## pow storage-info get

Returns the information about a stored cid.

### Synopsis

Returns the information about a stored cid.

```
pow storage-info get [cid] [flags]
```

### Options

```
  -h, --help   help for get
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-info](pow_storage-info.md)	 - Provides commands to get and query cid storage info.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-info_list.md ---
## pow storage-info list

Returns a list of information about all stored cids, filtered by cids if provided.

### Synopsis

Returns a list of information about all stored cids, filtered by cids if provided.

```
pow storage-info list [optional cid1,cid2,...] [flags]
```

### Options

```
  -h, --help   help for list
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-info](pow_storage-info.md)	 - Provides commands to get and query cid storage info.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs.md ---
## pow storage-jobs

Provides commands to query for storage jobs in various states

### Synopsis

Provides commands to query for storage jobs in various statess

### Options

```
  -h, --help   help for storage-jobs
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow storage-jobs cancel](pow_storage-jobs_cancel.md)	 - Cancel an executing storage job
* [pow storage-jobs cancel-executing](pow_storage-jobs_cancel-executing.md)	 - Cancel all executing jobs
* [pow storage-jobs cancel-queued](pow_storage-jobs_cancel-queued.md)	 - Cancel all queued jobs
* [pow storage-jobs get](pow_storage-jobs_get.md)	 - Get a storage job's current status
* [pow storage-jobs list](pow_storage-jobs_list.md)	 - List storage jobs according to query flag options.
* [pow storage-jobs storage-config](pow_storage-jobs_storage-config.md)	 - Get the StorageConfig associated with the specified job
* [pow storage-jobs summary](pow_storage-jobs_summary.md)	 - Give a summary of storage jobs in all states
* [pow storage-jobs watch](pow_storage-jobs_watch.md)	 - Watch for storage job status updates

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_cancel-executing.md ---
## pow storage-jobs cancel-executing

Cancel all executing jobs

### Synopsis

Cancel all executing jobs

```
pow storage-jobs cancel-executing [flags]
```

### Options

```
  -h, --help   help for cancel-executing
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_cancel-queued.md ---
## pow storage-jobs cancel-queued

Cancel all queued jobs

### Synopsis

Cancel all queued jobs

```
pow storage-jobs cancel-queued [flags]
```

### Options

```
  -h, --help   help for cancel-queued
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_cancel.md ---
## pow storage-jobs cancel

Cancel an executing storage job

### Synopsis

Cancel an executing storage job

```
pow storage-jobs cancel [jobid] [flags]
```

### Options

```
  -h, --help   help for cancel
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_get.md ---
## pow storage-jobs get

Get a storage job's current status

### Synopsis

Get a storage job's current status

```
pow storage-jobs get [jobid] [flags]
```

### Options

```
  -h, --help   help for get
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_list.md ---
## pow storage-jobs list

List storage jobs according to query flag options.

### Synopsis

List storage jobs according to query flag options.

```
pow storage-jobs list [flags]
```

### Options

```
  -a, --ascending       sort results ascending by time
  -c, --cid string      return results only for the specified cid
  -h, --help            help for list
  -l, --limit uint      limit the number of results returned
  -s, --select string   return only results using the specified selector: all, queued, executing, final (default "all")
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_storage-config.md ---
## pow storage-jobs storage-config

Get the StorageConfig associated with the specified job

### Synopsis

Get the StorageConfig associated with the specified job

```
pow storage-jobs storage-config [job-id] [flags]
```

### Options

```
  -h, --help   help for storage-config
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_summary.md ---
## pow storage-jobs summary

Give a summary of storage jobs in all states

### Synopsis

Give a summary of storage jobs in all states

```
pow storage-jobs summary [optional cid] [flags]
```

### Options

```
  -h, --help   help for summary
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_storage-jobs_watch.md ---
## pow storage-jobs watch

Watch for storage job status updates

### Synopsis

Watch for storage job status updates

```
pow storage-jobs watch [jobid,...] [flags]
```

### Options

```
  -h, --help   help for watch
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow storage-jobs](pow_storage-jobs.md)	 - Provides commands to query for storage jobs in various states

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_version.md ---
## pow version

Display version information for pow and the connected server

### Synopsis

Display version information for pow and the connected server

```
pow version [flags]
```

### Options

```
  -h, --help   help for version
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet.md ---
## pow wallet

Provides commands about filecoin wallets

### Synopsis

Provides commands about filecoin wallets

### Options

```
  -h, --help   help for wallet
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow](pow.md)	 - A client for storage and retreival of powergate data
* [pow wallet addrs](pow_wallet_addrs.md)	 - Print all wallet addresses for the current user
* [pow wallet balance](pow_wallet_balance.md)	 - Print the balance of the specified wallet address
* [pow wallet new-addr](pow_wallet_new-addr.md)	 - Create a new wallet address
* [pow wallet send](pow_wallet_send.md)	 - Send fil from one managed address to any other address
* [pow wallet sign](pow_wallet_sign.md)	 - Signs a message with user wallet addresses.
* [pow wallet verify](pow_wallet_verify.md)	 - Verifies the signature of a message signed with a user wallet address.

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_addrs.md ---
## pow wallet addrs

Print all wallet addresses for the current user

### Synopsis

Print all wallet addresses for the current user

```
pow wallet addrs [flags]
```

### Options

```
  -h, --help   help for addrs
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_balance.md ---
## pow wallet balance

Print the balance of the specified wallet address

### Synopsis

Print the balance of the specified wallet address

```
pow wallet balance [address] [flags]
```

### Options

```
  -h, --help   help for balance
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_new-addr.md ---
## pow wallet new-addr

Create a new wallet address

### Synopsis

Create a new wallet address

```
pow wallet new-addr [name] [flags]
```

### Options

```
  -d, --default         Make the new address the user default
  -f, --format string   Optionally specify address format bls or secp256k1
  -h, --help            help for new-addr
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_send.md ---
## pow wallet send

Send fil from one managed address to any other address

### Synopsis

Send fil from one managed address to any other address

```
pow wallet send [from address] [to address] [amount] [flags]
```

### Options

```
  -h, --help   help for send
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_sign.md ---
## pow wallet sign

Signs a message with user wallet addresses.

### Synopsis

Signs a message using all wallet addresses associated with the user

```
pow wallet sign [hex-encoded-message] [flags]
```

### Options

```
  -h, --help   help for sign
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cli-docs/pow/pow_wallet_verify.md ---
## pow wallet verify

Verifies the signature of a message signed with a user wallet address.

### Synopsis

Verifies the signature of a message signed with a user wallet address.

```
pow wallet verify [addr] [hex-encoded-message] [hex-encoded-signature] [flags]
```

### Options

```
  -h, --help   help for verify
```

### Options inherited from parent commands

```
      --serverAddress string   address of the powergate service api (default "127.0.0.1:5002")
  -t, --token string           user auth token
```

### SEE ALSO

* [pow wallet](pow_wallet.md)	 - Provides commands about filecoin wallets

'''
'''--- Filecoin/powergate/cmd/migrtest/README.md ---
# migrtest

`migrtest` is a tool for testing migrations on real data. This tools allows to run migrations on databases in a safe way since they're run in a copy of the target database. This tool is useful while developing new migrations, or to Powergate operations which might want to test a new release which has migrations on real data to see if something bad would happen in the real update.

## Usage

Run `migrtest -h` to know about the available flags.

### Target a remote `go-datastore` and run locally
```bash
migrtool --origin-remote "$MONGO_URI;$MONGO_DBNAME"
```
This command will:
- Create a folder `run_<TIMESTAMP>` which will have the run assets.
- Make a copy of the remote `go-datastore` to `run_<TIMESTAMP>/badger-migrated`.
- Run all detected/needed migrations in the copied datastore.
- Print to stdout Powergate output while doing the migrations.
- `run_<TIMESTAMP>/badger-migrated` will be the migrated `go-datastore` that might be useful for inspection.

###  Target a remote `go-datastore` and run remotely
```bash
migrtool --origin-remote "$MONGO_URI;$MONGO_DBNAME" --run-remote
```
This command will:
- Create a folder `run_<TIMESTAMP>` which will have the run assets.
- Make a copy of the remote `go-datastore` to the same MongoDB cluster, in a fixed `tmp_powergate_migrtest` database, with a collection name `run_<TIMESTAMP>`.
- Run all detected/needed migrations in the copied datastore.
- Print to stdout Powergate output while doing the migrations.
- The remote collection is kept that might be useful for inspection.

This setup is useful to double-check that running using `go-ds-mongo` client works correctly. This may be slower since it's targeting a remote datastore, but as close as simulating the real migration as possible.

Recall that you should delete the remote databases if not needed anymore. They're all under the same database `tmp_pow_migrtest`, so you can simply delete that database for cleaning all runs.

### Target a remote `go-datastore` and skip the migration
This setup might be useful to just have a local copy of the remote `go-datastore`.
```bash
migrtool --origin-remote "$MONGO_URI;$MONGO_DBNAME" --skip-migrations
```
This command will:
- Create a folder `run_<TIMESTAMP>` which will have the run assets.
- Make a copy of the remote `go-datastore` to the same MongoDB cluster, in a fixed `tmp_powergate_migrtest` database, with a collection name `run_<TIMESTAMP>`.

'''
'''--- Filecoin/powergate/cmd/migrtest/main.go ---
package main

import (
	"fmt"
	"path"
	"strings"
	"time"

	"github.com/ipfs/go-datastore"
	logger "github.com/ipfs/go-log/v2"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"github.com/textileio/dsutils/clone"
	"github.com/textileio/powergate/v2/api/server"
	"github.com/textileio/powergate/v2/migration"
)

const (
	tmpRemoteMongoDB = "tmp_pow_migrtest"
)

var (
	log = logger.Logger("migrtest")
)

func main() {
	config := viper.New()
	logger.SetAllLoggers(logger.LevelInfo)

	if err := wireFlagsAndEnvs(config); err != nil {
		log.Fatalf("wiring flags/envs: %s", err)
	}

	var (
		err      error
		copiedDS datastore.TxnDatastore

		runName        = fmt.Sprintf("run_%s", time.Now().Format("2006-01-02-15:04:05"))
		originRemote   = config.GetString("origin-remote")
		runRemote      = config.GetBool("run-remote")
		verbose        = config.GetBool("verbose")
		skipMigrations = config.GetBool("skip-migrations")
	)
	defer log.Infof("Inspect folder %s to see migration assets.", runName)

	switch {
	case len(originRemote) > 0:
		mongoSplits := strings.Split(originRemote, ";")
		mongoURI := mongoSplits[0]
		mongoDatabase := mongoSplits[1]

		if runRemote {
			copiedDS, err = clone.CloneFromRemoteToRemote(mongoURI, mongoDatabase, "kvstore", mongoURI, tmpRemoteMongoDB, runName, 5000, verbose)
			if err != nil {
				log.Fatalf("cloning remote to local: %s", err)
			}
		} else {
			badgerPath := path.Join(runName, "badger-migrated")
			copiedDS, err = clone.CloneFromRemoteToLocal(mongoURI, mongoDatabase, "kvstore", badgerPath, 1000, verbose)
			if err != nil {
				log.Fatalf("cloning remote to local: %s", err)
			}
		}

	default:
		log.Fatalf("unsupported flag combination")
	}

	if skipMigrations {
		log.Warnf("Skipping migrations, your detination datastore is a clean copy of the origin")
		return
	}

	m := migration.New(copiedDS, server.Migrations)
	if err = m.Ensure(); err != nil {
		log.Fatalf("running migrations: %s", err)
	}
}

func wireFlagsAndEnvs(config *viper.Viper) error {
	pflag.String("origin-remote", "", "(MongoDBURI;database-name)")
	pflag.Bool("run-remote", false, "Copies the origin to the remote to test the migration remotely. If not set, runs locally.")
	pflag.Bool("verbose", false, "Verbose output")
	pflag.Bool("skip-migrations", false, "Skips running migrations, the destination datastore would remain a clean copy of the origin")
	pflag.Parse()

	config.SetEnvPrefix("MIGRTEST")
	config.AutomaticEnv()
	if err := config.BindPFlags(pflag.CommandLine); err != nil {
		return fmt.Errorf("binding flags: %s", err)
	}

	return nil
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/admin.go ---
package admin

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/data"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storageinfo"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storagejobs"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/users"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/wallet"
)

func init() {
	Cmd.PersistentFlags().String("admin-token", "", "admin auth token")

	Cmd.AddCommand(
		data.Cmd,
		storagejobs.Cmd,
		storageinfo.Cmd,
		users.Cmd,
		wallet.Cmd,
	)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "admin",
	Short: "Provides admin commands",
	Long:  `Provides admin commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/data/data.go ---
package data

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/data/gcstaged"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/data/pinnedcids"
)

func init() {
	Cmd.AddCommand(gcstaged.Cmd, pinnedcids.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "data",
	Short: "Provides admin data commands",
	Long:  `Provides admin data commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/data/gcstaged/gcstaged.go ---
package gcstaged

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "gcstaged",
	Short: "Unpins unused staged data.",
	Long:  `Unpins staged data not used by queued or executing jobs.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.Data.GCStaged(c.AdminAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/data/pinnedcids/pinnedcids.go ---
package pinnedcids

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "pinnedcids",
	Short: "List pinned cids information in hot-storage.",
	Long:  "List pinned cids information in hot-storage.",
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.Data.PinnedCids(c.AdminAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storageinfo/get/get.go ---
package get

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "get [user-id] [cid]",
	Short: "Returns the information about a stored cid.",
	Long:  `Returns the information about a stored cid.`,
	Args:  cobra.ExactArgs(2),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.StorageInfo.Get(c.MustAuthCtx(ctx), args[0], args[1])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res.StorageInfo)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storageinfo/list/list.go ---
package list

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringSlice("user-ids", nil, "filter results by provided user ids.")
	Cmd.Flags().StringSlice("cids", nil, "filter results by provided cids.")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "list",
	Short: "Returns a list of information about all stored cids, filtered by user ids and cids if provided.",
	Long:  `Returns a list of information about all stored cids, filtered by user ids and cids if provided.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		userIDs := viper.GetStringSlice("user-ids")
		cids := viper.GetStringSlice("cids")

		res, err := c.PowClient.Admin.StorageInfo.List(c.MustAuthCtx(ctx), userIDs, cids)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storageinfo/storageinfo.go ---
package storageinfo

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storageinfo/get"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storageinfo/list"
)

func init() {
	Cmd.AddCommand(get.Cmd, list.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "storage-info",
	Short: "Provides admin storage info commands",
	Long:  `Provides admin storage info commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storagejobs/list/list.go ---
package list

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client/admin"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringP("user", "u", "", "return results only for the specified user id")
	Cmd.Flags().StringP("cid", "c", "", "return results only for the specified cid")
	Cmd.Flags().Uint64P("limit", "l", 0, "limit the number of results returned")
	Cmd.Flags().BoolP("ascending", "a", false, "sort results ascending by time")
	Cmd.Flags().StringP("select", "s", "all", "return only results using the specified selector: all, queued, executing, final")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "list",
	Short: "List storage jobs according to query flag options.",
	Long:  `List storage jobs according to query flag options.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var sel admin.ListSelect
		selIn := viper.GetString("select")
		switch selIn {
		case "all":
			sel = admin.All
		case "queued":
			sel = admin.Queued
		case "executing":
			sel = admin.Executing
		case "final":
			sel = admin.Final
		default:
			c.CheckErr(fmt.Errorf("invalid option for --select: %s", selIn))
		}

		conf := admin.ListConfig{
			UserIDFilter: viper.GetString("user"),
			CidFilter:    viper.GetString("cid"),
			Limit:        viper.GetUint64("limit"),
			Ascending:    viper.GetBool("ascending"),
			Select:       sel,
		}

		res, err := c.PowClient.Admin.StorageJobs.List(c.MustAuthCtx(ctx), conf)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storagejobs/storagejobs.go ---
package storagejobs

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storagejobs/list"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/storagejobs/summary"
)

func init() {
	Cmd.AddCommand(summary.Cmd, list.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:     "storage-jobs",
	Aliases: []string{"storage-job"},
	Short:   "Provides admin jobs commands",
	Long:    `Provides admin jobs commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/storagejobs/summary/summary.go ---
package summary

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client/admin"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringP("user-id", "u", "", "optional user id filter to apply")
	Cmd.Flags().StringP("cid", "c", "", "optional cid filter to apply")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "summary",
	Short: "Give a summary of storage jobs in all states",
	Long:  `Give a summary of storage jobs in all states`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var opts []admin.SummaryOption
		if viper.IsSet("user-id") {
			opts = append(opts, admin.WithUserID(viper.GetString("user-id")))
		}
		if viper.IsSet("cid") {
			opts = append(opts, admin.WithCid(viper.GetString("cid")))
		}

		res, err := c.PowClient.Admin.StorageJobs.Summary(c.AdminAuthCtx(ctx), opts...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/users/create/create.go ---
package create

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "create",
	Short: "Create a Powergate user.",
	Long:  `Create a Powergate user.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.Users.Create(c.AdminAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/users/list/list.go ---
package list

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "list",
	Short: "List all Powergate users.",
	Long:  `List all Powergate users.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.Users.List(c.AdminAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/users/regenerate/regenerate.go ---
package regenerate

import (
	"context"
	"errors"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "regenerate [token-to-regenerate]",
	Short: "Invalidates an existing token and replaces it with a new one.",
	Long:  `Invalidates an existing token and replaces it with a new one.`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		if len(args) != 1 {
			c.Fatal(errors.New("token argument is mandatory"))
		}

		res, err := c.PowClient.Admin.Users.RegenerateAuth(c.AdminAuthCtx(ctx), args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/users/users.go ---
package users

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/users/create"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/users/list"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/users/regenerate"
)

func init() {
	Cmd.AddCommand(create.Cmd, list.Cmd, regenerate.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:     "users",
	Aliases: []string{"user"},
	Short:   "Provides admin users commands",
	Long:    `Provides admin users commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/wallet/addrs/addrs.go ---
package addrs

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "addrs",
	Short: "List all addresses associated with this Powergate.",
	Long:  `List all addresses associated with this Powergate.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Admin.Wallet.Addresses(c.AdminAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/wallet/new/new.go ---
package new

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringP("format", "f", "bls", "Optionally specify address format bls or secp256k1")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "new",
	Short: "Creates a new walllet address.",
	Long:  `Creates a new wallet address.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		format := viper.GetString("format")

		res, err := c.PowClient.Admin.Wallet.NewAddress(c.AdminAuthCtx(ctx), format)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/wallet/send/send.go ---
package send

import (
	"context"
	"fmt"
	"math/big"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "send [from] [to] [amount]",
	Short: "Sends FIL from an address associated with this Powergate to any other address.",
	Long:  `Sends FIL from an address associated with this Powergate to any other address.`,
	Args:  cobra.ExactArgs(3),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		amount, ok := new(big.Int).SetString(args[2], 10)
		if !ok {
			c.CheckErr(fmt.Errorf("parsing amount %v", args[2]))
		}

		res, err := c.PowClient.Admin.Wallet.SendFil(c.AdminAuthCtx(ctx), args[0], args[1], amount)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/admin/wallet/wallet.go ---
package wallet

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/wallet/addrs"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/wallet/new"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin/wallet/send"
)

func init() {
	Cmd.AddCommand(addrs.Cmd, new.Cmd, send.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "wallet",
	Short: "Provides admin wallet commands",
	Long:  `Provides admin wallet commands`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/config/apply/apply.go ---
package apply

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"strconv"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

var (
	log = logging.Logger("apply")
)

func init() {
	Cmd.Flags().StringP("conf", "c", "", "Optional path to a file containing storage config json, falls back to stdin, uses the user default by default")
	Cmd.Flags().BoolP("override", "o", false, "If set, override any pre-existing storage configuration for the cid")
	Cmd.Flags().BoolP("noexec", "e", false, "If set, it doesn't create a job to ensure the new configuration")
	Cmd.Flags().BoolP("watch", "w", false, "Watch the progress of the resulting job")
	Cmd.Flags().StringSliceP("import-deals", "i", nil, "Comma-separated list of deal ids to import")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "apply [cid]",
	Short: "Apply the default or provided storage config to the specified cid",
	Long:  `Apply the default or provided storage config to the specified cid`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		configPath := viper.GetString("conf")

		var reader io.Reader
		if len(configPath) > 0 {
			file, err := os.Open(configPath)
			defer func() {
				if err := file.Close(); err != nil {
					log.Errorf("closing config file: %s", err)
				}
			}()
			reader = file
			c.CheckErr(err)
		} else {
			stat, _ := os.Stdin.Stat()
			// stdin is being piped in (not being read from terminal)
			if (stat.Mode() & os.ModeCharDevice) == 0 {
				reader = cmd.InOrStdin()
			}
		}

		options := []client.ApplyOption{}

		if reader != nil {
			buf := new(bytes.Buffer)
			_, err := buf.ReadFrom(reader)
			c.CheckErr(err)

			config := &userPb.StorageConfig{}
			err = protojson.UnmarshalOptions{}.Unmarshal(buf.Bytes(), config)
			c.CheckErr(err)

			options = append(options, client.WithStorageConfig(config))
		}

		if viper.IsSet("override") {
			options = append(options, client.WithOverride(viper.GetBool("override")))
		}

		if viper.IsSet("noexec") {
			options = append(options, client.WithNoExec(viper.GetBool("noexec")))
		}

		if viper.IsSet("import-deals") {
			csvDealIDs := viper.GetStringSlice("import-deals")
			var dealIDs []uint64
			for _, strDealID := range csvDealIDs {
				dealID, err := strconv.ParseUint(strDealID, 10, 64)
				c.CheckErr(err)
				dealIDs = append(dealIDs, dealID)
			}
			options = append(options, client.WithImportDealIDs(dealIDs))
		}

		res, err := c.PowClient.StorageConfig.Apply(c.MustAuthCtx(ctx), args[0], options...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))

		if viper.GetBool("watch") {
			c.WatchJobIds(res.JobId)
		}
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/config/config.go ---
package config

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/config/apply"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/config/getdefault"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/config/remove"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/config/setdefault"
)

func init() {
	Cmd.AddCommand(apply.Cmd, getdefault.Cmd, remove.Cmd, setdefault.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "config",
	Short: "Provides commands to interact with cid storage configs",
	Long:  `Provides commands to interact with cid storage configs`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/config/getdefault/getdefault.go ---
package getdefault

import (
	"context"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "default",
	Short: "Returns the default storage config",
	Long:  `Returns the default storage config`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		res, err := c.PowClient.StorageConfig.Default(c.MustAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res.DefaultStorageConfig)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/config/remove/remove.go ---
package remove

import (
	"context"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "remove [cid]",
	Short: "Removes a Cid from being tracked as an active storage",
	Long:  `Removes a Cid from being tracked as an active storage. The Cid should have both Hot and Cold storage disabled, if that isn't the case it will return ErrActiveInStorage`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()
		_, err := c.PowClient.StorageConfig.Remove(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/config/setdefault/setdefault.go ---
package setdefault

import (
	"bytes"
	"context"
	"io"
	"os"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

var (
	log = logging.Logger("setdefault")
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "set-default [optional file]",
	Short: "Sets the default storage config from stdin or a file",
	Long:  `Sets the default storage config from stdin or a file`,
	Args:  cobra.MaximumNArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		var reader io.Reader
		if len(args) > 0 {
			file, err := os.Open(args[0])
			defer func() {
				if err := file.Close(); err != nil {
					log.Errorf("closing config file: %s", err)
				}
			}()
			reader = file
			c.CheckErr(err)
		} else {
			reader = cmd.InOrStdin()
		}

		buf := new(bytes.Buffer)
		_, err := buf.ReadFrom(reader)
		c.CheckErr(err)

		config := &userPb.StorageConfig{}
		err = protojson.UnmarshalOptions{}.Unmarshal(buf.Bytes(), config)
		c.CheckErr(err)

		_, err = c.PowClient.StorageConfig.SetDefault(c.MustAuthCtx(ctx), config)
		c.CheckErr(err)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/data.go ---
package data

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/get"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/info"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/log"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/replace"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/stage"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data/summary"
)

func init() {
	Cmd.AddCommand(get.Cmd, info.Cmd, log.Cmd, replace.Cmd, stage.Cmd, summary.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "data",
	Short: "Provides commands to interact with general data APIs",
	Long:  `Provides commands to interact with general data APIs`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/get/get.go ---
package get

import (
	"context"
	"io"
	"os"
	"path"
	"time"

	"github.com/caarlos0/spin"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

func init() {
	Cmd.Flags().String("ipfsrevproxy", "localhost:6002", "Powergate IPFS reverse proxy DNS address. If port 443, is assumed is a HTTPS endpoint.")
	Cmd.Flags().BoolP("folder", "f", false, "Indicates that the retrieved Cid is a folder")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "get [cid] [output file path]",
	Short: "Get data stored by the user by cid",
	Long:  `Get data stored by the user by cid`,
	Args:  cobra.ExactArgs(2),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Hour*8)
		defer cancel()

		s := spin.New("%s Retrieving specified data...")
		s.Start()

		isFolder := viper.GetBool("folder")
		if isFolder {
			err := c.PowClient.Data.GetFolder(c.MustAuthCtx(ctx), viper.GetString("ipfsrevproxy"), args[0], args[1])
			c.CheckErr(err)
		} else {
			reader, err := c.PowClient.Data.Get(c.MustAuthCtx(ctx), args[0])
			c.CheckErr(err)

			dir := path.Dir(args[1])
			if _, err := os.Stat(dir); os.IsNotExist(err) {
				err = os.MkdirAll(dir, os.ModePerm)
				c.CheckErr(err)
			}
			file, err := os.Create(args[1])
			c.CheckErr(err)

			defer func() { c.CheckErr(file.Close()) }()

			buffer := make([]byte, 1024*32) // 32KB
			for {
				bytesRead, readErr := reader.Read(buffer)
				if readErr != nil && readErr != io.EOF {
					c.Fatal(readErr)
				}
				_, err = file.Write(buffer[:bytesRead])
				c.CheckErr(err)
				if readErr == io.EOF {
					break
				}
			}
		}
		s.Stop()
		c.Success("Data written to %v", args[1])
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/info/info.go ---
package info

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "info cid",
	Short: "Get information about the current storage state of a cid",
	Long:  `Get information about the current storage state of a cid`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Data.CidInfo(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/log/log.go ---
package log

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

func init() {
	Cmd.Flags().StringP("jid", "j", "", "Display information for only this job id")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:     "log [cid]",
	Aliases: []string{"logs"},
	Short:   "Display logs for specified cid",
	Long:    `Display logs for specified cid`,
	Args:    cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		opts := []client.WatchLogsOption{client.WithHistory(true)}
		jid := viper.GetString("jid")
		if jid != "" {
			opts = append(opts, client.WithJobIDFilter(jid))
		}

		ch := make(chan client.WatchLogsEvent)
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		err := c.PowClient.Data.WatchLogs(c.MustAuthCtx(ctx), ch, args[0], opts...)
		c.CheckErr(err)

		interrupt := make(chan os.Signal)
		signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)
		go func() {
			<-interrupt
			cancel()
			os.Exit(0)
		}()

		for {
			event, ok := <-ch
			if !ok {
				break
			}
			if event.Err != nil {
				c.Fatal(event.Err)
				break
			}
			ts := time.Unix(event.Res.LogEntry.Time, 0)
			c.Message("%v - %v", ts.Format("2006-01-02T15:04:05"), event.Res.LogEntry.Message)
		}
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/replace/replace.go ---
package replace

import (
	"context"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().BoolP("watch", "w", false, "Watch the progress of the resulting job")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "replace [cid1] [cid2]",
	Short: "Applies a StorageConfig for c2 equal to that of c1, and removes c1",
	Long:  `Applies a StorageConfig for c2 equal to that of c1, and removes c1. This operation is more efficient than manually removing and adding in two separate operations`,
	Args:  cobra.ExactArgs(2),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		res, err := c.PowClient.Data.ReplaceData(c.MustAuthCtx(ctx), args[0], args[1])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))

		if viper.GetBool("watch") {
			c.WatchJobIds(res.JobId)
		}
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/stage/stage.go ---
package stage

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().String("ipfsrevproxy", "127.0.0.1:6002", "Powergate IPFS reverse proxy multiaddr")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "stage [path|url]",
	Short: "Temporarily stage data in Hot Storage in preparation for applying a cid storage config",
	Long:  `Temporarily stage data in Hot Storage in preparation for applying a cid storage config`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Hour*8)
		defer cancel()

		if strings.HasPrefix(strings.ToLower(args[0]), "http") {
			res, err := http.DefaultClient.Get(args[0])
			c.CheckErr(err)
			defer func() { c.CheckErr(res.Body.Close()) }()
			stageReader(ctx, res.Body)
			return
		}

		fi, err := os.Stat(args[0])
		if os.IsNotExist(err) {
			c.Fatal(errors.New("file/folder doesn't exist"))
		}
		if err != nil {
			c.Fatal(fmt.Errorf("getting file/folder information: %s", err))
		}
		if fi.IsDir() {
			cid, err := c.PowClient.Data.StageFolder(c.MustAuthCtx(ctx), viper.GetString("ipfsrevproxy"), args[0])
			c.CheckErr(err)
			c.Success("Staged folder with cid: %s", cid)
		} else {
			f, err := os.Open(args[0])
			c.CheckErr(err)
			defer func() { c.CheckErr(f.Close()) }()
			stageReader(ctx, f)
		}
	},
}

func stageReader(ctx context.Context, reader io.Reader) {
	res, err := c.PowClient.Data.Stage(c.MustAuthCtx(ctx), reader)
	c.CheckErr(err)

	json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
	c.CheckErr(err)

	fmt.Println(string(json))
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/summary/summary.go ---
package summary

import (
	"context"
	"fmt"
	"os"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().BoolP("json", "j", false, "output data in raw json instead of an interactive ui")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "summary [optional cid1,cid2,...]",
	Short: "Get a summary about the current storage and jobs state of cids",
	Long:  `Get a summary about the current storage and jobs state of cids`,
	Args:  cobra.MaximumNArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		var cids []string
		if len(args) > 0 {
			cids = strings.Split(args[0], ",")
		}

		json := viper.GetBool("json")

		if json {
			res, err := getSummary(cids)
			c.CheckErr(err)

			json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
			c.CheckErr(err)

			fmt.Println(string(json))
			return
		}

		p := tea.NewProgram(model{cids: cids})
		if err := p.Start(); err != nil {
			fmt.Printf("Alas, there's been an error: %v", err)
			os.Exit(1)
		}
	},
}

func getSummary(cids []string) (*userPb.CidSummaryResponse, error) {
	ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
	defer cancel()
	return c.PowClient.Data.CidSummary(c.MustAuthCtx(ctx), cids...)
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/data/summary/tui.go ---
package summary

import (
	"context"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/mattn/go-runewidth"
	"github.com/muesli/termenv"
	"github.com/olekukonko/tablewriter"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

const (
	headerHeight = 0
	footerHeight = 2
)

var (
	term = termenv.ColorProfile()
)

type model struct {
	cids           []string
	summary        []*userPb.CidSummary
	summaryYOffset int
	cidInfo        *userPb.CidInfo
	err            error
	cursor         int
	viewport       viewport.Model
	ready          bool
}

func (m model) Init() tea.Cmd {
	return getSummaryCmd(m.cids)
}

func getSummaryCmd(cids []string) tea.Cmd {
	return func() tea.Msg {
		res, err := getSummary(cids)
		if err != nil {
			return errMsg{err}
		}
		return res
	}
}

func getInfo(cid string) tea.Cmd {
	return func() tea.Msg {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Data.CidInfo(c.MustAuthCtx(ctx), cid)
		if err != nil {
			return errMsg{err}
		}
		return res.CidInfo
	}
}

type errMsg struct{ err error }

// For messages that contain errors it's often handy to also implement the
// error interface on the message.
func (e errMsg) Error() string { return e.err.Error() }

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	m.viewport, _ = m.viewport.Update(msg)

	switch msg := msg.(type) {
	case *userPb.CidSummaryResponse:
		m.summary = msg.CidSummary
		m.viewport.SetContent(m.getViewportContent())
		return m, nil

	case *userPb.CidInfo:
		m.cidInfo = msg
		m.viewport.SetContent(m.getViewportContent())
		m.viewport.YOffset = 0
		return m, nil

	case errMsg:
		m.err = msg
		return m, tea.Quit

	case tea.WindowSizeMsg:
		verticalMargins := headerHeight + footerHeight
		if !m.ready {
			m.viewport = viewport.Model{Width: msg.Width, Height: msg.Height - verticalMargins}
			m.viewport.SetContent(m.getViewportContent())
			m.ready = true
		} else {
			m.viewport.Width = msg.Width
			m.viewport.Height = msg.Height - verticalMargins
		}

	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyCtrlC:
			return m, tea.Quit

		case tea.KeyUp:
			if m.cidInfo == nil && m.cursor > 0 {
				m.cursor--
				m.summaryYOffset = m.viewport.YOffset
				m.viewport.SetContent(m.getViewportContent())
			}

		case tea.KeyDown:
			if m.cidInfo == nil && m.cursor < len(m.summary)-1 {
				m.cursor++
				m.summaryYOffset = m.viewport.YOffset
				m.viewport.SetContent(m.getViewportContent())
			}

		case tea.KeyLeft:
			m.cidInfo = nil
			m.viewport.SetContent(m.getViewportContent())
			m.viewport.YOffset = m.summaryYOffset

		case tea.KeyEnter, tea.KeySpace:
			if len(m.summary) > 0 {
				return m, getInfo(m.summary[m.cursor].Cid)
			}
		}
	}

	return m, nil
}

func (m model) View() string {
	if !m.ready {
		return "\n  Initializing..."
	}

	if m.err != nil {
		return fmt.Sprintf("\nWe had some trouble: %v\n\n", m.err)
	}

	footerTop := termenv.String(strings.Repeat("â", m.viewport.Width)).Foreground(term.Color("241")).String()
	footerBottomLeft := m.getFooterContent()
	fits := m.viewport.AtTop() && (m.viewport.AtBottom() || m.viewport.PastBottom())
	footerBottomRight := fmt.Sprintf("%3.f%% ", m.viewport.ScrollPercent()*100)
	if fits {
		footerBottomRight = ""
	}
	gapSize := m.viewport.Width - (runewidth.StringWidth(footerBottomLeft) + runewidth.StringWidth(footerBottomRight))
	footerBottom := termenv.String(footerBottomLeft + strings.Repeat(" ", gapSize) + footerBottomRight).Foreground(term.Color("241")).String()

	footer := fmt.Sprintf("%s\n%s", footerTop, footerBottom)

	return fmt.Sprintf("%s\n%s", m.viewport.View(), footer)
}

func (m model) getViewportContent() string {
	if m.cidInfo != nil {
		return renderCidInfo(m.cidInfo)
	} else if m.summary != nil {
		return renderSummary(m.summary, m.cursor)
	}
	return "Loading..."
}

func (m model) getFooterContent() string {
	if m.cidInfo != nil {
		return " â: Back â¢ Ctrl+C: Quit"
	} else if m.summary != nil {
		return " â/â: Select â¢ Enter: View Seleted â¢ Ctrl+C: Quit"
	}
	return "Ctrl+C: Quit"
}

func renderCidInfo(cidInfo *userPb.CidInfo) string {
	json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(cidInfo)
	if err != nil {
		return fmt.Sprintf("error marshaling json: %v", err)
	}
	return fmt.Sprintf("%s\n", string(json))
}

func renderSummary(summary []*userPb.CidSummary, cursor int) string {
	s := &strings.Builder{}

	// Set table header
	table := tablewriter.NewWriter(s)
	table.SetHeader([]string{"Cid", "Stored", "Executing Job", "Queued Jobs"})
	table.SetColumnAlignment([]int{tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_RIGHT})

	// Add data to table
	for i, v := range summary {
		data := []string{
			v.Cid,
			fmt.Sprintf("%v", v.Stored),
			fmt.Sprintf("%v", len(v.ExecutingJob) > 0),
			fmt.Sprintf("%v", len(v.QueuedJobs)),
		}
		if cursor == i {
			// Color active item
			c := tablewriter.Colors{tablewriter.FgBlackColor, tablewriter.BgWhiteColor}
			var colors []tablewriter.Colors
			for range data {
				colors = append(colors, c)
			}
			table.Rich(data, colors)
		} else {
			table.Append(data)
		}
	}

	table.Render()
	return s.String()
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/deals/deals.go ---
package deals

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/deals/retrievals"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/deals/storage"
)

func init() {
	Cmd.AddCommand(retrievals.Cmd, storage.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "deals",
	Short: "Provides commands to view Filecoin deal information",
	Long:  `Provides commands to view Filecoin deal information`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/deals/retrievals/retrievals.go ---
package retrievals

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().BoolP("ascending", "a", false, "sort records ascending, default is descending")
	Cmd.Flags().StringSlice("cids", []string{}, "limit the records to deals for the specified data cids")
	Cmd.Flags().StringSlice("addrs", []string{}, "limit the records to deals initiated from  the specified wallet addresses")
	Cmd.Flags().BoolP("include-failed", "e", false, "include failed retrievals")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "retrievals",
	Short: "List retrieval deal records for the user",
	Long:  `List retrieval deal records for the user`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var opts []client.DealRecordsOption

		if viper.IsSet("ascending") {
			opts = append(opts, client.WithAscending(viper.GetBool("ascending")))
		}
		if viper.IsSet("cids") {
			opts = append(opts, client.WithDataCids(viper.GetStringSlice("cids")...))
		}
		if viper.IsSet("addrs") {
			opts = append(opts, client.WithFromAddrs(viper.GetStringSlice("addrs")...))
		}
		if viper.IsSet("include-failed") {
			opts = append(opts, client.WithIncludeFailed(viper.GetBool("include-failed")))
		}

		res, err := c.PowClient.Deals.RetrievalDealRecords(c.MustAuthCtx(ctx), opts...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/deals/storage/storage.go ---
package storage

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().BoolP("ascending", "a", false, "sort records ascending, default is sort descending")
	Cmd.Flags().StringSlice("cids", []string{}, "limit the records to deals for the specified data cids, treated as and AND operation if --addrs is also provided")
	Cmd.Flags().StringSlice("addrs", []string{}, "limit the records to deals initiated from  the specified wallet addresses, treated as and AND operation if --cids is also provided")
	Cmd.Flags().BoolP("include-pending", "p", false, "include pending deals")
	Cmd.Flags().BoolP("include-final", "f", false, "include final deals")
	Cmd.Flags().BoolP("include-failed", "e", false, "include failed deals")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "storage",
	Short: "List storage deal records for the user",
	Long:  `List storage deal records for the user`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var opts []client.DealRecordsOption

		if viper.IsSet("ascending") {
			opts = append(opts, client.WithAscending(viper.GetBool("ascending")))
		}
		if viper.IsSet("cids") {
			opts = append(opts, client.WithDataCids(viper.GetStringSlice("cids")...))
		}
		if viper.IsSet("addrs") {
			opts = append(opts, client.WithFromAddrs(viper.GetStringSlice("addrs")...))
		}
		if viper.IsSet("include-pending") {
			opts = append(opts, client.WithIncludePending(viper.GetBool("include-pending")))
		}
		if viper.IsSet("include-final") {
			opts = append(opts, client.WithIncludeFinal(viper.GetBool("include-final")))
		}
		if viper.IsSet("include-failed") {
			opts = append(opts, client.WithIncludeFailed(viper.GetBool("include-failed")))
		}

		res, err := c.PowClient.Deals.StorageDealRecords(c.MustAuthCtx(ctx), opts...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/id/id.go ---
package id

import (
	"context"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "id",
	Short: "Returns the user id",
	Long:  `Returns the user id`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		res, err := c.PowClient.UserID(c.MustAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/pow.go ---
package cmd

import (
	"os"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
	"github.com/spf13/viper"
	client "github.com/textileio/powergate/v2/api/client"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/admin"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/config"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/data"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/deals"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/id"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/prepare"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storageinfo"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/version"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

func init() {
	cobra.OnInitialize(initConfig)
	Cmd.Flags().BoolP("version", "v", false, "display version information for pow and the connected server")
	Cmd.PersistentFlags().String("serverAddress", "127.0.0.1:5002", "address of the powergate service api")
	Cmd.PersistentFlags().StringP("token", "t", "", "user auth token")

	Cmd.AddCommand(admin.Cmd, config.Cmd, data.Cmd, deals.Cmd, id.Cmd, storageinfo.Cmd, storagejobs.Cmd, version.Cmd, wallet.Cmd, docsCmd, prepare.Cmd)
}

func initConfig() {
	viper.SetEnvPrefix("POW")
	viper.AutomaticEnv()
	replacer := strings.NewReplacer("-", "_")
	viper.SetEnvKeyReplacer(replacer)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:               "pow",
	Short:             "A client for storage and retreival of powergate data",
	Long:              `A client for storage and retreival of powergate data`,
	DisableAutoGenTag: true,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlag("serverAddress", cmd.Root().PersistentFlags().Lookup("serverAddress"))
		c.CheckErr(err)

		target := viper.GetString("serverAddress")

		c.PowClient, err = client.NewClient(target)
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		v, err := cmd.Flags().GetBool("version")
		c.CheckErr(err)
		if v {
			version.Cmd.Run(cmd, args)
		} else {
			err := cmd.Help()
			c.CheckErr(err)
		}
	},
}

var docsCmd = &cobra.Command{
	Use:    "docs [outdir]",
	Short:  "Generate markdown docs for pow command",
	Long:   `Generate markdown docs for pow command`,
	Hidden: true,
	Args:   cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		dir := args[0]
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			err = os.MkdirAll(dir, os.ModePerm)
			c.CheckErr(err)
		}
		err := doc.GenMarkdownTree(Cmd, args[0])
		c.CheckErr(err)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/prepare/prepare.go ---
package prepare

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sync"
	"time"

	files "github.com/ipfs/go-ipfs-files"
	unixfile "github.com/ipfs/go-unixfs/file"

	"github.com/cheggaaa/pb/v3"
	"github.com/dustin/go-humanize"
	aggregator "github.com/filecoin-project/go-dagaggregator-unixfs"
	bsrv "github.com/ipfs/go-blockservice"
	"github.com/ipfs/go-car"
	"github.com/ipfs/go-cid"
	badger "github.com/ipfs/go-ds-badger"
	blockstore "github.com/ipfs/go-ipfs-blockstore"
	offline "github.com/ipfs/go-ipfs-exchange-offline"
	httpapi "github.com/ipfs/go-ipfs-http-client"
	ipld "github.com/ipfs/go-ipld-format"
	dag "github.com/ipfs/go-merkledag"
	"github.com/multiformats/go-multiaddr"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"github.com/textileio/powergate/v2/dataprep"
)

func init() {
	Cmd.AddCommand(prepare, genCar, commp)

	prepare.Flags().String("tmpdir", os.TempDir(), "path of folder where a temporal blockstore is created for processing data")
	prepare.Flags().String("ipfs-api", "", "IPFS HTTP API multiaddress that stores the cid (only for Cid processing instead of file/folder path)")
	prepare.Flags().Bool("json", false, "avoid pretty output and use json formatting")
	prepare.Flags().Bool("aggregate", false, "aggregates a folder of files")

	commp.Flags().Bool("json", false, "avoid pretty output and use json formatting")
	commp.Flags().Bool("skip-car-validation", false, "skips CAR validation when processing a path")

	genCar.Flags().String("tmpdir", os.TempDir(), "path of folder where a temporal blockstore is created for processing data")
	genCar.Flags().String("ipfs-api", "", "IPFS HTTP API multiaddress that stores the cid (only for Cid processing instead of file/folder path)")
	genCar.Flags().Bool("quiet", false, "avoid pretty output")
	genCar.Flags().Bool("aggregate", false, "aggregates a folder of files")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "offline",
	Short: "Provides commands to prepare data for Filecoin onbarding",
	Long:  `Provides commands to prepare data for Filecoin onbarding`,
}

var genCar = &cobra.Command{
	Use:   "car [path | cid] [output path]",
	Short: "car generates a CAR file from the data",
	Long: `Generates a CAR file from the data source. This data-source can be a file/folder path or a Cid.

If a file/folder path is provided, this command will DAGify the data and generate the CAR file.
If a Cid is provided, an extra --ipfs-api flag should be provided to connect to the IPFS node that contains this Cid data.`,
	Args: cobra.RangeArgs(1, 2),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		var dataCid cid.Cid
		var err error
		ctx := context.Background()

		w := os.Stdout
		if len(args) == 2 {
			w, err = os.OpenFile(args[1], os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0755)
			if err != nil {
				c.Fatal(fmt.Errorf("creating output file: %s", err))
			}
			defer func() {
				if err := w.Close(); err != nil {
					c.Fatal(fmt.Errorf("closing output file: %s", err))
				}
			}()
		}

		quiet, err := cmd.Flags().GetBool("quiet")
		if err != nil {
			c.Fatal(fmt.Errorf("parsing json flag: %s", err))
		}
		dataCid, dagService, _, cls, err := prepareDAGService(cmd, args, quiet)
		if err != nil {
			c.Fatal(fmt.Errorf("creating dag-service: %s", err))
		}
		defer func() { _ = cls() }()

		if err = car.WriteCar(ctx, dagService, []cid.Cid{dataCid}, w); err != nil {
			c.Fatal(fmt.Errorf("generating car file: %s", err))
		}
	},
}

var commp = &cobra.Command{
	Use:     "commp [path]",
	Aliases: []string{"commP"},
	Short:   "commP calculates the piece size and cid for a CAR file",
	Long: `commP calculates the piece-size and PieceCID for a CAR file.

This command calculates the piece-size and piece-cid (CommP) from a CAR file.
This command only makes sense to run for a CAR file, so it does some quick check if the input file *seems* to be well-formated. 
You can use the --skip-car-validation, but usually shouldn't be done unless you know what you're doing (e.g.: benchmarks, or other tests)`,
	Args: cobra.RangeArgs(0, 1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		r := io.Reader(os.Stdin)
		if len(args) > 0 && args[0] != "-" {
			f, err := os.Open(args[0])
			if err != nil {
				c.Fatal(fmt.Errorf("opening the file %s: %s", args[0], err))
			}
			defer func() { _ = f.Close() }()

			skipCARValidation, err := cmd.Flags().GetBool("skip-car-validation")
			if err != nil {
				c.Fatal(fmt.Errorf("getting skip-car-validation flag: %s", err))
			}
			if !skipCARValidation {
				_, err = car.ReadHeader(bufio.NewReader(f))
				if err != nil {
					c.Fatal(fmt.Errorf("wrong car file format: %s", err))
				}
				if _, err := f.Seek(0, io.SeekStart); err != nil {
					c.Fatal(fmt.Errorf("rewind file to start: %s", err))
				}
			}
			r = f
		}

		pieceCID, pieceSize, err := dataprep.CommP(r)
		if err != nil {
			c.Fatal(fmt.Errorf("calculating commP: %s", err))
		}

		jsonFlag, err := cmd.Flags().GetBool("json")
		if err != nil {
			c.Fatal(fmt.Errorf("parsing json flag: %s", err))
		}
		if jsonFlag {
			printJSONResult(pieceSize, cid.Undef, pieceCID, nil)
			return
		}
		c.Message("Piece-size: %d (%s)", pieceSize, humanize.IBytes(pieceSize))
		c.Message("PieceCID: %s", pieceCID)
	},
}

var prepare = &cobra.Command{
	Use:     "prepare [cid | path] [output CAR file path]",
	Aliases: []string{"prep"},
	Short:   "prepare generates a CAR file for data",
	Long: `Prepares a data source generating all needed to execute an offline deal.
The data source can be a file/folder path or a Cid.

If a file/folder path is provided, this command will DAGify the data and generate the CAR file.
If a Cid is provided, an extra --ipfs-api flag should be provided to connect to the IPFS node that contains this Cid data.

This command prepares data in a more efficiently than running car+commp subcommands, since it already starts calculating CommP at the same time that the CAR file is being generated.

By default prints to stdout the generated CAR file. You can provide a second argument to
specify the output file path, or simply pipe the stdout result.

The piece-size and piece-cid are printed to stderr. For scripting usage, its recommended to use the --json flag.`,
	Args: cobra.RangeArgs(1, 2),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		c.FmtOutput = os.Stderr

		json, err := cmd.Flags().GetBool("json")
		if err != nil {
			c.Fatal(fmt.Errorf("parsing json flag: %s", err))
		}
		aggregate, err := cmd.Flags().GetBool("aggregate")
		if err != nil {
			c.Fatal(fmt.Errorf("aggregate flag: %s", err))
		}
		ipfsAPI, err := cmd.Flags().GetString("ipfs-api")
		if err != nil {
			c.Fatal(fmt.Errorf("get api addr flag: %s", err))
		}
		if ipfsAPI != "" && aggregate {
			c.Fatal(errors.New("the --aggregate flag can't be used with a remote go-ipfs node"))
		}

		payloadCid, dagService, aggrFiles, cls, err := prepareDAGService(cmd, args, json)
		if err != nil {
			c.Fatal(fmt.Errorf("creating temporal dag-service: %s", err))
		}
		defer func() { _ = cls() }()

		ctx := context.Background()

		outputFile := os.Stdout
		if len(args) > 1 {
			outputFile, err = os.OpenFile(args[1], os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0755)
			if err != nil {
				c.Fatal(fmt.Errorf("creating output file: %s", err))
			}
			defer func() {
				if err := outputFile.Close(); err != nil {
					c.Fatal(fmt.Errorf("closing output file: %s", err))
				}
			}()
		}

		if !json {
			c.Message("Creating CAR and calculating piece-size and PieceCID...")
		}
		start := time.Now()
		prCAR, pwCAR := io.Pipe()
		var writeCarErr error
		go func() {
			defer func() {
				if err := pwCAR.Close(); err != nil {
					c.Fatal(fmt.Errorf("closing car writer: %s", err))
				}
			}()
			if err := car.WriteCar(ctx, dagService, []cid.Cid{payloadCid}, pwCAR); err != nil {
				writeCarErr = err
				return
			}
		}()

		prCommP, pwCommP := io.Pipe()
		teeCAR := io.TeeReader(prCAR, pwCommP)
		var (
			errCommP  error
			wg        sync.WaitGroup
			pieceCid  cid.Cid
			pieceSize uint64
		)
		wg.Add(1)
		go func() {
			defer wg.Done()
			pieceCid, pieceSize, errCommP = dataprep.CommP(prCommP)
		}()
		if _, err := io.Copy(outputFile, teeCAR); err != nil {
			c.Fatal(fmt.Errorf("writing CAR file to output: %s", err))
		}
		if writeCarErr != nil {
			c.Fatal(fmt.Errorf("generating CAR file: %s", err))
		}
		if err := pwCommP.Close(); err != nil {
			c.Fatal(fmt.Errorf("closing tee-reader writer: %s", err))
		}
		wg.Wait()
		if errCommP != nil {
			c.Fatal(fmt.Errorf("calculating piece-size and PieceCID: %s", err))
		}

		if aggregate {
			rootNd, err := dagService.Get(ctx, payloadCid)
			if err != nil {
				c.Fatal(fmt.Errorf("get root node: %s", err))
			}
			manifestLnk := rootNd.Links()[0]
			manifestNd, err := dagService.Get(ctx, manifestLnk.Cid)
			if err != nil {
				c.Fatal(fmt.Errorf("get manifest node: %s", err))
			}
			manifestF, err := unixfile.NewUnixfsFile(context.Background(), dagService, manifestNd)
			if err != nil {
				c.Fatal(fmt.Errorf("get unifxfs manifest file: %s", err))
			}
			manifest := manifestF.(files.File)
			fManifest, err := os.Create(args[1] + ".manifest")
			if err != nil {
				c.Fatal(fmt.Errorf("creating manifest file: %s", err))

			}
			defer func() {
				if err := fManifest.Close(); err != nil {
					c.Fatal(fmt.Errorf("closing manifest file: %s", err))
				}
			}()
			if _, err := io.Copy(fManifest, manifest); err != nil {
				c.Fatal(fmt.Errorf("writing manifest file: %s", err))
			}
		}

		if json {
			printJSONResult(pieceSize, payloadCid, pieceCid, aggrFiles)
			return
		}
		c.Message("Created CAR file, and piece digest in %.02fs.", time.Since(start).Seconds())
		c.Message("Payload cid: %s", payloadCid)
		c.Message("Piece size: %d (%s)", pieceSize, humanize.IBytes(pieceSize))
		c.Message("Piece CID: %s\n", pieceCid)

		c.Message("Lotus offline-deal command:")
		c.Message("lotus client deal --manual-piece-cid=%s --manual-piece-size=%d %s <miner> <price> <duration>", pieceCid, pieceSize, payloadCid)
	},
}

type closeFunc func() error

func prepareDAGService(cmd *cobra.Command, args []string, quiet bool) (cid.Cid, ipld.DAGService, []aggregatedFile, closeFunc, error) {
	ipfsAPI, err := cmd.Flags().GetString("ipfs-api")
	if err != nil {
		return cid.Undef, nil, nil, nil, fmt.Errorf("getting ipfs api flag: %s", err)
	}
	aggregate, err := cmd.Flags().GetBool("aggregate")
	if err != nil {
		return cid.Undef, nil, nil, nil, fmt.Errorf("aggregate flag: %s", err)
	}
	if ipfsAPI == "" {
		path := args[0]
		tmpDir, err := cmd.Flags().GetString("tmpdir")
		if err != nil {
			return cid.Undef, nil, nil, nil, fmt.Errorf("getting tmpdir directory: %s", err)
		}

		dagService, cls, err := createTmpDAGService(tmpDir)
		if err != nil {
			return cid.Undef, nil, nil, nil, fmt.Errorf("creating temporary dag-service: %s", err)
		}
		dataCid, aggregatedFiles, err := dagify(context.Background(), dagService, path, quiet, aggregate)
		if err != nil {
			return cid.Undef, nil, nil, nil, fmt.Errorf("creating dag for data: %s", err)
		}

		return dataCid, dagService, aggregatedFiles, cls, nil
	}

	if len(args) == 0 {
		return cid.Undef, nil, nil, nil, fmt.Errorf("cid argument is empty")
	}
	dataCid, err := cid.Decode(args[0])
	if err != nil {
		return cid.Undef, nil, nil, nil, fmt.Errorf("parsing cid: %s", err)
	}

	ipfsAPIMA, err := multiaddr.NewMultiaddr(ipfsAPI)
	if err != nil {
		return cid.Undef, nil, nil, nil, fmt.Errorf("parsing ipfs-api multiaddress: %s", err)
	}
	ipfs, err := httpapi.NewApi(ipfsAPIMA)
	if err != nil {
		return cid.Undef, nil, nil, nil, fmt.Errorf("creating ipfs client: %s", err)
	}

	return dataCid, ipfs.Dag(), nil, closeFunc(func() error { return nil }), nil
}

func createTmpDAGService(tmpDir string) (ipld.DAGService, closeFunc, error) {
	badgerFolder, err := ioutil.TempDir(tmpDir, "powprepare-*")
	if err != nil {
		return nil, nil, fmt.Errorf("creating temporary badger folder: %s", err)
	}

	ds, err := badger.NewDatastore(badgerFolder, &badger.DefaultOptions)
	if err != nil {
		return nil, nil, fmt.Errorf("creating temporal badger datastore: %s", err)
	}
	bstore := blockstore.NewBlockstore(ds)

	return dag.NewDAGService(bsrv.New(bstore, offline.Exchange(bstore))),
		func() error {
			if err := ds.Close(); err != nil {
				return fmt.Errorf("closing datastore: %s", err)
			}
			_ = os.RemoveAll(badgerFolder)

			return nil
		}, nil
}

var jsonOutput = io.Writer(os.Stderr)

func printJSONResult(pieceSize uint64, payloadCid, pieceCID cid.Cid, aggrFiles []aggregatedFile) {
	outData := struct {
		PayloadCid      string           `json:"payload_cid,omitempty"`
		PieceSize       uint64           `json:"piece_size"`
		PieceCid        string           `json:"piece_cid"`
		AggregatedFiles []aggregatedFile `json:"files,omitempty"`
	}{
		PieceSize:       pieceSize,
		PieceCid:        pieceCID.String(),
		AggregatedFiles: aggrFiles,
	}
	if payloadCid.Defined() {
		outData.PayloadCid = payloadCid.String()
	}
	out, err := json.Marshal(outData)
	c.CheckErr(err)
	fmt.Fprint(jsonOutput, string(out))
}

func dagify(ctx context.Context, dagService ipld.DAGService, path string, quiet bool, aggregate bool) (cid.Cid, []aggregatedFile, error) {
	var progressChan chan int64
	if !quiet {
		f, err := os.Open(path)
		if err != nil {
			return cid.Undef, nil, fmt.Errorf("opening path: %s", err)
		}
		stat, err := f.Stat()
		if err != nil {
			_ = f.Close()
			return cid.Undef, nil, fmt.Errorf("getting stat of data: %s", err)
		}
		_ = f.Close()

		c.Message("Creating data DAG...")
		start := time.Now()
		dataSize := int(stat.Size())
		if stat.IsDir() {
			dataSize = 0
			err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if !info.IsDir() {
					dataSize += int(info.Size())
				}
				return err
			})
			if err != nil {
				return cid.Undef, nil, fmt.Errorf("walking path: %s", err)
			}
		}
		bar := pb.StartNew(dataSize)
		bar.Set(pb.Bytes, true)

		var wg sync.WaitGroup
		wg.Add(1)
		defer wg.Wait()
		progressChan = make(chan int64)
		defer close(progressChan)
		go func() {
			defer wg.Done()
			for bytesProgress := range progressChan {
				bar.Add64(bytesProgress)
			}
			bar.Finish()
			c.Message("DAG created in %.02fs.", time.Since(start).Seconds())
		}()
	}

	var aggregatedFiles []aggregatedFile
	var dataCid cid.Cid
	var err error
	if !aggregate {
		dataCid, err = dataprep.Dagify(ctx, dagService, path, progressChan)
		if err != nil {
			return cid.Undef, nil, fmt.Errorf("creating dag for data: %s", err)
		}
	} else {
		var lst []aggregator.AggregateDagEntry
		err = filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return nil
			}
			dcid, err := dataprep.Dagify(ctx, dagService, p, progressChan)
			if err != nil {
				return err
			}
			lst = append(lst, aggregator.AggregateDagEntry{
				RootCid: dcid,
			})
			aggregatedFiles = append(aggregatedFiles, aggregatedFile{Name: p, Cid: dcid.String()})
			return err
		})
		if err != nil {
			return cid.Undef, nil, fmt.Errorf("walking the target folder: %s", err)
		}

		dataCid, err = aggregator.Aggregate(ctx, dagService, lst)
		if err != nil {
			return cid.Undef, nil, fmt.Errorf("aggregating: %s", err)
		}
	}

	return dataCid, aggregatedFiles, nil
}

type aggregatedFile struct {
	Name string `json:"name"`
	Cid  string `jsong:"cid"`
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/prepare/prepare_test.go ---
package prepare

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"os"
	"strconv"
	"testing"

	"github.com/stretchr/testify/require"
)

// NOTE: Testing only the `prepare` subcommand will indirectly test
// the `car` and `commp` subcommands. This test simply prepares
// some data and compares the final piece-size and piece-cid to a
// known correct value. If anything in the process (DAGification, CARing)
// misbehaves, it will result in a different PieceCID since, at the end of
// the day, PieceCID is a fingerprint of the prepared data.
func TestOfflinePreparation(t *testing.T) {
	testCases := []struct {
		size int
		json string
	}{
		{size: 10000, json: `{"payload_cid":"QmRP8TCp9bthhzLACAao6mh8cfLypqXncdNbzuPtuqFYP7","piece_size":16384,"piece_cid":"baga6ea4seaqjuk4uh5g7cu5znbvrr7wvfsn2l3xj47rbymvi63uiiroya44lkiy"}`},
		{size: 1000, json: `{"payload_cid":"QmQRAjpSLWziADGz8p5ezxTguFNn18yYbSnduKqMrbJ93c","piece_size":2048,"piece_cid":"baga6ea4seaqadahcx4ct54tlbvgkqlhmif7kxxkvxz3yf3vr2e4puhvsxdbrgka"}`},
		{size: 100, json: `{"payload_cid":"QmY6zHswPvyZkAyxwM9uup1DDPb67hZqChv8hnyu4MrFWk","piece_size":256,"piece_cid":"baga6ea4seaqd4hgfl6texpf377k7igx2ga2mfwn3lb4c4kdpaq3g3oao2yftuki"}`},
	}

	for _, test := range testCases {
		test := test
		t.Run(strconv.Itoa(test.size), func(t *testing.T) {
			out, err := run(t, test.size)
			require.NoError(t, err)
			require.Equal(t, test.json, out)
		})
	}
}

func run(t *testing.T, size int) (string, error) {
	f, err := os.CreateTemp("", "preparetest")
	if err != nil {
		return "", fmt.Errorf("creating temp file: %s", err)
	}
	defer func() { _ = os.Remove(f.Name()) }()

	z := sha256.New()
	_, err = z.Write([]byte("A")) //bytes.Repeat([]byte{byte('A')}, size))
	require.NoError(t, err)
	fmt.Printf("asjkdlas: %x\n", z.Sum(nil))

	if _, err := f.Write(bytes.Repeat([]byte{byte('A')}, size)); err != nil {
		return "", fmt.Errorf("generating temp file: %s", err)
	}
	if err := f.Close(); err != nil {
		return "", fmt.Errorf("closing file: %s", err)
	}

	stdbuf := bytes.NewBuffer(nil)
	jsonOutput = stdbuf
	Cmd.SetArgs([]string{"prepare", "--json", f.Name()})

	if _, err := Cmd.ExecuteC(); err != nil {
		return "", fmt.Errorf("executing command: %s", err)
	}

	return stdbuf.String(), nil
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storageinfo/get/get.go ---
package get

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "get [cid]",
	Short: "Returns the information about a stored cid.",
	Long:  `Returns the information about a stored cid.`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.StorageInfo.Get(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res.StorageInfo)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storageinfo/list/list.go ---
package list

import (
	"context"
	"fmt"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "list [optional cid1,cid2,...]",
	Short: "Returns a list of information about all stored cids, filtered by cids if provided.",
	Long:  `Returns a list of information about all stored cids, filtered by cids if provided.`,
	Args:  cobra.MaximumNArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var cids []string
		if len(args) > 0 {
			cids = strings.Split(args[0], ",")
		}

		res, err := c.PowClient.StorageInfo.List(c.MustAuthCtx(ctx), cids...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storageinfo/storageinfo.go ---
package storageinfo

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storageinfo/get"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storageinfo/list"
)

func init() {
	Cmd.AddCommand(get.Cmd, list.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "storage-info",
	Short: "Provides commands to get and query cid storage info.",
	Long:  `Provides commands to get and query cid storage info.`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/cancel/cancel.go ---
package cancel

import (
	"context"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "cancel [jobid]",
	Short: "Cancel an executing storage job",
	Long:  `Cancel an executing storage job`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
		defer cancel()

		_, err := c.PowClient.StorageJobs.Cancel(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/cancelexecuting/cancelexecuting.go ---
package cancelexecuting

import (
	"context"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "cancel-executing",
	Short: "Cancel all executing jobs",
	Long:  "Cancel all executing jobs",
	Args:  cobra.ExactArgs(0),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx := c.MustAuthCtx(context.Background())

		js, err := c.PowClient.StorageJobs.List(ctx, client.ListConfig{Select: client.Executing})
		c.CheckErr(err)

		for _, j := range js.StorageJobs {
			ctx, cancel := context.WithTimeout(ctx, time.Second*10)
			defer cancel()

			_, err := c.PowClient.StorageJobs.Cancel(ctx, j.Id)
			c.CheckErr(err)
		}
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/cancelqueued/cancelqueued.go ---
package cancelqueued

import (
	"context"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "cancel-queued",
	Short: "Cancel all queued jobs",
	Long:  "Cancel all queued jobs",
	Args:  cobra.ExactArgs(0),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx := c.MustAuthCtx(context.Background())

		js, err := c.PowClient.StorageJobs.List(ctx, client.ListConfig{Select: client.Queued})
		c.CheckErr(err)

		for _, j := range js.StorageJobs {
			ctx, cancel := context.WithTimeout(ctx, time.Second*10)
			defer cancel()

			_, err := c.PowClient.StorageJobs.Cancel(ctx, j.Id)
			c.CheckErr(err)
		}
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/get/get.go ---
package get

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "get [jobid]",
	Short: "Get a storage job's current status",
	Long:  `Get a storage job's current status`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.StorageJobs.Get(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res.StorageJob)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/list/list.go ---
package list

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringP("cid", "c", "", "return results only for the specified cid")
	Cmd.Flags().Uint64P("limit", "l", 0, "limit the number of results returned")
	Cmd.Flags().BoolP("ascending", "a", false, "sort results ascending by time")
	Cmd.Flags().StringP("select", "s", "all", "return only results using the specified selector: all, queued, executing, final")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "list",
	Short: "List storage jobs according to query flag options.",
	Long:  `List storage jobs according to query flag options.`,
	Args:  cobra.NoArgs,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var sel client.ListSelect
		selIn := viper.GetString("select")
		switch selIn {
		case "all":
			sel = client.All
		case "queued":
			sel = client.Queued
		case "executing":
			sel = client.Executing
		case "final":
			sel = client.Final
		default:
			c.CheckErr(fmt.Errorf("invalid option for --select: %s", selIn))
		}

		conf := client.ListConfig{
			CidFilter: viper.GetString("cid"),
			Limit:     viper.GetUint64("limit"),
			Ascending: viper.GetBool("ascending"),
			Select:    sel,
		}

		res, err := c.PowClient.StorageJobs.List(c.MustAuthCtx(ctx), conf)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/storageconfig/storageconfig.go ---
package storageconfig

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "storage-config [job-id]",
	Short: "Get the StorageConfig associated with the specified job",
	Long:  `Get the StorageConfig associated with the specified job`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.StorageJobs.StorageConfig(c.MustAuthCtx(ctx), args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res.StorageConfig)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/storagejobs.go ---
package storagejobs

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/cancel"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/cancelexecuting"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/cancelqueued"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/get"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/list"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/storageconfig"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/summary"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/storagejobs/watch"
)

func init() {
	Cmd.AddCommand(
		cancel.Cmd,
		cancelexecuting.Cmd,
		cancelqueued.Cmd,
		get.Cmd,
		list.Cmd,
		storageconfig.Cmd,
		summary.Cmd,
		watch.Cmd,
	)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:     "storage-jobs",
	Aliases: []string{"storage-job"},
	Short:   "Provides commands to query for storage jobs in various states",
	Long:    `Provides commands to query for storage jobs in various statess`,
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/summary/summary.go ---
package summary

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "summary [optional cid]",
	Short: "Give a summary of storage jobs in all states",
	Long:  `Give a summary of storage jobs in all states`,
	Args:  cobra.RangeArgs(0, 1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		var opts []client.SummaryOption
		if len(args) > 0 {
			opts = append(opts, client.WithCid(args[0]))
		}

		res, err := c.PowClient.StorageJobs.Summary(c.MustAuthCtx(ctx), opts...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/storagejobs/watch/watch.go ---
package watch

import (
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "watch [jobid,...]",
	Short: "Watch for storage job status updates",
	Long:  `Watch for storage job status updates`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		jobIds := strings.Split(args[0], ",")
		c.WatchJobIds(jobIds...)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/version/version.go ---
package version

import (
	"context"
	"fmt"
	"os"

	"github.com/caarlos0/spin"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/buildinfo"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "version",
	Short: "Display version information for pow and the connected server",
	Long:  `Display version information for pow and the connected server`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		c.Message("pow build info:")
		c.RenderTable(
			os.Stdout,
			[]string{},
			[][]string{
				{"Version", buildinfo.Version},
				{"Git Summary", buildinfo.GitSummary},
				{"Git Branch", buildinfo.GitBranch},
				{"Git State", buildinfo.GitState},
				{"Git Commit", buildinfo.GitCommit},
				{"Build Date", buildinfo.BuildDate},
			},
		)

		s := spin.New("%s Getting Powergate server build info...")
		s.Start()
		info, err := c.PowClient.BuildInfo(ctx)
		s.Stop()
		c.CheckErr(err)

		fmt.Print("\n")

		c.Message("powergate server build info:")
		c.RenderTable(
			os.Stdout,
			[]string{},
			[][]string{
				{"Version", info.Version},
				{"Git Summary", info.GitSummary},
				{"Git Branch", info.GitBranch},
				{"Git State", info.GitState},
				{"Git Commit", info.GitCommit},
				{"Build Date", info.BuildDate},
			},
		)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/addrs/addrs.go ---
package addrs

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "addrs",
	Short: "Print all wallet addresses for the current user",
	Long:  `Print all wallet addresses for the current user`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Wallet.Addresses(c.MustAuthCtx(ctx))
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/balance/balance.go ---
package balance

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "balance [address]",
	Short: "Print the balance of the specified wallet address",
	Long:  `Print the balance of the specified wallet address`,
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		res, err := c.PowClient.Wallet.Balance(ctx, args[0])
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/newaddr/newaddr.go ---
package newaddr

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

func init() {
	Cmd.Flags().StringP("format", "f", "", "Optionally specify address format bls or secp256k1")
	Cmd.Flags().BoolP("default", "d", false, "Make the new address the user default")
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "new-addr [name]",
	Short: "Create a new wallet address",
	Long:  `Create a new wallet address`,
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*60)
		defer cancel()

		if len(args) != 1 {
			c.Fatal(errors.New("must provide a name for the address"))
		}

		format := viper.GetString("format")
		makeDefault := viper.GetBool("default")

		var opts []client.NewAddressOption
		if format != "" {
			opts = append(opts, client.WithAddressType(format))
		}
		if makeDefault {
			opts = append(opts, client.WithMakeDefault(makeDefault))
		}

		res, err := c.PowClient.Wallet.NewAddress(c.MustAuthCtx(ctx), args[0], opts...)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/send/send.go ---
package send

import (
	"context"
	"fmt"
	"math/big"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "send [from address] [to address] [amount]",
	Short: "Send fil from one managed address to any other address",
	Long:  `Send fil from one managed address to any other address`,
	Args:  cobra.ExactArgs(3),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		from := args[0]
		to := args[1]

		amount, ok := new(big.Int).SetString(args[2], 10)
		if !ok {
			c.CheckErr(fmt.Errorf("parsing amount %v", args[2]))
		}

		res, err := c.PowClient.Wallet.SendFil(c.MustAuthCtx(ctx), from, to, amount)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/sign/sign.go ---
package sign

import (
	"context"
	"encoding/hex"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "sign [hex-encoded-message]",
	Short: "Signs a message with user wallet addresses.",
	Long:  "Signs a message using all wallet addresses associated with the user",
	Args:  cobra.ExactArgs(1),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		b, err := hex.DecodeString(args[0])
		c.CheckErr(err)

		res, err := c.PowClient.Wallet.Addresses(c.MustAuthCtx(ctx))
		c.CheckErr(err)

		data := make([][]string, len(res.Addresses))
		for i, a := range res.Addresses {
			signRes, err := c.PowClient.Wallet.SignMessage(c.MustAuthCtx(ctx), a.Address, b)
			c.CheckErr(err)
			data[i] = []string{a.Address, hex.EncodeToString(signRes.Signature)}
		}

		c.RenderTable(os.Stdout, []string{"address", "signature"}, data)
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/verify/verify.go ---
package verify

import (
	"context"
	"encoding/hex"
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	c "github.com/textileio/powergate/v2/cmd/pow/common"
	"google.golang.org/protobuf/encoding/protojson"
)

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "verify [addr] [hex-encoded-message] [hex-encoded-signature]",
	Short: "Verifies the signature of a message signed with a user wallet address.",
	Long:  "Verifies the signature of a message signed with a user wallet address.",
	Args:  cobra.ExactArgs(3),
	PreRun: func(cmd *cobra.Command, args []string) {
		err := viper.BindPFlags(cmd.Flags())
		c.CheckErr(err)
	},
	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := context.WithTimeout(context.Background(), c.CmdTimeout)
		defer cancel()

		mb, err := hex.DecodeString(args[1])
		c.CheckErr(err)
		sb, err := hex.DecodeString(args[2])
		c.CheckErr(err)

		res, err := c.PowClient.Wallet.VerifyMessage(c.MustAuthCtx(ctx), args[0], mb, sb)
		c.CheckErr(err)

		json, err := protojson.MarshalOptions{Multiline: true, Indent: "  ", EmitUnpopulated: true}.Marshal(res)
		c.CheckErr(err)

		fmt.Println(string(json))
	},
}

'''
'''--- Filecoin/powergate/cmd/pow/cmd/wallet/wallet.go ---
package wallet

import (
	"github.com/spf13/cobra"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/addrs"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/balance"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/newaddr"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/send"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/sign"
	"github.com/textileio/powergate/v2/cmd/pow/cmd/wallet/verify"
)

func init() {
	Cmd.AddCommand(addrs.Cmd, balance.Cmd, newaddr.Cmd, send.Cmd, sign.Cmd, verify.Cmd)
}

// Cmd is the command.
var Cmd = &cobra.Command{
	Use:   "wallet",
	Short: "Provides commands about filecoin wallets",
	Long:  `Provides commands about filecoin wallets`,
}

'''
'''--- Filecoin/powergate/cmd/pow/common/common.go ---
package common

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/signal"
	"sort"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/apoorvam/goterminal"
	"github.com/logrusorgru/aurora"
	"github.com/olekukonko/tablewriter"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/api/client"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
)

var (
	// PowClient is the powergate client.
	PowClient *client.Client

	// CmdTimeout is the standard timeout.
	CmdTimeout = time.Second * 60
)

// FmtOutput allows to configure where Message(), Success(), and
// Fatal() helpers should write.
var FmtOutput = os.Stdout

// Message prints a message to stdout.
func Message(format string, args ...interface{}) {
	fmt.Fprintln(FmtOutput, aurora.Sprintf(aurora.BrightBlack("> "+format), args...))
}

// Success prints a success message to stdout.
func Success(format string, args ...interface{}) {
	fmt.Fprintln(FmtOutput, aurora.Sprintf(aurora.Cyan("> Success! %s"),
		aurora.Sprintf(aurora.BrightBlack(format), args...)))
}

// Fatal prints a fatal error to stdout, and exits immediately with
// error code 1.
func Fatal(err error, args ...interface{}) {
	words := strings.SplitN(err.Error(), " ", 2)
	words[0] = strings.Title(words[0])
	msg := strings.Join(words, " ")
	fmt.Fprintln(FmtOutput, aurora.Sprintf(aurora.Red("> Error! %s"),
		aurora.Sprintf(aurora.BrightBlack(msg), args...)))
	os.Exit(1)
}

// RenderTable renders a table with header columns and data rows to writer.
func RenderTable(writer io.Writer, header []string, data [][]string) {
	table := tablewriter.NewWriter(writer)
	table.SetHeader(header)
	table.SetBorder(false)
	headersColors := make([]tablewriter.Colors, len(header))
	for i := range headersColors {
		headersColors[i] = tablewriter.Colors{tablewriter.FgHiBlackColor}
	}
	table.SetHeaderColor(headersColors...)
	table.AppendBulk(data)
	table.Render()
}

// CheckErr calls Fatal if there is an error.
func CheckErr(e error) {
	if e != nil {
		Fatal(e)
	}
}

// WatchJobIds watches jobs.
func WatchJobIds(jobIds ...string) {
	state := make(map[string]*client.WatchStorageJobsEvent, len(jobIds))
	for _, jobID := range jobIds {
		state[jobID] = nil
	}

	writer := goterminal.New(os.Stdout)

	updateJobsOutput(writer, state)

	ch := make(chan client.WatchStorageJobsEvent)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	err := PowClient.StorageJobs.Watch(MustAuthCtx(ctx), ch, jobIds...)
	CheckErr(err)

	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		cancel()
		os.Exit(0)
	}()

	for {
		event, ok := <-ch
		if !ok {
			break
		}
		state[event.Res.StorageJob.Id] = &event
		updateJobsOutput(writer, state)
		if jobsComplete(state) {
			break
		}
	}
}

func updateJobsOutput(writer *goterminal.Writer, state map[string]*client.WatchStorageJobsEvent) {
	keys := make([]string, 0, len(state))
	for k := range state {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var data [][]string
	for _, k := range keys {
		if state[k] != nil {
			var val string
			if state[k].Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_FAILED {
				val = fmt.Sprintf("%v %v", state[k].Res.StorageJob.Status.String(), state[k].Res.StorageJob.ErrorCause)
			} else if state[k].Err != nil {
				val = fmt.Sprintf("Error: %v", state[k].Err.Error())
			} else {
				val = state[k].Res.StorageJob.Status.String()
			}
			data = append(data, []string{k, val, "", "", ""})
			for _, dealInfo := range state[k].Res.StorageJob.DealInfo {
				data = append(data, []string{"", "", dealInfo.Miner, strconv.FormatUint(dealInfo.PricePerEpoch, 10), dealInfo.StateName})
			}
		} else {
			data = append(data, []string{k, "awaiting state", "", "", ""})
		}
	}

	RenderTable(writer, []string{"Job id", "Status", "Miner", "Price", "Deal Status"}, data)

	writer.Clear()
	_ = writer.Print()
}

func jobsComplete(state map[string]*client.WatchStorageJobsEvent) bool {
	for _, event := range state {
		processing := false
		if event == nil ||
			event.Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_EXECUTING ||
			event.Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_QUEUED {
			processing = true
		}
		if processing && event != nil && event.Err == nil {
			return false
		}
	}
	return true
}

// MustAuthCtx returns the auth context built from viper token.
func MustAuthCtx(ctx context.Context) context.Context {
	token := viper.GetString("token")
	if token == "" {
		Fatal(errors.New("must provide -t token"))
	}
	return context.WithValue(ctx, client.AuthKey, token)
}

// AdminAuthCtx returns the admin auth context built from viper admin token.
func AdminAuthCtx(ctx context.Context) context.Context {
	token := viper.GetString("admin-token")
	return context.WithValue(ctx, client.AdminKey, token)
}

'''
'''--- Filecoin/powergate/cmd/pow/main.go ---
package main

import (
	"fmt"
	"os"

	"github.com/textileio/powergate/v2/cmd/pow/cmd"
)

func main() {
	if err := cmd.Cmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

'''
'''--- Filecoin/powergate/cmd/powbench/README.md ---
# Powergate bench

Powergate `powbench` is an utility tool that allows to run benchmark scenarios against a properly configured Powergate server.

To build and install `powbench`, from the root of the Powergate repo, run:

```bash
> make install-powbench
> powbench -h
Usage of powbench:
      --maxParallel int    Max parallel file storage (default 1)
      --minerAddr string   Miner address to force Powergate to select for making deals (default "t01000")
      --pgAddr string      Powergate server multiaddress (default "/ip4/127.0.0.1/tcp/5002")
      --randSeed int       Random seed used to generate random samples data (default 42)
      --sampleSize int     Size of randomly generated files in bytes (default 1024)
      --totalSamples int   Total samples to run (default 3)
```

The targeted Powergate server should have enabled the auto-funding of newly created FFS instances wallet addresses.
This means:
- The Lotus node owned by Powergate must have a wallet address; the _master address_. 
- _master address_ should have funds.
- This address will be used to automatically send funds to the new FFS instance that will run the benchmark.
- Powergate should be started with two flags:
  - `--lotusmasteraddr`: with the above mentioned address.
  - `--walletinitialfund`: an reasonable amount of _attoFIL_ that will be transferred from the master address to the created FFS instance. It should be enough to fund _all_ deals that will be ran in the scenario.
  - _Note: env variables can be used instead of command line flags, i.e: `POWD_LOTUSMASTERADDR` and `POWD_WALLETINITIALFUND` respectively._

'''
'''--- Filecoin/powergate/cmd/powbench/main.go ---
package main

import (
	"context"
	"os"
	"os/signal"
	"sync"
	"syscall"

	logging "github.com/ipfs/go-log/v2"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"github.com/textileio/powergate/v2/buildinfo"
	"github.com/textileio/powergate/v2/cmd/powbench/runner"
)

const (
	cmdPowergateAddr = "pgAddr"
	cmdSampleSize    = "sampleSize"
	cmdMaxParallel   = "maxParallel"
	cmdTotalSamples  = "totalSamples"
	cmdRandSeed      = "randSeed"
	cmdMinerAddr     = "minerAddr"
)

var (
	log    = logging.Logger("main")
	config = viper.New()
)

func main() {
	log.Infof("starting powbench:\n%s", buildinfo.Summary())

	pflag.String(cmdPowergateAddr, "/ip4/127.0.0.1/tcp/5002", "Powergate server multiaddress")
	pflag.Int(cmdSampleSize, 1024, "Size of randomly generated files in bytes")
	pflag.Int(cmdMaxParallel, 1, "Max parallel file storage")
	pflag.Int(cmdTotalSamples, 3, "Total samples to run")
	pflag.Int(cmdRandSeed, 42, "Random seed used to generate random samples data")
	pflag.String(cmdMinerAddr, "t01000", "Miner address to force Powergate to select for making deals")
	pflag.Parse()

	config.SetEnvPrefix("POWBENCH")
	config.AutomaticEnv()
	if err := config.BindPFlags(pflag.CommandLine); err != nil {
		log.Fatalf("binding flags: %s", err)
	}

	pgAddr := config.GetString(cmdPowergateAddr)
	ts := runner.TestSetup{
		PowergateAddr: pgAddr,
		MinerAddr:     config.GetString(cmdMinerAddr),

		SampleSize:   config.GetInt64(cmdSampleSize),
		MaxParallel:  config.GetInt(cmdMaxParallel),
		TotalSamples: config.GetInt(cmdTotalSamples),
		RandSeed:     config.GetInt(cmdRandSeed),
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	var wg sync.WaitGroup
	wg.Add(1)
	go func(ctx context.Context) {
		defer wg.Done()
		if err := runner.Run(ctx, ts); err != nil {
			log.Fatalf("running test setup: %s", err)
		}
	}(ctx)

	ch := make(chan os.Signal, 1)
	signal.Notify(ch, os.Interrupt, syscall.SIGTERM)
	<-ch
	log.Info("Closing...")
	cancel()
	wg.Wait()
	log.Info("Done")
}

'''
'''--- Filecoin/powergate/cmd/powbench/runner/runner.go ---
package runner

import (
	"context"
	"fmt"
	"io"
	"math/rand"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/api/client"
	userPb "github.com/textileio/powergate/v2/api/gen/powergate/user/v1"
	"github.com/textileio/powergate/v2/util"
)

var (
	log = logging.Logger("runner")
)

// TestSetup describes a test configuration.
type TestSetup struct {
	PowergateAddr string
	MinerAddr     string
	SampleSize    int64
	MaxParallel   int
	TotalSamples  int
	RandSeed      int
}

// Run runs a test setup.
func Run(ctx context.Context, ts TestSetup) error {
	c, err := client.NewClient(ts.PowergateAddr)
	defer func() {
		if err := c.Close(); err != nil {
			log.Errorf("closing powergate client: %s", err)
		}
	}()
	if err != nil {
		return fmt.Errorf("creating client: %s", err)
	}

	if err := runSetup(ctx, c, ts); err != nil {
		return fmt.Errorf("running test setup: %s", err)
	}

	return nil
}

func runSetup(ctx context.Context, c *client.Client, ts TestSetup) error {
	res, err := c.Admin.Users.Create(ctx)
	if err != nil {
		return fmt.Errorf("creating ffs instance: %s", err)
	}
	ctx = context.WithValue(ctx, client.AuthKey, res.User.Token)
	res2, err := c.Wallet.Addresses(ctx)
	if err != nil {
		return fmt.Errorf("getting instance info: %s", err)
	}
	addr := res2.Addresses[0].Address
	time.Sleep(time.Second * 5)

	chLimit := make(chan struct{}, ts.MaxParallel)
	chErr := make(chan error, ts.TotalSamples)
	for i := 0; i < ts.TotalSamples; i++ {
		chLimit <- struct{}{}
		go func(i int) {
			defer func() { <-chLimit }()
			if err := run(ctx, c, i, ts.RandSeed+i, ts.SampleSize, addr, ts.MinerAddr); err != nil {
				chErr <- fmt.Errorf("failed run %d: %s", i, err)
			}
		}(i)
	}
	for i := 0; i < ts.MaxParallel; i++ {
		chLimit <- struct{}{}
	}
	close(chErr)
	for err := range chErr {
		return fmt.Errorf("sample run errored: %s", err)
	}
	return nil
}

func run(ctx context.Context, c *client.Client, id int, seed int, size int64, addr string, minerAddr string) error {
	log.Infof("[%d] Executing run...", id)
	defer log.Infof("[%d] Done", id)
	ra := rand.New(rand.NewSource(int64(seed)))
	lr := io.LimitReader(ra, size)

	log.Infof("[%d] Adding to hot storage...", id)
	statgeRes, err := c.Data.Stage(ctx, lr)
	if err != nil {
		return fmt.Errorf("importing data to hot storage (ipfs node): %s", err)
	}

	log.Infof("[%d] Pushing %s to FFS...", id, statgeRes.Cid)

	// For completeness, fields that could be relied on defaults
	// are explicitly kept here to have a better idea about their
	// existence.
	// This configuration will stop being static when we incorporate
	// other test cases.
	storageConfig := &userPb.StorageConfig{
		Repairable: false,
		Hot: &userPb.HotConfig{
			Enabled:          true,
			AllowUnfreeze:    false,
			UnfreezeMaxPrice: 0,
			Ipfs: &userPb.IpfsConfig{
				AddTimeout: 30,
			},
		},
		Cold: &userPb.ColdConfig{
			Enabled: true,
			Filecoin: &userPb.FilConfig{
				ReplicationFactor: 1,
				DealMinDuration:   util.MinDealDuration,
				Address:           addr,
				CountryCodes:      nil,
				ExcludedMiners:    nil,
				TrustedMiners:     []string{minerAddr},
				Renew:             &userPb.FilRenew{},
			},
		},
	}

	applyRes, err := c.StorageConfig.Apply(ctx, statgeRes.Cid, client.WithStorageConfig(storageConfig))
	if err != nil {
		return fmt.Errorf("pushing to FFS: %s", err)
	}

	log.Infof("[%d] Pushed successfully, queued job %s. Waiting for termination...", id, applyRes.JobId)
	chJob := make(chan client.WatchStorageJobsEvent, 1)
	ctxWatch, cancel := context.WithCancel(ctx)
	defer cancel()
	err = c.StorageJobs.Watch(ctxWatch, chJob, applyRes.JobId)
	if err != nil {
		return fmt.Errorf("opening listening job status: %s", err)
	}
	var s client.WatchStorageJobsEvent
	for s = range chJob {
		if s.Err != nil {
			return fmt.Errorf("job watching: %s", s.Err)
		}
		log.Infof("[%d] Job changed to status %s", id, s.Res.StorageJob.Status.String())
		if s.Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_FAILED || s.Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_CANCELED {
			return fmt.Errorf("job execution failed or was canceled")
		}
		if s.Res.StorageJob.Status == userPb.JobStatus_JOB_STATUS_SUCCESS {
			return nil
		}
	}
	return fmt.Errorf("unexpected Job status watcher")
}

'''
'''--- Filecoin/powergate/cmd/powbench/runner/runner_test.go ---
package runner

import (
	"context"
	"os"
	"os/exec"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/api/client"
)

var (
	powergateAddr = "127.0.0.1:5002"
)

func TestMain(m *testing.M) {
	logging.SetAllLoggers(logging.LevelInfo)
	os.Exit(m.Run())
}

func TestSimpleSetup(t *testing.T) {
	// Explicitly skip this test since its meant for benchmarking stuff.
	t.SkipNow()
	_ = spinup(t)
	ts := TestSetup{
		PowergateAddr: powergateAddr,
		MinerAddr:     "t01000",
		SampleSize:    700,
		MaxParallel:   1,
		TotalSamples:  1,
		RandSeed:      22,
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()
	err := Run(ctx, ts)
	require.NoError(t, err)
}

func spinup(t *testing.T) *client.Client {
	dockerFolder := "../../../docker"

	makeDown := func() {
		cmd := exec.Command("make", "down")
		cmd.Dir = dockerFolder
		err := cmd.Run()
		require.NoError(t, err)
	}
	makeDown()

	cmd := exec.Command("docker-compose", "-f", "docker-compose-devnet.yaml", "build")
	cmd.Dir = dockerFolder
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		t.Fatalf("docker-compose build: %s", err)
	}

	cmd = exec.Command("make", "devnet")
	cmd.Dir = dockerFolder
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Start(); err != nil {
		t.Fatalf("running docker-compose: %s", err)
	}
	t.Cleanup(makeDown)

	var c *client.Client
	var err error
	limit := 30
	retries := 0
	for retries < limit {
		c, err = client.NewClient(powergateAddr)
		require.NoError(t, err)
		time.Sleep(time.Second)
		retries++
	}
	if retries == limit {
		t.Fatalf("failed to connect to powergate")
	}
	// After PG is up, wait a bit more to ensure IPFS does to.
	time.Sleep(time.Second * 5)
	return c
}

'''
'''--- Filecoin/powergate/cmd/powcfg/main.go ---
package main

import (
	"context"
	"fmt"
	"time"

	"github.com/ipfs/go-datastore"
	badger "github.com/ipfs/go-ds-badger2"
	logger "github.com/ipfs/go-log/v2"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	mongods "github.com/textileio/go-ds-mongo"
	"github.com/textileio/powergate/v2/buildinfo"
)

var (
	log    = logger.Logger("powcfg")
	config = viper.New()
)

func main() {
	logger.SetAllLoggers(logger.LevelInfo)
	log.Infof("starting powcfg:\n%s", buildinfo.Summary())

	if err := wireFlagsAndEnvs(); err != nil {
		log.Fatalf("wiring flags/envs: %s", err)
	}

	mongoURI := config.GetString("mongouri")
	mongoDB := config.GetString("mongodb")
	mongoCollection := config.GetString("mongocollection")
	badgerrepo := config.GetString("badgerrepo")
	dryrun := config.GetBool("dryrun")
	ds, err := createDatastore(mongoURI, mongoDB, mongoCollection, badgerrepo)
	if err != nil {
		log.Fatalf("opening datastore: %s", err)
	}

	count, err := applyTransform(ds, dryrun, bumpIpfsAddTimeout(480))
	if err != nil {
		log.Fatalf("applying transformation: %s", err)
	}

	log.Infof("Transformation modified %d storage configs", count)
	if dryrun {
		log.Warnf("Dryrun: No changes applied")
	}
}

func wireFlagsAndEnvs() error {
	pflag.String("mongouri", "", "MongoDB URI")
	pflag.String("mongodb", "", "MongoDB database name")
	pflag.String("mongocollection", "", "MongoDB collection name")
	pflag.String("badgerrepo", "", "Badger Repo")
	pflag.Bool("dryrun", false, "Avoid any write to the datastore")
	config.SetEnvPrefix("POWCFG")
	config.AutomaticEnv()
	pflag.Parse()
	if err := config.BindPFlags(pflag.CommandLine); err != nil {
		return fmt.Errorf("binding flags: %s", err)
	}
	return nil
}

func createDatastore(mongoURI, mongoDB, mongoCollection, badgerrepo string) (datastore.TxnDatastore, error) {
	if mongoURI != "" {
		log.Info("Opening Mongo database...")
		mongoCtx, cancel := context.WithTimeout(context.Background(), time.Second*10)
		defer cancel()
		if mongoDB == "" {
			return nil, fmt.Errorf("mongo database name is empty")
		}
		if mongoCollection == "" {
			return nil, fmt.Errorf("mongo collection name is empty")
		}
		opts := []mongods.Option{
			mongods.WithCollName(mongoCollection),
			mongods.WithOpTimeout(time.Hour),
			mongods.WithTxnTimeout(time.Hour),
		}
		ds, err := mongods.New(mongoCtx, mongoURI, mongoDB, opts...)
		if err != nil {
			return nil, fmt.Errorf("opening mongo datastore: %s", err)
		}
		return ds, nil
	}

	log.Info("Opening badger database...")
	opts := &badger.DefaultOptions
	ds, err := badger.NewDatastore(badgerrepo, opts)
	if err != nil {
		return nil, fmt.Errorf("opening badger datastore: %s", err)
	}
	return ds, nil
}

'''
'''--- Filecoin/powergate/cmd/powcfg/ratelim/ratelim.go ---
package ratelim

import (
	"fmt"
	"sync"
)

// RateLim allows to logically cap the maximum number of functions.
// It returns a slice of error strings that happened during execution.
type RateLim struct {
	c chan struct{}

	lock   sync.Mutex
	errors []string
}

// New returns a new RateLim.
func New(limit int) (*RateLim, error) {
	if limit <= 0 {
		return nil, fmt.Errorf("limit should be positive")
	}

	return &RateLim{c: make(chan struct{}, limit)}, nil
}

// Exec executes f when a slot is available within the defined
// maximum limit.
func (rl *RateLim) Exec(f func() error) {
	rl.c <- struct{}{}
	go func() {
		defer func() { <-rl.c }()
		err := f()
		if err != nil {
			rl.lock.Lock()
			rl.errors = append(rl.errors, err.Error())
			rl.lock.Unlock()
		}
	}()
}

// Wait will block until all executing functions finish, and return
// all error strings that happened during executions. RateLim can't
// be reused after this call.
func (rl *RateLim) Wait() []string {
	for i := 0; i < cap(rl.c); i++ {
		rl.c <- struct{}{}
	}
	return rl.errors
}

'''
'''--- Filecoin/powergate/cmd/powcfg/transform.go ---
package main

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/cmd/powcfg/ratelim"
	"github.com/textileio/powergate/v2/ffs"
)

// Transform is a function that applies a transformation to a StorageConfig.
// The function should edit the received parameter directly, and return 'true'
// if changes were made, or false otherwise.
type Transform func(*ffs.StorageConfig) (bool, error)

func applyTransform(ds datastore.TxnDatastore, dryrun bool, t Transform) (int, error) {
	q := query.Query{Prefix: "/ffs/manager/api"}
	res, err := ds.Query(q)
	if err != nil {
		return 0, fmt.Errorf("running query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Warnf("closing query result: %s", err)
		}
	}()

	rl, err := ratelim.New(1000)
	if err != nil {
		return 0, fmt.Errorf("creating rate limiter: %s", err)
	}

	var lock sync.Mutex
	var modifiedCount int
	for r := range res.Next() {
		if r.Error != nil {
			return 0, fmt.Errorf("getting query record: %s", err)
		}

		// Key format: /ffs/manager/api/<api-id>/istore/storageconfig/<cid>
		key := datastore.NewKey(r.Key)
		parts := key.Namespaces()
		if len(parts) < 6 {
			continue
		}
		if parts[4] != "istore" || parts[5] != "cidstorageconfig" {
			continue
		}

		r := r
		rl.Exec(func() error {
			var cfg ffs.StorageConfig
			if err := json.Unmarshal(r.Value, &cfg); err != nil {
				return fmt.Errorf("unmarshaling storage config: %s", err)
			}

			modified, err := t(&cfg)
			if err != nil {
				return fmt.Errorf("applying transform: %s", err)
			}
			if !modified {
				return nil
			}

			lock.Lock()
			modifiedCount++
			lock.Unlock()
			if dryrun {
				return nil
			}

			buf, err := json.Marshal(cfg)
			if err != nil {
				return fmt.Errorf("marshaling storage config: %s", err)
			}
			if err := ds.Put(datastore.NewKey(r.Key), buf); err != nil {
				return fmt.Errorf("put in datastore: %s", err)
			}

			return nil
		})
	}

	errors := rl.Wait()
	if len(errors) > 0 {
		for err := range errors {
			log.Error(err)
		}
		return 0, fmt.Errorf("finished with %d errors", len(errors))
	}

	return modifiedCount, nil
}

'''
'''--- Filecoin/powergate/cmd/powcfg/transform_test.go ---
package main

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/ipfs/go-datastore"
	badger "github.com/ipfs/go-ds-badger2"
	logger "github.com/ipfs/go-log/v2"
	cp "github.com/otiai10/copy"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
)

func TestIpfsAddBump(t *testing.T) {
	logger.SetDebugLogging()
	_ = logger.SetLogLevel("badger", "error")

	for _, dryRun := range []bool{false, true} {
		dryRun := dryRun
		t.Run(fmt.Sprintf("dryrun %v", dryRun), func(t *testing.T) {
			t.Parallel()
			tmpDir := t.TempDir()
			err := cp.Copy("testdata/badgerdumpv1", tmpDir+"/badgerdump")
			require.NoError(t, err)

			opts := &badger.DefaultOptions
			ds, err := badger.NewDatastore(tmpDir+"/badgerdump", opts)
			require.NoError(t, err)
			defer func() { require.NoError(t, ds.Close()) }()

			modified, err := applyTransform(ds, dryRun, bumpIpfsAddTimeout(12345))
			require.NoError(t, err)

			// Verify
			require.Equal(t, 678, modified)

			var cfg ffs.StorageConfig
			k := datastore.NewKey("/ffs/manager/api/274cb2c5-a0da-49fa-91a8-97b9d387d4fa/istore/cidstorageconfig/QmbtfAvVRVgEa9RH6vYpKg1HWbBQjxiZ6vNG1AAvt3vyfR")
			buf, err := ds.Get(k)
			require.NoError(t, err)
			err = json.Unmarshal(buf, &cfg)
			require.NoError(t, err)

			if dryRun {
				require.NotEqual(t, 12345, cfg.Hot.Ipfs.AddTimeout)
				return
			}
			require.Equal(t, 12345, cfg.Hot.Ipfs.AddTimeout)
		})
	}
}

'''
'''--- Filecoin/powergate/cmd/powcfg/transformations.go ---
package main

import (
	"github.com/textileio/powergate/v2/ffs"
)

// bumpIpfsAddTimeout is a transformation that updates Hot.Ipfs.AddTimeout
// if the current value is less than a minimum desired value.
func bumpIpfsAddTimeout(minValue int) Transform {
	return func(cfg *ffs.StorageConfig) (bool, error) {
		if cfg.Hot.Ipfs.AddTimeout >= minValue {
			return false, nil
		}

		cfg.Hot.Ipfs.AddTimeout = minValue

		return true, nil
	}
}

var _ = unsetFilecoinUnlimitedPrice

// unsetFilecoinUnlimitedPrice is a transformation that sets
// Cold.Filecoin.MaxPrice to maxPrice if the current value is
// 0 (no limit).
func unsetFilecoinUnlimitedPrice(maxPrice uint64) Transform {
	return func(cfg *ffs.StorageConfig) (bool, error) {
		if cfg.Cold.Filecoin.MaxPrice > 0 {
			return false, nil
		}

		cfg.Cold.Filecoin.MaxPrice = maxPrice

		return true, nil
	}
}

'''
'''--- Filecoin/powergate/cmd/powd/main.go ---
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/big"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	_ "net/http/pprof"

	logging "github.com/ipfs/go-log/v2"
	homedir "github.com/mitchellh/go-homedir"
	ma "github.com/multiformats/go-multiaddr"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	metricsOpenTelemetry "github.com/textileio/go-metrics-opentelemetry"
	"github.com/textileio/powergate/v2/api/server"
	"github.com/textileio/powergate/v2/buildinfo"
	"github.com/textileio/powergate/v2/util"
	"go.opentelemetry.io/contrib/instrumentation/runtime"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/metric/prometheus"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	log    = logging.Logger("powd")
	config = viper.New()
)

func main() {
	// Configure flags.
	if err := setupFlags(); err != nil {
		log.Fatalf("configuring flags: %s", err)
	}

	// Create configuration from flags/envs.
	conf, err := configFromFlags()
	if err != nil {
		log.Fatalf("creating config from flags: %s", err)
	}

	// Configure logging.
	if err := setupLogging(conf.RepoPath); err != nil {
		log.Fatalf("configuring up logging: %s", err)
	}

	log.Infof("starting powd:\n%s", buildinfo.Summary())

	// Configuring Prometheus exporter.
	if err := setupInstrumentation(); err != nil {
		log.Fatalf("starting instrumentation: %s", err)
	}

	confProtected := conf
	if confProtected.MongoURI != "" {
		confProtected.MongoURI = "<hidden>"
	}
	confJSON, err := json.MarshalIndent(confProtected, "", "  ")
	if err != nil {
		log.Fatalf("marshaling configuration: %s", err)
	}
	log.Infof("%s", confJSON)

	// Start server.
	log.Info("starting server...")
	powd, err := server.NewServer(conf)
	if err != nil {
		log.Fatalf("starting server: %s", err)
	}
	log.Info("server started.")

	// Wait for Ctrl+C and close.
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, os.Interrupt, syscall.SIGTERM)
	<-ch
	log.Info("Closing...")
	powd.Close()
	if conf.Devnet {
		if err := os.RemoveAll(conf.RepoPath); err != nil {
			log.Error(err)
		}
	}
	log.Info("Closed")
}

func configFromFlags() (server.Config, error) {
	devnet := config.GetBool("devnet")

	lotusToken, err := getLotusToken(devnet)
	if err != nil {
		return server.Config{}, fmt.Errorf("getting lotus auth token: %s", err)
	}

	repoPath, err := getRepoPath(devnet)
	if err != nil {
		return server.Config{}, fmt.Errorf("getting repo path: %s", err)
	}

	grpcHostMaddr, err := ma.NewMultiaddr(config.GetString("grpchostaddr"))
	if err != nil {
		return server.Config{}, fmt.Errorf("parsing grpchostaddr: %s", err)
	}

	lotusHost, err := ma.NewMultiaddr(config.GetString("lotushost"))
	if err != nil {
		return server.Config{}, fmt.Errorf("parsing lotus api multiaddr: %s", err)
	}

	walletInitialFunds := *big.NewInt(config.GetInt64("walletinitialfund"))
	ipfsAPIAddr := util.MustParseAddr(config.GetString("ipfsapiaddr"))
	lotusMasterAddr := config.GetString("lotusmasteraddr")
	lotusConnectionRetries := config.GetInt("lotusconnectionretries")
	autocreateMasterAddr := config.GetBool("autocreatemasteraddr")
	ffsUseMasterAddr := config.GetBool("ffsusemasteraddr")
	grpcWebProxyAddr := config.GetString("grpcwebproxyaddr")
	gatewayHostAddr := config.GetString("gatewayhostaddr")
	gatewayBasePath := config.GetString("gatewaybasepath")
	indexRawJSONHostAddr := config.GetString("indexrawjsonhostaddr")
	maxminddbfolder := config.GetString("maxminddbfolder")
	mongoURI := config.GetString("mongouri")
	mongoDB := config.GetString("mongodb")
	minerSelector := config.GetString("ffsminerselector")
	minerSelectorParams := config.GetString("ffsminerselectorparams")
	ffsAdminToken := config.GetString("ffsadmintoken")
	ffsSchedMaxParallel := config.GetInt("ffsschedmaxparallel")
	ffsDealWatchFinalityTimeout := time.Minute * time.Duration(config.GetInt("ffsdealfinalitytimeout"))
	ffsMinimumPieceSize := config.GetUint64("ffsminimumpiecesize")
	ffsRetrievalNextEventTimeout := config.GetDuration("ffsretrievalnexteventtimeout")
	ffsMaxParallelDealPreparing := config.GetInt("ffsmaxparalleldealpreparing")
	ffsGCInterval := time.Minute * time.Duration(config.GetInt("ffsgcinterval"))
	ffsGCStagedGracePeriod := time.Minute * time.Duration(config.GetInt("ffsgcstagedgraceperiod"))
	dealWatchPollDuration := time.Second * time.Duration(config.GetInt("dealwatchpollduration"))
	askIndexQueryAskTimeout := time.Second * time.Duration(config.GetInt("askindexqueryasktimeout"))
	askIndexRefreshInterval := time.Minute * time.Duration(config.GetInt("askindexrefreshinterval"))
	askIndexRefreshOnStart := config.GetBool("askindexrefreshonstart")
	askIndexMaxParallel := config.GetInt("askindexmaxparallel")
	indexMinersRefreshOnStart := config.GetBool("indexminersrefreshonstart")
	indexMinersOnChainMaxParallel := config.GetInt("indexminersonchainmaxparallel")
	indexMinersOnChainFrequency := config.GetDuration("indexminersonchainfrequency")
	disableIndices := config.GetBool("disableindices")
	disableNonCompliantAPIs := config.GetBool("disablenoncompliantapis")

	return server.Config{
		WalletInitialFunds: walletInitialFunds,
		IpfsAPIAddr:        ipfsAPIAddr,
		Devnet:             devnet,
		RepoPath:           repoPath,
		MaxMindDBFolder:    maxminddbfolder,

		LotusAddress:           lotusHost,
		LotusAuthToken:         lotusToken,
		LotusConnectionRetries: lotusConnectionRetries,
		LotusMasterAddr:        lotusMasterAddr,

		// ToDo: Support secure gRPC connection
		GrpcHostNetwork:     "tcp",
		GrpcHostAddress:     grpcHostMaddr,
		GrpcWebProxyAddress: grpcWebProxyAddr,

		GatewayHostAddr:      gatewayHostAddr,
		GatewayBasePath:      gatewayBasePath,
		IndexRawJSONHostAddr: indexRawJSONHostAddr,

		MongoURI: mongoURI,
		MongoDB:  mongoDB,

		FFSAdminToken:                ffsAdminToken,
		FFSUseMasterAddr:             ffsUseMasterAddr,
		FFSDealFinalityTimeout:       ffsDealWatchFinalityTimeout,
		FFSMinimumPieceSize:          ffsMinimumPieceSize,
		FFSRetrievalNextEventTimeout: ffsRetrievalNextEventTimeout,
		FFSMaxParallelDealPreparing:  ffsMaxParallelDealPreparing,
		FFSGCAutomaticGCInterval:     ffsGCInterval,
		FFSGCStageGracePeriod:        ffsGCStagedGracePeriod,
		AutocreateMasterAddr:         autocreateMasterAddr,
		MinerSelector:                minerSelector,
		MinerSelectorParams:          minerSelectorParams,
		SchedMaxParallel:             ffsSchedMaxParallel,
		DealWatchPollDuration:        dealWatchPollDuration,

		AskIndexQueryAskTimeout: askIndexQueryAskTimeout,
		AskIndexRefreshInterval: askIndexRefreshInterval,
		AskIndexRefreshOnStart:  askIndexRefreshOnStart,
		AskindexMaxParallel:     askIndexMaxParallel,

		IndexMinersRefreshOnStart:     indexMinersRefreshOnStart,
		IndexMinersOnChainMaxParallel: indexMinersOnChainMaxParallel,
		IndexMinersOnChainFrequency:   indexMinersOnChainFrequency,

		DisableIndices: disableIndices,

		DisableNonCompliantAPIs: disableNonCompliantAPIs,
	}, nil
}

func setupInstrumentation() error {
	exporter, err := prometheus.InstallNewPipeline(prometheus.Config{
		DefaultHistogramBoundaries: []float64{1e-4, 1e-3, 1e-2, 1e-1, 1},
	})
	if err != nil {
		log.Panicf("failed to initialize prometheus exporter %v", err)
	}
	http.HandleFunc("/metrics", exporter.ServeHTTP)
	go func() {
		_ = http.ListenAndServe(":8888", nil)
	}()

	if err := metricsOpenTelemetry.Inject(); err != nil {
		return fmt.Errorf("injecting datastore open-telemetry: %s", err)
	}

	if err := runtime.Start(runtime.WithMinimumReadMemStatsInterval(time.Second)); err != nil {
		return fmt.Errorf("starting Go runtime metrics: %s", err)
	}

	meter := global.Meter("powergate")
	attrBuildDate := attribute.Key("builddate").String(buildinfo.BuildDate)
	attrGitSummary := attribute.Key("gitsummary").String(buildinfo.GitSummary)
	attrGitBranch := attribute.Key("gitbranch").String(buildinfo.GitBranch)
	attrGitCommit := attribute.Key("gitcommit").String(buildinfo.GitCommit)
	metricInfo := metric.Must(meter).NewInt64Counter("powergate.info")
	metricInfo.Add(context.Background(), 1, attrBuildDate, attrGitSummary, attrGitBranch, attrGitCommit)

	return nil
}

func setupLogging(repoPath string) error {
	loggers := []string{
		// Top-level
		"powd",
		"server",
		"migrations",

		// Indexes & Reputation
		"index-miner",
		"index-ask",
		"index-faults",
		"reputation",
		"reputation-source-store",
		"chainstore",
		"fchost",
		"maxmind",
		"lotusidx-store",

		// Lotus client
		"lotus-client",

		// Deals Module
		"deals",
		"deals-records",
		"deals-watcher",

		// Wallet Module
		"lotus-wallet",

		// Miner Selectors
		"sr2-miner-selector",
		"reptop",

		// FFS
		"ffs-scheduler",
		"ffs-manager",
		"ffs-auth",
		"ffs-api",
		"ffs-coreipfs",
		"ffs-filcold",
		"ffs-sched-sjstore",
		"ffs-sched-cistore",
		"ffs-sched-rjstore",
		"ffs-cidlogger",
		"ffs-pinstore",

		// gRPC Services
		"user-service",
	}

	var ipfslog bool
	// Looking for ipfs/go-log setup environment variables
	// If at least one of them defined - do not override
	// ipfs/go-log internal logging setup
	for _, e := range os.Environ() {
		if strings.HasPrefix(e, "GOLOG_") {
			ipfslog = true
			break
		}
	}
	if !ipfslog {
		if err := os.MkdirAll(repoPath, os.ModePerm); err != nil {
			return fmt.Errorf("creating repo folder: %s", err)
		}
		cfg := logging.Config{
			Level:  logging.LevelError,
			Stdout: true,
			File:   filepath.Join(repoPath, "powd.log"),
		}
		logging.SetupLogging(cfg)

		// powd registered loggers get info level by default.
		for _, l := range loggers {
			if err := logging.SetLogLevel(l, "info"); err != nil {
				return fmt.Errorf("setting up logger %s: %s", l, err)
			}
		}
	}

	debugLevel := config.GetBool("debug")
	if debugLevel {
		for _, l := range loggers {
			if err := logging.SetLogLevel(l, "debug"); err != nil {
				return err
			}
		}
	}
	_ = logging.SetLogLevel("rpc", "FATAL")
	return nil
}

func getRepoPath(devnet bool) (string, error) {
	if devnet {
		repoPath, err := ioutil.TempDir("", ".powergate-*")
		if err != nil {
			return "", fmt.Errorf("generating temp for repo folder: %s", err)
		}
		return repoPath, nil
	}
	repoPath := config.GetString("repopath")
	if repoPath == "~/.powergate" {
		expandedPath, err := homedir.Expand(repoPath)
		if err != nil {
			log.Fatalf("expanding homedir: %s", err)
		}
		repoPath = expandedPath
	}
	return repoPath, nil
}

func getLotusToken(devnet bool) (string, error) {
	// If running in devnet, there's no need for Lotus API auth token.
	if devnet {
		return "", nil
	}

	token := config.GetString("lotustoken")
	if token != "" {
		return token, nil
	}

	path := config.GetString("lotustokenfile")
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return "", fmt.Errorf("lotus auth token can't be empty")
	}
	b, err := ioutil.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("reading token file from lotus")
	}
	return string(b), nil
}

func setupFlags() error {
	pflag.Bool("debug", false, "Enable debug log level in all loggers.")

	pflag.Bool("autocreatemasteraddr", false, "Automatically creates & funds a master address if none is provided.")
	pflag.Int64("walletinitialfund", 250_000_000_000_000_000, "FFS initial funding transaction amount in attoFIL received by --lotusmasteraddr. (if set)")

	pflag.String("grpchostaddr", "/ip4/0.0.0.0/tcp/5002", "gRPC host listening address.")
	pflag.String("grpcwebproxyaddr", "0.0.0.0:6002", "gRPC webproxy listening address.")
	pflag.String("indexrawjsonhostaddr", "0.0.0.0:8889", "Indexes raw json output listening address")

	pflag.String("lotushost", "/ip4/127.0.0.1/tcp/1234", "Lotus client API endpoint multiaddress.")
	pflag.String("lotustoken", "", "Lotus API authorization token. This flag or --lotustoken file are mandatory.")
	pflag.String("lotustokenfile", "", "Path of a file that contains the Lotus API authorization token.")
	pflag.String("lotusmasteraddr", "", "Existing wallet address in Lotus to be used as source of funding for new FFS instances. (Optional)")
	pflag.Int64("lotusconnectionretries", 180, "Maximum amount of connection retries when making API calls before considering them a failure. Retries are spaced by 10s. (default ~30min).")

	pflag.String("gatewayhostaddr", "0.0.0.0:7000", "Gateway host listening address.")
	pflag.String("gatewaybasepath", "/", "Gateway base path.")

	pflag.String("repopath", "~/.powergate", "Path of the repository where Powergate state will be saved.")
	pflag.Bool("devnet", false, "Indicate that will be running on an ephemeral devnet. --repopath will be autocleaned on exit.")
	pflag.String("ipfsapiaddr", "/ip4/127.0.0.1/tcp/5001", "IPFS API endpoint multiaddress. (Optional, only needed if FFS is used)")
	pflag.String("maxminddbfolder", ".", "Path of the folder containing GeoLite2-City.mmdb.")

	pflag.String("mongouri", "", "Mongo URI to connect to MongoDB database. (Optional: if empty, will use Badger).")
	pflag.String("mongodb", "", "Mongo database name. (if --mongouri is used, is mandatory.")

	pflag.String("ffsadmintoken", "", "FFS admin token for authorized APIs. If empty, the APIs will be open to the public.")
	pflag.Bool("ffsusemasteraddr", false, "Use the master address as the initial address for all new FFS instances instead of creating a new unique addess for each new FFS instance.")
	pflag.String("ffsminerselector", "reputation", "Miner selector to be used by FFS: 'sr2', 'reputation'.")
	pflag.String("ffsminerselectorparams", "", "Miner selector configuration parameter, depends on --ffsminerselector.")
	pflag.String("ffsminimumpiecesize", "67108864", "Minimum piece size in bytes allowed to be stored in Filecoin.")
	pflag.Duration("ffsretrievalnexteventtimeout", time.Hour, "Maximum amount of time to wait for the next retrieval event before erroring it.")
	pflag.String("ffsschedmaxparallel", "1000", "Maximum amount of Jobs executed in parallel.")
	pflag.String("ffsdealfinalitytimeout", "4320", "Deadline in minutes in which a deal must prove liveness changing status before considered abandoned.")
	pflag.String("ffsmaxparalleldealpreparing", "2", "Max parallel deal preparing tasks.")
	pflag.String("ffsgcinterval", "60", "Interval in minutes of Hot Storage GC for staged data; zero is never.")
	pflag.String("ffsgcstagedgraceperiod", "60", "Duration in minutes where a staged Cid will be considered GCable if scheduled in a Job.")
	pflag.String("dealwatchpollduration", "900", "Poll interval in seconds used by Deals Module watch to detect state changes.")

	pflag.String("askindexqueryasktimeout", "15", "Timeout in seconds for a query ask.")
	pflag.String("askindexrefreshinterval", "360", "Refresh interval measured in minutes.")
	pflag.Bool("askindexrefreshonstart", false, "If true it will refresh the index on start.")
	pflag.String("askindexmaxparallel", "3", "Max parallel query ask to execute while updating index.")

	pflag.Bool("indexminersrefreshonstart", false, "If true it will refresh the miner's on start.")
	pflag.Int64("indexminersonchainmaxparallel", 20, "Max parallelization for building on-chain sub-index")
	pflag.Duration("indexminersonchainfrequency", time.Hour*6, "Frequency of updating on-chain sub-index")

	pflag.Bool("disableindices", false, "Disable all indices updates, useful to help Lotus syncing process.")
	pflag.Bool("disablenoncompliantapis", false, "Disable APIs that may not easily comply with US law.")

	pflag.Parse()

	config.SetEnvPrefix("POWD")
	config.AutomaticEnv()
	if err := config.BindPFlags(pflag.CommandLine); err != nil {
		return fmt.Errorf("binding pflags: %s", err)
	}
	return nil
}

'''
'''--- Filecoin/powergate/dataprep/dataprep.go ---
package dataprep

import (
	"context"
	"fmt"
	"io"
	"os"

	commcid "github.com/filecoin-project/go-fil-commcid"
	commP "github.com/filecoin-project/go-fil-commp-hashhash"
	"github.com/ipfs/go-cid"
	files "github.com/ipfs/go-ipfs-files"
	"github.com/ipfs/go-ipfs/core/coreunix"
	ipld "github.com/ipfs/go-ipld-format"
	coreiface "github.com/ipfs/interface-go-ipfs-core"
)

// CommP calculates the piece cid and size from an io.Reader.
func CommP(r io.Reader) (cid.Cid, uint64, error) {
	cp := &commP.Calc{}
	_, err := io.Copy(cp, r)
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("copying data to aggregator: %s", err)
	}

	rawCommP, pieceSize, err := cp.Digest()
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("calculating final digest: %s", err)
	}
	pieceCid, err := commcid.DataCommitmentV1ToCID(rawCommP)
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("converting commP to cid: %s", err)
	}

	return pieceCid, pieceSize, nil
}

// Dagify creates a UnixFS DAG from the provided file.
func Dagify(ctx context.Context, dagService ipld.DAGService, path string, progressBytes chan<- int64) (cid.Cid, error) {
	fileAdder, err := coreunix.NewAdder(ctx, nil, nil, dagService)
	if err != nil {
		return cid.Undef, fmt.Errorf("creating unixfs adder: %s", err)
	}
	fileAdder.Pin = false
	fileAdder.Progress = true
	events := make(chan interface{}, 10)
	fileAdder.Out = events

	f, err := os.Open(path)
	if err != nil {
		return cid.Undef, fmt.Errorf("opening path: %s", err)
	}
	defer func() { _ = f.Close() }()

	stat, err := f.Stat()
	if err != nil {
		return cid.Undef, fmt.Errorf("getting stat of data: %s", err)
	}
	fs, err := files.NewSerialFile(path, false, stat)
	if err != nil {
		return cid.Undef, fmt.Errorf("creating serial file: %s", err)
	}
	defer func() { _ = fs.Close() }()

	var (
		dagifyErr error
		dataCid   cid.Cid
	)
	go func() {
		defer close(events)

		nd, err := fileAdder.AddAllAndPin(fs)
		if err != nil {
			dagifyErr = err
			return
		}
		dataCid = nd.Cid()
	}()
	currentName := ""
	var previousSize int64
	for event := range events {
		output, ok := event.(*coreiface.AddEvent)
		if !ok {
			return cid.Undef, fmt.Errorf("unknown event type")
		}
		if stat.IsDir() && output.Name == "" {
			continue
		}
		if currentName != output.Name {
			currentName = output.Name
			previousSize = 0
		}
		if output.Bytes > 0 && progressBytes != nil {
			progressBytes <- (-previousSize + output.Bytes)
		}
		previousSize = output.Bytes
	}
	if dagifyErr != nil {
		return cid.Undef, fmt.Errorf("creating dag for data: %s", dagifyErr)
	}

	return dataCid, nil
}

'''
'''--- Filecoin/powergate/deals/module/deals.go ---
package module

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/big"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/util"
)

const (
	defaultDealStartOffset = 48 * 60 * 60 / util.EpochDurationSeconds // 48hs
)

var (
	// ErrDealNotFound indicates a particular ProposalCid from a deal isn't found on-chain. Currently,
	// in Lotus this indicates that it may never existed on-chain, or it existed but it already expired
	// (currEpoch > StartEpoch+Duration).
	ErrDealNotFound = errors.New("deal not found on-chain")
)

// Store create Deal Proposals with all miners indicated in dcfgs. The epoch price
// is automatically calculated considering each miner epoch price and piece size.
// The data of dataCid should be already imported to the Filecoin Client or should be
// accessible to it. (e.g: is integrated with an IPFS node).
func (m *Module) Store(ctx context.Context, waddr string, dataCid cid.Cid, dataSize int64, pieceSize abi.PaddedPieceSize, pieceCid cid.Cid, dcfgs []deals.StorageDealConfig, minDuration uint64) ([]deals.StoreResult, error) {
	if minDuration < util.MinDealDuration {
		return nil, fmt.Errorf("duration %d should be greater or equal to %d", minDuration, util.MinDealDuration)
	}
	addr, err := address.NewFromString(waddr)
	if err != nil {
		return nil, fmt.Errorf("parsing wallet address: %s", err)
	}
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return nil, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	ts, err := lapi.ChainHead(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting chaing head: %s", err)
	}
	res := make([]deals.StoreResult, len(dcfgs))
	for i, c := range dcfgs {
		maddr, err := address.NewFromString(c.Miner)
		if err != nil {
			log.Errorf("invalid miner address %v: %s", c, err)
			res[i] = deals.StoreResult{
				Config: c,
			}
			continue
		}
		dealStartOffset := c.DealStartOffset
		if dealStartOffset == 0 {
			dealStartOffset = defaultDealStartOffset
		}
		params := &api.StartDealParams{
			Data: &storagemarket.DataRef{
				TransferType: storagemarket.TTGraphsync,
				Root:         dataCid,
				PieceCid:     &pieceCid,
				PieceSize:    pieceSize.Unpadded(),
			},
			MinBlocksDuration: minDuration,
			EpochPrice:        big.Div(big.Mul(big.NewIntUnsigned(c.EpochPrice), big.NewIntUnsigned(uint64(pieceSize))), abi.NewTokenAmount(1<<30)),
			Miner:             maddr,
			Wallet:            addr,
			FastRetrieval:     c.FastRetrieval,
			DealStartEpoch:    ts.Height() + abi.ChainEpoch(dealStartOffset),
			VerifiedDeal:      c.VerifiedDeal,
		}
		p, err := lapi.ClientStartDeal(ctx, params)
		if err != nil {
			log.Errorf("starting deal with %v: %s", c, err)
			res[i] = deals.StoreResult{
				Config:  c,
				Message: err.Error(),
			}
			continue
		}
		res[i] = deals.StoreResult{
			Config:      c,
			ProposalCid: *p,
			Success:     true,
		}
		m.recordDeal(params, *p, dataSize)
	}

	return res, nil
}

// Watch returns a channel with state changes of indicated proposals.
func (m *Module) Watch(ctx context.Context, proposal cid.Cid) (<-chan deals.StorageDealInfo, error) {
	updates := make(chan deals.StorageDealInfo)

	go func() {
		defer close(updates)

		watcherUpdates := make(chan struct{}, 20)
		if err := m.dealWatcher.Subscribe(watcherUpdates, proposal); err != nil {
			log.Errorf("subscribing to deal-watcher channel: %s", err)
		}
		defer func() {
			if err := m.dealWatcher.Unsubscribe(watcherUpdates, proposal); err != nil {
				log.Errorf("unregistering from deal-watcher: %s", err)
			}
		}()

		// Notify once so that subscribers get a result quickly
		last, err := m.getStorageDealInfo(ctx, proposal)
		if err != nil {
			log.Errorf("notifying latest proposal status: %s", err)
			return
		}
		updates <- last

		// Then notify every m.pollDuration
		for {
			select {
			case <-ctx.Done():
				return
			case <-time.After(m.pollDuration):
			case <-watcherUpdates:
			}

			sdi, err := m.getStorageDealInfo(ctx, proposal)
			if err != nil {
				log.Errorf("notifying latests proposal status: %s", err)
				return
			}
			if last.StateID != sdi.StateID {
				last = sdi
				updates <- last
			}
		}
	}()

	return updates, nil
}

func (m *Module) getStorageDealInfo(ctx context.Context, proposal cid.Cid) (deals.StorageDealInfo, error) {
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return deals.StorageDealInfo{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	dinfo, err := robustClientGetDealInfo(ctx, lapi, proposal)
	if err != nil {
		return deals.StorageDealInfo{}, fmt.Errorf("getting deal proposal info %s: %s", proposal, err)
	}

	sdi, err := fromLotusDealInfo(ctx, lapi, dinfo)
	if err != nil {
		return deals.StorageDealInfo{}, fmt.Errorf("converting proposal cid %s from lotus deal info: %v", util.CidToString(proposal), err)
	}

	return sdi, nil
}

func fromLotusDealInfo(ctx context.Context, client *api.FullNodeStruct, dinfo *api.DealInfo) (deals.StorageDealInfo, error) {
	di := deals.StorageDealInfo{
		ProposalCid:   dinfo.ProposalCid,
		StateID:       dinfo.State,
		StateName:     storagemarket.DealStates[dinfo.State],
		Miner:         dinfo.Provider.String(),
		PieceCID:      dinfo.PieceCID,
		Size:          dinfo.Size,
		PricePerEpoch: dinfo.PricePerEpoch.Uint64(),
		Duration:      dinfo.Duration,
		DealID:        uint64(dinfo.DealID),
		Message:       dinfo.Message,
	}
	if dinfo.State == storagemarket.StorageDealActive {
		ocd, err := client.StateMarketStorageDeal(ctx, dinfo.DealID, types.EmptyTSK)
		if err != nil {
			return deals.StorageDealInfo{}, fmt.Errorf("getting on-chain deal info: %s", err)
		}
		di.ActivationEpoch = int64(ocd.State.SectorStartEpoch)
		di.StartEpoch = uint64(ocd.Proposal.StartEpoch)
		di.Duration = uint64(ocd.Proposal.EndEpoch) - uint64(ocd.Proposal.StartEpoch) + 1
	}
	return di, nil
}

'''
'''--- Filecoin/powergate/deals/module/deals_test.go ---
package module

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

const (
	tmpDir = "/tmp/powergate/dealstest"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Second
	if err := os.RemoveAll(tmpDir); err != nil {
		panic(err)
	}
	if _, err := os.Stat(tmpDir); os.IsNotExist(err) {
		if err := os.MkdirAll(tmpDir, os.ModePerm); err != nil {
			panic(err)
		}
	}
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestStore(t *testing.T) {
	t.Parallel()
	numMiners := []int{1, 2}
	for _, nm := range numMiners {
		nm := nm
		t.Run(fmt.Sprintf("CantMiners%d", nm), func(t *testing.T) {
			t.Parallel()
			tests.RunFlaky(t, func(t *tests.FlakyT) {
				clientBuilder, addr, _ := tests.CreateLocalDevnet(t, nm, 300)
				m, err := New(tests.NewTxMapDatastore(), clientBuilder, util.AvgBlockTime, time.Minute*10, deals.WithImportPath(filepath.Join(tmpDir, "imports")))
				require.NoError(t, err)
				c, cls, err := clientBuilder(context.Background())
				require.NoError(t, err)
				defer cls()
				cid, pcids, err := storeMultiMiner(m, c, nm, randomBytes(600))
				require.NoError(t, err)
				pending, err := m.ListStorageDealRecords(
					deals.WithIncludePending(true),
					deals.WithDataCids(util.CidToString(cid)),
					deals.WithAscending(true),
					deals.WithFromAddrs(addr.String()),
				)
				require.NoError(t, err)
				require.Len(t, pending, nm)
				final, err := m.ListStorageDealRecords(deals.WithIncludeFinal(true))
				require.NoError(t, err)
				require.Empty(t, final)
				err = waitForDealComplete(c, pcids)
				require.NoError(t, err)
				time.Sleep(util.AvgBlockTime)
				pending, err = m.ListStorageDealRecords(deals.WithIncludePending(true))
				require.NoError(t, err)
				require.Empty(t, pending)
				final, err = m.ListStorageDealRecords(
					deals.WithIncludeFinal(true),
					deals.WithDataCids(util.CidToString(cid)),
					deals.WithAscending(true),
					deals.WithFromAddrs(addr.String()),
				)
				require.NoError(t, err)
				require.Len(t, final, nm)
				for _, r := range final {
					require.Greater(t, r.TransferSize, int64(600)) // Greater since DAG transformation has an ovehead.
					require.Greater(t, r.DataTransferStart, int64(0))
					require.Greater(t, r.DataTransferEnd, int64(0))
					require.True(t, r.DataTransferStart <= r.DataTransferEnd)
					require.Greater(t, r.SealingStart, int64(0))
					require.Greater(t, r.SealingEnd, int64(0))
					require.True(t, r.SealingStart < r.SealingEnd)
				}
			})
		})
	}
}

func TestRetrieve(t *testing.T) {
	t.Parallel()
	numMiners := []int{1} // go-fil-markets: doesn't support remembering more than 1 miner
	for _, nm := range numMiners {
		nm := nm
		t.Run(fmt.Sprintf("CantMiners%d", nm), func(t *testing.T) {
			t.Parallel()
			tests.RunFlaky(t, func(t *tests.FlakyT) {
				data := randomBytes(600)
				clientBuilder, addr, _ := tests.CreateLocalDevnet(t, nm, 300)
				m, err := New(tests.NewTxMapDatastore(), clientBuilder, util.AvgBlockTime, time.Minute*10, deals.WithImportPath(filepath.Join(tmpDir, "imports")))
				require.NoError(t, err)
				c, cls, err := clientBuilder(context.Background())
				require.NoError(t, err)
				defer cls()

				dcid, pcids, err := storeMultiMiner(m, c, nm, data)
				require.NoError(t, err)

				err = waitForDealComplete(c, pcids)
				require.NoError(t, err)
				ctx, cancel := context.WithTimeout(context.Background(), time.Hour)
				defer cancel()

				miner, r, err := m.Retrieve(ctx, addr.String(), dcid, nil, []string{"t01000"}, false)
				require.NoError(t, err)
				require.NotEmpty(t, miner)
				defer func() {
					require.NoError(t, r.Close())
				}()
				rdata, err := ioutil.ReadAll(r)
				require.NoError(t, err)
				require.True(t, bytes.Equal(data, rdata), "retrieved data doesn't match with stored data")
				retrievals, err := m.ListRetrievalDealRecords()
				require.NoError(t, err)
				require.Len(t, retrievals, 1)
			})
		})
	}
}

func storeMultiMiner(m *Module, client *api.FullNodeStruct, numMiners int, data []byte) (cid.Cid, []cid.Cid, error) {
	ctx := context.Background()
	miners, err := client.StateListMiners(ctx, types.EmptyTSK)
	if err != nil {
		return cid.Undef, nil, err
	}
	if len(miners) != numMiners {
		return cid.Undef, nil, fmt.Errorf("unexpected number of miners in the network")
	}
	addr, err := client.WalletDefaultAddress(ctx)
	if err != nil {
		return cid.Undef, nil, err
	}

	cfgs := make([]deals.StorageDealConfig, numMiners)
	for i := 0; i < numMiners; i++ {
		cfgs[i] = deals.StorageDealConfig{
			Miner:      miners[i].String(),
			EpochPrice: 500000000,
		}
	}
	dataCid, _, err := m.Import(ctx, bytes.NewReader(data), false)
	if err != nil {
		return cid.Undef, nil, err
	}
	if !dataCid.Defined() {
		return cid.Undef, nil, fmt.Errorf("data cid is undefined")
	}
	piece, err := m.CalculateDealPiece(ctx, dataCid)
	if err != nil {
		return cid.Undef, nil, err
	}
	srs, err := m.Store(ctx, addr.String(), dataCid, piece.PayloadSize, piece.PieceSize, piece.PieceCID, cfgs, util.MinDealDuration)
	if err != nil {
		return cid.Undef, nil, fmt.Errorf("calling Store(): %s", err)
	}

	var pcids []cid.Cid
	for _, r := range srs {
		if !r.Success {
			return cid.Undef, nil, fmt.Errorf("%v deal configurations failed", r)
		}
		pcids = append(pcids, r.ProposalCid)
	}
	if len(srs) != len(cfgs) {
		return cid.Undef, nil, fmt.Errorf("some deal cids are missing, got %d, expected %d", len(srs), len(cfgs))
	}
	return dataCid, pcids, nil
}

func waitForDealComplete(client *api.FullNodeStruct, deals []cid.Cid) error {
	ctx := context.Background()
	finished := make(map[cid.Cid]struct{})
	for len(finished) != len(deals) {
		time.Sleep(time.Second)
		for _, d := range deals {
			if _, ok := finished[d]; ok {
				continue
			}

			di, err := client.ClientGetDealInfo(ctx, d)
			if err != nil {
				return err
			}
			if di.State == storagemarket.StorageDealActive {
				finished[d] = struct{}{}
				continue
			}
			switch di.State {
			case
				storagemarket.StorageDealUnknown,
				storagemarket.StorageDealWaitingForData,
				storagemarket.StorageDealProposalAccepted,
				storagemarket.StorageDealStaged,
				storagemarket.StorageDealValidating,
				storagemarket.StorageDealTransferring,
				storagemarket.StorageDealCheckForAcceptance,
				storagemarket.StorageDealReserveClientFunds,
				storagemarket.StorageDealClientFunding,
				storagemarket.StorageDealPublish,
				storagemarket.StorageDealPublishing,
				storagemarket.StorageDealSealing,
				storagemarket.StorageDealAwaitingPreCommit:
			default:

				return fmt.Errorf("unexpected deal state: %s", storagemarket.DealStates[di.State])
			}
		}
	}
	return nil
}

func randomBytes(size int) []byte {
	r := rand.New(rand.NewSource(22))
	return randomBytesFromSource(size, r)
}

func randomBytesFromSource(size int, r *rand.Rand) []byte {
	buf := make([]byte, size)
	_, _ = r.Read(buf)
	return buf
}

'''
'''--- Filecoin/powergate/deals/module/dealwatcher/dealwatcher.go ---
package dealwatcher

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/filecoin-project/lotus/api"
	"github.com/ipfs/go-cid"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/lotus"
	"go.opentelemetry.io/otel/metric"
)

var (
	log = logger.Logger("deals-watcher")

	// ErrNotFound is returned when a subscription isn't found.
	ErrNotFound = errors.New("subscription not found")
	// ErrActiveSubscription is returned when an already registered channel is registered again.
	ErrActiveSubscription = errors.New("active subscription")
)

// DealWatcher provides a centralize way to watch for deal updates.
type DealWatcher struct {
	cb lotus.ClientBuilder

	lock sync.Mutex
	subs map[cid.Cid][]chan<- struct{}

	closeLock     sync.Mutex
	closeCtx      context.Context
	closeCancel   context.CancelFunc
	closeFinished chan struct{}
	closed        bool

	// Metrics
	metricDealUpdates            metric.Int64Counter
	metricDealUpdatesChanFailure metric.Int64Counter
}

// New returns a new DealWatcher.
func New(cb lotus.ClientBuilder) (*DealWatcher, error) {
	ctx, cls := context.WithCancel(context.Background())
	dw := &DealWatcher{
		cb:            cb,
		subs:          make(map[cid.Cid][]chan<- struct{}),
		closeCtx:      ctx,
		closeCancel:   cls,
		closeFinished: make(chan struct{}),
	}

	dw.startDaemon()
	dw.initMetrics()

	return dw, nil
}

// Subscribe registers a channel that will receive updates for a proposalCid.
func (dw *DealWatcher) Subscribe(ch chan<- struct{}, proposalCid cid.Cid) error {
	dw.lock.Lock()
	defer dw.lock.Unlock()

	for _, ich := range dw.subs[proposalCid] {
		if ch == ich {
			return ErrActiveSubscription
		}
	}

	dw.subs[proposalCid] = append(dw.subs[proposalCid], ch)

	log.Infof("subscriber registered")
	return nil
}

// Unsubscribe removes a previously registered channel to stop receiving updates.
func (dw *DealWatcher) Unsubscribe(ch chan<- struct{}, proposalCid cid.Cid) error {
	dw.lock.Lock()
	defer dw.lock.Unlock()

	subs, ok := dw.subs[proposalCid]
	if !ok {
		return ErrNotFound
	}
	idx := -1
	for i := range subs {
		if subs[i] == ch {
			idx = i
			break
		}
	}
	if idx == -1 {
		return ErrNotFound
	}
	if len(subs) == 1 {
		delete(dw.subs, proposalCid)
		return nil
	}
	subs[idx] = subs[len(subs)-1]
	subs = subs[:len(subs)-1]
	dw.subs[proposalCid] = subs

	return nil
}

// Close gracefully shutdowns the deal watcher.
func (dw *DealWatcher) Close() error {
	dw.closeLock.Lock()
	defer dw.closeLock.Unlock()

	if dw.closed {
		return nil
	}
	dw.closed = true

	dw.closeCancel()
	<-dw.closeFinished

	return nil
}

func (dw *DealWatcher) startDaemon() {
	createUpdateChan := func() (<-chan api.DealInfo, func(), error) {
		c, cls, err := dw.cb(dw.closeCtx)
		if err != nil {
			return nil, nil, fmt.Errorf("creating lotus client: %s", err)
		}

		updates, err := c.ClientGetDealUpdates(dw.closeCtx)
		if err != nil {
			return nil, nil, fmt.Errorf("creating lotus deal updates channel: %s", err)
		}
		return updates, cls, nil
	}

	go func() {
		updates, cls, err := createUpdateChan()
		if err != nil {
			log.Errorf("creating initial updates chan: %s", err)
			return
		}
		log.Infof("deal watcher created")
		defer close(dw.closeFinished)
		defer func() { cls() }()

		for {
			select {
			case <-dw.closeCtx.Done():
				return
			case di, ok := <-updates:
				if !ok {
					if dw.closeCtx.Err() != nil {
						return
					}

					dw.metricDealUpdatesChanFailure.Add(dw.closeCtx, 1)
					log.Warnf("updates channel closed unexpectedly")

					cls() // Formally closed broken chan.
					for {
						updates, cls, err = createUpdateChan()
						if err != nil {
							log.Warnf("reconstructing updates channel: %s", err)
							time.Sleep(time.Second * 30)
							continue
						}
						break
					}
				}

				dw.lock.Lock()

				subs, ok := dw.subs[di.ProposalCid]
				if !ok {
					dw.lock.Unlock()

					dw.metricDealUpdates.Add(dw.closeCtx, 1, attrDealUntracked)
					continue
				}
				dw.metricDealUpdates.Add(dw.closeCtx, 1, attrDealTracked)
				for _, s := range subs {
					select {
					case s <- struct{}{}:
					default:
						log.Warn("skipping slow receiver")
					}
				}
				dw.lock.Unlock()
			}
		}
	}()
}

'''
'''--- Filecoin/powergate/deals/module/dealwatcher/metrics.go ---
package dealwatcher

import (
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	attrDealTracked   = attribute.Key("tracked").String("yes")
	attrDealUntracked = attribute.Key("tracked").String("no")
)

func (dw *DealWatcher) initMetrics() {
	meter := global.Meter("powergate")

	dw.metricDealUpdates = metric.Must(meter).NewInt64Counter("powergate.dealwatcher.updates.total")
	dw.metricDealUpdatesChanFailure = metric.Must(meter).NewInt64Counter("powergate.dealwatcher.updates.chan.failure.total")
}

'''
'''--- Filecoin/powergate/deals/module/metrics.go ---
package module

import (
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

func (m *Module) initMetrics() {
	meter := global.Meter("powergate")
	m.metricDealTracking = metric.Must(meter).NewInt64UpDownCounter("powergate.deal.tracking")
	m.metricRetrievalTracking = metric.Must(meter).NewInt64UpDownCounter("powergate.retrieval.tracking")
}

'''
'''--- Filecoin/powergate/deals/module/module.go ---
package module

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"time"

	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/deals/module/dealwatcher"
	"github.com/textileio/powergate/v2/deals/module/store"
	"github.com/textileio/powergate/v2/lotus"
	"go.opentelemetry.io/otel/metric"
)

var (
	log = logging.Logger("deals")
)

// Module exposes storage and monitoring from the market.
type Module struct {
	clientBuilder       lotus.ClientBuilder
	cfg                 *deals.Config
	store               *store.Store
	dealWatcher         *dealwatcher.DealWatcher
	pollDuration        time.Duration
	dealFinalityTimeout time.Duration

	metricDealTracking      metric.Int64UpDownCounter
	metricRetrievalTracking metric.Int64UpDownCounter
}

// New creates a new Module.
func New(ds datastore.TxnDatastore, clientBuilder lotus.ClientBuilder, pollDuration time.Duration, dealFinalityTimeout time.Duration, opts ...deals.Option) (*Module, error) {
	var cfg deals.Config
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			return nil, err
		}
	}

	log.Infof("creating deal watcher")
	dw, err := dealwatcher.New(clientBuilder)
	if err != nil {
		return nil, fmt.Errorf("creating deal watcher: %s", err)
	}
	m := &Module{
		clientBuilder:       clientBuilder,
		cfg:                 &cfg,
		store:               store.New(ds),
		pollDuration:        pollDuration,
		dealFinalityTimeout: dealFinalityTimeout,
		dealWatcher:         dw,
	}
	m.initMetrics()

	log.Infof("resuming pending records")
	if err := m.resumeWatchingPendingRecords(); err != nil {
		return nil, fmt.Errorf("resuming watching pending records: %s", err)
	}

	return m, nil
}

// GetDealInfo returns info about a deal. If the deal isn't active on-chain,
// it returns ErrDealNotFound.
func (m *Module) GetDealInfo(ctx context.Context, dealID uint64) (api.MarketDeal, error) {
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return api.MarketDeal{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	id := abi.DealID(dealID)
	smd, err := lapi.StateMarketStorageDeal(ctx, id, types.EmptyTSK)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			return api.MarketDeal{}, ErrDealNotFound
		}
		return api.MarketDeal{}, fmt.Errorf("getting deal info: %s", err)
	}
	if smd == nil {
		return api.MarketDeal{}, fmt.Errorf("deal on-chain information is empty")
	}

	return *smd, nil
}

// CalculateDealPiece calculates the size and CommP for a data cid.
func (m *Module) CalculateDealPiece(ctx context.Context, c cid.Cid) (api.DataCIDSize, error) {
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return api.DataCIDSize{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	dsz, err := lapi.ClientDealPieceCID(ctx, c)
	if err != nil {
		return api.DataCIDSize{}, fmt.Errorf("calculating data size: %s", err)
	}
	return dsz, nil
}

// Import imports raw data in the Filecoin client. The isCAR flag indicates if the data
// is already in CAR format, so it shouldn't be encoded into a UnixFS DAG in the Filecoin client.
// It returns the imported data cid and the data size.
func (m *Module) Import(ctx context.Context, data io.Reader, isCAR bool) (cid.Cid, int64, error) {
	f, err := ioutil.TempFile(m.cfg.ImportPath, "import-*")
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("error when creating tmpfile: %s", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Errorf("closing storing file: %s", err)
		}
	}()
	var size int64
	if size, err = io.Copy(f, data); err != nil {
		return cid.Undef, 0, fmt.Errorf("error when copying data to tmpfile: %s", err)
	}
	ref := api.FileRef{
		Path:  f.Name(),
		IsCAR: isCAR,
	}
	api, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	res, err := api.ClientImport(ctx, ref)
	if err != nil {
		return cid.Undef, 0, fmt.Errorf("error when importing data: %s", err)
	}
	return res.Root, size, nil
}

// Close gracefully shutdowns the deals module.
func (m *Module) Close() error {
	if err := m.dealWatcher.Close(); err != nil {
		return fmt.Errorf("closing deal watcher: %s", err)
	}
	return nil
}

func robustClientGetDealInfo(ctx context.Context, lapi *api.FullNodeStruct, propCid cid.Cid) (*api.DealInfo, error) {
	di, err := lapi.ClientGetDealInfo(ctx, propCid)
	if err != nil {
		return nil, fmt.Errorf("client get deal info: %s", err)
	}

	// Workaround ClientGetDealInfo giving unreliable status.
	// If the state isn't Active, double-check with on-chain API.
	if di.DealID != 0 && di.State != storagemarket.StorageDealActive {
		smd, err := lapi.StateMarketStorageDeal(ctx, di.DealID, types.EmptyTSK)
		if err != nil {
			// If the DealID is not found, most probably is because the Lotus
			// node isn't yet synced. Since all this logic is a workaround
			// for a problem, make an exception and just return what
			// ClientGetDealInfo said.
			if strings.Contains(err.Error(), "not found") {
				return di, nil
			}
			return nil, fmt.Errorf("state market storage deal: %s", err)
		}
		if smd.State.SectorStartEpoch > 0 {
			di.State = storagemarket.StorageDealActive
		}
	}
	return di, nil
}

'''
'''--- Filecoin/powergate/deals/module/records.go ---
package module

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"time"

	datatransfer "github.com/filecoin-project/go-data-transfer"
	sm "github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/lotus/api"
	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/util"
)

var (
	errWatchingTimeout         = "pow watching timeout"
	errWatchingUnexpectedClose = "pow watching unexpected closing"
)

// ListStorageDealRecords lists storage deals according to the provided options.
func (m *Module) ListStorageDealRecords(opts ...deals.DealRecordsOption) ([]deals.StorageDealRecord, error) {
	c := deals.DealRecordsConfig{}
	for _, opt := range opts {
		opt(&c)
	}

	if !c.IncludeFinal && !c.IncludePending {
		return nil, fmt.Errorf("you must specify one or both options of IncludePending and IncludeFinal")
	}

	var final []deals.StorageDealRecord
	if c.IncludeFinal {
		recs, err := m.store.GetFinalStorageDeals()
		if err != nil {
			return nil, fmt.Errorf("getting final deals: %v", err)
		}
		final = recs
	}

	var pending []deals.StorageDealRecord
	if c.IncludePending {
		recs, err := m.store.GetPendingStorageDeals()
		if err != nil {
			return nil, fmt.Errorf("getting pending deals: %v", err)
		}
		pending = recs
	}

	combined := append(final, pending...)

	var filtered []deals.StorageDealRecord

	if len(c.FromAddrs) > 0 || len(c.DataCids) > 0 || !c.IncludeFailed {
		fromAddrsFilter := make(map[string]struct{})
		dataCidsFilter := make(map[string]struct{})
		for _, addr := range c.FromAddrs {
			fromAddrsFilter[addr] = struct{}{}
		}
		for _, cid := range c.DataCids {
			dataCidsFilter[cid] = struct{}{}
		}
		for _, record := range combined {
			_, inFromAddrsFilter := fromAddrsFilter[record.Addr]
			_, inDataCidsFilter := dataCidsFilter[util.CidToString(record.RootCid)]
			includeViaFromAddrs := len(c.FromAddrs) == 0 || inFromAddrsFilter
			includeViaDataCids := len(c.DataCids) == 0 || inDataCidsFilter
			includeViaIncludeFailed := !c.IncludeFailed || record.ErrMsg != ""
			if includeViaFromAddrs && includeViaDataCids && includeViaIncludeFailed {
				filtered = append(filtered, record)
			}
		}
	} else {
		filtered = combined
	}

	sort.Slice(filtered, func(i, j int) bool {
		l := filtered[j]
		r := filtered[i]
		if c.Ascending {
			l = filtered[i]
			r = filtered[j]
		}
		return l.Time < r.Time
	})

	return filtered, nil
}

// ListRetrievalDealRecords returns a list of retrieval deals according to the provided options.
func (m *Module) ListRetrievalDealRecords(opts ...deals.DealRecordsOption) ([]deals.RetrievalDealRecord, error) {
	c := deals.DealRecordsConfig{}
	for _, opt := range opts {
		opt(&c)
	}
	ret, err := m.store.GetRetrievals()
	if err != nil {
		return nil, fmt.Errorf("getting retrievals: %v", err)
	}

	var filtered []deals.RetrievalDealRecord

	if len(c.FromAddrs) > 0 || len(c.DataCids) > 0 || !c.IncludeFailed {
		fromAddrsFilter := make(map[string]struct{})
		dataCidsFilter := make(map[string]struct{})
		for _, addr := range c.FromAddrs {
			fromAddrsFilter[addr] = struct{}{}
		}
		for _, cid := range c.DataCids {
			dataCidsFilter[cid] = struct{}{}
		}

		for _, record := range ret {
			_, inFromAddrsFilter := fromAddrsFilter[record.Addr]
			_, inDataCidsFilter := dataCidsFilter[util.CidToString(record.DealInfo.RootCid)]
			includeViaFromAddrs := len(c.FromAddrs) == 0 || inFromAddrsFilter
			includeViaDataCids := len(dataCidsFilter) == 0 || inDataCidsFilter
			includeViaIncludeFailed := c.IncludeFailed || record.ErrMsg == ""
			if includeViaFromAddrs && includeViaDataCids && includeViaIncludeFailed {
				filtered = append(filtered, record)
			}
		}
	} else {
		filtered = ret
	}

	sort.Slice(filtered, func(i, j int) bool {
		l := filtered[j]
		r := filtered[i]
		if c.Ascending {
			l = filtered[i]
			r = filtered[j]
		}
		return l.Time < r.Time
	})

	return filtered, nil
}

// GetUpdatedStorageDealRecordsSince returns all the storage deal records that got created or updated
// since sinceNano.
func (m *Module) GetUpdatedStorageDealRecordsSince(since time.Time, limit int) ([]deals.StorageDealRecord, error) {
	r, err := m.store.GetUpdatedStorageDealRecordsSince(since, limit)
	if err != nil {
		return nil, fmt.Errorf("get updated storage deal records from store: %s", err)
	}

	return r, nil
}

// GetUpdatedRetrievalRecordsSince returns all the retrieval records that got created or updated
// since sinceNano.
func (m *Module) GetUpdatedRetrievalRecordsSince(since time.Time, limit int) ([]deals.RetrievalDealRecord, error) {
	r, err := m.store.GetUpdatedRetrievalRecordsSince(since, limit)
	if err != nil {
		return nil, fmt.Errorf("get updated retrieval records from store: %s", err)
	}

	return r, nil
}

func (m *Module) resumeWatchingPendingRecords() error {
	pendingStorageRecords, err := m.store.GetPendingStorageDeals()
	if err != nil {
		return fmt.Errorf("getting pending storage records from store: %v", err)
	}

	log.Infof("resuming %d pending records", len(pendingStorageRecords))
	for _, dr := range pendingStorageRecords {
		remaining := time.Until(time.Unix(dr.Time, 0).Add(m.dealFinalityTimeout))
		if remaining <= 0 {
			go m.finalizePendingDeal(dr)
		} else {
			go m.eventuallyFinalizeDeal(dr, remaining)
		}
	}
	log.Infof("resumed watching %d pending storage deal records", len(pendingStorageRecords))

	return nil
}

func (m *Module) recordDeal(params *api.StartDealParams, proposalCid cid.Cid, dataSize int64) {
	di := deals.StorageDealInfo{
		Duration:      params.MinBlocksDuration,
		PricePerEpoch: params.EpochPrice.Uint64(),
		Miner:         params.Miner.String(),
		ProposalCid:   proposalCid,
	}
	record := deals.StorageDealRecord{
		RootCid:      params.Data.Root,
		Addr:         params.Wallet.String(),
		Time:         time.Now().Unix(),
		DealInfo:     di,
		Pending:      true,
		TransferSize: dataSize,
	}
	log.Infof("storing pending deal record for proposal cid: %s", util.CidToString(proposalCid))
	if err := m.store.PutStorageDeal(record); err != nil {
		log.Errorf("storing pending deal: %v", err)
		return
	}
	go m.eventuallyFinalizeDeal(record, m.dealFinalityTimeout)
}

func (m *Module) finalizePendingDeal(dr deals.StorageDealRecord) {
	lapi, cls, err := m.clientBuilder(context.Background())
	if err != nil {
		log.Errorf("finalize pending deal, creating client: %s", err)
		return
	}
	defer cls()

	ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
	defer cancel()
	info, err := robustClientGetDealInfo(ctx, lapi, dr.DealInfo.ProposalCid)
	if err != nil {
		errMsg := fmt.Sprintf("getting deal info: %s", err)
		log.Error(errMsg)
		dr.Pending = false
		dr.ErrMsg = errMsg
		if err := m.store.PutStorageDeal(dr); err != nil {
			log.Errorf("erroring pending deal for proposal cid %s: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
		}
		return
	}
	if info.State != sm.StorageDealActive {
		log.Infof("pending deal for proposal cid %s isn't active yet, erroring pending deal", util.CidToString(dr.DealInfo.ProposalCid))

		dr.Pending = false
		dr.ErrMsg = fmt.Sprintf("deal failed with status %s", sm.DealStates[info.State])
		if err := m.store.PutStorageDeal(dr); err != nil {
			log.Errorf("erroring pending deal for proposal cid %s: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
		}
	} else {
		di, err := fromLotusDealInfo(ctx, lapi, info)
		if err != nil {
			dr.Pending = false
			dr.ErrMsg = fmt.Sprintf("converting proposal cid %s from lotus deal info: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
			log.Errorf(dr.ErrMsg)
			if err := m.store.PutStorageDeal(dr); err != nil {
				log.Errorf("erroring pending deal for proposal cid %s: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
			}
			return
		}
		record := deals.StorageDealRecord{
			RootCid:  dr.RootCid,
			Addr:     dr.Addr,
			Time:     time.Now().Unix(), // Note: This can be much later in time than the deal actually became active on chain
			DealInfo: di,
			Pending:  false,
		}
		if err := m.store.PutStorageDeal(record); err != nil {
			log.Errorf("storing proposal cid %s deal record: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
		}
	}
}

func (m *Module) eventuallyFinalizeDeal(dr deals.StorageDealRecord, timeout time.Duration) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	m.metricDealTracking.Add(ctx, 1)
	defer m.metricDealTracking.Add(ctx, -1)

	dealUpdates, err := m.Watch(ctx, dr.DealInfo.ProposalCid)
	if err != nil {
		log.Errorf("watching proposal cid %s: %v", util.CidToString(dr.DealInfo.ProposalCid), err)
		return
	}
	dataTransferUpdates := make(chan dataTransferUpdate)
	go func() {
		if err = m.dataTransferUpdates(ctx, dr.DealInfo.ProposalCid, dataTransferUpdates); err != nil {
			log.Errorf("watching data transfer updates: %s", err)
			return
		}
	}()

	for {
		select {
		case <-ctx.Done():
			log.Infof("watching proposal cid %s timed out, erroring pending deal", util.CidToString(dr.DealInfo.ProposalCid))
			dr.Pending = false
			dr.ErrMsg = errWatchingTimeout
			if err := m.store.PutStorageDeal(dr); err != nil {
				log.Errorf("erroring pending deal: %v", err)
			}
			return
		case info, ok := <-dealUpdates:
			if !ok {
				log.Errorf("deal updates channel unexpectedly closed for proposal cid %s", util.CidToString(dr.DealInfo.ProposalCid))
				dr.Pending = false
				dr.ErrMsg = errWatchingUnexpectedClose
				if err := m.store.PutStorageDeal(dr); err != nil {
					log.Errorf("erroring pending deal: %v", err)
				}
				return
			}

			dr.DealInfo = info
			switch info.StateID {
			// Final status (`return`)
			case sm.StorageDealActive:
				dr.Pending = false
				if dr.SealingStart > 0 && dr.SealingEnd == 0 {
					dr.SealingEnd = time.Now().Unix()
				}
				log.Infof("proposal cid %s is active, storing deal record", util.CidToString(info.ProposalCid))
				if err := m.store.PutStorageDeal(dr); err != nil {
					log.Errorf("storing proposal cid %s deal record: %v", util.CidToString(info.ProposalCid), err)
				}
				return
			case sm.StorageDealProposalNotFound, sm.StorageDealProposalRejected, sm.StorageDealFailing, sm.StorageDealError:
				log.Infof("proposal cid %s failed with state %s, saving pending deal as failed", util.CidToString(info.ProposalCid), sm.DealStates[info.StateID])

				dr.Pending = false
				dr.ErrMsg = fmt.Sprintf("deal failed with status %s", sm.DealStates[info.StateID])
				if err := m.store.PutStorageDeal(dr); err != nil {
					log.Errorf("saving successful storage deal record: %v", err)
				}
				return

			// This case is just being paranoid of dataTransferUpdates not reporting the ending transfer time.
			// If we're in this status, data transfer should already finished, so just check if we got into
			// that situation and account for it. Shouldn't happen if Lotus doesn't misreports events.
			case sm.StorageDealCheckForAcceptance, sm.StorageDealProposalAccepted, sm.StorageDealAwaitingPreCommit:
				if dr.DataTransferStart > 0 && dr.DataTransferEnd == 0 {
					dr.DataTransferEnd = time.Now().Unix()
					if err := m.store.PutStorageDeal(dr); err != nil {
						log.Errorf("saving data transfer start time: %s", err)
					}
				}
			case sm.StorageDealSealing:
				if dr.SealingStart == 0 {
					dr.SealingStart = time.Now().Unix()
					if err := m.store.PutStorageDeal(dr); err != nil {
						log.Errorf("saving sealing start time: %s", err)
					}
				}
			}
		case u := <-dataTransferUpdates:
			if dr.DataTransferStart == 0 && !u.start.IsZero() {
				dr.DataTransferStart = u.start.Unix()
				if err := m.store.PutStorageDeal(dr); err != nil {
					log.Errorf("saving data transfer start time: %s", err)
				}
			}
			if dr.DataTransferEnd == 0 && !u.end.IsZero() {
				dr.DataTransferEnd = u.end.Unix()
				if err := m.store.PutStorageDeal(dr); err != nil {
					log.Errorf("saving data transfer end time: %s", err)
				}
			}
		}
	}
}

type dataTransferUpdate struct {
	start time.Time
	end   time.Time
}

type dealTransferVoucher struct {
	Proposal cid.Cid
}

func (m *Module) dataTransferUpdates(ctx context.Context, proposalCid cid.Cid, updates chan<- dataTransferUpdate) error {
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return fmt.Errorf("measure data transfer creating client: %s", err)
	}
	defer cls()
	ch, err := lapi.ClientDataTransferUpdates(ctx)
	if err != nil {
		return fmt.Errorf("measure data transfer getting update channel from lotus: %s", err)
	}

	var dtStart time.Time
	for {
		select {
		case <-ctx.Done():
			return nil
		case u, ok := <-ch:
			if !ok {
				return fmt.Errorf("data transfer updates channel unexpectedly closed: %s", err)
			}
			var dtVoucher dealTransferVoucher
			if err := json.Unmarshal([]byte(u.Voucher), &dtVoucher); err != nil {
				continue
			}
			if dtVoucher.Proposal != proposalCid {
				continue
			}
			switch u.Status {
			case datatransfer.Ongoing:
				if dtStart.IsZero() {
					dtStart = time.Now()
					updates <- dataTransferUpdate{start: dtStart, end: time.Time{}}
				}
			case datatransfer.Completed:
				updates <- dataTransferUpdate{start: dtStart, end: time.Now()}
				return nil
			case datatransfer.Failed, datatransfer.Cancelled:
				return nil
			}
		}
	}
}

func (m *Module) recordRetrieval(addr string, offer api.QueryOffer, bytesReceived uint64, dtStart, dtEnd time.Time, errMsg string) {
	rr := deals.RetrievalDealRecord{
		Addr: addr,
		Time: time.Now().Unix(),
		DealInfo: deals.RetrievalDealInfo{
			RootCid:                 offer.Root,
			Size:                    offer.Size,
			MinPrice:                offer.MinPrice.Uint64(),
			Miner:                   offer.MinerPeer.Address.String(),
			MinerPeerID:             offer.MinerPeer.ID.String(),
			PaymentInterval:         offer.PaymentInterval,
			PaymentIntervalIncrease: offer.PaymentIntervalIncrease,
		},
		DataTransferStart: dtStart.Unix(),
		DataTransferEnd:   dtEnd.Unix(),
		BytesReceived:     bytesReceived,
		ErrMsg:            errMsg,
	}
	if err := m.store.PutRetrieval(rr); err != nil {
		log.Errorf("storing retrieval: %v", err)
	}
}

'''
'''--- Filecoin/powergate/deals/module/retrieve.go ---
package module

import (
	"context"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-fil-markets/retrievalmarket"
	"github.com/filecoin-project/lotus/api"
	marketevents "github.com/filecoin-project/lotus/markets/loggers"
	"github.com/ipfs/go-cid"
)

var (
	// ErrRetrievalNoAvailableProviders indicates that the data isn't available on any provided
	// to be retrieved.
	ErrRetrievalNoAvailableProviders = errors.New("no providers to retrieve the data")
)

// Fetch fetches deal data to the underlying blockstore of the Filecoin client.
// This API is meant for clients that use external implementations of blockstores with
// their own API, e.g: IPFS.
func (m *Module) Fetch(ctx context.Context, waddr string, payloadCid cid.Cid, pieceCid *cid.Cid, miners []string) (string, <-chan marketevents.RetrievalEvent, error) {
	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return "", nil, fmt.Errorf("creating lotus client: %s", err)
	}

	miner, events, err := m.retrieve(ctx, lapi, cls, waddr, payloadCid, pieceCid, miners, nil)
	if err != nil {
		return "", nil, err
	}
	return miner, events, nil
}

// Retrieve retrieves Deal data. It returns the miner address where the data
// is being fetched from, and a byte reader to read the retrieved data.
func (m *Module) Retrieve(ctx context.Context, waddr string, payloadCid cid.Cid, pieceCid *cid.Cid, miners []string, CAREncoding bool) (string, io.ReadCloser, error) {
	rf, err := ioutil.TempDir(m.cfg.ImportPath, "retrieve-*")
	if err != nil {
		return "", nil, fmt.Errorf("creating temp dir for retrieval: %s", err)
	}
	ref := api.FileRef{
		Path:  filepath.Join(rf, "ret"),
		IsCAR: CAREncoding,
	}

	lapi, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return "", nil, fmt.Errorf("creating lotus client: %s", err)
	}
	miner, events, err := m.retrieve(ctx, lapi, cls, waddr, payloadCid, pieceCid, miners, &ref)
	if err != nil {
		return "", nil, fmt.Errorf("retrieving from lotus: %s", err)
	}
	for e := range events {
		if e.Err != "" {
			return "", nil, fmt.Errorf("in progress retrieval error: %s", e.Err)
		}
	}
	f, err := os.Open(ref.Path)
	if err != nil {
		return "", nil, fmt.Errorf("opening retrieved file: %s", err)
	}

	return miner, &autodeleteFile{File: f}, nil
}

func (m *Module) retrieve(ctx context.Context, lapi *api.FullNodeStruct, lapiCls func(), waddr string, payloadCid cid.Cid, pieceCid *cid.Cid, miners []string, ref *api.FileRef) (string, <-chan marketevents.RetrievalEvent, error) {
	addr, err := address.NewFromString(waddr)
	if err != nil {
		return "", nil, fmt.Errorf("parsing wallet address: %s", err)
	}

	sortedOffers := getRetrievalOffers(ctx, lapi, payloadCid, pieceCid, miners)
	if len(sortedOffers) == 0 {
		return "", nil, ErrRetrievalNoAvailableProviders
	}

	var events <-chan marketevents.RetrievalEvent

	// Try to make the retrieval in the specified offers order, until we
	// find one accepting providing the data.
	var o api.QueryOffer
	for _, o = range sortedOffers {
		events, err = lapi.ClientRetrieveWithEvents(ctx, o.Order(addr), ref)
		if err != nil {
			log.Infof("fetching/retrieving cid %s from %s: %s", payloadCid, o.Miner, err)
			continue
		}
		break
	}

	out := make(chan marketevents.RetrievalEvent, 1)
	go func() {
		defer lapiCls()
		defer close(out)
		m.metricRetrievalTracking.Add(ctx, 1)
		defer m.metricRetrievalTracking.Add(ctx, -1)

		// Redirect received events to the output channel
		var (
			canceled       bool
			errMsg         string
			dtStart, dtEnd time.Time
		)
		retrievalStartTime := time.Now()
		var bytesReceived uint64
	Loop:
		for {
			select {
			case <-ctx.Done():
				log.Infof("in progress retrieval canceled")
				canceled = true
				break Loop
			case e, ok := <-events:
				if !ok {
					break Loop
				}
				if e.Err != "" {
					log.Infof("in progress retrieval errored: %s", e.Err)
					errMsg = e.Err
				}
				if dtStart.IsZero() && e.Event == retrievalmarket.ClientEventBlocksReceived {
					dtStart = time.Now()
				}
				if e.Event == retrievalmarket.ClientEventAllBlocksReceived {
					dtEnd = time.Now()
				}
				bytesReceived = e.BytesReceived
				out <- e
			}
		}

		if !canceled {
			// This is a fallback if for some reason the
			// expected event that signals the first block
			// transfer is missed or not received.
			// We fallback to the starting time of the retrieval,
			// which means that will account for possibly the
			// payment channel creation. This isn't ideal, but
			// it's better than missing the data.
			// We WARN just to signal this might be happening.
			if dtStart.IsZero() && errMsg == "" {
				dtStart = retrievalStartTime
				log.Warnf("retrieval data-transfer start fallback to retrieval start")
			}
			// This is a fallback to not receiving an expected
			// event in the retrieval. We just fallback to Now(),
			// which should always be pretty close to the real
			// event. We WARN just to signal this is happening.
			if dtEnd.IsZero() && errMsg == "" {
				dtEnd = time.Now()
				log.Warnf("retrieval data-transfer end fallback to retrieval end")
			}
			m.recordRetrieval(waddr, o, bytesReceived, dtStart, dtEnd, errMsg)
		}
	}()

	return o.MinerPeer.Address.String(), out, nil
}

func getRetrievalOffers(ctx context.Context, lapi *api.FullNodeStruct, payloadCid cid.Cid, pieceCid *cid.Cid, miners []string) []api.QueryOffer {
	// Ask each miner about costs and information about retrieving this data.
	var offers []api.QueryOffer
	for _, mi := range miners {
		a, err := address.NewFromString(mi)
		if err != nil {
			log.Infof("parsing miner address: %s", err)
		}
		qo, err := lapi.ClientMinerQueryOffer(ctx, a, payloadCid, pieceCid)
		if err != nil {
			log.Infof("asking miner %s query-offer failed: %s", a, err)
			continue
		}
		offers = append(offers, qo)
	}

	// Sort received options by price.
	sort.Slice(offers, func(a, b int) bool { return offers[a].MinPrice.LessThan(offers[b].MinPrice) })

	return offers
}

'''
'''--- Filecoin/powergate/deals/module/store/metrics.go ---
package store

import (
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	attrTypeStorage   = attribute.Key("type").String("storage")
	attrTypeRetrieval = attribute.Key("type").String("retrieval")

	attrSuccess = attribute.Key("status").String("success")
	attrFailed  = attribute.Key("status").String("failed")
)

func (s *Store) initMetrics() {
	meter := global.Meter("powergate")

	s.metricFinalTotal = metric.Must(meter).NewInt64Counter("powergate.deals.record.final.total")
	s.metricVolumeBytes = metric.Must(meter).NewInt64Counter("powergate.deals.record.volume.bytes")
}

'''
'''--- Filecoin/powergate/deals/module/store/store.go ---
package store

import (
	"context"
	"crypto/md5"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/util"
	"go.opentelemetry.io/otel/metric"
)

var (
	dsBaseStoragePending = datastore.NewKey("storage-pending")
	dsBaseStorageFinal   = datastore.NewKey("storage-final")
	dsBaseRetrieval      = datastore.NewKey("retrieval")

	// TODO: we need a purging daemon to delete index entries older than X days.
	dsStorageUpdatedAtIdx   = datastore.NewKey("updatedatidx/storage")
	dsRetrievalUpdatedAtIdx = datastore.NewKey("updatedatidx/retrieval")

	// ErrNotFound indicates the instance doesn't exist.
	ErrNotFound = errors.New("cid info not found")

	log = logging.Logger("deals-records")
)

// Store stores deal and retrieval records.
type Store struct {
	ds   datastore.TxnDatastore
	lock sync.Mutex

	metricFinalTotal  metric.Int64Counter
	metricVolumeBytes metric.Int64Counter
}

// New returns a new *Store.
func New(ds datastore.TxnDatastore) *Store {
	s := &Store{
		ds: ds,
	}
	s.initMetrics()

	return s
}

// PutStorageDeal saves a storage deal record.
func (s *Store) PutStorageDeal(dr deals.StorageDealRecord) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	txn, err := s.ds.NewTransaction(false)
	if err != nil {
		return fmt.Errorf("creating transaction: %s", err)
	}
	defer txn.Discard()

	if dr.Pending && dr.ErrMsg != "" {
		return fmt.Errorf("pending storage records can't have error messages")
	}

	// If not pending, delete any saved record in the 'pending' keyspace.
	// If not exists, `Delete()` is a noop.
	if !dr.Pending {
		if err := txn.Delete(makePendingDealKey(dr.DealInfo.ProposalCid)); err != nil {
			return fmt.Errorf("delete pending deal storage record: %s", err)
		}
	}

	dr.UpdatedAt = time.Now().UnixNano()
	buf, err := json.Marshal(dr)
	if err != nil {
		return fmt.Errorf("marshaling storage deal record: %s", err)
	}

	var key datastore.Key
	if dr.Pending {
		key = makePendingDealKey(dr.DealInfo.ProposalCid)
	} else {
		ctx := context.Background()
		if dr.ErrMsg == "" {
			s.metricVolumeBytes.Add(ctx, int64(dr.DealInfo.Size), attrTypeStorage, attrSuccess)
			s.metricFinalTotal.Add(ctx, 1, attrTypeStorage, attrSuccess)
		} else {
			s.metricVolumeBytes.Add(ctx, int64(dr.DealInfo.Size), attrTypeStorage, attrFailed)
			s.metricFinalTotal.Add(ctx, 1, attrTypeStorage, attrFailed)
		}
		key = makeFinalDealKey(dr.DealInfo.ProposalCid)
	}

	if err := txn.Put(key, buf); err != nil {
		return fmt.Errorf("put storage deal record: %s", err)
	}

	updatedAtIndexKey := makeStorageUpdatedAtIndexKey(dr.UpdatedAt)
	if err := txn.Put(updatedAtIndexKey, key.Bytes()); err != nil {
		return fmt.Errorf("saving updated-at index: %s", err)
	}

	if err := txn.Commit(); err != nil {
		return fmt.Errorf("committing transaction: %s", err)
	}

	return nil
}

// GetPendingStorageDeals returns all the pending storage deal records.
func (s *Store) GetPendingStorageDeals() ([]deals.StorageDealRecord, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	q := query.Query{Prefix: dsBaseStoragePending.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()

	var ret []deals.StorageDealRecord
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var dr deals.StorageDealRecord
		if err := json.Unmarshal(r.Value, &dr); err != nil {
			return nil, fmt.Errorf("unmarshaling query result: %s", err)
		}
		ret = append(ret, dr)
	}
	return ret, nil
}

// GetFinalStorageDeals returns all final storage deal records.
func (s *Store) GetFinalStorageDeals() ([]deals.StorageDealRecord, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	q := query.Query{Prefix: dsBaseStorageFinal.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()

	var ret []deals.StorageDealRecord
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var dealRecord deals.StorageDealRecord
		if err := json.Unmarshal(r.Value, &dealRecord); err != nil {
			return nil, fmt.Errorf("unmarshaling query result: %s", err)
		}
		ret = append(ret, dealRecord)
	}

	return ret, nil
}

// PutRetrieval saves a retrieval deal record.
func (s *Store) PutRetrieval(rr deals.RetrievalDealRecord) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	txn, err := s.ds.NewTransaction(false)
	if err != nil {
		return fmt.Errorf("creating transaction: %s", err)
	}
	defer txn.Discard()

	rr.ID = retrievalID(rr)
	rr.UpdatedAt = time.Now().UnixNano()
	buf, err := json.Marshal(rr)
	if err != nil {
		return fmt.Errorf("marshaling RetrievalRecord: %s", err)
	}
	key := makeRetrievalKey(rr)
	if err := txn.Put(key, buf); err != nil {
		return fmt.Errorf("put RetrievalRecord: %s", err)
	}

	updatedAtIndexKey := makeRetrievalUpdatedAtIndexKey(rr.UpdatedAt)
	if err := txn.Put(updatedAtIndexKey, key.Bytes()); err != nil {
		return fmt.Errorf("saving updated-at index: %s", err)
	}

	if err := txn.Commit(); err != nil {
		return fmt.Errorf("committing transaction: %s", err)
	}

	ctx := context.Background()
	s.metricVolumeBytes.Add(ctx, int64(rr.BytesReceived), attrTypeStorage, attrFailed)
	s.metricFinalTotal.Add(ctx, 1, attrTypeRetrieval, attrSuccess)

	return nil
}

// GetRetrievals returns all retrieval deal records.
func (s *Store) GetRetrievals() ([]deals.RetrievalDealRecord, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	q := query.Query{Prefix: dsBaseRetrieval.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()

	var ret []deals.RetrievalDealRecord
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var rr deals.RetrievalDealRecord
		if err := json.Unmarshal(r.Value, &rr); err != nil {
			return nil, fmt.Errorf("unmarshaling query result: %s", err)
		}
		ret = append(ret, rr)
	}
	return ret, nil
}

// GetUpdatedStorageDealRecordsSince returns all the storage deal records that got created or updated
// since sinceNano.
func (s *Store) GetUpdatedStorageDealRecordsSince(since time.Time, limit int) ([]deals.StorageDealRecord, error) {
	q := query.Query{
		Prefix: dsStorageUpdatedAtIdx.String(),
	}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing updated storage deal records query result: %s", err)
		}
	}()

	sinceNano := since.UnixNano()
	msdrs := make(map[datastore.Key]deals.StorageDealRecord)
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("getting query result: %s", r.Error)
		}
		unixNanoKey := datastore.NewKey(r.Key).Namespaces()[2]
		unixNano, err := strconv.ParseInt(unixNanoKey, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("parsing unix nano key: %s", err)
		}

		if unixNano < sinceNano {
			continue
		}

		recordKey := datastore.RawKey(string(r.Value))
		buf, err := s.ds.Get(recordKey)
		if err == datastore.ErrNotFound && strings.HasPrefix(string(r.Value), dsBaseStoragePending.String()) {
			continue
		}
		if err != nil {
			return nil, fmt.Errorf("get updated storage deal record from store %s: %s", r.Value, err)
		}
		var sr deals.StorageDealRecord
		if err := json.Unmarshal(buf, &sr); err != nil {
			return nil, fmt.Errorf("unmarshaling updated storage deal record from store: %s", err)
		}
		msdrs[recordKey] = sr

		limit--
		if limit == 0 {
			break
		}
	}

	ret := make([]deals.StorageDealRecord, 0, len(msdrs))
	for _, v := range msdrs {
		ret = append(ret, v)
	}

	sort.Slice(ret, func(i, j int) bool {
		return ret[i].UpdatedAt < ret[j].UpdatedAt
	})

	return ret, nil
}

// GetUpdatedRetrievalRecordsSince returns all the retrieval records that got created or updated
// since sinceNano.
func (s *Store) GetUpdatedRetrievalRecordsSince(since time.Time, limit int) ([]deals.RetrievalDealRecord, error) {
	if limit < 0 {
		return nil, fmt.Errorf("limit is negative")
	}

	q := query.Query{
		Prefix: dsRetrievalUpdatedAtIdx.String(),
	}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing updated retrieval records query result: %s", err)
		}
	}()

	sinceNano := since.UnixNano()
	mrdrs := make(map[datastore.Key]deals.RetrievalDealRecord)
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("getting query result: %s", r.Error)
		}
		unixNanoKey := datastore.NewKey(r.Key).Namespaces()[2]
		unixNano, err := strconv.ParseInt(unixNanoKey, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("parsing unix nano key: %s", err)
		}

		if unixNano < sinceNano {
			continue
		}

		recordKey := datastore.RawKey(string(r.Value))
		buf, err := s.ds.Get(recordKey)
		if err != nil {
			return nil, fmt.Errorf("get updated retrieval deal record from store: %s", err)
		}
		var rr deals.RetrievalDealRecord
		if err := json.Unmarshal(buf, &rr); err != nil {
			return nil, fmt.Errorf("unmarshaling updated retrieval deal record from store: %s", err)
		}

		mrdrs[recordKey] = rr

		limit--
		if limit == 0 {
			break
		}
	}

	ret := make([]deals.RetrievalDealRecord, 0, len(mrdrs))
	for _, v := range mrdrs {
		ret = append(ret, v)
	}

	sort.Slice(ret, func(i, j int) bool {
		return ret[i].UpdatedAt < ret[j].UpdatedAt
	})

	return ret, nil
}

func retrievalID(rr deals.RetrievalDealRecord) string {
	str := fmt.Sprintf("%v%v%v%v", rr.Time, rr.Addr, rr.DealInfo.Miner, util.CidToString(rr.DealInfo.RootCid))
	sum := md5.Sum([]byte(str))

	return fmt.Sprintf("%x", sum[:])
}

func makePendingDealKey(c cid.Cid) datastore.Key {
	return dsBaseStoragePending.ChildString(util.CidToString(c))
}

func makeFinalDealKey(c cid.Cid) datastore.Key {
	return dsBaseStorageFinal.ChildString(util.CidToString(c))
}

func makeRetrievalKey(rr deals.RetrievalDealRecord) datastore.Key {
	return dsBaseRetrieval.ChildString(retrievalID(rr))
}

func makeStorageUpdatedAtIndexKey(unixNano int64) datastore.Key {
	return dsStorageUpdatedAtIdx.ChildString(strconv.FormatInt(unixNano, 10))
}

func makeRetrievalUpdatedAtIndexKey(unixNano int64) datastore.Key {
	return dsRetrievalUpdatedAtIdx.ChildString(strconv.FormatInt(unixNano, 10))
}

'''
'''--- Filecoin/powergate/deals/module/store/store_test.go ---
package store

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestPutPendingDeal(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "a", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c1}})
	require.NoError(t, err)

	c2, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2E")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "b", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c2}})
	require.NoError(t, err)

	c3, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2F")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "c", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c3}})
	require.NoError(t, err)
}

func TestGetPendingDeals(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	now := time.Now().Unix()

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "a", Time: now, Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c1}})
	require.NoError(t, err)

	c2, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2E")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "b", Time: now + 1, Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c2}})
	require.NoError(t, err)

	c3, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2F")
	require.NoError(t, err)
	err = s.PutStorageDeal(deals.StorageDealRecord{Addr: "c", Time: now + 3, Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c3}})
	require.NoError(t, err)

	res, err := s.GetPendingStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 3)
	for _, sd := range res {
		require.Greater(t, sd.UpdatedAt, int64(0))
	}
}

func TestErrorPendingDeal(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	dr := deals.StorageDealRecord{Addr: "a", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c1}}
	err = s.PutStorageDeal(dr)
	require.NoError(t, err)

	res, err := s.GetPendingStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 1)

	dr.Pending = false
	dr.ErrMsg = "ERROR TEST"
	err = s.PutStorageDeal(dr)
	require.NoError(t, err)

	res, err = s.GetPendingStorageDeals()
	require.NoError(t, err)
	require.Empty(t, res)

	res, err = s.GetFinalStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 1)
	require.False(t, res[0].Pending)
	require.Equal(t, "ERROR TEST", res[0].ErrMsg)
}

func TestPutDealRecord(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	pdr := deals.StorageDealRecord{Addr: "a", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c1}}
	err = s.PutStorageDeal(pdr)
	require.NoError(t, err)

	res, err := s.GetPendingStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 1)
	res, err = s.GetFinalStorageDeals()
	require.NoError(t, err)
	require.Empty(t, res)

	dr := deals.StorageDealRecord{Addr: "a", Time: time.Now().Unix(), Pending: false, DealInfo: deals.StorageDealInfo{ProposalCid: c1}}

	err = s.PutStorageDeal(dr)
	require.NoError(t, err)

	res, err = s.GetPendingStorageDeals()
	require.NoError(t, err)
	require.Empty(t, res)
	res, err = s.GetFinalStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 1)
}

func TestGetDealRecords(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	now := time.Now().Unix()

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	dr1 := deals.StorageDealRecord{Addr: "a", Time: now, Pending: false, DealInfo: deals.StorageDealInfo{ProposalCid: c1}}
	err = s.PutStorageDeal(dr1)
	require.NoError(t, err)

	c2, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2E")
	require.NoError(t, err)
	dr2 := deals.StorageDealRecord{Addr: "b", Time: now + 1, Pending: false, DealInfo: deals.StorageDealInfo{ProposalCid: c2}}
	err = s.PutStorageDeal(dr2)
	require.NoError(t, err)

	c3, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2F")
	require.NoError(t, err)
	dr3 := deals.StorageDealRecord{Addr: "c", Time: now + 2, Pending: false, DealInfo: deals.StorageDealInfo{ProposalCid: c3}}
	err = s.PutStorageDeal(dr3)
	require.NoError(t, err)

	res, err := s.GetFinalStorageDeals()
	require.NoError(t, err)
	require.Len(t, res, 3)
}

func TestPutRetrievalRecords(t *testing.T) {
	s := New(tests.NewTxMapDatastore())
	now := time.Now().Unix()
	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	rr := deals.RetrievalDealRecord{Time: now, Addr: "from", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr)
	require.NoError(t, err)
}

func TestGetRetrievalDeals(t *testing.T) {
	s := New(tests.NewTxMapDatastore())
	now := time.Now().Unix()

	c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	require.NoError(t, err)
	rr := deals.RetrievalDealRecord{Time: now, Addr: "from", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr)
	require.NoError(t, err)

	rr = deals.RetrievalDealRecord{Time: now + 1, Addr: "from", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr)
	require.NoError(t, err)

	rr = deals.RetrievalDealRecord{Time: now + 2, Addr: "from", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr)
	require.NoError(t, err)

	res, err := s.GetRetrievals()
	require.NoError(t, err)
	require.Len(t, res, 3)
	for _, rr := range res {
		require.NotEmpty(t, rr.ID)
	}
}

func TestUpdatedAt(t *testing.T) {
	t.Run("retrieval", func(t *testing.T) {
		s := New(tests.NewTxMapDatastore())

		c1, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
		require.NoError(t, err)
		rr := deals.RetrievalDealRecord{Time: time.Now().Unix(), Addr: "from", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
		err = s.PutRetrieval(rr)
		require.NoError(t, err)

		res, err := s.GetRetrievals()
		require.NoError(t, err)
		updatedAt1 := res[0].UpdatedAt

		// Save again, which should update UpdatedAt
		err = s.PutRetrieval(rr)
		require.NoError(t, err)

		res, err = s.GetRetrievals()
		require.NoError(t, err)
		updatedAt2 := res[0].UpdatedAt

		require.Greater(t, updatedAt2, updatedAt1)
	})

	t.Run("storage-deal", func(t *testing.T) {
		s := New(tests.NewTxMapDatastore())

		c, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2F")
		require.NoError(t, err)
		dr := deals.StorageDealRecord{Addr: "c", Time: time.Now().Unix(), Pending: false, DealInfo: deals.StorageDealInfo{ProposalCid: c}}
		err = s.PutStorageDeal(dr)
		require.NoError(t, err)

		res, err := s.GetFinalStorageDeals()
		require.NoError(t, err)
		updatedAt1 := res[0].UpdatedAt

		// Save again, which should update UpdatedAt
		err = s.PutStorageDeal(dr)
		require.NoError(t, err)

		res, err = s.GetFinalStorageDeals()
		require.NoError(t, err)
		updatedAt2 := res[0].UpdatedAt

		require.Greater(t, updatedAt2, updatedAt1)
	})
}

func TestStorageUpdatedSince(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	// Inception.
	t0 := time.Now()

	c1, _ := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	sr1 := deals.StorageDealRecord{Addr: "a", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c1}}
	err := s.PutStorageDeal(sr1)
	require.NoError(t, err)

	// Checkpoint 1
	t1 := time.Now()

	c2, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2E")
	require.NoError(t, err)
	sr2 := deals.StorageDealRecord{Addr: "b", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c2}}
	err = s.PutStorageDeal(sr2)
	require.NoError(t, err)

	c3, err := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2F")
	require.NoError(t, err)
	sr3 := deals.StorageDealRecord{Addr: "c", Time: time.Now().Unix(), Pending: true, DealInfo: deals.StorageDealInfo{ProposalCid: c3}}
	err = s.PutStorageDeal(sr3)
	require.NoError(t, err)

	// Checkpoint 2
	t2 := time.Now()

	sr2Updated := sr2
	sr2Updated.Addr = "c2"
	err = s.PutStorageDeal(sr2Updated)
	require.NoError(t, err)

	// Checkpoint 3
	t3 := time.Now()

	// ## Start verifying changes.

	// Since t0, we should get 3 results, even if there were 4 changes (since sr2 as touched two times; we get the latest state).
	udr, err := s.GetUpdatedStorageDealRecordsSince(t0, 10)
	require.NoError(t, err)
	require.Len(t, udr, 3)
	require.Equal(t, sr1.Addr, udr[0].Addr)
	require.Equal(t, sr3.Addr, udr[1].Addr)
	require.Equal(t, sr2Updated.Addr, udr[2].Addr)

	// Since t1, we should get 2 results: sr3 and sr2Updated
	udr, err = s.GetUpdatedStorageDealRecordsSince(t1, 10)
	require.NoError(t, err)
	require.Len(t, udr, 2)
	require.Equal(t, sr3.Addr, udr[0].Addr)
	require.Equal(t, sr2Updated.Addr, udr[1].Addr)

	// Since t2, we should get 1 result: sr2Updated
	udr, err = s.GetUpdatedStorageDealRecordsSince(t2, 10)
	require.NoError(t, err)
	require.Len(t, udr, 1)
	require.Equal(t, sr2Updated.Addr, udr[0].Addr)

	// Since t3, we should get 0 results
	udr, err = s.GetUpdatedStorageDealRecordsSince(t3, 10)
	require.NoError(t, err)
	require.Len(t, udr, 0)

	// Test limit
	udr, err = s.GetUpdatedStorageDealRecordsSince(t0, 1)
	require.NoError(t, err)
	require.Len(t, udr, 1)
}

func TestRetrievalUpdatedSince(t *testing.T) {
	s := New(tests.NewTxMapDatastore())

	// Inception.
	t0 := time.Now()

	c1, _ := util.CidFromString("QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D")
	rr1 := deals.RetrievalDealRecord{Time: time.Now().UnixNano(), Addr: "c1", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err := s.PutRetrieval(rr1)
	require.NoError(t, err)

	// Checkpoint 1
	t1 := time.Now()

	rr2 := deals.RetrievalDealRecord{Time: time.Now().UnixNano(), Addr: "c2", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr2)
	require.NoError(t, err)

	rr3 := deals.RetrievalDealRecord{Time: time.Now().UnixNano(), Addr: "c3", DealInfo: deals.RetrievalDealInfo{RootCid: c1, Miner: "miner"}}
	err = s.PutRetrieval(rr3)
	require.NoError(t, err)

	// Checkpoint 2
	t2 := time.Now()

	rr2Updated := rr2
	rr2Updated.Addr = "c2"
	err = s.PutRetrieval(rr2Updated)
	require.NoError(t, err)

	// Checkpoint 3
	t3 := time.Now()

	// ## Start verifying changes.

	// Since t0, we should get 3 results, even if there were 4 changes (since rr2 as touched two times; we get the latest state).
	udr, err := s.GetUpdatedRetrievalRecordsSince(t0, 10)
	require.NoError(t, err)
	require.Len(t, udr, 3)
	require.Equal(t, rr1.Addr, udr[0].Addr)
	require.Equal(t, rr3.Addr, udr[1].Addr)
	require.Equal(t, rr2Updated.Addr, udr[2].Addr)

	// Since t1, we should get 2 results: sr3 and rr2Updated
	udr, err = s.GetUpdatedRetrievalRecordsSince(t1, 10)
	require.NoError(t, err)
	require.Len(t, udr, 2)
	require.Equal(t, rr3.Addr, udr[0].Addr)
	require.Equal(t, rr2Updated.Addr, udr[1].Addr)

	// Since t2, we should get 1 result: rr2Updated
	udr, err = s.GetUpdatedRetrievalRecordsSince(t2, 10)
	require.NoError(t, err)
	require.Len(t, udr, 1)
	require.Equal(t, rr2Updated.Addr, udr[0].Addr)

	// Since t3, we should get 0 results
	udr, err = s.GetUpdatedRetrievalRecordsSince(t3, 10)
	require.NoError(t, err)
	require.Len(t, udr, 0)

	// Test limit
	udr, err = s.GetUpdatedRetrievalRecordsSince(t0, 1)
	require.NoError(t, err)
	require.Len(t, udr, 1)
}

'''
'''--- Filecoin/powergate/deals/module/util.go ---
package module

import (
	"fmt"
	"os"
)

type autodeleteFile struct {
	*os.File
}

func (af *autodeleteFile) Close() error {
	if err := af.File.Close(); err != nil {
		return fmt.Errorf("closing retrieval file: %s", err)
	}
	if err := os.Remove(af.File.Name()); err != nil {
		return fmt.Errorf("autodeleting retrieval file: %s", err)
	}
	return nil
}

'''
'''--- Filecoin/powergate/deals/options.go ---
package deals

import "os"

// Config contains configuration for storing deals.
type Config struct {
	ImportPath string
}

// Option sets values on a Config.
type Option func(*Config) error

// WithImportPath indicates the import path that will be used
// to store data to later be imported to Lotus.
func WithImportPath(path string) Option {
	return func(c *Config) error {
		if err := os.MkdirAll(path, 0700); err != nil {
			return err
		}
		c.ImportPath = path
		return nil
	}
}

// DealRecordsConfig specifies the options for DealsManager.List.
type DealRecordsConfig struct {
	FromAddrs      []string
	DataCids       []string
	IncludePending bool
	IncludeFinal   bool
	IncludeFailed  bool
	Ascending      bool
}

// DealRecordsOption updates a ListDealRecordsConfig.
type DealRecordsOption func(*DealRecordsConfig)

// WithFromAddrs limits the results deals initiated from the provided wallet addresses.
// If WithDataCids is also provided, this is an AND operation.
func WithFromAddrs(addrs ...string) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.FromAddrs = addrs
	}
}

// WithIncludeFailed indicates if failed records should be
// included in the results.
func WithIncludeFailed(includeFailed bool) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.IncludeFailed = includeFailed
	}
}

// WithDataCids limits the results to deals for the provided data cids.
// If WithFromAddrs is also provided, this is an AND operation.
func WithDataCids(cids ...string) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.DataCids = cids
	}
}

// WithIncludePending specifies whether or not to include pending deals in the results. Default is false.
// Ignored for ListRetrievalDealRecords.
func WithIncludePending(includePending bool) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.IncludePending = includePending
	}
}

// WithIncludeFinal specifies whether or not to include final deals in the results. Default is false.
// Ignored for ListRetrievalDealRecords.
func WithIncludeFinal(includeFinal bool) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.IncludeFinal = includeFinal
	}
}

// WithAscending specifies to sort the results in ascending order. Default is descending order.
// Records are sorted by timestamp.
func WithAscending(ascending bool) DealRecordsOption {
	return func(c *DealRecordsConfig) {
		c.Ascending = ascending
	}
}

'''
'''--- Filecoin/powergate/deals/types.go ---
package deals

import (
	"github.com/ipfs/go-cid"
)

// StorageDealConfig contains information about a storage proposal for a miner.
type StorageDealConfig struct {
	Miner           string
	EpochPrice      uint64
	FastRetrieval   bool
	DealStartOffset int64
	VerifiedDeal    bool
}

// StoreResult contains information about Executing deals.
type StoreResult struct {
	ProposalCid cid.Cid
	Config      StorageDealConfig
	Success     bool
	Message     string
}

// StorageDealInfo contains information about a proposed storage deal.
type StorageDealInfo struct {
	ProposalCid cid.Cid
	StateID     uint64
	StateName   string
	Miner       string

	PieceCID cid.Cid
	Size     uint64

	PricePerEpoch uint64
	StartEpoch    uint64
	Duration      uint64

	DealID          uint64
	ActivationEpoch int64
	Message         string
}

// StorageDealRecord represents a storage deal log record.
type StorageDealRecord struct {
	RootCid           cid.Cid
	Addr              string
	DealInfo          StorageDealInfo
	Time              int64
	Pending           bool
	TransferSize      int64
	DataTransferStart int64
	DataTransferEnd   int64
	SealingStart      int64
	SealingEnd        int64
	ErrMsg            string
	UpdatedAt         int64
}

// RetrievalDealInfo contains information about a retrieval deal.
type RetrievalDealInfo struct {
	RootCid                 cid.Cid
	Size                    uint64
	MinPrice                uint64
	PaymentInterval         uint64
	PaymentIntervalIncrease uint64
	Miner                   string
	MinerPeerID             string
}

// RetrievalDealRecord represents a retrieval deal log record.
type RetrievalDealRecord struct {
	ID                string
	Addr              string
	DealInfo          RetrievalDealInfo
	Time              int64
	DataTransferStart int64
	DataTransferEnd   int64
	BytesReceived     uint64
	ErrMsg            string
	UpdatedAt         int64
}

'''
'''--- Filecoin/powergate/docker/dashboards/System_Monitoring.json ---
{
  "id": 3,
  "title": "System Monitoring",
  "tags": [
    "alerts"
  ],
  "style": "dark",
  "timezone": "browser",
  "editable": true,
  "hideControls": true,
  "sharedCrosshair": false,
  "rows": [
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "cacheTimeout": null,
          "colorBackground": true,
          "colorValue": false,
          "colors": [
            "rgba(50, 172, 45, 0.97)",
            "rgba(237, 129, 40, 0.89)",
            "rgba(245, 54, 54, 0.9)"
          ],
          "datasource": null,
          "decimals": null,
          "editable": true,
          "error": false,
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "id": 7,
          "interval": null,
          "isNew": true,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "span": 6,
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "targets": [
            {
              "expr": "ALERTS{alertname=\"high_load\",alertstate=\"firing\"}",
              "interval": "",
              "intervalFactor": 1,
              "legendFormat": "",
              "metric": "ALERTS",
              "refId": "A",
              "step": 120
            }
          ],
          "thresholds": "0.6,0.9",
          "title": "Load Status",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "HIGH",
              "value": "1"
            },
            {
              "op": "=",
              "text": "OK",
              "value": "0"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": true,
          "colorValue": false,
          "colors": [
            "rgba(50, 172, 45, 0.97)",
            "rgba(237, 129, 40, 0.89)",
            "rgba(245, 54, 54, 0.9)"
          ],
          "datasource": null,
          "decimals": null,
          "editable": true,
          "error": false,
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "id": 9,
          "interval": null,
          "isNew": true,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "span": 6,
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "targets": [
            {
              "expr": "ALERTS{alertname=\"service_down\",alertstate=\"firing\"}",
              "interval": "",
              "intervalFactor": 1,
              "legendFormat": "",
              "metric": "ALERTS",
              "refId": "A",
              "step": 120
            }
          ],
          "thresholds": "0.6,0.9",
          "title": "Service Down",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "Offline",
              "value": "1"
            },
            {
              "op": "=",
              "text": "OK",
              "value": "0"
            }
          ],
          "valueName": "current"
        }
      ],
      "title": "Row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "aliasColors": {},
          "bars": false,
          "datasource": null,
          "editable": true,
          "error": false,
          "fill": 0,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 2,
          "isNew": true,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "rightSide": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 6,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "node_memory_MemFree",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "metric": "node_memory_MemFree",
              "refId": "A",
              "step": 30
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Free RAM",
          "tooltip": {
            "msResolution": false,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "bytes",
              "label": "",
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        },
        {
          "aliasColors": {},
          "bars": false,
          "datasource": null,
          "editable": true,
          "error": false,
          "fill": 0,
          "grid": {
            "threshold1": 500000000,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": 250000000,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 3,
          "isNew": true,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "rightSide": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 6,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "node_memory_SwapFree",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "refId": "A",
              "step": 30
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Free Swap",
          "tooltip": {
            "msResolution": true,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "bytes",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": 0,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "aliasColors": {},
          "bars": false,
          "datasource": null,
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 6,
          "isNew": true,
          "legend": {
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 12,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "process_virtual_memory_bytes",
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "metric": "process_virtual_memory_bytes",
              "refId": "A",
              "step": 20
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Virtual Mem Size",
          "tooltip": {
            "msResolution": false,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "bytes",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "aliasColors": {},
          "bars": false,
          "datasource": null,
          "decimals": null,
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": 1,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": 2,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 5,
          "isNew": true,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "rightSide": false,
            "show": true,
            "sideWidth": null,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 8,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "node_load1",
              "interval": "",
              "intervalFactor": 1,
              "legendFormat": "{{job}}",
              "metric": "node_load1",
              "refId": "A",
              "step": 15
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "CPU Load",
          "tooltip": {
            "msResolution": false,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        },
        {
          "aliasColors": {},
          "bars": false,
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "fill": 0,
          "grid": {
            "threshold1": 20,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": 10,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 4,
          "isNew": true,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "rightSide": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 4,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "(node_memory_MemFree + node_memory_SwapFree)/(node_memory_MemTotal + node_memory_SwapTotal)*100",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "refId": "A",
              "step": 60
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Free Memory (RAM + Swap)",
          "tooltip": {
            "msResolution": true,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "percent",
              "label": "",
              "logBase": 1,
              "max": 100,
              "min": 0,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": 229,
      "panels": [
        {
          "aliasColors": {},
          "bars": false,
          "datasource": "Prometheus",
          "decimals": null,
          "editable": true,
          "error": false,
          "fill": 0,
          "grid": {
            "threshold1": 2500000000,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": 1000000000,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 1,
          "isNew": true,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "rightSide": false,
            "show": true,
            "sideWidth": null,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 4,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "node_filesystem_avail{mountpoint=\"/\"}",
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "metric": "",
              "refId": "A",
              "step": 60
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Free Storage",
          "tooltip": {
            "msResolution": false,
            "shared": true,
            "sort": 0,
            "value_type": "cumulative"
          },
          "type": "graph",
          "xaxis": {
            "show": true
          },
          "yaxes": [
            {
              "format": "bytes",
              "label": "",
              "logBase": 1,
              "max": null,
              "min": 0,
              "show": true
            },
            {
              "format": "short",
              "label": "",
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ]
        }
      ],
      "title": "New row"
    }
  ],
  "time": {
    "from": "now-3h",
    "to": "now"
  },
  "timepicker": {
    "refresh_intervals": [
      "5s",
      "10s",
      "30s",
      "1m",
      "5m",
      "15m",
      "30m",
      "1h",
      "2h",
      "1d"
    ],
    "time_options": [
      "5m",
      "15m",
      "1h",
      "6h",
      "12h",
      "24h",
      "2d",
      "7d",
      "30d"
    ]
  },
  "templating": {
    "list": []
  },
  "annotations": {
    "list": []
  },
  "refresh": "10s",
  "schemaVersion": 12,
  "version": 5,
  "links": [],
  "gnetId": null
}

'''
'''--- Filecoin/powergate/docker/grafana/provisioning/dashboards/TextileFC.json ---
 {
  "annotations": {
    "list": [
      {
        "$$hashKey": "object:34",
        "builtIn": 1,
        "datasource": "-- Grafana --",
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "gnetId": null,
  "graphTooltip": 0,
  "links": [],
  "panels": [
    {
      "collapsed": false,
      "datasource": null,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 18,
      "panels": [],
      "title": "General",
      "type": "row"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "description": "",
      "format": "none",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 0,
        "y": 1
      },
      "id": 2,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "name": "value to text",
          "value": 1
        },
        {
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": true,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": null
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_lotus_height_count",
          "format": "time_series",
          "instant": false,
          "interval": "",
          "intervalFactor": 1,
          "legendFormat": " Height",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Lotus Height",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "percentunit",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 4,
        "y": 1
      },
      "id": 4,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:226",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:227",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "sum(rate(container_cpu_usage_seconds_total{name=\"docker_powergate_1\"}[1m]))",
          "instant": false,
          "interval": "10s",
          "legendFormat": "docker_powergate",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "CPU usage",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:229",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "bytes",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 9,
        "y": 1
      },
      "id": 6,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:635",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:636",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "container_memory_rss{name=\"docker_powergate_1\"}",
          "interval": "10s",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Mem RSS",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:638",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "none",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 14,
        "y": 1
      },
      "id": 41,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:387",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:388",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_process_cpu_goroutines{instance=\"powergate:8888\"}",
          "interval": "",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Go routines",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:390",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "decimals": null,
      "description": "",
      "format": "bytes",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 0,
        "y": 5
      },
      "id": 10,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:1004",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:1005",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "sum(rate(container_network_transmit_bytes_total{name=\"docker_powergate_1\"}[1m] ) )",
          "legendFormat": "docker_powergate",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Network Output",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:1007",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "bytes",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 4,
        "y": 5
      },
      "id": 8,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:718",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:719",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "sum(rate(container_network_receive_bytes_total{name=\"docker_powergate_1\"}[1m]))",
          "interval": "",
          "legendFormat": "docker_powergate",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Network Input",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:721",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "bytes",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 9,
        "y": 5
      },
      "id": 39,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:166",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:167",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "pluginVersion": "6.7.2",
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_process_heap_alloc{instance=\"powergate:8888\"}",
          "interval": "",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Heap Alloc",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:169",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "collapsed": false,
      "datasource": null,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 9
      },
      "id": 20,
      "panels": [],
      "title": "Miner index",
      "type": "row"
    },
    {
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 0,
        "y": 10
      },
      "id": 35,
      "options": {
        "fieldOptions": {
          "calcs": [
            "last"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [],
            "max": 1,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "yellow",
                  "value": null
                },
                {
                  "color": "green",
                  "value": 1
                }
              ]
            },
            "title": "",
            "unit": "percentunit"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "auto",
        "showThresholdLabels": false,
        "showThresholdMarkers": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_indexminer_onchain_refresh_progress",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "On-Chain Refresh",
      "type": "gauge"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "none",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 4,
        "y": 10
      },
      "id": 16,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "name": "value to text",
          "value": 1
        },
        {
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": true,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": null
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_index_miner_updated_height",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Index Height",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "current"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "decimals": 2,
      "format": "ms",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 8,
        "y": 10
      },
      "id": 14,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:838",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:839",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "pluginVersion": "6.4.4",
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_indexminer_refresh_duration{refreshtype=\"full\"}",
          "instant": false,
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Full-Refresh Duration",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:841",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "avg"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "ms",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 12,
        "y": 10
      },
      "id": 22,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:875",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:876",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_indexminer_refresh_duration{refreshtype=\"delta\"}",
          "legendFormat": "delta-refresh-time",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Delta-Refresh Duration",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:878",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "avg"
    },
    {
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 16,
        "y": 10
      },
      "id": 36,
      "options": {
        "fieldOptions": {
          "calcs": [
            "last"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [],
            "max": 1,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "yellow",
                  "value": null
                },
                {
                  "color": "green",
                  "value": 1
                }
              ]
            },
            "title": "",
            "unit": "percentunit"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "auto",
        "showThresholdLabels": false,
        "showThresholdMarkers": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_indexminer_meta_refresh_progress",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Meta Refresh",
      "type": "gauge"
    },
    {
      "cacheTimeout": null,
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 20,
        "y": 10
      },
      "id": 12,
      "links": [],
      "options": {
        "displayMode": "basic",
        "fieldOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [
              {
                "id": 0,
                "op": "=",
                "text": "N/A",
                "type": 1,
                "value": "null"
              }
            ],
            "max": 100,
            "min": 0,
            "nullValueMode": "connected",
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "rgb(255, 255, 255)",
                  "value": null
                }
              ]
            },
            "unit": "none"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "vertical",
        "showUnfilled": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_indexminer_meta_ping_count",
          "legendFormat": "{{ online }}",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "#Miners Ping Reply",
      "type": "bargauge"
    },
    {
      "collapsed": false,
      "datasource": null,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 14
      },
      "id": 24,
      "panels": [],
      "title": "Ask Index",
      "type": "row"
    },
    {
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 0,
        "y": 15
      },
      "id": 26,
      "options": {
        "fieldOptions": {
          "calcs": [
            "last"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [],
            "max": 1,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "yellow",
                  "value": null
                },
                {
                  "color": "green",
                  "value": 1
                }
              ]
            },
            "title": "",
            "unit": "percentunit"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "auto",
        "showThresholdLabels": false,
        "showThresholdMarkers": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_askindex_fullrefresh_progress",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Full Refresh",
      "type": "gauge"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "ms",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 4,
        "y": 15
      },
      "id": 30,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "$$hashKey": "object:778",
          "name": "value to text",
          "value": 1
        },
        {
          "$$hashKey": "object:779",
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": false,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": 0
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_askindex_fullrefresh_duration",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Refresh Duration",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "$$hashKey": "object:781",
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "avg"
    },
    {
      "cacheTimeout": null,
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 8,
        "y": 15
      },
      "id": 28,
      "links": [],
      "options": {
        "displayMode": "basic",
        "fieldOptions": {
          "calcs": [
            "last"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [],
            "max": 100,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "rgb(255, 255, 255)",
                  "value": null
                }
              ]
            },
            "title": ""
          },
          "overrides": [],
          "values": false
        },
        "orientation": "vertical",
        "showUnfilled": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_askindex_queryask_result",
          "legendFormat": "{{ askstatus }}",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Last Query-Ask Reply",
      "type": "bargauge"
    },
    {
      "collapsed": false,
      "datasource": null,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 19
      },
      "id": 32,
      "panels": [],
      "title": "Faults Index",
      "type": "row"
    },
    {
      "cacheTimeout": null,
      "datasource": null,
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 0,
        "y": 20
      },
      "id": 34,
      "links": [],
      "options": {
        "fieldOptions": {
          "calcs": [
            "last"
          ],
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "mappings": [
              {
                "id": 0,
                "op": "=",
                "text": "N/A",
                "type": 1,
                "value": "null"
              }
            ],
            "max": 1,
            "min": 0,
            "nullValueMode": "connected",
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "yellow",
                  "value": null
                },
                {
                  "color": "green",
                  "value": 1
                }
              ]
            },
            "unit": "percentunit"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "horizontal",
        "showThresholdLabels": false,
        "showThresholdMarkers": true
      },
      "pluginVersion": "6.7.2",
      "targets": [
        {
          "expr": "textilefc_indexslashing_refresh_progress",
          "refId": "A"
        }
      ],
      "timeFrom": null,
      "timeShift": null,
      "title": "Refresh",
      "type": "gauge"
    },
    {
      "cacheTimeout": null,
      "colorBackground": false,
      "colorValue": false,
      "colors": [
        "#299c46",
        "rgba(237, 129, 40, 0.89)",
        "#d44a3a"
      ],
      "datasource": null,
      "format": "none",
      "gauge": {
        "maxValue": 100,
        "minValue": 0,
        "show": false,
        "thresholdLabels": false,
        "thresholdMarkers": true
      },
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 4,
        "y": 20
      },
      "id": 37,
      "interval": null,
      "links": [],
      "mappingType": 1,
      "mappingTypes": [
        {
          "name": "value to text",
          "value": 1
        },
        {
          "name": "range to text",
          "value": 2
        }
      ],
      "maxDataPoints": 100,
      "nullPointMode": "connected",
      "nullText": null,
      "pluginVersion": "6.5.3",
      "postfix": "",
      "postfixFontSize": "50%",
      "prefix": "",
      "prefixFontSize": "50%",
      "rangeMaps": [
        {
          "from": "null",
          "text": "N/A",
          "to": "null"
        }
      ],
      "sparkline": {
        "fillColor": "rgba(31, 118, 189, 0.18)",
        "full": true,
        "lineColor": "rgb(31, 120, 193)",
        "show": true,
        "ymax": null,
        "ymin": null
      },
      "tableColumn": "",
      "targets": [
        {
          "expr": "textilefc_indexslashing_updated_height",
          "refId": "A"
        }
      ],
      "thresholds": "",
      "timeFrom": null,
      "timeShift": null,
      "title": "Index Height",
      "type": "singlestat",
      "valueFontSize": "80%",
      "valueMaps": [
        {
          "op": "=",
          "text": "N/A",
          "value": "null"
        }
      ],
      "valueName": "avg"
    }
  ],
  "refresh": "5s",
  "schemaVersion": 22,
  "style": "dark",
  "tags": [],
  "templating": {
    "list": []
  },
  "time": {
    "from": "now-1h",
    "to": "now"
  },
  "timepicker": {
    "refresh_intervals": [
      "5s",
      "10s",
      "30s",
      "1m",
      "5m",
      "15m",
      "30m",
      "1h",
      "2h",
      "1d"
    ]
  },
  "timezone": "",
  "title": "Textile Filecoin",
  "uid": "p4TiQMYWk",
  "variables": {
    "list": []
  },
  "version": 1
}

'''
'''--- Filecoin/powergate/docker/grafana/provisioning/dashboards/dashboard.yml ---
apiVersion: 1

providers:
- name: 'Prometheus'
  orgId: 1
  folder: ''
  type: file
  disableDeletion: false
  editable: false
  options:
    path: /etc/grafana/provisioning/dashboards

'''
'''--- Filecoin/powergate/docker/grafana/provisioning/datasources/datasource.yml ---
# config file version
apiVersion: 1

# list of datasources that should be deleted from the database
deleteDatasources:
  - name: Prometheus
    orgId: 1

# list of datasources to insert/update depending
# whats available in the database
datasources:
  # <string, required> name of the datasource. Required
- name: Prometheus
  # <string, required> datasource type. Required
  type: prometheus
  # <string, required> access mode. direct or proxy. Required
  access: proxy
  # <int> org id. will default to orgId 1 if not specified
  orgId: 1
  # <string> url
  url: http://prometheus:9090
  # <string> database password, if used
  password:
  # <string> database user, if used
  user:
  # <string> database name, if used
  database:
  # <bool> enable/disable basic auth
  basicAuth: false
  # <string> basic auth username, if used
  basicAuthUser:
  # <string> basic auth password, if used
  basicAuthPassword:
  # <bool> enable/disable with credentials headers
  withCredentials:
  # <bool> mark as default datasource. Max one per org
  isDefault: true
  # <map> fields that will be converted to json and stored in json_data
  jsonData:
     graphiteVersion: "1.1"
     tlsAuth: false
     tlsAuthWithCACert: false
  # <string> json object of data that will be encrypted.
  secureJsonData:
    tlsCACert: "..."
    tlsClientCert: "..."
    tlsClientKey: "..."
  version: 1
  # <bool> allow users to edit datasources from the UI.
  editable: true

'''
'''--- Filecoin/powergate/docker/prometheus/prometheus.yml ---
global:
  scrape_interval:     15s
  evaluation_interval: 15s
  scrape_timeout:      10s

  external_labels:
      monitor: 'textile-fc'

scrape_configs:
  - job_name: 'prometheus'
    scrape_interval: 5s
    static_configs:
         - targets: ['prometheus:9090']

  - job_name: 'cadvisor'
    scrape_interval: 5s
    static_configs:
          - targets: ['cadvisor:8082']

  - job_name: 'textile-fc'
    scrape_interval: 5s
    static_configs:
          - targets: ['powergate:8888']

'''
'''--- Filecoin/powergate/docs/manual_installation.md ---
# Powergate manual installation

This document describes the necessary steps for a manual installation setup. We highly recommend the dockerized installation version, which is in _.yaml_ files in the `docker` folder of the repo. Additionally, in that folder, we provide a _Makefile_ with one-command configuration to connect to different networks.

## Big picture

The following high-level design provides an excellent bird-eye picture of the different necessary components to run Powergate:
![Powergate Design](https://user-images.githubusercontent.com/6136245/86490337-6dbd5200-bd3d-11ea-9895-3689dd1c8a8f.png)

The relevant processes to understand from the picture above are:
- `powd`: The Powergate server daemon.
- `Lotus`: A Filecoin client.
- `go-ipfs`: An IPFS client.

The `powd` binary runs the Powergate daemon process, which provides all functionality of Powergate. To fully provide all its features, it requires two extra dependencies: `Lotus` and `go-ipfs`.

Below we'll provide the most natural order of installation of components.

## Install `go-ipfs`

To install [go-ipfs](https://github.com/ipfs/go-ipfs) please refer to its [installation instructions](https://github.com/ipfs/go-ipfs#install). Currently, Powergate targets version v0.6.1, so please have that consideration when selecting a version to install.

Powergate interacts with the IPFS daemon via its HTTP API, so there isn't a hard constraint on where the daemon should run. Depending on how decoupled you might want to do the setup, the daemon can live in the same or different host as `powd`.

The amount of resources that `go-ipfs` require will depend on the amount of load in the FFS-subsystem of Powergate, but take as a minimum the recommended [official system requirements](https://github.com/ipfs/go-ipfs#system-requirements). Recall those requirements are only for the `go-ipfs` daemon, so if you're installing other components in the same host, those are a hard-minimum.

Apart from CPU/Memory resources consideration, `go-ipfs` is the underlying system behind the _Hot Storage_ abstraction in the FFS module. That's to say, it's a datastore which should be fast to store and retrieve data. As a consequence, the amount of available storage for `go-ipfs` should be enough for your worst-case scenario estimation of _all_ the data stored in _Hot Storage_ for all FFS instances. Remember that storing data in `go-ipfs` has a slight overhead considering that the IPFS node does some data transformation. Despite that same transformation providing deduplication functionality that might compensate the overhead, it's recommended to plan for the worst use-case scenario with an extra threshold.

A priori, FFS instances can rely on the _Hot Storage_, thus the IPFS node, to go search for a particular piece of data in the public IPFS network which means that the IPFS daemon should have internet connection, and enough bandwidth to satisfy your use case.

We're currently not targeting any particular `go-ipfs` extra configuration such as custom networking configurations, or specific _profiles_. This might change in the future when we have more experience with better setups for `go-ipfs` in production and high load environments. Additionally, we'll soon explore more reliable and scalable setups for the _Hot Storage_ such as IPFS cluster, so stay tuned for more information.

## Install a Filecoin client (`lotus`)

Powergate interacts with the Filecoin network using two mechanisms:
1. It runs a libp2p client that connects to the Filecoin network, and it's DHT. This client is only used by the indices to interact directly with miners to resolve geolocation information, liveness, and other features.
2. It interacts with the Filecoin blockchain using a client. Currently, only `lotus` is supported since is the only fully-featured and most stable Filecoin client.

To install `lotus` there are two different flavors:
- Raw binary run: To run `lotus` daemon-less, please refer to the [official documentation](https://docs.lotu.sh/en+install-lotus-ubuntu) which provides all steps necessary depending on the OS of the host. 
- Run with _systemd_: You can run Lotus as a service with systemd, if that's the case refer to [this](https://docs.lotu.sh/en+install-systemd-services) link.

One important fact about `lotus` for Powergate, is that it only needs to be run in _client mode_. The `lotus` node *wont't* be a miner, thus it doesn't need a _Lotus storage miner_, workers, or similar components.

The official system requirements for running Lotus can be found [here](https://docs.lotu.sh/en+faqs#what-operating-systems-can-lotus-run-on-115423).

### Lotus configuration

Apart from installing a pristine Lotus daemon, some further configuration should be provided to work correctly with Powergate. 

By default, the `lotus` daemon creates a folder in `~/.lotus` containing all the daemon state. For configuring Lotus, there are two options:
- Editing `~/.lotus/config.toml` which contains the configuration parameters in TOML format.
- Using environment variables with the `LOTUS_` prefix, which takes precedence over the file configuration.

The default Lotus configuration is similar to the following snippet:
```
# Default config:
[API]
#  ListenAddress = "/ip4/127.0.0.1/tcp/1234/http"
#  RemoteListenAddress = ""
#  Timeout = "30s"
#
[Libp2p]
#  ListenAddresses = ["/ip4/0.0.0.0/tcp/0", "/ip6/::/tcp/0"]
#  AnnounceAddresses = []
#  NoAnnounceAddresses = []
#  ConnMgrLow = 150
#  ConnMgrHigh = 180
#  ConnMgrGrace = "20s"
#
[Pubsub]
#  Bootstrapper = false
#  RemoteTracer = "/ip4/147.75.67.199/tcp/4001/p2p/QmTd6UvR47vUidRNZ1ZKXHrAFhqTJAD27rKL9XYghEKgKX"
#
[Client]
#  UseIpfs = false
#  IpfsMAddr = ""
#  IpfsUseForRetrieval = false
#
[Metrics]
#  Nickname = ""
#  HeadNotifs = false
```

The first necessary configuration is allowing Powergate to access the [Lotus JSON-RPC API](https://docs.lotu.sh/en+api). By default, the Lotus daemon listens on `127.0.0.1:1234`. In case of needing to change the listening host/port, the configuration `API.ListenAddress` or `LOTUS_API_LISTENADDRESS` should be changed to the corresponding [multiaddress](https://multiformats.io/multiaddr/).

The second necessary configuration, is leveraging integrating the IPFS node, `go-ipfs` mentioned in the previous section, with Lotus. This configuration allows the IPFS node to be used as the underlying blockstore to store and retrieva data from the Filecoin network. This provides a convenient and efficient data-flow path in which Powergate won't participate, and thus avoid incurring in more overhead and resource usage.

To integrate IPFS with the Lotus node, the following configuration settings should be set:
- `Client.UseIpfs`/`LOTUS_CLIENT_USEIPFS`: With value `true`. This indicates that Lotus will use IPFS as the underlying blockstore for data for storage deals.
- `Client.IpfsUseForRetrieval`/`LOTUS_CLIENT_IPFSUSEFORERETRIEVAL`: With value `true`. This indicates Lotus will use IPFS as the underlying blockstore for retrieval deals.
- `Client.IpfsMAddr`/`LOTUS_CLIENT_IPFSMADDR`: Should contain the multiaddress of the IPFS node API mentioned in the last section, e.g: `/ip4/192.168.11.12/tcp/5001`.

The above description wraps all necessary and minimal configuration to run Lotus for Powergate.

### Wallet address keys

As mentioned before, the default folder where Lotus will save all its state is `~/.lotus`. Apart from containing the `config.toml` file, it includes the `keystore` folder. This folder contains *all the keys of wallets created in Lotus*. It's essential to understand the consequences of this fact correctly. 

The Lotus node will manage all wallet addresses used by Powergate, thus its private keys are contained in this folder. Therefore, take necessary precautions such as:
- This folder should have minimal access.
- Frequent backups are recommended for this folder. Recall that keys-backups are sensitive process to handle correctly since you're making copies of keys, and possibly increasing the risk of leakeage.
- You can reduce the blast-radius of data loss by thinking about different strategies to keep the balances from these wallet addresses to a minimum.

There's some discussion to allow Lotus to use an external component for signing, which allows to minimize these risks. Whenever that feature is ready, there's a high chance that this document will be updated to explain how to leverage that new feature for Powergate.

# Install Powergate

To run Powergate, you should run the `powd` binary with proper flags or environment variables configuration.

You can download `powd` binaries from the [GitHub Releases section](https://github.com/textileio/powergate/releases) for your OS and architecture. If you prefer to compile `powd` from source, you can checkout the Powergate repo to your desired version and run `make install-powd` which will build and install `powd` in your `$GOPATH/bin` folder. Note that to compile, we're targeting Go 1.14 or newer version.

## Basic configuration

In this section, we outline the basic configuration needed for Powergate. Recall you can execute `powd -h` to look for default values and format of configuration values.

The first configuration step is to provide information to connect to the Lotus API correctly. For this, you should provide `POWD_LOTUSHOST`/`--lotushost`, which should be multiaddress that indicates where is the Lotus API JSON-RPC endpoint mentioned in the previous section. 

Additionally, you should indicate which is the _auth token_ of the API. The _auth token_ lives in `~/.lotus/token` in your Lotus host. Powergate allows this parameter to be configured in two ways: the path of this token file, or providing the token value directly. For the former, you should set `POWD_LOTUSTOKENFILE`/`--lotustokenfile`, and for the latter `POWD_LOTUSTOKEN`/`--lotustoken`. At least one of each env/flags should be provided. If that isn't the case `powd` will fail to start indicating that as an error.

The second configuration step is to provide information to connect to the IPFS node. This is done by configuring `POWD_IPFSAPIADDR`/`--ipfsapiaddr` which is a multiaddress with the `go-ipfs` API endpoint.

Finally, the last necessary step is to have the _Geolite database_ which provides geolocation information for Powergate indices. This database can also be found in the release assets with name `GeoLite2-City.mmdb`. By default, `powd` expect to find this file in the current executing folder. You can customize the path of this file with `POWD_MAXMINDDBFOLDER`/`--maxminddbfolder`.

## gRPC APIs

Powergate provides a gRPC endpoint to serve its APIs, and a [grpc-Web proxy](https://github.com/improbable-eng/grpc-web) for the JS client. The default listening address can be changed by modifying `POWD_GRPCHOSTADDR`/`--grpchostaddr` and `POWD_GRPCWEBPROXYADDR`/`--grpchostaddr` respectively.

The `powd` binary doesn't have flags for providing SSL certificates to serve these endpoints securely. You might consider using a reverse proxy which does SSL offloading. The gRPC clients support secure gRPC connections.

## Filecoin network selection

Although Powergate interacts with the Filecoin network through Lotus, it also connects to the Filecoin network and DHT directly. This is done to gather information for building indices, which means that is important that Powergate connects to the same Filecoin network as the Lotus node to produce coherent index data.

To avoid possible configuration mismatches, Powergate always connects to the same network Lotus is connected. This is done automatically by Powergate which asks the Lotus node for the network identity its connected to. No extra flags or configuration are needed to select the right network to connect to. 

## Indices gateway

Powergate provides an indices gateway which presents miners, storage asks, and faults indices in a pretty web page.x  The listening address of this webserver can be modified with `POWD_GATEWAYHOSTADDR`/`--gatewayhostaddr`.

## FFS configuration

The FFS module is a central part of Powergate for storing data in Filecoin in a declarative way.

To provide some context about the related configuration parameters, we should understand some basics about FFS. In the FFS module, we have two central actors: the _FFS manager_, and _FFS instances_. The _FFS Manager_ is responsible for creating and managing _FFS instances_, which provide a scoped container for storing data in Filecoin.

In the usual configuration of FFS, when the manager creates a new instance it also creates a new wallet address in Lotus to be owned by it. 

As an optional feature, it can fund the newly created address with initial funds. For this to happen, the manager should have a _masteraddr_. A _masteraddr_ is a wallet address owned by the manager, which is used as the source to fund newly created instances wallet addresses. 

For this feature to be enabled, the `POWD_LOTUSMASTERADDR`/`--lotusmasteraddr` should be set. If this is the case, this most probably involved a previous action from the system administrator to create or import the wallet address with funds in the Lotus node. If you're running Powergate in a test network, you can avoid setting a specific _master address_, and enable the `POWD_AUTOCREATEMASTERADDR`/`--autocreatemasteraddr`. This configuration will auto-create a _master address_ for the manager, and auto-fund it with the corresponding test network facuet.

Finally, to configure the amount of _attoFil_ to be transferred by the _manager_ to a newly created wallet, you should set `POWD_WALLETINITIALFUND`/`--walletinitialfund`. This configuration only applies if you set the _master address_ manually, or enabled the master address auto-creation.

### Sharing wallet address in all FFS instances

Depending on your use-case, having each FFS instance have its own wallet address might be a beneficial setup. If you plan different FFS instances for different purposes, it may be logical to bound the amount of FIL spent on storage or retrieval actions for various purposes. Also, any abuse of FIL spending gets a hard limit per-instance and not in a _single bag_ of FIL.

On the other hand, other use-cases might want to share a single wallet address for all FFS instances operation. An example could be saving fees or gas cost of funding transactions, or avoiding the delay of funding transactions to be accepted on-chain.

If that's the case, you can provide an extra configuration `POWD_FFSUSEMASTERADDR`/`--ffsusemasteraddr` which indicates to the manager to avoid creating a new wallet address when an instance is created. As a consequence, _all newly created FFS instances will use the manager master address_ as its funding wallet address for operations.

## Metrics endpoint

Powergate exposes an Prometheus metrics endpoint at `:8888`. You can connect your Prometheus scrapper to gather metrics data about multiple components of Powergate. In the `docker/grafana` folder you can find a possible Grafana dashboard to leverage using existing metrics.

'''
'''--- Filecoin/powergate/fchost/config.go ---
package fchost

import (
	"fmt"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p-core/peer"
	"github.com/libp2p/go-libp2p/config"
	"github.com/multiformats/go-multiaddr"
)

var (
	networkBootstrappers = map[string][]string{
		"mainnet": {
			"/dns4/bootstrap-0.mainnet.filops.net/tcp/1347/p2p/12D3KooWCVe8MmsEMes2FzgTpt9fXtmCY7wrq91GRiaC8PHSCCBj",
			"/dns4/bootstrap-1.mainnet.filops.net/tcp/1347/p2p/12D3KooWCwevHg1yLCvktf2nvLu7L9894mcrJR4MsBCcm4syShVc",
			"/dns4/bootstrap-2.mainnet.filops.net/tcp/1347/p2p/12D3KooWEWVwHGn2yR36gKLozmb4YjDJGerotAPGxmdWZx2nxMC4",
			"/dns4/bootstrap-3.mainnet.filops.net/tcp/1347/p2p/12D3KooWKhgq8c7NQ9iGjbyK7v7phXvG6492HQfiDaGHLHLQjk7R",
			"/dns4/bootstrap-4.mainnet.filops.net/tcp/1347/p2p/12D3KooWL6PsFNPhYftrJzGgF5U18hFoaVhfGk7xwzD8yVrHJ3Uc",
			"/dns4/bootstrap-5.mainnet.filops.net/tcp/1347/p2p/12D3KooWLFynvDQiUpXoHroV1YxKHhPJgysQGH2k3ZGwtWzR4dFH",
			"/dns4/bootstrap-6.mainnet.filops.net/tcp/1347/p2p/12D3KooWP5MwCiqdMETF9ub1P3MbCvQCcfconnYHbWg6sUJcDRQQ",
			"/dns4/bootstrap-7.mainnet.filops.net/tcp/1347/p2p/12D3KooWRs3aY1p3juFjPy8gPN95PEQChm2QKGUCAdcDCC4EBMKf",
			"/dns4/bootstrap-8.mainnet.filops.net/tcp/1347/p2p/12D3KooWScFR7385LTyR4zU1bYdzSiiAb5rnNABfVahPvVSzyTkR",
			"/dns4/lotus-bootstrap.forceup.cn/tcp/41778/p2p/12D3KooWFQsv3nRMUevZNWWsY1Wu6NUzUbawnWU5NcRhgKuJA37C",
			"/dns4/bootstrap-0.starpool.in/tcp/12757/p2p/12D3KooWGHpBMeZbestVEWkfdnC9u7p6uFHXL1n7m1ZBqsEmiUzz",
			"/dns4/bootstrap-1.starpool.in/tcp/12757/p2p/12D3KooWQZrGH1PxSNZPum99M1zNvjNFM33d1AAu5DcvdHptuU7u",
			"/dns4/node.glif.io/tcp/1235/p2p/12D3KooWBF8cpp65hp2u9LK5mh19x67ftAam84z9LsfaquTDSBpt",
			"/dns4/bootstrap-0.ipfsmain.cn/tcp/34721/p2p/12D3KooWQnwEGNqcM2nAcPtRR9rAX8Hrg4k9kJLCHoTR5chJfz6d",
			"/dns4/bootstrap-1.ipfsmain.cn/tcp/34723/p2p/12D3KooWMKxMkD5DMpSWsW7dBddKxKT7L2GgbNuckz9otxvkvByP",
		},
		"calibrationnet": {
			"/dns4/bootstrap-0.calibration.fildev.network/tcp/1347/p2p/12D3KooWRLZAseMo9h7fRD6ojn6YYDXHsBSavX5YmjBZ9ngtAEec",
			"/dns4/bootstrap-1.calibration.fildev.network/tcp/1347/p2p/12D3KooWJFtDXgZEQMEkjJPSrbfdvh2xfjVKrXeNFG1t8ioJXAzv",
			"/dns4/bootstrap-2.calibration.fildev.network/tcp/1347/p2p/12D3KooWP1uB9Lo7yCA3S17TD4Y5wStP5Nk7Vqh53m8GsFjkyujD",
			"/dns4/bootstrap-3.calibration.fildev.network/tcp/1347/p2p/12D3KooWLrPM4WPK1YRGPCUwndWcDX8GCYgms3DiuofUmxwvhMCn",
		},
	}
)

func getBootstrapPeers(network string) ([]peer.AddrInfo, error) {
	addrs, ok := networkBootstrappers[network]
	if !ok {
		return nil, fmt.Errorf("network doesn't have any configured bootstrappers")
	}

	maddrs := make([]multiaddr.Multiaddr, len(addrs))
	for i, addr := range addrs {
		var err error
		maddrs[i], err = multiaddr.NewMultiaddr(addr)
		if err != nil {
			return nil, fmt.Errorf("converting multiaddrs: %s", err)
		}
	}
	peers, err := peer.AddrInfosFromP2pAddrs(maddrs...)
	if err != nil {
		return nil, fmt.Errorf("multiaddr conversion: %s", err)
	}
	return peers, nil
}

func getDefaultOpts() []config.Option {
	return []config.Option{libp2p.Defaults}
}

'''
'''--- Filecoin/powergate/fchost/fchost.go ---
package fchost

import (
	"context"
	"fmt"
	"sync"

	logging "github.com/ipfs/go-log/v2"
	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p-core/host"
	"github.com/libp2p/go-libp2p-core/peer"
	"github.com/libp2p/go-libp2p-core/protocol"
	dht "github.com/libp2p/go-libp2p-kad-dht"
	routedhost "github.com/libp2p/go-libp2p/p2p/host/routed"
	"github.com/libp2p/go-libp2p/p2p/protocol/ping"
	"github.com/multiformats/go-multiaddr"
)

var (
	log = logging.Logger("fchost")
)

// FilecoinHost is a libp2p host connected to the FC network.
type FilecoinHost struct {
	ping *ping.PingService
	h    host.Host
	dht  *dht.IpfsDHT
}

// New returns a new FilecoinHost.
func New(network string, bootstrap bool) (*FilecoinHost, error) {
	ctx := context.Background()
	opts := getDefaultOpts()
	h, err := libp2p.New(ctx, opts...)
	if err != nil {
		return nil, err
	}

	dht, err := dht.New(ctx, h, dht.ProtocolPrefix(protocol.ID("/fil/kad/"+network)))
	if err != nil {
		return nil, err
	}

	if bootstrap {
		if err := connectToBootstrapPeers(network, h); err != nil {
			return nil, err
		}
	}

	h = routedhost.Wrap(h, dht)
	return &FilecoinHost{
		h:    h,
		dht:  dht,
		ping: ping.NewPingService(h),
	}, nil
}

// Bootstrap connects to the bootstrap peers.
func (fc *FilecoinHost) Bootstrap() error {
	log.Info("bootstraping libp2p host dht")
	if err := fc.dht.Bootstrap(context.Background()); err != nil {
		return err
	}
	log.Info("dht bootstraped!")
	return nil
}

// Ping runs the ping protocol with a peer, returns true on success or false
// otherwise.
func (fc *FilecoinHost) Ping(ctx context.Context, pid peer.ID) bool {
	r := <-fc.ping.Ping(ctx, pid)
	return r.Error == nil
}

// GetAgentVersion returns the agent version of the peer, or empty otherwise.
func (fc *FilecoinHost) GetAgentVersion(pid peer.ID) string {
	if v, err := fc.h.Peerstore().Get(pid, "AgentVersion"); err == nil {
		agent, ok := v.(string)
		if ok {
			return agent
		}
	}
	return ""
}

// Addrs returns the known multiaddresses known of a peer.
func (fc *FilecoinHost) Addrs(pid peer.ID) []multiaddr.Multiaddr {
	return fc.h.Peerstore().Addrs(pid)
}

func connectToBootstrapPeers(network string, h host.Host) error {
	peers, err := getBootstrapPeers(network)
	if err != nil {
		return fmt.Errorf("getting bootstrap peers: %s", err)
	}
	ctx := context.Background()
	var lock sync.Mutex
	var success int
	var wg sync.WaitGroup
	wg.Add(len(peers))
	for _, ai := range peers {
		go func(ai peer.AddrInfo) {
			defer wg.Done()
			if err := h.Connect(ctx, ai); err != nil {
				return
			}
			lock.Lock()
			success++
			lock.Unlock()
		}(ai)
	}
	wg.Wait()
	if success == 0 {
		return fmt.Errorf("couldn't connect to any of bootstrap peers")
	}
	log.Infof("connected to %d out of %d bootstrap peers", success, len(peers))
	return nil
}

'''
'''--- Filecoin/powergate/fchost/fchost_test.go ---
package fchost

import (
	"context"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestPingBootstrapers(t *testing.T) {
	// This test is skipped since interopnet is getting reset
	// a lot and boostrap peers change very frequently.
	// We can re-enable this when the network becomes stable again.
	t.SkipNow()
	h, err := New("mainnet", false)
	require.NoError(t, err)
	err = h.Bootstrap()
	require.NoError(t, err)

	bsPeers, err := getBootstrapPeers("mainnet")
	require.NoError(t, err)
	for _, addr := range bsPeers {
		pong := h.Ping(context.Background(), addr.ID)
		if pong {
			return
		}
	}
	t.Fatalf("no bootstrap peers replied")
}

'''
'''--- Filecoin/powergate/ffs/Design.md ---
# FFS design

## Overview

This document presents the general design of the `ffs` package of `powergate`.

**Disclaimer**: This's ongoing work so the design will continue to change.

The following picture presents principal packages and interfaces that are part of the design:
![FFS Design](https://user-images.githubusercontent.com/6136245/83649396-847d5700-a58d-11ea-8d93-5ea20ca1bda7.png)

The picture has an advanced scenario where different _API_ instances are wired to different _Scheduler_ instances. Component names prefixed with * don't exist but are mentioned as possible implementations of existing interfaces.

The central idea about the design is that an _API_ defines the desired storing state for a _Cid_ using a _StorageConfig_ struct. This struct has information about desired storing state configuration in the Hot and Cold storages.

When a new or updated _StorageConfig_ is pushed in an _API_, it delegates this work to the _Scheduler_. The _Scheduler_ will execute whatever work is necessary to comply with the new/updated Cid storage configuration.

From the _Scheduler_ point of view, this work is considered a _Job_ created by _API_. The job refers to doing the necessary work to enforce the new _StorageConfig_. The _API_ can watch for this _Job_ state changes to see if the task of pushing a new _StorageConfig_ is queued, executing, finished successfully, failed, or canceled. The _Scheduler_ also provides a human-friendly log stream of work being done for a _Cid_.

The _Scheduler_ also executes proactive actions for prior pushed _StorageConfigs_ which enabled the _renew_ or _repair_ feature. Finally, the _Scheduler_ is designed to resume any kind of interrupted job executions.

## Components
The following sections give a more detailed description of each component and interface in the diagram.

### Manager
This component is responsible for creating _API_ instances. When a new _API_ instance is created, an _auth-token_ for this instance is also created. The client uses this _auth-token_ in each request in the API so that the _Manager_ can redirect the action to its corresponding _API_ instance, while also having some minimal access-control validation.

The mapping between _auth-tokens_ and _API_ is controlled by an _Auth_ component. Further features such as token invalidation, finer-grained access control per action, or multiple auth token support will live in this module.

Since _API_ might store data in the Filecoin network, they're asigned a newly created Filecoin address which will be controlled by the underlying Filecoin client used in the _ColdStorage_. The process of creating and assigning this new wallet account is done automatically by _Manager_, using a subcomponent _WalletManager_.

_Manager_ enables being configured to auto-fund newly created wallet addresses, so new created _API_ can have funds to execute actions in the Filecoin network. This feature can be optionally enabled. If enabled, a _masterAddress_ and _initialFunds_ will be configured which indicates from which Filecoin Client wallet address funds will be sent and the amount of the transfer.

### API
_API_ is a concrete instance of FFS to be used by a client.
It owns the following information:
- At least one Filecoin address. Later the client can opt to create more address and indicate which to use when making action.
- _StorageConfigs_ describing the desired state for Cids to be stored in Hot and Cold storage.
- A default _StorageConfig_ to be used unless an explicit _StorageConfig_ is given.

The instance provides apis to:
- Get and Set the default _StorageConfig_ used to store new data.
- Get summary information about all the _Cid_ stored in this instance.
- Manage Filecoin wallet addresses under its control.
- Sending FIL transactions from owned Filecoin wallet addresses.
- Create, replace and remove _StorageConfig_ which indicates which cids to store in the instance.
- Provide detailed information about a particular stored Cid.
- Get information about status of executing _Jobs_ corresponding to the FFS instance.
- Human-friendly log streams about events happening for a _Cid_, from storage, renewals, repair and anything related to actions being done for it.

### Scheduler

In a nutshell, the _Scheduler_ is the component responsible for orchestrating the Hot and Cold storage to enforce indicated _StorageConfigs_ by connected _API_.

Refer to the [Go docs](https://pkg.go.dev/github.com/textileio/powergate/ffs/scheduler?tab=doc) to see its exported API.

### Responsibilities
When a new _StorageConfig_ is pushed by an _API_, the _Scheduler_ is responsible for orchestrating whatever actions are necessary to enforce it with the Hot and Col storage.

Every new _StorageConfig_, being the first or newer version for a Cid, is encapsulated in a _Job_. A _Job_ is the unit of work which the _Scheduler_ executes. _Jobs_ have different status: _Queued_, _Executing_, _Done_, _Failed_, and _Canceled_.

Apart from executing _Jobs_, the _Scheduler_ has background processes to keep enforcing configuration features that requires tracking. For example, if a _StorageConfig_ has renewal or repair enabled, the _Scheduler_ is responsible for do necessary work as expected.
Apart from _Jobs_, the _Scheduler_ has background tasks that monitor deal renewals or repair operations.

In summary, _APIs_ delegates *the desired state for a Cid* and the _Scheduler_ is responsible for *ensuring that state is true* by orchestrating the Hot and Cold storage.

#### Hot and Cold storage abstraction
The _Scheduler_ interacts with abstractions for the Hot and Cold storage.
Refer to the Go docs of the [HotStorage](https://pkg.go.dev/github.com/textileio/powergate@v0.0.1-beta.6/ffs?tab=doc#HotStorage) and [ColdStorage](https://pkg.go.dev/github.com/textileio/powergate@v0.0.1-beta.6/ffs?tab=doc#ColdStorage) to understand their APIs.

It can be noticed that the _ColdStorage_ interface is quite biased towards using a _Filecoin client_ in the implementation, but this enables to include also other tiered cold storages if wanted if deal creation or retrieval may be wanted. Refer to the diagram at the top of this document to understand possible configurations.

The _ColdStorage_ relies on a _MinerSelector_ interface to query the universe of available miners to make new deals. Refer to the [Go doc](https://pkg.go.dev/github.com/textileio/powergate/ffs@v0.0.1-beta.6?tab=doc#MinerSelector) to understand its API.

Powergate has the _Reputation Module_ which leverages built indexes about miners data to provide a universe of available miners soreted by a chosen criteria. In a full run of FFS, the _ColdStorage_ is connected to a _MinerSelector_ with the _Reputation Module_ implementation. However, for integration tests a _FixedMiners_ miner selector is used to bound the universe of available miners for deals to desired values.

The _MinerSelector_ API already provides enough filtering configuration to force using or excluding particular miners. In general, other implementations than the default one should be used if the universe of available miners wants to be completely controlled by design, and not by available miners on the connected Filecoin network.

### Cid Configuration
In the current document we've referred to _StorageConfigs_ as a central concept in the FFS module. A _StorageConfig_ indicates the desired storing state of a _Cid_ scoped in a _API_. Refer to the [Go docs](https://pkg.go.dev/github.com/textileio/powergate/ffs) to understand its rich configuration.

#### _API_ _Get(...)_ operation
One important point is that `Get` operations in _API_ can only retrieve data from hot storage (via `GetCidFromHot` in the _Scheduler_).
This has some different scenarios:
- If the data is stored in hot storage, it fetched from there.
- If the data wasn't enabled in hot storage (`HotConfig.Enabled: false`), it will error indicating that hot storage isn't enabled.

The last point indicates that the _API_ client should explicitly set `HotConfig.Enabled: true` to be able to retrieve the data. Hot Storage enabling is done in two steps:
1) It tries to fetch the data from the IPFS network considering the `AddTimeout` as a bound of time.
2) If the last step failed:
2.a) If `HotConfig.AllowUnfreeze: false`, it fails since it couldn't fetch the data from the single allowed source (IPFS network).
2.b) If `HotConfig.AllowUnfreeze: true`; it will check if the data is available at Cold Storage. If that's the case, it will _unfreeze the data_, and save it to Hot Storage. This allows a `Get` operation afterward.

The rationale behind asking the client to enable hot storage with allow-unfreeze is related to the fact that retrieving data from Filecion incurs in an economic cost that will be paid by the _API_ address. Retrieving data from the IPFS network is considered _free_ (discarding unavoidable bandwidth costs, etc).

### Updating StorageConfig
The _Scheduler_ is always checking the current state of Cid storage before executing actions regarding an updated _StorageConfig_.

_StorageConfig_ changes regarding Hot Storage are always applied since Hot Storage is, in general, malleable. In particular, enabling or disabling Hot Storage is most probably easy to execute and thus have a predictable ending state.

_StorageConfig_ changes regarding Cold Storage have more subtle meaning. For example, if the _RepFactor_ is increased the _Scheduler_ will be aware of the current _RepFactor_ and only make enough new deals to ensure its new value. e.g: if _RepFactor_ was 1 and the updated _StorageConfig_ has _RepFactor_ 2, it will only make one new deal. 
As another example, if _RepFactor_ was 2 and is decreased to 1, the _Scheduler_ won't execute any actual work since one of the two current active deals will eventually expire.

The _RepFactor_ configuration also is considered if the Cid has enabled automatic deal renweal. In particular, if the _RepFactor_ was decreased from 3 to 1, the rewneal logic will wait until the last deal is close to expiring to only renew that one. That's saying, the renew logic doesn't blindly renew expiring deals, but it's _RepFactor aware_ as expected.

Regarding other Cold Storage configuration changes regarding miner selection, such as country filtering or excluded miners, these new considerations will be made every time a new deal is made. Any other existing deals that are active that were created on other configuration conditions can't be canceled or reverted. Saying it differently, the new miner-related configuration will be considered from future new deals, i.e: renewing deals, increased _RepFactor_, repairing.

'''
'''--- Filecoin/powergate/ffs/api/api.go ---
package api

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/namespace"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler"
)

var (
	log = logging.Logger("ffs-api")
)

var (
	// ErrMustOverrideConfig returned when trying to push config for storing a Cid
	// without the override flag.
	ErrMustOverrideConfig = errors.New("cid already pinned, consider using override flag")
	// ErrReplacedCidNotFound returns when replacing a Cid that isn't stored.
	ErrReplacedCidNotFound = errors.New("provided replaced cid wasn't found")
	// ErrActiveInStorage returns when a Cid is trying to be removed but still defined as active
	// on Hot or Cold storage.
	ErrActiveInStorage = errors.New("can't remove Cid, disable from Hot and Cold storage")
	// ErrHotStorageDisabled returned when trying to fetch a Cid when disabled on Hot Storage.
	// To retrieve the data, is necessary to call unfreeze by enabling the Enabled flag in
	// hot storage for that Cid.
	ErrHotStorageDisabled = errors.New("cid disabled in hot storage")
)

// API is an Api instance, which owns a Lotus Address and allows to
// Store and Retrieve Cids from hot and cold storage.
type API struct {
	is  *instanceStore
	wm  ffs.WalletManager
	drm ffs.DealRecordsManager

	sched *scheduler.Scheduler

	lock   sync.Mutex
	closed bool
	cfg    InstanceConfig
	ctx    context.Context
	cancel context.CancelFunc
}

// New returns a new Api instance.
func New(ds datastore.Datastore, iid ffs.APIID, sch *scheduler.Scheduler, wm ffs.WalletManager, drm ffs.DealRecordsManager, dc ffs.StorageConfig, addrInfo AddrInfo) (*API, error) {
	is := newInstanceStore(namespace.Wrap(ds, datastore.NewKey("istore")))

	dc.Cold.Filecoin.Addr = addrInfo.Addr

	if err := dc.Validate(); err != nil {
		return nil, fmt.Errorf("default storage config is invalid: %s", err)
	}

	config := InstanceConfig{
		ID:                   iid,
		Addrs:                map[string]AddrInfo{addrInfo.Addr: addrInfo},
		DefaultStorageConfig: dc,
	}

	ctx, cancel := context.WithCancel(context.Background())
	i := new(ctx, is, wm, drm, config, sch, cancel)
	if err := i.is.putInstanceConfig(config); err != nil {
		return nil, fmt.Errorf("saving new instance %s: %s", i.cfg.ID, err)
	}
	return i, nil
}

// Load loads a saved Api instance from its ConfigStore.
func Load(ds datastore.Datastore, iid ffs.APIID, sched *scheduler.Scheduler, wm ffs.WalletManager, drm ffs.DealRecordsManager) (*API, error) {
	is := newInstanceStore(namespace.Wrap(ds, datastore.NewKey("istore")))
	c, err := is.getInstanceConfig()
	if err != nil {
		return nil, fmt.Errorf("loading instance: %s", err)
	}
	ctx, cancel := context.WithCancel(context.Background())
	return new(ctx, is, wm, drm, c, sched, cancel), nil
}

func new(ctx context.Context, is *instanceStore, wm ffs.WalletManager, drm ffs.DealRecordsManager, config InstanceConfig, sch *scheduler.Scheduler, cancel context.CancelFunc) *API {
	i := &API{
		is:     is,
		wm:     wm,
		drm:    drm,
		cfg:    config,
		sched:  sch,
		cancel: cancel,
		ctx:    ctx,
	}
	return i
}

// ID returns the ID.
func (i *API) ID() ffs.APIID {
	return i.cfg.ID
}

// DefaultStorageConfig returns the default StorageConfig.
func (i *API) DefaultStorageConfig() ffs.StorageConfig {
	return i.cfg.DefaultStorageConfig
}

// SetDefaultStorageConfig sets a new default StorageConfig.
func (i *API) SetDefaultStorageConfig(c ffs.StorageConfig) error {
	i.lock.Lock()
	defer i.lock.Unlock()
	if err := c.Validate(); err != nil {
		return fmt.Errorf("default cid config is invalid: %s", err)
	}
	i.cfg.DefaultStorageConfig = c
	return i.is.putInstanceConfig(i.cfg)
}

// GetStorageConfigs returns the current StorageConfigs for a FFS instance, filtered by cids, if provided.
func (i *API) GetStorageConfigs(cids ...cid.Cid) (map[cid.Cid]ffs.StorageConfig, error) {
	configs, err := i.is.getStorageConfigs(cids...)
	if err == ErrNotFound {
		return nil, err
	}
	if err != nil {
		return nil, fmt.Errorf("getting cid configs from store: %s", err)
	}
	return configs, nil
}

// Close terminates the running Api.
func (i *API) Close() error {
	i.lock.Lock()
	defer i.lock.Unlock()
	if i.closed {
		return nil
	}
	i.cancel()
	i.closed = true
	return nil
}

'''
'''--- Filecoin/powergate/ffs/api/api_actions.go ---
package api

import (
	"context"
	"fmt"
	"io"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
)

// PushStorageConfig push a new configuration for the Cid in the hot and
// cold storage. If WithOverride opt isn't set it errors with ErrMustOverrideConfig.
func (i *API) PushStorageConfig(c cid.Cid, opts ...PushStorageConfigOption) (ffs.JobID, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	cfg := pushStorageConfigConfig{config: i.cfg.DefaultStorageConfig}
	for _, opt := range opts {
		if err := opt(&cfg); err != nil {
			return ffs.EmptyJobID, fmt.Errorf("config option: %s", err)
		}
	}
	if !cfg.overrideConfig {
		_, err := i.is.getStorageConfigs(c)
		if err == nil {
			return ffs.EmptyJobID, ErrMustOverrideConfig
		}
		if err != ErrNotFound {
			return ffs.EmptyJobID, fmt.Errorf("getting cid config: %s", err)
		}
	}
	if err := cfg.config.Validate(); err != nil {
		return ffs.EmptyJobID, err
	}
	if err := i.ensureValidColdCfg(cfg.config.Cold); err != nil {
		return ffs.EmptyJobID, err
	}

	if len(cfg.dealIDs) > 0 {
		if err := i.sched.ImportDeals(i.cfg.ID, c, cfg.dealIDs); err != nil {
			return ffs.EmptyJobID, fmt.Errorf("importing external deals information: %s", err)
		}
	}

	var jid ffs.JobID
	var err error
	if !cfg.noExec {
		jid, err = i.sched.PushConfig(i.cfg.ID, c, cfg.config)
		if err != nil {
			return ffs.EmptyJobID, fmt.Errorf("scheduling cid %s: %s", c, err)
		}
	}
	if err := i.is.putStorageConfig(c, cfg.config); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("saving new config for cid %s: %s", c, err)
	}
	return jid, nil
}

// Remove removes a Cid from being tracked as an active storage. The Cid should have
// both Hot and Cold storage disabled, if that isn't the case it will return ErrActiveInStorage.
func (i *API) Remove(c cid.Cid) error {
	i.lock.Lock()
	defer i.lock.Unlock()

	cfgs, err := i.is.getStorageConfigs(c)
	if err == ErrNotFound {
		return err
	}
	if err != nil {
		return fmt.Errorf("getting cid config from store: %s", err)
	}
	if cfgs[c].Hot.Enabled || cfgs[c].Cold.Enabled {
		return ErrActiveInStorage
	}
	if err := i.sched.Untrack(i.cfg.ID, c); err != nil {
		return fmt.Errorf("untracking from scheduler: %s", err)
	}
	if err := i.is.removeStorageConfig(c); err != nil {
		return fmt.Errorf("deleting replaced cid config: %s", err)
	}
	return nil
}

// Replace pushes a StorageConfig for c2 equal to that of c1, and removes c1. This operation
// is more efficient than manually removing and adding in two separate operations.
// c1 and c2 must not be equal.
func (i *API) Replace(c1 cid.Cid, c2 cid.Cid) (ffs.JobID, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	if c1.Equals(c2) {
		return ffs.EmptyJobID, fmt.Errorf("the old and new cid should be different")
	}

	cfgs, err := i.is.getStorageConfigs(c1)
	if err == ErrNotFound {
		return ffs.EmptyJobID, ErrReplacedCidNotFound
	}
	if err != nil {
		return ffs.EmptyJobID, fmt.Errorf("getting replaced cid config: %s", err)
	}

	if err := i.ensureValidColdCfg(cfgs[c1].Cold); err != nil {
		return ffs.EmptyJobID, err
	}

	jid, err := i.sched.PushReplace(i.cfg.ID, c2, cfgs[c1], c1)
	if err != nil {
		return ffs.EmptyJobID, fmt.Errorf("scheduling replacement %s to %s: %s", c1, c2, err)
	}
	if err := i.is.putStorageConfig(c2, cfgs[c1]); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("saving new config for cid %s: %s", c2, err)
	}
	if err := i.is.removeStorageConfig(c1); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("deleting replaced cid config: %s", err)
	}
	return jid, nil
}

// Get returns an io.Reader for reading a stored Cid from hot storage.
func (i *API) Get(ctx context.Context, c cid.Cid) (io.Reader, error) {
	if !c.Defined() {
		return nil, fmt.Errorf("cid is undefined")
	}
	cfgs, err := i.is.getStorageConfigs(c)
	if err != nil {
		return nil, fmt.Errorf("getting cid config: %s", err)
	}
	if !cfgs[c].Hot.Enabled {
		return nil, ErrHotStorageDisabled
	}
	r, err := i.sched.GetCidFromHot(ctx, c)
	if err != nil {
		return nil, fmt.Errorf("getting from hot storage %s: %s", c, err)
	}
	return r, nil
}

// CancelJob cancels an executing Job. If no Job is executing
// with that JobID, it won't fail.
func (i *API) CancelJob(jid ffs.JobID) error {
	if err := i.sched.Cancel(jid); err != nil {
		return fmt.Errorf("canceling job %s: %s", jid, err)
	}
	return nil
}

func (i *API) ensureValidColdCfg(cfg ffs.ColdConfig) error {
	if cfg.Enabled && !i.isManagedAddress(cfg.Filecoin.Addr) {
		return fmt.Errorf("%v is not managed by ffs instance", cfg.Filecoin.Addr)
	}
	return nil
}

'''
'''--- Filecoin/powergate/ffs/api/api_deals.go ---
package api

import (
	"fmt"

	"github.com/textileio/powergate/v2/deals"
)

// StorageDealRecords lists storage deals for this FFS instance according to the provided options.
func (i *API) StorageDealRecords(opts ...deals.DealRecordsOption) ([]deals.StorageDealRecord, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	c := deals.DealRecordsConfig{}
	for _, opt := range opts {
		opt(&c)
	}
	finalAddrs, err := i.validateAndPrepareAddresses(c.FromAddrs)
	if err != nil {
		return nil, fmt.Errorf("validating and preparing final addrs: %v", err)
	}

	// We don't passthrough opts below since above
	// the list of wallet addresses might get transformed from opts.
	recs, err := i.drm.ListStorageDealRecords(
		deals.WithFromAddrs(finalAddrs...),
		deals.WithAscending(c.Ascending),
		deals.WithDataCids(c.DataCids...),
		deals.WithIncludeFinal(c.IncludeFinal),
		deals.WithIncludePending(c.IncludePending),
		deals.WithIncludeFailed(c.IncludeFailed),
	)
	if err != nil {
		return nil, fmt.Errorf("calling ListStorageDealRecords: %v", err)
	}
	return recs, nil
}

// RetrievalDealRecords returns a list of retrieval deals for this FFS instance according to the provided options.
func (i *API) RetrievalDealRecords(opts ...deals.DealRecordsOption) ([]deals.RetrievalDealRecord, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	c := deals.DealRecordsConfig{}
	for _, opt := range opts {
		opt(&c)
	}
	finalAddrs, err := i.validateAndPrepareAddresses(c.FromAddrs)
	if err != nil {
		return nil, fmt.Errorf("validating and preparing addrs: %v", err)
	}

	// We don't passthrough opts below since above
	// the list of wallet addresses might get transformed from opts.
	recs, err := i.drm.ListRetrievalDealRecords(
		deals.WithFromAddrs(finalAddrs...),
		deals.WithAscending(c.Ascending),
		deals.WithDataCids(c.DataCids...),
		deals.WithIncludeFailed(c.IncludeFailed),
	)
	if err != nil {
		return nil, fmt.Errorf("calling ListRetrievalDealRecords: %v", err)
	}
	return recs, nil
}

func (i *API) validateAndPrepareAddresses(fromAddrs []string) ([]string, error) {
	instanceAddrs := make([]string, 0, len(i.cfg.Addrs))
	instanceAddrsFilter := make(map[string]struct{})
	for _, addrInfo := range i.cfg.Addrs {
		instanceAddrs = append(instanceAddrs, addrInfo.Addr)
		instanceAddrsFilter[addrInfo.Addr] = struct{}{}
	}

	var finalAddrs []string
	if len(fromAddrs) > 0 {
		for _, addr := range fromAddrs {
			if _, ok := instanceAddrsFilter[addr]; !ok {
				return nil, fmt.Errorf("address %s is not managed by this ffs instance", addr)
			}
			finalAddrs = append(finalAddrs, addr)
		}
	} else {
		finalAddrs = instanceAddrs
	}
	return finalAddrs, nil
}

'''
'''--- Filecoin/powergate/ffs/api/api_jobs.go ---
package api

import (
	"context"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler"
)

// GetStorageJob returns the current state of the specified job.
func (i *API) GetStorageJob(jid ffs.JobID) (ffs.StorageJob, error) {
	job, err := i.sched.StorageJob(jid)
	if err == scheduler.ErrNotFound {
		return ffs.StorageJob{}, fmt.Errorf("job id %s not found", jid)
	}
	if err != nil {
		return ffs.StorageJob{}, fmt.Errorf("getting current job state: %s", err)
	}
	return job, nil
}

// WatchJobs subscribes to Job status changes. If jids is empty, it subscribes to
// all Job status changes corresonding to the instance. If jids is not empty,
// it immediately sends current state of those Jobs. If empty, it doesn't.
func (i *API) WatchJobs(ctx context.Context, c chan<- ffs.StorageJob, jids ...ffs.JobID) error {
	var jobs []ffs.StorageJob
	for _, jid := range jids {
		j, err := i.sched.StorageJob(jid)
		if err == scheduler.ErrNotFound {
			return fmt.Errorf("job id %s not found", jid)
		}
		if err != nil {
			return fmt.Errorf("getting current job state: %s", err)
		}
		jobs = append(jobs, j)
	}

	ch := make(chan ffs.StorageJob, 10)
	for _, j := range jobs {
		select {
		case ch <- j:
		default:
			log.Warnf("dropped notifying current job state on slow receiver on %s", i.cfg.ID)
		}
	}
	var err error
	go func() {
		err = i.sched.WatchJobs(ctx, ch, i.cfg.ID)
		close(ch)
	}()
	for j := range ch {
		if len(jids) == 0 {
			c <- j
		}
	JidLoop:
		for _, jid := range jids {
			if jid == j.ID {
				c <- j
				break JidLoop
			}
		}
	}
	if err != nil {
		return fmt.Errorf("scheduler listener: %s", err)
	}

	return nil
}

// ListStorageJobsSelect specifies which StorageJobs to list.
type ListStorageJobsSelect int

const (
	// All lists all StorageJobs and is the default.
	All ListStorageJobsSelect = iota
	// Queued lists queued StorageJobs.
	Queued
	// Executing lists executing StorageJobs.
	Executing
	// Final lists final StorageJobs.
	Final
)

// ListStorageJobsConfig controls the behavior for listing StorageJobs.
type ListStorageJobsConfig struct {
	// CidFilter filters StorageJobs list to the specified cid. Defaults to no filter.
	CidFilter cid.Cid
	// Limit limits the number of StorageJobs returned. Defaults to no limit.
	Limit uint64
	// Ascending returns the StorageJobs ascending by time. Defaults to false, descending.
	Ascending bool
	// Select specifies to return StorageJobs in the specified state.
	Select ListStorageJobsSelect
	// NextPageToken sets the slug from which to start building the next page of results.
	NextPageToken string
}

// ListStorageJobs lists StorageJobs according to the provided ListStorageJobsConfig.
func (i *API) ListStorageJobs(config ListStorageJobsConfig) ([]ffs.StorageJob, bool, string, error) {
	c := scheduler.ListStorageJobsConfig{
		APIIDFilter:   i.cfg.ID,
		CidFilter:     config.CidFilter,
		Limit:         config.Limit,
		Ascending:     config.Ascending,
		Select:        scheduler.Select(config.Select),
		NextPageToken: config.NextPageToken,
	}
	return i.sched.ListStorageJobs(c)
}

// StorageConfigForJob returns the StorageConfig associated with the specified job.
func (i *API) StorageConfigForJob(jid ffs.JobID) (ffs.StorageConfig, error) {
	sc, err := i.sched.StorageConfig(jid)
	if err == scheduler.ErrNotFound {
		return ffs.StorageConfig{}, ErrNotFound
	}
	if err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("getting storage config for job: %v", err)
	}
	return sc, nil
}

'''
'''--- Filecoin/powergate/ffs/api/api_logs.go ---
package api

import (
	"context"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
)

// WatchLogs pushes human-friendly messages about Cid executions. The method is blocking
// and will continue to send messages until the context is canceled.
func (i *API) WatchLogs(ctx context.Context, ch chan<- ffs.LogEntry, c cid.Cid, opts ...GetLogsOption) error {
	_, err := i.is.getStorageConfigs(c)
	if err == ErrNotFound {
		return ErrNotFound
	}
	if err != nil {
		return fmt.Errorf("validating cid: %s", err)
	}

	config := &GetLogsConfig{}
	for _, o := range opts {
		o(config)
	}

	if config.history {
		lgs, err := i.sched.GetLogsByCid(ctx, i.cfg.ID, c)
		if err != nil {
			return fmt.Errorf("getting history logs of %s: %s", c, err)
		}
		for _, l := range lgs {
			if config.jid == ffs.EmptyJobID || config.jid == l.Jid {
				ch <- l
			}
		}
	}

	ichan := make(chan ffs.LogEntry, cap(ch))
	go func() {
		err = i.sched.WatchLogs(ctx, ichan)
		close(ichan)
	}()
	for le := range ichan {
		if c == le.Cid && le.APIID == i.cfg.ID && (config.jid == ffs.EmptyJobID || config.jid == le.Jid) {
			ch <- le
		}
	}
	if err != nil {
		return fmt.Errorf("listening to cid logs: %s", err)
	}

	return nil
}

'''
'''--- Filecoin/powergate/ffs/api/api_retrieval.go ---
package api

import (
	"fmt"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
)

type retrievalConfig struct {
	walletAddress string
	maxPrice      uint64
}

// Retrieval indicates information of a retrieval in the
// Filecoin network.
type Retrieval struct {
	ID            ffs.RetrievalID
	PayloadCid    cid.Cid
	PieceCid      cid.Cid
	Selector      string
	Miners        []string
	WalletAddress string
	MaxPrice      uint64
	JID           ffs.JobID
	CreatedAt     time.Time

	// Possibly empty
	RetrievalMiner string
	DataCid        cid.Cid
	Size           uint64
}

// StartRetrieval schedules a new job to do a data retrieval.
func (i *API) StartRetrieval(payloadCid, pieceCid cid.Cid, selector string, miners []string, opts ...RetrievalOption) (Retrieval, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	if !payloadCid.Defined() {
		return Retrieval{}, fmt.Errorf("payload cid is undefined")
	}
	if !pieceCid.Defined() {
		return Retrieval{}, fmt.Errorf("piece cid is undefined")
	}
	// ToDo: whenever text-based selectors are ready
	// we should try checking the prc.Selector is well-formated.

	defWalletAddress := i.cfg.DefaultStorageConfig.Cold.Filecoin.Addr
	rc := retrievalConfig{walletAddress: defWalletAddress}
	for _, o := range opts {
		o(&rc)
	}
	if !i.isManagedAddress(rc.walletAddress) {
		return Retrieval{}, fmt.Errorf("%s isn't a managed address", rc.walletAddress)
	}

	rID := ffs.NewRetrievalID()
	jid, err := i.sched.StartRetrieval(i.cfg.ID, rID, payloadCid, pieceCid, selector, miners, rc.walletAddress, rc.maxPrice)
	if err != nil {
		return Retrieval{}, fmt.Errorf("starting retrieval in scheduler: %s", err)
	}

	rr, err := i.is.putRetrievalRequest(rID, payloadCid, pieceCid, selector, miners, rc.walletAddress, rc.maxPrice, jid)
	if err != nil {
		return Retrieval{}, fmt.Errorf("saving new partial retrieval config: %s", err)
	}
	return retrievalRequestToRetrieval(rr), nil
}

// GetRetrieval returns information from a Retrieval using its ID.
func (i *API) GetRetrieval(prID ffs.RetrievalID) (Retrieval, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	rr, err := i.is.getRetrievalRequest(prID)
	if err == ErrNotFound {
		return Retrieval{}, err
	}
	if err != nil {
		return Retrieval{}, fmt.Errorf("getting retrieval request from store: %s", err)
	}
	r := retrievalRequestToRetrieval(rr)
	ri, err := i.sched.GetRetrievalInfo(r.ID)
	if err != nil {
		return Retrieval{}, fmt.Errorf("getting retrieval info: %s", err)
	}
	r.RetrievalMiner = ri.MinerAddr
	r.DataCid = ri.DataCid

	return r, nil
}

// RemoveRetrieval removes information and data from a executed retrieval.
func (i *API) RemoveRetrieval(partialCid cid.Cid) error {
	i.lock.Lock()
	defer i.lock.Unlock()

	// ToDo:
	// Check retrieval exists
	// Check retrieval ID was done by this API
	// Remove from scheduler (reference counting)
	// Remove from instance-store

	return nil
}

func retrievalRequestToRetrieval(rr retrievalRequest) Retrieval {
	return Retrieval{
		ID:            rr.ID,
		PayloadCid:    rr.PayloadCid,
		PieceCid:      rr.PieceCid,
		Selector:      rr.Selector,
		Miners:        rr.Miners,
		WalletAddress: rr.WalletAddress,
		MaxPrice:      rr.MaxPrice,
		JID:           rr.JID,
		CreatedAt:     rr.CreatedAt,
	}
}

'''
'''--- Filecoin/powergate/ffs/api/api_storageinfo.go ---
package api

import (
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler"
)

// StorageInfo returns the information about a stored Cid. If no information is available,
// since the Cid was never stored, it returns ErrNotFound.
func (i *API) StorageInfo(cid cid.Cid) (ffs.StorageInfo, error) {
	inf, err := i.sched.GetStorageInfo(i.cfg.ID, cid)
	if err == scheduler.ErrNotFound {
		return inf, ErrNotFound
	}
	if err != nil {
		return inf, fmt.Errorf("getting cid storage info: %s", err)
	}
	return inf, nil
}

// ListStorageInfo returns a list of information about all stored cids, filtered by cids if provided.
func (i *API) ListStorageInfo(cids ...cid.Cid) ([]ffs.StorageInfo, error) {
	return i.sched.ListStorageInfo([]ffs.APIID{i.cfg.ID}, cids)
}

'''
'''--- Filecoin/powergate/ffs/api/api_wallet.go ---
package api

import (
	"context"
	"fmt"
	"math/big"

	"github.com/ipfs/go-cid"
)

// Addrs returns the wallet addresses.
func (i *API) Addrs() []AddrInfo {
	i.lock.Lock()
	defer i.lock.Unlock()
	var addrs []AddrInfo
	for _, addr := range i.cfg.Addrs {
		addrs = append(addrs, addr)
	}
	return addrs
}

// NewAddr creates a new address managed by the FFS instance.
func (i *API) NewAddr(ctx context.Context, name string, options ...NewAddressOption) (string, error) {
	i.lock.Lock()
	defer i.lock.Unlock()

	conf := &NewAddressConfig{
		makeDefault: false,
		addressType: "bls",
	}
	for _, option := range options {
		option(conf)
	}

	exists := false
	for _, addr := range i.cfg.Addrs {
		if addr.Name == name {
			exists = true
			break
		}
	}

	if exists {
		return "", fmt.Errorf("address with name %s already exists", name)
	}

	addr, err := i.wm.NewAddress(ctx, conf.addressType)
	if err != nil {
		return "", fmt.Errorf("creating new wallet addr: %s", err)
	}
	i.cfg.Addrs[addr] = AddrInfo{
		Name: name,
		Addr: addr,
		Type: conf.addressType,
	}
	if conf.makeDefault {
		i.cfg.DefaultStorageConfig.Cold.Filecoin.Addr = addr
	}
	if err := i.is.putInstanceConfig(i.cfg); err != nil {
		return "", err
	}
	return addr, nil
}

// SignMessage signs a message using a managed address.
func (i *API) SignMessage(ctx context.Context, addr string, message []byte) ([]byte, error) {
	if !i.isManagedAddress(addr) {
		return nil, fmt.Errorf("%v is not managed by ffs instance", addr)
	}
	res, err := i.wm.Sign(ctx, addr, message)
	if err != nil {
		return nil, fmt.Errorf("signing message: %s", err)
	}
	return res, nil
}

// VerifyMessage verifies a message signature of a message from a managed address.
func (i *API) VerifyMessage(ctx context.Context, addr string, message, signature []byte) (bool, error) {
	ok, err := i.wm.Verify(ctx, addr, message, signature)
	if err != nil {
		return false, fmt.Errorf("signing message: %s", err)
	}
	return ok, nil
}

// SendFil sends fil from a managed address to any another address, returns immediately but funds are sent asynchronously.
func (i *API) SendFil(ctx context.Context, from string, to string, amount *big.Int) (cid.Cid, error) {
	if !i.isManagedAddress(from) {
		return cid.Cid{}, fmt.Errorf("%v is not managed by ffs instance", from)
	}
	return i.wm.SendFil(ctx, from, to, amount)
}

func (i *API) isManagedAddress(addr string) bool {
	for managedAddr := range i.cfg.Addrs {
		if managedAddr == addr {
			return true
		}
	}
	return false
}

'''
'''--- Filecoin/powergate/ffs/api/istore.go ---
package api

import (
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

var (
	dsInstanceConfig       = datastore.NewKey("instanceconfig")
	dsBaseCidStorageConfig = datastore.NewKey("cidstorageconfig")
	dsBaseRetrievalRequest = datastore.NewKey("retrievalrequest")
)

type instanceStore struct {
	lock sync.Mutex
	ds   datastore.Datastore
}

func newInstanceStore(ds datastore.Datastore) *instanceStore {
	return &instanceStore{
		ds: ds,
	}
}

// putInstanceConfig saves general instance configuration configuration, such as
// default wallet address, default storage config, etc.
func (s *instanceStore) putInstanceConfig(c InstanceConfig) error {
	buf, err := json.Marshal(c)
	if err != nil {
		return fmt.Errorf("marshaling instance config to datastore: %s", err)
	}
	if err := s.ds.Put(dsInstanceConfig, buf); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}
	return nil
}

// getInstanceConfig returns general instance configurations, such as default wallet address,
// default storage config, etc.
func (s *instanceStore) getInstanceConfig() (InstanceConfig, error) {
	buf, err := s.ds.Get(dsInstanceConfig)
	if err != nil {
		if err == datastore.ErrNotFound {
			return InstanceConfig{}, ErrNotFound
		}
		return InstanceConfig{}, fmt.Errorf("getting instance config from datastore: %s", err)
	}
	var c InstanceConfig
	if err := json.Unmarshal(buf, &c); err != nil {
		return InstanceConfig{}, fmt.Errorf("unmarshaling config from datastore: %s", err)
	}
	return c, nil
}

func (s *instanceStore) putStorageConfig(c cid.Cid, sc ffs.StorageConfig) error {
	if !c.Defined() {
		return fmt.Errorf("cid can't be undefined")
	}
	buf, err := json.Marshal(sc)
	if err != nil {
		return fmt.Errorf("marshaling cid config to datastore: %s", err)
	}
	if err := s.ds.Put(makeStorageConfigKey(c), buf); err != nil {
		return fmt.Errorf("saving cid config to datastore: %s", err)
	}
	return nil
}

func (s *instanceStore) removeStorageConfig(c cid.Cid) error {
	if !c.Defined() {
		return fmt.Errorf("cid can't be undefined")
	}
	if err := s.ds.Delete(makeStorageConfigKey(c)); err != nil {
		return fmt.Errorf("removing from datastore: %s", err)
	}
	return nil
}

func (s *instanceStore) getStorageConfigs(cids ...cid.Cid) (map[cid.Cid]ffs.StorageConfig, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	filter := make(map[cid.Cid]struct{})
	for _, cid := range cids {
		filter[cid] = struct{}{}
	}

	rawRes := make(map[cid.Cid][]byte)

	if len(cids) == 1 {
		// just getting a single value, do an explicit query for it
		buf, err := s.ds.Get(makeStorageConfigKey(cids[0]))
		if err != nil {
			if err == datastore.ErrNotFound {
				return nil, ErrNotFound
			}
			return nil, err
		}
		rawRes[cids[0]] = buf
	} else {
		// getting many or all values, so we have to query everything
		q := query.Query{
			Prefix: dsBaseCidStorageConfig.String(),
		}
		res, err := s.ds.Query(q)
		if err != nil {
			return nil, err
		}
		defer func() {
			if err := res.Close(); err != nil {
				log.Errorf("closing query result: %s", err)
			}
		}()
		for r := range res.Next() {
			if r.Error != nil {
				return nil, fmt.Errorf("iter next: %s", r.Error)
			}
			strCid := datastore.RawKey(r.Key).Name()
			c, err := util.CidFromString(strCid)
			if err != nil {
				return nil, fmt.Errorf("decoding cid: %s", err)
			}
			if len(filter) > 0 {
				// we have a filter, check it
				if _, ok := filter[c]; ok {
					rawRes[c] = r.Value
				}
			} else {
				// no filter, include everything
				rawRes[c] = r.Value
			}
		}
	}

	res := make(map[cid.Cid]ffs.StorageConfig, len(rawRes))
	for cid, buf := range rawRes {
		if buf == nil {
			// one of the provided filter cids wasn't found
			return nil, ErrNotFound
		}
		var conf ffs.StorageConfig
		if err := json.Unmarshal(buf, &conf); err != nil {
			return nil, fmt.Errorf("unmarshaling cid config from datastore: %s", err)
		}
		res[cid] = conf
	}

	return res, nil
}

func makeStorageConfigKey(c cid.Cid) datastore.Key {
	return dsBaseCidStorageConfig.ChildString(util.CidToString(c))
}

type retrievalRequest struct {
	ID            ffs.RetrievalID
	PayloadCid    cid.Cid
	PieceCid      cid.Cid
	Selector      string
	Miners        []string
	WalletAddress string
	MaxPrice      uint64
	JID           ffs.JobID
	CreatedAt     time.Time
}

func (s *instanceStore) putRetrievalRequest(rID ffs.RetrievalID, pyCid, piCid cid.Cid, selector string, miners []string, walletAddress string, maxPrice uint64, jid ffs.JobID) (retrievalRequest, error) {
	rr := retrievalRequest{
		ID:            rID,
		PayloadCid:    pyCid,
		PieceCid:      piCid,
		Selector:      selector,
		Miners:        miners,
		WalletAddress: walletAddress,
		MaxPrice:      maxPrice,
		JID:           jid,
		CreatedAt:     time.Now(),
	}
	buf, err := json.Marshal(rr)
	if err != nil {
		return retrievalRequest{}, fmt.Errorf("marshaling retrieval request for datastore: %s", err)
	}
	if err := s.ds.Put(makeRetrievalRequestKey(rID), buf); err != nil {
		return retrievalRequest{}, fmt.Errorf("saving cid config to datastore: %s", err)
	}
	return rr, nil
}

func (s *instanceStore) getRetrievalRequest(rid ffs.RetrievalID) (retrievalRequest, error) {
	buf, err := s.ds.Get(makeRetrievalRequestKey(rid))
	if err != nil {
		if err == datastore.ErrNotFound {
			return retrievalRequest{}, ErrNotFound
		}
		return retrievalRequest{}, fmt.Errorf("getting retrieval request from datastore: %s", err)
	}
	var rr retrievalRequest
	if err := json.Unmarshal(buf, &rr); err != nil {
		return retrievalRequest{}, fmt.Errorf("unmarshaling retrieval request from datastore: %s", err)
	}
	return rr, nil
}

func makeRetrievalRequestKey(rid ffs.RetrievalID) datastore.Key {
	return dsBaseRetrievalRequest.ChildString(rid.String())
}

'''
'''--- Filecoin/powergate/ffs/api/option.go ---
package api

import (
	"fmt"

	"github.com/textileio/powergate/v2/ffs"
)

// PushStorageConfigOption mutates a push configuration.
type PushStorageConfigOption func(o *pushStorageConfigConfig) error

type pushStorageConfigConfig struct {
	config         ffs.StorageConfig
	overrideConfig bool
	dealIDs        []uint64
	noExec         bool
}

// WithStorageConfig overrides the Api default Cid configuration.
func WithStorageConfig(c ffs.StorageConfig) PushStorageConfigOption {
	return func(o *pushStorageConfigConfig) error {
		o.config = c
		return nil
	}
}

// WithOverride allows a new push configuration to override an existing one.
// It's used as an extra security measure to avoid unwanted configuration changes.
func WithOverride(override bool) PushStorageConfigOption {
	return func(o *pushStorageConfigConfig) error {
		o.overrideConfig = override
		return nil
	}
}

// WithDealImport provides active deals to create/augment the storage info
// of the cid.
func WithDealImport(dealIDs []uint64) PushStorageConfigOption {
	return func(o *pushStorageConfigConfig) error {
		o.dealIDs = dealIDs
		return nil
	}
}

// WithNoExec avoids creating a Job for the new configuration.
func WithNoExec(noExec bool) PushStorageConfigOption {
	return func(o *pushStorageConfigConfig) error {
		o.noExec = noExec
		return nil
	}
}

// Validate validates a PushStorageConfigConfig.
func (pc pushStorageConfigConfig) Validate() error {
	if err := pc.config.Validate(); err != nil {
		return fmt.Errorf("invalid config: %s", err)
	}
	return nil
}

// NewAddressOption is a function that changes a NewAddressConfig.
type NewAddressOption func(config *NewAddressConfig)

// WithMakeDefault specifies if the new address should become the default.
func WithMakeDefault(makeDefault bool) NewAddressOption {
	return func(c *NewAddressConfig) {
		c.makeDefault = makeDefault
	}
}

// WithAddressType specifies the type of address to create.
func WithAddressType(addressType string) NewAddressOption {
	return func(c *NewAddressConfig) {
		c.addressType = addressType
	}
}

// GetLogsOption is a function that changes GetLogsConfig.
type GetLogsOption func(config *GetLogsConfig)

// WithJidFilter filters only log messages of a Cid related to
// the Job with id jid.
func WithJidFilter(jid ffs.JobID) GetLogsOption {
	return func(c *GetLogsConfig) {
		c.jid = jid
	}
}

// WithHistory indicates that prior log history should be sent
// to the channel before getting realtime logs.
func WithHistory(enabled bool) GetLogsOption {
	return func(c *GetLogsConfig) {
		c.history = enabled
	}
}

// RetrievalOption provides a retrieval configuration setup.
type RetrievalOption func(*retrievalConfig)

// WithRetrievalWalletAddress indicates which wallet address to use
// for doing the deal retrieval.
func WithRetrievalWalletAddress(addr string) RetrievalOption {
	return func(prc *retrievalConfig) {
		prc.walletAddress = addr
	}
}

// WithRetrievalMaxPrice indicates which is the maximum prices
// to pay for the retrieval.
func WithRetrievalMaxPrice(maxPrice uint64) RetrievalOption {
	return func(prc *retrievalConfig) {
		prc.maxPrice = maxPrice
	}
}

'''
'''--- Filecoin/powergate/ffs/api/types.go ---
package api

import (
	"errors"

	"github.com/textileio/powergate/v2/ffs"
)

var (
	// ErrNotFound returned when instance configuration doesn't exist.
	ErrNotFound = errors.New("stored item not found")
)

// InstanceConfig has general information about a Api instance.
type InstanceConfig struct {
	ID                   ffs.APIID
	Addrs                map[string]AddrInfo
	DefaultStorageConfig ffs.StorageConfig
}

// AddrInfo provides information about a wallet address.
type AddrInfo struct {
	Name string
	Addr string
	Type string
}

// NewAddressConfig contains options for creating a new wallet address.
type NewAddressConfig struct {
	makeDefault bool
	addressType string
}

// GetLogsConfig contains configuration for a stream-log
// of human-friendly messages for a Cid execution.
type GetLogsConfig struct {
	jid     ffs.JobID
	history bool
}

'''
'''--- Filecoin/powergate/ffs/auth/auth.go ---
package auth

import (
	"encoding/json"
	"errors"
	"fmt"
	"sync"

	"github.com/google/uuid"
	ds "github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
)

var (
	// ErrNotFound indicates that the auth-token isn't registered.
	ErrNotFound = errors.New("auth token not found")

	log = logging.Logger("ffs-auth")
)

// Auth contains a mapping between auth-tokens and Api instances.
type Auth struct {
	lock sync.Mutex
	ds   ds.TxnDatastore
}

// New returns a new Auth.
func New(store ds.TxnDatastore) *Auth {
	return &Auth{
		ds: store,
	}
}

// Generate generates a new returned auth-token mapped to the iid.
func (r *Auth) Generate(iid ffs.APIID) (string, error) {
	log.Infof("generating auth-token for instance %s", iid)
	r.lock.Lock()
	defer r.lock.Unlock()
	e := ffs.AuthEntry{
		Token: uuid.New().String(),
		APIID: iid,
	}
	buf, err := json.Marshal(&e)
	if err != nil {
		return "", fmt.Errorf("marshaling new auth token for instance %s: %s", iid, err)
	}
	if err := r.ds.Put(ds.NewKey(e.Token), buf); err != nil {
		return "", fmt.Errorf("saving generated token from %s to datastore: %s", iid, err)
	}
	return e.Token, nil
}

// Get returns the InstanceID associated with token.
// It returns ErrNotFound if there isn't such.
func (r *Auth) Get(token string) (ffs.APIID, error) {
	r.lock.Lock()
	defer r.lock.Unlock()

	buf, err := r.ds.Get(ds.NewKey(token))
	if err != nil && err == ds.ErrNotFound {
		return ffs.EmptyInstanceID, ErrNotFound
	}
	if err != nil {
		return ffs.EmptyInstanceID, fmt.Errorf("getting token %s from datastore: %s", token, err)
	}
	var e ffs.AuthEntry
	if err := json.Unmarshal(buf, &e); err != nil {
		return ffs.EmptyInstanceID, fmt.Errorf("unmarshaling %s information from datastore: %s", token, err)
	}
	return e.APIID, nil
}

// RegenerateAuthToken invalidates a token regenerating a new one.
func (r *Auth) RegenerateAuthToken(token string) (string, error) {
	r.lock.Lock()
	defer r.lock.Unlock()

	txn, err := r.ds.NewTransaction(false)
	if err != nil {
		return "", fmt.Errorf("creating transaction: %s", err)
	}
	defer txn.Discard()

	buf, err := txn.Get(ds.NewKey(token))
	if err != nil && err == ds.ErrNotFound {
		return "", ErrNotFound
	}
	if err != nil {
		return "", fmt.Errorf("getting token %s from datastore: %s", token, err)
	}
	var e ffs.AuthEntry
	if err := json.Unmarshal(buf, &e); err != nil {
		return "", fmt.Errorf("unmarshaling %s information from datastore: %s", token, err)
	}

	// Delete old token.
	if err := txn.Delete(ds.NewKey(token)); err != nil {
		return "", fmt.Errorf("deleting old token: %s", err)
	}

	// Set new token
	e.Token = uuid.New().String()
	buf, err = json.Marshal(&e)
	if err != nil {
		return "", fmt.Errorf("marshaling new regenerated token: %s", err)
	}
	if err := txn.Put(ds.NewKey(e.Token), buf); err != nil {
		return "", fmt.Errorf("saving regenerated token: %s", err)
	}

	if err := txn.Commit(); err != nil {
		return "", fmt.Errorf("committing transaction: %s", err)
	}

	return e.Token, nil
}

// List returns a list of all API instances.
func (r *Auth) List() ([]ffs.AuthEntry, error) {
	r.lock.Lock()
	defer r.lock.Unlock()
	q := query.Query{Prefix: ""}
	res, err := r.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query in datastore: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()

	var ret []ffs.AuthEntry
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var e ffs.AuthEntry
		if err := json.Unmarshal(r.Entry.Value, &e); err != nil {
			return nil, fmt.Errorf("unmarshaling query result: %s", err)
		}
		ret = append(ret, e)
	}
	return ret, nil
}

'''
'''--- Filecoin/powergate/ffs/coreipfs/coreipfs.go ---
package coreipfs

import (
	"context"
	"errors"
	"fmt"
	"io"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	ipfsfiles "github.com/ipfs/go-ipfs-files"
	logging "github.com/ipfs/go-log/v2"
	iface "github.com/ipfs/interface-go-ipfs-core"
	"github.com/ipfs/interface-go-ipfs-core/options"
	"github.com/ipfs/interface-go-ipfs-core/path"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/coreipfs/internal/pinstore"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
)

var (
	log = logging.Logger("ffs-coreipfs")

	// ErrUnpinnedCid indicates that the operation failed because
	// the provided cid is unpinned.
	ErrUnpinnedCid = errors.New("can't unpin an unpinned cid")
	// ErrReplaceFromNotPinned indicates that the source cid to be replaced
	// isn't pinned.
	ErrReplaceFromNotPinned = errors.New("c1 isn't pinned")
)

// CoreIpfs is an implementation of HotStorage interface which saves data
// into a remote go-ipfs using the HTTP API.
type CoreIpfs struct {
	ipfs iface.CoreAPI
	ps   *pinstore.Store

	lock sync.Mutex
}

var _ ffs.HotStorage = (*CoreIpfs)(nil)

// New returns a new CoreIpfs instance.
func New(ds datastore.TxnDatastore, ipfs iface.CoreAPI, l ffs.JobLogger) (*CoreIpfs, error) {
	ps, err := pinstore.New(txndstr.Wrap(ds, "pinstore"))
	if err != nil {
		return nil, fmt.Errorf("loading pinstore: %s", err)
	}
	ci := &CoreIpfs{
		ipfs: ipfs,
		ps:   ps,
	}
	return ci, nil
}

// Stage adds the data of io.Reader in the storage, and creates a stage-pin on the resulting cid.
func (ci *CoreIpfs) Stage(ctx context.Context, iid ffs.APIID, r io.Reader) (cid.Cid, error) {
	p, err := ci.ipfs.Unixfs().Add(ctx, ipfsfiles.NewReaderFile(r), options.Unixfs.Pin(true))
	if err != nil {
		return cid.Undef, fmt.Errorf("adding data to ipfs: %s", err)
	}
	ci.lock.Lock()
	defer ci.lock.Unlock()

	if err := ci.ps.AddStaged(iid, p.Cid()); err != nil {
		return cid.Undef, fmt.Errorf("saving new pin in pinstore: %s", err)
	}

	return p.Cid(), nil
}

// StageCid pull the Cid data and stage-pin it.
func (ci *CoreIpfs) StageCid(ctx context.Context, iid ffs.APIID, c cid.Cid) error {
	if err := ci.ipfs.Pin().Add(ctx, path.IpfsPath(c), options.Pin.Recursive(true)); err != nil {
		return fmt.Errorf("adding data to ipfs: %s", err)
	}
	ci.lock.Lock()
	defer ci.lock.Unlock()

	if err := ci.ps.AddStaged(iid, c); err != nil {
		return fmt.Errorf("saving new pin in pinstore: %s", err)
	}

	return nil
}

// Get retrieves a cid data from the IPFS node.
func (ci *CoreIpfs) Get(ctx context.Context, c cid.Cid) (io.Reader, error) {
	n, err := ci.ipfs.Unixfs().Get(ctx, path.IpfsPath(c))
	if err != nil {
		return nil, fmt.Errorf("getting cid %s from ipfs: %s", c, err)
	}
	file := ipfsfiles.ToFile(n)
	if file == nil {
		return nil, fmt.Errorf("node is a directory")
	}
	return file, nil
}

// Pin a cid for an APIID. If the cid was already pinned by a stage from APIID,
// the Cid is considered fully-pinned and not a candidate to be unpinned by GCStaged().
func (ci *CoreIpfs) Pin(ctx context.Context, iid ffs.APIID, c cid.Cid) (int, error) {
	ci.lock.Lock()
	defer ci.lock.Unlock()

	p := path.IpfsPath(c)

	// If some APIID already pinned this Cid in the underlying go-ipfs node, then
	// we don't need to call the Pin API, just count the reference from this APIID.
	if !ci.ps.IsPinned(c) {
		if err := ci.ipfs.Pin().Add(ctx, p, options.Pin.Recursive(true)); err != nil {
			return 0, fmt.Errorf("pinning cid %s: %s", c, err)
		}
	}
	s, err := ci.ipfs.Object().Stat(ctx, p)
	if err != nil {
		return 0, fmt.Errorf("getting stats of cid %s: %s", c, err)
	}

	// Count +1 reference to this Cid by APIID.
	if err := ci.ps.Add(iid, p.Cid()); err != nil {
		return 0, fmt.Errorf("saving new pin in pinstore: %s", err)
	}

	return s.CumulativeSize, nil
}

// Unpin unpins a Cid for an APIID. If the Cid isn't pinned, it returns ErrUnpinnedCid.
func (ci *CoreIpfs) Unpin(ctx context.Context, iid ffs.APIID, c cid.Cid) error {
	ci.lock.Lock()
	defer ci.lock.Unlock()

	return ci.removeAndUnpinIfApplies(ctx, iid, c)
}

// Replace moves the pin from c1 to c2. If c2 was already pinned from a stage,
// it's considered fully-pinned and not GCable.
func (ci *CoreIpfs) Replace(ctx context.Context, iid ffs.APIID, c1 cid.Cid, c2 cid.Cid) (int, error) {
	ci.lock.Lock()
	defer ci.lock.Unlock()

	p1 := path.IpfsPath(c1)
	p2 := path.IpfsPath(c2)

	c1refcount, _ := ci.ps.RefCount(c1)
	c2refcount, _ := ci.ps.RefCount(c2)

	if c1refcount == 0 {
		return 0, ErrReplaceFromNotPinned
	}

	// If c1 has a single reference, which must be from iid...
	if c1refcount == 1 {
		// If c2 isn't pinned, then we can move the pin so to unpin c1 and pin c2.
		if c2refcount == 0 {
			if err := ci.ipfs.Pin().Update(ctx, p1, p2); err != nil {
				return 0, fmt.Errorf("updating pin %s to %s: %s", c1, c2, err)
			}
		} else { // If c2 is pinned, then we need to unpin c1 (c2 is already pinned by other iid).
			if err := ci.ipfs.Pin().Rm(ctx, path.IpfsPath(c1), options.Pin.RmRecursive(true)); err != nil {
				return 0, fmt.Errorf("unpinning cid from ipfs node: %s", err)
			}
		}
	} else if c2refcount == 0 {
		// - c1 is pinned by another iid, so we can't unpin it.
		// - c2 isn't pinned by anyone, so we should pin it.
		if err := ci.ipfs.Pin().Add(ctx, p2, options.Pin.Recursive(true)); err != nil {
			return 0, fmt.Errorf("pinning cid %s: %s", c2, err)
		}
	}
	// If none of the if branches applied:
	// - c1 is pinned by another iid, so we can't unpin it.
	// - c2 is pinned by some other iid, so it's already pinned in the node, no need to do it.

	// In any case of above if, update the ref counts.
	if err := ci.ps.Remove(iid, c1); err != nil {
		return 0, fmt.Errorf("removing cid in pinstore: %s", err)
	}
	if err := ci.ps.Add(iid, c2); err != nil {
		return 0, fmt.Errorf("adding cid in pinstore: %s", err)
	}

	stat, err := ci.ipfs.Object().Stat(ctx, p2)
	if err != nil {
		return 0, fmt.Errorf("getting stats of cid %s: %s", c2, err)
	}

	return stat.CumulativeSize, nil
}

// IsPinned returns true if c is pinned by iid.
func (ci *CoreIpfs) IsPinned(ctx context.Context, iid ffs.APIID, c cid.Cid) (bool, error) {
	return ci.ps.IsPinnedBy(iid, c), nil
}

// GCStaged unpins Cids that are only pinned by Stage() calls and all pins satisfy the filters.
func (ci *CoreIpfs) GCStaged(ctx context.Context, exclude []cid.Cid, olderThan time.Time) ([]cid.Cid, error) {
	ci.lock.Lock()
	defer ci.lock.Unlock()

	unpinLst, err := ci.getGCCandidates(exclude, olderThan)
	if err != nil {
		return nil, fmt.Errorf("getting gc cid candidates: %s", err)
	}

	for _, c := range unpinLst {
		if err := ci.unpinStaged(ctx, c); err != nil {
			return nil, fmt.Errorf("unpinning cid from ipfs node: %s", err)
		}
	}

	return unpinLst, nil
}

// PinnedCids return detailed information about pinned cids.
func (ci *CoreIpfs) PinnedCids(ctx context.Context) ([]ffs.PinnedCid, error) {
	ci.lock.Lock()
	defer ci.lock.Unlock()

	ps, err := ci.ps.GetAll()
	if err != nil {
		return nil, fmt.Errorf("getting pins from pinstore: %s", err)
	}

	res := make([]ffs.PinnedCid, len(ps))
	for i, pc := range ps {
		npc := ffs.PinnedCid{
			Cid:    pc.Cid,
			APIIDs: make([]ffs.APIIDPinnedCid, len(pc.Pins)),
		}
		for j, upc := range pc.Pins {
			npc.APIIDs[j] = ffs.APIIDPinnedCid{
				ID:        upc.APIID,
				Staged:    upc.Staged,
				CreatedAt: upc.CreatedAt,
			}
		}
		res[i] = npc
	}

	return res, nil
}

func (ci *CoreIpfs) getGCCandidates(exclude []cid.Cid, olderThan time.Time) ([]cid.Cid, error) {
	lst, err := ci.ps.GetAllOnlyStaged()
	if err != nil {
		return nil, fmt.Errorf("get staged pins: %s", err)
	}

	excludeMap := map[cid.Cid]struct{}{}
	for _, c := range exclude {
		excludeMap[c] = struct{}{}
	}

	var unpinList []cid.Cid
Loop:
	for _, stagedPin := range lst {
		// Double check that ref count is consistent.
		total, staged := ci.ps.RefCount(stagedPin.Cid)
		if total != staged {
			return nil, fmt.Errorf("GC candidates are inconsistent")
		}

		// Skip Cids that are excluded.
		if _, ok := excludeMap[stagedPin.Cid]; ok {
			log.Infof("skipping staged cid %s since it's in exclusion list", stagedPin.Cid)
			continue Loop
		}
		// A Cid is only safe to GC if all existing stage-pin are older than
		// specified parameter. If any iid stage-pined the Cid more recently than olderThan
		// we still have to wait a bit more to consider it for GC.
		for _, sp := range stagedPin.Pins {
			if sp.CreatedAt > olderThan.Unix() {
				continue Loop
			}
		}

		// The Cid only has staged-pins, and all iids that staged it aren't in exclusion list
		// plus are older than olderThan ==> Safe to GCed.
		unpinList = append(unpinList, stagedPin.Cid)
	}

	return unpinList, nil
}

func (ci *CoreIpfs) removeAndUnpinIfApplies(ctx context.Context, iid ffs.APIID, c cid.Cid) error {
	count, _ := ci.ps.RefCount(c)
	if count == 0 {
		return ErrUnpinnedCid
	}

	if count == 1 {
		// There aren't more pinnings for this Cid, let's unpin from IPFS.
		log.Infof("unpinning cid %s with ref count 0", c)
		if err := ci.ipfs.Pin().Rm(ctx, path.IpfsPath(c), options.Pin.RmRecursive(true)); err != nil {
			return fmt.Errorf("unpinning cid from ipfs node: %s", err)
		}
	}

	if err := ci.ps.Remove(iid, c); err != nil {
		return fmt.Errorf("removing cid from pinstore: %s", err)
	}

	return nil
}

func (ci *CoreIpfs) unpinStaged(ctx context.Context, c cid.Cid) error {
	count, stagedCount := ci.ps.RefCount(c)

	// Just in case, verify that the total number of pins are equal
	// to stage-pins. That is, nobody is pinning this Cid apart from Stage() calls.
	if count != stagedCount {
		return fmt.Errorf("cid %s hasn't only stage-pins, total %d staged %d", c, count, stagedCount)
	}

	if err := ci.ipfs.Pin().Rm(ctx, path.IpfsPath(c), options.Pin.RmRecursive(true)); err != nil {
		return fmt.Errorf("unpinning cid from ipfs node: %s", err)
	}

	if err := ci.ps.RemoveStaged(c); err != nil {
		return fmt.Errorf("removing all staged pins for %s: %s", c, err)
	}

	return nil
}

'''
'''--- Filecoin/powergate/ffs/coreipfs/coreipfs_test.go ---
package coreipfs

import (
	"bytes"
	"context"
	"math/rand"
	"sort"
	"testing"
	"time"

	"github.com/ipfs/go-cid"
	ipfsfiles "github.com/ipfs/go-ipfs-files"
	httpapi "github.com/ipfs/go-ipfs-http-client"
	"github.com/ipfs/interface-go-ipfs-core/options"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	"github.com/textileio/powergate/v2/ffs/joblogger"
	"github.com/textileio/powergate/v2/tests"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
)

func TestStage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	iid := ffs.NewAPIID()

	c, err := ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err := ci.IsPinned(ctx, iid, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 1)

	// Re-stage and test ref count is stil 1.
	c, err = ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	requireRefCount(t, ci, c, 0, 1)
}

func TestStageCid(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	// Add as if the Powergate client uses the proxy
	p, err := ci.ipfs.Unixfs().Add(ctx, ipfsfiles.NewReaderFile(bytes.NewReader(data)), options.Unixfs.Pin(true))
	require.NoError(t, err)
	iid := ffs.NewAPIID()
	c := p.Cid()

	err = ci.StageCid(ctx, iid, c)
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err := ci.IsPinned(ctx, iid, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 1)

	// Re-stage and test ref count is stil 1.
	c, err = ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	requireRefCount(t, ci, c, 0, 1)
}

func TestStagePinStage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	iid := ffs.NewAPIID()

	// Stage
	c, err := ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	requireRefCount(t, ci, c, 0, 1)

	// Pin that Cid.
	_, err = ci.Pin(ctx, iid, c)
	require.NoError(t, err)
	requireRefCount(t, ci, c, 1, 0)

	// Stage again, it shouldn't be GCable.
	c2, err := ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	require.Equal(t, c, c2)
	it.RequireIpfsPinnedCid(ctx, t, c2, ipfs)
	requireCidIsNotGCable(t, ci, c2)
	okPinned, err := ci.IsPinned(ctx, iid, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 1, 0)
}

func TestPinAndRePin(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	iid := ffs.NewAPIID()

	rd := ipfsfiles.NewReaderFile(bytes.NewReader(data))
	p, err := ipfs.Unixfs().Add(ctx, rd, options.Unixfs.Pin(false))
	require.NoError(t, err)
	c := p.Cid()

	size, err := ci.Pin(ctx, iid, c)
	require.NoError(t, err)
	require.Greater(t, size, 0)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsNotGCable(t, ci, c)
	okPinned, err := ci.IsPinned(ctx, iid, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 1, 0)

	// Pin again, check that ref count is still 1.
	_, err = ci.Pin(ctx, iid, c)
	require.NoError(t, err)
	requireRefCount(t, ci, c, 1, 0)
}

func TestUnpin(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	iid := ffs.NewAPIID()

	rd := ipfsfiles.NewReaderFile(bytes.NewReader(data))
	p, err := ipfs.Unixfs().Add(ctx, rd, options.Unixfs.Pin(false))
	require.NoError(t, err)
	c := p.Cid()

	// Test unpin an unpinned cid.
	err = ci.Unpin(ctx, iid, c)
	require.Equal(t, ErrUnpinnedCid, err)

	// Test pin and unpin.
	requireRefCount(t, ci, c, 0, 0)
	_, err = ci.Pin(ctx, iid, c)
	require.NoError(t, err)

	err = ci.Unpin(ctx, iid, c)
	require.NoError(t, err)
	requireRefCount(t, ci, c, 0, 0)

	// Test unpin an unpinned cid again.
	err = ci.Unpin(ctx, iid, c)
	require.Equal(t, ErrUnpinnedCid, err)
}

func TestReplaceThatUnpinAndPin(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	iid := ffs.NewAPIID()

	// Pin c1
	data := it.RandomBytes(r, 1500)
	c1, err := ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	_, err = ci.Pin(ctx, iid, c1)
	require.NoError(t, err)
	requireRefCount(t, ci, c1, 1, 0)

	// Stage c2
	data2 := it.RandomBytes(r, 1500)
	c2, err := ci.Stage(ctx, iid, bytes.NewReader(data2))
	require.NoError(t, err)
	requireRefCount(t, ci, c2, 0, 1)

	// Replace
	size, err := ci.Replace(ctx, iid, c1, c2)
	require.NoError(t, err)
	require.Greater(t, size, 0)

	// Post checks
	it.RequireIpfsUnpinnedCid(ctx, t, c1, ipfs) // c1 unpinned in node.
	it.RequireIpfsPinnedCid(ctx, t, c2, ipfs)   // c2 pinned in node.

	okPinned, err := ci.IsPinned(ctx, iid, c1)
	require.NoError(t, err)
	require.False(t, okPinned) // API claims c1 is unpinned.
	okPinned, err = ci.IsPinned(ctx, iid, c2)
	require.NoError(t, err)
	require.True(t, okPinned) // API claims c2 is unpinned.

	requireRefCount(t, ci, c1, 0, 0) // c1 ref count all 0.
	requireRefCount(t, ci, c2, 1, 0) // c2 from staged to strong.
}

func TestReplaceNotUnpinAndPin(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)

	// Pin c1
	iid1 := ffs.NewAPIID()
	data := it.RandomBytes(r, 1500)
	c1, err := ci.Stage(ctx, iid1, bytes.NewReader(data))
	require.NoError(t, err)
	_, err = ci.Pin(ctx, iid1, c1)
	require.NoError(t, err)
	requireRefCount(t, ci, c1, 1, 0)

	// Make another iid pin c1, so can't be unpinned by replace.
	iid2 := ffs.NewAPIID()
	_, err = ci.Pin(ctx, iid2, c1)
	require.NoError(t, err)
	requireRefCount(t, ci, c1, 2, 0)

	// Stage data2
	data2 := it.RandomBytes(r, 1500)
	c2, err := ci.Stage(ctx, iid1, bytes.NewReader(data2))
	require.NoError(t, err)
	requireRefCount(t, ci, c2, 0, 1)

	// Replace
	size, err := ci.Replace(ctx, iid1, c1, c2)
	require.NoError(t, err)
	require.Greater(t, size, 0)

	// Post checks
	it.RequireIpfsPinnedCid(ctx, t, c1, ipfs) // c1 still pinned in node, since used by iid2.
	it.RequireIpfsPinnedCid(ctx, t, c2, ipfs) // c2 pinned in node.

	okPinned, err := ci.IsPinned(ctx, iid1, c1)
	require.NoError(t, err)
	require.False(t, okPinned) // API claims c1 unpinned in iid1.
	okPinned, err = ci.IsPinned(ctx, iid2, c1)
	require.NoError(t, err)
	require.True(t, okPinned) // API claims c1 pinned in iid2.
	okPinned, err = ci.IsPinned(ctx, iid1, c2)
	require.NoError(t, err)
	require.True(t, okPinned) // API claims c2 pinned in iid1.

	requireRefCount(t, ci, c1, 1, 0) // from (2, 0) to (1, 0), only iid2.
	requireRefCount(t, ci, c2, 1, 0) // c2 strong pin by replace.
}

func TestReplaceErrors(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	iid := ffs.NewAPIID()

	// Add directly to IPFS node without pinning
	data := it.RandomBytes(r, 1500)
	rd := ipfsfiles.NewReaderFile(bytes.NewReader(data))
	p, err := ipfs.Unixfs().Add(ctx, rd, options.Unixfs.Pin(false))
	require.NoError(t, err)
	c1 := p.Cid()

	// Stage c2
	data2 := it.RandomBytes(r, 1500)
	c2, err := ci.Stage(ctx, iid, bytes.NewReader(data2))
	require.NoError(t, err)
	requireRefCount(t, ci, c2, 0, 1)

	// Replace
	_, err = ci.Replace(ctx, iid, c1, c2)
	require.Equal(t, ErrReplaceFromNotPinned, err)
	requireRefCount(t, ci, c1, 0, 0)
	requireRefCount(t, ci, c2, 0, 1)
}

// Test pinning a Cid, unpinning it, and Stage it again.
func TestPinUnpinStage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)
	iid := ffs.NewAPIID()

	rd := ipfsfiles.NewReaderFile(bytes.NewReader(data))
	p, err := ipfs.Unixfs().Add(ctx, rd, options.Unixfs.Pin(false))
	require.NoError(t, err)
	c := p.Cid()

	_, err = ci.Pin(ctx, iid, c)
	require.NoError(t, err)
	err = ci.Unpin(ctx, iid, c)
	require.NoError(t, err)
	requireRefCount(t, ci, c, 0, 0)

	// Stage it again and check invariants:
	// must be gcable, is pinned, and should have a staged-pin.
	c, err = ci.Stage(ctx, iid, bytes.NewReader(data))
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err := ci.IsPinned(ctx, iid, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 1)
}

func TestMultipleStage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, ipfs := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)

	// Stage with iid1.
	iid1 := ffs.NewAPIID()
	c, err := ci.Stage(ctx, iid1, bytes.NewReader(data))
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err := ci.IsPinned(ctx, iid1, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 1)

	// Stage with iid1.
	iid2 := ffs.NewAPIID()
	c, err = ci.Stage(ctx, iid2, bytes.NewReader(data))
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err = ci.IsPinned(ctx, iid2, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 2)

	// Stage with iid3.
	iid3 := ffs.NewAPIID()
	c, err = ci.Stage(ctx, iid3, bytes.NewReader(data))
	require.NoError(t, err)
	it.RequireIpfsPinnedCid(ctx, t, c, ipfs)
	requireCidIsGCable(t, ci, c)
	okPinned, err = ci.IsPinned(ctx, iid3, c)
	require.NoError(t, err)
	require.True(t, okPinned)
	requireRefCount(t, ci, c, 0, 3)
}

func TestTwoStageOnePin(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, _ := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)

	// Stage with iid1
	iid1 := ffs.NewAPIID()
	c, err := ci.Stage(ctx, iid1, bytes.NewReader(data))
	require.NoError(t, err)
	require.True(t, c.Defined())

	// Stage with other iid.
	iid2 := ffs.NewAPIID()
	c, err = ci.Stage(ctx, iid2, bytes.NewReader(data))
	require.NoError(t, err)

	requireCidIsGCable(t, ci, c) // Can be GCable

	// Pin with iid1
	_, err = ci.Pin(ctx, iid1, c)
	require.NoError(t, err)
	requireCidIsNotGCable(t, ci, c) // Can't be GCable
	requireRefCount(t, ci, c, 1, 1) // One strong and one staged.

	// Now unpin and check.
	err = ci.Unpin(ctx, iid1, c)
	require.NoError(t, err)
	requireCidIsGCable(t, ci, c)    // Now is GCable again.
	requireRefCount(t, ci, c, 0, 1) // Only iid2 staged.
}

func TestPinnedCids(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	r := rand.New(rand.NewSource(22))

	ci, _ := newCoreIPFS(t)
	data := it.RandomBytes(r, 1500)

	// Stage with iid1
	iid1 := ffs.NewAPIID()
	c1, err := ci.Stage(ctx, iid1, bytes.NewReader(data))
	require.NoError(t, err)

	// Stage with iid2.
	iid2 := ffs.NewAPIID()
	_, err = ci.Stage(ctx, iid2, bytes.NewReader(data))
	require.NoError(t, err)

	// Pin with iid1
	_, err = ci.Pin(ctx, iid1, c1)
	require.NoError(t, err)

	// Stage another cid with iid3.
	data = it.RandomBytes(r, 1500)
	iid3 := ffs.NewAPIID()
	c2, err := ci.Stage(ctx, iid3, bytes.NewReader(data))
	require.NoError(t, err)

	// Get all and check.
	all, err := ci.PinnedCids(ctx)
	require.NoError(t, err)
	require.Len(t, all, 2)

	// Order the slices so we have predictable results
	// for comparing. In position 0 is c2, and 1 is c1.
	sort.Slice(all, func(a, b int) bool {
		return all[a].Cid.String() < all[b].Cid.String()
	})

	// c2 is staged by iid3.
	require.Equal(t, c2, all[0].Cid)
	require.Len(t, all[0].APIIDs, 1)
	require.Equal(t, iid3, all[0].APIIDs[0].ID)
	require.True(t, all[0].APIIDs[0].Staged)

	// c1 is:
	// - pinned by iid1
	// - staged by iid2
	require.Equal(t, c1, all[1].Cid)
	require.Len(t, all[1].APIIDs, 2)
	require.Equal(t, iid1, all[1].APIIDs[0].ID)
	require.False(t, all[1].APIIDs[0].Staged)
	require.Equal(t, iid2, all[1].APIIDs[1].ID)
	require.True(t, all[1].APIIDs[1].Staged)
}

func TestGCSingleAPIID(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	iid := ffs.NewAPIID()

	t.Run("Simple", func(t *testing.T) {
		ci, ipfs := newCoreIPFS(t)
		// # Stage 1
		r := rand.New(rand.NewSource(22))
		data := it.RandomBytes(r, 1500)
		c1, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		// # Stage 1
		data = it.RandomBytes(r, 1500)
		c2, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		gced, err := ci.GCStaged(ctx, nil, time.Now())
		require.NoError(t, err)
		require.Len(t, gced, 2)

		it.RequireIpfsUnpinnedCid(ctx, t, c1, ipfs)
		it.RequireIpfsUnpinnedCid(ctx, t, c2, ipfs)

		gced, err = ci.GCStaged(ctx, nil, time.Now())
		require.NoError(t, err)
		require.Len(t, gced, 0)
	})

	t.Run("Exclusion", func(t *testing.T) {
		ci, ipfs := newCoreIPFS(t)
		// # Stage 1
		r := rand.New(rand.NewSource(22))
		data := it.RandomBytes(r, 1500)
		c1, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		// # Stage 1
		data = it.RandomBytes(r, 1500)
		c2, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		gced, err := ci.GCStaged(ctx, []cid.Cid{c1}, time.Now())
		require.NoError(t, err)
		require.Len(t, gced, 1)

		it.RequireIpfsUnpinnedCid(ctx, t, c2, ipfs)

		gced, err = ci.GCStaged(ctx, nil, time.Now())
		require.NoError(t, err)
		require.Len(t, gced, 1)
		it.RequireIpfsUnpinnedCid(ctx, t, c1, ipfs)
	})

	t.Run("Very old", func(t *testing.T) {
		ci, ipfs := newCoreIPFS(t)
		// # Stage 1
		r := rand.New(rand.NewSource(22))
		data := it.RandomBytes(r, 1500)
		c1, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		// # Stage 1
		data = it.RandomBytes(r, 1500)
		c2, err := ci.Stage(ctx, iid, bytes.NewReader(data))
		require.NoError(t, err)

		gced, err := ci.GCStaged(ctx, nil, time.Now().Add(-time.Hour))
		require.NoError(t, err)
		require.Len(t, gced, 0)

		gced, err = ci.GCStaged(ctx, nil, time.Now())
		require.NoError(t, err)
		require.Len(t, gced, 2)

		it.RequireIpfsUnpinnedCid(ctx, t, c1, ipfs)
		it.RequireIpfsUnpinnedCid(ctx, t, c2, ipfs)
	})
}

func requireCidIsGCable(t *testing.T, ci *CoreIpfs, c cid.Cid) {
	t.Helper()
	require.True(t, isGCable(t, ci, c))
}

func requireCidIsNotGCable(t *testing.T, ci *CoreIpfs, c cid.Cid) {
	t.Helper()
	require.False(t, isGCable(t, ci, c))
}

func isGCable(t *testing.T, ci *CoreIpfs, c cid.Cid) bool {
	lst, err := ci.getGCCandidates(nil, time.Now())
	require.NoError(t, err)

	for _, cid := range lst {
		if cid.Equals(c) {
			return true
		}
	}
	return false
}

func requireRefCount(t *testing.T, ci *CoreIpfs, c cid.Cid, reqStrong, reqStaged int) {
	t.Helper()
	total, staged := ci.ps.RefCount(c)
	strong := total - staged

	require.Equal(t, strong, reqStrong)
	require.Equal(t, staged, reqStaged)
}

func newCoreIPFS(t *testing.T) (*CoreIpfs, *httpapi.HttpApi) {
	ds := tests.NewTxMapDatastore()
	ipfs, _ := it.CreateIPFS(t)
	l := joblogger.New(txndstr.Wrap(ds, "ffs/joblogger"))
	hl, err := New(ds, ipfs, l)
	require.NoError(t, err)

	return hl, ipfs
}

'''
'''--- Filecoin/powergate/ffs/coreipfs/internal/pinstore/pinstore.go ---
package pinstore

import (
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
)

var (
	pinBaseKey = datastore.NewKey("pins")
	log        = logger.Logger("ffs-pinstore")
)

// Store saves information about pinned Cids per APIID.
// It can be understood as the pinset for a set of APIIDs.
// There're two types of pins: stage-pins and full-pins.
// Stage-pins indicate a form of soft-pinning that clients might
// use as an indication of unpinnable Cids by GC processes.
type Store struct {
	lock  sync.Mutex
	ds    datastore.TxnDatastore
	cache map[cid.Cid]PinnedCid
}

// PinnedCid contains information about a pinned
// Cid from multiple APIIDs.
type PinnedCid struct {
	Cid  cid.Cid
	Pins []Pin
}

// Pin describes a pin of a Cid from a APIID.
// The Stage field indicates if the pin is a stage-pin.
type Pin struct {
	APIID     ffs.APIID
	Staged    bool
	CreatedAt int64
}

// New returns a new Store.
func New(ds datastore.TxnDatastore) (*Store, error) {
	cache, err := populateCache(ds)
	if err != nil {
		return nil, fmt.Errorf("populating cache: %s", err)
	}
	return &Store{ds: ds, cache: cache}, nil
}

// AddStaged pins a Cid for APIID with a staged-pin.
// If c is already stage-pinned, its stage-pin timestamp will be refreshed.
// If c is already fully-pinned, this call is a noop (full-pin will be kept).
func (s *Store) AddStaged(iid ffs.APIID, c cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	var r PinnedCid
	if cr, ok := s.cache[c]; ok {
		r = cr
	} else {
		r = PinnedCid{Cid: c}
	}

	for i, p := range r.Pins {
		if p.APIID == iid {
			if !p.Staged {
				// Looks like the APIID had this Cid
				// pinned with Hot Storage, and later
				// decided to stage the Cid again.
				// Don't mark this Cid as stage-pin since
				// that would be wrong; keep the strong pin.
				// This Cid isn't GCable.
				return nil
			}
			// If the Cid is pinned because of a stage,
			// and is re-staged then simply update its
			// CreatedAt, so it will survive longer to a
			// GC.
			r.Pins[i].CreatedAt = time.Now().Unix()
			return s.persist(r)
		}
	}

	// If the Cid is not present, create it as a staged pin.
	p := Pin{
		APIID:     iid,
		Staged:    true,
		CreatedAt: time.Now().Unix(),
	}
	r.Pins = append(r.Pins, p)

	return s.persist(r)
}

// Add marks c as fully-pinned by iid.
// If c is already stage-pinned, then is switched to fully-pinned.
// If c is already fully-pinned, then only its timestamp gets refreshed.
func (s *Store) Add(iid ffs.APIID, c cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	var r PinnedCid
	if cr, ok := s.cache[c]; ok {
		r = cr
	} else {
		r = PinnedCid{Cid: c}
	}

	var p *Pin
	for i := range r.Pins {
		if r.Pins[i].APIID == iid {
			p = &r.Pins[i]
			if !p.Staged {
				// Log this situation since might be interesting.
				log.Warnf("%s re-pinning already pinned %s", iid, c)
			}
			break
		}
	}
	if p == nil {
		r.Pins = append(r.Pins, Pin{})
		p = &r.Pins[len(r.Pins)-1]
	}
	*p = Pin{
		APIID:     iid,
		Staged:    false,
		CreatedAt: time.Now().Unix(),
	}

	return s.persist(r)
}

// RefCount returns two integers (total, staged).
// total is the total number of ref counts for the Cid.
// staged is the total number of ref counts corresponding to
// staged pins. total includes staged, this means that:
// * total >= staged
// * non-staged pins = total - staged.
func (s *Store) RefCount(c cid.Cid) (int, int) {
	s.lock.Lock()
	defer s.lock.Unlock()

	r, ok := s.cache[c]
	if !ok {
		return 0, 0
	}

	var stagedPins int
	for _, p := range r.Pins {
		if p.Staged {
			stagedPins++
		}
	}

	return len(r.Pins), stagedPins
}

// IsPinnedBy returns true if the Cid is pinned for APIID.
// Both strong and staged pins are considered.
func (s *Store) IsPinnedBy(iid ffs.APIID, c cid.Cid) bool {
	s.lock.Lock()
	defer s.lock.Unlock()

	r, ok := s.cache[c]
	if !ok {
		return false
	}

	for _, p := range r.Pins {
		if p.APIID == iid {
			return true
		}
	}
	return false
}

// IsPinned returns true if c is pinned by at least
// one APIID.
func (s *Store) IsPinned(c cid.Cid) bool {
	s.lock.Lock()
	defer s.lock.Unlock()

	_, ok := s.cache[c]
	return ok
}

// Remove unpins c for iid regarding any pin type.
// If c is unpinned for iid, this is a noop.
func (s *Store) Remove(iid ffs.APIID, c cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	r, ok := s.cache[c]
	if !ok {
		log.Warnf("%s removing globally unpinned cid %s", iid, c)
		return nil
	}

	c1idx := -1
	for i, p := range r.Pins {
		if p.APIID == iid {
			c1idx = i
			break
		}
	}
	if c1idx == -1 {
		log.Warnf("%s removing unpinned cid %s", iid, c)
		return nil
	}
	r.Pins[c1idx] = r.Pins[len(r.Pins)-1]
	r.Pins = r.Pins[:len(r.Pins)-1]

	return s.persist(r)
}

// RemoveStaged deletes from the pinstore c if all
// existing pins are stage-pins, if not it fails.
// This is a safe method used by GCs to unpin unpinnable cids.
func (s *Store) RemoveStaged(c cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	pc, ok := s.cache[c]
	if !ok {
		return fmt.Errorf("c isn't pinned")
	}

	for _, p := range pc.Pins {
		if !p.Staged {
			return fmt.Errorf("all pins should be stage type")
		}
	}

	if err := s.ds.Delete(makeKey(c)); err != nil {
		return fmt.Errorf("deleting from datastore: %s", err)
	}
	delete(s.cache, c)

	return nil
}

// GetAll returns all pinned cids.
func (s *Store) GetAll() ([]PinnedCid, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	var res []PinnedCid
	for _, v := range s.cache {
		v1 := PinnedCid{
			Cid:  v.Cid,
			Pins: make([]Pin, len(v.Pins)),
		}
		for i, p := range v.Pins {
			v1.Pins[i] = p
		}
		res = append(res, v1)
	}
	return res, nil
}

// GetAllOnlyStaged returns all cids that only have stage-pins.
func (s *Store) GetAllOnlyStaged() ([]PinnedCid, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	var res []PinnedCid
Loop:
	for _, v := range s.cache {
		for _, p := range v.Pins {
			if !p.Staged {
				continue Loop
			}
		}

		res = append(res, v)
	}
	return res, nil
}

// persist persists a PinnedCid in the datastore.
func (s *Store) persist(r PinnedCid) error {
	k := makeKey(r.Cid)

	if len(r.Pins) == 0 {
		if err := s.ds.Delete(k); err != nil {
			return fmt.Errorf("delete from datastore: %s", err)
		}
		delete(s.cache, r.Cid)

		return nil
	}
	buf, err := json.Marshal(r)
	if err != nil {
		return fmt.Errorf("marshaling to datastore: %s", err)
	}
	if err := s.ds.Put(k, buf); err != nil {
		return fmt.Errorf("put in datastore: %s", err)
	}
	s.cache[r.Cid] = r

	return nil
}

func populateCache(ds datastore.TxnDatastore) (map[cid.Cid]PinnedCid, error) {
	q := query.Query{Prefix: pinBaseKey.String()}
	res, err := ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing populating cache query: %s", err)
		}
	}()

	ret := map[cid.Cid]PinnedCid{}
	for res := range res.Next() {
		if res.Error != nil {
			return nil, fmt.Errorf("query item result: %s", err)
		}
		var pc PinnedCid
		if err := json.Unmarshal(res.Value, &pc); err != nil {
			return nil, fmt.Errorf("unmarshaling result: %s", err)
		}
		ret[pc.Cid] = pc
	}
	return ret, nil
}

func makeKey(c cid.Cid) datastore.Key {
	return pinBaseKey.ChildString(c.String())
}

'''
'''--- Filecoin/powergate/ffs/filcold/filcold.go ---
package filcold

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"time"

	"github.com/dustin/go-humanize"
	"github.com/filecoin-project/go-fil-markets/retrievalmarket"
	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/api"
	marketevents "github.com/filecoin-project/lotus/markets/loggers"
	"github.com/ipfs/go-cid"
	logger "github.com/ipfs/go-log/v2"
	iface "github.com/ipfs/interface-go-ipfs-core"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/deals/module"
	dealsModule "github.com/textileio/powergate/v2/deals/module"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/util"
	"github.com/textileio/powergate/v2/wallet"
	"go.opentelemetry.io/otel/metric"
)

const (
	unsyncedThreshold = 10
)

var (
	log = logger.Logger("ffs-filcold")
)

// FilCold is a ColdStorage implementation which saves data in the Filecoin network.
// It assumes the underlying Filecoin client has access to an IPFS node where data is stored.
type FilCold struct {
	ms                   ffs.MinerSelector
	dm                   *dealsModule.Module
	wm                   wallet.Module
	ipfs                 iface.CoreAPI
	chain                FilChain
	l                    ffs.JobLogger
	lsm                  *lotus.SyncMonitor
	minPieceSize         uint64
	retrNextEventTimeout time.Duration
	semaphDealPrep       chan struct{}

	// Metrics
	metricPreprocessingTotal metric.Int64UpDownCounter
}

var _ ffs.ColdStorage = (*FilCold)(nil)

// FilChain is an abstraction of a Filecoin node to get information of the network.
type FilChain interface {
	GetHeight(context.Context) (uint64, error)
}

// New returns a new FilCold instance.
func New(ms ffs.MinerSelector, dm *dealsModule.Module, wm wallet.Module, ipfs iface.CoreAPI, chain FilChain, l ffs.JobLogger, lsm *lotus.SyncMonitor, minPieceSize uint64, maxParallelDealPreparing int, retrievalNextEventTimeout time.Duration) *FilCold {
	fc := &FilCold{
		ms:                   ms,
		dm:                   dm,
		wm:                   wm,
		ipfs:                 ipfs,
		chain:                chain,
		l:                    l,
		lsm:                  lsm,
		minPieceSize:         minPieceSize,
		retrNextEventTimeout: retrievalNextEventTimeout,
		semaphDealPrep:       make(chan struct{}, maxParallelDealPreparing),
	}
	fc.initMetrics()

	return fc
}

// Fetch fetches the stored Cid data.The data will be considered available
// to the underlying blockstore.
func (fc *FilCold) Fetch(ctx context.Context, pyCid cid.Cid, piCid *cid.Cid, waddr string, miners []string, maxPrice uint64, selector string) (ffs.FetchInfo, error) {
	miner, events, err := fc.dm.Fetch(ctx, waddr, pyCid, piCid, miners)
	if err != nil {
		return ffs.FetchInfo{}, fmt.Errorf("fetching from deal module: %s", err)
	}
	fc.l.Log(ctx, "Fetching from %s...", miner)

	var (
		fundsSpent uint64
		lastMsg    string
		lastEvent  marketevents.RetrievalEvent
	)
Loop:
	for {
		select {
		case <-time.After(fc.retrNextEventTimeout):
			return ffs.FetchInfo{}, fmt.Errorf("didn't receive events for %d minutes", int64(fc.retrNextEventTimeout.Minutes()))
		case e, ok := <-events:
			if !ok {
				break Loop
			}
			if e.Err != "" {
				return ffs.FetchInfo{}, fmt.Errorf("event error in retrieval progress: %s", e.Err)
			}
			strEvent := retrievalmarket.ClientEvents[e.Event]
			strDealStatus := retrievalmarket.DealStatuses[e.Status]
			fundsSpent = e.FundsSpent.Uint64()
			newMsg := fmt.Sprintf("Received %s, total spent: %sFIL (%s/%s)", humanize.IBytes(e.BytesReceived), util.AttoFilToFil(fundsSpent), strEvent, strDealStatus)
			if newMsg != lastMsg {
				fc.l.Log(ctx, newMsg)
				lastMsg = newMsg
			}
			lastEvent = e
		}
	}
	if lastEvent.Status != retrievalmarket.DealStatusCompleted {
		return ffs.FetchInfo{}, fmt.Errorf("retrieval failed with status %s and message %s", retrievalmarket.DealStatuses[lastEvent.Status], lastMsg)
	}

	return ffs.FetchInfo{RetrievedMiner: miner, FundsSpent: fundsSpent}, nil
}

func (fc *FilCold) calculateDealPiece(ctx context.Context, c cid.Cid) (int64, abi.PaddedPieceSize, cid.Cid, error) {
	fc.l.Log(ctx, "Entering deal preprocessing queue...")
	fc.metricPreprocessingTotal.Add(ctx, 1, metricTagPreprocessingWaiting)
	select {
	case fc.semaphDealPrep <- struct{}{}:
	case <-ctx.Done():
		fc.metricPreprocessingTotal.Add(ctx, -1, metricTagPreprocessingWaiting)
		return 0, 0, cid.Undef, fmt.Errorf("canceled by context")
	}
	fc.metricPreprocessingTotal.Add(ctx, -1, metricTagPreprocessingWaiting)
	fc.metricPreprocessingTotal.Add(ctx, 1, metricTagPreprocessingInProgress)
	defer func() {
		fc.metricPreprocessingTotal.Add(ctx, -1, metricTagPreprocessingInProgress)
		<-fc.semaphDealPrep
	}()
	for {
		if fc.lsm.SyncHeightDiff() < unsyncedThreshold {
			break
		}
		log.Warnf("backpressure from unsynced Lotus node")
		select {
		case <-ctx.Done():
			return 0, 0, cid.Undef, fmt.Errorf("canceled by context")
		case <-time.After(time.Minute):
		}
	}
	fc.l.Log(ctx, "Calculating piece size...")
	piece, err := fc.dm.CalculateDealPiece(ctx, c)
	if err != nil {
		return 0, 0, cid.Undef, fmt.Errorf("getting cid cummulative size: %s", err)
	}
	return piece.PayloadSize, piece.PieceSize, piece.PieceCID, nil
}

// Store stores a Cid in Filecoin considering the configuration provided. The Cid is retrieved using
// the DAGService registered on instance creation. It returns a slice of ProposalCids that were correctly
// started, and a slice of with Proposal Cids rejected. Returned proposed deals can be tracked
// with the WaitForDeal API.
func (fc *FilCold) Store(ctx context.Context, c cid.Cid, cfg ffs.FilConfig) ([]cid.Cid, []ffs.DealError, abi.PaddedPieceSize, error) {
	payloadSize, pieceSize, pieceCid, err := fc.calculateDealPiece(ctx, c)
	if err != nil {
		return nil, nil, 0, fmt.Errorf("getting cid cummulative size: %s", err)
	}
	fc.l.Log(ctx, "The payload size is %s, and the calculated piece size is %s", humanize.IBytes(uint64(payloadSize)), humanize.IBytes(uint64(pieceSize)))

	if uint64(pieceSize) < fc.minPieceSize {
		return nil, nil, 0, fmt.Errorf("Piece size is below allowed minimum %s", humanize.IBytes(fc.minPieceSize))
	}

	if cfg.VerifiedDeal {
		vci, err := fc.wm.GetVerifiedClientInfo(ctx, cfg.Addr)
		if err != nil && err != wallet.ErrNoVerifiedClient {
			return nil, nil, 0, fmt.Errorf("get address verified client info: %s", err)
		}
		if err == wallet.ErrNoVerifiedClient {
			return nil, nil, 0, fmt.Errorf("wallet address isn't a verified client")
		}

		pieceSizeBig := big.NewInt(int64(pieceSize))
		if vci.RemainingDatacapBytes.Cmp(big.NewInt(0).Mul(big.NewInt(int64(cfg.RepFactor)), pieceSizeBig)) == -1 {
			return nil, nil, 0, fmt.Errorf("the remaining data-cap %s is less than piece-size %s * rep-factor %d", humanize.IBytes(vci.RemainingDatacapBytes.Uint64()), humanize.IBytes(uint64(pieceSize)), cfg.RepFactor)
		}

		fc.l.Log(ctx, "Attempting to use %s of data-cap. The current quota is %s", humanize.IBytes(uint64(pieceSize)*uint64(cfg.RepFactor)), humanize.IBytes(vci.RemainingDatacapBytes.Uint64()))
	}
	f := ffs.MinerSelectorFilter{
		ExcludedMiners: cfg.ExcludedMiners,
		CountryCodes:   cfg.CountryCodes,
		TrustedMiners:  cfg.TrustedMiners,
		MaxPrice:       cfg.MaxPrice,
		PieceSize:      uint64(pieceSize),
		VerifiedDeal:   cfg.VerifiedDeal,
	}
	cfgs, err := makeDealConfigs(fc.ms, cfg.RepFactor, f, cfg.FastRetrieval, cfg.DealStartOffset)
	if err != nil {
		return nil, nil, 0, fmt.Errorf("making deal configs: %s", err)
	}

	okDeals, failedStartingDeals, err := fc.makeDeals(ctx, c, payloadSize, pieceSize, pieceCid, cfgs, cfg)
	if err != nil {
		return nil, nil, 0, fmt.Errorf("starting deals: %s", err)
	}
	return okDeals, failedStartingDeals, pieceSize, nil
}

// GetDealInfo returns on-chain information for a deal.
func (fc *FilCold) GetDealInfo(ctx context.Context, dealID uint64) (api.MarketDeal, error) {
	di, err := fc.dm.GetDealInfo(ctx, dealID)
	if err == module.ErrDealNotFound {
		return api.MarketDeal{}, ffs.ErrOnChainDealNotFound
	}
	if err != nil {
		return api.MarketDeal{}, fmt.Errorf("getting deal information: %s", err)
	}
	if di.State.SlashEpoch != -1 {
		return api.MarketDeal{}, ffs.ErrOnChainDealNotFound
	}

	return di, nil
}

// EnsureRenewals analyzes a FilInfo state for a Cid and executes renewals considering the FilConfig desired configuration.
// Deal status updates are sent on the provided dealUpdates channel.
// The caller should close the channel once all calls to EnsureRenewals have returned.
// It returns an updated FilInfo for the Cid. All prevous Proposals in the received FilInfo are kept, only flagging the ones
// that got renewed with Renewed=true. New deals from renewals are added to the returned FilInfo.
// Note: Most probably all this code should change in the future, when Filecoin supports telling the miner which deal is about to
// expire that we're interested in extending the deal duration. Now we should make a new deal from scratch (send data, etc).
func (fc *FilCold) EnsureRenewals(ctx context.Context, c cid.Cid, inf ffs.FilInfo, cfg ffs.FilConfig, dealFinalityTimeout time.Duration, dealUpdates chan deals.StorageDealInfo) (ffs.FilInfo, []ffs.DealError, error) {
	height, err := fc.chain.GetHeight(ctx)
	if err != nil {
		return ffs.FilInfo{}, nil, fmt.Errorf("get current filecoin height: %s", err)
	}

	var renewable []ffs.FilStorage
	for _, p := range inf.Proposals {
		// If this deal was already renewed, we can ignore it will
		// soon expire since we already handled it.
		if p.Renewed {
			continue
		}
		expiry := int64(p.StartEpoch) + p.Duration
		renewalHeight := expiry - int64(cfg.Renew.Threshold)
		if uint64(renewalHeight) <= height {
			renewable = append(renewable, p)
		}
	}

	// Calculate how many active deals aren't expiring soon.
	youngActiveDeals := len(inf.Proposals) - len(renewable)
	// Calculate how many of the renewable (soon to be expired) deals should be renewed
	// so we have the desired RepFactor.
	numToBeRenewed := cfg.RepFactor - youngActiveDeals
	if numToBeRenewed <= 0 {
		// Nothing to be renewed to ensure RepFactor,
		// most prob the RepFactor was decreased.
		return inf, nil, nil
	}
	if numToBeRenewed > len(renewable) {
		// We need even more deals than renewable to ensure RepFactor,
		// that's job of the repair module. We renew as many as can be
		// renewed.
		numToBeRenewed = len(renewable)
	}

	newInf := ffs.FilInfo{
		DataCid:   inf.DataCid,
		Size:      inf.Size,
		Proposals: make([]ffs.FilStorage, len(inf.Proposals)),
	}
	for i, p := range inf.Proposals {
		newInf.Proposals[i] = p
	}

	toRenew := renewable[:numToBeRenewed]
	var newDealErrors []ffs.DealError
	for i, p := range toRenew {
		var dealError ffs.DealError
		newProposal, err := fc.renewDeal(ctx, c, p, cfg, dealFinalityTimeout, dealUpdates)
		if err != nil {
			if errors.As(err, &dealError) {
				newDealErrors = append(newDealErrors, dealError)
				continue
			}
			continue
		}
		newInf.Proposals = append(newInf.Proposals, newProposal)
		newInf.Proposals[i].Renewed = true
	}

	return newInf, newDealErrors, nil
}

func (fc *FilCold) renewDeal(ctx context.Context, c cid.Cid, p ffs.FilStorage, fcfg ffs.FilConfig, waitDealTimeout time.Duration, dealUpdates chan deals.StorageDealInfo) (ffs.FilStorage, error) {
	payloadSize, pieceSize, pieceCid, err := fc.calculateDealPiece(ctx, c)
	if err != nil {
		return ffs.FilStorage{}, fmt.Errorf("getting cid cummulative size: %s", err)
	}

	f := ffs.MinerSelectorFilter{
		ExcludedMiners: fcfg.ExcludedMiners,
		CountryCodes:   fcfg.CountryCodes,
		TrustedMiners:  []string{p.Miner},
		MaxPrice:       fcfg.MaxPrice,
		PieceSize:      uint64(pieceSize),
		VerifiedDeal:   fcfg.VerifiedDeal,
	}
	dealConfig, err := makeDealConfigs(fc.ms, 1, f, fcfg.FastRetrieval, fcfg.DealStartOffset)
	if err != nil {
		return ffs.FilStorage{}, fmt.Errorf("making new deal config: %s", err)
	}

	okDeals, failedStartedDeals, err := fc.makeDeals(ctx, c, payloadSize, pieceSize, pieceCid, dealConfig, fcfg)
	if err != nil {
		return ffs.FilStorage{}, fmt.Errorf("executing renewed deal: %s", err)
	}
	if len(okDeals) == 0 {
		if len(failedStartedDeals) != 1 {
			return ffs.FilStorage{}, fmt.Errorf("failed started deals must be of size 1, this should never happen")
		}
		fc.l.Log(ctx, "Starting renewal deal proposal failed: %s", failedStartedDeals[0].Message)
		return ffs.FilStorage{}, failedStartedDeals[0]
	}

	var dealError ffs.DealError
	okDeal, err := fc.WaitForDeal(ctx, c, okDeals[0], waitDealTimeout, dealUpdates)
	if err != nil && !errors.As(err, &dealError) {
		return ffs.FilStorage{}, ffs.DealError{ProposalCid: c, Message: fmt.Sprintf("waiting for renew deal: %s", err)}
	}
	return okDeal, err
}

// makeDeals starts deals with the specified miners. It returns a slice with all the ProposalCids
// that were started successfully, and a slice of DealError with deals that failed to be started.
func (fc *FilCold) makeDeals(ctx context.Context, c cid.Cid, payloadSize int64, pieceSize abi.PaddedPieceSize, pieceCid cid.Cid, cfgs []deals.StorageDealConfig, fcfg ffs.FilConfig) ([]cid.Cid, []ffs.DealError, error) {
	for {
		if fc.lsm.SyncHeightDiff() < unsyncedThreshold {
			break
		}
		log.Warnf("lotus backpressure from unsynced node")
		select {
		case <-ctx.Done():
			return nil, nil, fmt.Errorf("canceled by context")
		case <-time.After(time.Minute):
		}
	}

	for _, cfg := range cfgs {
		fc.l.Log(ctx, "Proposing deal to miner %s with %s FIL per epoch...", cfg.Miner, util.AttoFilToFil(cfg.EpochPrice))
	}

	sres, err := fc.dm.Store(ctx, fcfg.Addr, c, payloadSize, pieceSize, pieceCid, cfgs, uint64(fcfg.DealMinDuration))
	if err != nil {
		return nil, nil, fmt.Errorf("storing deals in deal module: %s", err)
	}
	var okDeals []cid.Cid
	var failedDeals []ffs.DealError
	for _, r := range sres {
		if !r.Success {
			fc.l.Log(ctx, "Proposal with miner %s failed: %s", r.Config.Miner, r.Message)
			log.Warnf("failed store result: %s", r.Message)
			de := ffs.DealError{
				ProposalCid: r.ProposalCid,
				Message:     r.Message,
				Miner:       r.Config.Miner,
			}
			failedDeals = append(failedDeals, de)
			continue
		}
		okDeals = append(okDeals, r.ProposalCid)
	}
	return okDeals, failedDeals, nil
}

// WaitForDeal blocks the provided Deal Proposal reaches a final state.
// Deal status updates are sent on the provided dealUpdates channel.
// The caller should close the channel once all calls to WaitForDeal have returned.
// If the deal finishes successfully it returns a FilStorage result.
// If the deal finished with error, it returns a ffs.DealError error
// result, so it should be considered in error handling.
func (fc *FilCold) WaitForDeal(ctx context.Context, c cid.Cid, proposal cid.Cid, timeout time.Duration, dealUpdates chan deals.StorageDealInfo) (ffs.FilStorage, error) {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	chDi, err := fc.dm.Watch(ctx, proposal)
	if err != nil {
		return ffs.FilStorage{}, fmt.Errorf("watching proposals in deals module: %s", err)
	}

	var last deals.StorageDealInfo
Loop:
	for {
		select {
		case <-time.After(timeout):
			msg := fmt.Sprintf("DealID %d with miner %s tracking timed out after waiting for %.0f hours.", last.DealID, last.Miner, timeout.Hours())
			fc.l.Log(ctx, msg)
			return ffs.FilStorage{}, ffs.DealError{ProposalCid: proposal, Miner: last.Miner, Message: msg}
		case di, ok := <-chDi:
			if !ok {
				break Loop
			}
			last = di
			select {
			case dealUpdates <- di:
			default:
				log.Warnf("slow receiver for deal updates for %s", c)
			}
			switch di.StateID {
			case storagemarket.StorageDealActive:
				activeProposal := ffs.FilStorage{
					DealID:     di.DealID,
					PieceCid:   di.PieceCID,
					Duration:   int64(di.Duration),
					Miner:      di.Miner,
					StartEpoch: di.StartEpoch,
					EpochPrice: di.PricePerEpoch,
				}
				fc.l.Log(ctx, "Deal %d with miner %s is active on-chain", di.DealID, di.Miner)

				return activeProposal, nil
			case storagemarket.StorageDealError, storagemarket.StorageDealFailing:
				log.Errorf("deal %d & proposal %s failed with state %s: %s", di.DealID, proposal, storagemarket.DealStates[di.StateID], di.Message)
				fc.l.Log(ctx, "DealID %d with miner %s failed and won't be active on-chain: %s", di.DealID, di.Miner, di.Message)

				return ffs.FilStorage{}, ffs.DealError{ProposalCid: di.ProposalCid, Miner: di.Miner, Message: di.Message}
			default:
				if di.DealID != 0 {
					fc.l.Log(ctx, "Deal %d with miner %s changed state to %s", di.DealID, di.Miner, storagemarket.DealStates[di.StateID])
				} else {
					fc.l.Log(ctx, "Deal with miner %s changed state to %s", di.Miner, storagemarket.DealStates[di.StateID])
				}
			}
		}
	}
	return ffs.FilStorage{}, fmt.Errorf("aborted due to cancellation")
}

func makeDealConfigs(ms ffs.MinerSelector, cntMiners int, f ffs.MinerSelectorFilter, fastRetrieval bool, dealStartOffset int64) ([]deals.StorageDealConfig, error) {
	mps, err := ms.GetMiners(cntMiners, f)
	if err != nil {
		return nil, fmt.Errorf("getting miners from minerselector: %s", err)
	}
	res := make([]deals.StorageDealConfig, len(mps))
	for i, m := range mps {
		res[i] = deals.StorageDealConfig{
			Miner:           m.Addr,
			EpochPrice:      m.EpochPrice,
			FastRetrieval:   fastRetrieval,
			DealStartOffset: dealStartOffset,
			VerifiedDeal:    f.VerifiedDeal,
		}
	}
	return res, nil
}

'''
'''--- Filecoin/powergate/ffs/filcold/metrics.go ---
package filcold

import (
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	metricTagPreprocessingWaiting    = attribute.Key("status").String("waiting")
	metricTagPreprocessingInProgress = attribute.Key("status").String("inprogress")
)

func (fc *FilCold) initMetrics() {
	meter := global.Meter("powergate")
	fc.metricPreprocessingTotal = metric.Must(meter).NewInt64UpDownCounter("powergate.preprocessing.queue.total")
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/config/config_test.go ---
package config

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestSetDefaultStorageConfig(t *testing.T) {
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	config := ffs.StorageConfig{
		Hot: ffs.HotConfig{
			Enabled: false,
			Ipfs: ffs.IpfsConfig{
				AddTimeout: 10,
			},
		},
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				DealMinDuration: util.MinDealDuration + 22333,
				RepFactor:       23,
				Addr:            "123456",
			},
		},
	}
	err := fapi.SetDefaultStorageConfig(config)
	require.NoError(t, err)
	newConfig := fapi.DefaultStorageConfig()
	require.Equal(t, newConfig.Hot, config.Hot)
	require.Equal(t, newConfig.Cold, config.Cold)
}

func TestEnabledConfigChange(t *testing.T) {
	t.Parallel()
	t.Run("HotEnabledDisabled", func(t *testing.T) {
		t.Parallel()
		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ctx := context.Background()
			ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			config := fapi.DefaultStorageConfig()

			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireIpfsPinnedCid(ctx, t, cid, ipfsAPI)

			config = fapi.DefaultStorageConfig().WithHotEnabled(false)
			jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireIpfsUnpinnedCid(ctx, t, cid, ipfsAPI)
		})
	})
	t.Run("HotDisabledEnabled", func(t *testing.T) {
		t.Parallel()
		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ctx := context.Background()
			ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			config := fapi.DefaultStorageConfig().WithHotEnabled(false)

			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireIpfsUnpinnedCid(ctx, t, cid, ipfsAPI)

			config = fapi.DefaultStorageConfig().WithHotEnabled(true)
			jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireIpfsPinnedCid(ctx, t, cid, ipfsAPI)
		})
	})
	t.Run("ColdDisabledEnabled", func(t *testing.T) {
		t.Parallel()

		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ctx := context.Background()
			ipfsAPI, client, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			config := fapi.DefaultStorageConfig().WithColdEnabled(false)

			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireFilUnstored(ctx, t, client, cid)

			config = fapi.DefaultStorageConfig().WithHotEnabled(true)
			jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireFilStored(ctx, t, client, cid)
		})
	})
	t.Run("ColdEnabledDisabled", func(t *testing.T) {
		t.Parallel()

		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ctx := context.Background()
			ipfsAPI, client, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			config := fapi.DefaultStorageConfig().WithColdEnabled(false)

			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireFilUnstored(ctx, t, client, cid)

			config = fapi.DefaultStorageConfig().WithHotEnabled(true)
			jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)

			// Yes, still stored in filecoin since deals can't be
			// undone.
			it.RequireFilStored(ctx, t, client, cid)
			// Despite of the above, check that the Cid Config still reflects
			// that this *shouldn't* be in cold storage. To indicate
			// this can't be renewed, or any other future action that tries to
			// store it again in cold storage.
			it.RequireStorageConfig(t, fapi, cid, &config)
		})
	})
}

func TestFilecoinEnableConfig(t *testing.T) {
	t.Parallel()
	tableTest := []struct {
		HotEnabled  bool
		ColdEnabled bool
	}{
		{HotEnabled: true, ColdEnabled: true},
		{HotEnabled: false, ColdEnabled: true},
		{HotEnabled: true, ColdEnabled: false},
		{HotEnabled: false, ColdEnabled: false},
	}

	for _, tt := range tableTest {
		tt := tt
		name := fmt.Sprintf("Hot(%v)/Cold(%v)", tt.HotEnabled, tt.ColdEnabled)
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			tests.RunFlaky(t, func(t *tests.FlakyT) {
				ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
				defer cls()

				r := rand.New(rand.NewSource(22))
				cid, _ := it.AddRandomFile(t, r, ipfsAPI)
				config := fapi.DefaultStorageConfig().WithColdEnabled(tt.ColdEnabled).WithHotEnabled(tt.HotEnabled)

				jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
				require.NoError(t, err)

				expectedJobState := ffs.Success
				it.RequireEventualJobState(t, fapi, jid, expectedJobState)

				if expectedJobState == ffs.Success {
					it.RequireStorageConfig(t, fapi, cid, &config)

					// Show() assertions
					cinfo, err := fapi.StorageInfo(cid)
					require.NoError(t, err)
					require.Equal(t, tt.HotEnabled, cinfo.Hot.Enabled)
					if tt.ColdEnabled {
						require.NotEmpty(t, cinfo.Cold.Filecoin.Proposals)
					} else {
						require.Empty(t, cinfo.Cold.Filecoin.Proposals)
					}

					// Get() assertions
					ctx := context.Background()
					_, err = fapi.Get(ctx, cid)
					var expectedErr error
					if !tt.HotEnabled {
						expectedErr = api.ErrHotStorageDisabled
					}
					require.Equal(t, expectedErr, err)

					// External assertions
					if !tt.HotEnabled {
						it.RequireIpfsUnpinnedCid(ctx, t, cid, ipfsAPI)
					} else {
						it.RequireIpfsPinnedCid(ctx, t, cid, ipfsAPI)
					}
				}
			})
		})
	}
}

func TestHotTimeoutConfig(t *testing.T) {
	t.SkipNow()
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	t.Run("ShortTime", func(t *testing.T) {
		tests.RunFlaky(t, func(t *tests.FlakyT) {
			cid, _ := util.CidFromString("Qmc5gCcjYypU7y28oCALwfSvxCBskLuPKWpK4qpterKC7z")
			config := fapi.DefaultStorageConfig().WithHotIpfsAddTimeout(1)
			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireEventualJobState(t, fapi, jid, ffs.Failed)
		})
	})
}

func TestDurationConfig(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfsAPI)
		duration := int64(util.MinDealDuration + 1234)
		config := fapi.DefaultStorageConfig().WithColdFilDealDuration(duration)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		p := cinfo.Cold.Filecoin.Proposals[0]
		require.Greater(t, p.Duration, duration)
	})
}

func TestGetDefaultStorageConfig(t *testing.T) {
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	defaultConf := fapi.DefaultStorageConfig()
	require.Nil(t, defaultConf.Validate())
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/filters/filters_test.go ---
package filters

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/ffs/minerselector/fixed"
	"github.com/textileio/powergate/v2/tests"

	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestFilecoinExcludedMiners(t *testing.T) {
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 2, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfsAPI)
		excludedMiner := "f01000"
		config := fapi.DefaultStorageConfig().WithColdFilExcludedMiners([]string{excludedMiner})

		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		p := cinfo.Cold.Filecoin.Proposals[0]
		require.NotEqual(t, p.Miner, excludedMiner)
	})
}

func TestFilecoinTrustedMiner(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 2, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfsAPI)
		trustedMiner := "f01001"
		config := fapi.DefaultStorageConfig().WithColdFilTrustedMiners([]string{trustedMiner})

		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		p := cinfo.Cold.Filecoin.Proposals[0]
		require.Equal(t, p.Miner, trustedMiner)
	})
}

func TestFilecoinCountryFilter(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfs, ipfsAddr := it.CreateIPFS(t)
		countries := []string{"China", "Uruguay"}
		numMiners := len(countries)
		client, addr, _ := tests.CreateLocalDevnetWithIPFS(t, numMiners, 300, ipfsAddr, false)
		addrs := make([]string, numMiners)
		for i := 0; i < numMiners; i++ {
			addrs[i] = fmt.Sprintf("f0%d", 1000+i)
		}
		fixedMiners := make([]fixed.Miner, len(addrs))
		for i, a := range addrs {
			fixedMiners[i] = fixed.Miner{Addr: a, Country: countries[i], EpochPrice: 500000000}
		}
		ms := fixed.New(fixedMiners)
		ds := tests.NewTxMapDatastore()
		manager, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)
		defer closeManager()
		auth, err := manager.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 3)
		fapi, err := manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfs)
		countryFilter := []string{"Uruguay"}
		config := fapi.DefaultStorageConfig().WithColdFilCountryCodes(countryFilter)

		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		p := cinfo.Cold.Filecoin.Proposals[0]
		require.Equal(t, p.Miner, "f01001")
	})
}

func TestFilecoinMaxPriceFilter(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfs, ipfsMAddr := it.CreateIPFS(t)
		client, addr, _ := tests.CreateLocalDevnetWithIPFS(t, 1, 300, ipfsMAddr, false)
		miner := fixed.Miner{Addr: "f01000", EpochPrice: 500000000}
		ms := fixed.New([]fixed.Miner{miner})
		ds := tests.NewTxMapDatastore()
		manager, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)
		defer closeManager()
		auth, err := manager.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 3) // Wait for funding txn.
		fapi, err := manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfs)

		config := fapi.DefaultStorageConfig().WithColdMaxPrice(400000000)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Failed)

		config = fapi.DefaultStorageConfig().WithColdMaxPrice(600000000)
		jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		p := cinfo.Cold.Filecoin.Proposals[0]
		require.Equal(t, p.Miner, "f01000")
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/general/general_test.go ---
package general

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"testing"
	"time"

	"github.com/ipfs/go-cid"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestAdd(t *testing.T) {
	t.Parallel()
	t.Run("WithDefaultStorageConfig", func(t *testing.T) {
		t.Parallel()
		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ctx := context.Background()
			ipfsAPI, client, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			jid, err := fapi.PushStorageConfig(cid)
			require.NoError(t, err)
			it.RequireStorageJobState(t, fapi, jid, ffs.Queued, ffs.Executing)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, nil)
			it.RequireFilStored(ctx, t, client, cid)
			it.RequireIpfsPinnedCid(ctx, t, cid, ipfsAPI)
			it.RequireStorageDealRecord(t, fapi, cid)
		})
	})

	t.Run("WithCustomConfig", func(t *testing.T) {
		t.Parallel()

		tests.RunFlaky(t, func(t *tests.FlakyT) {
			ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfsAPI)
			config := fapi.DefaultStorageConfig().WithHotEnabled(false).WithColdFilDealDuration(util.MinDealDuration + 1234)
			jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
			require.NoError(t, err)
			it.RequireStorageJobState(t, fapi, jid, ffs.Queued, ffs.Executing)
			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, &config)
			it.RequireStorageDealRecord(t, fapi, cid)
		})
	})
}

func TestGet(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ctx := context.Background()
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, data := it.AddRandomFile(t, r, ipfs)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, nil)

		rr, err := fapi.Get(ctx, cid)
		require.NoError(t, err)
		fetched, err := ioutil.ReadAll(rr)
		require.NoError(t, err)
		require.True(t, bytes.Equal(data, fetched))
	})
}

func TestDealConsistency(t *testing.T) {
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		firstID := fapi.ID()
		require.NotEmpty(t, firstID)

		firstAddrs := fapi.Addrs()
		require.Len(t, firstAddrs, 1)
		require.NotEmpty(t, firstAddrs[0].Addr)

		firstStorageConfigs, err := fapi.GetStorageConfigs()
		require.NoError(t, err)
		require.Equal(t, len(firstStorageConfigs), 0)

		r := rand.New(rand.NewSource(22))
		n := 1
		retriesPerDeal := 5
		for i := 0; i < n; i++ {
			for j := 0; j < retriesPerDeal; j++ {
				fmt.Printf("Deal %d, attempt %d...\n", i+1, j+1)
				cid, _ := it.AddRandomFile(t, r, ipfs)
				jid, err := fapi.PushStorageConfig(cid)
				require.NoError(t, err)
				ch := make(chan ffs.StorageJob)
				ctx, cancel := context.WithCancel(context.Background())
				defer cancel()
				go func() {
					err = fapi.WatchJobs(ctx, ch, jid)
					close(ch)
				}()
				var failed bool
				stop := false
				for !stop {
					select {
					case <-time.After(120 * time.Second):
						t.Errorf("waiting for job update timeout")
						failed = true
					case job, ok := <-ch:
						require.True(t, ok)
						require.Equal(t, jid, job.ID)
						if job.Status == ffs.Queued || job.Status == ffs.Executing {
							continue
						}
						if job.Status != ffs.Success {
							failed = true
						}
						stop = true
					}
				}
				require.NoError(t, err)
				if !failed {
					it.RequireStorageConfig(t, fapi, cid, nil)
					break
				}
			}
		}

		secondID := fapi.ID()
		require.Equal(t, secondID, firstID)

		secondAddrs := fapi.Addrs()
		require.NoError(t, err)
		require.Len(t, secondAddrs, 1)
		require.Equal(t, secondAddrs[0].Addr, firstAddrs[0].Addr)

		secondStorageConfigs, err := fapi.GetStorageConfigs()
		require.NoError(t, err)
		require.Equal(t, n, len(secondStorageConfigs))
	})
}

func TestShow(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)

		defer cls()

		// Test not stored
		c, _ := util.CidFromString("Qmc5gCcjYypU7y28oCALwfSvxCBskLuPKWpK4qpterKC7z")

		_, err := fapi.StorageInfo(c)
		require.Equal(t, api.ErrNotFound, err)

		r := rand.New(rand.NewSource(22))
		randomCid, _ := it.AddRandomFile(t, r, ipfs)
		jid, err := fapi.PushStorageConfig(randomCid)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, randomCid, nil)

		cfgs, err := fapi.GetStorageConfigs()
		require.NoError(t, err)
		require.Equal(t, 1, len(cfgs))

		cfgCids := make([]cid.Cid, 0, len(cfgs))
		for cid := range cfgs {
			cfgCids = append(cfgCids, cid)
		}

		c = cfgCids[0]

		s, err := fapi.StorageInfo(c)
		require.NoError(t, err)

		require.True(t, s.Cid.Defined())
		require.True(t, time.Now().After(s.Created))
		require.Greater(t, s.Hot.Size, 0)
		require.NotNil(t, s.Hot.Ipfs)
		require.True(t, time.Now().After(s.Hot.Ipfs.Created))
		require.NotNil(t, s.Cold.Filecoin)
		require.True(t, s.Cold.Filecoin.DataCid.Defined())
		require.Equal(t, 1, len(s.Cold.Filecoin.Proposals))
		p := s.Cold.Filecoin.Proposals[0]
		require.Greater(t, p.DealID, uint64(0))
		require.Greater(t, p.Duration, int64(0))
		require.Greater(t, p.EpochPrice, uint64(0))
	})
}

func TestColdInstanceLoad(t *testing.T) {
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ctx := context.Background()

		ds := tests.NewTxMapDatastore()
		ipfs, ipfsMAddr := it.CreateIPFS(t)
		addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
		manager, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)

		auth, err := manager.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 3) // Wait for funding txn to finish.

		fapi, err := manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		ra := rand.New(rand.NewSource(22))
		cid, data := it.AddRandomFile(t, ra, ipfs)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, nil)

		id := fapi.ID()
		shw, err := fapi.StorageInfo(cid)
		require.NoError(t, err)

		// Now close the FFS Instance, and the manager.
		err = fapi.Close()
		require.NoError(t, err)
		closeManager()

		// Rehydrate things again and check state.
		manager, closeManager = itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)
		defer closeManager()
		fapi, err = manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		nid := fapi.ID()
		require.Equal(t, id, nid)

		nshw, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		require.Equal(t, shw, nshw)

		r, err := fapi.Get(ctx, cid)
		require.NoError(t, err)
		fetched, err := ioutil.ReadAll(r)
		require.NoError(t, err)
		require.True(t, bytes.Equal(data, fetched))
	})
}

func TestHighMinimumPieceSize(t *testing.T) {
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ds := tests.NewTxMapDatastore()
		ipfs, ipfsMAddr := it.CreateIPFS(t)
		addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
		// Set MinimumPieceSize to 1GB so to force failing
		manager, _, closeManager := itmanager.NewCustomFFSManager(t, ds, client, addr, ms, ipfs, 1024*1024*1024)
		defer closeManager()

		auth, err := manager.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 3) // Wait for funding txn to finish.

		fapi, err := manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfs)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Failed)
	})
}

func TestStageCidUnpinedOnDisabledHotStorage(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ctx := context.Background()
		ds := tests.NewTxMapDatastore()
		ipfs, ipfsMAddr := it.CreateIPFS(t)
		addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
		manager, hs, closeManager := itmanager.NewCustomFFSManager(t, ds, client, addr, ms, ipfs, 0)
		defer closeManager()
		auth, err := manager.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 3) // Wait for funding txn to finish.

		fapi, err := manager.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		r := rand.New(rand.NewSource(22))

		data := it.RandomBytes(r, 1600)
		// Simulate staging the data, which Stage-pins it.
		cid, err := hs.Stage(ctx, fapi.ID(), bytes.NewReader(data))
		require.NoError(t, err)
		it.RequireIpfsPinnedCid(ctx, t, cid, ipfs)

		config := fapi.DefaultStorageConfig().WithHotEnabled(false)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		time.Sleep(time.Second)
		it.RequireIpfsUnpinnedCid(ctx, t, cid, ipfs)
	})
}

func TestRemove(t *testing.T) {
	t.Parallel()

	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		c1, _ := it.AddRandomFile(t, r, ipfs)

		config := fapi.DefaultStorageConfig().WithColdEnabled(false)
		jid, err := fapi.PushStorageConfig(c1, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, c1, &config)

		err = fapi.Remove(c1)
		require.Equal(t, api.ErrActiveInStorage, err)

		config = config.WithHotEnabled(false)
		jid, err = fapi.PushStorageConfig(c1, api.WithStorageConfig(config), api.WithOverride(true))
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		require.NoError(t, err)

		err = fapi.Remove(c1)
		require.NoError(t, err)
		_, err = fapi.GetStorageConfigs(c1)
		require.Equal(t, api.ErrNotFound, err)
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/importing/importing_test.go ---
package importing

import (
	"bytes"
	"context"
	"io/ioutil"
	"math/rand"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
)

func TestImportWithoutRetrievalTwoUsers(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ipfsAPI, ipfsMAddr := it.CreateIPFS(t)
	addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
	manager, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfsAPI)
	defer closeManager()

	// Store some data with User 1.
	auth, err := manager.Create(context.Background())
	require.NoError(t, err)
	time.Sleep(time.Second * 3) // Wait for funding txn to finish.
	fapi1, err := manager.GetByAuthToken(auth.Token)
	require.NoError(t, err)
	r := rand.New(rand.NewSource(22))
	c, _ := it.AddRandomFile(t, r, ipfsAPI)
	jid, err := fapi1.PushStorageConfig(c)
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi1, jid, ffs.Success)

	// Grab the DealID from the created deal.
	si1, err := fapi1.StorageInfo(c)
	require.NoError(t, err)
	si1p := si1.Cold.Filecoin.Proposals[0]

	// Create some User 2, import the DealIDs from User 1.
	// Make the import without unfreeze, so just import deals
	// and check StorageInfo is what we expect.
	auth, err = manager.Create(context.Background())
	require.NoError(t, err)
	require.NoError(t, err)
	time.Sleep(time.Second * 3) // Wait for funding txn to finish.
	fapi2, err := manager.GetByAuthToken(auth.Token)
	require.NoError(t, err)
	config := fapi2.DefaultStorageConfig().WithHotEnabled(false)
	jid, err = fapi2.PushStorageConfig(c, api.WithDealImport([]uint64{si1p.DealID}), api.WithStorageConfig(config))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi2, jid, ffs.Success)

	// Now compare that User 2 active deals for the Cid matches the same
	// data of User 1. That should be true, since User 2 imported the deal
	// created by User 1.
	si2, err := fapi2.StorageInfo(c)
	require.NoError(t, err)
	require.Equal(t, fapi2.ID(), si2.APIID)
	require.Equal(t, c, si2.Cid)
	require.Equal(t, jid, si2.JobID)
	require.Len(t, si2.Cold.Filecoin.Proposals, 1)
	si2p := si2.Cold.Filecoin.Proposals[0]
	require.Equal(t, si1p.DealID, si2p.DealID)
	require.Equal(t, si1p.PieceCid, si2p.PieceCid)
	require.Equal(t, si1p.Duration, si2p.Duration)
	require.Equal(t, si1p.StartEpoch, si2p.StartEpoch)
	require.Equal(t, si1p.Miner, si2p.Miner)
	require.Equal(t, si1.Cold.Filecoin.Size, si2.Cold.Filecoin.Size)
}

func TestImportWithRetrievalSingleUser(t *testing.T) {
	t.Parallel()

	ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	// Add some data to Filecoin.
	r := rand.New(rand.NewSource(22))
	c, data := it.AddRandomFile(t, r, ipfsAPI)
	cfg := fapi.DefaultStorageConfig().WithHotEnabled(false).WithHotAllowUnfreeze(true)
	jid, err := fapi.PushStorageConfig(c, api.WithStorageConfig(cfg))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)

	// Grab the DealID from the created deal.
	si1, err := fapi.StorageInfo(c)
	require.NoError(t, err)
	si1p := si1.Cold.Filecoin.Proposals[0]

	// Remove the Cid from the user.
	jid, err = fapi.PushStorageConfig(c, api.WithOverride(true), api.WithStorageConfig(cfg.WithColdEnabled(false)))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	err = fapi.Remove(c)
	require.NoError(t, err)
	ctx := context.Background()
	// Delete the cid data from go-ipfs, so we're clean.
	err = ipfsAPI.Dag().Remove(ctx, c)
	require.NoError(t, err)

	// Start a *new* storage config but with the deal import opt with the DealID
	// that still should be active in the Filecoin network.
	cfg = fapi.DefaultStorageConfig().WithHotEnabled(true).WithHotAllowUnfreeze(true)
	jid, err = fapi.PushStorageConfig(c, api.WithStorageConfig(cfg), api.WithDealImport([]uint64{si1p.DealID}))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	it.RequireStorageConfig(t, fapi, c, &cfg)

	// Check that the retrieved data matches the original data.
	re, err := fapi.Get(ctx, c)
	require.NoError(t, err)
	fetched, err := ioutil.ReadAll(re)
	require.NoError(t, err)
	require.True(t, bytes.Equal(data, fetched))
	it.RequireRetrievalDealRecord(t, fapi, c)
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/integrationtest.go ---
package integrationtest

import (
	"bytes"
	"context"
	"fmt"
	"math/rand"
	"time"

	lapi "github.com/filecoin-project/lotus/api"
	"github.com/ipfs/go-cid"
	ipfsfiles "github.com/ipfs/go-ipfs-files"
	httpapi "github.com/ipfs/go-ipfs-http-client"
	"github.com/ipfs/interface-go-ipfs-core/options"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

// CreateIPFS creates a docker container running IPFS.
func CreateIPFS(t tests.TestingTWithCleanup) (*httpapi.HttpApi, string) {
	ipfsDocker, cls := tests.LaunchIPFSDocker(t)
	t.Cleanup(cls)
	ipfsAddr := util.MustParseAddr("/ip4/127.0.0.1/tcp/" + ipfsDocker.GetPort("5001/tcp"))
	ipfs, err := httpapi.NewApi(ipfsAddr)
	require.NoError(t, err)
	bridgeIP := ipfsDocker.Container.NetworkSettings.Networks["bridge"].IPAddress
	ipfsDockerMAddr := fmt.Sprintf("/ip4/%s/tcp/5001", bridgeIP)

	return ipfs, ipfsDockerMAddr
}

// RequireIpfsUnpinnedCid checks that a cid is unpinned in the IPFS node.
func RequireIpfsUnpinnedCid(ctx context.Context, t require.TestingT, cid cid.Cid, ipfsAPI *httpapi.HttpApi) {
	pins, err := ipfsAPI.Pin().Ls(ctx, options.Pin.Ls.Recursive())
	require.NoError(t, err)
	for p := range pins {
		require.NotEqual(t, cid, p.Path().Cid(), "Cid isn't unpinned from IPFS node")
	}
}

// RequireIpfsPinnedCid checks that a cid is pinned in the IPFS node.
func RequireIpfsPinnedCid(ctx context.Context, t require.TestingT, cid cid.Cid, ipfsAPI *httpapi.HttpApi) {
	pins, err := ipfsAPI.Pin().Ls(ctx)
	require.NoError(t, err)

	pinned := false
	for p := range pins {
		if p.Path().Cid() == cid {
			pinned = true
			break
		}
	}
	require.True(t, pinned, "Cid should be pinned in IPFS node")
}

// RequireFilUnstored checks that a cid is not stored in the Filecoin network.
func RequireFilUnstored(ctx context.Context, t require.TestingT, client *lapi.FullNodeStruct, c cid.Cid) {
	offers, err := client.ClientFindData(ctx, c, nil)
	require.NoError(t, err)
	require.Empty(t, offers)
}

// RequireFilStored cehcks that a cid is stored in the Filecoin network.
func RequireFilStored(ctx context.Context, t require.TestingT, client *lapi.FullNodeStruct, c cid.Cid) {
	offers, err := client.ClientFindData(ctx, c, nil)
	require.NoError(t, err)
	require.NotEmpty(t, offers)
}

// RequireStorageJobState checks if the current status of a job matches one of the specified statuses.
func RequireStorageJobState(t require.TestingT, fapi *api.API, jid ffs.JobID, statuses ...ffs.JobStatus) ffs.StorageJob {
	job, err := fapi.GetStorageJob(jid)
	require.NoError(t, err)
	require.Contains(t, statuses, job.Status)
	return job
}

// RequireEventualJobState watches a Job for a desired status.
func RequireEventualJobState(t require.TestingT, fapi *api.API, jid ffs.JobID, status ffs.JobStatus) ffs.StorageJob {
	ch := make(chan ffs.StorageJob, 10)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	var err error
	go func() {
		err = fapi.WatchJobs(ctx, ch, jid)
		close(ch)
	}()
	stop := false
	var res ffs.StorageJob
	for !stop {
		select {
		case <-time.After(120 * time.Second):
			t.Errorf("waiting for job update timeout")
			t.FailNow()
		case job, ok := <-ch:
			require.True(t, ok)
			require.Equal(t, jid, job.ID)
			if job.Status == ffs.Queued || job.Status == ffs.Executing {
				if job.Status == status {
					stop = true
					res = job
				}
				continue
			}
			require.Equal(t, status, job.Status, job.ErrCause)
			stop = true
			res = job
		}
	}
	require.NoError(t, err)
	return res
}

// RequireStorageConfig compares a cid storage config against a target.
func RequireStorageConfig(t require.TestingT, fapi *api.API, c cid.Cid, config *ffs.StorageConfig) {
	if config == nil {
		defConfig := fapi.DefaultStorageConfig()
		config = &defConfig
	}
	currentConfigs, err := fapi.GetStorageConfigs(c)
	require.NoError(t, err)
	require.Equal(t, *config, currentConfigs[c])
}

// RequireStorageDealRecord checks that a storage deal record exist for a cid.
func RequireStorageDealRecord(t require.TestingT, fapi *api.API, c cid.Cid) {
	time.Sleep(time.Second)
	recs, err := fapi.StorageDealRecords(deals.WithIncludeFinal(true))
	require.NoError(t, err)
	require.Len(t, recs, 1)
	require.Equal(t, c, recs[0].RootCid)
}

// RequireRetrievalDealRecord checks that a retrieval deal record exits for a cid.
func RequireRetrievalDealRecord(t require.TestingT, fapi *api.API, c cid.Cid) {
	recs, err := fapi.RetrievalDealRecords()
	require.NoError(t, err)
	require.Len(t, recs, 1)
	require.Equal(t, c, recs[0].DealInfo.RootCid)
}

// RandomBytes returns a slice of random bytes of a desired size.
func RandomBytes(r *rand.Rand, size int) []byte {
	buf := make([]byte, size)
	_, _ = r.Read(buf)
	return buf
}

// AddRandomFile adds a random file to the IPFS node.
func AddRandomFile(t require.TestingT, r *rand.Rand, ipfs *httpapi.HttpApi) (cid.Cid, []byte) {
	return AddRandomFileSize(t, r, ipfs, 1600)
}

// AddRandomFileSize adds a random file with a specified size to the IPFS node.
func AddRandomFileSize(t require.TestingT, r *rand.Rand, ipfs *httpapi.HttpApi, size int) (cid.Cid, []byte) {
	data := RandomBytes(r, size)
	node, err := ipfs.Unixfs().Add(context.Background(), ipfsfiles.NewReaderFile(bytes.NewReader(data)), options.Unixfs.Pin(false))
	if err != nil {
		t.Errorf("error adding random file: %s", err)
		t.FailNow()
	}
	return node.Cid(), data
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/logger/logger_test.go ---
package logger

import (
	"context"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	_ = logging.SetLogLevel("rpc", "FATAL")
	os.Exit(m.Run())
}

func TestLogHistory(t *testing.T) {
	t.Parallel()
	ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	r := rand.New(rand.NewSource(22))
	c, _ := it.AddRandomFile(t, r, ipfs)
	jid, err := fapi.PushStorageConfig(c)
	require.NoError(t, err)
	job := it.RequireEventualJobState(t, fapi, jid, ffs.Success)

	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)
	defer cancel()
	ch := make(chan ffs.LogEntry, 100)
	go func() {
		err = fapi.WatchLogs(ctx, ch, c, api.WithHistory(true))
		close(ch)
	}()
	var lgs []ffs.LogEntry
	for le := range ch {
		require.Equal(t, c, le.Cid)
		require.Equal(t, job.ID, le.Jid)
		require.NotEmpty(t, le.Msg)
		if len(lgs) > 0 {
			require.True(t, le.Timestamp.After(lgs[len(lgs)-1].Timestamp))
		}

		lgs = append(lgs, le)
	}
	require.NoError(t, err)
	require.Greater(t, len(lgs), 3) // Ask to have more than 3 log messages.
}

func TestCidLogger(t *testing.T) {
	t.Parallel()
	t.Run("WithNoFilters", func(t *testing.T) {
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfs)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)

		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		ch := make(chan ffs.LogEntry)
		go func() {
			err = fapi.WatchLogs(ctx, ch, cid)
			close(ch)
		}()
		stop := false
		for !stop {
			select {
			case le, ok := <-ch:
				if !ok {
					require.NoError(t, err)
					stop = true
					continue
				}
				cancel()
				require.Equal(t, cid, le.Cid)
				require.Equal(t, jid, le.Jid)
				require.True(t, time.Since(le.Timestamp) < time.Second*5)
				require.NotEmpty(t, le.Msg)
			case <-time.After(time.Second):
				t.Fatal("no cid logs were received")
			}
		}

		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, nil)
	})
	t.Run("WithJidFilter", func(t *testing.T) {
		t.Run("CorrectJid", func(t *testing.T) {
			ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfs)
			jid, err := fapi.PushStorageConfig(cid)
			require.NoError(t, err)

			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			ch := make(chan ffs.LogEntry)
			go func() {
				err = fapi.WatchLogs(ctx, ch, cid, api.WithJidFilter(jid))
				close(ch)
			}()
			stop := false
			for !stop {
				select {
				case le, ok := <-ch:
					if !ok {
						require.NoError(t, err)
						stop = true
						continue
					}
					cancel()
					require.Equal(t, cid, le.Cid)
					require.Equal(t, jid, le.Jid)
					require.True(t, time.Since(le.Timestamp) < time.Second*5)
					require.NotEmpty(t, le.Msg)
				case <-time.After(time.Second):
					t.Fatal("no cid logs were received")
				}
			}

			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, nil)
		})
		t.Run("IncorrectJid", func(t *testing.T) {
			ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
			defer cls()

			r := rand.New(rand.NewSource(22))
			cid, _ := it.AddRandomFile(t, r, ipfs)
			jid, err := fapi.PushStorageConfig(cid)
			require.NoError(t, err)

			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			ch := make(chan ffs.LogEntry)
			go func() {
				fakeJid := ffs.NewJobID()
				err = fapi.WatchLogs(ctx, ch, cid, api.WithJidFilter(fakeJid))
				close(ch)
			}()
			select {
			case <-ch:
				t.Fatal("the channels shouldn't receive any log messages")
			case <-time.After(3 * time.Second):
			}
			require.NoError(t, err)

			it.RequireEventualJobState(t, fapi, jid, ffs.Success)
			it.RequireStorageConfig(t, fapi, cid, nil)
		})
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/manager/manager.go ---
package manager

import (
	"context"
	"fmt"
	"math/big"
	"time"

	"github.com/filecoin-project/go-address"
	lapi "github.com/filecoin-project/lotus/api"
	"github.com/ipfs/go-datastore"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/ffs/coreipfs"
	"github.com/textileio/powergate/v2/ffs/filcold"
	"github.com/textileio/powergate/v2/ffs/joblogger"
	"github.com/textileio/powergate/v2/ffs/manager"
	"github.com/textileio/powergate/v2/ffs/minerselector/fixed"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	"github.com/textileio/powergate/v2/filchain"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"

	httpapi "github.com/ipfs/go-ipfs-http-client"
	dealsModule "github.com/textileio/powergate/v2/deals/module"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
	lotusWallet "github.com/textileio/powergate/v2/wallet/lotuswallet"
)

const (
	iWalletBal int64 = 4000000000000000
)

// NewAPI returns a new set of components for FFS.
func NewAPI(t tests.TestingTWithCleanup, numMiners, speed int) (*httpapi.HttpApi, *lapi.FullNodeStruct, *api.API, func()) {
	ds := tests.NewTxMapDatastore()
	ipfs, ipfsMAddr := it.CreateIPFS(t)
	addr, clientBuilder, ms := NewDevnet(t, numMiners, speed, ipfsMAddr)
	manager, closeManager := NewFFSManager(t, ds, clientBuilder, addr, ms, ipfs)
	auth, err := manager.Create(context.Background())
	require.NoError(t, err)
	time.Sleep(time.Second * 3) // Wait for funding txn to finish.
	fapi, err := manager.GetByAuthToken(auth.Token)
	require.NoError(t, err)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	return ipfs, client, fapi, func() {
		err := fapi.Close()
		require.NoError(t, err)
		closeManager()
		cls()
	}
}

// NewDevnet creates a localnet.
func NewDevnet(t tests.TestingTWithCleanup, numMiners, speed int, ipfsAddr string) (address.Address, lotus.ClientBuilder, ffs.MinerSelector) {
	client, addr, _ := tests.CreateLocalDevnetWithIPFS(t, numMiners, speed, ipfsAddr, false)
	addrs := make([]string, numMiners)
	for i := 0; i < numMiners; i++ {
		addrs[i] = fmt.Sprintf("f0%d", 1000+i)
	}

	fixedMiners := make([]fixed.Miner, len(addrs))
	for i, a := range addrs {
		fixedMiners[i] = fixed.Miner{Addr: a, Country: "China", EpochPrice: 500000000}
	}
	ms := fixed.New(fixedMiners)
	return addr, client, ms
}

// NewFFSManager returns a new FFS manager.
func NewFFSManager(t require.TestingT, ds datastore.TxnDatastore, clientBuilder lotus.ClientBuilder, masterAddr address.Address, ms ffs.MinerSelector, ipfsClient *httpapi.HttpApi) (*manager.Manager, func()) {
	mg, _, err := NewCustomFFSManager(t, ds, clientBuilder, masterAddr, ms, ipfsClient, 0)
	return mg, err
}

// NewCustomFFSManager returns a new customized FFS manager.
func NewCustomFFSManager(t require.TestingT, ds datastore.TxnDatastore, cb lotus.ClientBuilder, masterAddr address.Address, ms ffs.MinerSelector, ipfsClient *httpapi.HttpApi, minimumPieceSize uint64) (*manager.Manager, *coreipfs.CoreIpfs, func()) {
	dm, err := dealsModule.New(txndstr.Wrap(ds, "deals"), cb, util.AvgBlockTime, time.Minute*10)
	require.NoError(t, err)

	fchain := filchain.New(cb)
	l := joblogger.New(txndstr.Wrap(ds, "ffs/joblogger"))
	lsm, err := lotus.NewSyncMonitor(cb)
	require.NoError(t, err)
	cl := filcold.New(ms, dm, nil, ipfsClient, fchain, l, lsm, minimumPieceSize, 1, time.Hour)
	hl, err := coreipfs.New(ds, ipfsClient, l)
	require.NoError(t, err)
	sched, err := scheduler.New(txndstr.Wrap(ds, "ffs/scheduler"), l, hl, cl, 10, time.Minute*10, nil, scheduler.GCConfig{AutoGCInterval: 0})
	require.NoError(t, err)

	wm, err := lotusWallet.New(cb, masterAddr, *big.NewInt(iWalletBal), false, "")
	require.NoError(t, err)

	manager, err := manager.New(ds, wm, dm, sched, false, true)
	require.NoError(t, err)
	err = manager.SetDefaultStorageConfig(ffs.StorageConfig{
		Hot: ffs.HotConfig{
			Enabled:       true,
			AllowUnfreeze: false,
			Ipfs: ffs.IpfsConfig{
				AddTimeout: 10,
			},
		},
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				ExcludedMiners:  nil,
				DealMinDuration: util.MinDealDuration,
				RepFactor:       1,
			},
		},
	})
	require.NoError(t, err)

	return manager, hl, func() {
		if err := manager.Close(); err != nil {
			t.Errorf("closing api: %s", err)
			t.FailNow()
		}
		if err := sched.Close(); err != nil {
			t.Errorf("closing scheduler: %s", err)
			t.FailNow()
		}
		if err := l.Close(); err != nil {
			t.Errorf("closing joblogger: %s", err)
			t.FailNow()
		}
	}
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/renew/renew_test.go ---
package renew

import (
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"

	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestRenew(t *testing.T) {
	// Unfortunately, a minimum deal duration of 180 *days* is enforced at
	// the Filecoin network. That's a lot of blocks to wait in a CI test.
	// We should eventually have some workaround this in the localnet.
	t.SkipNow()

	t.Parallel()
	ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	ra := rand.New(rand.NewSource(22))
	cid, _ := it.AddRandomFile(t, ra, ipfsAPI)

	renewThreshold := 12600
	config := fapi.DefaultStorageConfig().WithColdFilDealDuration(util.MinDealDuration+int64(100)).WithColdFilRenew(true, renewThreshold)
	jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	it.RequireStorageConfig(t, fapi, cid, &config)

	i, err := fapi.StorageInfo(cid)
	require.NoError(t, err)
	require.Equal(t, 1, len(i.Cold.Filecoin.Proposals))

	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()
	epochDeadline := 200
Loop:
	for range ticker.C {
		i, err := fapi.StorageInfo(cid)
		require.NoError(t, err)

		firstDeal := i.Cold.Filecoin.Proposals[0]
		require.NoError(t, err)
		if len(i.Cold.Filecoin.Proposals) < 2 {
			require.Greater(t, epochDeadline, 0)
			continue
		}

		require.Equal(t, 2, len(i.Cold.Filecoin.Proposals))
		require.True(t, firstDeal.Renewed)

		newDeal := i.Cold.Filecoin.Proposals[1]
		require.NotEqual(t, firstDeal.DealID, newDeal.DealID)
		require.False(t, newDeal.Renewed)
		require.Greater(t, newDeal.Duration, config.Cold.Filecoin.DealMinDuration)
		break Loop
	}
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/repair/repair_test.go ---
package repair

import (
	"context"
	"math/rand"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	os.Exit(m.Run())
}

// This isn't very nice way to test for repair. The main problem is that now
// deal start is buffered for future start for 10000 blocks at the Lotus level.
// Se we can't wait that much on a devnet. That setup has some ToDo comments so
// most prob will change and we can do some nicier test here.
// Better than no test is some test, so this tests that the repair logic gets triggered
// and the related Job ran successfully.
func TestRepair(t *testing.T) {
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		scheduler.RepairEvalFrequency = time.Second * 30
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		r := rand.New(rand.NewSource(22))
		cid, _ := it.AddRandomFile(t, r, ipfs)
		config := fapi.DefaultStorageConfig().WithRepairable(true)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)

		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		ch := make(chan ffs.LogEntry)
		go func() {
			err = fapi.WatchLogs(ctx, ch, cid, api.WithHistory(true))
			close(ch)
		}()
		stop := false
		for !stop {
			select {
			case le, ok := <-ch:
				if !ok {
					require.NoError(t, err)
					stop = true
					continue
				}
				// Expected message: "Job %s was queued for repair evaluation."
				if strings.Contains(le.Msg, "was queued for repair evaluation.") {
					parts := strings.SplitN(le.Msg, " ", 3)
					require.Equal(t, 3, len(parts), "Log message is malformed")
					jid := ffs.JobID(parts[1])
					it.RequireEventualJobState(t, fapi, jid, ffs.Success)
					it.RequireStorageConfig(t, fapi, cid, &config)
					cancel()
				}
			case <-time.After(time.Second * 10):
				t.Errorf("no cid logs related with repairing were received")
				t.FailNow()
			}
		}
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/repfactor/repfactor_test.go ---
package repfactor

import (
	"fmt"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestRepFactor(t *testing.T) {
	t.Parallel()
	rfs := []int{1, 2}
	for _, rf := range rfs {
		rf := rf
		t.Run(fmt.Sprintf("%d", rf), func(t *testing.T) {
			t.Parallel()
			tests.RunFlaky(t, func(t *tests.FlakyT) {
				r := rand.New(rand.NewSource(22))
				ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, rf, 300)
				defer cls()
				cid, _ := it.AddRandomFile(t, r, ipfsAPI)
				config := fapi.DefaultStorageConfig().WithColdFilRepFactor(rf)
				jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
				require.NoError(t, err)
				it.RequireEventualJobState(t, fapi, jid, ffs.Success)
				it.RequireStorageConfig(t, fapi, cid, &config)

				cinfo, err := fapi.StorageInfo(cid)
				require.NoError(t, err)
				require.Equal(t, rf, len(cinfo.Cold.Filecoin.Proposals))
			})
		})
	}
}

func TestRepFactorIncrease(t *testing.T) {
	t.SkipNow()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		r := rand.New(rand.NewSource(22))
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 2, 300)
		defer cls()
		cid, _ := it.AddRandomFile(t, r, ipfsAPI)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, nil)

		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		require.Equal(t, 1, len(cinfo.Cold.Filecoin.Proposals))
		firstProposal := cinfo.Cold.Filecoin.Proposals[0]

		config := fapi.DefaultStorageConfig().WithColdFilRepFactor(2)
		jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)
		cinfo, err = fapi.StorageInfo(cid)
		require.NoError(t, err)
		require.Equal(t, 2, len(cinfo.Cold.Filecoin.Proposals))
		require.Contains(t, cinfo.Cold.Filecoin.Proposals, firstProposal)
	})
}

func TestRepFactorDecrease(t *testing.T) {
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		r := rand.New(rand.NewSource(22))
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 2, 300)
		defer cls()

		cid, _ := it.AddRandomFile(t, r, ipfsAPI)
		config := fapi.DefaultStorageConfig().WithColdFilRepFactor(2)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)

		cinfo, err := fapi.StorageInfo(cid)
		require.NoError(t, err)
		require.Equal(t, 2, len(cinfo.Cold.Filecoin.Proposals))

		config = fapi.DefaultStorageConfig().WithColdFilRepFactor(1)
		jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)

		cinfo, err = fapi.StorageInfo(cid)
		require.NoError(t, err)
		require.Equal(t, 2, len(cinfo.Cold.Filecoin.Proposals))
	})
}

func TestRenewWithDecreasedRepFactor(t *testing.T) {
	// Too flaky for CI.
	t.SkipNow()
	ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 2, 300)
	defer cls()

	ra := rand.New(rand.NewSource(22))
	cid, _ := it.AddRandomFile(t, ra, ipfsAPI)

	renewThreshold := 12600
	config := fapi.DefaultStorageConfig().WithColdFilDealDuration(int64(100)).WithColdFilRenew(true, renewThreshold).WithColdFilRepFactor(2)
	jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	it.RequireStorageConfig(t, fapi, cid, &config)

	// Now decrease RepFactor to 1, so the renewal should consider this.
	// Both now active deals shouldn't be renewed, only one of them.
	config = config.WithColdFilRepFactor(1)
	jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	it.RequireStorageConfig(t, fapi, cid, &config)

	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()
	epochDeadline := 200
Loop:
	for range ticker.C {
		i, err := fapi.StorageInfo(cid)
		require.NoError(t, err)

		firstDeal := i.Cold.Filecoin.Proposals[0]
		secondDeal := i.Cold.Filecoin.Proposals[1]
		require.NoError(t, err)
		if len(i.Cold.Filecoin.Proposals) < 3 {
			epochDeadline--
			require.Greater(t, epochDeadline, 0)
			continue
		}

		require.Equal(t, 3, len(i.Cold.Filecoin.Proposals))
		// Only one of the two deas should be renewed
		require.True(t, (firstDeal.Renewed && !secondDeal.Renewed) || (secondDeal.Renewed && !firstDeal.Renewed))

		newDeal := i.Cold.Filecoin.Proposals[2]
		require.NotEqual(t, firstDeal.DealID, newDeal.DealID)
		require.False(t, newDeal.Renewed)
		require.Greater(t, newDeal.Duration, config.Cold.Filecoin.DealMinDuration)
		break Loop
	}
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/replace/replace_test.go ---
package replace

import (
	"context"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestPushCidReplace(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	ipfs, client, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	r := rand.New(rand.NewSource(22))
	c1, _ := it.AddRandomFile(t, r, ipfs)

	// Test case that an unknown cid is being replaced
	nc, _ := util.CidFromString("Qmc5gCcjYypU7y28oCALwfSvxCBskLuPKWpK4qpterKC7z")
	_, err := fapi.Replace(nc, c1)
	require.Equal(t, api.ErrReplacedCidNotFound, err)

	// Test tipical case
	config := fapi.DefaultStorageConfig().WithColdEnabled(false)
	jid, err := fapi.PushStorageConfig(c1, api.WithStorageConfig(config))
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	it.RequireStorageConfig(t, fapi, c1, &config)

	c2, _ := it.AddRandomFile(t, r, ipfs)
	jid, err = fapi.Replace(c1, c2)
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)

	configs2, err := fapi.GetStorageConfigs(c2)
	require.NoError(t, err)
	require.Equal(t, config.Cold.Enabled, configs2[c2].Cold.Enabled)

	_, err = fapi.GetStorageConfigs(c1)
	require.Equal(t, api.ErrNotFound, err)

	it.RequireIpfsUnpinnedCid(ctx, t, c1, ipfs)
	it.RequireIpfsPinnedCid(ctx, t, c2, ipfs)
	it.RequireFilUnstored(ctx, t, client, c1)
	it.RequireFilUnstored(ctx, t, client, c2)
}

func TestDoubleReplace(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ipfs, ipfsMAddr := it.CreateIPFS(t)
	addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
	m, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)
	defer closeManager()

	// This will ask for a new API to the manager, and do a replace. Always the same replace.
	testAddThenReplace := func() {
		auth, err := m.Create(context.Background())
		require.NoError(t, err)
		time.Sleep(time.Second * 2) // Give some time to the funding transaction

		fapi, err := m.GetByAuthToken(auth.Token)
		require.NoError(t, err)

		r := rand.New(rand.NewSource(22))
		c1, _ := it.AddRandomFile(t, r, ipfs)
		config := fapi.DefaultStorageConfig().WithColdEnabled(false)
		jid, err := fapi.PushStorageConfig(c1, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, c1, &config)

		c2, _ := it.AddRandomFile(t, r, ipfs)
		jid, err = fapi.Replace(c1, c2)
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
	}

	// Test the same workflow in different APIs instaneces,
	// but same hot & cold storage.
	testAddThenReplace()
	testAddThenReplace()
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/retrieval/retrieval_test.go ---
package retrieval

import (
	"context"
	"math/rand"
	"os"
	"testing"
	"time"

	"github.com/ipfs/go-cid"
	cbornode "github.com/ipfs/go-ipld-cbor"
	format "github.com/ipfs/go-ipld-format"
	logging "github.com/ipfs/go-log/v2"
	mh "github.com/multiformats/go-multihash"
	"github.com/stretchr/testify/require"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

type rootType struct {
	MyLinks []cid.Cid
}

func TestMain(m *testing.M) {
	cbornode.RegisterCborType(rootType{})
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestPartialRetrievalFlow(t *testing.T) {
	t.SkipNow() // Skip since Lotus isn't ready for this.
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ctx := context.Background()
		ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()
		_ = ctx
		_ = fapi

		// Generate some data to run a selector.
		numInternalNodes := 3
		nodes := make([]format.Node, numInternalNodes)
		r := rand.New(rand.NewSource(22))
		for i := 0; i < numInternalNodes; i++ {
			buf := make([]byte, 500)
			_, _ = r.Read(buf)
			n, err := cbornode.WrapObject(buf, mh.SHA2_256, -1)
			require.NoError(t, err)
			nodes[i] = n
		}
		err := ipfs.Dag().AddMany(context.Background(), nodes)
		require.NoError(t, err)

		root := rootType{
			MyLinks: make([]cid.Cid, numInternalNodes),
		}
		for i, v := range nodes {
			root.MyLinks[i] = v.Cid()
		}
		rn, err := cbornode.WrapObject(root, mh.SHA2_256, -1)
		require.NoError(t, err)
		err = ipfs.Dag().Add(context.Background(), rn)
		require.NoError(t, err)

		/*
			c := rn.Cid() // Cid of data.

			// Make a deal with a IPLD graph that makes sense
			// to do partial retrieval.
			jid, err := fapi.PushStorageConfig(c)
			require.NoError(t, err)
			it.RequireJobState(t, fapi, jid, ffs.Success)

			// Current partial retrievals should be 0.
			prs, err := fapi.GetPartialRetrievals(c)
			require.NoError(t, err)
			require.Len(t, 0, prs)
			it.RequireIpfsUnpinnedCid(context.Background(), t, nodes[1].Cid(), ipfs)

			// Do partial retrieval.
			selector := "/Link/2/Hash/Qm...."
			jid, err = fapi.PushPartialRetrieval(c, selector)
			require.NoError(t, err)
			it.RequireJobState(t, fapi, jid, ffs.Success)
			it.RequireIpfsPinnedCid(context.Background(), t, nodes[1].Cid(), ipfs)

			// Current partial retrievals should be 1.
			prs, err = fapi.GetPartialRetrievals(c)
			require.NoError(t, err)
			require.Len(t, 1, prs)
			pr := prs[0]
			require.Equal(t, pr.RootCid, c)
			require.Equal(t, pr.Selector, selector)
			require.Equal(t, nodes[1].Cid(), pr.DataCid) // Change assertion to expected Cid.

			rr, err := fapi.Get(ctx, pr.DataCid)
			require.NoError(t, err)
			fetched, err := ioutil.ReadAll(rr)
			require.NoError(t, err)
			require.True(t, bytes.Equal(nodes[1].RawData(), fetched))

			// Remove it. Check that we have 0 partial retrievals again, and
			// check was unpined from IPFS node.
			err = fapi.RemovePartialRetrieval(c)
			require.NoError(t, err)
			prs, err = fapi.GetPartialRetrievals(c)
			require.NoError(t, err)
			require.Len(t, 0, prs)
			it.RequireIpfsUnpinnedCid(context.Background(), t, nodes[1].Cid(), ipfs)
		*/
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/scheduler/scheduler_test.go ---
package scheduler

import (
	"context"
	"math/rand"
	"os"
	"testing"
	"time"

	"github.com/ipfs/go-cid"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"

	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestJobCancelation(t *testing.T) {
	r := rand.New(rand.NewSource(22))
	ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	cid, _ := it.AddRandomFile(t, r, ipfsAPI)
	jid, err := fapi.PushStorageConfig(cid)
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Executing)
	time.Sleep(time.Second * 2)

	err = fapi.CancelJob(jid)
	require.NoError(t, err)

	// Assert that the Job status is Canceled, *and* was
	// finished _fast_.
	before := time.Now()
	it.RequireEventualJobState(t, fapi, jid, ffs.Canceled)
	require.True(t, time.Since(before) < time.Second)
}

func TestParallelExecution(t *testing.T) {
	t.Parallel()
	ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	r := rand.New(rand.NewSource(22))
	n := 3
	cids := make([]cid.Cid, n)
	jids := make([]ffs.JobID, n)
	for i := 0; i < n; i++ {
		cid, _ := it.AddRandomFile(t, r, ipfs)
		jid, err := fapi.PushStorageConfig(cid)
		require.NoError(t, err)
		cids[i] = cid
		jids[i] = jid
		// Add some sleep time to avoid all of them
		// being batched in the same scheduler run.
		time.Sleep(time.Millisecond * 100)
	}
	// Check that all jobs should be immediately in the Executing status, since
	// the default max parallel runs is 50. So all should get in.
	for i := 0; i < len(jids); i++ {
		it.RequireEventualJobState(t, fapi, jids[i], ffs.Executing)
	}

	// Now just check that all of them finish successfully.
	for i := 0; i < len(jids); i++ {
		it.RequireEventualJobState(t, fapi, jids[i], ffs.Executing)
		it.RequireStorageConfig(t, fapi, cids[i], nil)
	}
}

func TestResumeScheduler(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()
	ipfs, ipfsMAddr := it.CreateIPFS(t)
	addr, client, ms := itmanager.NewDevnet(t, 1, 300, ipfsMAddr)
	manager, closeManager := itmanager.NewFFSManager(t, ds, client, addr, ms, ipfs)
	auth, err := manager.Create(context.Background())
	require.NoError(t, err)
	time.Sleep(time.Second * 3) // Wait for funding txn to finish.
	fapi, err := manager.GetByAuthToken(auth.Token)
	require.NoError(t, err)

	r := rand.New(rand.NewSource(22))
	c, _ := it.AddRandomFile(t, r, ipfs)
	jid, err := fapi.PushStorageConfig(c)
	require.NoError(t, err)

	time.Sleep(time.Second * 3)
	ds2, err := ds.Clone()
	require.NoError(t, err)
	closeManager()

	manager, closeManager = itmanager.NewFFSManager(t, ds2, client, addr, ms, ipfs)
	defer closeManager()
	fapi, err = manager.GetByAuthToken(auth.Token) // Get same FFS instance again
	require.NoError(t, err)
	it.RequireEventualJobState(t, fapi, jid, ffs.Success)

	sh, err := fapi.StorageInfo(c)
	require.NoError(t, err)
	require.Equal(t, 1, len(sh.Cold.Filecoin.Proposals)) // Check only one deal still exists.
}

func TestFailedJobMessage(t *testing.T) {
	t.Parallel()
	ipfs, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	r := rand.New(rand.NewSource(22))
	// Add a file size that would be bigger than the
	// sector size. This should make the deal fail on the miner.
	c1, _ := it.AddRandomFileSize(t, r, ipfs, 2000)

	jid, err := fapi.PushStorageConfig(c1)
	require.NoError(t, err)
	job := it.RequireEventualJobState(t, fapi, jid, ffs.Failed)
	require.NotEmpty(t, job.ErrCause)
	require.Len(t, job.DealErrors, 1)
	de := job.DealErrors[0]
	require.False(t, de.ProposalCid.Defined())
	require.NotEmpty(t, de.Miner)
	require.Equal(t, "data doesn't fit in a sector", de.Message)
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/unfreeze/unfreeze_test.go ---
package unfreeze

import (
	"bytes"
	"context"
	"io/ioutil"
	"math/rand"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	it "github.com/textileio/powergate/v2/ffs/integrationtest"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestUnfreeze(t *testing.T) {
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		ra := rand.New(rand.NewSource(22))
		ctx := context.Background()
		cid, data := it.AddRandomFile(t, ra, ipfsAPI)

		config := fapi.DefaultStorageConfig().WithHotEnabled(false).WithHotAllowUnfreeze(true)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)

		_, err = fapi.Get(ctx, cid)
		require.Equal(t, api.ErrHotStorageDisabled, err)

		err = ipfsAPI.Dag().Remove(ctx, cid)
		require.NoError(t, err)
		config = config.WithHotEnabled(true)
		jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)
		it.RequireStorageConfig(t, fapi, cid, &config)

		r, err := fapi.Get(ctx, cid)
		require.NoError(t, err)
		fetched, err := ioutil.ReadAll(r)
		require.NoError(t, err)
		require.True(t, bytes.Equal(data, fetched))
		it.RequireRetrievalDealRecord(t, fapi, cid)
	})
}

func TestUnfreezeRecords(t *testing.T) {
	t.Parallel()
	tests.RunFlaky(t, func(t *tests.FlakyT) {
		ipfsAPI, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
		defer cls()

		// Step 1. Produce a Filecoin retrieval.
		ra := rand.New(rand.NewSource(22))
		ctx := context.Background()
		cid, _ := it.AddRandomFile(t, ra, ipfsAPI)

		config := fapi.DefaultStorageConfig().WithHotEnabled(false).WithHotAllowUnfreeze(true)
		jid, err := fapi.PushStorageConfig(cid, api.WithStorageConfig(config))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)

		err = ipfsAPI.Dag().Remove(ctx, cid)
		require.NoError(t, err)
		config = config.WithHotEnabled(true)
		jid, err = fapi.PushStorageConfig(cid, api.WithStorageConfig(config), api.WithOverride(true))
		require.NoError(t, err)
		it.RequireEventualJobState(t, fapi, jid, ffs.Success)

		// Step 2. Check that the Retrieval Record has appropriate values.
		recs, err := fapi.RetrievalDealRecords()
		require.NoError(t, err)
		require.Len(t, recs, 1)

		rr := recs[0]
		require.Equal(t, cid, rr.DealInfo.RootCid)
		dtStart := time.Unix(rr.DataTransferStart, 0)
		dtEnd := time.Unix(rr.DataTransferEnd, 0)
		require.False(t, dtStart.IsZero())
		require.False(t, dtEnd.IsZero())
		// Retrievals happen too fast in CI to enforce
		// a strict start < end, so we consider == too.
		// The designed granularity is 'seconds', not 'nanoseconds'.
		require.True(t, dtStart.Before(dtEnd) || dtStart.Equal(dtEnd))
		require.Empty(t, rr.ErrMsg)
		require.Greater(t, rr.BytesReceived, uint64(0))
	})
}

'''
'''--- Filecoin/powergate/ffs/integrationtest/wallet/wallet_test.go ---
package wallet

import (
	"context"
	"math/big"
	"os"
	"testing"
	"time"

	"github.com/filecoin-project/go-address"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs/api"
	itmanager "github.com/textileio/powergate/v2/ffs/integrationtest/manager"
	"github.com/textileio/powergate/v2/util"
)

const (
	initialBalance int64 = 4000000000000000
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 500
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestAddrs(t *testing.T) {
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	addrs := fapi.Addrs()
	require.Len(t, addrs, 1)
	require.NotEmpty(t, addrs[0].Name)
	require.NotEmpty(t, addrs[0].Addr)
}

func TestNewAddress(t *testing.T) {
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	addr, err := fapi.NewAddr(context.Background(), "my address")
	require.NoError(t, err)
	require.NotEmpty(t, addr)

	addrs := fapi.Addrs()
	require.Len(t, addrs, 2)
}

func TestNewAddressDefault(t *testing.T) {
	t.Parallel()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	addr, err := fapi.NewAddr(context.Background(), "my address", api.WithMakeDefault(true))
	require.NoError(t, err)
	require.NotEmpty(t, addr)

	defaultConf := fapi.DefaultStorageConfig()
	require.Equal(t, defaultConf.Cold.Filecoin.Addr, addr)
}
func TestSendFil(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	_, api, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	const amt int64 = 1

	balForAddress := func(addr string) (uint64, error) {
		a, err := address.NewFromString(addr)
		if err != nil {
			return 0, err
		}
		bal, err := api.WalletBalance(ctx, a)
		if err != nil {
			return 0, err
		}
		return bal.Uint64(), nil
	}

	addrs := fapi.Addrs()
	require.NotEmpty(t, addrs)

	addr1 := addrs[0].Addr

	addr2, err := fapi.NewAddr(ctx, "addr2")
	require.NoError(t, err)

	hasInitialBal := func() bool {
		bal, err := balForAddress(addr2)
		require.NoError(t, err)
		return bal == uint64(initialBalance)
	}

	hasNewBal := func() bool {
		bal, err := balForAddress(addr2)
		require.NoError(t, err)
		return bal == uint64(initialBalance+amt)
	}

	require.Eventually(t, hasInitialBal, time.Second*5, time.Second)

	_, err = fapi.SendFil(ctx, addr1, addr2, big.NewInt(amt))
	require.NoError(t, err)

	require.Eventually(t, hasNewBal, time.Second*5, time.Second)
}

func TestSignVerifyMessage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	_, _, fapi, cls := itmanager.NewAPI(t, 1, 300)
	defer cls()

	addrs := fapi.Addrs()
	bi := addrs[0]

	msg := []byte("hello world")

	sig, err := fapi.SignMessage(ctx, bi.Addr, msg)
	require.NoError(t, err)
	require.NotEmpty(t, sig)

	ok, err := fapi.VerifyMessage(ctx, bi.Addr, msg, sig)
	require.NoError(t, err)
	require.True(t, ok)

	newAddr, err := fapi.NewAddr(ctx, "new")
	require.NoError(t, err)
	ok, err = fapi.VerifyMessage(ctx, newAddr, msg, sig)
	require.NoError(t, err)
	require.False(t, ok)
}

'''
'''--- Filecoin/powergate/ffs/interfaces.go ---
package ffs

import (
	"context"
	"errors"
	"io"
	"math/big"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/api"
	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/deals"
)

// WalletManager provides access to a Lotus wallet for a Lotus node.
type WalletManager interface {
	// MasterAddr returns the master address.
	// Will return address.Undef is Powergate was started with no master address.
	MasterAddr() address.Address
	// NewAddress creates a new address.
	NewAddress(context.Context, string) (string, error)
	// Balance returns the current balance for an address.
	Balance(context.Context, string) (*big.Int, error)
	// SendFil sends fil from one address to another.
	SendFil(context.Context, string, string, *big.Int) (cid.Cid, error)
	// Sign signs a message using an address.
	Sign(context.Context, string, []byte) ([]byte, error)
	// Verify verifies if a message was signed with an address.
	Verify(context.Context, string, []byte, []byte) (bool, error)
}

// DealRecordsManager provides access to deal records.
type DealRecordsManager interface {
	ListStorageDealRecords(opts ...deals.DealRecordsOption) ([]deals.StorageDealRecord, error)
	ListRetrievalDealRecords(opts ...deals.DealRecordsOption) ([]deals.RetrievalDealRecord, error)
}

// HotStorage is a fast storage layer for Cid data.
type HotStorage interface {
	// Stage adds io.Reader and stage-pins it.
	Stage(context.Context, APIID, io.Reader) (cid.Cid, error)

	// StageCid pulls Cid data and stage-pin it.
	StageCid(context.Context, APIID, cid.Cid) error

	// Unpin unpins a Cid.
	Unpin(context.Context, APIID, cid.Cid) error

	// Get retrieves a stored Cid data.
	Get(context.Context, cid.Cid) (io.Reader, error)

	// Pin pins a Cid. If the data wasn't previously Added,
	// depending on the implementation it may use internal mechanisms
	// for pulling the data, e.g: IPFS network
	Pin(context.Context, APIID, cid.Cid) (int, error)

	// Replace replaces a stored Cid with a new one. It's mostly
	// thought for mutating data doing this efficiently.
	Replace(context.Context, APIID, cid.Cid, cid.Cid) (int, error)

	// IsPinned returns true if the Cid is pinned, or false
	// otherwise.
	IsPinned(context.Context, APIID, cid.Cid) (bool, error)

	// GCStaged unpins Cids that are stage-pinned that aren't
	// contained in a exclude list, and were pinned before a time.
	GCStaged(context.Context, []cid.Cid, time.Time) ([]cid.Cid, error)

	// PinnedCids returns pinned cids information.
	PinnedCids(context.Context) ([]PinnedCid, error)
}

// DealError contains information about a failed deal.
type DealError struct {
	ProposalCid cid.Cid
	Miner       string
	Message     string
}

// Error returns an stringified message of the
// underlying error cause.
func (de DealError) Error() string {
	return de.Message
}

// FetchInfo describes information about a Filecoin retrieval.
type FetchInfo struct {
	RetrievedMiner string
	FundsSpent     uint64
}

var (
	// ErrOnChainDealNotFound is returned when a deal doesn't exist,
	// or might have been slashed.
	ErrOnChainDealNotFound = errors.New("on-chain deal not found, may not exist or have been slashed")
)

// ColdStorage is slow/cheap storage for Cid data. It has
// native support for Filecoin storage.
type ColdStorage interface {
	// Store stores a Cid using the provided configuration and
	// account address. It returns a slice of accepted proposed deals,
	// a slice of rejected proposal deals, and the size of the data.
	Store(context.Context, cid.Cid, FilConfig) ([]cid.Cid, []DealError, abi.PaddedPieceSize, error)

	// WaitForDeal blocks the provided Deal Proposal reach a
	// final state. If the deal finishes successfully it returns a FilStorage
	// result. If the deal finished with error, it returns a ffs.DealError
	// error result, so it should be considered in error handling.
	WaitForDeal(context.Context, cid.Cid, cid.Cid, time.Duration, chan deals.StorageDealInfo) (FilStorage, error)

	// Fetch fetches the cid data in the underlying storage.
	Fetch(context.Context, cid.Cid, *cid.Cid, string, []string, uint64, string) (FetchInfo, error)

	// EnsureRenewals executes renewal logic for a Cid under a particular
	// configuration. It returns a slice of deal errors happened during execution.
	EnsureRenewals(context.Context, cid.Cid, FilInfo, FilConfig, time.Duration, chan deals.StorageDealInfo) (FilInfo, []DealError, error)

	// GetDealInfo returns information about an on-chain deal.
	// If a deal ID doesn't exist, the deal isn't active anymore, or was
	// slashed, then ErrOnChainDealNotFound is returned.
	GetDealInfo(context.Context, uint64) (api.MarketDeal, error)
}

// MinerSelector returns miner addresses and ask storage information using a
// desired strategy.
type MinerSelector interface {
	// GetMiners returns a specified amount of miners that satisfy
	// provided filters.
	GetMiners(int, MinerSelectorFilter) ([]MinerProposal, error)
}

// MinerSelectorFilter establishes filters that should be considered when
// returning miners.
type MinerSelectorFilter struct {
	// ExcludedMiners contains miner addresses that should not be considered in
	// returned results. An empty list means no exclusions.
	ExcludedMiners []string
	// TrustedMiners contains miner addresses that will be prioritized
	// if are available in the query result. If the number of expected
	// results exceeeds the number of trusted miners, the remaining amount
	// of results will be returned still applying the rest of the filters
	// and the MinerSelector sorting logic.
	TrustedMiners []string
	// CountryCodes contains long-ISO country names that should be
	// considered in selected miners. An empty list means no filtering.
	CountryCodes []string
	// MaxPrice is the max ask price to consider when selecting miner deals
	MaxPrice uint64
	// PieceSize is the piece size of the data.
	PieceSize uint64
	// VerifiedDeal indicates it should take verified storage prices.
	VerifiedDeal bool
}

// MinerProposal contains a miners address and storage ask information
// to make a, most probably, successful deal.
type MinerProposal struct {
	Addr       string
	EpochPrice uint64
}

// PinnedCid provides information about a pinned Cid.
type PinnedCid struct {
	Cid    cid.Cid
	APIIDs []APIIDPinnedCid
}

// APIIDPinnedCid has information about a Cid pinned by a user.
type APIIDPinnedCid struct {
	ID        APIID
	Staged    bool
	CreatedAt int64
}

'''
'''--- Filecoin/powergate/ffs/joblogger/joblogger.go ---
package joblogger

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"strconv"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

var (
	log = logging.Logger("ffs-cidlogger")
)

// Logger is a datastore backed implementation of ffs.Logger.
type Logger struct {
	ds datastore.Datastore

	lock     sync.Mutex
	watchers []chan<- ffs.LogEntry
	closed   bool
}

type logEntry struct {
	Cid         cid.Cid
	RetrievalID ffs.RetrievalID
	Timestamp   int64
	Jid         ffs.JobID
	Msg         string
}

var _ ffs.JobLogger = (*Logger)(nil)

// New returns a new CidLogger.
func New(ds datastore.Datastore) *Logger {
	return &Logger{
		ds: ds,
	}
}

// Log logs a log entry for a Cid. The ctx can contain an optional ffs.CtxKeyJid to add
// additional metadata about the log entry being part of a Job execution.
func (cl *Logger) Log(ctx context.Context, format string, a ...interface{}) {
	log.Infof(format, a...)

	// Retrieve context values.
	c, _ := ctx.Value(ffs.CtxStorageCid).(cid.Cid)
	rid, _ := ctx.Value(ffs.CtxRetrievalID).(ffs.RetrievalID)
	jid, _ := ctx.Value(ffs.CtxKeyJid).(ffs.JobID)
	iid, _ := ctx.Value(ffs.CtxAPIID).(ffs.APIID)

	now := time.Now()
	nowNano := now.UnixNano()
	key := makeKey(iid, c, rid, nowNano)
	le := logEntry{
		Cid:         c,
		RetrievalID: rid,
		Jid:         jid,
		Msg:         fmt.Sprintf(format, a...),
		Timestamp:   nowNano,
	}
	b, err := json.Marshal(le)
	if err != nil {
		log.Errorf("marshaling to json: %s", err)
		return
	}
	if err := cl.ds.Put(key, b); err != nil {
		log.Error("saving to datastore: %s", err)
		return
	}

	entry := ffs.LogEntry{
		APIID:     iid,
		Cid:       le.Cid,
		Jid:       le.Jid,
		Timestamp: now,
		Msg:       fmt.Sprintf(format, a...),
	}
	cl.lock.Lock()
	defer cl.lock.Unlock()
	for _, c := range cl.watchers {
		select {
		case c <- entry:
		default:
			log.Warn("slow cid log receiver")
		}
	}
}

// GetByCid returns history logs for a Cid.
func (cl *Logger) GetByCid(ctx context.Context, iid ffs.APIID, c cid.Cid) ([]ffs.LogEntry, error) {
	q := query.Query{Prefix: makeStorageCidKey(iid, c).String()}
	res, err := cl.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("running query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()
	var lgs []ffs.LogEntry
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var le logEntry
		if err := json.Unmarshal(r.Value, &le); err != nil {
			return nil, fmt.Errorf("unmarshaling log entry: %s", err)
		}
		lgs = append(lgs, ffs.LogEntry{
			Cid:       le.Cid,
			Jid:       le.Jid,
			Msg:       le.Msg,
			Timestamp: time.Unix(0, le.Timestamp),
		})
	}
	sort.Slice(lgs, func(a, b int) bool {
		return lgs[a].Timestamp.Before(lgs[b].Timestamp)
	})
	return lgs, nil
}

// Watch is a blocking function that writes to the channel all new created log entries.
// The client should cancel the ctx to signal stopping writing to the channel and free resources.
func (cl *Logger) Watch(ctx context.Context, c chan<- ffs.LogEntry) error {
	cl.lock.Lock()
	ic := make(chan ffs.LogEntry, 20)
	cl.watchers = append(cl.watchers, ic)
	cl.lock.Unlock()

	stop := false
	for !stop {
		select {
		case <-ctx.Done():
			stop = true
		case l, ok := <-ic:
			if !ok {
				return fmt.Errorf("cidlogger was closed with a listening client")
			}
			c <- l
		}
	}
	cl.lock.Lock()
	defer cl.lock.Unlock()
	for i := range cl.watchers {
		if cl.watchers[i] == ic {
			cl.watchers = append(cl.watchers[:i], cl.watchers[i+1:]...)
			break
		}
	}
	return nil
}

// Close closes and cancels all watchers that might be active.
func (cl *Logger) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	cl.lock.Lock()
	defer cl.lock.Unlock()

	if cl.closed {
		return nil
	}
	cl.closed = true
	for _, w := range cl.watchers {
		close(w)
	}
	return nil
}

func makeKey(iid ffs.APIID, c cid.Cid, rid ffs.RetrievalID, timestamp int64) datastore.Key {
	if !iid.Valid() {
		panic("iid can't be empty")
	}
	strt := strconv.FormatInt(timestamp, 10)
	if c != cid.Undef {
		return makeStorageCidKey(iid, c).ChildString(strt)
	}
	if rid != ffs.EmptyRetrievalID {
		return makeRetrievalKey(iid, c).ChildString(strt)
	}
	panic("log should be from stored cid or retrieval request")
}

func makeStorageCidKey(iid ffs.APIID, c cid.Cid) datastore.Key {
	return datastore.NewKey(iid.String()).ChildString(util.CidToString(c))
}

func makeRetrievalKey(iid ffs.APIID, rid cid.Cid) datastore.Key {
	return datastore.NewKey(iid.String()).ChildString(rid.String())
}

'''
'''--- Filecoin/powergate/ffs/manager/manager.go ---
package manager

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"

	"github.com/filecoin-project/go-address"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/namespace"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/api"
	"github.com/textileio/powergate/v2/ffs/auth"
	"github.com/textileio/powergate/v2/ffs/scheduler"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
	"github.com/textileio/powergate/v2/util"
)

var (
	// ErrAuthTokenNotFound returns when an auth-token doesn't exist.
	ErrAuthTokenNotFound = errors.New("auth token not found")

	log = logging.Logger("ffs-manager")

	// zeroConfig is a safe-initial value for a default
	// StorageConfig for a manager. A newly (not re-loaded) created
	// manager will have this configuration by default. It can be
	// later changed with the Get/Set APIs. A re-loaded manager will
	// recover its last configured default StorageConfig from the datastore.
	zeroConfig = ffs.StorageConfig{
		Hot: ffs.HotConfig{
			Enabled: false,
			Ipfs: ffs.IpfsConfig{
				AddTimeout: 15 * 60, // 15min
			},
		},
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				RepFactor:       1,
				DealMinDuration: util.MinDealDuration,
				FastRetrieval:   true,
				DealStartOffset: 72 * 60 * 60 / util.EpochDurationSeconds, // 72hs
				MaxPrice:        100_000_000_000,
			},
		},
	}

	localnetZeroConfig = ffs.StorageConfig{
		Hot: ffs.HotConfig{
			Enabled: true,
			Ipfs: ffs.IpfsConfig{
				AddTimeout: 10,
			},
		},
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				RepFactor:       1,
				DealMinDuration: util.MinDealDuration,
			},
		},
	}
	dsDefaultStorageConfigKey = datastore.NewKey("defaultstorageconfig")
)

// Manager creates Api instances, or loads existing ones them from an auth-token.
type Manager struct {
	wm    ffs.WalletManager
	drm   ffs.DealRecordsManager
	sched *scheduler.Scheduler

	lock             sync.Mutex
	ds               datastore.Datastore
	auth             *auth.Auth
	instances        map[ffs.APIID]*api.API
	defaultConfig    ffs.StorageConfig
	ffsUseMasterAddr bool

	closed bool
}

// New returns a new Manager.
func New(ds datastore.TxnDatastore, wm ffs.WalletManager, drm ffs.DealRecordsManager, sched *scheduler.Scheduler, ffsUseMasterAddr bool, onLocalnet bool) (*Manager, error) {
	if ffsUseMasterAddr && wm.MasterAddr() == address.Undef {
		return nil, fmt.Errorf("ffsUseMasterAddr requires that master address is defined")
	}
	storageConfig, err := loadDefaultStorageConfig(ds, onLocalnet)
	if err != nil {
		return nil, fmt.Errorf("loading default storage config: %s", err)
	}
	return &Manager{
		auth:             auth.New(txndstr.Wrap(ds, "auth")),
		ds:               ds,
		wm:               wm,
		drm:              drm,
		sched:            sched,
		instances:        make(map[ffs.APIID]*api.API),
		defaultConfig:    storageConfig,
		ffsUseMasterAddr: ffsUseMasterAddr,
	}, nil
}

// Create creates a new Api instance and an auth-token mapped to it.
func (m *Manager) Create(ctx context.Context) (ffs.AuthEntry, error) {
	log.Info("creating instance")

	var addr address.Address
	if m.ffsUseMasterAddr {
		addr = m.wm.MasterAddr()
	} else {
		res, err := m.wm.NewAddress(ctx, "bls")
		if err != nil {
			return ffs.AuthEntry{}, fmt.Errorf("creating new wallet addr: %s", err)
		}
		a, err := address.NewFromString(res)
		if err != nil {
			return ffs.AuthEntry{}, fmt.Errorf("decoding newly created addr: %s", err)
		}
		addr = a
	}

	addrInfo := api.AddrInfo{Name: "Initial Address", Addr: addr.String()}
	switch addr.Protocol() {
	case address.BLS:
		addrInfo.Type = "bls"
	case address.SECP256K1:
		addrInfo.Type = "secp256k1"
	case address.Actor:
		addrInfo.Type = "actor"
	case address.ID:
		addrInfo.Type = "id"
	case address.Unknown:
	default:
		addrInfo.Type = "unknown"
	}

	iid := ffs.NewAPIID()

	fapi, err := api.New(namespace.Wrap(m.ds, datastore.NewKey("api/"+iid.String())), iid, m.sched, m.wm, m.drm, m.defaultConfig, addrInfo)
	if err != nil {
		return ffs.AuthEntry{}, fmt.Errorf("creating new instance: %s", err)
	}

	auth, err := m.auth.Generate(fapi.ID())
	if err != nil {
		return ffs.AuthEntry{}, fmt.Errorf("generating auth token for %s: %s", fapi.ID(), err)
	}
	m.lock.Lock()
	defer m.lock.Unlock()

	m.instances[iid] = fapi

	return ffs.AuthEntry{APIID: fapi.ID(), Token: auth}, nil
}

// SetDefaultStorageConfig sets the default StorageConfig to be set as default to newly created
// FFS instances.
func (m *Manager) SetDefaultStorageConfig(dc ffs.StorageConfig) error {
	m.lock.Lock()
	defer m.lock.Unlock()
	if err := m.saveDefaultConfig(dc); err != nil {
		return fmt.Errorf("persisting default configuration: %s", err)
	}
	return nil
}

// List returns a list of all existing API instances.
func (m *Manager) List() ([]ffs.AuthEntry, error) {
	m.lock.Lock()
	defer m.lock.Unlock()

	res, err := m.auth.List()
	if err != nil {
		return nil, fmt.Errorf("listing existing instances: %s", err)
	}
	return res, nil
}

// RegenerateAuthToken invalidates the provided token replacing it with a new one.
func (m *Manager) RegenerateAuthToken(token string) (string, error) {
	m.lock.Lock()
	defer m.lock.Unlock()

	newToken, err := m.auth.RegenerateAuthToken(token)
	if err == auth.ErrNotFound {
		return "", ErrAuthTokenNotFound
	}

	return newToken, nil
}

// GetByAuthToken loads an existing instance using an auth-token. If auth-token doesn't exist,
// it returns ErrAuthTokenNotFound.
func (m *Manager) GetByAuthToken(token string) (*api.API, error) {
	m.lock.Lock()
	defer m.lock.Unlock()

	iid, err := m.auth.Get(token)
	if err == auth.ErrNotFound {
		return nil, ErrAuthTokenNotFound
	}

	i, ok := m.instances[iid]
	if !ok {
		log.Debugf("loading uncached instance %s", iid)
		i, err = api.Load(namespace.Wrap(m.ds, datastore.NewKey("api/"+iid.String())), iid, m.sched, m.wm, m.drm)
		if err != nil {
			return nil, fmt.Errorf("loading instance %s: %s", iid, err)
		}
		m.instances[iid] = i
	} else {
		log.Debugf("using cached instance %s", iid)
	}

	return i, nil
}

// GetDefaultStorageConfig returns the current default StorageConfig used
// for newly created FFS instances.
func (m *Manager) GetDefaultStorageConfig() ffs.StorageConfig {
	m.lock.Lock()
	defer m.lock.Unlock()
	return m.defaultConfig
}

// Close closes a Manager and consequently all loaded instances.
func (m *Manager) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	m.lock.Lock()
	defer m.lock.Unlock()
	if m.closed {
		return nil
	}
	for _, i := range m.instances {
		if err := i.Close(); err != nil {
			log.Errorf("closing instance %s: %s", i.ID(), err)
		}
	}
	m.closed = true
	return nil
}

// saveDefaultConfig persists a new default configuration and updates
// the cached value. This method must be guarded.
func (m *Manager) saveDefaultConfig(dc ffs.StorageConfig) error {
	buf, err := json.Marshal(dc)
	if err != nil {
		return fmt.Errorf("marshaling default config: %s", err)
	}
	if err := m.ds.Put(dsDefaultStorageConfigKey, buf); err != nil {
		return fmt.Errorf("saving default config to datastore: %s", err)
	}
	m.defaultConfig = dc
	return nil
}

func loadDefaultStorageConfig(ds datastore.Datastore, onLocalnet bool) (ffs.StorageConfig, error) {
	d, err := ds.Get(dsDefaultStorageConfigKey)
	if err == datastore.ErrNotFound {
		if onLocalnet {
			return localnetZeroConfig, nil
		}
		return zeroConfig, nil
	}
	if err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("get from datastore: %s", err)
	}

	var defaultConfig ffs.StorageConfig
	if err := json.Unmarshal(d, &defaultConfig); err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("unmarshaling default StorageConfig: %s", err)
	}
	return defaultConfig, nil
}

'''
'''--- Filecoin/powergate/ffs/manager/manager_test.go ---
package manager

import (
	"context"
	"math/big"
	"os"
	"testing"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	dealsModule "github.com/textileio/powergate/v2/deals/module"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/tests"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
	"github.com/textileio/powergate/v2/util"
	lotusWallet "github.com/textileio/powergate/v2/wallet/lotuswallet"
)

func TestMain(m *testing.M) {
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestNewManager(t *testing.T) {
	t.Parallel()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, tests.NewTxMapDatastore(), addr, false)
	require.NoError(t, err)
	require.NotNil(t, m)
	defer require.NoError(t, cls())
}

func TestNewManagerMasterAddrFFSUseMasterAddr(t *testing.T) {
	t.Parallel()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, tests.NewTxMapDatastore(), addr, true)
	require.NoError(t, err)
	require.NotNil(t, m)
	defer require.NoError(t, cls())
}

func TestNewManagerNoMasterAddrNoFFSUseMasterAddr(t *testing.T) {
	t.Parallel()
	client, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, tests.NewTxMapDatastore(), address.Undef, false)
	require.NoError(t, err)
	require.NotNil(t, m)
	defer require.NoError(t, cls())
}

func TestNewManagerNoMasterAddrFFSUseMasterAddr(t *testing.T) {
	t.Parallel()
	client, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	_, cls, err := newManager(client, tests.NewTxMapDatastore(), address.Undef, true)
	require.Error(t, err)
	defer require.NoError(t, cls())
}

func TestCreate(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ctx := context.Background()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, false)
	require.NoError(t, err)
	defer require.NoError(t, cls())

	auth, err := m.Create(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, auth.Token)
	require.True(t, auth.APIID.Valid())
}

func TestCreateWithFFSMasterAddr(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ctx := context.Background()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, true)
	require.NoError(t, err)
	defer require.NoError(t, cls())

	auth, err := m.Create(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, auth.Token)
	require.True(t, auth.APIID.Valid())

	i, err := m.GetByAuthToken(auth.Token)
	require.NoError(t, err)
	iAddrs := i.Addrs()
	require.Len(t, iAddrs, 1)
	require.Equal(t, m.wm.MasterAddr().String(), iAddrs[0].Addr)
	c := i.DefaultStorageConfig()
	require.Equal(t, m.wm.MasterAddr().String(), c.Cold.Filecoin.Addr)
}

func TestList(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ctx := context.Background()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, false)
	require.NoError(t, err)
	defer require.NoError(t, cls())

	lst, err := m.List()
	require.NoError(t, err)
	require.Equal(t, 0, len(lst))

	auth1, err := m.Create(ctx)
	require.NoError(t, err)
	lst, err = m.List()
	require.NoError(t, err)
	require.Equal(t, 1, len(lst))
	require.Contains(t, lst, auth1)

	auth2, err := m.Create(ctx)
	require.NoError(t, err)

	lst, err = m.List()
	require.NoError(t, err)
	require.Contains(t, lst, auth1)
	require.Contains(t, lst, auth2)
	require.Equal(t, 2, len(lst))
}

func TestGetByAuthToken(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ctx := context.Background()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, false)
	require.NoError(t, err)
	defer require.NoError(t, cls())
	auth, err := m.Create(ctx)
	require.NoError(t, err)

	t.Run("Hot", func(t *testing.T) {
		new, err := m.GetByAuthToken(auth.Token)
		require.NoError(t, err)
		require.Equal(t, auth.APIID, new.ID())
		require.NotEmpty(t, new.Addrs())
	})
	t.Run("Cold", func(t *testing.T) {
		client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
		m, cls, err := newManager(client, ds, addr, false)
		require.NoError(t, err)
		defer require.NoError(t, cls())
		new, err := m.GetByAuthToken(auth.Token)
		require.NoError(t, err)
		require.Equal(t, auth.APIID, new.ID())
		require.NotEmpty(t, new.Addrs())
	})
	t.Run("NonExistant", func(t *testing.T) {
		i, err := m.GetByAuthToken(string("123"))
		require.Equal(t, err, ErrAuthTokenNotFound)
		require.Nil(t, i)
	})
}

func TestRegenerateAuthToken(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	ctx := context.Background()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, false)
	require.NoError(t, err)
	defer require.NoError(t, cls())
	originalAuth, err := m.Create(ctx)
	require.NoError(t, err)

	regeneratedAuth, err := m.RegenerateAuthToken(originalAuth.Token)
	require.NoError(t, err)

	// The old token should be invalid
	_, err = m.GetByAuthToken(originalAuth.Token)
	require.Equal(t, err, ErrAuthTokenNotFound)

	// Get with new token and check the APIID is equal to the original one.
	n, err := m.GetByAuthToken(regeneratedAuth)
	require.NoError(t, err)
	require.Equal(t, originalAuth.APIID, n.ID())
	require.NotEmpty(t, n.Addrs())
}

func TestDefaultStorageConfig(t *testing.T) {
	t.Parallel()
	ds := tests.NewTxMapDatastore()
	client, addr, _ := tests.CreateLocalDevnet(t, 1, 300)
	m, cls, err := newManager(client, ds, addr, true)
	require.NoError(t, err)
	defer require.NoError(t, cls())

	// A newly created manager must have
	// the zeroConfig defined value.
	c := m.GetDefaultStorageConfig()
	require.Equal(t, localnetZeroConfig, c)

	// Change the default config and test.
	c.Hot.Enabled = false
	c.Repairable = true
	err = m.SetDefaultStorageConfig(c)
	require.NoError(t, err)
	c2 := m.GetDefaultStorageConfig()
	require.Equal(t, c, c2)
	defer require.NoError(t, cls())

	// Re-open manager, and check that
	// the default config was the last
	// saved one, and not zeroConfig.
	m, cls, err = newManager(client, ds, addr, false)
	require.NoError(t, err)
	defer require.NoError(t, cls())
	c3 := m.GetDefaultStorageConfig()
	require.Equal(t, c, c3)
}

func newManager(clientBuilder lotus.ClientBuilder, ds datastore.TxnDatastore, masterAddr address.Address, ffsUseMasterAddr bool) (*Manager, func() error, error) {
	wm, err := lotusWallet.New(clientBuilder, masterAddr, *big.NewInt(4000000000), false, "")
	if err != nil {
		return nil, func() error { return nil }, err
	}
	dm, err := dealsModule.New(txndstr.Wrap(ds, "deals"), clientBuilder, util.AvgBlockTime, time.Minute*10)
	if err != nil {
		return nil, func() error { return nil }, err
	}
	m, err := New(ds, wm, dm, nil, ffsUseMasterAddr, true)
	if err != nil {
		return nil, func() error { return nil }, err
	}
	cls := func() error {
		return m.Close()
	}
	return m, cls, nil
}

'''
'''--- Filecoin/powergate/ffs/minerselector/fixed/fixed.go ---
package fixed

import (
	"fmt"

	"github.com/textileio/powergate/v2/ffs"
)

// MinerSelector is a MinerSelector implementation which
// always return a single miner address with an fixed epochPrice.
type MinerSelector struct {
	miners []Miner
}

// Miner contains miner information.
type Miner struct {
	Addr       string
	Country    string
	EpochPrice uint64
}

var _ ffs.MinerSelector = (*MinerSelector)(nil)

// New returns a new FixedMinerSelector that always return addr as the miner address
// and epochPrice.
func New(miners []Miner) *MinerSelector {
	fixedMiners := make([]Miner, len(miners))
	copy(fixedMiners, miners)
	return &MinerSelector{
		miners: fixedMiners,
	}
}

// GetMiners returns the single allowed miner in the selector.
func (fms *MinerSelector) GetMiners(n int, f ffs.MinerSelectorFilter) ([]ffs.MinerProposal, error) {
	res := make([]ffs.MinerProposal, 0, n)
	mres := make(map[string]struct{})
	for _, pm := range f.TrustedMiners {
		for _, m := range fms.miners {
			if m.Addr == pm {
				if f.MaxPrice > 0 && m.EpochPrice > f.MaxPrice {
					continue
				}
				mres[m.Addr] = struct{}{}
				res = append(res, ffs.MinerProposal{
					Addr:       m.Addr,
					EpochPrice: m.EpochPrice,
				})
				break
			}
		}
		if len(res) == n {
			return res, nil
		}
	}

	for _, m := range fms.miners {
		if _, ok := mres[m.Addr]; ok {
			continue
		}
		if f.MaxPrice > 0 && m.EpochPrice > f.MaxPrice {
			continue
		}
		skip := false
		for _, bAddr := range f.ExcludedMiners {
			if bAddr == m.Addr {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		if len(f.CountryCodes) != 0 {
			skip := true
			for _, c := range f.CountryCodes {
				if c == m.Country {
					skip = false
					break
				}
			}
			if skip {
				continue
			}
		}
		res = append(res, ffs.MinerProposal{
			Addr:       m.Addr,
			EpochPrice: m.EpochPrice,
		})
		if len(res) == n {
			break
		}
	}
	if len(res) != n {
		return nil, fmt.Errorf("not enough fixed miners to provide, want %d, got %d", n, len(res))
	}
	return res, nil
}

'''
'''--- Filecoin/powergate/ffs/minerselector/reptop/reptop.go ---
package reptop

import (
	"context"
	"fmt"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/lotus/chain/types"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	askRunner "github.com/textileio/powergate/v2/index/ask/runner"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/reputation"
)

var (
	log = logger.Logger("reptop")
)

// RepTop is a ffs.MinerSelector implementation that returns the top N
// miners from a Reputations Module and an Ask Index.
type RepTop struct {
	rm *reputation.Module
	ai *askRunner.Runner
	cb lotus.ClientBuilder
}

var _ ffs.MinerSelector = (*RepTop)(nil)

// New returns a new RetTop instance that uses the specified Reputation Module
// to select miners and the AskIndex for their epoch prices.
func New(cb lotus.ClientBuilder, rm *reputation.Module, ai *askRunner.Runner) *RepTop {
	return &RepTop{
		rm: rm,
		ai: ai,
		cb: cb,
	}
}

// GetMiners returns n miners using the configured Reputation Module and
// Ask Index.
func (rt *RepTop) GetMiners(n int, f ffs.MinerSelectorFilter) ([]ffs.MinerProposal, error) {
	if n < 1 {
		return nil, fmt.Errorf("the number of miners should be greater than zero")
	}

	// We start directly targeting trusted miners without relying on reputation index.
	// This is done to circumvent index building restrictions such as excluding miners
	// with zero power. Trusted miners are trusted by definition, so if they have zero
	// power, that's a risk that the client is accepting.
	trustedMiners := rt.genTrustedMiners(f, n)

	// The remaining needed miners are gathered from the reputation index.
	reputationMiners, err := rt.genFromReputation(f, n-len(trustedMiners))
	if err != nil {
		return nil, fmt.Errorf("getting miners from reputation module: %s", err)
	}

	// Return both lists.
	return append(trustedMiners, reputationMiners...), nil
}

func (rt *RepTop) genTrustedMiners(f ffs.MinerSelectorFilter, n int) []ffs.MinerProposal {
	ret := make([]ffs.MinerProposal, 0, len(f.TrustedMiners))
	for _, m := range f.TrustedMiners {
		mp, err := rt.getMinerProposal(f, m)
		if err != nil {
			log.Warnf("trusted miner %s query asking: %s", m, err)
			continue
		}
		ret = append(ret, mp)
		if len(ret) == n {
			break
		}
	}

	return ret
}

func (rt *RepTop) genFromReputation(f ffs.MinerSelectorFilter, n int) ([]ffs.MinerProposal, error) {
	if n == 0 {
		return nil, nil
	}
	ms, err := rt.rm.QueryMiners(f.TrustedMiners, f.CountryCodes, nil)
	if err != nil {
		return nil, fmt.Errorf("getting miners from reputation module: %s", err)
	}
	if len(ms) < n {
		return nil, fmt.Errorf("not enough miners from reputation module to satisfy the constraints")
	}

	var minerErrors []error
	maxMinerErrors := 5
	res := make([]ffs.MinerProposal, 0, n)
	for _, m := range ms {
		mp, err := rt.getMinerProposal(f, m.Addr)
		if err != nil {
			if len(minerErrors) < maxMinerErrors {
				minerErrors = append(minerErrors, err)
			} else if len(minerErrors) == maxMinerErrors {
				minerErrors = append(minerErrors, fmt.Errorf("and more ... "))
			}
			continue // Cached miner isn't replying to query-ask now, skip.
		}
		res = append(res, mp)
		if len(res) == n {
			break
		}
	}
	if len(res) < n {
		return nil, fmt.Errorf("not enough miners satisfy the miner selector constraints: %s", minerErrors)
	}
	return res, nil
}

func (rt *RepTop) getMinerProposal(f ffs.MinerSelectorFilter, addrStr string) (ffs.MinerProposal, error) {
	c, cls, err := rt.cb(context.Background())
	if err != nil {
		return ffs.MinerProposal{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	addr, err := address.NewFromString(addrStr)
	if err != nil {
		return ffs.MinerProposal{}, fmt.Errorf("miner address is invalid: %s", err)
	}
	ctx, cls := context.WithTimeout(context.Background(), time.Second*10)
	defer cls()

	mi, err := c.StateMinerInfo(ctx, addr, types.EmptyTSK)
	if err != nil {
		return ffs.MinerProposal{}, fmt.Errorf("getting miner %s info: %s", addr, err)
	}

	if mi.PeerId == nil {
		return ffs.MinerProposal{}, fmt.Errorf("the miner %s doesn't specify a peer id", addr)
	}

	type chAskRes struct {
		Error string
		Ask   *storagemarket.StorageAsk
	}
	chAsk := make(chan chAskRes)
	go func() {
		sask, err := c.ClientQueryAsk(ctx, *mi.PeerId, addr)
		if err != nil {
			chAsk <- chAskRes{Error: err.Error()}
			return
		}

		chAsk <- chAskRes{Ask: sask}
	}()

	select {
	case <-time.After(time.Second * 20):
		return ffs.MinerProposal{}, fmt.Errorf("query asking timed out")
	case r := <-chAsk:
		if r.Error != "" {
			return ffs.MinerProposal{}, fmt.Errorf("query ask had controlled error: %s", r.Error)
		}
		price := r.Ask.Price.Uint64()
		if f.VerifiedDeal {
			price = r.Ask.VerifiedPrice.Uint64()
		}
		if f.MaxPrice > 0 && price > f.MaxPrice {
			return ffs.MinerProposal{}, fmt.Errorf("miner's price doesn't satisfy price constraints: %d>%d", r.Ask.Price, f.MaxPrice)
		}
		if f.PieceSize < uint64(r.Ask.MinPieceSize) || f.PieceSize > uint64(r.Ask.MaxPieceSize) {
			return ffs.MinerProposal{}, fmt.Errorf("miner doesn't satisfy piece size constraints: %d<%d<%d", r.Ask.MinPieceSize, f.PieceSize, r.Ask.MaxPieceSize)
		}

		return ffs.MinerProposal{Addr: addrStr, EpochPrice: price}, nil
	}
}

'''
'''--- Filecoin/powergate/ffs/minerselector/sr2/sr2.go ---
package sr2

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/lotus"
)

const (
	maxSR2Price = 100_000_000_000
)

var (
	log = logger.Logger("sr2-miner-selector")
)

// MinerSelector chooses miner under SR2 strategy.
type MinerSelector struct {
	url string
	cb  lotus.ClientBuilder
}

var _ ffs.MinerSelector = (*MinerSelector)(nil)

type minersBuckets struct {
	Buckets []bucket
}

type bucket struct {
	Amount         int
	MinerAddresses []string
}

// New returns a new SR2 miner selector.
func New(url string, cb lotus.ClientBuilder) (*MinerSelector, error) {
	ms := &MinerSelector{url: url, cb: cb}

	_, err := ms.getMiners()
	if err != nil {
		return nil, fmt.Errorf("verifying sr2 url content: %s", err)
	}

	return ms, nil
}

// GetMiners returns miners from SR2.
func (ms *MinerSelector) GetMiners(n int, f ffs.MinerSelectorFilter) ([]ffs.MinerProposal, error) {
	mb, err := ms.getMiners()
	if err != nil {
		return nil, fmt.Errorf("getting miners from url: %s", err)
	}

	c, cls, err := ms.cb(context.Background())
	if err != nil {
		return nil, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	rand.Seed(time.Now().UnixNano())
	var selected []ffs.MinerProposal
	for _, bucket := range mb.Buckets {
		miners := bucket.MinerAddresses
		rand.Shuffle(len(miners), func(i, j int) { miners[i], miners[j] = miners[j], miners[i] })

		// Stay safe.
		if bucket.Amount < 0 {
			bucket.Amount = 0
		}
		if bucket.Amount > len(miners) {
			bucket.Amount = len(miners)
		}
		var regionSelected int
		for i := 0; regionSelected < bucket.Amount && i < len(miners); i++ {
			sask, err := getMinerQueryAsk(c, miners[i])
			if err != nil {
				log.Warnf("sr2 miner %s query-ask errored: %s", miners[i], err)
				continue
			}
			price := sask.Price.Uint64()
			if f.VerifiedDeal {
				price = sask.VerifiedPrice.Uint64()
			}
			if price > maxSR2Price {
				log.Warnf("skipping miner %s since has price %d above maximum allowed for SR2", miners[i], sask.Price)
				continue
			}
			if f.MaxPrice > 0 && price > f.MaxPrice {
				log.Warnf("skipping miner %s with price %d higher than max-price %d", miners[i], sask.Price, f.MaxPrice)
				continue
			}
			if f.PieceSize < uint64(sask.MinPieceSize) || f.PieceSize > uint64(sask.MaxPieceSize) {
				log.Warnf("skipping miner %s since needed piece size %d doesn't fit bounds (%d, %d)", miners[i], f.PieceSize, sask.MinPieceSize, sask.MaxPieceSize)
			}
			selected = append(selected, ffs.MinerProposal{
				Addr:       miners[i],
				EpochPrice: sask.Price.Uint64(),
			})
			regionSelected++
		}
	}

	if len(selected) == 0 {
		return nil, fmt.Errorf("no SR2 miners are available")
	}

	return selected, nil
}

// GetReplicationFactor returns the current replication factor of the
// remote configuration.
func (ms *MinerSelector) GetReplicationFactor() (int, error) {
	mb, err := ms.getMiners()
	if err != nil {
		return 0, fmt.Errorf("getting sr2 miners: %s", err)
	}
	var repFactor int
	for _, b := range mb.Buckets {
		repFactor += b.Amount
	}

	return repFactor, nil
}

func (ms *MinerSelector) getMiners() (minersBuckets, error) {
	r, err := http.DefaultClient.Get(ms.url)
	if err != nil {
		return minersBuckets{}, fmt.Errorf("getting miners list from url: %s", err)
	}
	defer func() {
		if err := r.Body.Close(); err != nil {
			log.Warnf("closing request body from sr2 file: %s", err)
		}
	}()
	content, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return minersBuckets{}, fmt.Errorf("reading body: %s", err)
	}
	var res minersBuckets
	if err := json.Unmarshal(content, &res); err != nil {
		return minersBuckets{}, fmt.Errorf("unmarshaling url contents: %s", err)
	}
	return res, nil
}

func getMinerQueryAsk(c *api.FullNodeStruct, addrStr string) (*storagemarket.StorageAsk, error) {
	addr, err := address.NewFromString(addrStr)
	if err != nil {
		return nil, fmt.Errorf("miner address is invalid: %s", err)
	}
	ctx, cls := context.WithTimeout(context.Background(), time.Second*10)
	defer cls()
	mi, err := c.StateMinerInfo(ctx, addr, types.EmptyTSK)
	if err != nil {
		return nil, fmt.Errorf("getting miner %s info: %s", addr, err)
	}

	type chAskRes struct {
		Error string
		Ask   *storagemarket.StorageAsk
	}
	chAsk := make(chan chAskRes)
	go func() {
		sask, err := c.ClientQueryAsk(ctx, *mi.PeerId, addr)
		if err != nil {
			chAsk <- chAskRes{Error: err.Error()}
			return
		}
		chAsk <- chAskRes{Ask: sask}
	}()

	select {
	case <-time.After(time.Second * 10):
		return nil, fmt.Errorf("query asking timed out")
	case r := <-chAsk:
		if r.Error != "" {
			return nil, fmt.Errorf("query ask had controlled error: %s", r.Error)
		}
		return r.Ask, nil
	}
}

'''
'''--- Filecoin/powergate/ffs/minerselector/sr2/sr2_test.go ---
package sr2

import (
	"context"
	"fmt"
	"testing"

	"github.com/filecoin-project/go-address"
	"github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/lotus"
)

// TestMS is meant to be runned locally since it needs a fully
// synced Lotus node.
func TestMS(t *testing.T) {
	t.SkipNow()
	lotusHost, err := multiaddr.NewMultiaddr("/ip4/127.0.0.1/tcp/5555")
	require.NoError(t, err)
	lotusToken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBbGxvdyI6WyJyZWFkIiwid3JpdGUiLCJzaWduIiwiYWRtaW4iXX0.4KpuySIvV4n6kBEXQOle-hi1Ec3lyUmRYCknz4NQyLM"

	cb, err := lotus.NewBuilder(lotusHost, lotusToken, 1)
	require.NoError(t, err)

	url := "https://raw.githubusercontent.com/filecoin-project/slingshot/master/miners.json"
	sr2, err := New(url, cb)
	require.NoError(t, err)

	for {
		_, err := sr2.GetMiners(1, ffs.MinerSelectorFilter{})
		require.NoError(t, err)
	}
}

func TestCustom(t *testing.T) {
	t.SkipNow()
	lotusHost, err := multiaddr.NewMultiaddr("/ip4/127.0.0.1/tcp/5555")
	require.NoError(t, err)
	lotusToken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBbGxvdyI6WyJyZWFkIiwid3JpdGUiLCJzaWduIiwiYWRtaW4iXX0.4KpuySIvV4n6kBEXQOle-hi1Ec3lyUmRYCknz4NQyLM"

	cb, err := lotus.NewBuilder(lotusHost, lotusToken, 1)
	require.NoError(t, err)

	c, cls, err := cb(context.Background())
	require.NoError(t, err)
	defer cls()

	addr, err := address.NewFromString("t3rvsbv5yj5lil74o33bfn5mjsdlnnogukgqua5cnumtid3kgibqeer2uaipcm57iil2ndzykzq34ebp2xajwq")
	require.NoError(t, err)
	b, err := c.WalletBalance(context.Background(), addr)
	require.NoError(t, err)
	fmt.Printf("Balance: %d\n", b)
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/astore/astore.go ---
package astore

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/textileio/powergate/v2/ffs"
)

var (
	// ErrNotFound indicates the instance doesn't exist.
	ErrNotFound = errors.New("action not found")

	dsBaseStorageAction   = datastore.NewKey("storageaction")
	dsBaseRetrievalAction = datastore.NewKey("retrievalaction")
)

// StorageAction contains information necessary to execute a
// StorageJob.
type StorageAction struct {
	APIID       ffs.APIID
	Cid         cid.Cid
	Cfg         ffs.StorageConfig
	ReplacedCid cid.Cid
}

// RetrievalAction contains information necessary to execute a
// RetrievalJob.
type RetrievalAction struct {
	APIID         ffs.APIID
	RetrievalID   ffs.RetrievalID
	PayloadCid    cid.Cid
	PieceCid      cid.Cid
	Selector      string
	Miners        []string
	WalletAddress string
	MaxPrice      uint64
}

// Store persists Actions.
type Store struct {
	ds datastore.Datastore
}

// New returns a new ActionStore backed by the Datastore.
func New(ds datastore.Datastore) *Store {
	return &Store{
		ds: ds,
	}
}

// GetStorageAction gets an action for a JobID. If doesn't exist, returns ErrNotFound.
func (s *Store) GetStorageAction(jid ffs.JobID) (StorageAction, error) {
	var a StorageAction
	buf, err := s.ds.Get(makeStorageActionKey(jid))
	if err == datastore.ErrNotFound {
		return a, ErrNotFound
	}
	if err != nil {
		return a, fmt.Errorf("get from datastore: %s", err)
	}
	if err := json.Unmarshal(buf, &a); err != nil {
		return a, fmt.Errorf("unmarshaling from datastore: %s", err)
	}
	return a, nil
}

// PutStorageAction saves a new Action for a Job.
func (s *Store) PutStorageAction(jid ffs.JobID, a StorageAction) error {
	buf, err := json.Marshal(a)
	if err != nil {
		return fmt.Errorf("json marshaling: %s", err)
	}
	if err := s.ds.Put(makeStorageActionKey(jid), buf); err != nil {
		return fmt.Errorf("saving in datastore: %s", err)
	}
	return nil
}

// GetRetrievalAction returns a the RetrievalAction corresponding to the
// RetrievalJob id.
func (s *Store) GetRetrievalAction(jid ffs.JobID) (RetrievalAction, error) {
	var a RetrievalAction
	buf, err := s.ds.Get(makeRetrievalActionKey(jid))
	if err == datastore.ErrNotFound {
		return a, ErrNotFound
	}
	if err != nil {
		return a, fmt.Errorf("get from datastore: %s", err)
	}
	if err := json.Unmarshal(buf, &a); err != nil {
		return a, fmt.Errorf("unmarshaling from datastore: %s", err)
	}
	return a, nil
}

// PutRetrievalAction saves the RetrievalAction corresponding to a RetrievalJob.
func (s *Store) PutRetrievalAction(jid ffs.JobID, a RetrievalAction) error {
	buf, err := json.Marshal(a)
	if err != nil {
		return fmt.Errorf("json marshaling: %s", err)
	}
	if err := s.ds.Put(makeRetrievalActionKey(jid), buf); err != nil {
		return fmt.Errorf("saving in datastore: %s", err)
	}
	return nil
}

func makeStorageActionKey(jid ffs.JobID) datastore.Key {
	return dsBaseStorageAction.ChildString(jid.String())
}

func makeRetrievalActionKey(jid ffs.JobID) datastore.Key {
	return dsBaseRetrievalAction.ChildString(jid.String())
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/cistore/cistore.go ---
package cistore

import (
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

var (
	log = logging.Logger("ffs-sched-cistore")

	// ErrNotFound indicates the instance doesn't exist.
	ErrNotFound = errors.New("storage info not found")
)

// Store is an Datastore implementation of StorageInfoStore.
type Store struct {
	ds datastore.Datastore
	// ToDo: Build some index in here for fetching by iid and cid etc
}

// New returns a new JobStore backed by the Datastore.
func New(ds datastore.Datastore) *Store {
	return &Store{
		ds: ds,
	}
}

// Get gets the current stored state of a Cid.
func (s *Store) Get(iid ffs.APIID, c cid.Cid) (ffs.StorageInfo, error) {
	var ci ffs.StorageInfo
	buf, err := s.ds.Get(makeKey(iid, c))
	if err == datastore.ErrNotFound {
		return ci, ErrNotFound
	}
	if err != nil {
		return ci, fmt.Errorf("getting cid info from datastore: %s", err)
	}
	if err := json.Unmarshal(buf, &ci); err != nil {
		return ci, fmt.Errorf("unmarshaling cid info from datastore: %s", err)
	}
	return ci, nil
}

// List returns a list of StorageInfo matching any provided query options.
func (s *Store) List(iids []ffs.APIID, cids []cid.Cid) ([]ffs.StorageInfo, error) {
	APIIDFilter := make(map[ffs.APIID]struct{})
	for _, id := range iids {
		APIIDFilter[id] = struct{}{}
	}

	cidFilter := make(map[cid.Cid]struct{})
	for _, cid := range cids {
		cidFilter[cid] = struct{}{}
	}

	q := query.Query{}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("querying StorageInfos: %v", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing query result: %s", err)
		}
	}()
	var ret []ffs.StorageInfo
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		if len(APIIDFilter) > 0 || len(cidFilter) > 0 {
			keyParts := strings.Split(r.Key, "/")
			if len(keyParts) != 3 {
				return nil, fmt.Errorf("parsing query result key, expected 3 parts but got %d", len(keyParts))
			}
			apiid := ffs.APIID(keyParts[1])
			cid, err := util.CidFromString(keyParts[2])
			if err != nil {
				return nil, fmt.Errorf("parsing cid from key: %v", err)
			}
			if len(APIIDFilter) > 0 {
				if _, ok := APIIDFilter[apiid]; !ok {
					continue
				}
			}
			if len(cidFilter) > 0 {
				if _, ok := cidFilter[cid]; !ok {
					continue
				}
			}
		}
		var si ffs.StorageInfo
		if err := json.Unmarshal(r.Value, &si); err != nil {
			return nil, fmt.Errorf("unmarshaling query result: %s", err)
		}
		ret = append(ret, si)
	}
	sort.Slice(ret, func(i, j int) bool {
		// Descending.
		return ret[i].Created.After(ret[j].Created)
	})
	return ret, nil
}

// Put saves a new storage state for a Cid.
func (s *Store) Put(ci ffs.StorageInfo) error {
	if !ci.APIID.Valid() {
		return fmt.Errorf("instance id is invalid")
	}
	if !ci.Cid.Defined() {
		return fmt.Errorf("cid can't be undefined")
	}
	buf, err := json.Marshal(ci)
	if err != nil {
		return fmt.Errorf("marshaling storage info for datastore: %s", err)
	}
	if err := s.ds.Put(makeKey(ci.APIID, ci.Cid), buf); err != nil {
		return fmt.Errorf("put storage info in datastore: %s", err)
	}
	return nil
}

func makeKey(iid ffs.APIID, c cid.Cid) datastore.Key {
	return datastore.NewKey(iid.String()).ChildString(util.CidToString(c))
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/ristore/cistore.go ---
package ristore

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/textileio/powergate/v2/ffs"
)

var (
	// ErrNotFound indicates there's not information for the retrieval.
	ErrNotFound = errors.New("retrieval info not found")
)

// Store stores retrieval information.
type Store struct {
	ds datastore.Datastore
}

// New returns a new retrieval information store.
func New(ds datastore.Datastore) *Store {
	return &Store{
		ds: ds,
	}
}

// Get gets information about an executed retrieval.
func (s *Store) Get(rid ffs.RetrievalID) (ffs.RetrievalInfo, error) {
	var ri ffs.RetrievalInfo
	buf, err := s.ds.Get(makeKey(rid))
	if err == datastore.ErrNotFound {
		return ri, ErrNotFound
	}
	if err != nil {
		return ri, fmt.Errorf("getting retrieval info from datastore: %s", err)
	}
	if err := json.Unmarshal(buf, &ri); err != nil {
		return ri, fmt.Errorf("unmarshaling retrieval info from datastore: %s", err)
	}
	return ri, nil
}

// Put saves new information about a retrieval.
func (s *Store) Put(ri ffs.RetrievalInfo) error {
	if ri.ID == ffs.EmptyRetrievalID {
		return fmt.Errorf("retrieval id can't be empty")
	}
	buf, err := json.Marshal(ri)
	if err != nil {
		return fmt.Errorf("marshaling retrieval info for datastore: %s", err)
	}
	if err := s.ds.Put(makeKey(ri.ID), buf); err != nil {
		return fmt.Errorf("putting retrieval info in datastore: %s", err)
	}
	return nil
}

func makeKey(rid ffs.RetrievalID) datastore.Key {
	return datastore.NewKey(rid.String())
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/rjstore/rjstore.go ---
package rjstore

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"

	datastore "github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
)

var (
	log = logging.Logger("ffs-sched-rjstore")

	// ErrNotFound indicates the job doesn't exists.
	ErrNotFound = errors.New("retrieval job not found")
	dsBaseJob   = datastore.NewKey("job")
)

// Store is a persistent store for retrieval jobs.
type Store struct {
	lock     sync.Mutex
	ds       datastore.Datastore
	watchers []watcher
}

// watcher represents an API instance who is watching for
// retrieval jobs updates.
type watcher struct {
	iid ffs.APIID
	C   chan ffs.RetrievalJob
}

// New returns a new retrieval job store.
func New(ds datastore.Datastore) (*Store, error) {
	s := &Store{ds: ds}
	return s, nil
}

// Finalize finalizes a retrieval job.
func (s *Store) Finalize(jid ffs.JobID, st ffs.JobStatus, jobError error) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	j, err := s.get(jid)
	if err != nil {
		return err
	}
	switch st {
	case ffs.Success, ffs.Failed, ffs.Canceled:
		// Success: Job executed within expected behavior.
		// Failed: Job executed with expected failure scenario.
		// Canceled: Job was canceled by the client.
	default:
		return fmt.Errorf("can't finalize job with status %s", ffs.JobStatusStr[st])
	}
	j.Status = st
	if jobError != nil {
		j.ErrCause = jobError.Error()
	}
	if err := s.put(j); err != nil {
		return fmt.Errorf("saving in datastore: %s", err)
	}
	return nil
}

// Dequeue dequeues a ready to be executed retrieval job.
func (s *Store) Dequeue() (*ffs.RetrievalJob, error) {
	s.lock.Lock()
	defer s.lock.Unlock()
	q := query.Query{Prefix: dsBaseJob.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("querying datastore: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing dequeue query result: %s", err)
		}
	}()
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		var j ffs.RetrievalJob
		if err := json.Unmarshal(r.Value, &j); err != nil {
			return nil, fmt.Errorf("unmarshalling job: %s", err)
		}
		if j.Status == ffs.Queued {
			j.Status = ffs.Executing
			if err := s.put(j); err != nil {
				return nil, err
			}
			return &j, nil
		}
	}
	return nil, nil
}

// Enqueue queues a new retrieval job.
func (s *Store) Enqueue(j ffs.RetrievalJob) error {
	s.lock.Lock()
	defer s.lock.Unlock()
	j.Status = ffs.Queued
	if err := s.put(j); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}
	return nil
}

// Get returns the current state of a retrieval job.
//If doesn't exist, returns ErrNotFound.
func (s *Store) Get(jid ffs.JobID) (ffs.RetrievalJob, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	return s.get(jid)
}

// Watch subscribes to retrieval job changes from a specified Api instance.
func (s *Store) Watch(ctx context.Context, c chan<- ffs.RetrievalJob, iid ffs.APIID) error {
	s.lock.Lock()
	ic := make(chan ffs.RetrievalJob, 1)
	s.watchers = append(s.watchers, watcher{iid: iid, C: ic})
	s.lock.Unlock()

	stop := false
	for !stop {
		select {
		case <-ctx.Done():
			stop = true
		case l, ok := <-ic:
			if !ok {
				return fmt.Errorf("jobstore was closed with a listening client")
			}
			c <- l
		}
	}

	s.lock.Lock()
	defer s.lock.Unlock()
	for i := range s.watchers {
		if s.watchers[i].C == ic {
			s.watchers = append(s.watchers[:i], s.watchers[i+1:]...)
			break
		}
	}
	return nil
}

// Close closes the Store, unregistering any subscribed watchers.
func (s *Store) Close() error {
	s.lock.Lock()
	defer s.lock.Unlock()
	for i := range s.watchers {
		close(s.watchers[i].C)
	}
	s.watchers = nil
	return nil
}

func (s *Store) put(j ffs.RetrievalJob) error {
	buf, err := json.Marshal(j)
	if err != nil {
		return fmt.Errorf("marshaling for datastore: %s", err)
	}
	if err := s.ds.Put(makeKey(j.ID), buf); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}
	s.notifyWatchers(j)
	return nil
}

func (s *Store) get(jid ffs.JobID) (ffs.RetrievalJob, error) {
	buf, err := s.ds.Get(makeKey(jid))
	if err == datastore.ErrNotFound {
		return ffs.RetrievalJob{}, ErrNotFound
	}
	if err != nil {
		return ffs.RetrievalJob{}, fmt.Errorf("getting job from datastore: %s", err)
	}
	var job ffs.RetrievalJob
	if err := json.Unmarshal(buf, &job); err != nil {
		return job, fmt.Errorf("unmarshaling job from datastore: %s", err)
	}
	return job, nil
}

func (s *Store) notifyWatchers(j ffs.RetrievalJob) {
	for _, w := range s.watchers {
		if w.iid != j.APIID {
			continue
		}
		select {
		case w.C <- j:
			log.Infof("notifying watcher")
		default:
			log.Warnf("slow watcher skipped job %s", j.ID)
		}
	}
}

func makeKey(jid ffs.JobID) datastore.Key {
	return dsBaseJob.ChildString(jid.String())
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/rjstore/rjstore_test.go ---
package rjstore

import (
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
)

func TestEnqueue(t *testing.T) {
	t.Parallel()
	s := create(t)
	j := createJob()
	err := s.Enqueue(j)
	require.NoError(t, err)
	jQueued, err := s.Get(j.ID)
	require.NoError(t, err)
	j.Status = ffs.Queued
	require.Equal(t, j, jQueued)
}

func TestDequeue(t *testing.T) {
	t.Parallel()
	t.Run("Success", func(t *testing.T) {
		t.Parallel()
		s := create(t)
		j := createJob()
		err := s.Enqueue(j)
		require.NoError(t, err)
		j2, err := s.Dequeue()
		require.NoError(t, err)
		j.Status = ffs.Executing
		require.NotNil(t, j2)
		require.Equal(t, j, *j2)
	})
	t.Run("Empty", func(t *testing.T) {
		t.Parallel()
		s := create(t)
		j, err := s.Dequeue()
		require.NoError(t, err)
		require.Nil(t, j)
	})
}

func createJob() ffs.RetrievalJob {
	return ffs.RetrievalJob{
		ID:          ffs.NewJobID(),
		APIID:       "ApiIDTest",
		RetrievalID: ffs.NewRetrievalID(),
	}
}

func create(t *testing.T) *Store {
	ds := tests.NewTxMapDatastore()
	store, err := New(ds)
	require.NoError(t, err)
	return store
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/sjstore/metrics.go ---
package sjstore

import (
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	attrStatusQueued    = attribute.Key("jobstatus").String("queued")
	attrStatusExecuting = attribute.Key("jobstatus").String("executing")
	attrStatusSuccess   = attribute.Key("jobstatus").String("success")
	attrStatusCanceled  = attribute.Key("jobstatus").String("canceled")
	attrStatusFailed    = attribute.Key("jobstatus").String("failed")
)

func (s *Store) initMetrics() {
	meter := global.Meter("powergate")
	s.metricJobCounter = metric.Must(meter).NewInt64UpDownCounter("powergate.storage.job.total")
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/sjstore/sjstore.go ---
package sjstore

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
	"go.opentelemetry.io/otel/metric"
)

/**
There are many namespaces that are maintained in the contained datastore.
Use these descriptions to understand what information is stored where.
Might be useful in a future migration or datastore maintenance.

/job/<job-id>: Stores StorageJob data by job-id
/apiid/<api-id>/<cid>/<timestamp>: Index on api-id primarily, cid secondarily, with timestamp, values of job-id
/cid/<cid>/<api-id>/<timestamp>: Index on cid primarily, api-id secondarily, with timestamp, values of job-id
/starteddeals_v2/<instance-id>/<cid>: Stores StartedDeals data by instance-id and cid
*/

var (
	log = logging.Logger("ffs-sched-sjstore")

	// ErrNotFound indicates the instance doesn't exist.
	ErrNotFound = errors.New("job not found")

	dsBaseJob          = datastore.NewKey("job")
	dsBaseAPIID        = datastore.NewKey("apiid")
	dsBaseCid          = datastore.NewKey("cid")
	dsBaseStartedDeals = datastore.NewKey("starteddeals_v2")
)

// Store is a Datastore implementation of JobStore, which saves
// state of scheduler Jobs.
type Store struct {
	lock     sync.Mutex
	ds       datastore.TxnDatastore
	watchers []watcher

	queued []ffs.StorageJob

	jobStatusCache map[ffs.APIID]map[cid.Cid]map[cid.Cid]deals.StorageDealInfo

	queuedJobs         map[ffs.APIID]map[cid.Cid][]*ffs.StorageJob
	executingJobs      map[ffs.APIID]map[cid.Cid]*ffs.StorageJob
	lastFinalJobs      map[ffs.APIID]map[cid.Cid]*ffs.StorageJob
	lastSuccessfulJobs map[ffs.APIID]map[cid.Cid]*ffs.StorageJob

	queuedIDs    map[ffs.JobID]struct{}
	executingIDs map[ffs.JobID]struct{}

	// Metrics
	metricJobCounter metric.Int64UpDownCounter
}

// Stats return metrics about current job queues.
type Stats struct {
	TotalQueued    int
	TotalExecuting int
}

type watcher struct {
	iid ffs.APIID
	C   chan ffs.StorageJob
}

// New returns a new JobStore backed by the Datastore.
func New(ds datastore.TxnDatastore) (*Store, error) {
	s := &Store{
		ds:                 ds,
		jobStatusCache:     make(map[ffs.APIID]map[cid.Cid]map[cid.Cid]deals.StorageDealInfo),
		queuedJobs:         make(map[ffs.APIID]map[cid.Cid][]*ffs.StorageJob),
		executingJobs:      make(map[ffs.APIID]map[cid.Cid]*ffs.StorageJob),
		lastFinalJobs:      make(map[ffs.APIID]map[cid.Cid]*ffs.StorageJob),
		lastSuccessfulJobs: make(map[ffs.APIID]map[cid.Cid]*ffs.StorageJob),
		queuedIDs:          make(map[ffs.JobID]struct{}),
		executingIDs:       make(map[ffs.JobID]struct{}),
	}
	s.initMetrics()
	if err := s.loadCaches(); err != nil {
		return nil, fmt.Errorf("reloading caches: %s", err)
	}

	return s, nil
}

// MonitorJob returns a channel that can be passed into the deal monitoring process.
func (s *Store) MonitorJob(j ffs.StorageJob) chan deals.StorageDealInfo {
	dealUpdates := make(chan deals.StorageDealInfo, 1000)
	go func() {
		for update := range dealUpdates {
			s.lock.Lock()
			_, ok := s.jobStatusCache[j.APIID]
			if !ok {
				s.jobStatusCache[j.APIID] = map[cid.Cid]map[cid.Cid]deals.StorageDealInfo{}
			}
			_, ok = s.jobStatusCache[j.APIID][j.Cid]
			if !ok {
				s.jobStatusCache[j.APIID][j.Cid] = map[cid.Cid]deals.StorageDealInfo{}
			}
			s.jobStatusCache[j.APIID][j.Cid][update.ProposalCid] = update
			job, err := s.get(j.ID)
			if err != nil {
				log.Errorf("getting job: %v", err)
				s.lock.Unlock()
				continue
			}
			values := make([]deals.StorageDealInfo, 0, len(s.jobStatusCache[j.APIID][j.Cid]))
			for _, v := range s.jobStatusCache[j.APIID][j.Cid] {
				values = append(values, v)
			}
			sort.Slice(values, func(i, j int) bool {
				return values[i].ProposalCid.String() < values[j].ProposalCid.String()
			})
			job.DealInfo = values
			if err := s.put(job, false); err != nil {
				log.Errorf("saving job with deal info updates: %v", err)
			}
			s.lock.Unlock()
		}
		s.lock.Lock()
		delete(s.jobStatusCache[j.APIID], j.Cid)
		s.lock.Unlock()
	}()
	return dealUpdates
}

// Finalize sets a Job status to a final state, i.e. Success or Failed,
// with a list of Deal errors occurred during job execution.
func (s *Store) Finalize(jid ffs.JobID, st ffs.JobStatus, jobError error, dealErrors []ffs.DealError) error {
	s.lock.Lock()
	defer s.lock.Unlock()
	j, err := s.get(jid)
	if err != nil {
		return err
	}

	ctx := context.Background()
	s.metricJobCounter.Add(ctx, -1, attrStatusExecuting)
	switch st {
	case ffs.Success:
		s.metricJobCounter.Add(ctx, 1, attrStatusSuccess)
	case ffs.Failed:
		s.metricJobCounter.Add(ctx, 1, attrStatusFailed)
	case ffs.Canceled:
		s.metricJobCounter.Add(ctx, 1, attrStatusCanceled)
	default:
		return fmt.Errorf("can't finalize job with status %s", ffs.JobStatusStr[st])
	}
	j.Status = st
	if jobError != nil {
		j.ErrCause = jobError.Error()
	}
	j.DealErrors = dealErrors
	if err := s.put(j, false); err != nil {
		return fmt.Errorf("saving in datastore: %s", err)
	}

	return nil
}

// Dequeue dequeues a Job which doesn't have have another Executing Job
// for the same Cid. Saying it differently, it's safe to execute. The returned
// job Status is automatically changed to Executing. If an instance id is provided,
// only a job for that instance id will be dequeued. If no jobs are available to dequeue
// it returns a nil *ffs.Job and no-error.
func (s *Store) Dequeue(iid ffs.APIID) (*ffs.StorageJob, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	for _, job := range s.queued {
		execJob, ok := s.executingJobs[job.APIID][job.Cid]
		isAPIIDMatch := true
		if iid != ffs.EmptyInstanceID {
			isAPIIDMatch = iid == job.APIID
		}
		if job.Status == ffs.Queued && !ok && isAPIIDMatch {
			job.Status = ffs.Executing
			if err := s.put(job, false); err != nil {
				return nil, err
			}

			ctx := context.Background()
			s.metricJobCounter.Add(ctx, -1, attrStatusQueued)
			s.metricJobCounter.Add(ctx, 1, attrStatusExecuting)

			return &job, nil
		}
		if ok {
			// ToDo: Maybe remove this since there might be lots of reasons we skip over a job.
			// For example, if the specified iid doesn't match, but that is not worth logging.
			log.Infof("queued %s is delayed since job %s is running", job.ID, execJob.ID)
		}
	}
	return nil, nil
}

// Enqueue queues a new Job. If other Job for the same Cid is in Queued status,
// it will be automatically marked as Canceled.
func (s *Store) Enqueue(j ffs.StorageJob) error {
	s.lock.Lock()
	defer s.lock.Unlock()
	if err := s.cancelQueued(j.Cid); err != nil {
		return fmt.Errorf("canceling queued jobs: %s", err)
	}
	j.Status = ffs.Queued
	if err := s.put(j, true); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}
	s.metricJobCounter.Add(context.Background(), 1, attrStatusQueued)

	return nil
}

// GetExecutingJob returns a JobID that is currently executing for
// data with cid c in iid. If there's not such job, it returns nil.
func (s *Store) GetExecutingJob(iid ffs.APIID, c cid.Cid) *ffs.JobID {
	s.lock.Lock()
	defer s.lock.Unlock()
	j, ok := s.executingJobs[iid][c]
	if !ok {
		return nil
	}
	return &j.ID
}

// GetStats return the current Stats for storage jobs.
func (s *Store) GetStats() Stats {
	s.lock.Lock()
	defer s.lock.Unlock()

	return s.getStats()
}

func (s *Store) getStats() Stats {
	var count int
	for _, iidJobs := range s.executingJobs {
		count += len(iidJobs)
	}
	return Stats{
		TotalQueued:    len(s.queued),
		TotalExecuting: count,
	}
}

// GetExecutingJobIDs returns the JobIDs of all Jobs in Executing status.
func (s *Store) GetExecutingJobIDs() []ffs.JobID {
	s.lock.Lock()
	defer s.lock.Unlock()
	var res []ffs.JobID
	for _, iid := range s.executingJobs {
		for _, j := range iid {
			res = append(res, j.ID)
		}
	}
	return res
}

// CancelQueued cancels a job if it's in Queued status.
// If the Job isn't Queued, the call is a noop. If the Job
// doesn't exist it returns ErrNotFound.
func (s *Store) CancelQueued(jid ffs.JobID) (bool, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	j, err := s.get(jid)
	if err != nil {
		return false, err
	}
	if j.Status != ffs.Queued {
		return false, nil
	}
	j.Status = ffs.Canceled
	if err := s.put(j, false); err != nil {
		return false, fmt.Errorf("canceling queued job: %s", err)
	}

	return true, nil
}

func (s *Store) cancelQueued(c cid.Cid) error {
	q := query.Query{Prefix: dsBaseJob.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying datastore: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing cancelQueued query result: %s", err)
		}
	}()
	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iter next: %s", r.Error)
		}
		var j ffs.StorageJob
		if err := json.Unmarshal(r.Value, &j); err != nil {
			return fmt.Errorf("unmarshalling job: %s", err)
		}
		if j.Status == ffs.Queued && j.Cid == c {
			j.Status = ffs.Canceled
			if err := s.put(j, false); err != nil {
				return fmt.Errorf("canceling queued job: %s", err)
			}
		}
	}
	return nil
}

// Get returns the current state of Job. If doesn't exist, returns
// ErrNotFound.
func (s *Store) Get(jid ffs.JobID) (ffs.StorageJob, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	return s.get(jid)
}

// Watch subscribes to Job changes from a specified Api instance.
func (s *Store) Watch(ctx context.Context, c chan<- ffs.StorageJob, iid ffs.APIID) error {
	s.lock.Lock()
	ic := make(chan ffs.StorageJob, 1)
	s.watchers = append(s.watchers, watcher{iid: iid, C: ic})
	s.lock.Unlock()

	stop := false
	for !stop {
		select {
		case <-ctx.Done():
			stop = true
		case l, ok := <-ic:
			if !ok {
				return fmt.Errorf("jobstore was closed with a listening client")
			}
			c <- l
		}
	}

	s.lock.Lock()
	defer s.lock.Unlock()
	for i := range s.watchers {
		if s.watchers[i].C == ic {
			s.watchers = append(s.watchers[:i], s.watchers[i+1:]...)
			break
		}
	}
	return nil
}

// StartedDeals describe deals that are currently waiting to have a
// final status.
type StartedDeals struct {
	Cid          cid.Cid
	ProposalCids []cid.Cid
}

// AddStartedDeals is a temporal storage solution of deals that are started
// are being watched. It serves as a recovery point to reattach to fired
// deals when the scheduler was abruptly interrupted.
func (s *Store) AddStartedDeals(iid ffs.APIID, c cid.Cid, proposals []cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()
	sd := StartedDeals{Cid: c, ProposalCids: proposals}
	buf, err := json.Marshal(sd)
	if err != nil {
		return fmt.Errorf("marshaling started deals: %s", err)
	}
	if err := s.ds.Put(makeStartedDealsKey(iid, c), buf); err != nil {
		return fmt.Errorf("saving started deals to datastore: %s", err)
	}
	return nil
}

// RemoveStartedDeals removes all started deals from Cid.
func (s *Store) RemoveStartedDeals(iid ffs.APIID, c cid.Cid) error {
	s.lock.Lock()
	defer s.lock.Unlock()
	if err := s.ds.Delete(makeStartedDealsKey(iid, c)); err != nil {
		return fmt.Errorf("deleting started deals from datastore: %s", err)
	}
	return nil
}

// GetStartedDeals gets all stored started deals from Cid for an APIID.
// If no started deals are present, an empty slice is returned.
func (s *Store) GetStartedDeals(iid ffs.APIID, c cid.Cid) ([]cid.Cid, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	b, err := s.ds.Get(makeStartedDealsKey(iid, c))
	if err == datastore.ErrNotFound {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("getting started deals from datastore: %s", err)
	}
	var sd StartedDeals
	if err := json.Unmarshal(b, &sd); err != nil {
		return nil, fmt.Errorf("unmarshaling started deals from datastore: %s", err)
	}
	return sd.ProposalCids, nil
}

// Select specifies which StorageJobs to list.
type Select int

const (
	// All lists all StorageJobs and is the default.
	All Select = iota
	// Queued lists queued StorageJobs.
	Queued
	// Executing lists executing StorageJobs.
	Executing
	// Final lists final StorageJobs.
	Final
)

// ListConfig controls the behavior for listing StorageJobs.
type ListConfig struct {
	// APIIDFilter filters StorageJobs list to the specified APIID. Defaults to no filter.
	APIIDFilter ffs.APIID
	// CidFilter filters StorageJobs list to the specified cid. Defaults to no filter.
	CidFilter cid.Cid
	// Limit limits the number of StorageJobs returned. Defaults to no limit.
	Limit uint64
	// Ascending returns the StorageJobs ascending by time. Defaults to false, descending.
	Ascending bool
	// Select specifies to return StorageJobs in the specified state.
	Select Select
	// NextPageToken sets the slug from which to start building the next page of results.
	NextPageToken string
}

// List lists StorageJobs according to the provided ListConfig.
func (s *Store) List(config ListConfig) ([]ffs.StorageJob, bool, string, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	byTime := func(ascending bool) func(a, b query.Entry) int {
		extractTime := func(key string) (int64, error) {
			parts := strings.Split(key, "/")
			if len(parts) != 5 {
				return 0, fmt.Errorf("expected 5 key parts but got %v", len(parts))
			}
			return strconv.ParseInt(parts[4], 10, 64)
		}
		return func(a, b query.Entry) int {
			l := a
			r := b
			if ascending {
				l = b
				r = a
			}
			lTime, err := extractTime(l.Key)
			if err != nil {
				log.Errorf("extracting time from key a: %v", err)
				return 0
			}
			rTime, err := extractTime(r.Key)
			if err != nil {
				log.Errorf("extracting time from key b: %v", err)
				return 0
			}
			if lTime > rTime {
				return -1
			} else if rTime > lTime {
				return 1
			} else {
				return 0
			}
		}
	}

	// by default, query all.
	prefix := dsBaseCid.String()
	if config.APIIDFilter != ffs.EmptyInstanceID && config.CidFilter.Defined() {
		// use apiid/cid
		prefix = prefixAPIIDAndCid(config.APIIDFilter, config.CidFilter)
	} else if config.APIIDFilter != ffs.EmptyInstanceID && !config.CidFilter.Defined() {
		// use apiid
		prefix = prefixAPIID(config.APIIDFilter)
	} else if config.APIIDFilter == ffs.EmptyInstanceID && config.CidFilter.Defined() {
		// use cid
		prefix = prefixCid(config.CidFilter)
	}

	q := query.Query{
		Prefix: prefix,
		Orders: []query.Order{query.OrderByFunction(byTime(config.Ascending))},
	}
	res, err := s.ds.Query(q)
	if err != nil {
		return nil, false, "", fmt.Errorf("querying datastore: %v", err)
	}
	var jobs []ffs.StorageJob
	foundNextPageToken := false
	if config.NextPageToken == "" {
		foundNextPageToken = true
	}
	done := false
	more := false
	nextPageToken := ""
	for r := range res.Next() {
		// return an error if there was an error iterating next.
		if r.Error != nil {
			return nil, false, "", fmt.Errorf("iter next: %s", r.Error)
		}

		// if in the last loop we decided we're done, we use this iteration
		// just to note that there is more data available then break.
		if done {
			more = true
			break
		}

		jobIDString := string(r.Value)
		jobID := ffs.JobID(jobIDString)

		// if we haven't found the record we need to seek to, continue to the next.
		if !foundNextPageToken {
			// additionally, if this is the record we are seeking to, note that we've found it, then continue.
			if config.NextPageToken == jobIDString {
				foundNextPageToken = true
			}
			continue
		}

		// Filter out based on queued/executing etc
		switch config.Select {
		case All:
		case Queued:
			if _, queued := s.queuedIDs[jobID]; !queued {
				continue
			}
		case Executing:
			if _, executing := s.executingIDs[jobID]; !executing {
				continue
			}
		case Final:
			_, queued := s.queuedIDs[jobID]
			_, executing := s.executingIDs[jobID]
			if queued || executing {
				continue
			}
		}

		job, err := s.get(jobID)
		if err != nil {
			return nil, false, "", fmt.Errorf("getting job: %v", err)
		}
		jobs = append(jobs, job)
		nextPageToken = jobIDString
		if len(jobs) == int(config.Limit) {
			done = true
		}
	}

	if !more {
		nextPageToken = ""
	}

	return jobs, more, nextPageToken, nil
}

// Close closes the Store, unregistering any subscribed watchers.
func (s *Store) Close() error {
	s.lock.Lock()
	defer s.lock.Unlock()
	for i := range s.watchers {
		close(s.watchers[i].C)
	}
	s.watchers = nil
	return nil
}

func (s *Store) put(j ffs.StorageJob, updateIndex bool) error {
	buf, err := json.Marshal(j)
	if err != nil {
		return fmt.Errorf("marshaling for datastore: %s", err)
	}

	txn, err := s.ds.NewTransaction(false)
	if err != nil {
		return fmt.Errorf("starting transaction: %s", err)
	}
	defer txn.Discard()

	if err := s.ds.Put(makeKey(j.ID), buf); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}

	if updateIndex {
		if err := s.ds.Put(makeAPIIDKey(j), []byte(j.ID)); err != nil {
			return fmt.Errorf("saving to api id index: %s", err)
		}
		if err := s.ds.Put(makeCidKey(j), []byte(j.ID)); err != nil {
			return fmt.Errorf("saving to cid index: %s", err)
		}
	}

	if err := txn.Commit(); err != nil {
		return fmt.Errorf("committing txn: %v", err)
	}

	// Update executing cids cache.
	ensureJobsMap(s.executingJobs, j.APIID)
	if j.Status == ffs.Executing {
		s.executingJobs[j.APIID][j.Cid] = &j
		s.executingIDs[j.ID] = struct{}{}
	} else {
		execJob, ok := s.executingJobs[j.APIID][j.Cid]
		if ok && execJob.ID == j.ID {
			delete(s.executingJobs[j.APIID], j.Cid)
		}
		delete(s.executingIDs, j.ID)
	}

	// Update queued cids cache.
	ensureJobsSliceMap(s.queuedJobs, j.APIID)
	if j.Status == ffs.Queued {
		// Every new Queued job goes at the tail since has
		// the biggest CreatedAt value.
		s.queued = append(s.queued, j)
		s.queuedJobs[j.APIID][j.Cid] = append(s.queuedJobs[j.APIID][j.Cid], &j)
		s.queuedIDs[j.ID] = struct{}{}
	} else { // In any other case, ensure taking it out from queued caches.
		delIndex := -1
		for i, job := range s.queued {
			if j.ID == job.ID {
				delIndex = i
				break
			}
		}
		if delIndex != -1 {
			s.queued = append(s.queued[:delIndex], s.queued[delIndex+1:]...)
		}

		delIndex = -1
		for i, job := range s.queuedJobs[j.APIID][j.Cid] {
			if j.ID == job.ID {
				delIndex = i
				break
			}
		}
		if delIndex != -1 {
			s.queuedJobs[j.APIID][j.Cid] = append(s.queuedJobs[j.APIID][j.Cid][:delIndex], s.queuedJobs[j.APIID][j.Cid][delIndex+1:]...)
		}
		delete(s.queuedIDs, j.ID)
	}

	// Update the cache of latest final jobs
	if isFinal(j) {
		ensureJobsMap(s.lastFinalJobs, j.APIID)
		s.lastFinalJobs[j.APIID][j.Cid] = &j
	}

	// Update the cache of latest successful jobs
	if isSuccessful(j) {
		ensureJobsMap(s.lastSuccessfulJobs, j.APIID)
		s.lastSuccessfulJobs[j.APIID][j.Cid] = &j
	}

	s.notifyWatchers(j)
	return nil
}

func (s *Store) get(jid ffs.JobID) (ffs.StorageJob, error) {
	buf, err := s.ds.Get(makeKey(jid))
	if err == datastore.ErrNotFound {
		return ffs.StorageJob{}, ErrNotFound
	}
	if err != nil {
		return ffs.StorageJob{}, fmt.Errorf("getting job from datastore: %s", err)
	}
	var job ffs.StorageJob
	if err := json.Unmarshal(buf, &job); err != nil {
		return job, fmt.Errorf("unmarshaling job from datastore: %s", err)
	}
	return job, nil
}

func (s *Store) notifyWatchers(j ffs.StorageJob) {
	for _, w := range s.watchers {
		if w.iid != j.APIID {
			continue
		}
		select {
		case w.C <- j:
			log.Infof("notifying watcher")
		default:
			log.Warnf("slow watcher skipped job %s", j.ID)
		}
	}
}

func (s *Store) loadCaches() error {
	s.lock.Lock()
	defer s.lock.Unlock()

	q := query.Query{Prefix: dsBaseJob.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying datastore: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing queued jobs result: %s", err)
		}
	}()
	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iter next: %s", r.Error)
		}
		var j ffs.StorageJob
		if err := json.Unmarshal(r.Value, &j); err != nil {
			return fmt.Errorf("unmarshalling job: %s", err)
		}

		if j.Status == ffs.Queued {
			s.queued = append(s.queued, j)
			ensureJobsSliceMap(s.queuedJobs, j.APIID)
			s.queuedJobs[j.APIID][j.Cid] = append(s.queuedJobs[j.APIID][j.Cid], &j)
			s.queuedIDs[j.ID] = struct{}{}
		} else if j.Status == ffs.Executing {
			ensureJobsMap(s.executingJobs, j.APIID)
			s.executingJobs[j.APIID][j.Cid] = &j
			s.executingIDs[j.ID] = struct{}{}
		}

		ensureJobsMap(s.lastFinalJobs, j.APIID)
		newest, ok := s.lastFinalJobs[j.APIID][j.Cid]
		if isFinal(j) && (!ok || j.CreatedAt > newest.CreatedAt) {
			s.lastFinalJobs[j.APIID][j.Cid] = &j
		}

		ensureJobsMap(s.lastSuccessfulJobs, j.APIID)
		newest, ok = s.lastSuccessfulJobs[j.APIID][j.Cid]
		if isSuccessful(j) && (!ok || j.CreatedAt > newest.CreatedAt) {
			s.lastSuccessfulJobs[j.APIID][j.Cid] = &j
		}
	}
	sort.Slice(s.queued, func(a, b int) bool {
		return s.queued[a].CreatedAt < s.queued[b].CreatedAt
	})
	for _, cidMap := range s.queuedJobs {
		for _, queuedJobs := range cidMap {
			sort.Slice(queuedJobs, func(a, b int) bool {
				return queuedJobs[a].CreatedAt < queuedJobs[b].CreatedAt
			})
		}
	}

	stats := s.getStats()
	ctx := context.Background()
	s.metricJobCounter.Add(ctx, int64(stats.TotalQueued), attrStatusQueued)
	s.metricJobCounter.Add(ctx, int64(stats.TotalExecuting), attrStatusExecuting)

	return nil
}

func ensureJobsMap(m map[ffs.APIID]map[cid.Cid]*ffs.StorageJob, apiID ffs.APIID) {
	_, ok := m[apiID]
	if !ok {
		m[apiID] = map[cid.Cid]*ffs.StorageJob{}
	}
}

func ensureJobsSliceMap(m map[ffs.APIID]map[cid.Cid][]*ffs.StorageJob, apiID ffs.APIID) {
	_, ok := m[apiID]
	if !ok {
		m[apiID] = map[cid.Cid][]*ffs.StorageJob{}
	}
}

func isFinal(j ffs.StorageJob) bool {
	return j.Status == ffs.Success || j.Status == ffs.Failed || j.Status == ffs.Canceled
}

func isSuccessful(j ffs.StorageJob) bool {
	return j.Status == ffs.Success
}

func makeStartedDealsKey(iid ffs.APIID, c cid.Cid) datastore.Key {
	return dsBaseStartedDeals.ChildString(iid.String()).ChildString(util.CidToString(c))
}

func makeKey(jid ffs.JobID) datastore.Key {
	return dsBaseJob.ChildString(jid.String())
}

func makeAPIIDKey(j ffs.StorageJob) datastore.Key {
	return datastore.NewKey(prefixAPIIDAndCid(j.APIID, j.Cid)).ChildString(fmt.Sprintf("%d", j.CreatedAt))
}

func makeCidKey(j ffs.StorageJob) datastore.Key {
	return datastore.NewKey(prefixCidAndAPIID(j.Cid, j.APIID)).ChildString(fmt.Sprintf("%d", j.CreatedAt))
}

func prefixCid(cid cid.Cid) string {
	return dsBaseCid.ChildString(cid.String()).String()
}

func prefixAPIID(APIID ffs.APIID) string {
	return dsBaseAPIID.ChildString(APIID.String()).String()
}

func prefixCidAndAPIID(cid cid.Cid, APIID ffs.APIID) string {
	return dsBaseCid.ChildString(cid.String()).ChildString(APIID.String()).String()
}

func prefixAPIIDAndCid(APIID ffs.APIID, cid cid.Cid) string {
	return dsBaseAPIID.ChildString(APIID.String()).ChildString(cid.String()).String()
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/sjstore/sjstore_test.go ---
package sjstore

import (
	"math/rand"
	"testing"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/multiformats/go-multihash"
	mh "github.com/multiformats/go-multihash"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
)

type apiJobs struct {
	apiid     string
	queued    int
	executing int
	final     int
}

type createdJobs struct {
	apiid     string
	queued    []ffs.StorageJob
	executing []ffs.StorageJob
	final     []ffs.StorageJob
}
type test struct {
	name    string
	apiJobs []apiJobs
	cb      func(t *testing.T, s *Store, createdJobs ...createdJobs)
}

var testsList = []test{
	{
		name: "list all apis queued",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Select: Queued})
			require.NoError(t, err)
			require.Len(t, res, 18)
		},
	},
	{
		name: "list all apis executing",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Select: Executing})
			require.NoError(t, err)
			require.Len(t, res, 21)
		},
	},
	{
		name: "list all apis final",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Select: Final})
			require.NoError(t, err)
			require.Len(t, res, 24)
		},
	},
	{
		name: "list all apis all",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Select: All})
			require.NoError(t, err)
			require.Len(t, res, 63)
		},
	},
	{
		name: "list all apis empty",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{})
			require.NoError(t, err)
			require.Len(t, res, 63)
		},
	},
	{
		name: "list api1 queued",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1"), Select: Queued})
			require.NoError(t, err)
			require.Len(t, res, 3)
		},
	},
	{
		name: "list api1 executing",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1"), Select: Executing})
			require.NoError(t, err)
			require.Len(t, res, 4)
		},
	},
	{
		name: "list api1 final",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1"), Select: Final})
			require.NoError(t, err)
			require.Len(t, res, 5)
		},
	},
	{
		name: "list api1 all",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1"), Select: All})
			require.NoError(t, err)
			require.Len(t, res, 12)
		},
	},
	{
		name: "list api1 empty",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1")})
			require.NoError(t, err)
			require.Len(t, res, 12)
		},
	},
	{
		name: "list all apis with cid filter",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{CidFilter: createdJobs[0].queued[0].Cid})
			require.NoError(t, err)
			require.Len(t, res, 1)
			require.Equal(t, createdJobs[0].queued[0].Cid, res[0].Cid)
		},
	},
	{
		name: "list api1 with cid filter",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api1"), CidFilter: createdJobs[0].queued[0].Cid})
			require.NoError(t, err)
			require.Len(t, res, 1)
			require.Equal(t, createdJobs[0].queued[0].Cid, res[0].Cid)
			require.Equal(t, createdJobs[0].queued[0].APIID, res[0].APIID)
		},
	},
	{
		name: "list wrong api filter with cid filter",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("api2"), CidFilter: createdJobs[0].queued[0].Cid})
			require.NoError(t, err)
			require.Len(t, res, 0)
		},
	},
	{
		name: "list nonexistent apiid",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{APIIDFilter: ffs.APIID("doesntexist")})
			require.NoError(t, err)
			require.Len(t, res, 0)
		},
	},
	{
		name: "list all apis descending",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Ascending: false})
			require.NoError(t, err)
			require.Len(t, res, 63)
			requireOrder(t, res, false)
		},
	},
	{
		name: "list all apis ascending",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, _, _, err := s.List(ListConfig{Ascending: true})
			require.NoError(t, err)
			require.Len(t, res, 63)
			requireOrder(t, res, true)
		},
	},
	{
		name: "list all apis with limit",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, more, last, err := s.List(ListConfig{Limit: 5})
			require.NoError(t, err)
			require.Len(t, res, 5)
			require.True(t, more)
			require.Greater(t, len(last), 0)
		},
	},
	{
		name: "list api1 queued with limit",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			res, more, last, err := s.List(ListConfig{Limit: 5, APIIDFilter: ffs.APIID("api1"), Select: Queued})
			require.NoError(t, err)
			require.Len(t, res, 3)
			require.False(t, more)
			require.Empty(t, last)
		},
	},
	{
		name: "iterate list with limit and next token",
		apiJobs: []apiJobs{
			{apiid: "api1", queued: 3, executing: 4, final: 5},
			{apiid: "api2", queued: 6, executing: 7, final: 8},
			{apiid: "api3", queued: 9, executing: 10, final: 11},
		},
		cb: func(t *testing.T, s *Store, createdJobs ...createdJobs) {
			numPages := 0
			more := true
			nextToken := ""
			for more {
				c := ListConfig{Limit: 10}
				if nextToken != "" {
					c.NextPageToken = nextToken
				}
				res, m, n, err := s.List(c)
				require.NoError(t, err)
				require.Greater(t, len(res), 0)
				numPages++
				nextToken = n
				more = m
			}
			require.Equal(t, 7, numPages)
		},
	},
}

func TestTests(t *testing.T) {
	for _, test := range testsList {
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			s := create(t)
			var allCreatedJobs []createdJobs
			for _, apiJobs := range test.apiJobs {
				cj := createdJobs{apiid: apiJobs.apiid}
				for i := 0; i < apiJobs.queued; i++ {
					j := createJob(t, apiJobs.apiid, cid.Undef)
					err := s.Enqueue(j)
					require.NoError(t, err)
					cj.queued = append(cj.queued, j)
				}
				for i := 0; i < apiJobs.executing; i++ {
					j := createJob(t, apiJobs.apiid, cid.Undef)
					err := s.Enqueue(j)
					require.NoError(t, err)
					dj, err := s.Dequeue(ffs.APIID(apiJobs.apiid))
					require.NoError(t, err)
					cj.executing = append(cj.executing, *dj)
				}
				for i := 0; i < apiJobs.final; i++ {
					j := createJob(t, apiJobs.apiid, cid.Undef)
					err := s.Enqueue(j)
					require.NoError(t, err)
					err = s.Finalize(j.ID, ffs.Success, nil, nil)
					require.NoError(t, err)
					cj.final = append(cj.final, j)
				}
				allCreatedJobs = append(allCreatedJobs, cj)
			}
			test.cb(t, s, allCreatedJobs...)
		})
	}
}

func TestEnqueue(t *testing.T) {
	t.Parallel()
	s := create(t)
	j := createJob(t, "apiid", cid.Undef)
	err := s.Enqueue(j)
	require.NoError(t, err)
	jQueued, err := s.Get(j.ID)
	require.NoError(t, err)
	j.Status = ffs.Queued
	require.Equal(t, j, jQueued)
}

func TestDequeue(t *testing.T) {
	t.Parallel()
	t.Run("Success", func(t *testing.T) {
		t.Parallel()
		s := create(t)
		j := createJob(t, "apiid", cid.Undef)
		err := s.Enqueue(j)
		require.NoError(t, err)
		j2, err := s.Dequeue(ffs.EmptyInstanceID)
		require.NoError(t, err)
		j.Status = ffs.Executing
		require.NotNil(t, j2)
		require.Equal(t, j, *j2)
	})
	t.Run("Empty", func(t *testing.T) {
		t.Parallel()
		s := create(t)
		j, err := s.Dequeue(ffs.EmptyInstanceID)
		require.NoError(t, err)
		require.Nil(t, j)
	})
	t.Run("ExecutingAndFinalized", func(t *testing.T) {
		t.Parallel()
		s := create(t)

		j1 := createJob(t, "apiid", cid.Undef)
		err := s.Enqueue(j1)
		require.NoError(t, err)
		_, err = s.Dequeue(ffs.EmptyInstanceID)
		require.NoError(t, err)

		j2 := createJob(t, "apiid", j1.Cid)
		err = s.Enqueue(j2)
		require.NoError(t, err)

		// Dequeue should be nil since j1 is Executing,
		// and j2 can't be returned until that fininishes since
		// both are jobs for the same Cid.
		jq, err := s.Dequeue(ffs.EmptyInstanceID)
		require.NoError(t, err)
		require.Nil(t, jq)

		errors := []ffs.DealError{{ProposalCid: cid.Undef, Miner: "t0100", Message: "abcd"}}
		err = s.Finalize(j1.ID, ffs.Success, nil, errors)
		require.NoError(t, err)
		// Dequeue now returns a new job since the Executing one
		// was finalized
		jq, err = s.Dequeue(ffs.EmptyInstanceID)
		require.NoError(t, err)
		require.NotNil(t, jq)
		j2.Status = ffs.Executing
		require.Equal(t, j2, *jq)
	})
	t.Run("APIID", func(t *testing.T) {
		t.Parallel()
		s := create(t)

		j1 := createJob(t, "apiid1", cid.Undef)
		err := s.Enqueue(j1)
		require.NoError(t, err)

		j2 := createJob(t, "apiid2", cid.Undef)
		err = s.Enqueue(j2)
		require.NoError(t, err)

		j, err := s.Dequeue(ffs.APIID("apiid2"))
		require.NoError(t, err)
		require.Equal(t, ffs.APIID("apiid2"), j.APIID)
	})
}

func TestCancelation(t *testing.T) {
	t.Parallel()
	s := create(t)

	j1 := createJob(t, "apiid", cid.Undef)
	err := s.Enqueue(j1)
	require.NoError(t, err)

	j2 := createJob(t, "apiid", j1.Cid)
	err = s.Enqueue(j2)
	require.NoError(t, err)

	j1Canceled, err := s.Get(j1.ID)
	require.NoError(t, err)
	require.Equal(t, ffs.Canceled, j1Canceled.Status)

	j2Queued, err := s.Get(j2.ID)
	require.NoError(t, err)
	require.Equal(t, ffs.Queued, j2Queued.Status)
}

func TestStartedDeals(t *testing.T) {
	t.Parallel()
	s := create(t)

	iid := ffs.NewAPIID()
	b, _ := multihash.Encode([]byte("data"), multihash.SHA1)
	cidData := cid.NewCidV1(1, b)

	fds, err := s.GetStartedDeals(iid, cidData)
	require.NoError(t, err)
	require.Equal(t, 0, len(fds))

	b, _ = multihash.Encode([]byte("prop1"), multihash.SHA1)
	cidProp1 := cid.NewCidV1(1, b)
	b, _ = multihash.Encode([]byte("prop2"), multihash.SHA1)
	cidProp2 := cid.NewCidV1(1, b)

	startedDeals := []cid.Cid{cidProp1, cidProp2}
	err = s.AddStartedDeals(iid, cidData, startedDeals)
	require.NoError(t, err)

	fds, err = s.GetStartedDeals(iid, cidData)
	require.NoError(t, err)
	require.Equal(t, startedDeals, fds)

	err = s.RemoveStartedDeals(iid, cidData)
	require.NoError(t, err)

	fds, err = s.GetStartedDeals(iid, cidData)
	require.NoError(t, err)
	require.Equal(t, 0, len(fds))
}

func requireOrder(t *testing.T, res []ffs.StorageJob, ascending bool) {
	var last *ffs.StorageJob
	for _, job := range res {
		if last != nil && !ascending {
			require.Less(t, job.CreatedAt, last.CreatedAt)
		}
		if last != nil && ascending {
			require.Greater(t, job.CreatedAt, last.CreatedAt)
		}
		tmp := &job
		bar := *tmp
		last = &bar
	}
}

func createJob(_ *testing.T, apiid string, c cid.Cid) ffs.StorageJob {
	finalCid := c
	if !finalCid.Defined() {
		data := make([]byte, 20)
		rand.Read(data)
		hash, _ := mh.Sum(data, mh.SHA2_256, -1)
		finalCid = cid.NewCidV1(cid.DagCBOR, hash)
	}

	return ffs.StorageJob{
		ID:        ffs.NewJobID(),
		APIID:     ffs.APIID(apiid),
		Cid:       finalCid,
		CreatedAt: time.Now().UnixNano(),
	}
}

func create(t *testing.T) *Store {
	ds := tests.NewTxMapDatastore()
	store, err := New(ds)
	require.NoError(t, err)
	return store
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/trackstore/trackstore.go ---
package trackstore

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
)

// Store persist information about storage configs which
// should be repaired or renewed. It always contain the
// latest Storage Config value of a Cid to execute those actions.
// This store is used by the Scheduler background jobs that
// repair or renew storage configurations.
type Store struct {
	lock sync.Mutex
	ds   datastore.Datastore
}

// TrackedStorageConfig has information about a StorageConfig from
// an APIID which is repairable/renewable.
type TrackedStorageConfig struct {
	IID           ffs.APIID
	StorageConfig ffs.StorageConfig
}

// TrackedCid contains tracked storage configs for a Cid.
type TrackedCid struct {
	Cid     cid.Cid
	Tracked []TrackedStorageConfig
}

// New retruns a new Store.
func New(ds datastore.Datastore) (*Store, error) {
	return &Store{ds: ds}, nil
}

// Put updates the StorageConfig tracking state for a Cid.
// If the StorageConfig is repairable or renewable, it will be
// added (or updated if exist) for a Cid. If it isn't repairable
// or renewable, it will ensure it's removed from the store
// if exists. This last point happens when a StorageConfig
// which was repairable/renewable get that feature disabled.
func (s *Store) Put(iid ffs.APIID, c cid.Cid, sc ffs.StorageConfig) error {
	s.lock.Lock()
	defer s.lock.Unlock()

	scs, err := s.get(c)
	if err != nil {
		return fmt.Errorf("getting current storage configs for cid: %s", err)
	}
	idx := -1
	for i := range scs {
		if scs[i].IID == iid {
			idx = i
			break
		}
	}

	isRepairable := sc.Repairable
	isRenewable := sc.Cold.Enabled && sc.Cold.Filecoin.Renew.Enabled
	// If has any of the interesting features, it should be in the slice.
	if isRepairable || isRenewable {
		if idx == -1 {
			nsc := TrackedStorageConfig{IID: iid, StorageConfig: sc}
			scs = append(scs, nsc)
		} else {
			scs[idx].StorageConfig = sc
		}
	} else { // Not interesting storage config to track, remove if present or simply return.
		if idx != -1 {
			scs[idx] = scs[len(scs)-1]
			scs = scs[:len(scs)-1]
		} else {
			return nil
		}
	}

	if err := s.persist(c, scs); err != nil {
		return fmt.Errorf("persisting updated storage configs for cid: %s", err)
	}

	return nil
}

// Remove removes tracking the storage config from iid.
func (s *Store) Remove(iid ffs.APIID, c cid.Cid) error {
	scs, err := s.get(c)
	if err != nil {
		return fmt.Errorf("getting current storage configs for cid: %s", err)
	}
	idx := -1
	for i := range scs {
		if scs[i].IID == iid {
			idx = i
			break
		}
	}
	if idx != -1 {
		scs[idx] = scs[len(scs)-1]
		scs = scs[:len(scs)-1]
	}
	if err := s.persist(c, scs); err != nil {
		return fmt.Errorf("persisting updated storage configs for cid: %s", err)
	}
	return nil
}

// GetRepairables returns all the tracked repairable storage configs.
func (s *Store) GetRepairables() ([]TrackedCid, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	tcs, err := s.query(false, true)
	if err != nil {
		return nil, fmt.Errorf("getting repairable cids from datastore: %s", err)
	}

	return tcs, nil
}

// GetRenewables returns all the tracked renewable storage configs.
func (s *Store) GetRenewables() ([]TrackedCid, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	tcs, err := s.query(true, false)
	if err != nil {
		return nil, fmt.Errorf("getting renewable cids from datastore: %s", err)
	}

	return tcs, nil
}

func (s *Store) query(renewable bool, repairable bool) ([]TrackedCid, error) {
	q := query.Query{}
	r, err := s.ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("querying persisted tracked storage configs: %s", err)
	}
	defer func() { _ = r.Close() }()

	var res []TrackedCid
	for v := range r.Next() {
		if v.Error != nil {
			return nil, fmt.Errorf("iterating query result: %s", v.Error)
		}
		var tscs []TrackedStorageConfig
		if err := json.Unmarshal(v.Value, &tscs); err != nil {
			return nil, fmt.Errorf("unmarshaling storage configs: %s", err)
		}
		cidStr := strings.TrimPrefix(v.Key, "/")
		c, err := cid.Decode(cidStr)
		if err != nil {
			return nil, fmt.Errorf("decoding cid: %s", err)
		}

		tc := TrackedCid{Cid: c}
		for _, tsc := range tscs {
			isRepairable := tsc.StorageConfig.Repairable
			isRenewable := tsc.StorageConfig.Cold.Enabled && tsc.StorageConfig.Cold.Filecoin.Renew.Enabled
			if (repairable && isRepairable) || (renewable && isRenewable) {
				tc.Tracked = append(tc.Tracked, tsc)
			}
		}
		if len(tc.Tracked) > 0 {
			res = append(res, tc)
		}
	}
	return res, nil
}

func (s *Store) persist(c cid.Cid, scs []TrackedStorageConfig) error {
	// If the list of storage configs resulted to be empty, then remove it from datastore.
	key := datastore.NewKey(c.String())
	if len(scs) == 0 {
		if err := s.ds.Delete(key); err != nil {
			return fmt.Errorf("deleting empty storage configs for cid: %s", err)
		}
		return nil
	}

	// Persist the updated storage config list for the cid.
	buf, err := json.Marshal(scs)
	if err != nil {
		return fmt.Errorf("marshaling storage configs: %s", err)
	}
	if err := s.ds.Put(key, buf); err != nil {
		return fmt.Errorf("saving storage config list in datastore: %s", err)
	}
	return nil
}

func (s *Store) get(c cid.Cid) ([]TrackedStorageConfig, error) {
	v, err := s.ds.Get(datastore.NewKey(c.String()))
	if err == datastore.ErrNotFound {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("getting tracked storage configs: %s", err)
	}
	var tsc []TrackedStorageConfig
	if err := json.Unmarshal(v, &tsc); err != nil {
		return nil, fmt.Errorf("unmarshaling tracked storage configs: %s", err)
	}
	return tsc, nil
}

'''
'''--- Filecoin/powergate/ffs/scheduler/internal/trackstore/trackstore_test.go ---
package trackstore

import (
	"sort"
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

var (
	scRepairable = ffs.StorageConfig{
		Repairable: true,
	}
	scRenewable = ffs.StorageConfig{
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				Renew: ffs.FilRenew{
					Enabled: true,
				},
			},
		},
	}
	scRepairableRenewable = ffs.StorageConfig{
		Repairable: true,
		Cold: ffs.ColdConfig{
			Enabled: true,
			Filecoin: ffs.FilConfig{
				Renew: ffs.FilRenew{
					Enabled: true,
				},
			},
		},
	}
)

func TestEmpty(t *testing.T) {
	t.Parallel()
	ts := create(t)

	repairables, err := ts.GetRepairables()
	require.NoError(t, err)
	require.Len(t, repairables, 0)

	renewables, err := ts.GetRenewables()
	require.NoError(t, err)
	require.Len(t, renewables, 0)
}

func TestPut(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	// Repairable
	c1, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c1, scRepairable)
	require.NoError(t, err)

	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid}})

	// Renewable
	c2, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs82")
	err = ts.Put(iid, c2, scRenewable)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c2, IIDs: []ffs.APIID{iid}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid}})
}

func TestDoublePut(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRepairable)
	require.NoError(t, err)
	err = ts.Put(iid, c, scRepairable)
	require.NoError(t, err)

	requireRepairables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})
}

func TestUninterestingPut(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	scUninteresting := ffs.StorageConfig{}
	err := ts.Put(iid, c, scUninteresting)
	require.NoError(t, err)

	requireRepairables(t, ts)
}

func TestRevertedPut(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	// Add some repariable
	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRepairable)
	require.NoError(t, err)
	requireRepairables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})

	// Put again but not repariable, should be gone.
	scUninteresting := ffs.StorageConfig{}
	err = ts.Put(iid, c, scUninteresting)
	require.NoError(t, err)
	requireRepairables(t, ts)
}

func TestPutRenewableRepairable(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRepairableRenewable)
	require.NoError(t, err)

	requireRepairables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})
	requireRenewables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})
}

func TestPutRenewableRepairableReverted(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRepairableRenewable)
	require.NoError(t, err)
	err = ts.Put(iid, c, scRenewable)
	require.NoError(t, err)
	requireRepairables(t, ts)
	requireRenewables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})
}

func TestPutRenewableSwitchRepairable(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRenewable)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})

	err = ts.Put(iid, c, scRepairable)
	require.NoError(t, err)
	requireRenewables(t, ts)
	requireRepairables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})
}

func TestRemove(t *testing.T) {
	t.Parallel()

	ts := create(t)
	iid := ffs.NewAPIID()

	c, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	err := ts.Put(iid, c, scRenewable)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c, IIDs: []ffs.APIID{iid}})

	err = ts.Remove(iid, c)
	require.NoError(t, err)

	requireRenewables(t, ts)
	requireRepairables(t, ts)
}

func TestPutMultipleIIDsWithRemoves(t *testing.T) {
	t.Parallel()

	ts := create(t)
	c1, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs81")
	c2, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs82")
	c3, _ := util.CidFromString("QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs83")

	// IID1:
	// - c1 repairable
	// - c2 renewable
	iid1 := ffs.APIID("1")
	err := ts.Put(iid1, c1, scRepairable)
	require.NoError(t, err)
	err = ts.Put(iid1, c2, scRenewable)
	require.NoError(t, err)

	// IID2:
	// - c1 repairable
	// - c2 renewable
	iid2 := ffs.APIID("2")
	err = ts.Put(iid2, c1, scRepairable)
	require.NoError(t, err)
	err = ts.Put(iid2, c2, scRenewable)
	require.NoError(t, err)

	requireRenewables(t, ts, expected{Cid: c2, IIDs: []ffs.APIID{iid1, iid2}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid1, iid2}})

	// IID3:
	// - c1 renewable
	// - c3 renewable
	iid3 := ffs.APIID("3")
	err = ts.Put(iid3, c1, scRenewable)
	require.NoError(t, err)
	err = ts.Put(iid3, c3, scRenewable)
	require.NoError(t, err)

	requireRenewables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid3}}, expected{Cid: c2, IIDs: []ffs.APIID{iid1, iid2}}, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid1, iid2}})

	// Remove arbitrary and check correctness.
	err = ts.Remove(iid2, c2)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid3}}, expected{Cid: c2, IIDs: []ffs.APIID{iid1}}, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid1, iid2}})

	err = ts.Remove(iid3, c1)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c2, IIDs: []ffs.APIID{iid1}}, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid1, iid2}})

	err = ts.Remove(iid1, c1)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c2, IIDs: []ffs.APIID{iid1}}, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid2}})

	err = ts.Remove(iid1, c2)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts, expected{Cid: c1, IIDs: []ffs.APIID{iid2}})

	err = ts.Remove(iid2, c1)
	require.NoError(t, err)
	requireRenewables(t, ts, expected{Cid: c3, IIDs: []ffs.APIID{iid3}})
	requireRepairables(t, ts)

	err = ts.Remove(iid3, c3)
	require.NoError(t, err)
	requireRenewables(t, ts)
	requireRepairables(t, ts)
}

type expected struct {
	Cid  cid.Cid
	IIDs []ffs.APIID
}

func requireRepairables(t *testing.T, ts *Store, exp ...expected) {
	t.Helper()
	tcs, err := ts.GetRepairables()
	require.NoError(t, err)
	require.Len(t, tcs, len(exp))

	sortTC(tcs)
	for i := range exp {
		require.Equal(t, exp[i].Cid, tcs[i].Cid)
		for j := range exp[i].IIDs {
			require.Equal(t, exp[i].IIDs[j], tcs[i].Tracked[j].IID)
			require.True(t, tcs[i].Tracked[j].StorageConfig.Repairable)
		}
	}
}

func requireRenewables(t *testing.T, ts *Store, exp ...expected) {
	t.Helper()
	tcs, err := ts.GetRenewables()
	require.NoError(t, err)
	require.Len(t, tcs, len(exp))

	sortTC(tcs)
	for i := range exp {
		require.Equal(t, exp[i].Cid, tcs[i].Cid)
		for j := range exp[i].IIDs {
			require.Equal(t, exp[i].IIDs[j], tcs[i].Tracked[j].IID)
			sc := tcs[i].Tracked[j].StorageConfig
			require.True(t, sc.Cold.Enabled)
			require.True(t, sc.Cold.Filecoin.Renew.Enabled)
		}
	}
}

func sortTC(tcs []TrackedCid) {
	sort.Slice(tcs, func(i, j int) bool {
		return tcs[i].Cid.String() < tcs[j].Cid.String()
	})
	for _, tc := range tcs {
		sort.Slice(tc.Tracked, func(i, j int) bool {
			return tc.Tracked[i].IID.String() < tc.Tracked[j].IID.String()
		})
	}
}

func create(t *testing.T) *Store {
	ds := tests.NewTxMapDatastore()
	store, err := New(ds)
	require.NoError(t, err)
	return store
}

'''
'''--- Filecoin/powergate/ffs/scheduler/scheduler.go ---
package scheduler

import (
	"context"
	"errors"
	"fmt"
	"io"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/astore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/cistore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/ristore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/rjstore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/sjstore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/trackstore"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
)

var (
	log = logging.Logger("ffs-scheduler")

	// ErrNotFound is returned when an item isn't found on a Store.
	ErrNotFound = errors.New("item not found")

	// RenewalEvalFrequency is the frequency in which renewable StorageConfigs
	// will be evaluated.
	RenewalEvalFrequency = time.Hour * 24

	// RepairEvalFrequency is the frequency in which repairable StorageConfigs
	// will be evaluated.
	RepairEvalFrequency = time.Hour * 24
)

// Scheduler receives actions to store a Cid in hot and cold storage. These actions are
// created as Jobs which have a lifecycle that can be watched by external actors.
// This Jobs are executed by delegating the work to the hot and cold storage configured for
// the scheduler.
type Scheduler struct {
	cs  ffs.ColdStorage
	hs  ffs.HotStorage
	sjs *sjstore.Store
	rjs *rjstore.Store
	as  *astore.Store
	ts  *trackstore.Store
	cis *cistore.Store
	ris *ristore.Store
	l   ffs.JobLogger

	sr2RepFactor        func() (int, error)
	dealFinalityTimeout time.Duration

	gcLock sync.Mutex
	gc     GCConfig

	sd         storageDaemon
	rd         retrievalDaemon
	cancelLock sync.Mutex
	jobsCancel map[ffs.JobID]chan struct{}

	ctx      context.Context
	cancel   context.CancelFunc
	finished chan struct{}
}

// storageDaemon contains components used by
// the daemon attending the storage job executions.
type storageDaemon struct {
	rateLim       chan struct{}
	evaluateQueue chan struct{}
}

// retrievalDaemon contains components used by
// the daemon attending the retrieval jobs executions.
type retrievalDaemon struct {
	rateLim       chan struct{}
	evaluateQueue chan struct{}
}

// GCConfig provides configuration for FFS GC.
type GCConfig struct {
	StageGracePeriod time.Duration
	AutoGCInterval   time.Duration
}

// New returns a new instance of Scheduler which uses JobStore as its backing repository for state,
// HotStorage for the hot layer, and ColdStorage for the cold layer.
func New(ds datastore.TxnDatastore, l ffs.JobLogger, hs ffs.HotStorage, cs ffs.ColdStorage, maxParallel int, dealFinalityTimeout time.Duration, sr2rf func() (int, error), gcConfig GCConfig) (*Scheduler, error) {
	sjs, err := sjstore.New(txndstr.Wrap(ds, "sjstore"))
	if err != nil {
		return nil, fmt.Errorf("loading stroage jobstore: %s", err)
	}
	rjs, err := rjstore.New(txndstr.Wrap(ds, "rjstore"))
	if err != nil {
		return nil, fmt.Errorf("loading retrieval jobstore: %s", err)
	}
	as := astore.New(txndstr.Wrap(ds, "astore"))
	ts, err := trackstore.New(txndstr.Wrap(ds, "tstore"))
	if err != nil {
		return nil, fmt.Errorf("loading scheduler trackstore: %s", err)
	}

	cis := cistore.New(txndstr.Wrap(ds, "cistore_v2"))
	ris := ristore.New(txndstr.Wrap(ds, "ristore"))

	ctx, cancel := context.WithCancel(context.Background())
	sch := &Scheduler{
		cs: cs,
		hs: hs,

		sjs: sjs,
		rjs: rjs,

		as: as,
		ts: ts,

		cis: cis,
		ris: ris,

		l:  l,
		gc: gcConfig,

		jobsCancel: make(map[ffs.JobID]chan struct{}),
		sd: storageDaemon{
			rateLim:       make(chan struct{}, maxParallel),
			evaluateQueue: make(chan struct{}, 1),
		},
		rd: retrievalDaemon{
			rateLim:       make(chan struct{}, maxParallel),
			evaluateQueue: make(chan struct{}, 1),
		},

		ctx:      ctx,
		cancel:   cancel,
		finished: make(chan struct{}),

		sr2RepFactor:        sr2rf,
		dealFinalityTimeout: dealFinalityTimeout,
	}

	go sch.run()

	return sch, nil
}

// GetCidFromHot returns an io.Reader of the data from hot storage.
func (s *Scheduler) GetCidFromHot(ctx context.Context, c cid.Cid) (io.Reader, error) {
	r, err := s.hs.Get(ctx, c)
	if err != nil {
		return nil, fmt.Errorf("getting %s from hot storage: %s", c, err)
	}
	return r, nil
}

// Cancel cancels an executing Job.
func (s *Scheduler) Cancel(jid ffs.JobID) error {
	s.cancelLock.Lock()
	defer s.cancelLock.Unlock()

	ok, err := s.sjs.CancelQueued(jid)
	if err != nil {
		return fmt.Errorf("canceling potentially queued job: %s", err)
	}
	// The Job was Queued, and switched to Cancel; we're done.
	if ok {
		return nil
	}

	cancelChan, ok := s.jobsCancel[jid]
	// The Job isn't executing; nothing to do.
	if !ok {
		return nil
	}

	// Send cancel signal to executing job.
	// The main scheduler loop is responsible for
	// deleting cancelChan from the map.
	select {
	case cancelChan <- struct{}{}:
	default:
		// If this channel was already signaled,
		// don't block, this is just a cancel retry.
	}
	return nil
}

// GCStaged runs a unpinned garbage collection of stage-pins.
func (s *Scheduler) GCStaged(ctx context.Context) ([]cid.Cid, error) {
	return s.gcStaged(ctx, 0)
}

// PinnedCids returns the pinned cids from Hot-Storage.
func (s *Scheduler) PinnedCids(ctx context.Context) ([]ffs.PinnedCid, error) {
	res, err := s.hs.PinnedCids(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting pinned cids from hot-storage: %s", err)
	}
	return res, nil
}

func (s *Scheduler) gcStaged(ctx context.Context, gracePeriod time.Duration) ([]cid.Cid, error) {
	s.gcLock.Lock()
	defer s.gcLock.Unlock()
	log.Infof("running scheduler gc...")
	cids := map[cid.Cid]struct{}{}

	qj, _, _, err := s.sjs.List(sjstore.ListConfig{Select: sjstore.Queued})
	if err != nil {
		return nil, fmt.Errorf("listing queued storage jobs: %s", err)
	}
	for _, j := range qj {
		cids[j.Cid] = struct{}{}
	}
	ej, _, _, err := s.sjs.List(sjstore.ListConfig{Select: sjstore.Executing})
	if err != nil {
		return nil, fmt.Errorf("listing executing storage jobs: %s", err)
	}
	for _, j := range ej {
		cids[j.Cid] = struct{}{}
	}

	excludedCids := make([]cid.Cid, 0, len(cids))
	for c := range cids {
		excludedCids = append(excludedCids, c)
	}

	gced, err := s.hs.GCStaged(ctx, excludedCids, time.Now().Add(-gracePeriod))
	if err != nil {
		return nil, fmt.Errorf("hot-storage gc: %s", err)
	}

	log.Infof("scheduler gc ran with %d excluded cids, unpinning %d staged cids", len(excludedCids), len(gced))

	return gced, nil
}

// Close terminates the scheduler.
func (s *Scheduler) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	s.cancel()
	<-s.finished
	if err := s.sjs.Close(); err != nil {
		return fmt.Errorf("closing jobstore: %s", err)
	}
	return nil
}

// run spins the long-running goroutines that will execute
// queued storage, retrieval jobs, renewals, repairs, and gc.
func (s *Scheduler) run() {
	defer close(s.finished)

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()

		if s.gc.AutoGCInterval == 0 {
			return
		}

		for {
			select {
			case <-s.ctx.Done():
				return
			case <-time.After(s.gc.AutoGCInterval):
				if _, err := s.gcStaged(s.ctx, s.gc.StageGracePeriod); err != nil {
					log.Errorf("automatic gc: %s", err)
				}
			}
		}
	}()

	if err := s.resumeStartedDeals(); err != nil {
		log.Errorf("resuming started deals: %s", err)
		return
	}

	// Timer for evaluating renewable storage configs.
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				return
			case <-time.After(RenewalEvalFrequency):
				log.Debug("running renewal checks...")
				s.execRenewCron(s.ctx)
				log.Debug("renewal cron done")
			}
		}
	}()

	// Timer for evaluatin repairable storage configs.
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				return
			case <-time.After(RepairEvalFrequency):
				log.Debug("running repair checks...")
				s.execRepairCron(s.ctx)
				log.Debug("repair cron done")
			}
		}
	}()

	// Loop for retrievals jobs.
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				return
			case <-s.rd.evaluateQueue:
				log.Debug("evaluating retrieval job queue...")
				s.execQueuedRetrievals(s.ctx)
				log.Debug("retrieval job queue evaluated")
			}
		}
	}()

	// Force a first evaluation on start.
	go func() { s.sd.evaluateQueue <- struct{}{} }()

	// Loop for new pushed storage configs.
	for {
		select {
		case <-s.ctx.Done():
			log.Infof("terminating scheduler daemon")
			wg.Wait()
			log.Infof("scheduler daemon terminated")
			return
		case <-s.sd.evaluateQueue:
			s.printStats()
			s.execQueuedStorages(s.ctx)
			s.printStats()
		}
	}
}

func (s *Scheduler) printStats() {
	stats := s.sjs.GetStats()
	log.Infof("storage job total queued: %d, total executing: %d", stats.TotalQueued, stats.TotalExecuting)
}

func (s *Scheduler) resumeStartedDeals() error {
	ejids := s.sjs.GetExecutingJobIDs()
	// No need for rate limit since the number of "Executing"
	// jobs is always rate-limited on creation.
	for _, jid := range ejids {
		if s.ctx.Err() != nil {
			break
		}
		j, err := s.sjs.Get(jid)
		if err != nil {
			return fmt.Errorf("getting resumed queued job: %s", err)
		}

		s.printStats()
		s.sd.rateLim <- struct{}{}
		go func(j ffs.StorageJob) {
			log.Infof("resuming job %s with cid %s", j.ID, j.Cid)
			// We re-execute the pipeline as if was dequeued.
			// Both hot and cold storage can detect resumed job execution.
			s.executeQueuedStorage(j)

			s.printStats()
			<-s.sd.rateLim

			// Signal that a free slot is available for a queued job.
			select {
			case s.sd.evaluateQueue <- struct{}{}:
			default:
			}
		}(j)
	}
	return nil
}

// execRepairCron gets all repairable storage configs and
// reschedule them as if they were pushed. The scheduler main executing logic
// does whatever work is necessary to satisfy the storage config, thus
// it has repairing semantics too. If no work is needed, this scheduled
// job would have no real work done.
func (s *Scheduler) execRepairCron(ctx context.Context) {
	tcids, err := s.ts.GetRepairables()
	if err != nil {
		log.Errorf("getting repairable cid configs from store: %s", err)
		return
	}
	for _, tc := range tcids {
		for _, sc := range tc.Tracked {
			lCtx := context.WithValue(ctx, ffs.CtxStorageCid, tc.Cid)
			lCtx = context.WithValue(lCtx, ffs.CtxAPIID, sc.IID)
			s.l.Log(lCtx, "Scheduling deal repair evaluation...")
			jid, err := s.push(sc.IID, tc.Cid, sc.StorageConfig, cid.Undef)
			if err != nil {
				s.l.Log(lCtx, "Scheduling deal repair errored: %s", err)
			} else {
				s.l.Log(lCtx, "Job %s was queued for repair evaluation.", jid)
			}
		}
	}
}

// execRenewCron gets all renewable storage configs and
// reschedule them as if they were pushed. The scheduler main executing logic
// will do renewals if necessary.
func (s *Scheduler) execRenewCron(ctx context.Context) {
	tcids, err := s.ts.GetRenewables()
	if err != nil {
		log.Errorf("getting repairable cid configs from store: %s", err)
	}
	for _, tc := range tcids {
		for _, sc := range tc.Tracked {
			lCtx := context.WithValue(ctx, ffs.CtxStorageCid, tc.Cid)
			lCtx = context.WithValue(lCtx, ffs.CtxAPIID, sc.IID)
			s.l.Log(lCtx, "Scheduling deal renew evaluation...")
			jid, err := s.push(sc.IID, tc.Cid, sc.StorageConfig, cid.Undef)
			if err != nil {
				s.l.Log(lCtx, "Scheduling deal renewal errored: %s", err)
			} else {
				s.l.Log(lCtx, "Job %s was queued for renew evaluation.", jid)
			}
		}
	}
}

func (s *Scheduler) execQueuedStorages(ctx context.Context) {
	var err error
	var j *ffs.StorageJob

forLoop:
	for {
		select {
		case <-ctx.Done():
			break forLoop
		case s.sd.rateLim <- struct{}{}:
			// We have a slot, try pushing queued things.
		default:
			// If the execution pipeline is full, we can't
			// add new things as Executing.
			break forLoop
		}

		j, err = s.sjs.Dequeue(ffs.EmptyInstanceID)
		if err != nil {
			log.Errorf("getting queued jobs: %s", err)
			<-s.sd.rateLim
			return
		}
		if j == nil {
			// Make the slot available again.
			<-s.sd.rateLim
			break
		}
		go func(j ffs.StorageJob) {
			s.executeQueuedStorage(j)
			s.printStats()
			<-s.sd.rateLim

			// Signal that there's a new open slot, and
			// that other blocked Jobs with the same Cid
			// can be executed.
			select {
			case s.sd.evaluateQueue <- struct{}{}:
			default:
			}
		}(*j)
	}
}

func (s *Scheduler) executeQueuedStorage(j ffs.StorageJob) {
	cancelChan := make(chan struct{}, 1)
	// Create chan to allow Job cancellation.
	s.cancelLock.Lock()
	s.jobsCancel[j.ID] = cancelChan
	s.cancelLock.Unlock()
	defer func() {
		s.cancelLock.Lock()
		delete(s.jobsCancel, j.ID)
		s.cancelLock.Unlock()
	}()

	ctx, cancel := context.WithCancel(context.WithValue(context.Background(), ffs.CtxKeyJid, j.ID))
	defer cancel()
	ctx = context.WithValue(ctx, ffs.CtxStorageCid, j.Cid)
	ctx = context.WithValue(ctx, ffs.CtxAPIID, j.APIID)

	var cancelLock sync.Mutex
	var canceled bool
	go func() {
		// If the user called Cancel to cancel Job execution,
		// we cancel the context to finish.
		<-cancelChan
		cancelLock.Lock()
		canceled = true
		cancelLock.Unlock()
		cancel()
	}()

	// Get
	a, err := s.as.GetStorageAction(j.ID)
	if err != nil {
		log.Errorf("getting push config action data from store: %s", err)
		if err := s.sjs.Finalize(j.ID, ffs.Failed, err, nil); err != nil {
			log.Errorf("changing job to failed: %s", err)
		}
		s.l.Log(ctx, "Job %s couldn't start: %s.", j.ID, err)
		return
	}

	// Execute
	s.l.Log(ctx, "Executing job %s...", j.ID)
	dealUpdates := s.sjs.MonitorJob(j)
	info, dealErrors, err := s.executeStorage(ctx, a, j, dealUpdates)
	close(dealUpdates)
	// Something bad-enough happened to make Job
	// execution fail.
	if err != nil {
		log.Errorf("executing job %s: %s", j.ID, err)
		if err := s.sjs.Finalize(j.ID, ffs.Failed, err, dealErrors); err != nil {
			log.Errorf("changing job to failed: %s", err)
		}
		s.l.Log(ctx, "Job %s execution failed: %s", j.ID, err)
		return
	}
	// Save whatever stored information was completely/partially
	// done in execution.
	if err := s.cis.Put(info); err != nil {
		log.Errorf("saving cid info to store: %s", err)
	}

	finalStatus := ffs.Success
	// Detect if user-cancelation was triggered
	cancelLock.Lock()
	if canceled {
		finalStatus = ffs.Canceled
	}
	cancelLock.Unlock()

	// Finalize Job, saving any deals errors happened during execution.
	if err := s.sjs.Finalize(j.ID, finalStatus, nil, dealErrors); err != nil {
		log.Errorf("changing job to success: %s", err)
	}

	s.l.Log(ctx, "Job %s execution finished with status %s.", j.ID, ffs.JobStatusStr[finalStatus])
}

func (s *Scheduler) execQueuedRetrievals(ctx context.Context) {
	var err error
	var j *ffs.RetrievalJob

forLoop:
	for {
		select {
		case <-ctx.Done():
			break forLoop
		case s.rd.rateLim <- struct{}{}:
			// We have a slot, try pushing queued things.
		default:
			// If the execution pipeline is full, we can't
			// add new things as Executing.
			break forLoop
		}

		j, err = s.rjs.Dequeue()
		if err != nil {
			log.Errorf("getting queued jobs: %s", err)
			<-s.rd.rateLim
			return
		}
		if j == nil {
			// Make the slot available again.
			<-s.rd.rateLim
			break
		}
		go func(j ffs.RetrievalJob) {
			s.executeQueuedRetrievals(j)

			<-s.rd.rateLim

			// Signal that there's a new open slot, and
			// that other blocked Jobs with the same Cid
			// can be executed.
			select {
			case s.rd.evaluateQueue <- struct{}{}:
			default:
			}
		}(*j)
	}
}

func (s *Scheduler) executeQueuedRetrievals(j ffs.RetrievalJob) {
	cancelChan := make(chan struct{})
	// Create chan to allow Job cancellation.
	s.cancelLock.Lock()
	s.jobsCancel[j.ID] = cancelChan
	s.cancelLock.Unlock()
	defer func() {
		s.cancelLock.Lock()
		delete(s.jobsCancel, j.ID)
		s.cancelLock.Unlock()
	}()

	ctx, cancel := context.WithCancel(context.WithValue(context.Background(), ffs.CtxKeyJid, j.ID))
	defer cancel()
	ctx = context.WithValue(ctx, ffs.CtxRetrievalID, j.RetrievalID)
	go func() {
		// If the user called Cancel to cancel Job execution,
		// we cancel the context to finish.
		<-cancelChan
		cancel()
	}()

	// Get
	a, err := s.as.GetRetrievalAction(j.ID)
	if err != nil {
		log.Errorf("getting job action data from store: %s", err)
		if err := s.rjs.Finalize(j.ID, ffs.Failed, err); err != nil {
			log.Errorf("changing job to failed: %s", err)
		}
		s.l.Log(ctx, "Job %s couldn't start: %s.", j.ID, err)
		return
	}

	// Execute
	s.l.Log(ctx, "Executing job %s...", j.ID)
	info, err := s.executeRetrieval(ctx, a, j)

	// Something bad-enough happened to make Job
	// execution fail.
	if err != nil {
		log.Errorf("executing retrieval job %s: %s", j.ID, err)
		if err := s.rjs.Finalize(j.ID, ffs.Failed, err); err != nil {
			log.Errorf("changing retrieval job status to failed: %s", err)
		}
		s.l.Log(ctx, "Job %s execution failed: %s", j.ID, err)
		return
	}
	// Save whatever stored information was completely/partially
	// done in execution.
	if err := s.ris.Put(info); err != nil {
		log.Errorf("saving retrieval info into store: %s", err)
	}

	finalStatus := ffs.Success
	// Detect if user-cancelation was triggered
	select {
	case <-cancelChan:
		finalStatus = ffs.Canceled
	default:
	}

	// Finalize Job, saving any deals errors happened during execution.
	if err := s.rjs.Finalize(j.ID, finalStatus, nil); err != nil {
		log.Errorf("changing retrieval job to success: %s", err)
	}
	s.l.Log(ctx, "Retrieval job %s execution finished with status %s.", j.ID, ffs.JobStatusStr[finalStatus])
}

'''
'''--- Filecoin/powergate/ffs/scheduler/scheduler_import.go ---
package scheduler

import (
	"context"
	"fmt"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/cistore"
)

// ImportDeals create or augments a Storageinfo for a Cid with the provided deal ids.
// All deal ids must be active on-chain to let the operation succeed.
func (s *Scheduler) ImportDeals(iid ffs.APIID, payloadCid cid.Cid, dealIDs []uint64) error {
	// 1. Get current StorageInfo.
	si, err := s.cis.Get(iid, payloadCid)
	if err == cistore.ErrNotFound {
		si = ffs.StorageInfo{
			APIID:   iid,
			JobID:   ffs.EmptyJobID,
			Cid:     payloadCid,
			Created: time.Now(),
			Cold: ffs.ColdInfo{
				Filecoin: ffs.FilInfo{
					DataCid: payloadCid,
				},
			},
		}
	} else if err != nil {
		return fmt.Errorf("getting current storageinfo: %s", err)
	}

	// 2. Augment the retrieved/bootstraped StorageInfo with provided deals.
	if err := s.augmentStorageInfo(&si.Cold.Filecoin, dealIDs); err != nil {
		return fmt.Errorf("generating storage info from imported deals: %s", err)
	}
	if err := s.cis.Put(si); err != nil {
		return fmt.Errorf("importing cid information: %s", err)
	}

	return nil
}

func (s *Scheduler) augmentStorageInfo(fi *ffs.FilInfo, deals []uint64) error {
	// Deduplicate any already known DealID existing in StorageInfo with the
	// imported ones.
	var newDealIDs []uint64
	existingDealID := map[uint64]struct{}{}
	for _, p := range fi.Proposals {
		existingDealID[p.DealID] = struct{}{}
	}
	for _, did := range deals {
		if _, ok := existingDealID[did]; !ok {
			newDealIDs = append(newDealIDs, did)
		}
	}

	// If we have known deals, get the PieceCid. This will be used
	// for validating that the provided DealID are from deals also
	// for the same data. If that isn't the case, those DealIDs are
	// wrong to import.
	// If no known deals are present, we'll at least verify that all
	// DealIDs point to the same PieceCid, so at least are all
	// coherent. Unfortunately, there isn't a safe way to match
	// PieceCid for PayloadCid without the data.
	var pieceCid cid.Cid
	if len(fi.Proposals) > 0 {
		pieceCid = fi.Proposals[0].PieceCid
	}

	// Iterate new imported deals, and add the information
	// to StorageInfo as if Powergate made those deals.
	for _, dealID := range newDealIDs {
		fs, size, err := s.genFilStorage(dealID)
		if err != nil {
			return fmt.Errorf("generating fil storage for dealid %d: %s", dealID, err)
		}

		// If we couldn't know the right PieceCID from known deals
		// take the value from the first imported deals. Then use
		// this to also assert that other provided DealIDs are coherent
		// between each other.
		if pieceCid == cid.Undef {
			pieceCid = fs.PieceCid
		}

		// Validate that imported deals correspond all to the
		// same PieceCid. And if we already knew PieceCid from
		// previous deals Powergate did, also assert that's the case.
		if fs.PieceCid != pieceCid {
			return fmt.Errorf("invalid deal, PieceCID doesn't match: %s != %s", fs.PieceCid, pieceCid)
		}

		fi.Proposals = append(fi.Proposals, fs)

		// If our StorageInfo doesn't know about size, which is the case if we're boostrapping only
		// knowing DealIDs, then populate that data.
		if fi.Size == 0 {
			fi.Size = size
		}
	}

	return nil
}

// genFilStorage given a DealID it generates FilStorage and returns the piece size.
func (s *Scheduler) genFilStorage(dealID uint64) (ffs.FilStorage, uint64, error) {
	ctx, cls := context.WithTimeout(context.Background(), time.Second*10)
	defer cls()
	di, err := s.cs.GetDealInfo(ctx, dealID)
	if err != nil {
		return ffs.FilStorage{}, 0, fmt.Errorf("getting deal %d information: %s", dealID, err)
	}
	return ffs.FilStorage{
		DealID:     dealID,
		PieceCid:   di.Proposal.PieceCID,
		Renewed:    false,
		Duration:   int64(di.Proposal.EndEpoch) - int64(di.Proposal.StartEpoch) + 1,
		StartEpoch: uint64(di.Proposal.StartEpoch),
		Miner:      di.Proposal.Provider.String(),
		EpochPrice: di.Proposal.StoragePricePerEpoch.Uint64(),
	}, uint64(di.Proposal.PieceSize), nil
}

'''
'''--- Filecoin/powergate/ffs/scheduler/scheduler_retrieval.go ---
package scheduler

import (
	"context"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/astore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/ristore"
)

// StartRetrieval schedules a new RetrievalJob to execute a Filecoin retrieval.
func (s *Scheduler) StartRetrieval(iid ffs.APIID, rid ffs.RetrievalID, pyCid, piCid cid.Cid, sel string, miners []string, walletAddr string, maxPrice uint64) (ffs.JobID, error) {
	if iid == ffs.EmptyInstanceID {
		return ffs.EmptyJobID, fmt.Errorf("empty API ID")
	}
	if rid == ffs.EmptyRetrievalID {
		return ffs.EmptyJobID, fmt.Errorf("empty retrieval ID")
	}
	if pyCid == cid.Undef {
		return ffs.EmptyJobID, fmt.Errorf("payload cid is undefined")
	}
	if piCid == cid.Undef {
		return ffs.EmptyJobID, fmt.Errorf("piece cid is undefined")
	}
	if len(miners) == 0 {
		return ffs.EmptyJobID, fmt.Errorf("miner list can't be empty")
	}
	if walletAddr == "" {
		return ffs.EmptyJobID, fmt.Errorf("wallet address can't be empty")
	}

	jid := ffs.NewJobID()
	j := ffs.RetrievalJob{
		ID:          jid,
		APIID:       iid,
		RetrievalID: rid,
		Status:      ffs.Queued,
	}

	ctx := context.WithValue(context.Background(), ffs.CtxKeyJid, jid)
	ctx = context.WithValue(ctx, ffs.CtxRetrievalID, rid)
	s.l.Log(ctx, "Scheduling new retrieval...")

	ra := astore.RetrievalAction{
		APIID:         iid,
		RetrievalID:   rid,
		PayloadCid:    pyCid,
		PieceCid:      piCid,
		Selector:      sel,
		Miners:        miners,
		WalletAddress: walletAddr,
		MaxPrice:      maxPrice,
	}
	if err := s.as.PutRetrievalAction(j.ID, ra); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("saving retrieval action for job: %s", err)
	}

	if err := s.rjs.Enqueue(j); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("enqueuing job: %s", err)
	}

	select {
	case s.rd.evaluateQueue <- struct{}{}:
	default:
	}

	s.l.Log(ctx, "Retrieval scheduled successfully")
	return jid, nil
}

// GetRetrievalInfo returns the information about an executed retrieval.
func (s *Scheduler) GetRetrievalInfo(rid ffs.RetrievalID) (ffs.RetrievalInfo, error) {
	info, err := s.ris.Get(rid)
	if err == ristore.ErrNotFound {
		return ffs.RetrievalInfo{}, ErrNotFound
	}
	if err != nil {
		return ffs.RetrievalInfo{}, fmt.Errorf("getting retrieval info from store: %s", err)
	}
	return info, nil
}

func (s *Scheduler) executeRetrieval(ctx context.Context, a astore.RetrievalAction, j ffs.RetrievalJob) (ffs.RetrievalInfo, error) {
	// ToDo: WIP.
	_ = j
	fi, err := s.cs.Fetch(ctx, a.PayloadCid, &a.PieceCid, a.WalletAddress, a.Miners, a.MaxPrice, a.Selector)
	if err != nil {
		return ffs.RetrievalInfo{}, fmt.Errorf("fetching from cold storage: %s", err)
	}
	// ToDo: use graphsync to get the underlying DataCid to be pinned
	dataCid := cid.Undef

	size, err := s.hs.Pin(ctx, a.APIID, dataCid)
	if err != nil {
		return ffs.RetrievalInfo{}, fmt.Errorf("pinning data cid: %s", err)
	}

	ri := ffs.RetrievalInfo{
		ID:        a.RetrievalID,
		DataCid:   dataCid,
		TotalPaid: fi.FundsSpent,
		MinerAddr: fi.RetrievedMiner,
		Size:      int64(size),
	}

	return ri, nil
}

'''
'''--- Filecoin/powergate/ffs/scheduler/scheduler_storage.go ---
package scheduler

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/astore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/cistore"
	"github.com/textileio/powergate/v2/ffs/scheduler/internal/sjstore"
)

// PushConfig queues the specified StorageConfig to be executed as a new Job. It returns
// the created JobID for further tracking of its state.
func (s *Scheduler) PushConfig(iid ffs.APIID, c cid.Cid, cfg ffs.StorageConfig) (ffs.JobID, error) {
	return s.push(iid, c, cfg, cid.Undef)
}

// PushReplace queues a new StorageConfig to be executed as a new Job, replacing an oldCid that will be
// untrack in the Scheduler (i.e: deal renewals, repairing).
func (s *Scheduler) PushReplace(iid ffs.APIID, c cid.Cid, cfg ffs.StorageConfig, oldCid cid.Cid) (ffs.JobID, error) {
	if !oldCid.Defined() {
		return ffs.EmptyJobID, fmt.Errorf("cid can't be undefined")
	}
	return s.push(iid, c, cfg, oldCid)
}

func (s *Scheduler) push(iid ffs.APIID, c cid.Cid, cfg ffs.StorageConfig, oldCid cid.Cid) (ffs.JobID, error) {
	if !c.Defined() {
		return ffs.EmptyJobID, fmt.Errorf("cid can't be undefined")
	}
	if iid == ffs.EmptyInstanceID {
		return ffs.EmptyJobID, fmt.Errorf("empty API ID")
	}
	if err := cfg.Validate(); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("validating storage config: %s", err)
	}
	jid := ffs.NewJobID()
	j := ffs.StorageJob{
		ID:        jid,
		APIID:     iid,
		Cid:       c,
		Status:    ffs.Queued,
		CreatedAt: time.Now().Unix(),
	}

	ctx := context.WithValue(context.Background(), ffs.CtxKeyJid, jid)
	ctx = context.WithValue(ctx, ffs.CtxStorageCid, c)
	ctx = context.WithValue(ctx, ffs.CtxAPIID, iid)
	s.l.Log(ctx, "Pushing new configuration...")

	aa := astore.StorageAction{
		APIID:       iid,
		Cid:         c,
		Cfg:         cfg,
		ReplacedCid: oldCid,
	}
	if err := s.as.PutStorageAction(j.ID, aa); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("saving action for job: %s", err)
	}

	if err := s.ts.Put(iid, c, cfg); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("saving repairable/renewable storage config: %s", err)
	}

	if err := s.sjs.Enqueue(j); err != nil {
		return ffs.EmptyJobID, fmt.Errorf("enqueuing job: %s", err)
	}
	if jid := s.sjs.GetExecutingJob(iid, c); jid != nil {
		s.l.Log(ctx, "Job %s is already being executed for the same data, this job will be queued until it finishes or is canceled.", jid)
	}

	select {
	case s.sd.evaluateQueue <- struct{}{}:
	default:
	}

	s.l.Log(ctx, "Configuration saved successfully")
	return jid, nil
}

// Untrack untracks a Cid from iid for renewal and repair background crons.
func (s *Scheduler) Untrack(iid ffs.APIID, c cid.Cid) error {
	if err := s.ts.Remove(iid, c); err != nil {
		return fmt.Errorf("removing cid from action store: %s", err)
	}
	return nil
}

// GetStorageInfo returns the current storage state of a Cid for a APIID. Returns ErrNotFound
// if there isn't information for a Cid.
func (s *Scheduler) GetStorageInfo(iid ffs.APIID, c cid.Cid) (ffs.StorageInfo, error) {
	info, err := s.cis.Get(iid, c)
	if err == cistore.ErrNotFound {
		return ffs.StorageInfo{}, ErrNotFound
	}
	if err != nil {
		return ffs.StorageInfo{}, fmt.Errorf("getting StorageInfo from store: %s", err)
	}
	return info, nil
}

// ListStorageInfo returns a list of StorageInfo matching any provided query options.
func (s *Scheduler) ListStorageInfo(iids []ffs.APIID, cids []cid.Cid) ([]ffs.StorageInfo, error) {
	res, err := s.cis.List(iids, cids)
	if err != nil {
		return nil, fmt.Errorf("listing storage info from cistore: %v", err)
	}
	return res, nil
}

// StorageJob the current storage state of a Job.
func (s *Scheduler) StorageJob(jid ffs.JobID) (ffs.StorageJob, error) {
	j, err := s.sjs.Get(jid)
	if err != nil {
		if err == sjstore.ErrNotFound {
			return ffs.StorageJob{}, ErrNotFound
		}
		return ffs.StorageJob{}, fmt.Errorf("get Job from store: %s", err)
	}
	return j, nil
}

// WatchJobs returns a channel to listen to Job status changes from a specified
// API instance. It immediately pushes the current Job state to the channel.
func (s *Scheduler) WatchJobs(ctx context.Context, c chan<- ffs.StorageJob, iid ffs.APIID) error {
	return s.sjs.Watch(ctx, c, iid)
}

// WatchLogs writes to a channel all new logs for Cids. The context should be
// canceled when wanting to stop receiving updates to the channel.
func (s *Scheduler) WatchLogs(ctx context.Context, c chan<- ffs.LogEntry) error {
	return s.l.Watch(ctx, c)
}

// GetLogsByCid returns history logs of a Cid.
func (s *Scheduler) GetLogsByCid(ctx context.Context, iid ffs.APIID, c cid.Cid) ([]ffs.LogEntry, error) {
	lgs, err := s.l.GetByCid(ctx, iid, c)
	if err != nil {
		return nil, fmt.Errorf("getting logs: %s", err)
	}
	return lgs, nil
}

// Select specifies which StorageJobs to list.
type Select int

const (
	// All lists all StorageJobs and is the default.
	All Select = iota
	// Queued lists queued StorageJobs.
	Queued
	// Executing lists executing StorageJobs.
	Executing
	// Final lists final StorageJobs.
	Final
)

// ListStorageJobsConfig controls the behavior for listing StorageJobs.
type ListStorageJobsConfig struct {
	// APIIDFilter filters StorageJobs list to the specified APIID. Defaults to no filter.
	APIIDFilter ffs.APIID
	// CidFilter filters StorageJobs list to the specified cid. Defaults to no filter.
	CidFilter cid.Cid
	// Limit limits the number of StorageJobs returned. Defaults to no limit.
	Limit uint64
	// Ascending returns the StorageJobs ascending by time. Defaults to false, descending.
	Ascending bool
	// Select specifies to return StorageJobs in the specified state.
	Select Select
	// NextPageToken sets the slug from which to start building the next page of results.
	NextPageToken string
}

// ListStorageJobs lists StorageJobs according to the provided ListStorageJobsConfig.
func (s *Scheduler) ListStorageJobs(config ListStorageJobsConfig) ([]ffs.StorageJob, bool, string, error) {
	c := sjstore.ListConfig{
		APIIDFilter:   config.APIIDFilter,
		CidFilter:     config.CidFilter,
		Limit:         config.Limit,
		Ascending:     config.Ascending,
		Select:        sjstore.Select(config.Select),
		NextPageToken: config.NextPageToken,
	}
	return s.sjs.List(c)
}

// StorageConfig returns the storage config for a job.
func (s *Scheduler) StorageConfig(jid ffs.JobID) (ffs.StorageConfig, error) {
	a, err := s.as.GetStorageAction(jid)
	if err == astore.ErrNotFound {
		return ffs.StorageConfig{}, ErrNotFound
	}
	if err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("getting storage action: %v", err)
	}
	return a.Cfg, nil
}

// executeStorage executes a Job. If an error is returned, it means that the Job
// should be considered failed. If error is nil, it still can return []ffs.DealError
// since some deals failing isn't necessarily a fatal Job config execution.
func (s *Scheduler) executeStorage(ctx context.Context, a astore.StorageAction, job ffs.StorageJob, dealUpdates chan deals.StorageDealInfo) (ffs.StorageInfo, []ffs.DealError, error) {
	ci, err := s.getRefreshedInfo(ctx, a.APIID, a.Cid)
	if err != nil {
		return ffs.StorageInfo{}, nil, fmt.Errorf("getting current cid info from store: %s", err)
	}

	if a.ReplacedCid.Defined() {
		if err := s.Untrack(a.APIID, a.ReplacedCid); err != nil && err != astore.ErrNotFound {
			return ffs.StorageInfo{}, nil, fmt.Errorf("untracking replaced cid: %s", err)
		}
	}

	var hot ffs.HotInfo
	if a.Cfg.Hot.Enabled {
		s.l.Log(ctx, "Executing Hot-Storage configuration...")
		hot, err = s.executeEnabledHotStorage(ctx, a.APIID, ci, a.Cfg.Hot, a.Cfg.Cold.Filecoin.Addr, a.ReplacedCid)
		if err != nil {
			s.l.Log(ctx, "Enabled Hot-Storage excution failed.")
			return ffs.StorageInfo{}, nil, fmt.Errorf("executing enabled hot-storage: %s", err)
		}
		s.l.Log(ctx, "Hot-Storage configuration ran successfully.")
	}

	// We want to avoid relying on Lotus working in online-mode.
	// We need to take care ourselves of pulling the data from
	// the IPFS network.
	if !a.Cfg.Hot.Enabled && a.Cfg.Cold.Enabled {
		s.l.Log(ctx, "Automatically staging Cid from the IPFS network...")
		stageCtx, cancel := context.WithTimeout(ctx, time.Duration(a.Cfg.Hot.Ipfs.AddTimeout)*time.Second)
		defer cancel()
		if err := s.hs.StageCid(stageCtx, a.APIID, a.Cid); err != nil {
			return ffs.StorageInfo{}, nil, fmt.Errorf("automatically staging cid: %s", err)
		}
	}

	s.l.Log(ctx, "Executing Cold-Storage configuration...")
	cold, errors, err := s.executeColdStorage(ctx, ci, a.Cfg.Cold, dealUpdates)
	if err != nil {
		s.l.Log(ctx, "Cold-Storage execution failed.")
		return ffs.StorageInfo{}, errors, fmt.Errorf("executing cold-storage config: %s", err)
	}
	s.l.Log(ctx, "Cold-Storage configuration ran successfully.")

	if !a.Cfg.Hot.Enabled {
		s.l.Log(ctx, "Executing Hot-Storage configuration...")
		if err := s.executeDisabledHotStorage(ctx, a.APIID, a.Cid); err != nil {
			s.l.Log(ctx, "Disabled Hot-Storage execution failed.")
			return ffs.StorageInfo{}, nil, fmt.Errorf("executing disabled hot-storage: %s", err)
		}
		s.l.Log(ctx, "Hot-Storage configuration ran successfully.")
	}

	return ffs.StorageInfo{
		APIID:   a.APIID,
		JobID:   job.ID,
		Cid:     a.Cid,
		Hot:     hot,
		Cold:    cold,
		Created: time.Now(),
	}, errors, nil
}

// ensureCorrectPinning ensures that the Cid has the correct pinning flag in hot storage.
func (s *Scheduler) executeDisabledHotStorage(ctx context.Context, iid ffs.APIID, c cid.Cid) error {
	ok, err := s.hs.IsPinned(ctx, iid, c)
	if err != nil {
		return fmt.Errorf("getting pinned status: %s", err)
	}
	if !ok {
		s.l.Log(ctx, "Data was already unpinned.")
		return nil
	}
	if err := s.hs.Unpin(ctx, iid, c); err != nil {
		return fmt.Errorf("unpinning cid %s: %s", c, err)
	}
	s.l.Log(ctx, "Data was unpinned.")

	return nil
}

// executeEnabledHotStorageEnabled runs the logic if the Job has Hot Storage enabled.
func (s *Scheduler) executeEnabledHotStorage(ctx context.Context, iid ffs.APIID, curr ffs.StorageInfo, cfg ffs.HotConfig, waddr string, replaceCid cid.Cid) (ffs.HotInfo, error) {
	if curr.Hot.Enabled {
		s.l.Log(ctx, "No actions needed in enabling Hot Storage.")
		return curr.Hot, nil
	}

	ipfsTimeout := time.Duration(cfg.Ipfs.AddTimeout) * time.Second
	sctx, cancel := context.WithTimeout(ctx, ipfsTimeout)
	defer cancel()

	var size int
	var err error
	if !replaceCid.Defined() {
		s.l.Log(ctx, "Fetching from the IPFS network...")
		size, err = s.hs.Pin(sctx, iid, curr.Cid)
	} else {
		s.l.Log(ctx, "Replace of previous pin %s", replaceCid)
		size, err = s.hs.Replace(sctx, iid, replaceCid, curr.Cid)
	}
	if err != nil {
		s.l.Log(ctx, "Direct fetching from IPFS wasn't possible.")
		if !cfg.AllowUnfreeze || len(curr.Cold.Filecoin.Proposals) == 0 {
			s.l.Log(ctx, "Unfreeze is disabled or active Filecoin deals are unavailable.")
			return ffs.HotInfo{}, fmt.Errorf("pinning cid in hot storage: %s", err)
		}
		s.l.Log(ctx, "Unfreezing from Filecoin...")
		if len(curr.Cold.Filecoin.Proposals) == 0 {
			return ffs.HotInfo{}, fmt.Errorf("no active deals to make retrieval possible")
		}
		var pieceCid *cid.Cid
		var miners []string
		for _, p := range curr.Cold.Filecoin.Proposals {
			if p.PieceCid != cid.Undef {
				pieceCid = &p.PieceCid
			}
			miners = append(miners, p.Miner)
		}

		fi, err := s.cs.Fetch(ctx, curr.Cold.Filecoin.DataCid, pieceCid, waddr, miners, cfg.UnfreezeMaxPrice, "")
		if err != nil {
			return ffs.HotInfo{}, fmt.Errorf("unfreezing from Cold Storage: %s", err)
		}
		s.l.Log(ctx, "Unfrozen successfully from %s with cost %d attoFil, saving in Hot-Storage...", fi.RetrievedMiner, fi.FundsSpent)
		size, err = s.hs.Pin(ctx, iid, curr.Cold.Filecoin.DataCid)
		if err != nil {
			return ffs.HotInfo{}, fmt.Errorf("pinning unfrozen cid: %s", err)
		}
	}
	return ffs.HotInfo{
		Enabled: true,
		Size:    size,
		Ipfs: ffs.IpfsHotInfo{
			Created: time.Now(),
		},
	}, nil
}

func (s *Scheduler) getRefreshedInfo(ctx context.Context, iid ffs.APIID, c cid.Cid) (ffs.StorageInfo, error) {
	var err error
	ci, err := s.cis.Get(iid, c)
	if err != nil {
		if err != cistore.ErrNotFound {
			return ffs.StorageInfo{}, ErrNotFound
		}
		return ffs.StorageInfo{Cid: c, APIID: iid}, nil // Default value has both storages disabled
	}

	ci.Hot, err = s.getRefreshedHotInfo(ctx, iid, c, ci.Hot)
	if err != nil {
		return ffs.StorageInfo{}, fmt.Errorf("getting refreshed hot info: %s", err)
	}

	ci.Cold, err = s.getRefreshedColdInfo(ctx, ci.Cold)
	if err != nil {
		return ffs.StorageInfo{}, fmt.Errorf("getting refreshed cold info: %s", err)
	}

	return ci, nil
}

func (s *Scheduler) getRefreshedHotInfo(ctx context.Context, iid ffs.APIID, c cid.Cid, curr ffs.HotInfo) (ffs.HotInfo, error) {
	var err error
	curr.Enabled, err = s.hs.IsPinned(ctx, iid, c)
	if err != nil {
		return ffs.HotInfo{}, err
	}
	return curr, nil
}

func (s *Scheduler) getRefreshedColdInfo(ctx context.Context, curr ffs.ColdInfo) (ffs.ColdInfo, error) {
	activeDeals := make([]ffs.FilStorage, 0, len(curr.Filecoin.Proposals))
	for _, fp := range curr.Filecoin.Proposals {
		_, err := s.cs.GetDealInfo(ctx, fp.DealID)
		if err == ffs.ErrOnChainDealNotFound {
			s.l.Log(ctx, "Detected that deal %d isn't active anymore, removing from active deals.", fp.DealID)
			continue
		}
		if err != nil {
			return ffs.ColdInfo{}, fmt.Errorf("getting deal %d state: %s", fp.DealID, err)
		}
		activeDeals = append(activeDeals, fp)
	}
	curr.Filecoin.Proposals = activeDeals
	return curr, nil
}

func (s *Scheduler) executeColdStorage(ctx context.Context, curr ffs.StorageInfo, cfg ffs.ColdConfig, dealUpdates chan deals.StorageDealInfo) (ffs.ColdInfo, []ffs.DealError, error) {
	if !cfg.Enabled {
		s.l.Log(ctx, "Cold-Storage was disabled, Filecoin deals will eventually expire.")
		return curr.Cold, nil, nil
	}
	curr.Cold.Enabled = true

	// 1. If we recognize there were some unfinished started deals, then
	// Powergate was closed while that was being executed. If that's the case
	// we resume tracking those deals until they finish.
	sds, err := s.sjs.GetStartedDeals(curr.APIID, curr.Cid)
	if err != nil {
		return ffs.ColdInfo{}, nil, fmt.Errorf("checking for started deals: %s", err)
	}
	var allErrors []ffs.DealError
	if len(sds) > 0 {
		s.l.Log(ctx, "Resuming %d dettached executing deals...", len(sds))
		okResumedDeals, failedResumedDeals := s.waitForDeals(ctx, curr.Cid, sds, dealUpdates)
		s.l.Log(ctx, "A total of %d resumed deals finished successfully", len(okResumedDeals))
		allErrors = append(allErrors, failedResumedDeals...)
		// Append the resumed and confirmed deals to the current active proposals
		curr.Cold.Filecoin.Proposals = append(okResumedDeals, curr.Cold.Filecoin.Proposals...)

		// We can already clean resumed started deals.
		if err := s.sjs.RemoveStartedDeals(curr.APIID, curr.Cid); err != nil {
			return ffs.ColdInfo{}, allErrors, fmt.Errorf("removing resumed started deals storage: %s", err)
		}
	}

	// 2. If this Storage Config is renewable, then let's check if any of the existing deals
	// should be renewed, and do it.
	if cfg.Filecoin.Renew.Enabled {
		if curr.Hot.Enabled {
			s.l.Log(ctx, "Checking deal renewals...")
			newFilInfo, errors, err := s.cs.EnsureRenewals(ctx, curr.Cid, curr.Cold.Filecoin, cfg.Filecoin, s.dealFinalityTimeout, dealUpdates)
			if err != nil {
				s.l.Log(ctx, "Deal renewal process couldn't be executed: %s", err)
			} else {
				for _, e := range errors {
					s.l.Log(ctx, "Deal deal renewal errored. ProposalCid: %s, Miner: %s, Cause: %s", e.ProposalCid, e.Miner, e.Message)
				}
				numDeals := len(newFilInfo.Proposals) - len(curr.Cold.Filecoin.Proposals)
				if numDeals > 0 {
					// If renew process created deals, we eagerly save this information in the datastore.
					// Further work about the new storage config could decide the Job failed and we'd lose
					// this information if not saved.
					if err := s.cis.Put(curr); err != nil {
						return ffs.ColdInfo{}, nil, fmt.Errorf("eager saving of new info: %s", err)
					}
					s.l.Log(ctx, "A total of %d new deals were created in the renewal process", numDeals)
				}
				s.l.Log(ctx, "Deal renewal evaluated successfully")
				curr.Cold.Filecoin = newFilInfo

				if err := s.cis.Put(curr); err != nil {
					log.Errorf("saving cid info to store: %s", err)
				}
			}
		} else {
			// (**) Renewable note:
			// This shouldn't happen since it would be an invalid Storage Config.
			// We can only accept "Repair" if Hot Storage is enabled.
			// We can the feature to retrieve the data from a miner,
			// put it in Hot Storage, and then try the renewal. Looks to me
			// we should be sure about doing that since it would be paying
			// for retrieval to later discard the data. Sounds like Filecoin
			// should allow renewing a deal without the need of sending the data
			// again. Still not clear.
			return ffs.ColdInfo{}, nil, fmt.Errorf("invalid storage configuration, can't be renewable with disabled hot storage")
		}
	}

	// 3. Now that we have final information about what deals are really active,
	// we calculate how many new deals should be made to ensure the desired RepFactor.
	// If the current active deals is equal or greater than desired, do nothing. If not, make
	// whatever extra deals we need to make that true.

	// Do we need to do some work?
	if s.sr2RepFactor != nil {
		cfg.Filecoin.RepFactor, err = s.sr2RepFactor()
		if err != nil {
			return ffs.ColdInfo{}, nil, fmt.Errorf("getting SR2 replication factor: %s", err)
		}
	}
	if cfg.Filecoin.RepFactor-len(curr.Cold.Filecoin.Proposals) <= 0 {
		s.l.Log(ctx, "The current replication factor is equal or higher than desired, avoiding making new deals.")
		return curr.Cold, nil, nil
	}

	// The answer is yes, calculate how many extra deals we need and create them.
	deltaFilConfig := createDeltaFilConfig(cfg, curr.Cold.Filecoin)
	s.l.Log(ctx, "Current replication factor is lower than desired, making %d new deals...", deltaFilConfig.RepFactor)
	startedProposals, rejectedProposals, size, err := s.cs.Store(ctx, curr.Cid, deltaFilConfig)
	if err != nil {
		s.l.Log(ctx, "Starting deals failed, with cause: %s", err)
		return ffs.ColdInfo{}, rejectedProposals, err
	}
	allErrors = append(allErrors, rejectedProposals...)

	// If *none* of the tried proposals succeeded, then the Job fails.
	if len(startedProposals) == 0 {
		return ffs.ColdInfo{}, allErrors, fmt.Errorf("all proposals were rejected")
	}

	// Track all deals that weren't rejected, just in case Powergate crashes/closes before
	// we see them finalize, so they can be detected and resumed on starting Powergate again (point 1. above)
	if err := s.sjs.AddStartedDeals(curr.APIID, curr.Cid, startedProposals); err != nil {
		return ffs.ColdInfo{}, rejectedProposals, err
	}

	// Wait for started deals.
	okDeals, failedDeals := s.waitForDeals(ctx, curr.Cid, startedProposals, dealUpdates)
	allErrors = append(allErrors, failedDeals...)
	if err := s.sjs.RemoveStartedDeals(curr.APIID, curr.Cid); err != nil {
		return ffs.ColdInfo{}, allErrors, fmt.Errorf("removing temporal started deals storage: %s", err)
	}

	// If the Job wasn't canceled, and not even one deal finished succcessfully,
	// consider this Job execution a failure.
	if ctx.Err() == nil && len(failedDeals) == len(startedProposals) {
		return ffs.ColdInfo{}, allErrors, fmt.Errorf("all started deals failed")
	}

	// At least 1 of the proposal deals reached a successful final status, Job succeeds.
	return ffs.ColdInfo{
		Enabled: true,
		Filecoin: ffs.FilInfo{
			DataCid:   curr.Cid,
			Size:      uint64(size),
			Proposals: append(okDeals, curr.Cold.Filecoin.Proposals...), // Append to any existing other proposals
		},
	}, allErrors, nil
}

func (s *Scheduler) waitForDeals(ctx context.Context, c cid.Cid, startedProposals []cid.Cid, dealUpdates chan deals.StorageDealInfo) ([]ffs.FilStorage, []ffs.DealError) {
	s.l.Log(ctx, "Watching deals unfold...")

	var failedDeals []ffs.DealError
	var okDeals []ffs.FilStorage
	var wg sync.WaitGroup
	var lock sync.Mutex
	wg.Add(len(startedProposals))
	for _, pc := range startedProposals {
		pc := pc
		go func() {
			defer wg.Done()

			res, err := s.cs.WaitForDeal(ctx, c, pc, s.dealFinalityTimeout, dealUpdates)
			var dealError ffs.DealError
			if err != nil {
				if !errors.As(err, &dealError) {
					dealError = ffs.DealError{
						ProposalCid: pc,
						Message:     fmt.Sprintf("waiting for deal finality: %s", err),
					}
				}
				lock.Lock()
				failedDeals = append(failedDeals, dealError)
				lock.Unlock()
				return
			}
			lock.Lock()
			okDeals = append(okDeals, res)
			lock.Unlock()
		}()
	}
	wg.Wait()
	return okDeals, failedDeals
}

func createDeltaFilConfig(cfg ffs.ColdConfig, curr ffs.FilInfo) ffs.FilConfig {
	res := cfg.Filecoin
	res.RepFactor = cfg.Filecoin.RepFactor - len(curr.Proposals)
	for _, p := range curr.Proposals {
		res.ExcludedMiners = append(res.ExcludedMiners, p.Miner)
	}
	return res
}

'''
'''--- Filecoin/powergate/ffs/types.go ---
package ffs

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/ipfs/go-cid"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/util"
)

var (
	// EmptyRetrievalID is an undef retrieval id.
	EmptyRetrievalID = RetrievalID("")
)

// RetrievalID is the identifier of a Filecoin retrieval.
type RetrievalID string

// NewRetrievalID returns an new retrieval ID.
func NewRetrievalID() RetrievalID {
	return RetrievalID(uuid.New().String())
}

// String returns a string representation of RetrievalID.
func (ri RetrievalID) String() string {
	return string(ri)
}

var (
	// EmptyJobID represents an empty JobID.
	EmptyJobID = JobID("")
)

// JobID is an identifier for a ffs.Job.
type JobID string

// NewJobID returns a new JobID.
func NewJobID() JobID {
	return JobID(uuid.New().String())
}

// String returns a string representation of JobID.
func (jid JobID) String() string {
	return string(jid)
}

var (
	// EmptyInstanceID represents an empty/invalid Instance ID.
	EmptyInstanceID = APIID("")
)

// APIID is an identifier for a Api instance.
type APIID string

// NewAPIID returns a new InstanceID.
func NewAPIID() APIID {
	return APIID(uuid.New().String())
}

// Valid returns true if the InstanceID is valid, false
// otherwise.
func (i APIID) Valid() bool {
	_, err := uuid.Parse(string(i))
	return err == nil
}

// String returns a string representation of InstanceID.
func (i APIID) String() string {
	return string(i)
}

// AuthEntry encapsulates auth info for a FFS instance.
type AuthEntry struct {
	Token string
	APIID APIID
}

// JobStatus is a type for Job statuses.
type JobStatus int

const (
	// Unspecified indicates a default or empty value.
	Unspecified JobStatus = iota
	// Queued indicates the Job is queued in the Scheduler.
	Queued
	// Executing indicates that the Job is currently being
	// executed.
	Executing
	// Failed indicates the Job failed, with job.ErrCause with
	// the error cause.
	Failed
	// Canceled indicates the Job was canceled from Queued,
	// and didn't reach execution.
	Canceled
	// Success indicates the Job was successfully executed.
	Success
)

// JobStatusStr maps JobStatus to describing string.
var JobStatusStr = map[JobStatus]string{
	Unspecified: "Unspecified",
	Queued:      "Queued",
	Executing:   "Executing",
	Failed:      "Failed",
	Canceled:    "Canceled",
	Success:     "Success",
}

// StorageJob is a task executed by the Scheduler.
type StorageJob struct {
	ID         JobID
	APIID      APIID
	Cid        cid.Cid
	Status     JobStatus
	ErrCause   string
	DealInfo   []deals.StorageDealInfo
	DealErrors []DealError
	CreatedAt  int64
}

// RetrievalJob is a retrieval task executed by the Scheduler.
type RetrievalJob struct {
	ID          JobID
	APIID       APIID
	RetrievalID RetrievalID
	Status      JobStatus
	ErrCause    string
}

// StorageConfig contains a default storage configuration for an Api instance.
type StorageConfig struct {
	Hot        HotConfig
	Cold       ColdConfig
	Repairable bool
}

// WithRepairable allows to enable/disable auto-repair.
func (s StorageConfig) WithRepairable(enabled bool) StorageConfig {
	s.Repairable = enabled
	return s
}

// WithColdEnabled allows to enable/disable Cold storage usage.
func (s StorageConfig) WithColdEnabled(enabled bool) StorageConfig {
	s.Cold.Enabled = enabled
	return s
}

// WithColdFastRetrieval sets the Fast Retrieval feature for new deals.
func (s StorageConfig) WithColdFastRetrieval(enabled bool) StorageConfig {
	s.Cold.Filecoin.FastRetrieval = enabled
	return s
}

// WithColdStartDealOffset sets the maximum time in epochs a new deal must
// be active on-chain.
func (s StorageConfig) WithColdStartDealOffset(offset int64) StorageConfig {
	s.Cold.Filecoin.DealStartOffset = offset
	return s
}

// WithColdFilCountryCodes defines a list of allowed country codes to select miners
// for deals.
func (s StorageConfig) WithColdFilCountryCodes(countryCodes []string) StorageConfig {
	s.Cold.Filecoin.CountryCodes = make([]string, len(countryCodes))
	copy(s.Cold.Filecoin.CountryCodes, countryCodes)
	return s
}

// WithColdFilExcludedMiners defines a list of miner addresses which won't be selected for
// making deals, no matter if they comply to other filters in the configuration.
func (s StorageConfig) WithColdFilExcludedMiners(miners []string) StorageConfig {
	s.Cold.Filecoin.ExcludedMiners = make([]string, len(miners))
	copy(s.Cold.Filecoin.ExcludedMiners, miners)
	return s
}

// WithColdFilTrustedMiners defines a list of trusted miners addresses which will be
// returned if available. If more miners reusults are needed, other filters will be
// applied as usual.
func (s StorageConfig) WithColdFilTrustedMiners(miners []string) StorageConfig {
	s.Cold.Filecoin.TrustedMiners = make([]string, len(miners))
	copy(s.Cold.Filecoin.TrustedMiners, miners)
	return s
}

// WithColdFilRepFactor defines the replication factor for Filecoin storage.
func (s StorageConfig) WithColdFilRepFactor(repFactor int) StorageConfig {
	s.Cold.Filecoin.RepFactor = repFactor
	return s
}

// WithColdFilDealDuration defines the duration used for deals for Filecoin storage.
func (s StorageConfig) WithColdFilDealDuration(duration int64) StorageConfig {
	s.Cold.Filecoin.DealMinDuration = duration
	return s
}

// WithColdFilRenew specifies if deals should be renewed before they expire with a particular
// threshold chain epochs.
func (s StorageConfig) WithColdFilRenew(enabled bool, threshold int) StorageConfig {
	s.Cold.Filecoin.Renew.Enabled = enabled
	s.Cold.Filecoin.Renew.Threshold = threshold
	return s
}

// WithColdMaxPrice specifies the max price that should be considered for
// deal asks even when all other filers match.
func (s StorageConfig) WithColdMaxPrice(maxPrice uint64) StorageConfig {
	s.Cold.Filecoin.MaxPrice = maxPrice
	return s
}

// WithVerifiedDeal specifies that new deals will be marked as verified assuming
// the wallet address is a verified-client.
func (s StorageConfig) WithVerifiedDeal(enabled bool) StorageConfig {
	s.Cold.Filecoin.VerifiedDeal = enabled
	return s
}

// WithFastRetrieval specifies if deal fast retrieval flag on new deals
// is enabled.
func (s StorageConfig) WithFastRetrieval(enabled bool) StorageConfig {
	s.Cold.Filecoin.FastRetrieval = enabled
	return s
}

// WithColdAddr specifies the wallet address that should be used for transactions.
func (s StorageConfig) WithColdAddr(addr string) StorageConfig {
	s.Cold.Filecoin.Addr = addr
	return s
}

// WithHotEnabled allows to enable/disable Hot storage usage.
func (s StorageConfig) WithHotEnabled(enabled bool) StorageConfig {
	s.Hot.Enabled = enabled
	return s
}

// WithHotIpfsAddTimeout specifies a timeout for fetching data in Ipfs.
func (s StorageConfig) WithHotIpfsAddTimeout(seconds int) StorageConfig {
	s.Hot.Ipfs.AddTimeout = seconds
	return s
}

// WithHotAllowUnfreeze allows the Scheduler to fetch data from cold storage,
// if the Enabled flag of hot storage switches from false->true.
func (s StorageConfig) WithHotAllowUnfreeze(allow bool) StorageConfig {
	s.Hot.AllowUnfreeze = true
	return s
}

// WithUnfreezeMaxPrice indicates the maximum price to pay for an unfreeze
// procedure.
func (s StorageConfig) WithUnfreezeMaxPrice(maxPrice uint64) StorageConfig {
	s.Hot.UnfreezeMaxPrice = maxPrice
	return s
}

// Validate validates a StorageConfig.
func (s StorageConfig) Validate() error {
	if err := s.Hot.Validate(); err != nil {
		return fmt.Errorf("hot-ipfs config is invalid: %s", err)
	}
	if err := s.Cold.Validate(); err != nil {
		return fmt.Errorf("cold-filecoin config is invalid: %s", err)
	}
	// We can't accept being renewable without hot storage enabled.
	// See the (**) note in scheduler.go
	if s.Cold.Enabled && s.Cold.Filecoin.Renew.Enabled && !s.Hot.Enabled {
		return fmt.Errorf("hot storage should be enabled to enable renewals")
	}
	return nil
}

// HotConfig is the desired storage of a Cid in a Hot Storage.
type HotConfig struct {
	// Enable indicates if Cid data is stored. If true, it will consider
	// further configurations to execute actions.
	Enabled bool
	// AllowUnfreeze indicates that if data isn't available in hot storage,
	// it's allowed to be feeded by Cold Storage if available.
	AllowUnfreeze bool
	// UnfreezeMaxPrice indicates the maximum amount of attoFil to pay for
	// retrieval of data to unfreeze.
	UnfreezeMaxPrice uint64
	// Ipfs contains configuration related to storing Cid data in a IPFS node.
	Ipfs IpfsConfig
}

// Validate validates a HotConfig.
func (hc HotConfig) Validate() error {
	if !hc.Enabled {
		return nil
	}
	if err := hc.Ipfs.Validate(); err != nil {
		return fmt.Errorf("invalid ipfs config: %s", err)
	}
	return nil
}

// IpfsConfig is the desired storage of a Cid in IPFS.
type IpfsConfig struct {
	// AddTimeout is an upper bound on adding data to IPFS node from
	// the network before failing.
	AddTimeout int
}

// Validate validates an IpfsConfig.
func (ic *IpfsConfig) Validate() error {
	if ic.AddTimeout <= 0 {
		return fmt.Errorf("add timeout should be greater than 0 seconds, got %d", ic.AddTimeout)
	}
	return nil
}

// ColdConfig is the desired state of a Cid in cold storage.
type ColdConfig struct {
	// Enabled indicates that data will be saved in Cold storage.
	// If is switched from false->true, it will consider the other attributes
	// as the desired state of the data in this Storage.
	Enabled bool
	// Filecoin describes the desired Filecoin configuration for a Cid in the
	// Filecoin network.
	Filecoin FilConfig
}

// Validate validates a ColdConfig.
func (cc ColdConfig) Validate() error {
	if !cc.Enabled {
		return nil
	}
	if err := cc.Filecoin.Validate(); err != nil {
		return fmt.Errorf("invalid Filecoin config: %s", err)
	}
	if cc.Filecoin.Addr == "" {
		return fmt.Errorf("invalid wallet address")
	}
	return nil
}

// FilConfig is the desired state of a Cid in the Filecoin network.
type FilConfig struct {
	// RepFactor indicates the desired amount of active deals
	// with different miners to store the data. While making deals
	// the other attributes of FilConfig are considered for miner selection.
	RepFactor int
	// DealMinDuration indicates the duration to be used when making new deals.
	DealMinDuration int64
	// ExcludedMiners is a set of miner addresses won't be ever be selected
	// when making new deals, even if they comply to other filters.
	ExcludedMiners []string
	// TrustedMiners is a set of miner addresses which will be forcibly used
	// when making new deals. An empty/nil list disables this feature.
	TrustedMiners []string
	// CountryCodes indicates that new deals should select miners on specific
	// countries.
	CountryCodes []string
	// Renew indicates deal-renewal configuration.
	Renew FilRenew
	// Addr is the wallet address used to store the data in filecoin
	Addr string
	// MaxPrice is the maximum price that will be spent per RepFactor to store the data in units of attoFIL per GiB per epoch
	MaxPrice uint64
	// FastRetrieval indicates that created deals should enable the
	// fast retrieval feature.
	FastRetrieval bool
	// DealStartOffset indicates how many epochs in the future impose a
	// deadline to new deals being active on-chain. This value might influence
	// if miners accept deals, since they should seal fast enough to satisfy
	// this constraint.
	DealStartOffset int64
	// VerifiedDeal indicates if new deals should be marked as verified.
	VerifiedDeal bool
}

// Validate returns a non-nil error if the configuration is invalid.
func (fc *FilConfig) Validate() error {
	if fc.RepFactor <= 0 {
		return fmt.Errorf("replication factor should be greater than zero, got %d", fc.RepFactor)
	}
	if fc.DealMinDuration < util.MinDealDuration {
		return fmt.Errorf("deal duration should be greater than minimum, got %d", fc.DealMinDuration)
	}
	if err := fc.Renew.Validate(); err != nil {
		return fmt.Errorf("invalid renew config: %s", err)
	}
	return nil
}

// FilRenew contains renew configuration for a Cid Cold Storage deals.
type FilRenew struct {
	// Enabled indicates that deal-renewal is enabled for this Cid.
	Enabled bool
	// Threshold indicates how many epochs before expiring should trigger
	// deal renewal. e.g: 100 epoch before expiring.
	Threshold int
}

// Validate returns a non-nil error if the configuration is invalid.
func (fr *FilRenew) Validate() error {
	if fr.Enabled && fr.Threshold <= 0 {
		return fmt.Errorf("renew threshold should be positive: %d", fr.Threshold)
	}
	return nil
}

// RetrievalInfo has data about an executed Filecoin retrieval.
type RetrievalInfo struct {
	ID        RetrievalID
	DataCid   cid.Cid
	TotalPaid uint64
	MinerAddr string
	Size      int64
	CreatedAt time.Time
}

// StorageInfo contains information about the current storage state
// of a Cid.
type StorageInfo struct {
	// APIID indicate from which instance this
	// information belongs.
	APIID APIID
	// JobID indicates the Job ID which updated
	// the current information. It *may be empty* if
	// the data was imported manually.
	JobID JobID
	// Cid of payload.
	Cid cid.Cid
	// Created is the timestamp of the data.
	Created time.Time
	// Hot contains hot storage information.
	Hot HotInfo
	// Cold contains cold storage information.
	Cold ColdInfo
}

// HotInfo contains information about the current storage state
// of a Cid in hot storage.
type HotInfo struct {
	Enabled bool
	Size    int
	Ipfs    IpfsHotInfo
}

// IpfsHotInfo contains information about the current storage state
// of a Cid in an IPFS node.
type IpfsHotInfo struct {
	Created time.Time
}

// ColdInfo contains information about the current storage state
// of a Cid in cold storage.
type ColdInfo struct {
	Enabled  bool
	Filecoin FilInfo
}

// FilInfo contains information about the current storage state
// of a Cid in the Filecoin network.
type FilInfo struct {
	// DataCid corresponds to the PayloadCid of the deal.
	DataCid cid.Cid
	// Size is the size of the Piece. Recall that this size
	// is which is accounted for payment, and is usually
	// greater than real data size since data is padded in
	// Filecoin.
	Size uint64
	// Proposals contains known deals for the data.
	Proposals []FilStorage
}

// FilStorage contains Deal information of a storage in Filecoin.
// This information is used in FFS may be used by FFS logic to
// provide repair, renwal, or retrieval tasks.
type FilStorage struct {
	// DealID is the deal id in the network.
	DealID uint64
	// PieceCid is the piece Cid.
	PieceCid cid.Cid
	// Renewed indicates if this deal was
	// already renewed, so it can expiry
	// safely if renewals are enabled.
	Renewed bool
	// Duration is the duration of the deal.
	Duration int64
	// StartEpoch is the starting epoch in which
	// the deal is considered active on-chain.
	StartEpoch uint64
	// Miner is the miner address which is storing
	// deals data.
	Miner string
	// EpochPrice is the price of attoFil per GiB
	// per epoch paid in this deal.
	EpochPrice uint64
}

// JobLoggerCtxKey is a type to use in ctx values for CidLogger.
type JobLoggerCtxKey int

const (
	// CtxKeyJid is a context-key to indicate the Job ID for JobLogger.
	CtxKeyJid JobLoggerCtxKey = iota
	// CtxStorageCid is the context-key to indicate the Cid of a
	// StorageJob for JobLogger.
	CtxStorageCid
	// CtxRetrievalID is the context-key to indicate the RetrievalID of
	// a RetrievalJob for JobLogger.
	CtxRetrievalID
	// CtxAPIID is the context-key to indicate which APIID owns the log
	// entry.
	CtxAPIID
)

// JobLogger saves log information about a storage and retrieval tasks.
type JobLogger interface {
	Log(context.Context, string, ...interface{})
	Watch(context.Context, chan<- LogEntry) error
	GetByCid(context.Context, APIID, cid.Cid) ([]LogEntry, error)
}

// LogEntry is a log entry from a Cid execution.
type LogEntry struct {
	APIID     APIID
	Cid       cid.Cid
	Timestamp time.Time
	Jid       JobID
	Msg       string
}

// PaychDir specifies the direction of a payment channel.
type PaychDir int

const (
	// PaychDirUnspecified is an undefined direction.
	PaychDirUnspecified PaychDir = iota
	// PaychDirInbound is an inbound direction.
	PaychDirInbound
	// PaychDirOutbound is an outbound direction.
	PaychDirOutbound
)

// PaychDirStr maps PaychDirs to describing string.
var PaychDirStr = map[PaychDir]string{
	PaychDirUnspecified: "Unspecified",
	PaychDirInbound:     "Inbound",
	PaychDirOutbound:    "Outbound",
}

// PaychInfo holds information about a payment channel.
type PaychInfo struct {
	CtlAddr   string
	Addr      string
	Direction PaychDir
}

'''
'''--- Filecoin/powergate/filchain/filchain.go ---
package filchain

import (
	"context"
	"fmt"

	"github.com/textileio/powergate/v2/lotus"
)

// FilChain is an abstraction of the Filecoin network.
type FilChain struct {
	clientBuilder lotus.ClientBuilder
}

// New creates a new deal module.
func New(clientBuilder lotus.ClientBuilder) *FilChain {
	return &FilChain{
		clientBuilder: clientBuilder,
	}
}

// GetHeight returns the current height of the chain for the targeted Lotus node.
func (lc *FilChain) GetHeight(ctx context.Context) (uint64, error) {
	client, cls, err := lc.clientBuilder(ctx)
	if err != nil {
		return 0, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	h, err := client.ChainHead(ctx)
	if err != nil {
		return 0, fmt.Errorf("get head from lotus node: %s", err)
	}
	return uint64(h.Height()), nil
}

'''
'''--- Filecoin/powergate/gateway/assets.go ---
package gateway

import (
	"time"

	"github.com/jessevdk/go-assets"
)

var _Assets86cd0824fababa1fde259c0e52ec8ca0455e8965 = "{{template \"header\" \"Oops!\"}}\n<div class=\"aligner\">\n    <div class=\"aligner-item\">\n        <i class=\"fas fa-grimace icon-big\"></i>\n    </div>\n    <div class=\"aligner-item\">\n        <p>{{.Code}} Error: {{.Error}}</p>\n    </div>\n</div>\n{{template \"footer\"}}\n"
var _Assets610f90f49cdc96fabb5ee57a1f077cfc00c6295e = "{{template \"header\" \"Miners Index\"}}\n{{template \"menu\" .}}\n<div class=\".aligner-item\">\n    {{template \"table\" .MetaData}}\n</div>\n<div class=\".aligner-item\">\n    {{template \"table\" .ChainData}}\n</div>\n{{template \"footer\"}}"
var _Assets19d4daaf5fda2bea44d5a868092320a88976ec0f = "{{template \"header\" \"Asks Index\"}}\n{{template \"menu\" .}}\n<div class=\".aligner-item\">\n    {{template \"table\" .}}\n</div>\n{{template \"footer\"}}"
var _Assetsff87a1af2b558b9c75d6a7149f7e7b3cc4566919 = "{{template \"header\" \"Reputation\"}}\n{{template \"menu\" .}}\n<div class=\".aligner-item\">\n    {{template \"table\" .}}\n</div>\n{{template \"footer\"}}"
var _Assetsb289e24e7683deca2454781b8d3914d88103d97a = "package gateway\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-contrib/location\"\n\t\"github.com/gin-contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n\tlogger \"github.com/ipfs/go-log/v2\"\n\tassets \"github.com/jessevdk/go-assets\"\n\t\"github.com/rs/cors\"\n\tgincors \"github.com/rs/cors/wrapper/gin\"\n\taskRunner \"github.com/textileio/powergate/v2/index/ask/runner\"\n\tfaultsModule \"github.com/textileio/powergate/v2/index/faults/module\"\n\tminerModule \"github.com/textileio/powergate/v2/index/miner/module\"\n\t\"github.com/textileio/powergate/v2/reputation\"\n)\n\nconst numTopMiners = 100\n\nvar log = logger.Logger(\"gateway\")\n\n// fileSystem extends the binary asset file system with Exists,\n// enabling its use with the static middleware.\ntype fileSystem struct {\n\t*assets.FileSystem\n}\n\n// Exists returns whether or not the path exists in the binary assets.\nfunc (f *fileSystem) Exists(prefix, path string) bool {\n\tpth := strings.TrimPrefix(path, prefix)\n\tif pth == \"/\" {\n\t\treturn false\n\t}\n\t_, ok := f.Files[pth]\n\treturn ok\n}\n\n// Gateway provides HTTP-based access to Textile.\ntype Gateway struct {\n\taddr             string\n\tserver           *http.Server\n\taskIndex         *askRunner.Runner\n\tminerIndex       *minerModule.Index\n\tfaultsIndex      *faultsModule.Index\n\treputationModule *reputation.Module\n}\n\n// NewGateway returns a new gateway.\nfunc NewGateway(\n\taddr string,\n\taskIndex *askRunner.Runner,\n\tminerIndex *minerModule.Index,\n\tfaultsIndex *faultsModule.Index,\n\treputationModule *reputation.Module,\n) *Gateway {\n\treturn &Gateway{\n\t\taddr:             addr,\n\t\taskIndex:         askIndex,\n\t\tminerIndex:       minerIndex,\n\t\tfaultsIndex:      faultsIndex,\n\t\treputationModule: reputationModule,\n\t}\n}\n\n// Start the gateway.\nfunc (g *Gateway) Start(basePath string) {\n\tgin.SetMode(gin.ReleaseMode)\n\trouter := gin.Default()\n\trouter.Use(location.Default())\n\n\t// @todo: Config based headers\n\toptions := cors.Options{}\n\trouter.Use(gincors.New(options))\n\n\ttemp, err := loadTemplate()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trouter.SetHTMLTemplate(temp)\n\n\trouter.Use(static.Serve(\"/wololo\", &fileSystem{Assets}))\n\trg := router.Group(\"/wololo\")\n\trg.GET(\"/asks\", g.asksHandler)\n\trg.GET(\"/miners\", g.minersHandler)\n\trg.GET(\"/faults\", g.faultsHandler)\n\trg.GET(\"/reputation\", g.reputationHandler)\n\n\trg.GET(\"/\", func(c *gin.Context) {\n\t\tc.Request.URL.Path = basePath + \"/asks\"\n\t\trouter.HandleContext(c)\n\t})\n\n\trouter.NoRoute(func(c *gin.Context) {\n\t\tg.render404(c)\n\t})\n\n\tg.server = &http.Server{\n\t\tAddr:    g.addr,\n\t\tHandler: router,\n\t}\n\n\terrc := make(chan error)\n\tgo func() {\n\t\terrc <- g.server.ListenAndServe()\n\t\tclose(errc)\n\t}()\n\tgo func() {\n\t\tfor err := range errc {\n\t\t\tif err != nil {\n\t\t\t\tif err != http.ErrServerClosed {\n\t\t\t\t\tlog.Errorf(\"gateway error: %s\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tlog.Info(\"gateway was shutdown\")\n\t}()\n\tlog.Infof(\"gateway listening at %s\", g.server.Addr)\n}\n\n// Addr returns the gateway's address.\nfunc (g *Gateway) Addr() string {\n\treturn g.server.Addr\n}\n\n// Stop the gateway.\nfunc (g *Gateway) Stop() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tif err := g.server.Shutdown(ctx); err != nil {\n\t\tlog.Errorf(\"error shutting down gateway: %s\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (g *Gateway) asksHandler(c *gin.Context) {\n\tmenuItems := makeMenuItems(0)\n\n\tindex := g.askIndex.Get()\n\n\tsubtitle := fmt.Sprintf(\"Last updated: %v, storage median price: %v\", timeToString(index.LastUpdated), index.StorageMedianPrice)\n\n\theaders := []string{\"Miner\", \"Price\", \"Min Piece Size\", \"Timestamp\", \"Expiry\"}\n\n\trows := make([][]interface{}, len(index.Storage))\n\ti := 0\n\tfor _, ask := range index.Storage {\n\t\trows[i] = []interface{}{\n\t\t\task.Miner,\n\t\t\task.Price,\n\t\t\task.MinPieceSize,\n\t\t\task.Timestamp,\n\t\t\task.Expiry,\n\t\t}\n\t\ti++\n\t}\n\n\tc.HTML(http.StatusOK, \"/public/html/asks.gohtml\", gin.H{\n\t\t\"MenuItems\": menuItems,\n\t\t\"Title\":     \"Available Asks\",\n\t\t\"Subtitle\":  subtitle,\n\t\t\"Headers\":   headers,\n\t\t\"Rows\":      rows,\n\t})\n}\n\nfunc (g *Gateway) minersHandler(c *gin.Context) {\n\tmenuItems := makeMenuItems(1)\n\n\tindex := g.minerIndex.Get()\n\n\tmetaSubtitle := fmt.Sprintf(\"%v miners online, %v miners offline\", index.Meta.Online, index.Meta.Offline)\n\tmetaHeaders := []string{\"Miner\", \"Location\", \"Online\", \"User Agent\", \"Updated\"}\n\tmetaRows := make([][]interface{}, len(index.Meta.Info))\n\ti := 0\n\tfor id, meta := range index.Meta.Info {\n\t\tmetaRows[i] = []interface{}{\n\t\t\tid,\n\t\t\tmeta.Location.Country,\n\t\t\tmeta.Online,\n\t\t\tmeta.UserAgent,\n\t\t\ttimeToString(meta.LastUpdated),\n\t\t}\n\t\ti++\n\t}\n\n\tchainSubtitle := fmt.Sprintf(\"Last updated %v\", timeToString(uint64ToTime(index.OnChain.LastUpdated)))\n\tchainHeaders := []string{\"Miner\", \"Power\", \"RelativePower\", \"SectorSize\", \"ActiveDeals\"}\n\tvar chainRows [][]interface{}\n\ti = 0\n\tfor id, onchainData := range index.OnChain.Miners {\n\t\tif onchainData.Power == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tchainRows = append(chainRows, []interface{}{\n\t\t\tid,\n\t\t\tonchainData.Power,\n\t\t\tonchainData.RelativePower,\n\t\t\tonchainData.SectorSize,\n\t\t\tonchainData.ActiveDeals,\n\t\t})\n\t\ti++\n\t}\n\n\tsort.Slice(chainRows, func(i, j int) bool {\n\t\tl := chainRows[i][0].(string)\n\t\tr := chainRows[j][0].(string)\n\t\treturn index.OnChain.Miners[l].ActiveDeals >= index.OnChain.Miners[r].ActiveDeals\n\t})\n\n\tc.HTML(http.StatusOK, \"/public/html/miners.gohtml\", gin.H{\n\t\t\"MenuItems\": menuItems,\n\t\t\"MetaData\": gin.H{\n\t\t\t\"Title\":    \"Miner Metadata\",\n\t\t\t\"Subtitle\": metaSubtitle,\n\t\t\t\"Headers\":  metaHeaders,\n\t\t\t\"Rows\":     metaRows,\n\t\t},\n\t\t\"ChainData\": gin.H{\n\t\t\t\"Title\":    \"Miner On-Chain Data\",\n\t\t\t\"Subtitle\": chainSubtitle,\n\t\t\t\"Headers\":  chainHeaders,\n\t\t\t\"Rows\":     chainRows,\n\t\t},\n\t})\n}\n\nfunc (g *Gateway) faultsHandler(c *gin.Context) {\n\tmenuItems := makeMenuItems(2)\n\n\tindex := g.faultsIndex.Get()\n\n\tsubtitle := fmt.Sprintf(\"Current tip set key: %v\", index.TipSetKey)\n\n\theaders := []string{\"Miner\", \"Faults Epochs\"}\n\n\trows := make([][]interface{}, len(index.Miners))\n\ti := 0\n\tfor id, faults := range index.Miners {\n\t\tepochs := make([]string, len(faults.Epochs))\n\t\tfor j, epoch := range faults.Epochs {\n\t\t\tepochs[j] = strconv.FormatInt(epoch, 10)\n\t\t}\n\t\trows[i] = []interface{}{\n\t\t\tid,\n\t\t\tstrings.Join(epochs, \", \"),\n\t\t}\n\t\ti++\n\t}\n\n\tsort.Slice(rows, func(i, j int) bool {\n\t\tl := rows[i][0].(string)\n\t\tr := rows[j][0].(string)\n\t\treturn len(index.Miners[l].Epochs) >= len(index.Miners[r].Epochs)\n\t})\n\n\tc.HTML(http.StatusOK, \"/public/html/faults.gohtml\", gin.H{\n\t\t\"MenuItems\": menuItems,\n\t\t\"Title\":     \"Miner Faults\",\n\t\t\"Subtitle\":  subtitle,\n\t\t\"Headers\":   headers,\n\t\t\"Rows\":      rows,\n\t})\n}\n\nfunc (g *Gateway) reputationHandler(c *gin.Context) {\n\tmenuItems := makeMenuItems(3)\n\n\ttopMiners, err := g.reputationModule.GetTopMiners(numTopMiners)\n\tif err != nil {\n\t\tg.renderError(c, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\n\theaders := []string{\"Miner\", \"Score\"}\n\n\trows := make([][]interface{}, len(topMiners))\n\tfor i, minerScore := range topMiners {\n\t\trows[i] = []interface{}{\n\t\t\tminerScore.Addr,\n\t\t\tminerScore.Score,\n\t\t}\n\t}\n\n\tc.HTML(http.StatusOK, \"/public/html/reputation.gohtml\", gin.H{\n\t\t\"MenuItems\": menuItems,\n\t\t\"Title\":     fmt.Sprintf(\"Top %v Miners\", numTopMiners),\n\t\t\"Headers\":   headers,\n\t\t\"Rows\":      rows,\n\t})\n}\n\nfunc uint64ToTime(value int64) time.Time {\n\treturn time.Unix(value, 0)\n}\n\nfunc timeToString(t time.Time) string {\n\treturn t.Format(\"01/02/06 3:04 PM\")\n}\n\ntype menuItem struct {\n\tName     string\n\tPath     string\n\tSelected bool\n}\n\nfunc makeMenuItems(selectedIndex int) []menuItem {\n\tmenuItems := []menuItem{\n\t\t{\n\t\t\tName:     \"Asks\",\n\t\t\tPath:     \"asks\",\n\t\t\tSelected: false,\n\t\t},\n\t\t{\n\t\t\tName:     \"Miners\",\n\t\t\tPath:     \"miners\",\n\t\t\tSelected: false,\n\t\t},\n\t\t{\n\t\t\tName:     \"Faults\",\n\t\t\tPath:     \"faults\",\n\t\t\tSelected: false,\n\t\t},\n\t\t{\n\t\t\tName:     \"Reputation\",\n\t\t\tPath:     \"reputation\",\n\t\t\tSelected: false,\n\t\t},\n\t}\n\tmenuItems[selectedIndex].Selected = true\n\treturn menuItems\n}\n\n// render404 renders the 404 template.\nfunc (g *Gateway) render404(c *gin.Context) {\n\tc.HTML(http.StatusNotFound, \"/public/html/404.gohtml\", nil)\n}\n\n// renderError renders the error template.\nfunc (g *Gateway) renderError(c *gin.Context, code int, err error) {\n\tc.HTML(code, \"/public/html/error.gohtml\", gin.H{\n\t\t\"Code\":  code,\n\t\t\"Error\": formatError(err),\n\t})\n}\n\n// loadTemplate loads HTML templates.\nfunc loadTemplate() (*template.Template, error) {\n\tt := template.New(\"\")\n\tfor name, file := range Assets.Files {\n\t\tif file.IsDir() || !strings.HasSuffix(name, \".gohtml\") {\n\t\t\tcontinue\n\t\t}\n\t\th, err := ioutil.ReadAll(file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tt, err = t.New(name).Parse(string(h))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t, nil\n}\n\n// formatError formats a go error for browser display.\nfunc formatError(err error) string {\n\twords := strings.SplitN(err.Error(), \" \", 2)\n\twords[0] = strings.Title(words[0])\n\treturn strings.Join(words, \" \") + \".\"\n}\n"
var _Assets5e70439c4378bfd4d8fad0377484821d8d3176bb = "ASSET_DIRS = $(shell find ./public/ -type d)\nASSET_FILES = $(shell find ./public/ -type f -name '*')\n\nassets.go: ./public/ $(ASSET_DIRS) $(ASSET_FILES)\n\tgo-assets-builder . -p gateway -o assets.go"
var _Assetsdde0973434b88ffc53b81b28400233e4fde8bb40 = "html {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n}\n\n*, *:before, *:after {\n    box-sizing: inherit;\n}\n\nbody {\n    margin: 0;\n    padding: 2em;\n    font-family: monospace, sans-serif;\n    color: #666666;\n    background-color: #222222;\n    height: 100%;\n}\n\n.logo {\n    position: absolute;\n}\n\n.title {\n    margin-bottom: 0.5em;\n    color: white;\n    font-weight: bold;\n}\n\n.subtitle {\n    font-size: 0.8em;\n    margin-bottom: 0.5em;\n}\n\n.navbar {\n    list-style: none;\n    text-align: center;\n    margin-bottom: 2em;\n    margin-top: 2em;\n    font-size: 0.8em;\n    text-transform: uppercase;\n}\n\n.navbar li {\n    display: inline;\n}\n\n.navbar a{\n    display: inline-block;\n    padding: 10px;\n}\n\n.navbar a.selected {\n    color: white;\n    font-weight: bold;\n}\n\na {\n    text-decoration: none;\n    color: #666666;\n}\n\na:hover {\n    text-decoration: underline;\n}\n\ntable {\n    border-collapse: collapse;\n    width: 100%;\n    margin-bottom: 1em;\n}\n\ntd, th {\n    border: 1px solid #666666;\n    padding: 8px;\n}\n\ntr:nth-child(odd){background-color: #252525;}\n\ntr:hover {background-color: rgb(49, 49, 49);}\n\nth {\n    padding-top: 12px;\n    padding-bottom: 12px;\n    text-align: left;\n    background-color: rgb(15, 15, 15);\n    color: white;\n    font-size: 0.8em;\n    text-transform: uppercase;\n}\n\n.aligner {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-direction: column;\n    height: 100%;\n}\n\n.aligner-item {\n    max-width: 60%;\n}\n\n.aligner-item p {\n    text-align: center;\n    line-height: 1.5em;\n}\n\n.icon-big {\n    font-size: 4em;\n}\n"
var _Assets747353a94cf1b19b7a2e5c9fbc50b3ea0972f088 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"1200px\" height=\"1400px\" viewBox=\"0 0 1200 1400\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch -->\n    <title>Artboard</title>\n    <desc>Created with Sketch.</desc>\n    <defs>\n        <polygon id=\"path-1\" points=\"650 0 1212.91651 325 1212.91651 975 650 1300 87.0834875 975 87.0834875 325\"></polygon>\n    </defs>\n    <g id=\"Artboard\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Group\" transform=\"translate(-100.000000, 0.000000)\">\n            <polygon id=\"Polygon\" fill=\"#FFCE00\" points=\"700 0 1306.21778 350 1306.21778 1050 700 1400 93.7822174 1050 93.7822174 350\"></polygon>\n            <g id=\"Textile_Icon_A_1200px-copy\" transform=\"translate(50.000000, 50.000000)\">\n                <mask id=\"mask-2\" fill=\"white\">\n                    <use xlink:href=\"#path-1\"></use>\n                </mask>\n                <use id=\"Mask\" fill=\"#FFB6D5\" xlink:href=\"#path-1\"></use>\n                <image mask=\"url(#mask-2)\" x=\"25\" y=\"25\" width=\"1250\" height=\"1250\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAASwCAYAAADrIbPPAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N1frK35edD3tWfGIdiezIzrkD92Ytdx4hInxcUE8schuUhCuUAqFCMBohcV0FbqBWq5rHrVXlaVWlypLW0vKiCxetM/Kokd6mlIADWE2K2iJKoU2ZEAVUXYE8PMeDznLPY+57znnH32Xnu971rv7/09z/P7cLP23utd7/v8Ps8qjb6cUXY7/4cAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBARIEPvHv/e7/zpf0rEWczEwECBAgQIECAAIFJ4LnpB68ECBAgQIDAWAJX8Wq/331u9/bu50WssXbvtAQIECBAgACBbAIX2QY2LwECBAgQIHC+wBSvLgPWt1zd7eJi9w92L+x+4rdfu/jy+Xd3BwIECBAgQIAAAQLrCghY63q6GwECBAgQCC/wbLyaBhaxJgmvBAgQIECAAAEC0QQErGgbMQ8BAgQIEGgocCheTY8UsSYJrwQIECBAgAABApEEBKxI2zALAQIECBBoKHAsXk2PFrEmCa8ECBAgQIAAAQJRBASsKJswBwECBAgQaCgwN15NI4hYk4RXAgQIECBAgACBCAICVoQtmIEAAQIECDQUWBqvplFErEnCKwECBAgQIECAQG8BAav3BjyfAAECBAg0FDg1Xk0jiViThFcCBAgQIECAAIGeAgJWT33PJkCAAAECDQXOjVfTaCLWJOGVAAECBAgQIECgl4CA1UvecwkQIECAQEOBteLVNKKINUl4JUCAAAECBAgQ6CEgYPVQ90wCBAgQINBQYO14NY0qYk0SXgkQIECAAAECBLYWELC2Fvc8AgQIECDQUKBVvJpGFrEmCa8ECBAgQIAAAQJbCghYW2p7FgECBAgQaCjQOl5No4tYk4RXAgQIECBAgACBrQQErK2kPYcAAQIECDQU2CpeTUcQsSYJrwQIECBAgAABAlsICFhbKHsGAQIECBBoKLB1vJqOImJNEl4JECBAgAABAgRaCwhYrYXdnwABAgQINBToFa+mI4lYk4RXAgQIECBAgACBlgICVktd9yZAgAABAg0Feser6Wgi1iThlQABAgQIECBAoJWAgNVK1n0JECBAgEBDgSjxajqiiDVJeCVAgAABAgQIEGghIGC1UHVPAgQIECDQUCBavJqOevk/VPzK7h27n/zt1y6+PP3NKwECBAgQIECAAIE1BASsNRTdgwABAgQIbCQQNV5NxxexJgmvBAgQIECAAAECawoIWGtquhcBAgQIEGgoED1eTUcXsSYJrwQIECBAgAABAmsJCFhrSboPAQIECBBoKJAlXk0EItYk4ZUAAQIECBAgQGANAQFrDUX3IECAAAECDQWyxauJQsSaJLwSIECAAAECBAicKyBgnSvo8wQIECBAoKFA1ng1kYhYk4RXAgQIECBAgACBcwQErHP0fJYAAQIECDQUyB6vJhoRa5LwSoAAAQIECBAgcKqAgHWqnM8RIECAAIGGAlXi1UQkYk0SXgkQIECAAAECBE4RELBOUfMZAgQIECDQUKBavJqoRKxJwisBAgQIECBAgMBSAQFrqZjrCRAgQIBAQ4Gq8WoiE7EmCa8ECBAgQIAAAQJLBASsJVquJUCAAAECDQWqx6uJTsSaJLwSIECAAAECBAjMFRCw5kq5jgABAgQINBQYJV5NhCLWJOGVAAECBAgQIEBgjoCANUfJNQQIECBAoKHAaPFqohSxJgmvBAgQIECAAAECxwQErGNC3idAgAABAg0FRo1XE6mINUl4JUCAAAECBAgQuEtAwLpLx3sECBAgQKChwOjxaqIVsSYJrwQIECBAgAABAocEBKxDMv5OgAABAgQaCohX13FFrOsefiNAgAABAgQIELguIGBd9/AbAQIECBBoLiBe3U4sYt3u4q8ECBAgQIAAAQK73XMQCBAgQIAAge0EHsWr/2O/333Ldk/N8aT9bvfx3dd3n/3Ol/av5JjYlAQIECBAgAABAlsJ+BdYW0l7DgECBAgML/BUvPrW4THuAPAvse7A8RYBAgQIECBAYFABAWvQxTs2AQIECGwrIF4t8xaxlnm5mgABAgQIECBQXcB/Qlh9w85HgAABAt0FPvji/l+5/E8Gr/6zQf/yauY2/OeEM6FcRoAAAQIECBAYRMC/wBpk0Y5JgAABAn0EruLV/fu7z4lXp/n7l1inufkUAQIECBAgQKCagIBVbaPOQ4AAAQJhBMSrdVYhYq3j6C4ECBAgQIAAgcwCAlbm7ZmdAAECBMIKiFfrrkbEWtfT3QgQIECAAAEC2QQErGwbMy8BAgQIhBcQr9qsSMRq4+quBAgQIECAAIEMAgJWhi2ZkQABAgTSCIhXbVclYrX1dXcCBAgQIECAQFQBASvqZsxFgAABAukExKttViZibePsKQQIECBAgACBSAICVqRtmIUAAQIE0gqIV9uuTsTa1tvTCBAgQIAAAQK9BQSs3hvwfAIECBBILyBe9VmhiNXH3VMJECBAgAABAj0EBKwe6p5JgAABAmUExKu+qxSx+vp7OgECBAgQIEBgK4HntnqQ5xAgQIAAgWoC4lX/je53u4/vvr777Adf3r/cfxoTECBAgAABAgQItBLwL7BaybovAQIECJQWEK9irffqX2I99w27n/jiVy6+Emsy0xAgQIAAAQIECKwhIGCtoegeBAgQIDCUgHgVc90iVsy9mIoAAQIECBAgsIaAgLWGonsQIECAwDAC4lXsVYtYsfdjOgIECBAgQIDAqQIC1qlyPkeAAAECwwmIVzlWLmLl2JMpCRAgQIAAAQJLBASsJVquJUCAAIFhBcSrXKsXsXLty7QECBAgQIAAgWMCAtYxIe8TIECAwPAC4lXOr4CIlXNvpiZAgAABAgQI3CYgYN2m4m8ECBAgQOCRgHiV+6sgYuXen+kJECBAgAABApOAgDVJeCVAgAABAs8IiFfPgCT9VcRKujhjEyBAgAABAgSeEhCwnsLwIwECBAgQmATEq0mixquIVWOPTkGAAAECBAiMKyBgjbt7JydAgACBAwLi1QGY5H8WsZIv0PgECBAgQIDA0AIC1tDrd3gCBAgQeFZAvHpWpNbvIlatfToNAQIECBAgMI6AgDXOrp2UAAECBI4IiFdHgIq8LWIVWaRjECBAgAABAkMJCFhDrdthCRAgQOCQgHh1SKbm30Wsmnt1KgIECBAgQKCugIBVd7dORoAAAQIzBcSrmVDFLhOxii3UcQgQIECAAIHSAgJW6fU6HAECBAgcExCvjgnVfl/Eqr1fpyNAgAABAgTqCAhYdXbpJAQIECCwUEC8WghW9HIRq+hiHYsAAQIECBAoJSBglVqnwxAgQIDAXAHxaq7UGNeJWGPs2SkJECBAgACBvAICVt7dmZwAAQIEThQQr06EK/4xEav4gh2PAAECBAgQSC3wXOrpDU+AAAECBBYKiFcLwQa6fL/bffz+W7vPfvDl/csDHdtRCRAgQIAAAQIpBPwLrBRrMiQBAgQIrCEgXq2hWP8el//D0d9/7ht2P/nFr1x8pf5pnZAAAQIECBAgkENAwMqxJ1MSIECAwJkC4tWZgIN9XMQabOGOS4AAAQIECIQXELDCr8iABAgQIHCugHh1ruCYnxexxty7UxMgQIAAAQIxBQSsmHsxFQECBAisJCBerQQ56G1ErEEX79gECBAgQIBAOAEBK9xKDESAAAECawmIV2tJjn0fEWvs/Ts9AQIECBAgEENAwIqxB1MQIECAwMoC4tXKoIPfTsQa/Avg+AQIECBAgEB3AQGr+woMQIAAAQJrC4hXa4u635WAiOV7QIAAAQIECBDoJyBg9bP3ZAIECBBoICBeNUB1y8cCItZjCj8QIECAAAECBDYVELA25fYwAgQIEGgpIF611HXvSUDEmiS8EiBAgAABAgS2ExCwtrP2JAIECBBoKCBeNcR16xsCItYNEn8gQIAAAQIECDQVELCa8ro5AQIECGwhIF5toewZzwqIWM+K+J0AAQIECBAg0E5AwGpn684ECBAgsIGAeLUBskccFBCxDtJ4gwABAgQIECCwqoCAtSqnmxEgQIDAlgLi1ZbannVIQMQ6JOPvBAgQIECAAIH1BASs9SzdiQABAgQ2FBCvNsT2qKMCItZRIhcQIECAAAECBM4SELDO4vNhAgQIEOghIF71UPfMYwIi1jEh7xMgQIAAAQIEThcQsE6380kCBAgQ6CAgXnVA98jZAiLWbCoXEiBAgAABAgQWCQhYi7hcTIAAAQI9BcSrnvqePVdAxJor5ToCBAgQIECAwHwBAWu+lSsJECBAoKOAeNUR36MXC4hYi8l8gAABAgQIECBwp4CAdSePNwkQIEAggoB4FWELZlgqIGItFXM9AQIECBAgQOCwgIB12MY7BAgQIBBAQLwKsAQjnCwgYp1M54MECBAgQIAAgWsCAtY1Dr8QIECAQCQB8SrSNsxyqoCIdaqczxEgQIAAAQIEnggIWE8s/ESAAAECgQTEq0DLMMrZAiLW2YRuQIAAAQIECAwuIGAN/gVwfAIECEQUEK8ibsVM5wqIWOcK+jwBAgQIECAwsoCANfL2nZ0AAQIBBcSrgEsx0moCItZqlG5EgAABAgQIDCYgYA22cMclQIBAZAHxKvJ2zLaWgIi1lqT7ECBAgAABAiMJCFgjbdtZCRAgEFhAvAq8HKOtLiBirU7qhgQIECBAgEBxAQGr+IIdjwABAhkExKsMWzLj2gIi1tqi7keAAAECBAhUFhCwKm/X2QgQIJBAQLxKsCQjNhMQsZrRujEBAgQIECBQTEDAKrZQxyFAgEAmgX/5xf1H7t3fvbrf774109xmJbCmgIi1pqZ7ESBAgAABAlUFBKyqm3UuAgQIBBcQr4IvyHibCohYm3J7GAECBAgQIJBQQMBKuDQjEyBAILuAeJV9g+ZvISBitVB1TwIECBAgQKCKgIBVZZPOQYAAgSQC4lWSRRmzi4CI1YXdQwkQIECAAIEEAgJWgiUZkQABAlUExKsqm3SOlgIiVktd9yZAgAABAgSyCghYWTdnbgIECCQTEK+SLcy4XQVErK78Hk6AAAECBAgEFBCwAi7FSAQIEKgmIF5V26jzbCEgYm2h7BkECBAgQIBAFgEBK8umzEmAAIGkAuJV0sUZO4SAiBViDYYgQIAAAQIEAggIWAGWYAQCBAhUFRCvqm7WubYUELG21PYsAgQIECBAIKqAgBV1M+YiQIBAcgHxKvkCjR9KQMQKtQ7DECBAgAABAh0EnuvwTI8kQIAAgeICj+LV5/b73bcWP6rjEdhEYL/b/YH7b+0++8GX9y9v8kAPIUCAAAECBAgEE/AvsIItxDgECBDILvBUvPq27GcxP4FoAv4lVrSNmIcAAQIECBDYSkDA2kracwgQIDCAgHg1wJIdsbuAiNV9BQYgQIAAAQIEOggIWB3QPZIAAQIVBcSrilt1pqgCIlbUzZiLAAECBAgQaCUgYLWSdV8CBAgMJCBeDbRsRw0jIGKFWYVBCBAgQIAAgQ0EBKwNkD2CAAEClQXEq8rbdbboAiJW9A2ZjwABAgQIEFhLQMBaS9J9CBAgMKCAeDXg0h05nICIFW4lBiJAgAABAgQaCAhYDVDdkgABAiMIiFcjbNkZswiIWFk2ZU4CBAgQIEDgVAEB61Q5nyNAgMDAAuLVwMt39LACIlbY1RiMAAECBAgQWEFAwFoB0S0IECAwkoB4NdK2nTWbgIiVbWPmJUCAAAECBOYKCFhzpVxHgAABAjvxypeAQAqBX37+G3Y/9cWvXHwlxbSGJECAAAECBAjMEBCwZiC5hAABAgR24pUvAYFcAiJWrn2ZlgABAgQIEDgiIGAdAfI2AQIECIhXvgMEkgqIWEkXZ2wCBAgQIEDgpoCAddPEXwgQIEDgKQH/2eBTGH4kkE9AxMq3MxMTIECAAAECtwgIWLeg+BMBAgQIPBQQr3wTCJQQELFKrNEhCBAgQIDA2AIC1tj7d3oCBAgcFBCvDtJ4g0BGAREr49bMTIAAAQIECDwWELAeU/iBAAECBCYB8WqS8EqglICIVWqdDkOAAAECBMYSELDG2rfTEiBA4KiAeHWUyAUEMguIWJm3Z3YCBAgQIDCwgIA18PIdnQABAs8KiFfPividQEkBEavkWh2KAAECBAjUFhCwau/X6QgQIDBbQLyaTeVCAhUERKwKW3QGAgQIECAwkICANdCyHZUAAQKHBMSrQzL+TqC0gIhVer0OR4AAAQIEagkIWLX26TQECBBYLCBeLSbzAQKVBESsStt0FgIECBAgUFhAwCq8XEcjQIDAMQHx6piQ9wkMISBiDbFmhyRAgAABArkFBKzc+zM9AQIEThYQr06m80ECFQVErIpbdSYCBAgQIFBIQMAqtExHIUCAwFwB8WqulOsIDCUgYg21boclQIAAAQK5BASsXPsyLQECBM4WEK/OJnQDApUFRKzK23U2AgQIECCQWEDASrw8oxMgQGCpgHi1VMz1BIYUELGGXLtDEyBAgACB2AICVuz9mI4AAQKrCYhXq1G6EYERBESsEbbsjAQIECBAIJGAgJVoWUYlQIDAqQLi1alyPkdgaAERa+j1OzwBAgQIEIglIGDF2odpCBAgsLqAeLU6qRsSGElAxBpp285KgAABAgQCCwhYgZdjNAIECJwrIF6dK+jzBAhcCohYvgYECBAgQIBAdwEBq/sKDECAAIE2AuJVG1d3JTCogIg16OIdmwABAgQIRBEQsKJswhwECBBYUUC8WhHTrQgQmARErEnCKwECBAgQILC5wHObP9EDCRAgQKCpgHjVlNfNCYws8AP33tp95kOv7F8aGcHZCRAgQIAAgT4C/gVWH3dPJUCAQBMB8aoJq5sSIHBd4Jff8bt2P/lbX7547fqf/UaAAAECBAgQaCcgYLWzdWcCBAhsKiBebcrtYQRGFxCxRv8GOD8BAgQIENhYQMDaGNzjCBAg0EJAvGqh6p4ECBwRELGOAHmbAAECBAgQWE9AwFrP0p0IECDQRUC86sLuoQQIPBQQsXwTCBAgQIAAgU0EBKxNmD2EAAECbQTEqzau7kqAwCIBEWsRl4sJECBAgACBUwQErFPUfIYAAQIBBMSrAEswAgECk4CINUl4JUCAAAECBJoICFhNWN2UAAECbQXEq7a+7k6AwEkCItZJbD5EgAABAgQIzBEQsOYouYYAAQKBBMSrQMswCgECzwqIWM+K+J0AAQIECBBYRUDAWoXRTQgQILCNgHi1jbOnECBwloCIdRafDxMgQIAAAQK3CQhYt6n4GwECBAIKiFcBl2IkAgQOCYhYh2T8nQABAgQIEDhJQMA6ic2HCBAgsK2AeLWtt6cRILCKgIi1CqObECBAgAABAlcCApbvAQECBIILiFfBF2Q8AgTuEhCx7tLxHgECBAgQIDBbQMCaTeVCAgQIbC8gXm1v7okECKwuIGKtTuqGBAgQIEBgPAEBa7ydOzEBAkkExKskizImAQJzBESsOUquIUCAAAECBA4KCFgHabxBgACBfgLiVT97TyZAoJmAiNWM1o0JECBAgEB9AQGr/o6dkACBZAIfenH/PW/f37263+++LdnoxiVAgMAxARHrmJD3CRAgQIAAgVsFBKxbWfyRAAECfQTEqz7unkqAwKYCItam3B5GgAABAgRqCAhYNfboFAQIFBAQrwos0REIEJgrIGLNlXIdAQIECBAg8EBAwPJFIECAQAAB8SrAEoxAgMDWAiLW1uKeR4AAAQIEEgsIWImXZ3QCBGoIiFc19ugUBAicJCBincTmQwQIECBAYDwBAWu8nTsxAQKBBMSrQMswCgECvQRErF7ynkuAAAECBBIJCFiJlmVUAgRqCYhXtfbpNAQInCUgYp3F58MECBAgQKC+gIBVf8dOSIBAQAHxKuBSjESAQG8BEav3BjyfAAECBAgEFhCwAi/HaAQI1BQQr2ru1akIEFhFQMRahdFNCBAgQIBAPQEBq95OnYgAgcAC4lXg5RiNAIEoAiJWlE2YgwABAgQIBBJ4LtAsRiFAgEBpAfGq9HodjgCB9QR+4Otf233mQ6/sX1rvlu5EgAABAgQIZBfwL7Cyb9D8BAikEBCvUqzJkAQIxBL4v97xu3Y/9Vtfvngt1limIUCAAAECBHoICFg91D2TAIGhBMSrodbtsAQIrCsgYq3r6W4ECBAgQCCtgICVdnUGJ0Agg4B4lWFLZiRAILiAiBV8QcYjQIAAAQJbCAhYWyh7BgECQwqIV0Ou3aEJEGgjIGK1cXVXAgQIECCQRkDASrMqgxIgkElg/9N//7v+h7/1e/7Lf/xP3/HuTHObdTyBN+/9069+4/PveXG8kztxNoGPX/zm//tH/qf/6C9f7H7xy9lmNy8BAgQIECBwvoCAdb6hOxAgQOCawFW82r+9f3W/273/2ht+IRBM4OKF13714tv//ffc/+3/8QPBRjMOgRsCF7/6f3/h3n/2qXsv7N75EyLWDR5/IECAAAEC5QWeK39CByRAgMCGAuLVhtgedZbAg3j1HZ/8yO7ijW8860Y+TGBTgf3vf3v3+s/vd594ZdPHehgBAgQIECDQXUDA6r4CAxAgUEVAvKqyyfrnuHjutc9fXMar/e7Nd9Y/rRPWExCx6u3UiQgQIECAwHEBAeu4kSsIECBwVEC8OkrkgiACD+LVBz75PeJVkIUY40QBEetEOB8jQIAAAQJpBQSstKszOAECUQTEqyibMMcxAfHqmJD3cwmIWLn2ZVoCBAgQIHCegIB1np9PEyAwuIB4NfgXINHxxatEyzLqAgERawGWSwkQIECAQGoBASv1+gxPgEBPAfGqp75nLxEQr5ZouTafgIiVb2cmJkCAAAECywUErOVmPkGAAIGdeOVLkEVAvMqyKXOeJyBinefn0wQIECBAIL6AgBV/RyYkQCCYwP7Tv/Lh/dv7V/e73fuDjWYcAtcExKtrHH4pLyBilV+xAxIgQIDA0AIC1tDrd3gCBJYKPIhXb93/nHi1VM71WwuIV1uLe14MARErxh5MQYAAAQIE1hcQsNY3dUcCBIoKiFdFF1vwWOJVwaU60gIBEWsBlksJECBAgEAaAQErzaoMSoBATwHxqqe+Zy8REK+WaLm2roCIVXe3TkaAAAECowoIWKNu3rkJEJgtIF7NpnJhZwHxqvMCPD6YwIOI9dn97hOvBBvMOAQIECBAgMAJAgLWCWg+QoDAOALi1Ti7zn5S8Sr7Bs3fRmD/8bd3r4tYbXDdlQABAgQIbCogYG3K7WEECGQSEK8ybWvsWcWrsffv9McERKxjQt4nQIAAAQIZBASsDFsyIwECmwuIV5uTe+CJAuLViXA+NpiAiDXYwh2XAAECBAoKCFgFl+pIBAicJyBenefn09sJiFfbWXtSBQERq8IWnYEAAQIExhUQsMbdvZMTIHCLgHh1C4o/hRQQr0KuxVDhBUSs8CsyIAECBAgQOCAgYB2A8WcCBMYTeBiv9q/ud7v3j3d6J84kIF5l2pZZ4wmIWPF2YiICBAgQIHBcQMA6buQKAgQGEHgSr/bvG+C4jphYQLxKvDyjBxIQsQItwygECBAgQGCWgIA1i8lFBAhUFhCvKm+31tnEq1r7dJreAiJW7w14PgECBAgQWCIgYC3Rci0BAuUExKtyKy17IPGq7GodrKuAiNWV38MJECBAgMACAQFrAZZLCRCoJSBe1dpn5dOIV5W362z9BUSs/jswAQECBAgQOC4gYB03cgUBAgUFxKuCSy16JPGq6GIdK5iAiBVsIcYhQIAAAQI3BASsGyT+QIBAdQHxqvqG65xPvKqzSyfJICBiZdiSGQkQIEBgXAEBa9zdOzmBIQXEqyHXnvLQ4lXKtRk6vYCIlX6FDkCAAAECZQUErLKrdTACBJ4VEK+eFfF7VAHxKupmzDWGgIg1xp6dkgABAgSyCQhY2TZmXgIEThIQr05i86EOAuJVB3SPJHBDQMS6QeIPBAgQIECgs4CA1XkBHk+AQHsB8aq9sSesIyBerePoLgTWERCx1nF0FwIECBAgsI6AgLWOo7sQIBBUQLwKuhhj3RAQr26Q+AOBAAIiVoAlGIEAAQIECDwQELB8EQgQKCsgXpVdbbmDiVflVupApQRErFLrdBgCBAgQSCsgYKVdncEJELhLQLy6S8d7kQTEq0jbMAuBQwIi1iEZfydAgAABAlsJCFhbSXsOAQKbCYhXm1F70JkC4tWZgD5OYFMBEWtTbg8jQIAAAQLPCAhYz4D4lQCB3ALiVe79jTS9eDXStp21joCIVWeXTkKAAAEC2QQErGwbMy8BAgcFxKuDNN4IJiBeBVuIcQgsEhCxFnG5mAABAgQIrCQgYK0E6TYECPQVEK/6+nv6fAHxar6VKwnEFRCx4u7GZAQIECBQVUDAqrpZ5yIwkIB4NdCykx9VvEq+QOMTuCYgYl3j8AsBAgQIEGgsIGA1BnZ7AgTaCohXbX3dfT0B8Wo9S3ciEEdAxIqzC5MQIECAQHUBAav6hp2PQGEB8arwcosdTbwqtlDHIXBNQMS6xuEXAgQIECDQSEDAagTrtgQItBUQr9r6uvt6AuLVepbuRCCugIgVdzcmI0CAAIEqAgJWlU06B4GBBMSrgZad/KjiVfIFGp/AIgERaxGXiwkQIECAwEIBAWshmMsJEOgrIF719ff0+QLi1XwrVxKoIzBFrB9/uc6ZnIQAAQIECMQQELBi7MEUBAjMEBCvZiC5JISAeBViDYYg0EngKmL9zs/vdyJWpwV4LAECBAgUFRCwii7WsQhUExCvqm207nnEq7q7dTIC8wVErPlWriRAgAABAvMEBKx5Tq4iQKCjgHjVEd+jFwmIV4u4XEyguICIVXzBjkeAAAECGwsIWBuDexwBAssExKtlXq7uJyBe9bP3ZAJxBUSsuLsxGQECBAhkExCwsm3MvAQGEhCvBlp28qOKV8kXaHwCTQVErKa8bk6AAAECwwgIWMOs2kEJ5BIQr3Lta+RpxauRt+/sBOYKiFhzpVxHgAABAgQOCQhYh2T8nQCBbgLiVTd6D14oIF4tBHM5gaEFRKyh1+/wBAgQIHC2gIB1NqEbECCwpoB4taame7UUuHjhtc9ffOCT37PfvfnOls9xbwIEKgmIWJW26SwECBAgsK2AgLWtt6cRIHCHgHh1B463Qgk8iFffIV6FWophCKQRELHSrMqgBAgQIBBKQMAKtQ7DEBhXQLwad/fZTi5eZduYeQlEFBCxIm7FTAQIECAQW0DAir0f0xEYQkC8GmLNJQ4pXpVYo0MQCCIgYgVZhDEIECBAIImAgJVkUcYkUFVAvKq62XrnEq/q7dSJCPQXELH678AEBAgQIJBFQMDKsilzEigoIF4VXGrRI4lXRRfrWARCCIhYIdZgCAIECBAILyBghV+RAQnUFBCvau614qnEq4pbdSYC0QRErGgbMQ8BAgQIxBMQsOLtxEQEyguIV+VXXOaAD+LV+//Ud+93b76zzKEchACBoAIiVtDFGIsAAQIEgggIWEEWYQwCowiIV6NsOv85H8erizfelf80TkCAQA4BESvHnkxJgAABAj0EBKwe6p5JYFAB8WrQxSc8tniVcGlGJlBGQMQqs0oHIUCAAIFVBQSsVTndjACBQwLi1SEZf48mIF5F24h5CIwoIGKNuHVnJkCAAIG7BQSsu328S4DACgLi1QqIbrGJgHi1CbOHECAwS0DEmsXkIgIECBAYRkDAGmbVDkqgj4B41cfdU5cLiFfLzXyCAIHWAg8i1mf3ux9/ufWT3J8AAQIECEQXELCib8h8BBILiFeJlzfY6OLVYAt3XAKpBPZ/4O3d74hYqXZmWAIECBBoISBgtVB1TwIEduKVL0EWAfEqy6bMSWBkARFr5O07OwECBAg8FBCwfBMIEFhdQLxandQNGwmIV41g3ZYAgQYCIlYDVLckQIAAgUQCAlaiZRmVQAYB8SrDlsx4JSBe+R4QIJBPQMTKtzMTEyBAgMBaAgLWWpLuQ4DAbv/XfvW792/tX93v9u/DQSCygHgVeTtmI0DgbgER624f7xIgQIBAVQEBq+pmnYvAxgIP4tX+3ufEq43hPW6xgHi1mMwHCBAIJyBihVuJgQgQIECguYCA1ZzYAwjUFxCv6u+4ygnFqyqbdA4CBHY7Ecu3gAABAgTGEhCwxtq30xJYXUC8Wp3UDRsJiFeNYN2WAIGOAiJWR3yPJkCAAIGNBQSsjcE9jkAlAfGq0jZrn0W8qr1fpyMwtoCINfb+nZ4AAQLjCAhY4+zaSQmsKiBercrpZg0FxKuGuG5NgEAQAREryCKMQYAAAQINBQSshrhuTaCqgHhVdbP1ziVe1dupExEgcEhAxDok4+8ECBAgUENAwKqxR6cgsJmAeLUZtQedKSBenQno4wQIJBQQsRIuzcgECBAgMFNAwJoJ5TICBC7/9x39tV/97v3+3uf2u/37eBCILCBeRd6O2QgQaCsgYrX1dXcCBAgQ6CUgYPWS91wCyQTEq2QLG3hc8Wrg5Ts6AQKPBEQsXwUCBAgQqCcgYNXbqRMRWF1AvFqd1A0bCYhXjWDdlgCBhAIiVsKlGZkAAQIE7hAQsO7A8RYBAv6zQd+BPALiVZ5dmZQAga0ERKytpD2HAAECBNoLCFjtjT2BQFoB//Iq7eqGG1y8Gm7lDkyAwGwBEWs2lQsJECBAILSAgBV6PYYj0E9AvOpn78nLBMSrZV6uJkBgRAERa8StOzMBAgSqCQhY1TbqPARWEBCvVkB0i00ExKtNmD2EAIESAiJWiTU6BAECBAYWELAGXr6jE7hNQLy6TcXfIgqIVxG3YiYCBGILiFix92M6AgQIELhLQMC6S8d7BAYTEK8GW3ji44pXiZdndAIEOguIWJ0X4PEECBAgcKKAgHUinI8RqCYgXlXbaN3ziFd1d+tkBAhsJSBibSXtOQQIECCwnoCAtZ6lOxFIKyBepV3dcIOLV8Ot3IEJEGgmIGI1o3VjAgQIEGgiIGA1YXVTAnkExKs8uxp9UvFq9G+A8xMgsL6AiLW+qTsSIECAQCsBAauVrPsSSCAgXiVYkhEfCIhXvggECBBoJSBitZJ1XwIECBBYV0DAWtfT3QikERCv0qxq+EHFq+G/AgAIEGguIGI1J/YAAgQIEDhbQMA6m9ANCOQTEK/y7WzUicWrUTfv3AQIbC8gYm1v7okECBAgsERAwFqi5VoCBQQexKvdvVf3u/37ChzHEQoLiFeFl+toBAgEFRCxgi7GWAQIECBwKSBg+RoQGEjgcbza7799oGM7akIB8Srh0oxMgEARARGryCIdgwABAuUEBKxyK3UgArcLiFe3u/hrPAHxKt5OTESAwGgCItZoG3deAgQIZBAQsDJsyYwEzhQQr84E9PHNBMSrzag9iAABAkcERKwjQN4mQIAAgY0FBKyNwT2OwNYC4tXW4p53qoB4daqczxEgQKCVgIjVStZ9CRAgQGC5gIC13MwnCKQREK/SrGr4QcWr4b8CAAgQCCsgYoVdjcEIECAwmICANdjCHXccAfFqnF1nP+nF87/zhYv3/6nv3l+88a7sZzE/AQIEagqIWDX36lQECBDIJSBg5dqXaQnMEhCvZjG5KIDAg3j1HZ/8sHgVYBlGIECAwJ0CItadPN4kQIAAgeYCAlZzYg8gsK2AeLWtt6edLiBenW7nkwQIEOgjIGL1cfdUAgQIELgSELB8DwgUEhCvCi2z+FHEq+ILdjwCBAoLiFiFl+toBAgQCC0gYIVej+EIzBcQr+ZbubKvgHjV19/TCRAgcL6AiHW+oTsQIECAwFIBAWupmOsJBBQQrwIuxUi3CohXt7L4IwECBBIKiFgJl2ZkAgQIpBYQsFKvz/AEdjvxyrcgi4B4lWVT5iRAgMBcARFrrpTrCBAgQOB8AQHrfEN3INBNQLzqRu/BCwXEq4VgLidAgEAaARErzaoMSoAAgeQCAlbyBRp/XAHxatzdZzu5eJVtY+YlQIDAUgERa6mY6wkQIEBguYCAtdzMJwh0FxCvuq/AADMFxKuZUC4jQIBAegERK/0KHYAAAQLBBQSs4AsyHoFnBcSrZ0X8HlVAvIq6GXMRIECglYCI1UrWfQkQIEBgtxOwfAsIJBIQrxIta/BRxavBvwCOT4DAwAIi1sDLd3QCBAg0FRCwmvK6OYH1BMSr9Szdqa2AeNXW190JECAQX0DEir8jExIgQCCfgICVb2cmHlBAvBpw6UmPLF4lXZyxCRAgsLqAiLU6qRsSIEBgcAEBa/AvgOPHFxCv4u/IhA8FxCvfBAIECBC4LiBiXffwGwECBAicIyBgnaPnswQaC4hXjYHdfjUB8Wo1SjciQIBAMYGriPXaZ/a7H3+52MEchwABAgQ2FhCwNgb3OAJzBcSruVKu6y0gXvXegOcTIEAgvMAPiFjhd2RAAgQIhBcQsMKvyIAjCohXI24955nFq5x7MzUBAgQ6CIhYHdA9kgABApUEBKxK23SWEgLiVYk1DnEI8WqINTskAQIE1hQQsdbUdC8CBAgMJiBgDbZwx40tIF7F3o/pngiIV08s/ESAAAECiwRErEVcLiZAgACBSUDAmiS8EugsIF51XoDHzxYQr2ZTuZAAAQIEbhcQsW538VcCBAgQuENAwLoDx1sEthIQr7aS9pxzBcSrcwV9ngABAgQeCYhYvgoECBAgsEhAwFrE5WIC6wuIV+ubumMbAfGqjau7EiBAYGABEWvg5Ts6AQIElgoIWEvFXE9gRQHxakVMt2oqIF415XVzAgQIjCwgYo28fWcnQIDAAgEBawGWSwmsKSBeranpXi0FxKuWuu5NgAABApcCIpavAQECBAgcFRCwjhK5gMD6AuLV+qbu2EZAvGrj6q4ECBAgcENAxLpB4g8ECBAg8LSAgPW0hp8JbCAgXm2A7BGrCIhXqzC6CQECBAjMFxCx5lu5kgABAsMJCFjDrdyBewqIVz31PXuJgHi1RMu1BAgQILCigIi1IqZbESBAoJKAgFVpm84SWkC8Cr0ewz0lIF49heFHAgQIEOghIGL1UPdMAgQIBBcQsIIvyHg1BPY//fnv2e/uvbrf77+9xomcoqqAeFV1s85FgACBdAIiVrqVGZgAAQJtBQSstr7uTmD3IF7de/tz4pUvQ3QB8Sr6hsxHgACB4QRErOFW7sAECBA4LCBgHbbxDoGzBcSrswndYCMB8WojaI8hQIAAgaUCItZSMdcTIECgqICAVXSxjtVfQLzqvwMTzBMQr+Y5uYoAAQIEugmIWN3oPZgAAQJxBASsOLswSSEB8arQMosfRbwqvmDHI0CAQB0BEavOLp2EAAECJwkIWCex+RCBwwLi1WEb78QSEK9i7cM0BAgQIHBUQMQ6SuQCAgQI1BUQsOru1sk6CIhXHdA98iQB8eokNh8iQIAAgf4CIlb/HZiAAAECXQQErC7sHlpRQLyquNWaZxKvau7VqQgQIDCQgIg10LIdlQABApOAgDVJeCVwhoB4dQaej24qIF5tyu1hBAgQINBOQMRqZ+vOBAgQCCkgYIVci6EyCYhXmbY19qzi1dj7d3oCBAgUFHgUsT7+UsGzORIBAgQIPCMgYD0D4lcCSwTEqyVaru0pIF711PdsAgQIEGgocBmx7n92vxOxGhq7NQECBEIICFgh1mCIjALiVcatjTmzeDXm3p2aAAECAwmIWAMt21EJEBhXQMAad/dOfoaAeHUGno9uKiBebcrtYQQIECDQT0DE6mfvyQQIENhEQMDahNlDKgmIV5W2Wfss4lXt/TodAQIECNwQELFukPgDAQIE6ggIWHV26SQbCIhXGyB7xCoC4tUqjG5CgAABAvkERKx8OzMxAQIEZgkIWLOYXERgtxOvfAuyCIhXWTZlTgIECBBoJCBiNYJ1WwIECPQUELB66nt2GgHxKs2qhh9UvBr+KwCAAAECBB4KiFi+CQQIECgmIGAVW6jjrC8gXq1v6o5tBC6e/+oXLr7jkx/eX7zxrjZPcFcCBAgQIJBKQMRKtS7DEiBA4G4BAetuH+8OLiBeDf4FSHT8h/HqT4pXiXZmVAIECBDYREDE2oTZQwgQINBeQMBqb+wJSQXEq6SLG3Bs8WrApTsyAQIECCwRELGWaLmWAAECQQUErKCLMVZfAfGqr7+nzxcQr+ZbuZIAAQIEhhYQsYZev8MTIFBBQMCqsEVnWFVAvFqV080aCohXDXHdmgABAgQqCohYFbfqTAQIDCMgYA2zagedIyBezVFyTQQB8SrCFsxAgAABAgkFRKyESzMyAQIErgQELN8DAo8ExCtfhSwC4lWWTZmTAAECBIIKiFhBF2MsAgQI3CUgYN2l471hBMSrYVad/qDiVfoVOgABAgQIxBAQsWLswRQECBCYLSBgzaZyYVUB8arqZuudS7yqt1MnIkCAAIGuAiJWV34PJ0CAwDIBAWuZl6uLCYhXxRZa+DjiVeHlOhoBAgQI9BQQsXrqezYBAgQWCAhYC7BcWktAvKq1z8qnEa8qb9fZCBAgQCCAgIgVYAlGIECAwDEBAeuYkPdLCohXJdda8lDiVcm1OhQBAgQIxBMQseLtxEQECBC4JiBgXePwywgC4tUIW65xRvGqxh6dggABAgTSCIhYaVZlUAIERhQQsEbc+sBnFq8GXn6yo4tXyRZmXAIECBCoIiBiVdmkcxAgUE5AwCq3Ugc6JCBeHZLx92gC4lW0jZiHAAECBAYTELEGW7jjEiCQQ0DAyrEnU54pIF6dCejjmwmIV5tRexABAgQIELhLQMS6S8d7BAgQ6CAgYHVA98htBcSrbb097XQB8ep0O58kQIAAAQINBESsBqhuSYAAgVMFBKxT5XwuhYB4lWJNhrwUEK98DQgQIECAQEgBESvkWgxFgMCIAgLWiFsf5Mzi1SCLLnBM8arAEh2BAAECBCoLXEWsz+x3H3+p8iGdjQABAtEFBKzoGzLfSQIP4tXbb7+63++//aQb+BCBjQQexqtPftf+4o13bfRIjyFAgAABAgSWC/xBEWs5mk8QIEBgTQEBa01N9woh8Dhe7fbfFmIgQxA4IPAkXr3+7gOX+DMBAgQIECAQR0DEirMLkxAgMKCAgDXg0isfWbyqvN1aZxOvau3TaQgQIEBgGAERa5hVOygBAtEEBKxoGzHPyQLi1cl0PrixgHi1MbjHESBAgACBdQVErHU93Y0AAQKzBASsWUwuii4gXkXfkPkmAfFqkvBKgAABAgRSC4hYqddneAIEMgoIWBm3ZuZrAuLVNQ6/BBYQrwIvx2gECBAgQGC5gIi13MwnCBAgcLKAgHUynQ9GEBCvImzBDHMExKs5Sq4hQIAAAQLpBESsdCszMAECWQUErKybM/dOvPIlyCIgXmXZlDkJECBAgMBJAiLWSWw+RIAAgWUCAtYyL1cHERCvgizCGEcFxKujRC4gQIAAAQIVBESsClt0BgIEQgsIWKHXY7jbBMSr21T8LaKAeBVxK2YiQIAAAQLNBESsZrRuTIAAgd3uAgKBbAL3vv9P/we7L/2jP5ttbvMOKHDxO/vdxT3/9+yAq8905Ddf+MbXP/HCL70z08xmHVPgXW+9tv/ef/Z5/3fqmOtPc+rLfx2w/7F7v/T5/+Q9//Ff+rX//+KfpRncoAQIEEgg4H8ISLAkI14X2O/2F/d2H/+rl6//9vV3/EaAAAECSwX2u+f/v+965y9/y9LPuZ4AAQIEnhG4/B9O/+c3/9z/+fzu3vN/7Hf/9YsX37X7oyLWM0Z+JUCAwBkC/hPCM/B8tI/Axe5i//zuV/785et/32cCTyVAgAABAgQIECDwlMCjePX9+1/78au/7ne7T3z1n+/+5ke/ef/up67yIwECBAicISBgnYHno/0EnkSs3X/XbwpPJkCAAAECBAgQGF7gYbz6hSleTR4i1iThlQABAusICFjrOLpLB4GHEesf/IXL/w5WxOrg75EECBAgQIAAgeEFnsSrH7vNQsS6TcXfCBAgcJqAgHWam08FERCxgizCGAQIECBAgACB0QSOxKuJQ8SaJLwSIEDgPAEB6zw/nw4gIGIFWIIRCBAgQIAAAQIjCcyMVxOJiDVJeCVAgMDpAgLW6XY+GUhAxAq0DKMQIECAAAECBCoLLIxXE4WINUl4JUCAwGkCAtZpbj4VUEDECrgUIxEgQIAAAQIEKgmcGK8mAhFrkvBKgACB5QIC1nIznwgsIGIFXo7RCBAgQIAAAQKZBc6MV9PRRaxJwisBAgSWCQhYy7xcnUBAxEqwJCMSIECAAAECBDIJrBSvpiOLWJOEVwIECMwXELDmW7kykYCIlWhZRiVAgAABAgQIRBZYOV5NRxWxJgmvBAgQmCcgYM1zclVCAREr4dKMTIAAAQIECBCIJNAoXk1HFLEmCa8ECBA4LiBgHTdyRWIBESvx8oxOgAABAgQIEOgp0DheTUcTsSYJrwQIELhbQMC628e7BQRErAJLdAQCBAgQIECAwJYCG8Wr6Ugi1iThlQABAocFBKzDNt4pJCBiFVqmoxAgQIAAAQIEWgpsHK+mo4hYk4RXAgQI3C4gYN3u4q8FBUSsgkt1JAIECBAgQIDAmgKd4tV0BBFrkvBKgACBmwIC1k0TfyksIGIVXq6jESBAgAABAgTOEegcr6bRRaxJwisBAgSuCwhY1z38NoCAiDXAkh2RAAECBAgQILBEIEi8mkYWsSYJrwQIEHgiIGA9sfDTQAIi1kDLdlQCBAgQIECAwF0CweLVNKqINUl4JUCAwEMBAcs3YVgBEWvY1Ts4AQIECBAgQOChQNB4Na1HxJokvBIgQGC3E7B8C4YWELGGXr/DEyBAgAABAiMLBI9X02pErEnCKwECowsIWKN/A5x/J2L5EhAgQIAAAQIEBhNIEq+mrYhYk4RXAgRGFhCwRt6+sz8WELEeU/iBAAECBAgQIFBbIFm8mpYhYk0SXgkQGFVAwBp18859Q0DEukHiDwQIECBAgACBWgJJ49W0BBFrkvBKgMCIAgLWiFt35oMCItZBGm8QIECAAAECBHILJI9XE76INUl4JUBgNAEBa7SNO+9RARHrKJELCBAgQIAAAQK5BIrEqwldxJokvBIgMJKAgDXStp11toCINZvKhQQIECBAgACB2ALF4tWELWJNEl4JEBhFQMAaZdPOuVhAxFpM5gMECBAgQIAAgVgCRePVhCxiTRJeCRAYQUDAGmHLzniygIh1Mp0PEiBAgAABAgT6ChSPVxOuiDVJeCVAoLqAgFV9w853toCIdTahGxAgQIAAAQIEthUYJF5NqCLWJOGVAIHKAgJW5e0622oCItZqlG5EgAABAgQIEGgrMFi8mjBFrEnCKwECVQUErKqbda7VBUSs1UndkAABAgQIECCwrsCg8WpCFLEmCa8ECFQUELAqbtWZmgmIWM1o3ZgAAQIECBAgcJ7A4PFqwhOxJgmvBAhUExCwqm3UeZoLiFjNiT2AAAECBAgQILBMQLy65iViXePwCwECRQQErCKLdIxtBUSsbb09jQABAgQIECBwUEC8upVGxLqVxR8JEEgsIGAlXp7R+wqIWH39PZ0AAQIECBAgsBOv7vwSiFh38niTAIFkAgJWsoUZN5aAiBVrH6YhQIAAAQIEBhIQr2YtW8SaxeQiAgQSCAhYCZZkxNgCT0Wsvxp7UtMRIECAAAECBIoIiFeLFiliLeJyMQECQQUErKCLMVYugUcR6y9e7HYiVq7VmZYAAQIECBDIJnAZr/6XN//sL3z//td+LNvoPecVsXrqezYBAmsICFhrKLoHgUsBEcvXgAABAgQIECDQWOBRvPq+/a+LVydQi1gnoPkIAQJhBASsMKswSAUBEavCFp2BAAECBAgQCCkgXq2yFhFrFUY3IUCgg4CA1QHdI2sLiFi19+t0BAgQIECAQAcB8WpVdBFrVU43I0BgIwEBayNojxlLQMQaa99OS4AAAQIECDQUEK+a4IpYTVjdlACBhgICVkNctx5bQMQae/9OT4AAAQIECKwgIF6tgHj4Fo8i1s9+9Jv37z58lXcIECAQQ0DAirEHUxQVELGKLtaxCBAgQIAAgfYC4lV748snXEasH/nqP9+JWJtoewgBAucICFjn6PksgRkCItYMJJcQIECAAAECBJ4WEK+e1mj+s4jVnNgDCBBYQUDAWgHRLQgcExCxjgl5nwABAgQIECDwSEC86vJVELG6sHsoAQILBASsBVguJXCOgIh1jp7PEiBAgAABAkMIiFdd1yxideX3cAIEjggIWEeAvE1gTQERa01N9yJAgAABAgRKCYhXIdYpYoVYgyEIELhFQMC6BcWfCLQUELFa6ro3AQIECBAgkFJAvAq1NhEr1DoMQ4DAIwEBy1eBQAcBEasDukcSIECAAAECMQXEq5B7EbFCrsVQBIYWELCGXr/D9xQQsXrqezYBAgQIECAQQkC8CrGGQ0OIWIdk/J0AgR4CAlYPdc8k8EhAxPJVIECAAAECBIYVEK9SrF7ESrEmQxIYQkDAGmLNDhlZQMSKvB2zESBAgAABAk0ExKsmrK1uKmK1knVfAgSWCAhYS7RcS6CRgIjVCNZtCRAgQIAAgXgC4lW8ncyYSMSageQSAgSaCghYTXndnMB8ARFrvpUrCRAgQIAAgaQC4lXSxT0cW8RKvT7DE0gvIGClX6EDVBIQsSpt01kIECBAgACBawLi1TWOrL+IWFk3Z24C+QUErPw7dIJiAiJWsYU6DgECBAgQILDbiVelvgUiVql1OgyBNAICVppVGXQkARFrpG07KwECBAgQKC4gXpVcsIhVcq0ORSC0gIAVej2GG1lAxBp5+85OgAABAgSKCIhXRRZ5+zFErNtd/JUAgTYCAlYbV3clsIqAiLUKo5sQIECAAAECPQTEqx7qmz9TxNqc3AMJDCsgYA27egfPIiBiZdmUOQkQIECAAIHHAuLVY4oRfhCxRtiyMxLoLyBg9d+BCQgcFRCxjhK5gAABAgQIEIgiIF5F2cSmc4hYm3J7GIEhBQSsIdfu0BkFRKyMWzMzAQIECBAYTEC8Gmzh148rYl338BsBAusKCFjrerobgaYCIlZTXjcnQIAAAQIEzhEQr87RK/NZEavMKh2EQDgBASvcSgxE4G4BEetuH+8SIECAAAECHQTEqw7ocR8pYsXdjckIZBYQsDJvz+zDCohYw67ewQkQIECAQDwB8SreTgJMJGIFWIIRCBQTELCKLdRxxhEQscbZtZMSIECAAIGwAuJV2NVEGEzEirAFMxCoIyBg1dmlkwwoIGINuHRHJkCAAAECUQTEqyibCD2HiBV6PYYjkEpAwEq1LsMSuCkgYt008RcCBAgQIECgsYB41Ri41u1FrFr7dBoCvQQErF7ynktgRQERa0VMtyJAgAABAgTuFhCv7vbx7q0CItatLP5IgMACAQFrAZZLCUQWeBKxLv7byHOajQABAgQIEEgsIF4lXl7/0UWs/jswAYHMAgJW5u2ZncAzAg8j1q/8O5evItYzNn4lQIAAAQIEzhQQr84E9PErARHL94AAgVMFBKxT5XyOQFABESvoYoxFgAABAgQyC4hXmbcXbnYRK9xKDEQghYCAlWJNhiSwTEDEWublagIECBAgQOAOAfHqDhxvnSogYp0q53MExhUQsMbdvZMXFxCxii/Y8QgQIECAwBYCD+PV3/6+/a//2BaP84yxBESssfbttATOFRCwzhX0eQKBBUSswMsxGgECBAgQiC7wJF794eijmi+vgIiVd3cmJ7C1gIC1tbjnEdhYQMTaGNzjCBAgQIBABQHxqsIW05xBxEqzKoMS6CogYHXl93AC2wiIWNs4ewoBAgQIECghIF6VWGO2Q4hY2TZmXgLbCwhY25t7IoEuAiJWF3YPJUCAAAECuQTEq1z7KjatiFVsoY5DYGUBAWtlULcjEFlAxIq8HbMRIECAAIHOAuKg67FTAABAAElEQVRV5wV4/JWAiOV7QIDAIQEB65CMvxMoKiBiFV2sYxEgQIAAgXMExKtz9Hx2ZQERa2VQtyNQREDAKrJIxyCwREDEWqLlWgIECBAgUFxAvCq+4JzHE7Fy7s3UBFoKCFgtdd2bQGABESvwcoxGgAABAgS2EhCvtpL2nBMERKwT0HyEQGEBAavwch2NwDEBEeuYkPcJECBAgEBhAfGq8HLrHE3EqrNLJyFwroCAda6gzxNILiBiJV+g8QkQIECAwCkC4tUpaj7TSUDE6gTvsQSCCQhYwRZiHAI9BESsHuqeSYAAAQIEOgmIV53gPfYcARHrHD2fJVBDQMCqsUenIHC2gIh1NqEbECBAgACB+ALiVfwdmfCggIh1kMYbBIYQELCGWLNDEpgnIGLNc3IVAQIECBBIKSBepVyboa8LiFjXPfxGYCQBAWukbTsrgRkCItYMJJcQIECAAIFsAuJVto2Z9w4BEesOHG8RKCwgYBVerqMROFVAxDpVzucIECBAgEBAAfEq4FKMdK7AFLE+8t79i+fey+cJEMghIGDl2JMpCWwuIGJtTu6BBAgQIEBgfQHxan1TdwwjcBWx3nh99zdFrDArMQiBpgICVlNeNyeQW0DEyr0/0xMgQIDA4ALi1eBfgDGO/yhi/ayINca+nXJsAQFr7P07PYGjAiLWUSIXECBAgACBeALiVbydmKiZwGXE+uHLf4klYjUTdmMCMQQErBh7MAWB0AIiVuj1GI4AAQIECFwXEK+ue/htCAERa4g1O+TgAgLW4F8AxycwV0DEmivlOgIECBAg0FFAvOqI79G9BUSs3hvwfAJtBQSstr7uTqCUgIhVap0OQ4AAAQLVBMSraht1nhMERKwT0HyEQBIBASvJooxJIIqAiBVlE+YgQIAAAQJPCYhXT2H4cXQBEWv0b4DzVxUQsKpu1rkINBQQsRriujUBAgQIEFgqIF4tFXP9AAIi1gBLdsThBASs4VbuwATWERCx1nF0FwIECBAgcJaAeHUWnw/XFhCxau/X6cYTELDG27kTE1hNQMRajdKNCBAgQIDAcgHxarmZTwwnIGINt3IHLiwgYBVerqMR2EJAxNpC2TMIECBAgMAzAuLVMyB+JXBYQMQ6bOMdApkEBKxM2zIrgaACIlbQxRiLAAECBGoKiFc19+pUTQVErKa8bk5gEwEBaxNmDyFQX0DEqr9jJyRAgACBAALiVYAlGCGrgIiVdXPmJvBQQMDyTSBAYDUBEWs1SjciQIAAAQI3BcSrmyb+QmChgIi1EMzlBAIJCFiBlmEUAhUERKwKW3QGAgQIEAgnIF6FW4mB8gqIWHl3Z/KxBQSssffv9ASaCDwVsf6bJg9wUwIECBAgMJKAeDXStp11IwERayNojyGwooCAtSKmWxEg8ETgUcT6dy9fRawnLH4iQIAAAQLLBMSrZV6uJrBAQMRagOVSAgEEBKwASzACgaoCIlbVzToXAQIECGwiIF5twuwhYwuIWGPv3+lzCQhYufZlWgLpBESsdCszMAECBAhEEBCvImzBDIMIiFiDLNox0wsIWOlX6AAE4guIWPF3ZEICBAgQCCQgXgVahlFGERCxRtm0c2YWELAyb8/sBBIJiFiJlmVUAgQIEOgncBmv/tc3/8wvft/+1/9wvyE8mcCYAiLWmHt36jwCAlaeXZmUQHoBESv9Ch2AAAECBFoKPIpXH93/xo+2fIx7EyBwWEDEOmzjHQK9BQSs3hvwfAKDCYhYgy3ccQkQIEBgnoB4Nc/JVQQ2EBCxNkD2CAInCAhYJ6D5CAEC5wmIWOf5+TQBAgQIFBMQr4ot1HEqCIhYFbboDNUEBKxqG3UeAkkERKwkizImAQIECLQVEK/a+ro7gTMERKwz8HyUQAMBAasBqlsSIDBPQMSa5+QqAgQIECgqIF4VXaxjVRIQsSpt01myCwhY2TdofgLJBUSs5As0PgECBAicJiBenebmUwQ6CIhYHdA9ksAtAgLWLSj+RIDAtgIi1rbenkaAAAECnQXEq84L8HgCywVErOVmPkFgbQEBa21R9yNA4CQBEeskNh8iQIAAgWwC4lW2jZmXwGMBEesxhR8IdBEQsLqweygBArcJiFi3qfgbAQIECJQREK/KrNJBxhUQscbdvZP3FxCw+u/ABAQIPCUgYj2F4UcCBAgQqCMgXtXZpZMMLyBiDf8VANBJQMDqBO+xBAgcFhCxDtt4hwABAgQSCohXCZdmZAJ3C4hYd/t4l0ALAQGrhap7EiBwtoCIdTahGxAgQIBABAHxKsIWzECgiYCI1YTVTQkcFBCwDtJ4gwCB3gIiVu8NeD4BAgQInCUgXp3F58MEMgiIWBm2ZMYqAgJWlU06B4GiAiJW0cU6FgECBKoLiFfVN+x8BB4LiFiPKfxAoKmAgNWU180JEFhDQMRaQ9E9CBAgQGAzAfFqM2oPIhBFQMSKsglzVBYQsCpv19kIFBIQsQot01EIECBQWUC8qrxdZyNwp4CIdSePNwmcLSBgnU3oBgQIbCUgYm0l7TkECBAgcJKAeHUSmw8RqCQgYlXaprNEExCwom3EPAQI3CkgYt3J400CBAgQ6CUgXvWS91wC4QRErHArMVARAQGryCIdg8BIAiLWSNt2VgIECCQQEK8SLMmIBLYVELG29fa0MQQErDH27JQEygmIWOVW6kAECBDIKSBe5dybqQlsICBibYDsEUMJCFhDrdthCdQSELFq7dNpCBAgkE5AvEq3MgMT2FpAxNpa3PMqCwhYlbfrbAQGEBCxBliyIxIgQCCigHgVcStmIhBSQMQKuRZDJRQQsBIuzcgECFwXELGue/iNAAECBBoLiFeNgd2eQD0BEaveTp1oewEBa3tzTyRAoIGAiNUA1S0JECBA4KaAeHXTxF8IEJglIGLNYnIRgYMCAtZBGm8QIJBNQMTKtjHzEiBAIJmAeJVsYcYlEE9AxIq3ExPlERCw8uzKpAQIzBAQsWYguYQAAQIElguIV8vNfIIAgVsFRKxbWfyRwFEBAesokQsIEMgmIGJl25h5CRAgEFxAvAq+IOMRyCcgYuXbmYn7CwhY/XdgAgIEGgiIWA1Q3ZIAAQIjCohXI27dmQlsIiBibcLsIYUEBKxCy3QUAgSuC4hY1z38RoAAAQILBcSrhWAuJ0BgqYCItVTM9SMLCFgjb9/ZCQwg8FTE+q8HOK4jEiBAgMBaAuLVWpLuQ4DAEYFHEevnPvLe/YtHLvU2gaEFBKyh1+/wBMYQeBSx/r3LVxFrjJU7JQECBM4TEK/O8/NpAgQWC1xGrB964/WdiLVYzgdGEhCwRtq2sxIYWEDEGnj5jk6AAIElAuLVEi3XEiCwooCItSKmW5UUELBKrtWhCBC4TUDEuk3F3wgQIEDgsYB49ZjCDwQI9BEQsfq4e2oOAQErx55MSYDASgIi1kqQbkOAAIFqAuJVtY06D4G0AiJW2tUZvLGAgNUY2O0JEIgnIGLF24mJCBAg0FVAvOrK7+EECNwUELFumvgLAQHLd4AAgSEFRKwh1+7QBAgQuCkgXt008RcCBEIIiFgh1mCIQAICVqBlGIUAgW0FRKxtvT2NAAEC4QQu49X/9uaf+cWP7n/jR8PNZiACBAhcCohYvgYEnggIWE8s/ESAwIACItaAS3dkAgQIXAk8ilffK175PhAgEFxAxAq+IONtJiBgbUbtQQQIRBUQsaJuxlwECBBoJCBeNYJ1WwIEWgmIWK1k3TeTgICVaVtmJUCgmYCI1YzWjQkQIBBLQLyKtQ/TECAwW0DEmk3lwqICAlbRxToWAQLLBUSs5WY+QYAAgVQC4lWqdRmWAIGbAiLWTRN/GUdAwBpn105KgMAMARFrBpJLCBAgkFFAvMq4NTMTIHCLgIh1C4o/DSEgYA2xZockQGCJgIi1RMu1BAgQSCAgXiVYkhEJEFgiIGIt0XJtFQEBq8omnYMAgVUFRKxVOd2MAAEC/QTEq372nkyAQFMBEaspr5sHFBCwAi7FSAQIxBAQsWLswRQECBA4WUC8OpnOBwkQyCEgYuXYkynXERCw1nF0FwIEigqIWEUX61gECNQXEK/q79gJCRB4ICBi+SKMIiBgjbJp5yRA4GQBEetkOh8kQIBAHwHxqo+7pxIg0E1AxOpG78EbCghYG2J7FAECeQVErLy7MzkBAoMJiFeDLdxxCRCYBESsScJrVQEBq+pmnYsAgdUFRKzVSd2QAAEC6wqIV+t6uhsBAukERKx0KzPwAgEBawGWSwkQICBi+Q4QIEAgqIB4FXQxxiJAYGsBEWtrcc/bSkDA2kracwgQKCMgYpVZpYMQIFBFQLyqsknnIEBgJQERayVItwklIGCFWodhCBDIIiBiZdmUOQkQKC8gXpVfsQMSIHCagIh1mptPxRUQsOLuxmQECAQXELGCL8h4BAjUFxCv6u/YCQkQOEtAxDqLz4eDCQhYwRZiHAIEcgmIWLn2ZVoCBAoJiFeFlukoBAi0FBCxWuq695YCAtaW2p5FgEBJARGr5FodigCByALiVeTtmI0AgYACIlbApRhpsYCAtZjMBwgQIHBTQMS6aeIvBAgQaCIgXjVhdVMCBOoLiFj1d1z9hAJW9Q07HwECmwmIWJtRexABAqMKiFejbt65CRBYSUDEWgnSbboICFhd2D2UAIGqAiJW1c06FwEC3QXEq+4rMAABAjUERKwaexzxFC+MeGhnJkCAQEuBq4j1wXfuf/Y3vutf/d7n/58XfrTls9ybAAECowj8S7/7a1/4/v/03/rQ5Xn/4Shnds6cAp/7zAfe2v1CztlNPY7AVcR6/fXdZz7y3v1P/eY/ufjqOCd30swCAlbm7ZmdAIGQAh98cf9v3L+3+/T9//wfv/XCf/jNf2//hW/8wZCDGooAAQKJBO49//zF/ve8932JRjbqoAL3X3rptwY9umPnE/jBN17f/dxlxPojIla+5Y04sf+EcMStOzMBAs0Epnh1+f+q9Y7dxW733Ke++IMXv+/Nv9fsgW5MgAABAgQIECBA4EQB/znhiXA+1kVAwOrC7qEECFQUuBavpgOKWJOEVwIECBAgQIAAgYACIlbApRjpVgEB61YWfyRAgMAygVvj1XQLEWuS8EqAAAECBAgQIBBQQMQKuBQj3RAQsG6Q+AMBAgSWCdwZr6ZbiViThFcCBAgQIECAAIGAAiJWwKUY6ZqAgHWNwy8ECBBYJjArXk23FLEmCa8ECBAgQIAAAQIBBUSsgEsx0mMBAesxhR8IECCwTGBRvJpuLWJNEl4JECBAgAABAgQCCohYAZdipAcCApYvAgECBE4QOCleTc8RsSYJrwQIECBAgAABAgEFRKyASzHSTsDyJSBAgMBCgbPi1fQsEWuS8EqAAAECBAgQIBBQQMQKuJTBRxKwBv8COD4BAssEPvDi/o/fv7f79OX/D/0dyz55y9Ui1i0o/kSAAAECBAgQIBBFQMSKsglzXAkIWL4HBAgQmClwFa/293Y/s0q8mp4pYk0SXgkQIECAAAECBAIKTBHrw+/Zf1PA8Yw0kICANdCyHZUAgdMFmsSraRwRa5LwSoAAAQIECBAgEFDgKmK99ebuZ0WsgMsZaCQBa6BlOyoBAqcJNI1X00gi1iThlQABAgQIECBAIKCAiBVwKYONJGANtnDHJUBgmcAm8WoaScSaJLwSIECAAAECBAgEFBCxAi5loJEErIGW7agECCwT2DReTaOJWJOEVwIECBAgQIAAgYACIlbApQwykoA1yKIdkwCBZQJd4tU04hSxPvbm353+5JUAAQIECBAgQIBAFAERK8omxppDwBpr305LgMAMga7xaprvKmL9lS/+0IWINYl4JUCAAAECBAgQCCQgYgVaxiCjCFiDLNoxCRCYJxAiXk2jThHr97/xy9OfvBIgQIAAAQIECBCIIiBiRdnEGHMIWGPs2SkJEJghECpeTfNeRaz/4ks/4F9iTSBeCRAgQIAAAQIEIgmIWJG2UXsWAav2fp2OAIGZAiHj1TT79C+x/OeEk4hXAgQIECBAgACBQAIiVqBlFB5FwCq8XEcjQGCeQOh4NR1BxJokvBIgQIAAAQIECAQUuIpYX3tz93Mffs/+mwKOZ6QCAgJWgSU6AgECpwukiFfT8USsScIrAQIECBAgQIBATIEfFLFiLqbCVAJWhS06AwECJwmkilfTCUWsScIrAQIECBAgQIBATAERK+Ze0k8lYKVfoQMQIHCKQMp4NR1UxJokvBIgQIAAAQIECMQUELFi7iX1VAJW6vUZngCBUwRSx6vpwCLWJOGVAAECBAgQIEAgpoCIFXMvaacSsNKuzuAECJwiUCJeTQcXsSYJrwQIECBAgAABAjEFRKyYe0k5lYCVcm2GJkDgFIGreHX/3u7Tl/8bUt5xyudDfkbECrkWQxEgQIAAAQIECDwWELEeU/jhHAEB6xw9nyVAII3AFK8uB34hzdBzBxWx5kq5jgABAgQIECBAoI+AiNXHvdRTBaxS63QYAgRuEygdr6YDi1iThFcCBAgQIECAAIGYAiJWzL2kmUrASrMqgxIgcIrAEPFqghGxJgmvBAgQIECAAAECMQVErJh7STGVgJViTYYkQOAUgaHi1QQkYk0SXgkQIECAAAECBGIKiFgx9xJ+KgEr/IoMSIDAKQJDxqsJSsSaJLwSIECAAAECBAjEFBCxYu4l9FQCVuj1GI4AgVMEho5XE5iINUl4JUCAAAECBAgQiCkgYsXcS9ipBKywqzEYAQKnCIhXT6mJWE9h+JEAAQIECBAgQCCggIgVcClRRxKwom7GXAQILBYQr24hE7FuQfEnAgQIECBAgACBQAIiVqBlRB5FwIq8HbMRIDBbQLy6g0rEugPHWwQIECBAgAABAgEERKwAS4g+goAVfUPmI0DgqIB4dZRotxOxZiC5hAABAgQIECBAoKOAiNURP8OjBawMWzIjAQIHBcSrgzQ33xCxbpr4CwECBAgQIECAQCQBESvSNoLNImAFW4hxCBCYLyBezbd6fKWI9ZjCDwQIECBAgAABAiEFRKyQa+k/lIDVfwcmIEDgBAHx6gS06SOPI9Ybf3f6k1cCBAgQIECAAAECgQRErEDLiDKKgBVlE+YgQGC2gHg1m+rwhQ8i1pd+6OJjItZhJO8QIECAAAECBAh0FBCxOuJHfLSAFXErZiJA4KCAeHWQZvkbItZyM58gQIAAAQIECBDYUkDE2lI7+LMErOALMh4BAk8ExKsnFqv9JGKtRulGBAgQIECAAAECTQRErCas+W4qYOXbmYkJDCkgXjVcu4jVENetCRAgQIAAAQIEVhAQsVZAzH4LASv7Bs1PYAAB8WqDJYtYGyB7BAECBAgQIECAwBkCItYZeBU+KmBV2KIzECgsIF5tuFwRa0NsjyJAgAABAgQIEDhBQMQ6Aa3KRwSsKpt0DgIFBcSrDksVsTqgeyQBAgQIECBAgMACARFrAValSwWsStt0FgKFBD7w7v2fuH9v9+nLI71Q6Fg5jiJi5diTKQkQIECAAAEC4wqIWAPuXsAacOmOTCC6wIN4dX/3M5dzile9lvUkYv2dXiN4LgECBAgQIECAAIE7BESsO3AqviVgVdyqMxFILCBeBVrew4j1wxcfe0PECrQWoxAgQIAAAQIECDwWELEeU9T/QcCqv2MnJJBGQLwKuCoRK+BSjESAAAECBAgQIPCUgIj1FEblHwWsytt1NgKJBMSrwMsSsQIvx2gECBAgQIAAAQKXAiLWAF8DAWuAJTsigegC4lX0DV3OJ2IlWJIRCRAgQIAAAQJDC4hYxdcvYBVfsOMRiC4gXkXf0FPziVhPYfiRAAECBAgQIEAgoICIFXApa40kYK0l6T4ECCwWEK8Wk/X/gIjVfwcmIECAAAECBAgQuEtAxLpLJ/F7Albi5RmdQGYB8Srx9kSsxMszOgECBAgQIEBgCAERq+CaBayCS3UkAtEFxKvoG5oxn4g1A8klBAgQIECAAAECHQVErI74LR4tYLVQdU8CBA4KiFcHafK9IWLl25mJCRAgQIAAAQJjCYhYhfYtYBVapqMQiC4gXkXf0AnziVgnoPkIAQIECBAgQIDAhgIi1obYLR8lYLXUdW8CBB4LiFePKer9IGLV26kTESBAgAABAgRqCYhYBfYpYBVYoiMQiC4gXkXf0ArziVgrILoFAQIECBAgQIBAQwERqyHuFrcWsLZQ9gwCAwuIVwMtX8QaaNmOSoAAAQIECBBIKSBipVzbw6EFrMTLMzqB6ALiVfQNNZhPxGqA6pYECBAgQIAAAQIrCohYK2JueSsBa0ttzyIwkIB4NdCynz2qiPWsiN8JECBAgAABAgRiCYhYsfYxaxoBaxaTiwgQWCIgXi3RKnqtiFV0sY5FgAABAgQIECgjIGIlW6WAlWxhxiUQXUC8ir6hDecTsTbE9igCBAgQIECAAIETBESsE9B6fUTA6iXvuQQKCohXBZd67pFErHMFfZ4AAQIECBAgQKCtgIjV1ne1uwtYq1G6EYGxBcSrsfd/5+lFrDt5vEmAAAECBAgQINBdQMTqvoLjAwhYx41cQYDAEQHx6giQt3c7Ecu3gAABAgQIECBAILaAiBV7PzsBK/iCjEcguoB4FX1DgeYTsQItwygECBAgQIAAAQK3CFxFrM98+D37b7rlPX/qLCBgdV6AxxPILCBeZd5ep9lFrE7wHkuAAAECBAgQIDBT4A+JWDOlNr5MwNoY3OMIVBEQr6psssM5RKwO6B5JgAABAgQIECCwQEDEWoC11aUC1lbSnkOgkIB4VWiZvY4iYvWS91wCBAgQIECAAIF5AiLWPKfNrhKwNqP2IAI1BMSrGnsMcQoRK8QaDEGAAAECBAgQIHBQQMQ6SLP9GwLW9uaeSCCtgHiVdnVxBxex4u7GZAQIECBAgAABAlcCIlaQ74GAFWQRxiAQXUC8ir6hxPOJWImXZ3QCBAgQIECAwBACIlaANQtYAZZgBALRBcSr6BsqMJ+IVWCJjkCAAAECBAgQKC0gYnVer4DVeQEeTyC6gHgVfUOF5hOxCi3TUQgQIECAAAECJQVErI5rFbA64ns0gegC4lX0DRWcT8QquFRHIkCAAAECBAiUEhCxOq1TwOoE77EEoguIV9E3VHg+Eavwch2NAAECBAgQIFBCQMTqsEYBqwO6RxKILiBeRd/QAPOJWAMs2REJECBAgAABAqkFRKyN1ydgbQzucQSiC4hX0Tc00HxXEetTX/rhi4+98XcGOrWjEiBAgAABAgQI5BEQsTbclYC1IbZHEYguIF5F39CY84lYY+7dqQkQIECAAAECSQRErI0WJWBtBO0xBKILiFfRNzT2fA8i1u9745fGVnB6AgQIECBAgACBoAIi1gaLEbA2QPYIAtEFxKvoGzLflcBz/9WXfuRCxPJlIECAAAECBAgQiCkgYjXei4DVGNjtCUQXuIxX/+b9+7ufuZzzheizmo+AiOU7QIAAAQIECBAgEFhAxGq4HAGrIa5bE4gu8Che/fTlnOJV9GWZ77GAiPWYwg8ECBAgQIAAAQLxBESsRjsRsBrBui2B6ALiVfQNme8uARHrLh3vESBAgAABAgQIdBYQsRosQMBqgOqWBKILiFfRN2S+OQIi1hwl1xAgQIAAAQIECHQSELFWhhewVgZ1OwLRBcSr6Bsy3xIBEWuJlmsJECBAgAABAgQ2FhCxVgQXsFbEdCsC0QXEq+gbMt8pAiLWKWo+Q4AAAQIECBAgsJGAiLUStIC1EqTbEIguIF5F35D5zhEQsc7R81kCBAgQIECAAIHGAiLWCsAC1gqIbkEguoB4FX1D5ltDQMRaQ9E9CBAgQIAAAQIEGgmIWGfCClhnAvo4gegC4lX0DZlvTQERa01N9yJAgAABAgQIEFhZQMQ6A1TAOgPPRwlEFxCvom/IfC0ERKwWqu5JgAABAgQIECCwkoCIdSKkgHUinI8RiC4gXkXfkPlaCohYLXXdmwABAgQIECBA4EwBEesEQAHrBDQfIRBdQLyKviHzbSEgYm2h7BkECBAgQIAAAQInCohYC+EErIVgLicQXUC8ir4h820pIGJtqe1ZBAgQIECAAAECCwVErAVgAtYCLJcSiC4gXkXfkPl6CIhYPdQ9kwABAgQIECBAYKaAiDUTSsCaCeUyAtEFxKvoGzJfTwERq6e+ZxMgQIAAAQIECBwRELGOAF29LWDNQHIJgegC4lX0DZkvgoCIFWELZiBAgAABAgQIEDggIGIdgJn+LGBNEl4JJBUQr5IuzthdBESsLuweSoAAAQIECBAgME9AxLrDScC6A8dbBKILiFfRN2S+iAIiVsStmIkAAQIECBAgQOCRwIOI9aFX9i8RuS4gYF338BuBNALiVZpVGTSggIgVcClGIkCAAAECBAgQmAT+0Ne/tvs5EWviePgqYF338BuBFALiVYo1GTK4gIgVfEHGI0CAAAECBAiMLSBiPbN/AesZEL8SiC4gXkXfkPkyCYhYmbZlVgIECBAgQIDAcAIi1lMrF7CewvAjgegC4lX0DZkvo4CIlXFrZiZAgAABAgQIDCMgYj1atYA1zHfeQbMLiFfZN2j+yAIiVuTtmI0AAQIECBAgMLyAiHX5FRCwhv//DgBkEBCvMmzJjNkFRKzsGzQ/AQIECBAgQKC0wPARS8Aq/f12uAoC4lWFLTpDFoEHEetjb/xSlnnNSYAAAQIECBAgMJTA0BFLwBrqu+6w2QTEq2wbM28Fgec+9aUfuRCxKqzSGQgQIECAAAECFQWGjVgCVsWvszOVEBCvSqzRIZIKiFhJF2dsAgQIECBAgMAYAkNGLAFrjC+3UyYTEK+SLcy4JQVErJJrdSgCBAgQIECAQBWB4SKWgFXlq+scZQTEqzKrdJACAiJWgSU6AgECBAgQIECgrsBQEUvAqvtFdrKEAuJVwqUZubyAiFV+xQ5IgAABAgQIEMgsMEzEErAyf03NXkpAvCq1TocpJiBiFVuo4xAgQIAAAQIEagkMEbEErFpfWqdJKiBeJV2csYcSELGGWrfDEiBAgAABAgSyCZSPWAJWtq+kecsJiFflVupAhQUeRqw3f7HwER2NAAECBAgQIEAgr0DpiCVg5f1imryAgHhVYImOMJzAc5/64icuPiZiDbd4ByZAgAABAgQI5BC4ilif+dAr+5dyjDt/SgFrvpUrCawqIF6tyulmBDYVELE25fYwAgQIECBAgACBZQJ/sGLEErCWfQlcTWAVAfFqFUY3IdBVQMTqyu/hBAgQIECAAAECdwuUi1gC1t0L9y6B1QXEq9VJ3ZBANwERqxu9BxMgQIAAAQIECBwXKBWxBKzjC3cFgdUExKvVKN2IQBgBESvMKgxCgAABAgQIECBwU6BMxBKwbi7XXwg0EfjOd+//5P37u5++vPkLTR7gpgQIdBMQsbrRezABAgQIECBAgMBxgRIRS8A6vmhXEDhb4Cpe7e/v/sbljcSrszXdgEBMAREr5l5MRYAAAQIECBAg8EAgfcQSsHyTCTQWEK8aA7s9gUACIlagZRiFAAECBAgQIEDgWYHUEUvAenadfiewooB4tSKmWxFIIiBiJVmUMQkQIECAAAECYwqkjVgC1phfWKfeQEC82gDZIwgEFRCxgi7GWAQIECBAgAABAlcCKSOWgOXLS6CBgHjVANUtCSQTELGSLcy4BAgQIECAAIGxBNJFLAFrrC+o024gIF5tgOwRBJIIiFhJFmVMAgQIECBAgMCYAqkiloA15pfUqRsJiFeNYN2WQGIBESvx8oxOgAABAgQIEKgvkCZiCVj1v4xOuJGAeLURtMcQSCggYiVcmpEJECBAgAABAuMIpIhYAtY4X0gnbSggXjXEdWsCRQRErCKLdAwCBAgQIECAQE2B8BFLwKr5xXOqDQXEqw2xPYpAcgERK/kCjU+AAAECBAgQqC0QOmIJWLW/fE7XWEC8agzs9gQKCohYBZfqSAQIECBAgACBOgJhI5aAVedL5iQbC4hXG4N7HIFCAiJWoWU6CgECBAgQIECgnkDIiCVg1fuiOdEGAuLVBsgeQaC4gIhVfMGOR4AAAQIECBDILRAuYglYub9Qpu8gIF51QPdIAkUFRKyii3UsAgQIECBAgEANgVARS8Cq8aVyio0ExKuNoD2GwEACItZAy3ZUAgQIECBAgEA+gTARS8DK9+UxcScB8aoTvMcSGEBAxBpgyY5IgAABAgQIEMgrECJiCVh5v0Am31BAvNoQ26MIDCogYg26eMcmQIAAAQIECOQQ6B6xBKwcXxRTdhQQrzriezSBwQRErMEW7rgECBAgQIAAgVwCXSOWgJXry2LajQXEq43BPY4AgZ2I5UtAgAABAgQIECAQWKBbxBKwAn8rjNZXQLzq6+/pBEYWELFG3r6zEyBAgAABAgTCC3SJWAJW+O+FAXsIiFc91D2TAIGnBUSspzX8TIAAAQIECBAgEExg84glYAX7Bhinv4B41X8HJiBA4KGAiOWbQIAAAQIECBAgEFhg04glYAX+JhhtewHxantzTyRA4G4BEetuH+8SIECAAAECBAh0FdgsYglYXffs4ZEExKtI2zALAQJPC4hYT2v4mQABAgQIECBAIJjAJhFLwAq2deP0ERCv+rh7KgEC8wVErPlWriRAgAABAgQIENhcoHnEErA236kHRhMQr6JtxDwECBwSELEOyfg7AQIECBAgQIBAAIGmEUvACrBhI/QTEK/62XsyAQKnCYhYp7n5FAECBAgQIECAwCYCzSKWgLXJ/jwkooB4FXErZiJAYI6AiDVHyTUECBAgQIAAAQKdBJpELAGr0zY9tq+AeNXX39MJEDhf4EHE+tde/9vn38kdCBAgQIAAAQIECKwusHrEErBW35EbRhcQr6JvyHwECMwVeO6v/PaPXohYc7lcR4AAAQIECBAgsK3AqhFLwNp2eZ7WWUC86rwAjydAYHUBEWt1UjckQIAAAQIECBBYT2C1iCVgrbcUdwouIF4FX5DxCBA4WUDEOpnOBwkQIECAAAECBNoLrBKxBKz2i/KEAALiVYAlGIEAgaYCIlZTXjcnQIAAAQIECBA4T+DsiCVgnbcAn04gIF4lWJIRCRBYRUDEWoXRTQgQIECAAAECBNoInBWxBKw2S3HXIALiVZBFGIMAgc0ERKzNqD2IAAECBAgQIEBgucDJEUvAWo7tE0kExKskizImAQKrC4hYq5O6IQECBAgQIECAwHoCJ0UsAWu9BbhTIAHxKtAyjEKAQBcBEasLu4cSIECAAAECBAjME1gcsQSsebCuSiQgXiVallEJEGgqIGI15XVzAgQIECBAgACB8wQWRSwB6zxsnw4mcBmvPrm/v/sbl2O9EGw04xAgQKCLgIjVhd1DCRAgQIAAAQIE5gnMjlgC1jxQVyUQeBSv/vrlqOJVgn0ZkQCB7QRErO2sPYkAAQIECBAgQGCxwKyIJWAtdvWBiALiVcStmIkAgUgCIlakbZiFAAECBAgQIEDgGYGjEUvAekbMr/kExKt8OzMxAQJ9BESsPu6eSoAAAQIECBAgMEvgzoglYM0ydFFUAfEq6mbMRYBAVAERK+pmzEWAAAECBAgQIHApcDBiCVi+H2kFxKu0qzM4AQKdBUSszgvweAIECBAgQIAAgbsEbo1YAtZdZN4LKyBehV2NwQgQSCIgYiVZlDEJECBAgAABAmMKXEWsz37olf1L0/H9b2ubJLymERCv0qzKoAQIBBe4iliv/eWP/vzuC7tvCT6q8Qjs9vvd/uLt+19HQSC8wP379y52O9/V8IsyIAECCQQ+du9r+//9I+/d/+u/+U8uvvov2ruXWG+3u6Dj//97etqjp7HQo0ZRSpVESQBP6TktHYiWIqVVEmdY204MCfeLA0fOTJQYU6uJ94FxoDBAZ06MA6kWUPASbj2GGMQeRtACKZxSaNOz3c973v/e797v//Jc1uW31vqQmL33//8861nr83uC5utLuf7vrf6LQDsC4lU7s7LT3e4X//0f+uwzz3z2WRYEogt829/4jx//qZ/9s98QfZ/2N7bAH37mcz/z0/tvffXVX//Nt48t4fTRBfZ/6vc+/uBf/bL/nhp9UPZHgEATAvv9/qd3r3/De/cv/uZn/I8QNjEym5wExCvvAQECBPII/OhH3vsNX//8j388z+pWJZBG4PNPPb3ff+SHvvbBc1/6v9KsaBUCBAgQIEAgssDj8Wrap4AVeVr2diMgXt1Q+IUAAQJZBESsLKwWTSxw9fR1xRKxEqtajgABAgQIxBO4H6+mHQpY8eZkR/cExKt7IP4kQIBAJgERKxOsZZMKiFhJOS1GgAABAgTCCRyLV9MmBaxwo7KhxwXEq8c1/E6AAIH8AiJWfmNP2C4gYm03tAIBAgQIEIgocCpeTXsVsCJOzJ4eCohXXgQCBAjUERCx6rh76jIBEWuZl6sJECBAgEB0gXPxatq7gBV9goPuT7wadPCOTYBAGAERK8wobOSMgIh1BsdXBAgQIECgIYFL8Wo6ioDV0EBH2ap4NcqknZMAgegCIlb0CdnfJCBieQ8IECBAgEDbAnPi1XRCAavtOXe3e/Gqu5E6EAECjQuIWI0PcJDti1iDDNoxCRAgQKA7gbnxajq4gNXd+Ns9kHjV7uzsnACBvgVErL7n28vpRKxeJukcBAgQIDCKwJJ4NZkIWKO8GcHPKV4FH5DtESAwvICINfwr0ASAiNXEmGySAAECBAjslsariUzA8uJUFxCvqo/ABggQIDBLQMSaxeSiygIiVuUBeDwBAgQIELggsCZeTUsKWBdgfZ1XQLzK62t1AgQIpBYQsVKLWi+HgIiVQ9WaBAgQIEBgu8DaeDU9WcDa7m+FlQLi1Uo4txEgQKCygIhVeQAeP0tAxJrF5CICBAgQIFBMYEu8mjYpYBUblQc9LiBePa7hdwIECLQnIGK1N7MRdyxijTh1ZyZAgACBiAJb49V0JgEr4mQ735N41fmAHY8AgWEERKxhRt30QUWspsdn8wQIECDQgcDDePXgmW/ev/ibn9lyHAFri557FwuIV4vJ3ECAAIHQAiJW6PHY3CMBEcurQIAAAQIE6gjcxKt3/cZvbd2BgLVV0P2zBcSr2VQuJECAQFMCDyPW1/74x5vatM0OJyBiDTdyByZAgACBygIp49V0FAGr8kBHebx4NcqknZMAgVEFfvSj7/2GrxexRh1/M+cWsZoZlY0SIECAQOMCqePVxCFgNf5StLB98aqFKdkjAQIEtguIWNsNrZBfQMTKb+wJBAgQIDC2QI54NYkKWGO/V9lPL15lJ/YAAgQIhBIQsUKNw2ZOCDwWsf7niUt8TIAAAQIECKwQyBWvpq0IWCsG4pZ5AuLVPCdXESBAoDcBEau3ifZ5nkcR6888eO5LRaw+R+xUBAgQIFBYIGe8mo4iYBUe6CiPE69GmbRzEiBA4LiAiHXcxaexBESsWPOwGwIECBBoVyB3vJpkBKx234+wOxevwo7GxggQIFBUQMQqyu1hKwVErJVwbiNAgAABAo8ESsSr6VECllcuqYB4lZTTYgQIEGheQMRqfoRDHEDEGmLMDkmAAAECGQRKxatp6wJWhgGOuqR4NerknZsAAQLnBUSs8z6+jSEgYsWYg10QIECAQDsCJePVpCJgtfNuhN6peBV6PDZHgACB6gIiVvUR2MAMARFrBpJLCBAgQIDAtcB1vPqp3YNnvnn/rt/4rVIgAlYp6Y6fI151PFxHI0CAQEIBESshpqWyCYhY2WgtTIAAAQKdCDyKV+8tGa8mOgGrkxeo1jHEq1rynkuAAIE2BUSsNuc22q5FrNEm7rwECBAgMFegVrya9idgzZ2S654QEK+eIPEBAQIECMwQELFmILmkuoCIVX0ENkCAAAECwQRqxquJQsAK9kK0sp3rePVtV6/ufuR6v69rZc/2SYAAAQJxBESsOLOwk9MCItZpG98QIECAwFgCtePVpC1gjfXOJTnto3j1w9eLiVdJRC1CgACBMQVErDHn3tqpRazWJma/BAgQIJBaIEK8ms4kYKWebOfriVedD9jxCBAgUFhAxCoM7nGrBESsVWxuIkCAAIEOBKLEq4lSwOrghSp1BPGqlLTnECBAYCwBEWusebd6WhGr1cnZNwECBAisFYgUr6YzCFhrJznYfeLVYAN3XAIECBQWELEKg3vcKgERaxWbmwgQIECgQYFo8WoiFLAafJFKb1m8Ki3ueQQIEBhTQMQac+6tnVrEam1i9kuAAAECSwUixqvpDALW0kkOdr14NdjAHZcAAQKVBUSsygPw+FkCItYsJhcRIECAQIMCUePVRClgNfhCldqyeFVK2nMIECBA4HEBEetxDb9HFRCxok7GvggQIEBgrUDkeDWdScBaO9nO7xOvOh+w4xEgQCC4gIgVfEC291BAxPIiECBAgEAvAtHj1eQsYPXytiU8h3iVENNSBAgQILBaQMRaTefGggIiVkFsjyJAgACBLAItxKvp4AJWlvG3u6h41e7s7JwAAQI9CohYPU61vzOJWP3N1IkIECAwikAr8Wqah4A1yls545zi1QwklxAgQIBAcQERqzi5B64QELFWoLmFAAECBKoKtBSvJigBq+rrEufh4lWcWdgJAQIECDwpIGI9aeKTeAIiVryZ2BEBAgQIHBdoLV5NpxCwjs9yqE/Fq6HG7bAECBBoVkDEanZ0Q21cxBpq3A5LgACBJgVajFcTtIDV5OuWbtPiVTpLKxEgQIBAfgERK7+xJ2wXELG2G1qBAAECBPIItBqvJg0BK8870cSq4lUTY7JJAgQIELgnIGLdA/FnSAERK+RYbIoAAQJDC7Qcr6bBCViDvr7i1aCDd2wCBAh0IiBidTLIzo8hYnU+YMcjQIBAQwKtx6uJWsBq6IVLtVXxKpWkdQgQIECgpoCIVVPfs+cKiFhzpVxHgAABArkEeohXk42AlesNCbqueBV0MLZFgAABAqsERKxVbG4qLCBiFQb3OAIECBC4EeglXk0HErBuxtr/L+JV/zN2QgIECIwoIGKNOPX2zixitTczOyZAgEDrAj3Fq2kWAlbrb+TM/YtXM6FcRoAAAQJNCohYTY5tuE2LWMON3IEJECBQTaC3eDVBCljVXqdyDxavyll7EgECBAjUExCx6tl78nwBEWu+lSsJECBAYJ1Aj/FqkhCw1r0Pzdz1KF79yPWGX9fMpm2UAAECBAisFBCxVsK5raiAiFWU28MIECAwlECv8WoaooDV8av8WLx6quNjOhoBAgQIELgjIGLd4fBHUAERK+hgbIsAAQINC/Qcr6axCFgNv5znti5endPxHQECBAj0LiBi9T7hPs4nYvUxR6cgQIBABIHe49VkLGBFeNMS70G8SgxqOQIECBBoUkDEanJsw21axBpu5A5MgACB5AIjxKsJTcBK/urUXVC8quvv6QQIECAQS0DEijUPuzkuIGIdd/EpAQIECFwWGCVeTRIC1uX3oZkrxKtmRmWjBAgQIFBQQMQqiO1RqwVErNV0biRAgMCwAiPFq2nIAlYnr7p41ckgHYMAAQIEsgiIWFlYLZpYQMRKDGo5AgQIdCwwWryaRilgdfBCi1cdDNERCBAgQCC7gIiVndgDEgiIWAkQLUGAAIHOBUaMV9NIBazGX2zxqvEB2j4BAgQIFBUQsYpye9hKARFrJZzbCBAgMIDAqPFqGq2A1fALLl41PDxbJ0CAAIFqAiJWNXoPXiBwiFj75978Pxbc5lICBAgQ6Fhg5Hg1jVXAavTlFq8aHZxtEyBAgEAIARErxBhs4oLAFLEefOTvPC9iXYDyNQECBAYQGD1eTSMWsBp80cWrBodmywQIECAQTkDECjcSGzoi8DBi/f0fErGO2PiIAAECowiIV69NWsBq7I0XrxobmO0SIECAQGgBESv0eGzukcDV6x48/UDE8j4QIEBgSAHx6nbsAtatRfjfxKvwI7JBAgQIEGhQQMRqcGgDblnEGnDojkyAwPAC4tXdV0DAuusR9i/xKuxobIwAAQIEOhAQsToY4gBHELEGGLIjEiBA4JGAePXkqyBgPWkS7hPxKtxIbIgAAQIEOhQQsTocaodHErE6HKojESBA4J6AeHUP5NGfAtZxlzCffvkbr/7K1au7H7ne0FNhNmUjBAgQIECgUwERq9PBdnYsEauzgToOAQIEHhMQrx7DuPergHUPJNKfU7zavbr74es9iVeRBmMvBAgQINC1gIjV9Xi7OZyI1c0oHYQAAQI3AuLVDcXRXwSsoyz1PxSv6s/ADggQIEBgXAERa9zZt3RyEauladkrAQIEzguIV+d9pm8FrMtGxa8Qr4qTeyABAgQIEHhCQMR6gsQHAQVErIBDsSUCBAgsFBCv5oEJWPOcil0lXhWj9iACBAgQIHBRQMS6SOSCAAIiVoAh2AIBAgRWCux3+/+2e/DMe/fv+o3fWrnEMLcJWIFGLV4FGoatECBAgACBRwIillehBQERq4Up2SMBAgTuCjyMV0898y3i1V2XU38JWKdkCn8uXhUG9zgCBAgQILBAQMRagOXSagIiVjV6DyZAgMBiAfFqMZn/DKzlZOnvEK/Sm1qRAAECBAikFhCxUotaL4eAiJVD1ZoECBBIKyBerfP0L7DWuSW7S7xKRmkhAgQIECCQXUDEyk7sAQkERKwEiJYgQIBAJgHxaj2sgLXebvOd4tVmQgsQIECAAIHiAiJWcXIPXCEgYq1AcwsBAgQyC4hX24AFrG1+q+8Wr1bTuZEAAQIECFQXELGqj8AGZgiIWDOQXEKAAIFCAuLVdmgBa7vh4hXEq8VkbiBAgAABAuEERKxwI7GhIwIi1hEUHxEgQKCwgHiVBlzASuM4exXxajaVCwkQIECAQHgBESv8iGzwWkDE8hoQIECgnoB4lc5ewEpneXEl8eoikQsIECBAgEBzAiJWcyMbcsMi1pBjd2gCBCoLiFdpByBgpfU8uZp4dZLGFwQIECBAoHkBEav5EQ5xABFriDE7JAECQQTEq/SDELDSmz6xonj1BIkPCBAgQIBAdwIiVncj7fJAIlaXY3UoAgSCCYhXeQYiYOVxvVlVvLqh8AsBAgQIEOheQMTqfsRdHFDE6mKMDkGAQFAB8SrfYASsfLY78SojrqUJECBAgEBQAREr6GBs646AiHWHwx8ECBBIIiBeJWE8uYiAdZJm2xfi1TY/dxMgQIAAgZYFpoj1zq/9if/S8hnsvX8BEav/GTshAQLlBMSr/NYCVgZj8SoDqiUJECBAgEBjAv/2o9/850SsxoY24HZFrAGH7sgECCQXEK+Skx5dUMA6yrL+Q/FqvZ07CRAgQIBAbwIiVm8T7fM8Ilafc3UqAgTKCIhXZZynpwhYCa3Fq4SYliJAgAABAp0IiFidDLLzY4hYnQ/Y8QgQyCIgXmVhPbmogHWSZtkX4tUyL1cTIECAAIGRBESskabd7llFrHZnZ+cECJQXEK/KmwtYCczFqwSIliBAgAABAp0LiFidD7iT44lYnQzSMQgQyCogXmXlPbm4gHWSZt4X4tU8J1cRIECAAAECu52I5S1oQUDEamFK9kiAQC0B8aqWvP8MrE3y4tUmPjcTIECAAIEhBUSsIcfe3KFFrOZGZsMECBQQEK8KIJ95hH+BdQbn3Ffi1Tkd3xEgQIAAAQLnBESsczq+iyIgYkWZhH0QIBBBQLyqPwUBa8UMxKsVaG4hQIAAAQIE7giIWHc4/BFUQMQKOhjbIkCgqIB4VZT75MMErJM0x78Qr467+JQAAQIECBBYLiBiLTdzR3kBEau8uScSIBBHQLyKMwsBa8EsxKsFWC4lQIAAAQIEZgmIWLOYXFRZQMSqPACPJ0CgioB4VYX95EMFrJM0d78Qr+56+IsAAQIECBBIJyBipbO0Uj4BESufrZUJEIgnIF7Fm4mANWMm4tUMJJcQIECAAAECmwRErE18bi4kIGIVgvYYAgSqCohXVflPPlzAOknz2hfi1QUgXxMgQIAAAQLJBESsZJQWyiggYmXEtTQBAtUFxKvqIzi5AQHrJM1uJ16dwfEVAQIECBAgkEVAxMrCatHEAiJWYlDLESAQQkC8CjGGk5sQsE7QiFcnYHxMgAABAgQIZBcQsbITe0ACgcci1n9PsJwlCBAgUFVAvKrKP+vhAtYRJvHqCIqPCBAgQIAAgaICIlZRbg9bKfAoYr1t/9ybRayVhm4jQKC+gHhVfwZzdiBg3VMSr+6B+JMAAQIECBCoJiBiVaP34AUCItYCLJcSIBBOQLwKN5KTGxKwHqMRrx7D8CsBAgQIECAQQkDECjEGm7ggIGJdAPI1AQIhBcSrkGM5uSkB6xHNW9949YHdq7sfvv7zqZNaviBAgAABAgQIVBAQsSqge+RiARFrMZkbCBCoKCBeVcRf+WgB6xpuildffHX3b65/Fa9WvkhuI0CAAAECBPIKiFh5fa2eRkDESuNoFQIE8gqIV3l9c60+fMASr3K9WtYlQIAAAQIEUguIWKlFrZdDQMTKoWpNAgRSCYhXqSTLrzN0wBKvyr9wnkiAAAECBAhsExCxtvm5u4yAiFXG2VMIEFgmIF4t84p29bABS7yK9iraDwECBAgQIDBXQMSaK+W6mgIiVk19zyZA4L6AeHVfpL2/hwxY4lV7L6odEyBAgAABAncFRKy7Hv6KKSBixZyLXREYTUC86mPiwwUs8aqPF9cpCBAgQIAAgd1OxPIWtCAgYrUwJXsk0K+AeNXPbIcKWOJVPy+ukxAgQIAAAQKvCYhY3oQWBESsFqZkjwT6ExCv+prpMAFLvOrrxXUaAgQIECBA4FZAxLq18FtcAREr7mzsjECPAuJVf1MdImCJV/29uE5EgAABAgQI3BUQse56+CumgIgVcy52RaA3AfGqt4m+dp7uA5Z41eeL61QECBAgQIDAkwIi1pMmPoknIGLFm4kdEehJQLzqaZp3z9J1wBKv7g7bXwQIECBAgED/AiJW/zPu4YQiVg9TdAYC8QTEq3gzSbmjbgOWeJXyNbEWAQIECBAg0JKAiNXStMbdq4g17uydnEAOgf1u9193Tz3zLft3/cZv5VjfmvUFugxY4lX9F8sOCBAgQIAAgboCIlZdf0+fJyBizXNyFQEC5wVei1e/733i1Xmn1r/tLmCJV62/kvZPgAABAgQIpBIQsVJJWiengIiVU9faBPoXeBivnnvWv7zqf9S7rgKWeDXAG+uIBAgQIECAwCIBEWsRl4srCYhYleA9lkDjAjfx6qs+/duNH8X2Zwh0E7DEqxnTdgkBAgQIECAwpICINeTYmzu0iNXcyGyYQFUB8aoqf5WHdxGwxKsq746HEiBAgAABAg0JiFgNDWvgrYpYAw/f0QksEBCvFmB1dGnzAUu86uhtdBQCBAgQIEAgq4CIlZXX4okERKxEkJYh0KmAeNXpYGccq+mAJV7NmLBLCBAgQIAAAQKPCYhYj2H4NayAiBV2NDZGoKqAeFWVv/rDmw1Y4lX1d8cGCBAgQIAAgUYFRKxGBzfYtkWswQbuuAQuCIhXF4AG+LrJgCVeDfBmOiIBAgQIECCQVUDEyspr8UQCIlYiSMsQaFxAvGp8gIm231zAEq8STd4yBAgQIECAwPACItbwr0ATACJWE2OySQLZBMSrbLTNLdxUwBKvmnu/bJgAAQIECBAILiBiBR+Q7T0UeBixPvpDz++fe/N/R0KAwDgC4tU4s55z0mYClng1Z5yuIUCAAAECBAgsFxCxlpu5o7zA1VMPXv9AxCoP74kEKgmIV5XgAz+2iYAlXgV+g2yNAAECBAgQ6EJAxOpijN0fQsTqfsQOSOChgHjlRTgmED5giVfHxuYzAgQIECBAgEB6ARErvakV0wuIWOlNrUggkoB4FWkasfYSOmCJV7FeFrshQIAAAQIE+hcQsfqfcQ8nFLF6a65YlQAAPxZJREFUmKIzEHhSQLx60sQntwJhA5Z4dTskvxEgQIAAAQIESgqIWCW1PWutgIi1Vs59BGIKiFcx5xJpVyEDlngV6RWxFwIECBAgQGBEARFrxKm3d2YRq72Z2TGBYwLi1TEVn90XCBewxKv7I/I3AQIECBAgQKCOgIhVx91TlwmIWMu8XE0gmoB4FW0icfcTKmCJV3FfFDsjQIAAAQIExhQQscace2unFrFam5j9EnhNQLzyJiwRCBOwxKslY3MtAQIECBAgQKCcgIhVztqT1guIWOvt3EmghoB4VUO97WeGCFjiVdsvkd0TIECAAAEC/QuIWP3PuIcTilg9TNEZRhAQr0aYcvozVg9Y4lX6oVqRAAECBAgQIJBDQMTKoWrN1AIiVmpR6xFIKyBepfUcabWqAUu8GulVc1YCBAgQIECgBwERq4cp9n8GEav/GTthmwLiVZtzi7LragFLvIryCtgHAQIECBAgQGCZgIi1zMvVdQRErDrunkrglIB4dUrG53MFqgQs8WrueFxHgAABAgQIEIgpIGLFnItd3RW4jVh/8KfvfuMvAgRKCohXJbX7fVbxgPXWZ6/+6hdf3f2ba9Kn+mV1MgIECBAgQIBA/wIiVv8z7uGEr0Wsv/22/XMiVg/zdIb2BMSr9mYWdcdFA9bDeHW1+9fXGOJV1DfCvggQIECAAAECCwRErAVYLq0mIGJVo/fgwQXEq8FfgMTHLxawxKvEk7McAQIECBAgQCCIgIgVZBC2cVZAxDrL40sCyQXEq+Skwy9YJGCJV8O/ZwAIECBAgACBzgVErM4H3MnxRKxOBukY4QXEq/AjanKD2QOWeNXke2HTBAgQIECAAIHFAiLWYjI3VBAQsSqge+RQAuLVUOMuetisAUu8KjpLDyNAgAABAgQIVBcQsaqPwAZmCIhYM5BcQmCFgHi1As0tswWyBSzxavYMXEiAAAECBAgQ6EpAxOpqnN0eRsTqdrQOVklAvKoEP9BjswQs8WqgN8hRCRAgQIAAAQJHBESsIyg+CidwG7He/NPhNmdDBBoSEK8aGlbDW00esMSrht8GWydAgAABAgQIJBQQsRJiWiqbwGsR64fetn9OxMqGbOGuBcSrrscb6nBJA5Z4FWq2NkOAAAECBAgQqC4gYlUfgQ3MEBCxZiC5hMARAfHqCIqPsgkkC1jiVbYZWZgAAQIECBAg0LSAiNX0+IbZvIg1zKgdNJGAeJUI0jKzBZIELPFqtrcLCRAgQIAAAQJDCohYQ469uUOLWM2NzIYrCYhXleAHf+zmgCVeDf4GOT4BAgQIECBAYKbAFLHe8TU/+Z9nXu4yAlUERKwq7B7akIB41dCwOtvqpoAlXnX2NjgOAQIECBAgQCCzwL/7B3/hz4tYmZEtv1lAxNpMaIFOBcSrTgfbyLFWByzxqpEJ2yYBAgQIECBAIJiAiBVsILZzVEDEOsriw4EFxKuBhx/k6KsClngVZHq2QYAAAQIECBBoVEDEanRwg21bxBps4I57UkC8Oknji4ICiwOWeFVwOh5FgAABAgQIEOhYQMTqeLgdHU3E6miYjrJKQLxaxeamDAKLApZ4lWECliRAgAABAgQIDCwgYg08/IaOLmI1NCxbTSogXiXltNhGgdkBS7zaKO12AgQIECBAgACBowIi1lEWHwYTELGCDcR2sguIV9mJPWChwKyAJV4tVHU5AQIECBAgQIDAIgERaxGXiysJiFiV4D22uIB4VZzcA2cIXAxY4tUMRZcQIECAAAECBAhsFhCxNhNaoICAiFUA2SOqCuz3u5/cPffst+y/6tO/XXUjHk7gnsDZgCVe3dPyJwECBAgQIECAQFYBESsrr8UTCYhYiSAtE07gYbx687PvE6/CjcaGrgVOBizxyvtBgAABAgQIECBQQ0DEqqHumUsFRKylYq6PLiBeRZ+Q/R0NWOKVF4MAAQIECBAgQKCmgIhVU9+z5wqIWHOlXBddQLyKPiH7mwSeCFjilReDAAECBAgQIEAggoCIFWEK9nBJQMS6JOT76ALiVfQJ2d9B4E7AEq8OLH4SIECAAAECBAhEEBCxIkzBHi4JiFiXhHwfVUC8ijoZ+zomcP2/HfO1//qON/ynv/Qr+y/76NVufydqHb73k0AUgZef/ord5x+8Psp27IPASYFf+Mgf+703PP27bzh5gS8IRBB45nW73R/5sgg7sQcCZwX+4b/8R5/4gW/5fX/57EW+JFBZYP/FVz+/+89/9z/uvv0/fGvlrXg8gYsC1/HqJ3Zvfvb9/gPbL1K5IIjATcC62r3rrV/cff5jV7urrwiyN9sgcFTgqb/1N3/x6ivf+qePfulDAoEErj78HZ+92u2eDbQlWyFwR2C/2//O7q9/z0v7F59/8c4X/iAQTOD6/8H66/v96/7Cq1evftdu9+p3Btue7RC4I7B/w//5+O7Lvv0b7nzoDwLBBPzLq2ADsZ1ZAjf/2mq/+2//76nd6999/f+Y/eSsO11EgAABAgQINCsgXjU7uuE2/jBeve6pb9p/6Ot+5sGH3v7d1/8Rrv9iOAQHJkCAQEIB8SohpqWKCtwErOmpIlZRew8jQIAAAQJVBMSrKuweukLgJl594O0/O92+3++vHkas/f6fr1jOLQQIEBheQLwa/hVoGuBOwJpOImI1PU+bJ0CAAAECZwXEq7M8vgwkcD9eHbb2MGJ98IXvua5ZItYBxU8CBAjMEBCvZiC5JLTAEwFr2q2IFXpmNkeAAAECBFYJiFer2NxUQeBUvDpsRcQ6SPhJgACBeQLi1TwnV8UWOBqwpi2LWLEHZ3cECBAgQGCJgHi1RMu1NQUuxavD3kSsg4SfBAgQOC8gXp338W07AicD1nQEEaudQdopAQIECBA4JSBenZLxeTSBufHqsG8R6yDhJwECBI4LiFfHXXzapsDZgDUdScRqc7B2TYAAAQIEJgHxynvQisDSeHU4l4h1kPCTAAECdwXEq7se/mpf4GLAmo4oYrU/aCcgQIAAgfEExKvxZt7qidfGq8N5RayDhJ8ECBB4TUC88ib0KDArYE0HF7F6HL8zESBAgECvAuJVr5Pt71xb49VBRMQ6SPhJgMDoAuLV6G9Av+efHbAmAhGr3xfByQgQIECgHwHxqp9Z9n6SVPHq4CRiHST8JEBgVAHxatTJj3HuRQFrIhGxxngxnJIAAQIE2hQQr9qc24i7Th2vDoYi1kHCTwIERhMQr0ab+HjnXRywJiIRa7wXxYkJECBAIL6AeBV/Rnb4mkCueHXwFbEOEn4SIDCKgHg1yqTHPueqgDWRiVhjvzhOT4AAAQKxBMSrWPOwm9MCuePV4cki1kHCTwIEehcQr3qfsPMdBFYHrGkBEevA6CcBAgQIEKgnIF7Vs/fkZQKl4tVhVyLWQcJPAgR6FRCvep2scx0T2BSwpgVFrGOsPiNAgAABAmUExKsyzp6yXaB0vDrsWMQ6SPhJgEBvAuJVbxN1nksCmwPW9AAR6xKz7wkQIECAQHoB8Sq9qRXzCNSKV4fTiFgHCT8JEOhFQLzqZZLOsUQgScCaHihiLWF3LQECBAgQ2CYgXm3zc3c5gdrx6nBSEesg4ScBAq0LiFetT9D+1wokC1jTBkSstWNwHwECBAgQmC8gXs23cmVdgSjx6qAgYh0k/CRAoFUB8arVydl3CoGkAWvakIiVYizWIECAAAECxwXEq+MuPo0nEC1eHYRErIOEnwQItCYgXrU2MftNLZA8YE0bFLFSj8l6BAgQIEBg+r9f97+z++vf89L+xedf5EEgskDUeHUwE7EOEn4SINCKgHjVyqTsM6dAloA1bVjEyjk2axMgQIDAaALi1WgTb/e80ePVQVbEOkj4SYBAdAHxKvqE7K+UQLaANR1AxCo1Rs8hQIAAgZ4FxKuep9vX2VqJVwd1Eesg4ScBAlEFxKuok7GvGgJZA9Z0IBGrxlg9kwABAgR6ERCveplk/+doLV4dJiJiHST8JEAgmoB4FW0i9lNbIHvAmg4oYtUes+cTIECAQIsC4lWLUxtzz63Gq8O0RKyDhJ8ECEQREK+iTMI+IgkUCVjTgUWsSGO3FwIECBCILiBeRZ+Q/R0EWo9XN+fY768efPCF79nt9//88JmfBAgQqCEgXtVQ98wWBIoFrAlDxGrhlbBHAgQIEKgtIF7VnoDnzxXoJV4dzutfYh0k/CRAoJaAeFVL3nNbECgasCYQEauF18IeCRAgQKCWgHhVS95zlwr0Fq8O5xexDhJ+EiBQWkC8Ki3uea0JFA9YE5CI1dprYr8ECBAgUEJAvCqh7BkpBHqNVwcbEesg4ScBAqUExKtS0p7TskCVgDWBiVgtvzb2ToAAAQKpBcSr1KLWyyXQe7w6uIlYBwk/CRDILSBe5Ra2fi8C1QLWBChi9fIaOQcBAgQIbBEQr7boubekwCjx6mAqYh0k/CRAIJeAeJVL1ro9ClQNWBOoiNXja+VMBAgQIDBXQLyaK+W62gKjxauDt4h1kPCTAIHUAuJValHr9S5QPWBNwCJW76+Z8xEgQIDAMQHx6piKzyIKjBqvDrMQsQ4SfhIgkEpAvEolaZ2RBEIErAlcxBrptXNWAgQIEBCvvAOtCIwerw5zErEOEn4SILBVQLzaKuj+UQXCBKxpACLWqK+hcxMgQGAsAfFqrHm3fFrx6u70RKy7Hv4iQGC5gHi13MwdBA4CoQLWtCkR6zAaPwkQIECgRwHxqsep9nkm8er4XEWs4y4+JUDgsoB4ddnIFQTOCYQLWNNmRaxzI/MdAQIECLQqMMWrBz/43S/tX3z+xVbPYN9jCIhX5+f8WMT6Z+ev9C0BAgReExCvvAkEtguEDFjTsUSs7cO1AgECBAjEETjEq6t3vE28ijMWOzkiIF4dQTny0aOI9b27/V7EOuLjIwIEbgXEq1sLvxHYIhA2YE2HErG2jNa9BAgQIBBFQLyKMgn7uCQgXl0Suvu9iHXXw18ECDwpIF49aeITAmsFQges6VAi1trRuo8AAQIEIgiIVxGmYA9zBMSrOUpPXiNiPWniEwIEXhO4jlc/sXvzs+/bf9Wnf5sJAQLbBcIHrOmIItb2QVuBAAECBMoLiFflzT1xnYB4tc7tcJeIdZDwkwCBg8CjePV+8eog4ieB7QJNBKzpmCLW9mFbgQABAgTKCYhX5aw9aZuAeLXN73C3iHWQ8JMAAfHKO0Agj0AzAWs6voiV5yWwKgECBAikFRCv0npaLZ+AeJXWVsRK62k1Ai0KiFctTs2eWxFoKmBNqCJWK6+WfRIgQGBMAfFqzLm3eGrxKs/URKw8rlYl0IKAeNXClOyxZYHmAtaELWK1/MrZOwECBPoVEK/6nW1vJ3sYrx48eM/+A2//2d7OFuE8IlaEKdgDgbIC4lVZb08bU6DJgDWNSsQa84V1agIECEQVEK+iTsa+7gvcxKsPvvBz97/zdzoBESudpZUIRBcQr6JPyP56EWg2YE0DELF6eQ2dgwABAm0LiFdtz2+k3YtXZactYpX19jQCNQTEqxrqnjmqQNMBaxqaiDXqq+vcBAgQiCEgXsWYg11cFhCvLhvluELEyqFqTQIxBMSrGHOwi3EEmg9Y06hErHFeWCclQIBAJAHxKtI07OWcgHh1Tif/dyJWfmNPIFBaQLwqLe55BHa7LgLWNEgRy+tMgAABAiUFxKuS2p61RUC82qKX7l4RK52llQjUFhCvak/A80cV6CZgTQMUsUZ9jZ2bAAECZQWu49XnHvzgd7909Y63vVj2yZ5GYJmAeLXMK/fVIlZuYesTyC8gXuU39gQCpwS6CljTIUWsU6P2OQECBAikEHgUrz4hXqXQtEZOAfEqp+76tUWs9XbuJFBbQLyqPQHPH12gu4A1DVTEGv21dn4CBAjkERCv8rhaNb2AeJXeNOWKIlZKTWsRKCMgXpVx9hQC5wS6DFjTgUWsc2P3HQECBAgsFRCvloq5vpaAeFVLftlzRaxlXq4mUFNAvKqp79kEbgW6DVjTEUWs20H7jQABAgTWC4hX6+3cWVZAvCrrvfVpItZWQfcTyC/wMF696Y3v23/Vp387/9M8gQCBcwJdB6zp4CLWufH7jgABAgQuCYhXl4R8H0VAvIoyiWX7ELGWebmaQEmBm3j11Z96peRzPYsAgeMC3Qes6dgi1vHh+5QAAQIEzguIV+d9fBtHQLyKM4s1OxGx1qi5h0BeAfEqr6/VCawRGCJgTTAi1prXwz0ECBAYV0C8Gnf2rZ1cvGptYsf3K2Idd/EpgRoC4lUNdc8kcFlgmIA1UYhYl18IVxAgQIDA9H9f7D/34Ae/+xNX73jbizwIRBa4jh6f3j948J79B1/4ucj7tLd5AiLWPCdXEcgpIF7l1LU2gW0CQwWsiUrE2vbCuJsAAQK9C4hXvU+4n/M9jFf7/TeJV/3MdDqJiNXXPJ2mLQHxqq152e14AsMFrGnEItZ4L7oTEyBAYI6AeDVHyTURBMSrCFPItwcRK5+tlQmcEhCvTsn4nEAcgSED1sQvYsV5Ce2EAAECEQTEqwhTsIc5AuLVHKX2rxGx2p+hE7QjIF61Mys7HVtg2IA1jV3EGvvld3oCBAgcBMSrg4Sf0QXEq+gTSrs/ESutp9UIHBMQr46p+IxATIGhA9Y0EhEr5otpVwQIECglIF6VkvacrQLi1VbBNu8Xsdqcm123ISBetTEnuyRwEBg+YE0QItbhdfCTAAECYwmIV2PNu+XTilctT2/73kWs7YZWIHBfQLy6L+JvAvEFBKxHMxKx4r+sdkiAAIGUAuJVSk1r5RQQr3LqtrO2iNXOrOw0voB4FX9GdkjgmICA9ZiKiPUYhl8JECDQsYB41fFwOzuaeNXZQDceR8TaCOh2AtcC4pXXgEC7AgLWvdmJWPdA/EmAAIHOBMSrzgba8XHEq46Hu+FoItYGPLcOLyBeDf8KAGhcQMA6MkAR6wiKjwgQINCBgHjVwRAHOYJ4NcigVx5TxFoJ57ahBcSrocfv8J0ICFgnBilinYDxMQECBBoVEK8aHdyA2xavBhz6iiOLWCvQ3DKsgHg17OgdvDMBAevMQEWsMzi+IkCAQEMC4lVDwxp8q+LV4C/AwuOLWAvBXD6kgHg15NgdulMBAevCYEWsC0C+JkCAQHAB8Sr4gGzvRkC8uqHwywKBm4i12//TBbe5lMAQAuLVEGN2yIEEBKwZwxaxZiC5hAABAgEFxKuAQ7GlowLi1VEWH84UeBixPvTC913/71cTsWaauax/AfGq/xk74XgCAtbMmYtYM6FcRoAAgSAC4lWQQdjGRQHx6iKRC2YIiFgzkFwyjIB4NcyoHXQwAQFrwcBFrAVYLiVAgEBFAfGqIr5HLxIQrxZxufiCgIh1AcjXQwiIV0OM2SEHFRCwFg5exFoI5nICBAgUFhCvCoN73GoB8Wo1nRvPCIhYZ3B81b2AeNX9iB1wcAEBa8ULIGKtQHMLAQIECgiIVwWQPSKJgHiVhNEiJwRErBMwPu5aQLzqerwOR+ChgIC18kUQsVbCuY0AAQKZBMSrTLCWTS4gXiUnteARgSliPfXhF7/Xf7D7ERwfdScgXnU3UgcicFRAwDrKMu9DEWuek6sIECCQW0C8yi1s/VQC4lUqSevMFRCx5kq5rlUB8arVydk3geUCAtZyszt3iFh3OPxBgACB4gJTvNr/wHe+dPWOt71Y/OEeSGCBgHi1AMulSQVErKScFgskIF4FGoatECggIGAlQBaxEiBaggABAisEDvFq9863v7DidrcQKCYgXhWj9qATAiLWCRgfNysgXjU7OhsnsFpAwFpNd/dGEeuuh78IECCQW0C8yi1s/VQC4lUqSetsFRCxtgq6P4qAeBVlEvZBoKyAgJXQW8RKiGkpAgQInBEQr87g+CqUgHgVahw2cy0gYnkNWhcQr1qfoP0TWC8gYK23O3qniHWUxYcECBBIJiBeJaO0UGYB8SozsOVXC4hYq+ncWFlAvKo8AI8nUFlAwMowABErA6olCRAgcC0gXnkNWhEQr1qZ1Lj7FLHGnX2rJxevWp2cfRNIJyBgpbO8s5KIdYfDHwQIENgsIF5tJrRAIQHxqhC0x2wWELE2E1qgkMB+t/vx3Zve+L79V3/qlUKP9BgCBAIKCFgZhyJiZcS1NAECQwmIV0ONu+nDildNj2/IzYtYQ469qUM/jFdf8sb3i1dNjc1mCWQRELCysN4uKmLdWviNAAECawTEqzVq7qkhIF7VUPfMFAIiVgpFa+QQEK9yqFqTQLsCAlaB2YlYBZA9ggCBLgXEqy7H2uWhxKsuxzrUoUSsocbdxGHFqybGZJMEigoIWIW4RaxC0B5DgEA3AuJVN6Ps/iDiVfcjHuaAItYwow5/UPEq/IhskEAVAQGrILuIVRDbowgQaFpAvGp6fENtXrwaatxDHFbEGmLMoQ8pXoUej80RqCogYBXmF7EKg3scAQLNCYhXzY1s2A2LV8OOvvuDi1jdjzjsAcWrsKOxMQIhBASsCmMQsSqgeyQBAk0IiFdNjMkmrwXEK69B7wIiVu8Tjnc+8SreTOyIQDQBAavSRESsSvAeS4BAWAHxKuxobOyegHh1D8Sf3QqIWN2ONtzBxKtwI7EhAiEFBKyKYxGxKuJ7NAECoQTEq1DjsJkzAuLVGRxfdSkgYnU51lCHEq9CjcNmCIQWELAqj0fEqjwAjydAoLqAeFV9BDYwU0C8mgnlsu4ERKzuRhrmQOJVmFHYCIEmBASsAGMSsQIMwRYIEKgiIF5VYffQFQLi1Qo0t3QlIGJ1Nc4QhxGvQozBJgg0JSBgBRmXiBVkELZBgEAxAfGqGLUHbRQQrzYCur0bARGrm1FWP4h4VX0ENkCgSQEBK9DYRKxAw7AVAgSyCohXWXktnlDgYby62r1n/8EXfi7hspYi0KyAiNXs6MJsXLwKMwobIdCcgIAVbGQiVrCB2A4BAskFxKvkpBbMJHATrz784s9neoRlCTQpIGI1ObYQmxavQozBJgg0KyBgBRydiBVwKLZEgEASAfEqCaNFCgiIVwWQPaJpARGr6fFV2bx4VYXdQwl0JSBgBR2niBV0MLZFgMBqAfFqNZ0bCwuIV4XBPa5ZARGr2dEV37h4VZzcAwl0KSBgBR6riBV4OLZGgMAiAfFqEZeLKwqIVxXxPbpJARGrybEV3bR4VZTbwwh0LSBgBR+viBV8QLZHgMBFAfHqIpELggiIV0EGYRvNCYhYzY2s2IbFq2LUHkRgCAEBq4Exi1gNDMkWCRA4KiBeHWXxYUAB8SrgUGypKQERq6lxFdmseFWE2UMIDCUgYDUybhGrkUHZJgECNwLi1Q2FX4ILiFfBB2R7zQiIWM2MKvtGxavsxB5AYEgBAauhsYtYDQ3LVgkMLiBeDf4CNHR88aqhYdlqEwIPI9Z+90+a2KxNZhEQr7KwWpQAgWsBAaux10DEamxgtktgQAHxasChN3pk8arRwdl2eIGnPvSO79uJWOHnlGOD4lUOVWsSIHAQELAOEg39FLEaGpatEhhMQLwabOANH1e8anh4tt6EgIjVxJiSblK8SsppMQIEjggIWEdQWvhIxGphSvZIYCwB8Wqsebd8WvGq5enZe0sCIlZL09q2V/Fqm5+7CRCYJyBgzXMKeZWIFXIsNkVgSAHxasixN3lo8arJsdl0wwIiVsPDm7l18WomlMsIENgsIGBtJqy7gIhV19/TCRDYXf/HnOw/t/+B73xp9863v8CDQGQB8SrydOytZwERq9/pilf9ztbJCEQUELAiTmXhnkSshWAuJ0AgmYB4lYzSQpkFxKvMwJYncEFAxLoA1ODX4lWDQ7NlAo0LCFiND/CwfRHrIOEnAQKlBMSrUtKes1VAvNoq6H4CaQRErDSOEVYRryJMwR4IjCcgYHU0cxGro2E6CoHgAuJV8AHZ3o2AeHVD4RcCIQRErBBj2LQJ8WoTn5sJENggIGBtwIt4q4gVcSr2RKAvAfGqr3n2fBrxqufpOlvLAiJWu9MTr9qdnZ0T6EFAwOphivfOIGLdA/EnAQLJBMSrZJQWyiwgXmUGtjyBjQIi1kbACreLVxXQPZIAgTsCAtYdjn7+ELH6maWTEIgiIF5FmYR9XBIQry4J+Z5ADAERK8Yc5uxCvJqj5BoCBHILCFi5hSuuL2JVxPdoAp0JiFedDbTj44hXHQ/X0boUELHij1W8ij8jOyQwioCA1fmkRazOB+x4BAoIiFcFkD0iiYB4lYTRIgSKC4hYxclnP1C8mk3lQgIECggIWAWQaz9CxKo9Ac8n0K6AeNXu7EbbuXg12sSdtzcBESveRMWreDOxIwKjCwhYg7wBItYgg3ZMAgkFxKuEmJbKKiBeZeW1OIFiAiJWMeqLDxKvLhK5gACBCgICVgX0Wo8UsWrJey6B9gTEq/ZmNuqOxatRJ+/cvQqIWPUnK17Vn4EdECBwXEDAOu7S7aciVrejdTACyQRei1ff9dLunW9/IdmiFiKQQUC8yoBqSQIBBESsekMQr+rZezIBApcFBKzLRt1dIWJ1N1IHIpBM4DZefZ14lUzVQjkExKscqtYkEEdAxCo/C/GqvLknEiCwTEDAWubVzdUiVjejdBACyQTEq2SUFsosIF5lBrY8gSACIla5QYhX5aw9iQCB9QIC1nq75u8UsZofoQMQSCYgXiWjtFBmAfEqM7DlCQQTELHyD0S8ym/sCQQIpBEQsNI4NruKiNXs6GycQDIB8SoZpYUyC4hXmYEtTyCogIiVbzDiVT5bKxMgkF5AwEpv2tyKIlZzI7NhAskExKtklBbKLCBeZQa2PIHgAiJW+gGJV+lNrUiAQF4BASuvbzOri1jNjMpGCSQTEK+SUVoos4B4lRnY8gQaERCx0g1KvEpnaSUCBMoJCFjlrMM/ScQKPyIbJJBMQLxKRmmhzALiVWZgyxNoTEDE2j4w8Wq7oRUIEKgjIGDVcQ/7VBEr7GhsjEAyAfEqGaWFMguIV5mBLU+gUQERa/3gruPVx3df8sb377/6U6+sX8WdBAgQqCMgYNVxD/1UESv0eGyOwCYB8WoTn5sLCohXBbE9ikCDAiLW8qE9ild/UbxabucOAgRiCAhYMeYQbhciVriR2BCBzQLi1WZCCxQSEK8KQXsMgcYFRKz5AxSv5lu5kgCBuAICVtzZVN+ZiFV9BDZAIJmAeJWM0kKZBcSrzMCWJ9CZgIh1eaDi1WUjVxAg0IaAgNXGnKrtUsSqRu/BBJIJiFfJKC2UWUC8ygxseQKdCohYpwcrXp228Q0BAu0JCFjtzaz4jkWs4uQeSCCZgHiVjNJCmQWu49Wn9le79+w//OLPZ36U5QkQ6FBAxHpyqOLVkyY+IUCgbQEBq+35Fdu9iFWM2oMIJBMQr5JRWiizwKN49U3iVWZoyxPoXEDEuh2weHVr4TcCBPoRELD6mWX2k4hY2Yk9gEAyAfEqGaWFMguIV5mBLU9gMAERa7cTrwZ76R2XwEACAtZAw05xVBErhaI1COQVEK/y+lo9nYB4lc7SSgQI3AqMHLHEq9v3wG8ECPQnIGD1N9PsJxKxshN7AIHVAuLVajo3FhYQrwqDexyBwQRei1gP/vFIxxavRpq2sxIYU0DAGnPum08tYm0mtACB5ALiVXJSC2YSEK8ywVqWAIE7Ak996IXv3+3HiFji1Z3R+4MAgU4FBKxOB1viWCJWCWXPIDBPQLya5+Sq+gLiVf0Z2AGBkQRGiFji1UhvtLMSGFtAwBp7/ptPL2JtJrQAgc0C4tVmQgsUEhCvCkF7DAECdwR6jlji1Z1R+4MAgc4FBKzOB1zieCJWCWXPIHBcQLw67uLTeALiVbyZ2BGBkQR6jFji1UhvsLMSIDAJCFjegyQCIlYSRosQWCQgXi3icnFFAfGqIr5HEyBwI9BTxBKvbsbqFwIEBhIQsAYadu6jili5ha1P4FZAvLq18FtsAfEq9nzsjsBoAj1ELPFqtLfWeQkQOAgIWAcJP5MIiFhJGC1C4KyAeHWWx5eBBMSrQMOwFQIEbgRajlji1c0Y/UKAwIACAtaAQ899ZBErt7D1RxYQr0aefltnF6/ampfdEhhNoMWIJV6N9pY6LwEC9wUErPsi/k4iIGIlYbQIgTsC4tUdDn8EFhCvAg/H1ggQuBFoKWKJVzdj8wsBAgMLCFgDDz/30UWs3MLWH0lAvBpp2m2fVbxqe352T2A0gRYilng12lvpvAQInBIQsE7J+DyJgIiVhNEigwuIV4O/AA0dX7xqaFi2SoDAjUDkiCVe3YzJLwQIENgJWF6C7AIiVnZiD+hYQLzqeLidHe1hvHrq6ffsP/ziz3d2NMchQGAAgYgRS7wa4MVzRAIEFgkIWIu4XLxWQMRaK+e+kQXEq5Gn39bZb+LVB57/hbZ2brcECBC4FYgUscSr27n4jQABAgcBAesg4Wd2ARErO7EHdCQgXnU0zM6PIl51PmDHIzCYQISIJV4N9tI5LgECswUErNlULkwhIGKlULRG7wLiVe8T7ud84lU/s3QSAgRuBWpGLPHqdg5+I0CAwH0BAeu+iL+zC4hY2Yk9oGEB8arh4Q22dfFqsIE7LoHBBGpELPFqsJfMcQkQWCwgYC0mc0MKARErhaI1ehMQr3qbaL/nEa/6na2TESBwK1AyYolXt+5+I0CAwCkBAeuUjM+zC4hY2Yk9oCEB8aqhYQ2+VfFq8BfA8QkMJlAiYolXg71UjkuAwGoBAWs1nRtTCIhYKRSt0bqAeNX6BMfZv3g1zqydlACBW4GcEethvHrjH3j//qs/9crtE/1GgAABAscEBKxjKj4rKiBiFeX2sGAC4lWwgdjOSQHx6iSNLwgQGEAgR8S6iVfP/+pnByB0RAIECGwWELA2E1oghYCIlULRGq0JiFetTWzc/YpX487eyQkQuBVIGbHEq1tXvxEgQGCugIA1V8p12QVErOzEHhBIQLwKNAxbOSsgXp3l8SUBAoMJpIhY4tVgL43jEiCQTEDASkZpoRQCIlYKRWtEFxCvok/I/g4C4tVBwk8CBAjcCmyJWOLVraPfCBAgsFRAwFoq5vrsAiJWdmIPqCggXlXE9+hFAuLVIi4XEyAwmMCaiCVeDfaSOC4BAskFBKzkpBZMISBipVC0RjQB8SraROznlIB4dUrG5wQIELgVWBKxxKtbN78RIEBgrYCAtVbOfdkFRKzsxB5QUOBhvPr+73xp986ve6HgYz2KwGIB8WoxmRsIEBhYYE7EEq8GfkEcnQCBpAICVlJOi6UWELFSi1qvhsBNvPr6t4tXNQbgmbMFxKvZVC4kQIDAjcC5iCVe3TD5hQABApsFBKzNhBbILSBi5Ra2fk4B8SqnrrVTCohXKTWtRYDAaALHIpZ4Ndpb4LwECOQWELByC1s/iYCIlYTRIqUF9g9+dz/9jw36l1el5T1voYB4tRDM5QQIEDgi8HjEEq+OAPmIAAECGwWu/3ur/yLQjsDV7l1v/fi3/71/8PLr3/JH29m1nY4q8Kaf/alf/8zzX//cqOd37jYEvuxLPv+73/j8575v/4Hnf6GNHdslAQIEYgtc/fu/9dd2b/mnP7p//lc/G3undkeAAIG2BASstuZlt9cCX/6mq6/cfWH3setf/zgQAgQIEFgvsN/vfvX6/3zjJ1/Z/+/1q7iTAAECBAgQIECAQH4BASu/sSdkEBCxMqBakgCBoQTEq6HG7bAECBAgQIAAgeYFBKzmRzjuAUSscWfv5AQIbBMQr7b5uZsAAQIECBAgQKC8gIBV3twTEwqIWAkxLUWAwBAC4tUQY3ZIAgQIECBAgEB3AgJWdyMd70Ai1ngzd2ICBNYJiFfr3NxFgAABAgQIECBQX0DAqj8DO0ggIGIlQLQEAQJdC4hXXY/X4QgQIECAAAEC3QsIWN2PeJwDiljjzNpJCRBYJiBeLfNyNQECBAgQIECAQDwBASveTOxog4CItQHPrQQIdCkgXnU5VociQIAAAQIECAwnIGANN/L+Dyxi9T9jJyRAYJ6AeDXPyVUECBAgQIAAAQLxBQSs+DOywxUCItYKNLcQINCVgHjV1TgdhgABAgQIECAwvICANfwr0C+AiNXvbJ2MAIHzAuLVeR/fEiBAgAABAgQItCcgYLU3MzteICBiLcByKQECXQiIV12M0SEIECBAgAABAgTuCQhY90D82Z+AiNXfTJ2IAIHjAuLVcRefEiBAgAABAgQItC8gYLU/QyeYISBizUByCQECTQuIV02Pz+YJECBAgAABAgQuCAhYF4B83Y+AiNXPLJ2EAIG7AuLVXQ9/ESBAgAABAgQI9CcgYPU3Uyc6IyBincHxFQECTQqIV02OzaYJECBAgAABAgQWCghYC8Fc3r6AiNX+DJ2AAIHXBMQrbwIBAgQIECBAgMAoAgLWKJN2zjsCItYdDn8QINCgwBSvdvvde15+Zf9Sg9u3ZQIECBAgQIAAAQKLBASsRVwu7klAxOppms5CYCwB8WqseTstAQIECBAgQIDA7vr/79Z/ERhYQMQaePiOTqBRAfGq0cHZNgECBAgQIECAwCaBB5vudjOBxgV+5TP7X9o9vXv39TF+pfGj2D4BAgMIiFcDDNkRCRAgQIAAAQIEjgr4F1hHWXw4msCjf4n1Y9fn/vLRzu68BAi0ISBetTEnuyRAgAABAgQIEMgjIGDlcbVqgwIiVoNDs2UCgwiIV4MM2jEJECBAgAABAgROCghYJ2l8MaLAW9509SevvrD72PXZ/UusEV8AZyYQUEC8CjgUWyJAgAABAgQIECguIGAVJ/fA6AIiVvQJ2R+BcQTEq3Fm7aQECBAgQIAAAQLnBQSs8z6+HVRAxBp08I5NIJCAeBVoGLZCgAABAgQIECBQXUDAqj4CG4gqIGJFnYx9EehfQLzqf8ZOSIAAAQIECBAgsExAwFrm5erBBESswQbuuAQCCIhXAYZgCwQIECBAgAABAuEEBKxwI7GhaAIiVrSJ2A+BfgXEq35n62QECBAgQIAAAQLbBASsbX7uHkRAxBpk0I5JoKKAeFUR36MJECBAgAABAgTCCwhY4Udkg1EERKwok7APAv0JiFf9zdSJCBAgQIAAAQIE0goIWGk9rda5gIjV+YAdj0AFAfGqArpHEiBAgAABAgQINCcgYDU3MhuuLSBi1Z6A5xPoR0C86meWTkKAAAECBAgQIJBXQMDK62v1TgVErE4H61gECgqIVwWxPYoAAQIECBAgQKB5AQGr+RE6QC0BEauWvOcSaF9AvGp/hk5AgAABAgQIECBQVkDAKuvtaZ0JiFidDdRxCBQQEK8KIHsEAQIECBAgQIBAdwICVncjdaDSAiJWaXHPI9CugHjV7uzsnAABAgQIECBAoK6AgFXX39M7ERCxOhmkYxDIKHAdr35tt99948uv7F/K+BhLEyBAgAABAgQIEOhSQMDqcqwOVUNAxKqh7pkE2hAQr9qYk10SIECAAAECBAjEFRCw4s7GzhoUELEaHJotE8gsIF5lBrY8AQIECBAgQIDAEAIC1hBjdsiSAiJWSW3PIhBbQLyKPR+7I0CAAAECBAgQaEdAwGpnVnbakICI1dCwbJVAJgHxKhOsZQkQIECAAAECBIYUELCGHLtDlxAQsUooewaBmALiVcy52BUBAgQIECBAgEC7AgJWu7Oz8wYERKwGhmSLBBILiFeJQS1HgAABAgQIECBA4FpAwPIaEMgsIGJlBrY8gUAC4lWgYdgKAQIECBAgQIBAVwICVlfjdJioAiJW1MnYF4F0AuJVOksrESBAgAABAgQIELgvIGDdF/E3gUwCIlYmWMsSCCAgXgUYgi0QIECAAAECBAh0LSBgdT1eh4smIGJFm4j9ENguIF5tN7QCAQIECBAgQIAAgUsCAtYlId8TSCwgYiUGtRyBigLiVUV8jyZAgAABAgQIEBhKQMAaatwOG0VAxIoyCfsgsF5AvFpv504CBAgQIECAAAECSwUErKVirieQSEDESgRpGQIVBMSrCugeSYAAAQIECBAgMLSAgDX0+B2+toCIVXsCnk9guYB4tdzMHQQIECBAgAABAgS2CghYWwXdT2CjgIi1EdDtBAoKiFcFsT2KAAECBAgQIECAwGMCAtZjGH4lUEtAxKol77kE5guIV/OtXEmAAAECBAgQIEAgtYCAlVrUegRWCohYK+HcRqCAgHhVANkjCBAgQIAAAQIECJwRELDO4PiKQGkBEau0uOcRuCwgXl02cgUBAgQIECBAgACB3AICVm5h6xNYKCBiLQRzOYGMAuJVRlxLEyBAgAABAgQIEFggIGAtwHIpgVICIlYpac8hcFpAvDpt4xsCBAgQIECAAAECpQUErNLinkdgpoCINRPKZQQyCIhXGVAtSYAAAQIECBAgQGCDgIC1Ac+tBHILiFi5ha1P4EkB8epJE58QIECAAAECBAgQqC0gYNWegOcTuCAgYl0A8jWBhALiVUJMSxEgQIAAAQIECBBIKCBgJcS0FIFcAiJWLlnrErgVEK9uLfxGgAABAgQIECBAIJqAgBVtIvZD4ISAiHUCxscEEgiIVwkQLUGAAAECBAgQIEAgo4CAlRHX0gRSC4hYqUWtR2C3E6+8BQQIECBAgAABAgTiCwhY8WdkhwTuCIhYdzj8QWCTgHi1ic/NBAgQIECAAAECBIoJCFjFqD2IQDoBESudpZXGFRCvxp29kxMgQIAAAQIECLQnIGC1NzM7JvBQQMTyIhBYLyBerbdzJwECBAgQIECAAIEaAgJWDXXPJJBIQMRKBGmZoQTEq6HG7bAECBAgQIAAAQKdCAhYnQzSMcYVELHGnb2TLxcQr5abuYMAAQIECBAgQIBABAEBK8IU7IHARgERayOg24cQEK+GGLNDEiBAgAABAgQIdCogYHU6WMcaT0DEGm/mTjxfQLyab+VKAgQIECBAgAABAhEFHkTclD0RILBc4OXP7P/v/undu6/v/JXld7uDQL8Cj+LVe15+Zf9Sv6d0MgIECBAgQIAAAQJ9C/gXWH3P1+kGFPAvsQYcuiOfFHgsXn3i5EW+IECAAAECBAgQIEAgvICAFX5ENkhguYCItdzMHf0JiFf9zdSJCBAgQIAAAQIExhUQsMadvZN3LiBidT5gxzsrIF6d5fElAQIECBAgQIAAgeYEBKzmRmbDBOYLiFjzrVzZj4B41c8snYQAAQIECBAgQIDAQUDAOkj4SaBTARGr08E61lEB8eooiw8JECBAgAABAgQINC8gYDU/QgcgcFlAxLps5Ir2BcSr9mfoBAQIECBAgAABAgROCQhYp2R8TqAzARGrs4E6zh0B8eoOhz8IECBAgAABAgQIdCcgYHU3UgcicFpAxDpt45t2BcSrdmdn5wQIECBAgAABAgTmCghYc6VcR6ATARGrk0E6xkMB8cqLQIAAAQIECBAgQGAMAQFrjDk7JYE7AiLWHQ5/NCogXjU6ONsmQIAAAQIECBAgsEJAwFqB5hYCPQiIWD1McdwziFfjzt7JCRAgQIAAAQIExhQQsMacu1MTeCggYnkRWhQQr1qcmj0TIECAAAECBAgQ2CbwYNvt7iZAoGWBlz+z/7/7p3fvvj7Dyy2fw97HERCvxpm1kxIgQIAAAQIECBB4XMC/wHpcw+8EBhV49C+xfuz6+G8ZlMCxGxAQrxoYki0SIECAAAECBAgQyCQgYGWCtSyB1gRErNYmNtZ+xaux5u20BAgQIECAAAECBO4LCFj3RfxNYGCBr3jT1Z949Qu7j10T+JdYA78H0Y4uXkWbiP0QIECAAAECBAgQKC8gYJU390QCoQVErNDjGW5z4tVwI3dgAgQIECBAgAABAkcFBKyjLD4kMLaAiDX2/KOcXryKMgn7IECAAAECBAgQIFBfQMCqPwM7IBBSQMQKOZZhNiVeDTNqByVAgAABAgQIECAwS0DAmsXkIgJjCohYY8699qnFq9oT8HwCBAgQIECAAAEC8QQErHgzsSMCoQRErFDj6H4z4lX3I3ZAAgQIECBAgAABAqsEBKxVbG4iMJaAiDXWvGudVryqJe+5BAgQIECAAAECBOILCFjxZ2SHBEIIiFghxtDtJsSrbkfrYAQIECBAgAABAgSSCAhYSRgtQmAMARFrjDmXPqV4VVrc8wgQIECAAAECBAi0JyBgtTczOyZQVUDEqsrf3cPFq+5G6kAECBAgQIAAAQIEsggIWFlYLUqgbwERq+/5ljqdeFVK2nMIECBAgAABAgQItC8gYLU/QycgUEVAxKrC3s1DxatuRukgBAgQIECAAAECBIoICFhFmD2EQJ8CIlafc819KvEqt7D1CRAgQIAAAQIECPQnIGD1N1MnIlBUQMQqyt38w8Sr5kfoAAQIECBAgAABAgSqCAhYVdg9lEBfAiJWX/PMdRrxKpesdQkQIECAAAECBAj0LyBg9T9jJyRQREDEKsLc7EPEq2ZHZ+MECBAgQIAAAQIEQggIWCHGYBME+hAQsfqYY+pTiFepRa1HgAABAgQIECBAYDwBAWu8mTsxgawCIlZW3uYWF6+aG5kNEyBAgAABAgQIEAgpIGCFHItNEWhbQMRqe36pdi9epZK0DgECBAgQIECAAAECApZ3gACBLAIiVhbWZhYVr5oZlY0SIECAAAECBAgQaEJAwGpiTDZJoE0BEavNuW3dtXi1VdD9BAgQIECAAAECBAjcFxCw7ov4mwCBpAIiVlLO8IuJV+FHZIMECBAgQIAAAQIEmhQQsJocm00TaEtAxGprXmt3K16tlXMfAQIECBAgQIAAAQKXBASsS0K+J0AgiYCIlYQx7CLiVdjR2BgBAgQIECBAgACBLgQErC7G6BAE2hAQsdqY09JdildLxVxPgAABAgQIECBAgMBSAQFrqZjrCRDYJCBibeILd7N4FW4kNkSAAAECBAgQIECgSwEBq8uxOhSB2AIiVuz5zN2deDVXynUECBAgQIAAAQIECGwVELC2CrqfAIFVAiLWKrYwN4lXYUZhIwQIECBAgAABAgSGEBCwhhizQxKIKSBixZzLpV2JV5eEfE+AAAECBAgQIECAQGoBASu1qPUIEFgkIGIt4qp/8X73qeuA9Y0vv7L/RP3N2AEBAgQIECBAgAABAqMICFijTNo5CQQWELECD+fxrYlXj2v4nQABAgQIECBAgACBggICVkFsjyJA4LSAiHXaJsQ34lWIMdgEAQIECBAgQIAAgVEFBKxRJ+/cBAIKiFgBhzJtSbwKOhjbIkCAAAECBAgQIDCOgIA1zqydlEATAiJWsDGJV8EGYjsECBAgQIAAAQIExhQQsMacu1MTCC0gYgUZj3gVZBC2QYAAAQIECBAgQICAgOUdIEAgpICIVXks4lXlAXg8AQIECBAgQIAAAQKPCwhYj2v4nQCBUAIiVqVxiFeV4D2WAAECBAgQIECAAIFTAgLWKRmfEyAQQkDEKjwG8aowuMcRIECAAAECBAgQIDBH4MGci1xDgACBWgKf/Mz+lx88vXv39fNfrrWHYZ57Ha9ev9+95+VX9p8Y5swOSoAAAQIECBAgQIBAEwL+BVYTY7JJAgT8S6zM78CjePVLr+x/IfOTLE+AAAECBAgQIECAAIHFAgLWYjI3ECBQS0DEyiQvXmWCtSwBAgQIECBAgAABAqkEBKxUktYhQKCIgIiVmFm8SgxqOQIECBAgQIAAAQIEcggIWDlUrUmAQFYBESsRr3iVCNIyBAgQIECAAAECBAjkFhCwcgtbnwCBLAIi1kZW8WojoNsJECBAgAABAgQIECgpIGCV1PYsAgSSCohYKznFq5VwbiNAgAABAgQIECBAoJaAgFVL3nMJEEgiIGItZBSvFoK5nAABAgQIECBAgACBCAICVoQp2AMBApsERKyZfOLVTCiXESBAgAABAgQIECAQTUDAijYR+yFAYJWAiHWBTby6AORrAgQIECBAgAABAgQiCwhYkadjbwQILBIQsU5wiVcnYHxMgAABAgQIECBAgEArAgJWK5OyTwIEZgmIWPeYxKt7IP4kQIAAAQIECBAgQKBFAQGrxanZMwECZwVErEc84tXZ98SXBAgQIECAAAECBAi0IyBgtTMrOyVAYIHA8BFLvFrwtriUAAECBAgQIECAAIHoAgJW9AnZHwECqwWGjVji1ep3xo0ECBAgQIAAAQIECMQUELBizsWuCBBIJDBcxBKvEr05liFAgAABAgQIECBAIJKAgBVpGvZCgEAWgWEilniV5f2xKAECBAgQIECAAAEC9QUErPozsAMCBAoIdB+xxKsCb5FHECBAgAABAgQIECBQS0DAqiXvuQQIFBfoNmKJV8XfJQ8kQIAAAQIECBAgQKCsgIBV1tvTCBCoLNBdxBKvKr9RHk+AAAECBAgQIECAQAkBAauEsmcQIBBKoJuIJV6Feq9shgABAgQIECBAgACBfAICVj5bKxMgEFig+YglXgV+u2yNAAECBAgQIECAAIHUAgJWalHrESDQjECzEUu8auYds1ECBAgQIECAAAECBNIICFhpHK1CgECjAs1FLPGq0TfNtgkQIECAAAECBAgQ2CIgYG3Rcy8BAl0ITBHr6gu7H7va7b4i9IHEq9DjsTkCBAgQIECAAAECBPIJPMi3tJUJECDQhsAnP7P/5Qev3737uuh/MuyOxauwo7ExAgQIECBAgAABAgTyC/gXWPmNPYEAgUYE3volV2999fO7j4X7l1jiVSNvkG0SIECAAAECBAgQIJBLQMDKJWtdAgSaFAgXscSrJt8jmyZAgAABAgQIECBAIK2AgJXW02oECHQgECZiiVcdvE2OQIAAAQIECBAgQIBACgEBK4WiNQgQ6E6gesQSr7p7pxyIAAECBAgQIECAAIH1AgLWejt3EiDQuUC1iCVedf5mOR4BAgQIECBAgAABAksFBKylYq4nQGAogeIRS7wa6v1yWAIECBAgQIAAAQIE5gkIWPOcXEWAwMACxSKWeDXwW+boBAgQIECAAAECBAicExCwzun4jgABAo8Eskcs8cq7RoAAAQIECBAgQIAAgZMCAtZJGl8QIEDgrkC2iCVe3YX2FwECBAgQIECAAAECBO4JCFj3QPxJgACBcwLJI5Z4dY7bdwQIECBAgAABAgQIEHgoIGB5EQgQILBQIFnEEq8WyrucAAECBAgQIECAAIFRBQSsUSfv3AQIbBLYHLHEq03+biZAgAABAgQIECBAYCwBAWuseTstAQIJBVZHLPEq4RQsRYAAAQIECBAgQIDACAIC1ghTdkYCBLIJLI5Y4lW2WViYAAECBAgQIECAAIF+BQSsfmfrZAQIFBKYHbHEq0IT8RgCBAgQIECAAAECBHoTELB6m6jzECBQReBixBKvqszFQwkQIECAAAECBAgQ6ENAwOpjjk5BgEAAgZMRS7wKMB1bIECAAAECBAgQIECgZQEBq+Xp2TsBAuEEnohY4lW4GdkQAQIECBAgQIAAAQIECBAgQGB4gSliveX3X/2/L3/26te+8o1XXzM8CAACBAgQIECAAAECBAgQIECAAIF4AlPEEq/izcWOCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJjCfx/6JJc9YV91YIAAAAASUVORK5CYII=\"></image>\n            </g>\n        </g>\n    </g>\n</svg>"
var _Assetsdd23384c8fb75cba24325da13db5e88f27edd970 = "{{template \"header\" \"Fault Index\"}}\n{{template \"menu\" .}}\n<div class=\".aligner-item\">\n    {{template \"table\" .}}\n</div>\n{{template \"footer\"}}\n"
var _Assets5505a97055e70f2214132a49de39b49ea42721ef = "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x02\x00\x00\x00\x02\x00\b\x06\x00\x00\x00\xf4x\xd4\xfa\x00\x00 \x00IDATx\x9c\xed\x9dy\x94\x1ceÙ·\xef\xc1]Q|U\x14\xdcP\x16C'd\xa7\x93\xccdB\b\x84\xa0\xa0`\x14\x905l\xb2\x88l\xa2\xa2\xaf\xbc\n\n*(*Û}O\b!d\x9f\xee\xec\xfb2[W\xf5\x84LE\x10\x97O\xc5\r\x95=\x132\xe9\x9e\xdf\xf7GgB\x92\xd9zy\xaa\xee\xaaz~\xd79\xd79\xfe#g\xd2]\xfd\xdcWwU=%B\b\xb1\x0e@\xf6\x81#\xcf\xc0\x956<%o\xd3\xfe{\b!\x84\x10\xe23p\xe4\xa7p\x05{\x98\x95_h\xff]\x84\x10B\b\xf1\x01dd\x12\x1c\xc9u\x1b\xfeo\x99GVN\xd0\xfe;\t!\x84\x10b\x00x\xb2/\\i\xefc\xf0\xef\xed6x\xb2\xaf\xf6\xdfM\b!\x84\x902\xc0\r\xb2\x0f\x1cYQ\xc2\xe0\xdfÓ\xac\ad\x1f\xed\u007f\a!\x84\x10B\x8a\x04\xae|\xbb\xec\xc1\xdf\xdd\xefi\xff{\b!\x84\x10\xd2\ah\x91\xe1pe\xbb\xc1\xe1_Ð\x1d\xc8JR\xfb\xdfG\b!\x84\x90\xdd\x00d\x9f\x12\xcf\xf3\x97k;\xc0\xdb\x06\t!\x84\x10u\xe0Ê\x00\x06\xff\u07bf\b\xcc\x06\xa4J\xfb\xdfN\b!\x84X\a2\xf2\xf5\xc0\a\u007f\xf7\v\x05/\xd5~\x1d\b!\x84\x10+@\x8b\x1c\fW\xb6\xa9\x0f\xff\xb7\xdc\x0eG\x0e\xd5~]\b!\x84\x90X\xb2s\xfb\xde\x17C0\xf0{;-\xf0on+L\b!\x84\x18\x04\x8eÜ¥>\xe0\x8b5+\xf7j\xbf^\x84\x10BH\xa4AV\xbe\fW\xf2\xeaC\xbd<O\xd1~\xfd\b!\x84\x90H\x81M\xf2Q\x04s[\x9f\xbf:\xb2\r\x9b\xe5cÚ¯'!\x84\x10\x12jp\x83ì¬\xfcA}p\x9b6+\u007f\xe4\xf5\x01\x84\x10BH\x0f\xc0\x95\x1f\xab\x0fj\xff\xfd\xb9\xf6\xebL\b!\x84\x84\x02\xb4\xc8\xd1p\xa5#\x04\xc39\x18\v\x8f$\x9e\xa8\xfd\xba\x13B\b!*\xc0\x93}\xe1\xc8V\xa5!\f4\x8e\x04\x1a\xaa\v\xff[\xe7oh\xe7c\x87\t!\x84X\x03 Upd\x83\xda7\xf0\x96\x8f\x02\x8b\xd7\x00i\xaf\xe0\xe2u@\xcb\x01\x9a\xbf\bdp\x03\x1f;L\b!$\xc6\xc0\x95+\xf4\x06\xedÛ\x15\xbfyk\xf0\xef\xed\x8a;\x00\xe7\x9dz!\xd0*\xdf\xd2~\u007f\b!\x84\x10\xa3\xc0\x95\xa1p\xe5M\xb5\xe1\xbanJ\xef\x83\u007fo\xd7^\xa8\xf9k@\aZe\xb8\xf6\xfbE\b!\x84TD\x80\x8f\xe9\xed\xd9\xe6O\x15?\xf8\xf7\xb6\xf9 \xbd\x10\xc8J;o\x1b$\x84\x10\x12I\x90\x95\xb9j\x034\xf3~`\xc9\xe2\xf2\x87\xff\xae\xeb\x03\x96\x02\x99\xfd4C \xa5\xfd>\x12B\b!E\x01W\xa6\xa8\rLW\x80U7V>\xf8\xf7v\xe5\xcf\x01\xa7J\xef\xdf\xe4\xca\x05\xda\xef+!\x84\x10\xd2#\xd8$\x9f\x85\xd6\xcf\xfd\x8e\x00\x1bN6?\xf8\xf7v\xfd)\x9a\xb7\rnCF\x0e\xd1~\x9f\t!\x84\x10\x11\t\xc1cz\x9b?\x01\xa4\xb3\xfe\x0f\xff]\xb6\x16\xae-\xd0\xfa\xf7\xf2\xb1Ã\x10B\xb4\x81+S\xd5\x06a\xe6}\xc0Ò§\x03\x1c\xfc{\xb9tn\xe1Z\x03\xad\u007f\u007fV\xee\xd7~\xff\t!\x84X\x06\\9iç¶:\xc3o\xf5\xf7\xf4\x06\xffÞ®\xbeN/\x02\\\xc9Ã\xafh\x1f\x0f\x84\x10Bb\x0e\x9e\x93\x8f\xc0\xd5Ü¾\xb7Z\u007f\xe0\xf7f\xc3Qz\xd7\a\xb8ÒM\xf2Q\xed\xe3\x83\x10BH\xcc\x00\xa4\nYÙ¢\xf6M\xb7\xe5\x00`Q\xa3\xfe\x90\xef\xcfEM@\xcb\xc7\xf5~\x11\xc8\xca\x1f\x01n+L\b!\xc4\x00p\xe4&\xb5\x81\xe6\xbc\x03X\xf6\xa8\xfe`/\xd5e\xd3\x00\xe7]z!\xe0\xc8/\xb4\x8f\x1bB\b!\x11\x05\xadR\v\xcd\xed{\xd7^\xa6?\xc8+uÍ\x9a\x11Ð\x8cL\xd0>\x8e\b!\x84D\x04l\x92\xf7i=\xa6\xb7\xd3\x11\xech\x18\xa0?\xb8M\xdb8D\xf3\xfa\x80\xad\xf8\xa7\xbcO\xfb\xb8\"\x84\x10\x12b\xe0\xc8\x12\xado\xac\xffZy \x8e\x9a\xf87\f\x1d\x93\xc7ks~\xab?\xb4M\xbbx5\xd0\xf21\xcd_\x04V\x03R\xa5}\x8c\x11B\b\t\x11p\xe5{Z\x83)\x97\xd9\a\x97^\xb0\x10\x89$vy\xe4\xd8\x1c^y:\x86\x11\x90\xf6\x80\xe5\xf7\x16\x1eM\xac\x15\x02Y\xb9N\xfbx#\x84\x10\xa2\fZe\x10\x1cÙ¦1\x88:\x1d\xc1\x93\xbf\xb9d\x8f\xc1\xbf\xbb\xc9\xda\x1c^\x9d\x1d\xd3\bH{\xc0\xba\xb34O\v\xbc\x89gd\xb0\xf6\xf1G\b!$`vnß«\xf6\x98\u07bf.\xf9l\xaf\x83\u007fw\x87\x8d\xc9\xe3\x8d8\x9e\x0e\xd8ÝO\xeb\xfd\x1a\xe0\xf0\xb1Ã\x10b\rpe\xba\xd6\xc0y}\xc3\xfb\xf1\xf9\x13\x9f+j\xf8w9\xbc&\x87?>\xfa;\xfdA\xed\xa7K\x16\xebn+\xec\xca,\xed\xe3\x92\x10B\x88O\xc0\x91K\xe0\xeam\xdf\xfb\x9doN/i\xf0\xef\xf1K@u\x1e\xcf=\xfc\xbc\xfe\xa0\xf6Û\xbfÒ\x80\xac\xe4\xe1\xc8\xe5\xda\xc7)!\x84\x10C\xc0\x95\x83\xa0\xb4}o\xa7#X|ß©e\x0f\xfe\xbd#\xe0_O>\xa7?\xa4\x83p\xfd\x17u\xb7\x15n\x92\xcfj\x1f\xb7\x84\x10B\xca\x04\x90}\xe0\xca_\xb4\xbeQ\xbe\xb0\xec \f\xad\xdefd\xf8w9tt\x0e/\xc5\xf5\xee\x80nf\x81\xe6Oj\xfe\"\xf0\"\xaf\x0f \x84\x90\x88\x01G\xee\xd4\x1a\x1c\xed\r\xef\xc1W\xbe\xe2\x18\x1d\xfc\xbb;\xa2&\x8f\xff\xcez6\x04\x03: \x97\xce\x012\xef\xd5\v\x01W\xee\xd1>\x9e\t!\x84\xf4\x03\\\xf9*\\\xe9\xd0\x1a\x167]{\x87o\x83\u007fwG\xd5\xe6\xf0J\x9co\x11\xec\xc9U?Ò\x80\x1dp\xe4k\xda\xc77!\x84\x90\xbd@F\xef1\xbd\x9d\x8e\xa0q\xc6Ñ\f\xfe\xdd=rl\x0e\xed\xf3B0\x98\x83\xb6a\x9c\xee\xf5\x01\xae\xec\xaf}\xbc\x13B\b\x11\x118Ò¬\xf5\xcd\xf0Å\ab\xd4Q/\x05>\xfcw\xbf0\xf0\xf5\xb9[\xf4\x87r\xd0.j\xd4\xdeVx\x13\xb7\x15&\x84\x10%\xe0Ê\xb5\x06@G\xf3;0\xe5\xacUj\x83\u007f\xef_\x02^\x98\x1e\xf3}\x02zs\xd9\xe3\x80\xf3N\xbd\x10p\xe5gÚ\x03B\b\xb1\x06\xb8r,\xb2:\x8f\xe9\xedt\x04\xb7_\xff\x13\xf5\xa1\xdfS\x04\xfc\xfe\x11\v\xf6\t\xe8\xcd\xd5\xdfÒ\x80\xed\xc8\xc8$\xed\xcf\x05!\x84\xc4\x16d\xe4\xbdP<\xcf\xffÜ\xc1ê¾/\x87\x8e\xc9\xe3%\x9b\xee\x0e\xe8\xc9Æ\xde\xf5\x01YÙM|\xec0!\x84\x18\x05\xae\xa4\xb4\xbe\xe1\xe5\x9b?\x84Ï\xf0\x17\xf5\x01_\x8cG\x8c\xce\xe3\xff=f\xe9\xe9\x80.\x17\xaf\x06Z>\xa2\xf9\x8b\xc02\xed\xcf\v!\x84D\x1e\xb4È·\x90\x95\xbc\xd6b\xfe\xe6\x92;0i\xd2v\xf5\xc1^\x8a#\xabs\xf8\xcb4\xcb# \xed\x01+\xee\x02\x9c}\xf4B\xc0\x91\xefj\u007f~\b!$r\xa0Y\x92Z\x8f\xe9\x85#\xc0\xba)\xe8X\xe8\xe1\xe4\x13\xcc\xee\xe4\x17\x94G\x8e\xb5p\x9f\x80\xde\\{\xa1\xeec\x87\x1d\x19\xa3\xfdy\"\x84\x90Ð£\xfd\x98^\xb4|\x1cH{\xc8\xd5{\x18{\xd4\x0e\xf5A^\x89#j\xf2xs~\b\x06pX\xd4\xdcVØv@\xf6\xd1\xfe|\x11BH(\x81#\x8f\xa9-Ð\xf7\x02KR@\xdaC\xc7\x02\x0f\x93OlW\x1f\xe0&\x1c^\x93\xc7\xebs,\xdc'\xa07\x97,\x022\xfbê+3\xb4?g\x84\x10\x12\x1a\xe0\xc8\xf9pe\x87Ú¢\xbc\xf2\xa7\xbb\x06\xc4\xf6\xf9[p\xcaI\xf1\x18\xfe]\x8e\xaa\xb5\xe9\x01BE\xba\xf2\x16\xcd\b\xc8\xc1\x91\x8b\xb4?w\x84\x10\xa2\x066\xc9\x00(\xdd\xd6\aG\x80\r'\xed1\x14\xda\xe7m\xc1\xb1\x13\xa3u\xc1_\xb1\x1e96\x87\u007f\xda\xf2(\xe1R\xdc\xf0U\xedm\x85\aj\u007f\x0e\t!$0\x00\xa9\x82+\xbfW\xfb\x06\xd6r\x00\x90v\xf7\x18\x04\xdb\xe6m\xc1\x91cs\xea\x83\xdaOGT\xe7\xf0\xaf'-\xdf'\xa0G\xddÂµ\x1fZ\xc7cV^\xc0\r\xbc>\x80\x10\x12s\x90\x95_\xa8-\xb4\xce;\x81\xa53\xba\r\x807\xe6n\xc1\x98\x88_\xf0W\xacC\xc6\xe4\xf1\xdb\a\u007f\x1f\x82\xa1\x1bB\x97>\x05dÞ£\x17\x02\x8eÜ¦\xfd\xf9$\x84\x10\xe3 +_\x86+\xdb\xd5\x16\xd7\xd5\xdf\xefq\xd1o\x9f\xb7\x05GM\xe8P\x1f\xccA:\xac:\x8fg\x1fb\x04\xf4\xea\xea\xffÓ\x80Â£\xacO\xd1\xfe\xbc\x12BH\xc5\xc0\x95\x8fC\xf3<\u007fCM\xaf\v\xfd\xb6\xf9[0\xfe\x18\xbb\x86\u007f\x97#jr\xf8\xf7S<\x1dÐ§\r\xb5z\xd7\a8ÒM\xf2I\xed\xcf/!\x84\x94\x05\\Ù \xf6M\xaa\xe5#\xc0\xa2\x8d\xbd.\xee\x1d\v=\x1c\x17\xd3\v\xfeJ\x89\x00+\x1f%\\\x8a\x8b\x1a\x80\x96\x8f\xea\xfd\"\xe0HF\xfbsL\b!E\x83\x8c\xfcHm\xc1t\x05X~\u007f\x9f\x8bz\xc7B\x0f\xa7\x9d\xbcU}\x00\x87\xc1#\xc7\xe6\xf0*w\f\xec\xdf\xe5\x0f\xe9n+\xec\xcaO\xb4?×\x10\xd2+h\x95\t\xaa\xdb\xf7\xae\xb9\xacß\x9cÃ¿\xbb\xa3\xc6\xe5\xf0\xda\x1cF@Q\xae\xb9Jw[\xe1\xac\x1c\xa7\xfd9'\x84\x90] +\x1fDV\xf1<\u007fÓ\xa2\x16\xefm\xf3\xb7X\xff\xb3\u007fo\x8e\x1c\x9b\xc3\xd6y<\x1dP\xb4\x8d\xc3u\xf7\x0f\xf0\xe4CÚ{B\x88\xe5\xc0\x95YJ\x8b \x90\xd9\x0fX\xbc\xbc\xa8\x05\xbb}\x9e\xbd\x17\xfc\x15ë<\xfe\xc1Í\x8aw\xf1J\xa0\xe5CZ\x11\x00\xb82_\xfb\xf3O\b\xb1\x10\xb8r%\\É©-~+n+z\xa1~c\xae}\xb7\xfa\x95\xebÈ\x1c~\xcb[\x04KsÅz\x11PxT\xf65\xda\xeb\x01!\xc4\x02\x90\x95aÐ¼\xado\xfd\xd7JZ\x9c\xb7\xcdß\xea\xf1vl\xf2c\xcaac\xf2x\xeeaF@É®;K\xf7\xb4\xc032R{} \x84\xc4\x10\xfcI\xde\rG^Q\xfb\xa6\xd3|H\xc9\vr\xbb\x05\xdb\xfb\xfa\xe5\xe0\xd1y\xbc4\x8b\x17\x06\x96e\xd3az\xbf\b8\xb2\r\u007f\x95\xf7h\xaf\x17\x84\x90\x98\x00W\xee\xd1[\xd0\xde\x05,\x9d_\xf2\"\xbc}~|\x1f\xec\x13\x94Ã«s\xf8\xc7\f^\x13P\x96K\xeau\xb7\x15\xce\xcaC\xda\xeb\x06!$\xc2\xc0\x95)\xd0Ü¾w\xd5Me-\xbe\x1d\v=\x9c\x1a\xb3G\xfajy\xe4X>J\xb8\"W\xfe\\/\x02\n\xdb\n_\xa0\xbd\x8e\x10B\"\x04\x1c9\x14\x9a\xe7\xf97N*{\xc1\xcd\xd5{\x98|\"\x87\xbfI\x93\xb59\xbc1\x87\xb7\bV\xe4\x86\x13u\xaf\x0fh\x95\xcfi\xaf+\x84\x90\x90\x03G\xfb1\xbd\xe5/\xb2;\x16z\xa8\xb5\xe4\xa9~A;\xac:\x8f7\xe7+\fÎ¸Ù¬\xf8\xd8aW\xfe\nH\x95\xf6\x1aC\b\t\x19\xc8\xc8\xcdj\v\x93\xb3\x0f\xb0ì\x16\xd67\xe7o\xc1\xc9'nS\x1f\x94qv\xe4\xd8\x1c^\xe6\xe9\x80\xca]6\x13pÞ®\x19\x02\xbf\xd2^o\b!!\x00-r\x02\\ySm1ZsM\xc5\vj\xfb\xbc-8\xfe\xf87\xd5\a\xa4\r\x1eY\x9b\xc3_\xa6\xfdN\u007f\x88\xc6\xc1\xd5\xd7jF\xc0v\xb8r\x92\xf6\xfaC\bQ\x00\x199\x10\xaa\xe7\xf9\xab\x8d,\xa2\xdb\xe6oA5\u007f\xf6\x0f\xd4\x11\xd59\xbc0\x9dw\a\x18s\xa3\xe2c\x87\v\xd7\a|B{=\"\x84\x04\x04\\Ù¨\xf6\xcd#\xf3?@\xda1\xb2p\xb6\xcfÛ\x11\xbc\xcf_\xc5!\xa3\xf3\xf8\x17\xb7\r6\xa8Sx\x84\xb5\xd6\xe7\xd2\x11G{]\"\x84\xf8\b\x1c\xb9\x0e\x9a\xdb\xf7.\xbf\xcf\u0602\xd9>\x8f\xdb\xfbj;tL\x1e\xbf{\xf8\xf9\x10\f\xcf\x18\xb9\xfcA\xbd\b\xc8J\x1e\x8eÜ \xbdN\x11B\f\x82\xac\x8c\x85+\xedJ\xdf,\x80u_\a\xd2m\xc6\x16\xc9\xed\v<|\x81\xe7\xfcC\xe1È±9\xfc\xed\t\xfe\x12`Üµ\x97j\x9e\x16\xd8\x06W\xc6k\xaf[\x84\x90\n@V>\bG^V\xfbF\xd1X\xdcczK\xb1c\xa1\x87\xe3\x8e\xe3\xf0\x0f\x93#k\xf8(a\xdfl\x1c\xa6\x17\x02\x8e\xb4c#\x1f;LH\xe4\x80+\v\xd4\x06\u007f\xe6\xbd\xc0\xa2\xf5\xc6\x17\xc3\x1d\v=L\x9a\xc8\xe1\x1fF\x87U\xe7\xb1u.#\xc0\x17\x17m\x002\xef\xd7\xfa5\x00pe\xb1\xf6zF\b)\x02\xb8r)\n[\x80\xea,\x16+\u007f\xe9\xcb\"Ø±\x80\xdb\xfb\x86\xddQ\xe3rxu6\xf7\t\xf0Í\xbfÑ\x80\x1dp\xe4r\xed\xf5\x8d\x10\xd2\x03pe(\x1c\xc5\xf3\xfc\xebO\xf1m\xe1Û¾\xc0\xe3&?\x111Y\x9b\xc3+\xdc,\xc8_×\xa1{\xdb`FFh\xafw\x84\x10\x11\x81'\xefDV\xfe\xaa\xf6Í \xf9 _\x17\xbb\xed\v<\x8c\x19\xc7\xfb\xfc\xa3\xe4\xb0\xea<^\x9f\xc3\b\xf0\xdd\xe6\x835\u007f\x11x\x11\xab\xe4\xdd\xda\xeb\x1f!Ö\x8c<\xaa\xb6\x008\xef\x00\x96,\xf6u\x81k\x9f\xb7\x055\xdc\xe4'\x92\x0e\x1d\x93\xc7?f<\xab?$\xe3\xeeâ¥\xf3n\xcd\x10xB{\x1d$\xc4*\xd0*\xa7A\xf51\xbd?\xf2}ak\x9f\xb7\x05\xb5G\xf3>\xff(;\xbc:\x8f\xe7\xb8O@0\xae\xfa\x89^\x048\xd2\x01G\xce\xd2^\x17\t\x895xF\x0e\x86\xa3\xb9}\xefq\x81,f\xdb\x17l\xc18n\xf2\x13\v\x87U\xe7\xf9\xec\x80 \xdd\xf8y\xcd\xeb\x03\xb6\"+\x87i\xaf\x93\x84\xc4\x0e8\xb2E\xad\xf0[>\x12\xd8\x02\xb6c\xa1Ç\xfdc\xe6\xb0\xea<\xde\xe0-\x82\xc1\xda\xf21\xcd_\x04\xfe\xa0\xbd^\x12\x12\v\xe0Ê­p\xa5S\xedÃ¼\xf4\xa9\xc0\x16\xad\xed\v<L\xe2&?\xb1t\xf8\x98\x1c^\xe5\xdd\x01\xc1\xbatv\xe1Q\xdbZk\x87+\xb7k\xaf\x9f\x84D\x12\xb4\xca\xf1pd\x9bR\xc1\x03k\xae\x0et\xb1\xeaX\xe8\xe1\xab_\xe2}\xfeq6Y\xcb\bPq\xf5w4O\v\xbc\x89\xac\x9c\xa8\xbd\x9e\x12\x12\t\xb0I>\n\xcd\xc7\xf46&\x03_\xa0:\x16z\xf8\xe2\xe7y\x9f\xbf\r\x1eY\x9b\xe3\xe9\x00-\x1b\xc7\xe8\x85@V\xb6\u0093\x03\xb4\xd7WBB\v\\Y\xa3T\xe9@\xe6\x030\xf5\x98\xdeR\x87\xffx^\xedo\x95Ãª\xf3h\x9f\xdb\xf3\xf1@\xfd\xd6\x01Z\xfeG\xeb\xd7\x00\xc0\x91F\xedu\x96\x90P\x81\xac\xdc\x00\xd5\xc7\xf4>\xa4\xb2\x18\xbd9\u007f\v\x1f\xecc\xa9#j\xf2xi\x16\xf7\tPsÙ£z\x11\xe0J\x1eY\xb9I{\xdd%D\x15d\xa5\x06Z?\xf7\xbb\x02\xac\xbb@m\x01zs\xfe\x16L8f\xbb\xfa \xa2z&\xf9(a}\xd7^\xac\x19\x02\xed\xd8$\xe3\xb4\xd7aB\x02\x05\xcf\xca\xfb\xe1Êj\x1f\xbc\xa6\x81\xca\vO\x1bv,\xf4\xd0>\xd7n\xb7.\xf9\xb9\xfaß \xed\xf6\xa9Ë\x19\x1b\xf4\a\xa1\xed6\r\xd6\v\x01G^EF\xf6\xd3^\x97\t\xf1\x1d\xb8\xf2\x94\xde\a\xed\xdd\xc0\xe2\xd5\xea\xc3\x1f\xa96\xfd\x05O\xfb5h:T\xf5\x17\x98\xd0X\x97\x02\x06\x1d\vL[\xab\xff\xb7\xd8\xee\xe2\xb5@\xe6}z!\x90\x95\xb9\xda\xeb3!\xbe\x80\x8c\\\x05Gv\xa8}\xb8VÜ¡\xbf\xc0p\xf8\x03\xe9\xcd@S\xa2\xf0\x9e0\x00\n\x010`<0h\"\xf0\xd8\x1a\xfd\xbf\x87\x02+\xa6\xeaE@\xe1\xb1\xc3\xdf\xd5^\xaf\t1\x026K\x02\x9a\xb7\xf5m8I\u007fAI{\x85\xc1o\xfd\xf0o\x03\x1ak\xdfz\u007f\x18\x00o\x05\xc0\x80\xf1\xc0\x90I\xc0SM\xfa\u007f\x13-\xb8~\xb2\xeec\x877\xc9\x11\xda\xeb7!e\x81\x8c\xbc\x03Y\xf9\xa3ZI7\u007fZ\u007f\x01\xe9\xd2\xfa\xc1\xef\x01\xa9\xcd@c\xf5\x9e\xef\x11\x03`\xcf\x00\xe8\xfa%`\x8e\xab\xffwÑ·l\xfe\xac\xe6/\x02\u007fCZÞ¥\xbd\x9e\x13R4\xc8Ê½\x8a\x1f\x18`I\xbd\xfe\xa2\xd1e\xaa\rH\x85\xe0\xefP}\r6\x03\x8d\xa3\xbb\xbfO\f\x80\xee\x010`|\u1680\xa7[\xf4\xff6\xfa\x96KÒ\xf36\xbd5Í\x87\xb5\xd7uB\xfa\x04\xaeL\x81+o\xaa}HV\xfdL\u007f\xa1\xd8]~\xf3\aÒ\x81\x8d\x93z~\xbf\x18\x00=\a@\xd7é§\x9b\xf5\xff>\xba\xa7+o\x01\xdc*\xad\x10ØMr\xa1\xf6:O\xc8\x1e\xc0\x95\x83t\x1f\xd3;A\u007fa\xe8&\xcf\xf9#\xdd\x06l8\xa1\xf7\xf7\x8e\x01\xd0{\x00\f\x18\x0f\f9\x9e\xbf\x04\x84Õ\xc7\xea>vx\x93|V{\xdd'D\xe0H\x8bÒ\x00h\xf9\x90\xfeBÐ«\xb6\x0f\u007f\x0fh\x1e\xde\xf7\xfb\xc7\x00\xe8;\x00v]\x13\x10\xfc\x16Õ´H[\xf6\u05ca\x00\xc0\x91g\xb4\xd7\u007fb)p\xe4\x17p%\xafv\xf0/\x9b\xa9\xff\xe1\xefM\xeb\xbf\xf9o\x06\x9a\x86\xf4\xff\x1e2\x00\xfa\x0f\x80\x01\xe3\x81#\x8e\x03\x1e^\xa1\xff\xb7Ò]:K/\x02\\\xe9\x84#\xbfÑ\a\xc4\x12\xd0\"'\xe8=\xa6\xb7\nX\xf3\x1d\x84\xfa\xdb5\x87?\xd0txq\xef'\x03\xa0\xb8\x00\x180\x1e8b\"\xf0\xc0R\xfd\xbf\x97\xf6b\x1b\xb0\xfa\xfb\x855J'\x04\xdeD\x8b\x9c\xac=\x1fHL\x81+\xfbÃW\xd4J\xb7\xf1\xc8\x10|\xc8\xfbY\x00\xac\x1f\xfemom\xf2\xc3\x00(ÎºTq\x01\xd0u:`\xc6F\xfd\xbf\x99\xf6mC\x0fw\xbc\x04\xf6%IÚ±Y>\xa6=/H\x8c\x80#\x8b\xd5\x0e\xe8\xcc{\x80E!\xbf\x1a\xbak\x93\x1f\xab\x03\xa0\xad\xf0\x8c\x85R\xde[\x06@i\x010`<0\xf0Xn\x16\x14\t3@f_\xbd\x10\xc8\xcaJ\xed\xb9A\"\x0e\\\xf9!\\\xc5\xed{\x97?\x18\x82\x0fr?Z=\xf4\xbb^\x83\xcd@\xe3\x98\xd2\xdf_\x06@\xe9\x01\xd0uM\xc0\xccF\xfd\xbf\x9d\xf6\xef\xf2G\xf4\"\xc0\x91\x1c2\xf2\x13\xed9B\"\x06Z\xa5\x16\x8e\xb4+\x1d\xb4\xc0Ú\xf4?\xb8\xc5h\xfd\xb7~\xaf0\xfc7\xf6q\xab\x1f\x03\xa0o\xebR\xa5\a\xc0\x80\xf1\xc0\xd0\xe3\xb9O@\x94\\\xf3\r\xbd\xdb\x06\x1dÙ\xac\x1c\xad=WH\xc8\xc1zy?\\\xf9\x93Z\xb16\x1d\xae\xffA-V\xdb\a\u007f\xdaC\xe1>\xff/\x96\xff~3\x00\xca\x0f\x80\xaeÍ\xe6e\xf5\xff\r\xb4x\x1b\aé¬­\x05\xff\x86F\xf9\x80\xf6\x9c!!\x04\xae\xccP;0\x9d\xb7\x01\x8bW\xea\u007f8\x8b\xb6\r\xa1\xbe\x13!\xa8× \xa7\xed}\x19\x00\xa5Y\x97*?\x00v\xed\x13\x90\xd1\xffw\xd0\xe2]\xbc\x1apÞ©\x19\x02\xb3\xb5\xe7\r\t\th\x95\x8b\xe1\xcav\xb5\x83qÅ¯\xf5?\x90\xa5j\xfd\xb7\xff\xcd@\xc31\x95\xbf\xf7\f\x80\xca\x03`\xc0x`\xf0\xf1\xc0\xe3k\xf5\xff-\xb44WÜ®\x19\x01\x1dp\xe4r\xed\xf9C\x94@V\x86\xc1U<Ï¿\xfek\xfa\x1f\xc0r\xe4\xf07w\x9b\x13\x03\xc0L\x00\f\x18\x0f\f\x9e\x04<\xb4\\\xff\xdfCKwÝ\xba\x8f\x1d~FFj\xcf#\x12\x10\xc8\xc8;\xe0\xc8f\xb5\xf2l9P\xff\x03W\xae\xd6\x0f\xff6\xa0\xe90s\xc7\x02\x03\xc0\\\x00\xec\xbaE\x90\x17\x06F\xd6\xe6OjE\x00\xe0\xcas\xc8\xc8;\xb4\xe7\x13\xf1\x11\xb8r\x0f\xb2\x8a\xdb\xf7.Y\xa0\xff!+×\xed\xe7\xfd7\x03Í6{<0\x00\xcc\x06\xc0\x80\xf1@b\x02\xf0h\x94\xae\xa7\xa1{\xb8$\xa5\x19\x01\x9dp\xe5A\xed9E\f\x03GN\x83\xd6cz\x1d\x01V\xfd\x18\x91\x1d\x9e\xbc\xd5\x0fHo\x06\x1aG\x9a?6\x18\x00\xe6\x03`\xc0\xf8\xc2>\x01\x8f\xad\xd6\xff\xb7\xd1\xf2]y\x93\xe6\xb6\xc2\xdb\xe1\xc8Y\xdas\x8bT\b<9\x14\xae\xbc\xaaV\x94\x1b\xbe\xa0\xffA\xaaD\xeb\a\xff\xce\xd7`\xe3$\u007f\x8e\x0f\x06\x80?\x010`\xe7-\x82\xb3x: \xf2n\xf8\xa2\xee\xf5\x01\x199\\{\x8e\x912\x80#\x8dj\x83?\xb3\xaf\xfe\a\xa7b9\xfc\x91n\x03\x1a&\xfaw\x9c0\x00\xfc\v\x80\xae_\x02\xe6s\x9f\x80X\x98\xd9O+\x02\x00G\\\xedyF\x8a\x04\x8e\xdc\x04Grj\aË²\xe9\xfa\x1f\x96J\xe57\u007f \xdd\x06l\x1c\xef\xef\xb1\xc2\x00\xf07\x00\xba\"`6\xf7\t\x88\x85\xcbf\xe8E\x80+y8r\x8b\xf6|#\xbd\x80V9\x1e\xae\xd2cz]\x01\xd6|[\xff\x03bL\xdb\x03\xa0\r\xd8p\x92\xff\xc7\f\x03\xc0\xff\x00\x180\x1e\x18\xfay>@(N\xae\xfe\x1e\xe0\xaa]\x1f\xf0&Z\xe5\x8b\xda\xf3\x8e\xec\x04\x9e\x1c\x00G\xfe\xa16\xf8\x1bj\xf4?\x10&\xb5\xfeÛ¿\x8f\xe7\xfc\x19\x00Ý­K\xf9\x1f\x00]\xd7\x04<\xb1A\xff\xdfK\xcd\xd90N+\x02\x00W\xfe\x8bV\xf9\x84\xf6\xfc\xb3\x1a\xb8\x92V;\x00\x9cw\x02\x8bb\xf6D2\xeb\xaf\xf8o\x03\x1aF\x04w\f1\x00\x82\v\x80\xae\xd3\x013\x18\x01\xb1rQ3\x90y\xaff\b,×\x83Ö\x8c|\a\xaet\xa8\xbd\xe9\xcb\xef\xd5?\xf0\x8dk\xf3\xe0\xf7\x80\xf43@\xd3\xc1\xc1^q\xcc\x00\b6\x00\x06\x8c\a\x06\x1e\x03Ü¿D\xff\xdfMÍº\xfc~\xcd\b\xd8\x01G~\xa0=\x17c\x0f\xb2R\x03\xcd\xed{\xd7^\xa8\u007f\xa0\xfb\xa1\xd5\xdf\xfa= \xbd\x19h\x1a\x10\xfc1\xc5\x00\b>\x00\x06\x8c/<@\xe8\x01F@,]{\x89\xeem\x83\xae\x1c\xa5='c\a\xd6\xc9\xff +\u007fP+\xbc\xc6\xc1\xfa\a\xb6/\xda\xfe\x93\xff\xce× \xf1H\x9d\xe3\x8a\x01\xa0\x13\x00]\xa7\x03f6\xe8\xff\xfb\xa9?6\x0eÓ\x00\xc0\x95\xbfb\xa3|H{n\xc6\x02\xb8\xf2(\n[4ê¼\x8b\x97\xea\x1f\xcc~h\xfd\xe0\xf7P8\xe7_\xab\xb7P0\x00\xf4\x02`\xc0x`\xf0q|\x94p\x9c]\xbc\xa2\xf0\xa8u\xbd\x10xB{~F\x16\xb8r!4\x1fÓ»\xf2W\xfa\a\xb0oÚ¾\xaf\xbf\a\xa46\x03\x1b?\xaf\xb980\x00Òn\x00\f\x18\x0f\f9\x1ex\xbaE\xffu\xa0\xfe\xb9\xf26\xa8\xdd6\xe8H\a\\\xb9T{\x9eF\x06\xb82\x10\x8e\xe6cz\xbf\xa2\u007f\xc0\xfa\xaaå¿\xeb5X?Yw\xf83\x00\nÖ¥t\x03`\xc0\xf8\xc2>\x01\xdc,(\xfe\xae?U\xef\xfa\x00G\xda\xe1\xc8\x10\xed\xf9\x1aZ\x90\x91\xf7\u0095g\xd4\x16\xe3\xe6\xcf\xe8\x1f\xa0\xbe\xcb\xe1_\xb8\xcf_\xf9\x9b?\x03\xe0-\xebR\xfa\x010`<0x\x120\xd7\xd5\u007f=\xa8\xff6\x1d\xaa\xf7\x99w\xe4Yl\x92\xf7i\xcf\xdb\xd0\x01W\x9eS{S\x96\xce\xd5?(\x03\xd1\xf6\x00P>\xe7\xcf\x00\xe8n]J\u007f\xf8\uf280\xe3\x80'\xd6\xeb\xbf&\xd4\u007f\x97\xcc\u05cc\x80\xbfk\xcf\xdb\xd0\x11x\x008U\xc0\xaa\xeba\xcdP\xb4\xfe\xa2\xbf\xcd@\x83\xd2\xd5\xfe\f\x80Þ­K\xe9\x0f\xfe\xdd=\xe28\xee\x13`\x8dm\xc0\xaa\x1b\x83\u007f\xec0\x03\xa0;\x81\x06\xc0Æ!8\xf8\x02>\xd0\xd5\xff\x06M7\x03\x8d\n\xf7\xf93\x00\xfa\xb7.\xa5?\xf4\xf7vÐ±\xc0\x03\xcb\xf4_\x1b\x1a\x9c\x1b\x02<-\xc8\x00\xe8N \x01\xd0\xf2a Ýª\u007f\xb0\x05\xa9\xf5\xdf\xfc\xdb\n;\xfci\x0f{\x06@\xcfÖ¥\xf4\a~O\x0e<\x06\x98\xc5\a\b\xd9\xe53@\xcbG\x19\x00\x1a\xf8\x1e\x00Ë¦\x85\xe0\x00\vX\xee\xed\x0f4\f\xd7\x1f\xf4\f\x80Þ­K\xe9\x0f\xfb^\u007f\t\x98\bL\xe75\x01Ö¹\xec\t\x06@\xd0\xf8\x12\x00\x8e\x00k.\xd7?\xa0\x82\xd6\ua87f\xdbk\x10\xd4S\xfd\x18\x00\xe5[\x97\xd2\x1f\xf4}9\xe4x>J\xd8V\xd7\\\xed\xcfm\x83\f\x80\xee\x18\x0f\x80\x861\xfa\a\x90\x8a\xdc\xe4\a\xa9\xcd\xc0\x86\x93\xf5\a<\x03\xa0\u007f\xebR\xfaC\xbe?\x87\x1e\xcf\x1d\x03mv\xe3X\x06\x80\xdf\x18\r\x80E\xb6~X-\x1f\xfc\xbb>\xb0\xe3\xf5\x87;\x03\xa08\xebR\xfa\x03\xbe\xa8\xd3\x01\xc7\x02\xf3-\xbb~\x88\xee\xa6kn[a\x06@w\x8c\x04\xc0\xf2{Bp\xa0(É\xfdw\xfe\xec\u007f\x9c\xfe`g\x00\x14o]J\u007f\xb8\x17}:`\x12/\f\xb4\xdd\xe5\xf71\x00\xfc\xa0\xe2\x00H;\xfa\a\x87\xaa\xb6\a\xc0\xe6\xf0\x9f\xf3g\x00t\xb7.\xa5?\xd8K\x8a\x80\xe3\x81\xc7V\xeb\xbfnTQ\x97\x01`\x1a\x06@\x05Z\xff\xed_\xf1\x91\xbe\f\x80Ê¬K\xe9\x0f\xf5R=\xe28`\xda\x1a\xfd\u05ce*\xc9\x000\x0e\x03\xa0LS\xb6_\xf4\xd7\x064}F\xef!\x1f\f\x80Ê¬K\xe9\x0f\xf4rL\x1c\x03\xccØ¨\xff\xfaQ\x05\x19\x00\xc6a\x00\x94\xaa\xed\xf7\xf8{\b\xed\x0e\u007f\f\x80\xe2\xadK\xe9\x0f\xf3r\x1dt,\xf0 w\f\xb4O\x06\x80q\x18\x00\xa5j\xfb\xf0o\x03\x1a\xaa\xf5\x878\x03\xa02\xebR\xfa\x83\xbc\x12\x87L\x02\xa6\xad\xd3\u007f\x1di\x802\x00\x8c\xc3\x00(V\xdb\u007f\xf2\xf7v^\xed?Q\u007f\x803\x00*\xb7.\xa5?\xc4+u\xf0q|\x94\xb0U2\x00\x8c\xc3\x00(\u0094\a\x0e\xff\xcd@cÄ¿\xf93\x00\u07b2.\xa5?\xc0M8h\"0×5\x88\x82\x01\xe0\x03\f\x80~\xe4\xf0ß¹\xc3\xdfI\xfa\x83\x9b\x01`Îº\x94\xfe\xf06\xe5\xd0ã§[\xf4_S\xea\xb3\f\x00\xe30\x00\xfa\x90\xc3\u007f\xe7\xf0\xff\x92\xfe\xd0f\x00\x98\xb5.\xa5?\xb8MG\x00\x9f\x1d\x10s\x19\x00\xc6a\x00\xf4&\xcf\xf9\x17.\xf83\xbc\x1fw\x18d\x00\xc4/\x00\x06\x8c\a\x8e\x98\bÌ\xebzD\x19\x00>\xc0\x00\xe8E>\xd2\x17h\x1a\xa4?\xac\x19\x00\xfeX\x97\xd2\x1f\xd8~8\xf0X`:\xef\x0e\x88\xa7\f\x00\xe30\x00\xf6\xd6\xf6\xc1\xef\xa1p\x9f\xff\xc0hn\xf2\xc3\x00(Îº\x94\xfe\xb0\xf6\xf3\x97\x80\a\x96\xea\xbf\xc6\u0530\f\x00\xe30\x00v\x97?\xfb\xef\x1a\xfe\xdaC\x9a\x01\xe0\xafu)\xfdA\xedw\x04\xf0\xd9\x011\x93\x01`\x1c\x06\xc0n.\n\xc1ß m\xc30\xfd\x01\xcd\x00\xf0ßº\x94\xfe\x90\x0e\"\x02f\xdb\xfa\x88\xf28\xca\x000\x0e\x03\xc0\xe3\xd5\xfei\xafp\xda#\x8a\x0f\xf6a\x00\x94g]J\u007f@\a\x15\x01\xb3\x9a\xf5_oj@\x06\x80q\xac\x0f\x00\x0e\xffx\xde\xea\xc7\x00\xe8Ûº\x94\xfep\x0eÊ¡\xc73\x02b!\x03\xc08V\a\x80\xf5O\xf4\xf3\n\xc3\u007f\xe3\x17\xf4\x872\x03 X\xebR\xfa\x839H\x87L\xe2-\x82\x91\x97\x01`\x1ck\x03 \xb5S\xed\xbfC\xf55\xd8\x1c\xcf\xfb\xfc\x19\x00\xfd[\x97\xd2\x1f\xcaA\xcb}\x02\".\x03\xc08\xf6\x06\x80\xed\xdf\xfcÛ\x86Z\xfda\xcc\x00Ð±.\xa5?\x905\x1c|\x1cw\f\x8c\xac\f\x00\xe3X\x19\x00\xb6\x0f\xfft\x1b\xb0q\xbc\xfe f\x00\xe8Y\x97\xd2\x1f\xc6Z\x0e9\x1e\x98\xb6V\xff=\xa0%\xca\x000\x8eU\x01\x90j\xe3\xcf\xfe\xe96\xa01\xa6;\xfc1\x00\x8a\xb7.\xa5?\x885=b\"0c\x83\xfe\xfb@K\x90\x01`\x1c\xab\x02à¡\xc0\x91'\x03#m\xf6\x8b\xc0\x91\x93\xacv\xcdQ7\xe3\xe8\xa3;\xac\xf6\x98\xa3\xb6\xe1\xa4\xea\x17\xad6\xfb\x85\xfb\xf0\xcf'\x9f\xd3_\x97h\x912\x00\x8ccU\x00\xa4=\xe0\xe7ÓÃ\xd6\xff\x06B\xd5\\6\xfc&$\x92\xa0\xd6Ú\xfa\x9a{\xb0u\xd8)\x18^\x9d\xc3ß`\x04DC\x06\x80q\xac\v\x80\xb4\a\xdc\xf4(#\xc0b\x19\x00v[_s\x0f0`<\xb6\x0e;\x05\x89$0\xaav\a^\x9d\xfd[\xfdu\x89\xf6#\x03\xc08V\x06@\xda\x03~>]}\x10Q\x06\x00\r\xd2N,\xab\xbd{\xd7q\xd0\x15\x00\x89$0\xbc&\x8fms=\xfdu\x89\xf6!\x03\xc08\xd6\x06@\xda\x03n\x9b\xa3>\x8c(\x03\x80\x06\xe3Ê£\xa6\xa2s\xb7\xe3`\xf7\x00H$\x81a\xd5y\xbc1w\x8b\xfe\xbaD{\x91\x01`\x1c\xab\x03 \xed\x01\xbf\x99\xad>\x90(\x03\x80\xfak\xfd\xd8{\xbb\x1d\a{\a@\"\t\x8c\x1a\x97\xc3k\xb3\x19\x01\xe1\x94\x01`\x1c\xeb\x03 \xed\x01\xb7\xceT\x1fJ\x94\x01@\xfdq\xf9\xb8\xbb{<\x0ez\n\x80D\x12\x18=.\x87\xd7\xe70\x02\xc2'\x03\xc08\f\x80\x9d\u07b7X}0Q\x06\x005k\xebqw\xf4z\x1c\xf4\x16\x00\x89$0\xbc:\x87\xf6y\x9e\xfe\xbaDw\x93\x01`\x1c\x06\xc0nÞV\x1fN\x94\x01@\u0378\xb4v\xcfs\xfe\xa5\x04@\"\t\x8c\xa8\xc9\xe1Ï\xffN\u007f]\xa2;e\x00\x18\x87\x01\xb0\x97\xbfz\x8a\xb7\b\xc6\\\x06@\xfc]X}O\xbf\xc7A\u007f\x01\x90H\x16~\t\xf8\xfd\xa3\xcf\xeb\xafK\x14\f\x00\x1f`\x00\xf4\xe0-O\x00\x03\x18\x01q\x95\x01\x10g;\xb1\xb4vjQ\xc7A1\x01\xd0\x15\x01\xff\x9d\xf5\xac\xfe\xbad\xbd\f\x00\xe30\x00z\x91\xfb\x04\xc4V\x06@|M\xd5\xdc\xdd\xe7\xcf\xfe\xe5\x04@\"\t\f\x1b\x93\xc3+O\xf3\xc2@]\x19\x00\xc6a\x00\xf4b\xca\x03~\xf2\bp\xf8\x04\xf5\x81E\x19\x00\xb4\u007f\x17Tw\xbf\xd5\xcfT\x00$\x92\xc0È±9\xbc\xf24w\fÔ\x01`\x1c\x06@?\xde\xfc\x04\xaf\t\x88\x99\f\x80\xf89\xbf\xc4\xe1_N\x00$\x92\xc0\xe8q;x\x8b\xa0\x9a\f\x00\xe30\x00\x8a\xf0\xd6Y\xeaC\x8b2\x00hOvb\xdd\xd1ue\x1d\a\xe5\x04@\"Y\xd8,\xe8M\xde\"\xa8 \x03\xc08\f\x80\"\xbdo\x89\xfa\xe0\xa2\f\x00\xba\xa7\uec77\x15}\xce\xdfT\x00$\x92\x85g\al\xe5\xb6\xc1\x01\xcb\x000\x0e\x03\xa0\x04\xeb\x16\xaa\x0f/\xca\x00\xa0\x05\x17\xd5\xf6\xbc\xc3_\x10\x01\x90H\x02\xa3j\xf9(\xe1`e\x00\x18\x87\x01P\xa2\xb7\xf1\xd9\x01Q\x97\x01\x10}Sc+\x1b\xfe&\x02 \x91\x04\x92cs\xf8\xd3c\xdc,(\x18\x19\x00\xc6a\x00\x94\xe1\xed|\x8a`\x94e\x00D\xd9Nl\x18\xdf\xfb\xf6\xbeA\a@\"Y\xb8E\xf0\xd5Ù¼;\xc0\u007f\x19\x00\xc6a\x00\x94\xe9\xedsxw@De\x00D\xd5N\xa4\xc7\xf6\xbd\xbd\xafF\x00$\x92\xc0\xe0\xd1y\xfcu\x1a\u007f\t\xf0W\x06\x80q\x18\x00\x15\xf8\xe3\a\x81\x81Ç¨\x0f4\xca\x00\xb0\xc1Ù£K\xbf\xd5/\xa8\x00H$\x81#krxa:\xaf\t\xf0O\x06\x80q\x18\x00\x15z\xfd\x03@b\x82\xfaP\xa3\f\x808;\xaf\x8c\xfb\xfc\x83\x0e\x80D\xb2pa O\a\xf8%\x03\xc08\f\x00\x03\xfe\xf2I\xf5\xa1F\x19\x00q\xb5\xe9\x183\xe7\xfc\x83\b\x80D\xb2\xb0c\xe0\xf6\xf9\x9e\xfe\xba\x14;\x19\x00\xc6a\x00\x18rjJ}\xb0Q\x06@\xdc\\qT\x9d\xb1s\xfeA\x05@W\x04\xbc\xc1\x1d\x03\r\xcb\x000\x0e\x03\xc0\xa0\xb7\xf1\xee\x80(\xc8\x00\x88\x86\xa9\xb1\xfd?\xd27\xac\x01\x90H\x02c\xc6\xed\xe0\xb3\x03\x8c\xca\x000\x0e\x03\xc0\xb0w\xcdW\x1fp\x94\x01\x10uW\x8e\xab\xf3\xfd8\xf0;\x00\x12I Y\x9bÃ¿g\xf2Q\xc2fd\x00\x18\x87\x01\xe0\x83S\xebÕ\x1ce\x00D\xd5\xd6\xe3\xca\xdf\xde7l\x01\x90H\x02#kr\xf8\xcfS\x8c\x80\xcae\x00\x18\x87\x01\xe0\x93w-\xe0>\x01!\x95\x01\x10^\xd3\x06v\xf8\v[\x00$\x92\xc0\xd019\xfc\xee\xe1\xe7\xf5×¥H\xcb\x000\x0e\x03\xc0Goy\x02\xbcE0|2\x00\xc2h'\xe6\x8c1\u007f\xab_X\x02 \x91\x04\x86W\xe7\xf0\xfc#\x8c\x80\xf2e\x00\x18\x87\x01\xe0\xb3?~\x88\x11\x102\x19\x00a\xb3\x13s\xc7\xf8{\xc1_\x18\x02 \x91,\x9c\x0e\xf8\xef,^\x18X\x9e\f\x00\xe30\x00|6\xe5\x15\"\x80\xa7\x03B#\x03 \\.\xab\xf5\xefV\xbf\xb0\x05@\"Y\xb8E\x90\x8f\x12.G\x06\x80q\x18\x00\x01y\xebS\x8c\x80\x90\xc8\x00\b\x8f\xf55\xc1\u007f\xf3\xd7\x0e\x80D\xb2\xb0c\xe0\xeb\xdc'\xa0D\x19\x00\xc6a\x00\x04\xe8\xafg\xa9\x0f?\xca\x00\b\x8b\xf5\x01^\xf0\x17\xb6\x00H$\x811G\xed\xe0fA%\xc9\x000\x0e\x03 `\xefZ\xa0>\x00m\x97\x01\xa0m'\x1a&Ü®~\x1ch\a@\"Y\xd8'`\xdb<F@q2\x00\x8c\xc3\x00P\xf0\xfe%ê\xcd2\x00t\r\xc3\xf0\x0fK\x00$\x92\x85k\x02^|\x92\xfb\x04\xf4/\x03\xc08\f\x00%\uf627\xbe\x00\xda*\x03@\xcfz\x9f\xb7\xf7\x8db\x00$\x92\xc0\x91c\xb9O@\xff2\x00\x8c\xc3\x00P\xf4\xd7O\xf3\xc2@\x06\x805\xd6\xd7\xe8\x9e\xf3\x0fs\x00$\x92\x85}\x02~\xcf}\x02\xfa\x90\x01`\x1c\x06\x80\xb2\xbc0\x90\x01\x10{;\xb1\xb4\xb6N\xfd}\x0f{\x00$\x92\xc0\x90\xd1y\xbc\xca\a\b\xf5\"\x03\xc08\f\x80\x10x\x037\x19\xda[r\x00\x00 \x00IDAT\vb\x00\xc4\xd5\xc2&?\x1a\xf7\xf9G1\x00\x12\xc9\xc2/\x01\xff|\xf29\xfdu)t2\x00\x8c\xc3\x00\b\x81]\x9b\x051\x02\x18\x001sn\xc0\xdb\xfb\xc6!\x00\x12\xc9\xc2>\x01|\x94\xf0\xde2\x00\x8c\xc3\x00\b\x91\xb7\xcc\x00\x06\xf0\x9a\x00\x06@<\f\xf2\xc1>q\v\x80D\x12\x18=\x8e;\x06\xee)\x03\xc08\f\x80\x9095\xa5\xbe0\xc6]\x06\x80\xff\xb6N\xfc\xb5\xfa\xfb\x1c\xf5\x00H$\x81\xe15yl\x9f\xef\xe9\xafK\xa1\x90\x01`\x1c\x06@\be\x040\x00\"\xec\xcaqw\x85\xf2\x9c\u007f\x14\x03 \x91,l\x16\xc4\xd3\x01\x1e\x18\x00>\xc0\x00\b\xa9w\xccW_ \xe3*\x03\xc0?S!\xbb\xd5/\x0e\x01\x90H\x16\xae\txa\xba\xed\x17\x062\x00\x8c\xc3\x00\b\xb1\xdc,\x88\x01\x10!W\x1eu\x97\xfa{\x1b\xd7\x00H$\v\x8f\x12\xfe\xfb\x136G\x00\x03\xc08\f\x80\x90{wZ}\xa1\x8c\x9b\f\x00\xf36M\xb8=\x12?\xfbG9\x00\x12\xc9\xc2>\x01\xff\x9ei\xeb\xb6\xc1\f\x00\xe30\x00\"\xe0-3\xc0[\x04\x19\x00au^ux\xb6\xf7\x8d{\x00$\x92\xc0\xb01\xb6\xee\x18\xc8\x000\x0e\x03 \"\xde\xf0 0\xf0\x18\xf5E3\x0e2\x00LÙÙ£\xc3{\x9f\u007f\\\x03 \x91\x04\x92cs\xf8\xfb\f\xdbN\a0\x00\x8c\xc3\x00\x88\x90?y\x98\xcf\x0e`\x00\x84\xc4N,\xae\x99\xaa\xfe^\xda\x1a\x00\x89d\xe1\x01B\xedV=J\x98\x01`\x1c\x06@\x84Ly\xc0\xeds\xd5\x17Î¨\xcb\x00\xa8Ü\xe3\xa3w\xce?n\x01\x90H\x02Ãª\xf3h\xb7f\xb3 \x06\x80q\x18\x00\x11\xf47\xb3\xd5\x17\xcf(\xcb\x00\xa8\xcc\xf4\xd8h\u007f\xf3\x8fS\x00$\x92\x85\x1d\x03_\x9bmC\x040\x00\x8c\xc3\x00\x88\xa8\xb7\xcdQ_@\xa3*\x03\xa0|\x17\xc7d\xf8\xc7)\x00\n\x11\xb0ÃÍ\x18\x00\xc6a\x00DX\xde\"\xc8\x00\b\xccNd\x8f\r\xff\xf6\xbe\xb6\x06@\"Y\xd86\xf8\x8d9q\xfe%\x80\x01`\x1c\x06@Ä½o\x89\xfaB\x1a5\x19\x00\xa5\xbb\xee\xe8;#\u007f\xce?\xee\x01\x90H\x02\xc3\xc6\xe4\xf1\xaf'\xe3\xbaO\x00\x03\xc08\f\x80\x18x\xebS\xbc;\x80\x01\xe0\x9b\v\"z\x9f\xbf\x8d\x01\x90H\x02#jrx>\x96\xfb\x040\x00\x8c\xc3\x00\x88\x89\xbf\x98\x01\x1c>A}Q\x8d\x82\f\x80R\x86\u007ft\xf6\xf6g\x00\xbc\xe5\xf0\xea\x1c^\x98\xfe;\xfduÉ¨\f\x00\xe30\x00b\xe4O\x1fS_T\xa3 \x03\xa0\x18;\x91\xaa\xa9S\u007f\xaf\x18\x00\xe5;\xac:\x8f\xad\xb1\xda'\x80\x01`\x1c\x06@\x8cLy;\u007f\t\xe0\xe9\x00\x06@e.\x1b\x1b\x8dG\xfa2\x00\xfavxu\x0e\xafÎ\xcb\xdd\x01\f\x00\xe30\x00b\xe8\xcdO\xa8/\xaea\x96\x01Ð·\vc\xfc\xb3\xbfm\x01\x90H\x16n\x11\x8c\xc7>\x01\f\x00\xe30\x00bê¯V_`\xc3*\x03\xa0w\x97\xd5Ö©\xbf?\f\x00\xf3&ks\xd8\x1a\xf9\x1d\x03\x19\x00\xc6a\x00\xc4\xd8{\xb8O\x00\x03\xa0x7M\xfcu\xec\u007f\xf6\xb75\x00\x12I`xu\x1e\xeds=\xfdu\xa9l\x19\x00\xc6a\x00\xc4Ü»S\xea\vm\xd8d\x00twÅ¸\xbb\xd4\xdf\x17\x06\x80\xff\x8e\xac\xc9Ex\xc7@\x06\x80q\x18\x00\x16x\xebS\xea\x8bm\x98d\x00\xecij\xac\x1d\xe7\xfc\x19\x00\x05G\xd5F\xf5Q\xc2\f\x00\xe30\x00,\xf1\x8ey\xea\vnXd\x00tÙ\x95\x16~\xf3\xb7=\x00\x12I`Xu\x0e\xffy*j;\x062\x00\x8c\xc3\x00\xb0H>J\x98\x01\xb0\x9b\xcbj\xe3\u007f\xab\x1f\x03\xa0w\x87\x8e\xc9ã\xfa%\x80\x01`\x1c\x06\x80=\xe6\xea=\xfc\xee\xbb\xd7\x01\x87\xeb/\xbe\f\x00]O?\xf1\r\xe0\xa1\x15V\xfb\xe2\xed\xeb\xd5\xdf\am\x87\x8d\xc9\xe1oOD%\x02\x18\x00\xc6a\x00\xd8a\xbe\xdeÃ\xa7\xbf\x86\x05w}\x13\xb8\xedp\xab#\x80\x01\x00\x9cyr\xbb\xfa1\xa9\xed?\xa7?\xa7\xfe>\x84\xc1Q\xb5Qy\x940\x03\xc08\f\x80\xf8Û\xf2p\xcdy\xaf \x91D!\x00\\\x01\xee:\\}\x103\x00\x18\x00\x9a2\x00\xderxu\x1e\xdbB\u007f\x8b \x03\xc08\f\x80\xf8\xfb\x8d3_\xdb\xf5A\xdf\x15\x00\xae\x00\x0f\x1f\xa4>\x8c\x19\x00:2\x00\x18\x00{;\xac:\x8f7B\xbdY\x10\x03\xc08\f\x80\xf8Ú\xf2\xf0Í³^\xdd\xe3C\xbeG\x00\xb8\x02<\xf4Y\xf5\x81\xcc\x00\b^\x06\x00\x03\xa0'G\xd5\xe6\xf0jh\xb7\rf\x00\x18\x87\x01\x10O;S\x1e\xfe\xf7\xeb/u\xfb\x80w\v\x00W\x80\xfb>\xa7>\x94\x19\x00\xc1\xca\x00`\x00\xf4\xe6\xa8\xda\\H\x9f\x1d\xc0\x000\x0e\x03 \x9e^=\xe5\x95\x1e?\xdc=\x06\x80+\xc0\xd3\a\xa8\x0ff\x06@p2\x00\x18\x00}9<\x94\x8f\x12f\x00\x18\x87\x01\x10?\xbf~\xfak\xbd~\xb0{\r\x00W\x80\x99\x9fP\x1f\xce\f\x80`d\x000\x00\xfasDM\x0e\xff\xef\xb1ß©\xbfOo\xc9\x000\x0e\x03 >v,\xf4pÞ©o\xf4\xf9\xa1\xee3\x00\\\x01\xee?4\xf6\xb7\b2\x00\x18\x00H3\x00\x8aqxu\x0e\xbf{\xf8y\xf5\xf7\xaa \x03\xc08\f\x80x\x98\xab\xf7p\xc6\xe4\xad\xfd~\xa0\xfb\r\x00W\x80\xbb\x0f\x8bu\x040\x00\x18\x00H3\x00\x8auØ\x1c\xfe=3\f\xdb\x063\x00\x8c\xc3\x00\x88\x87\xe7\x9e\xfazQ\x1f\xe6\xa2\x02\xc0\x11\xa0.\xbe\xfb\x040\x00\x18\x00H3\x00Jq\xd8\xe8\x1c^V\xdf,\x88\x01`\x1c\x06@\xb4\xedLy\xb8\xf8\x8c\xde\xcf\xf9\xefmQ\x01\xd0\xe5o\x12@\xe2h\xf5\x81\xcd\x000/\x03\x80\x01P\xaa#j\xf2xy\x96f\x040\x00\x8c\xc3\x00\x88\xae\xf9\x94\x87+{\xb9Ú¿7K\n\x00W\x80\xa9\xf1;\x1d\xc0\x00`\x00 \xcd\x00(G\xdd[\x04\x19\x00\xc6a\x00D\xd3Î\x87\xef_\xf8r\xc9\x1f\xe0\x92\x03\xc0\x15\xe0\x81CÕ6\x03\xc0\xac\f\x00\x06@\xb9&ks\xd86O\xe3=c\x00\x18\x87\x01\x10M\xbfuni\xdf\xfc\xbb,+\x00\\\x01\x9e\xfe\x98\xfa\xe0f\x00\x98\x93\x01\xc0\x00\xa8\xc4\xe1\xd5y\xbc1'\xe8_\x02\x18\x00\xc6a\x00D\xcb|\xca\xc3\xe5g\xbfZ\xf6\a\xb7\xec\x00p\x05\x98~\x90\xfa\xf0f\x00\x98\x91\x01\xc0\x00\xa8\xd4\xe4Ø \x1f%\xcc\x000\x0e\x03 :v,,\xfd\x9c\xff\xdeV\x14\x00\xae\x00\x0f\x1f\xac>\xc0\x19\x00\x95\xcb\x00`\x00\x98096\x87?<\x1a\xd4>\x01\f\x00\xe30\x00\xa2a>\xe5\xe1\xbcÓ\xbbÕ¯/+\x0e\x00W\x80G\xa2\xfdK\x00\x03\x80\x01\x804\x03\xc0\x94C\xc7\x04u\x8b \x03\xc08\f\x80h\xf8\xb5/\xf7\xbf\xc9O1\x1a\t\x80\xae\b\x88\xe8\xdd\x01\f\x00\x06\x00\xd2\f\x00\x93\x0e\x1e\x9dÇ\x1f\xf7{\xdb`\x06\x80q\x18\x00\xe1v\xc7B\x0fgL\xee{{\xdfR4\x16\x00\x8e\x00\xbfJ\x00\x03\x8fV\x1f\xe8\f\x80\xd2e\x000\x00L;\xb2&\x87\xbfN\xf73\x02\x18\x00\xc6a\x00\x84\xd7\\\xbd\x87+\xce)\xff\x82\xbf\x9e4\x16\x00]\xde:\x10Q\xdb,\x88\x01\xc0\x00@\x9a\x01\xe0\x87É±9\xbc:Û¯\xd3\x01\f\x00\xe30\x00\xc2\xeb5\xe7\x95~\x9f\u007f\u007f\x1a\x0f\x00W\x80{\x0fQ\x1f\xea\f\x80\xd2d\x000\x00\xfcrDM\x1e\xdb\xe7\xfb\xf1\x9e1\x00\x8c\xc3\x00\b\xa7W\x97y\x9f\u007f\u007f\xfa\x12\x00\xae\x00OF\xe7Q\xc2\f\x00\x06\x00\xd2\f\x00?\x1dQ\x93\xf3a\x9f\x00\x06\x80q\x18\x00\xe12\x9f\xf2p\xd5\x14\xb3?\xfb\xef\xaeo\x01\xe0\n\xf0H4n\x11d\x000\x00\x90f\x00\xf8\xed\xe8\xda\x1d\x86\xef\x0e`\x00\x18\x87\x01\x10\x1e\xf3\xf5\x1e\xbes\xbe\xf9\x9f\xfdw\xd7\xd7\x00p\x05x\xfc\xb3\xea\x03\x9e\x01Ð¿\f\x00\x06@\x10\x1e96\x87\x17\x8d=J\x98\x01`\x1c\x06@x4}\xc1_O\xfa\x1e\x00\xae\x003\xc2}:\x80\x01\xc0\x00@\x9a\x01\x10\x94#\xaaME\x00\x03\xc08\f\x00}\xf3\xf5\x1e\xce=\xb5\xf2M~\x8a1\x90\x00p\x05\x98\xf6\xe9\xd0\xee\x13\xc0\x00`\x00 \xcd\x00\bÒ¡crx\xf6\xa1Jw\fd\x00\x18\x87\x01\xa0\xeb\x9b\v\xb6`\xf2\x97\xda\x03\xfb \x06\x16\x00\xae\x14\x1e%\x1c\xc2[\x04\x19\x00\f\x00\xa4\x19\x00A;\xac:\x8f\xe7\x1e\xae$\x02\x18\x00\xc6a\x00\xe8\xb9c\xa1\x87sN1\xb7\xc9O1\x06\x1a\x00\xae\x146\vJ\xe8\x0f}\x06\xc0\x9e2\x00\x18\x00\x1a\x8e\xa8\xc9\xe1?O\x95{:\x80\x01`\x1c\x06\x80\x9e\x95<Õ¯\\\x03\x0f\x00G\x80_\r\n\xd5\xe9\x00\x06\x00\x03\x00i\x06\x80\x96#Ç{\x8b \x03\xc08\f\x80\xe0\xedLy\xb8\xaaÂ§\xfa\x95k\xe0\x01\xd0\x15\x01\xf7\x1e\x12\x9a\b`\x000\x00\x90f\x00h\x9a\xac\xcd\xe1\xb5Ù¥F\x00\x03\xc08\f\x80`Í§<|\xf7\x02\u007fo\xf5\xebK\x95\x00\xe8\xf2\x81p\xec\x18\xc8\x00`\x00 \xcd\x00\xd0v\xf4\xb8\x1dx\xbd\xa4\b`\x00\x18\x87\x01\x10\x9c\x9d\xca\xc3?\x91T\x0e\x00W\nw\a0\x00\xd4e\x000\x00\xc2\xe0\x91csh\x9f[l\x040\x00\x8c\xc3\x00\b\xce+}\xdc\xe1\xafX\xd5\x03\xc0\x15`\xf6\x81\f\x00e\x19\x00\f\x80\xb08\xa2&\x8f\u007f>\xf9\\\x11\xef\x19\x03\xc08\f\x00\xffÝ±\xd0\xc3\xe5\x01l\xf2S\x8c\xa1\b\x00W\x80\xc7>\xcb\x00P\x94\x01\xc0\x00\b\x93#k\x8a\xd9'\x80\x01`\x1c\x06\x80\xbf\xbe\xb9`K\xe0\xb7\xfa\xf5eh\x02\xc0\x95\xc25\x01\n\x17\x062\x00\x18\x00H3\x00\xc2\xe6\xb0\xea<\x9e\u007f\xa4\xaf\b`\x00\x18\x87\x01\xe0\x9f\xf9z/\xd0M~\x8a1T\x01\xe0\n\xf0@\xf0\x0f\x10b\x000\x00\x90f\x00\x84\xd1\xc1\xa3\xf3}<@\x88\x01`\x1c\x06\x80\u007f\x9e{Z0\xdb\xfb\x96b\xe8\x02\xc0\x95\xc2>\x01\x01\xee\x18\xc8\x00`\x00 \xcd\x00\b\xabÃ«s\xbd\\\x13\xc0\x000\x0e\x03\xc0\xbc\xf9\xfa\xf0\x9c\xf3\xdf\xdbP\x06\x80+\xc0\xaf\x06\"\xa8\b`\x000\x00\x90f\x00\x84\xd9dm\x0e/\xcf\xda\xfb\x97\x00\x06\x80q\x18\x00fÍ§<|\xfb|\x9dM~\x8a1\xb4\x01\xe0\np\xcfa\f\x80\x80d\x000\x00\xc2\xee\xa8Ú½w\fd\x00\x18\x87\x01`Ö«Bp\xab__\x86:\x00\\\x01\x9e\xf4\xffQ\xc2\f\x00\x06\x00\xd2\f\x80(8\xac:\x8f\xed\xf3\xbb\xde3\x06\x80q\x18\x00\xe6\xbc\xfa\xdc\xf0~\xf3\xef2\xf4\x01\xe0\n0\xe3\x93\f\x00\x9fe\x000\x00\xa2\xe2\x91c\xbbN\a0\x00\x8c\xc3\x00\xa8\xdc\\\xbd\x87k\xce\v\xff\xf0O$#\x12\x00\xae\x00\x8f\xfb\xb7m0\x03\x80\x01\xc0\x00\x88\x96\xc9\xda\x1c\xfe:}3\x03\xc04\f\x80\xca\f\xd3&?\xc5\x18\x99\x00pÅ·Í\x18\x00\f\x00\x06@\xf4\xac>j+\x03\xc04\f\x80\xca<\xf3+\xe1\xd9\xe4\xa7\x18#\x15\x00\xae\x003?\xce\x00\xf0A\x06\x00\x03 j\x0e\xad\xde\xc6\x000\r\x03\xa0<\xf3)\x0f_\xfb\xf2V\xf5\x0fE\xa9F.\x00\\\x01\xee\xf9\x1cL\xde\"\xc8\x00`\x000\x00\xa2'\x03\xc0\a\x18\x00\xa5Û±\xd0\xc3y!\xdc\xe4\xa7\x18#\x19\x00\xae\x14\xf6\t\x18h&\x02\x18\x00\f\x00\x06@\xf4d\x00\xf8\x00\x03\xa04\xf3)\x0fWL\x89\xc6\x05\u007f=\x19\xd9\x00p\x05\xf8\xcd #\xcf\x0e`\x000\x00\x18\x00Ñ\x01\xe0\x03\f\x80Ò¼\xec\xec\xe8\\\xf0×\x91\x0e\x00W\x80\xc7\x0eb\x00\x18\x90\x01\xc0\x00\x88\x9a\f\x00\x1f`\x00\x14gg\xca\xc3U\x11\xb8Ï¿?#\x1f\x00\xae\x00\x0fUv\x8b \x03\x80\x01\xc0\x00\x88\x9e\f\x00\x1f`\x00\xf4o>\xe5\xe1\xda\v_V\xff\x00\x980\x16\x01\xe0\n\xf0È¡\f\x80\nd\x000\x00\xa2&\x03\xc0\a\x18\x00}Û\xf2pE\x84\xee\xf3\xef\xcf\xd8\x04\x80+\xc0\xccO1\x00Ê\x01\xc0\x00\x88\x9a\f\x00\x1f`\x00\xf4\xedE\xa7\xbf\xa6~\xe0\x9b4V\x01\xe0\n0\xfbc\f\x802d\x000\x00\xa2&\x03\xc0\a\x18\x00=\x9b\xab\xf70\xe5\xd4h\xde\xea×\xb1\v\x00W\x80\xfb>W\xd2\xdd\x01\f\x00\x06\x00\x03 z2\x00|\x80\x01\xd0Ý\x85\xd1\xdc\xe4\xa7\x18c\x19\x00\xae\x146\v*2\x02\x18\x00\f\x00\x06@\xf4d\x00\xf8\x00\x03\xa0\xbb\xe7\x9c\x12\xad\xed}K1\xb6\x01\xe0\np\xc7@\x06@\x912\x00\x18\x00Q\x93\x01\xe0\x03\f\x80=\xbd\xe0k\xf1\xfb\xd9\u007fwc\x1d\x00\xae\x00\xf7$\xfa\xfd%\x80\x01\xc0\x00`\x00DO\x06\x80\x0f0\x00\nv\xa6<\\\x19\x83\xfb\xfc\xfb3\xf6\x01\xe0\n0u@\x9f\x11\xc0\x00`\x000\x00\xa2'\x03\xc0\a\x18\x00\x85\xe1\xff\xbd\x98\xdc\xe7ßV\x04\x80+\xc0\x83\x871\x00\xfa\x90\x01\xc0\x00\x88\x9a\f\x00\x1f`\x00x\xb8\xf4\xccx\xdd\xea×\xd6\x04\x80+\xc0S=?J\x98\x01\xc0\x00`\x00DO\x06\x80\x0f\xd8\x1c\x00\x9d)\x0f\x97\x9ca\xcf\xf0O$-\v\x00W\x80\x99\x9fd\x00\xf4 \x03\x80\x01\x105\x19\x00>`k\x00\xe4\xeb=\\\x15\xe1\xa7\xfa\x95\xabu\x01\xe0\np\xff\x00\x06\xc0^2\x00\x18\x00Q\x93\x01\xe0\x036\x06@\xae\xde\xc3\xf9\xa7\xc5\xfbj\xff\u07b42\x00\\\xd9\xe3)\x82\f\x00\x06\x00\x03 z2\x00|\xc0\xc6\x00\x88\xeb&?\xc5hm\x00\xb8\x02<\xfa\x19\x06\xc0N\x19\x00\f\x80\xa8\xc9\x00\xf0\x01\x9b\x02 Wo\xf7\xf0O$-\x0f\x00W\x80\xa9\t,\x1b\xf9S\xf5\xf7A[\x06\x00\x03 j2\x00|\xc0\x96\x00\xc8\xd7{8?\xe6\x9b\xfc\x14\xa3\xf5\x01\xe0\n6M=\r\x83F\xe5\xd5\xdf\vM\xcf\xfa\xc2\xcb\xc0\xe9\xdf\x06\xbe\xf6-k\xddv\xf6\xffb\xd1}_\xa3\x11q\xc9\xfd\xa70\x00LcC\x00t\xa6<\\e\xc1&?\f\x80\xe2]s\xdf\xc5H$;\xd5\xdf\x0f-\xcf<\xb9\x1dx`9p\xf8\x84\xb2\x1e\xa9\x1c\vGOR?\x0ei\x802\x00\xba\x03\v\x02\xe0b\xcbn\xf5c\x00\x14\xa73m2\x06Z\x1a\x01\x85S\x00m;#\xe0h\xfda\xcc\x00\xa0~\xcb\x00\xe8\x0eb\x1c\x00\x9d)\xbb6\xf9a\x00\x94\xae\xf3\xf8)VF\xc0\x1e\xd7\x00Ü½\b\x18p\xb4\xfe@f\x00P?e\x00t\a1\r\x80Î\x87k-\xd9Þ\x01P\x99\x8d\x0fOQ\u007f_T\x03 \xed\x01\x0f\xaf\xd2\x1f\xc8\f\x00\xea\xa7\f\x80\xee \xa6\x01p\xc59<\xe7ß\f\x80\x9e}~\xee8\xf5\xf7F5\x00\xd2\x1e0\xdb\xd1\x1f\xca\f\x00\xea\x97\f\x80\xee \x86\x01\x10\xf7G\xfaV\"\x03\xa0w\x9f}\xfa\x18\xd8ra`\xaf\xb7\x01\u07bfÌk\x02\x18\x00v\xc9\x00\xe8\x0eb\x14\x00\x1d\v=\x9cs\xca\x1b\xea\x8bk\x98e\x00\xf4m\xd3#gYq\x8b`\x9f\xfb\x00LM\x03\x89c\xf4\a4\x03\x80\x9a\x94\x01\xd0\x1d\xc4$\x00r\xf5\x1eN;\xd9\xeeM~\x8a\x91\x01Ð¿\xeb\xee?\x1f\x03\x93\xf1\x8e\x80~7\x02\xbaoi\xfc#\x80\x01`\x97\f\x80\xee &\x01\xc0o\xfe\f\x00\x93\xae\xbd\xff\x92X\xdf\x1d\xd0o\x00\xa4Ú{\x16\x01\x03\x8f\xd5\x1f\xd4\f\x00jB\x06@w\x10\xf1\x00\xe8Ly\xb8\xe8t\xde\xea\xc7\x000\xefÒ»\xae\xc4\xe0\xd1\xf1\xfc%\xa0è­\xef\xaaGl\u007f\t`\x00\xd8%\x03\xa0;\x88p\x00\xe4S\x1e.?\xfbU\xf5\xc54J2\x00Js\xed\xfd\xe7\xc7\U0009a012\x9e\x0505\x15\xcf\v\x03\x19\x00v\xc9\x00\xe8\x0e\"\x1a\x00\x9d)\x0f\xdf\xe5}\xfe\f\x80\x00lz\xe4L\xc4\xed\ue012\x1f\x06\xf4Øº\xf8E\x00\x03\xc0.\x19\x00\xddAD\x03\xe0\xca)\xbcÏ\x01\x10\x9c\xcfÏ­Q\u007f\xefT\x03 \xd5\x06\xcch\xd0\x1f\xda\f\x00Z\xae\f\x80\xee b\x01\x90Oy\xb8\xec,\xfe\xec_\xae\f\x80\xf2m\x9b\xf9\x05\xf5\xf7O-\x00\xba\xbco)b\xb3m0\x03\xc0.\x19\x00\xddA\x84\x02\xa0c\xa1\x87\xcb\xcf\xe67\xffJd\x00T\xa6\xfb\xf8\xa9\xb1\xb8;\xa0\xec\x00H{\xc0\xbdK\xe2q:\x80\x01`\x97\f\x80\xee \"\x01\x90Oy8\xf7T\xde\xea\xc7\x00\xd0×6\x19Q\xbf&\xa0\xa2\x00H{\xc0\xb4\xf5@b\x82\xfe\x10g\x00\xd0be\x00t\a\x11\t\x00n\xf2\xc3\x00\b\x93\xee\xb4É\xbe;\xa0\xe2\x00H\xb5\x15\x9e\"8h\xa2\xfe g\x00\xd0bd\x00t\a!\x0f\x80\x1d\v=\x9c>\x99Ã\x01\x10>\x17\xdd\xf9-\f\x1d\x93S\u007fOU\x02\xa0\xcb\xdb\xe7\x01G\x1c\xa7?\xcc\x19\x00\xb4?\x19\x00\xddA\x88\x03 W\xef\u16fcÏ\x01\x10bS\xb7_\x13\xc9Í\x8c\x05@\xdaÛ¹Y\xd0\x04\xfd\x81\xce\x00\xa0}\xc9\x00\xe8\x0eB\x1c\x00W\x9f\xcb\v\xfe\x18\x00\xe1w\xe3Cg\xab\xbf\xaf\xaa\x01\x90\xf6\x80'\x1b\xa3wa \x03\xc0.\x19\x00\xddAH\x03\xe0*\xde\xe7\xef\x8b\f\x00\u007f\xfc\xed\xac\x89\x88Ò\x81\xc6\x03 \xed\x01\x0f,G\xa4n\x11d\x00\xd8%\x03\xa0;\bY\x00\xe4S\x1e\xae8\x87?\xfb3\x00\xa2\xa7\xfb\xf8)\xea\xef\xafj\x00\xa4\xbd\xc2-\x82Ú\x9d\x01\x10O\x9b?[\xd9\xff\x9f\x01\xd0\x1d\x84(\x00r\xf5\x1e\xbeÅ\xfd}\x95\x01\xe0\xaf\xcf\xcc8Y\xfd=V\r\x80\xb4\a<\xb2:\x1a\xa7\x03\x18\x00Ñ±\xe9\b \xddR\xd9\u007f\x83\x01\xd0\x1d\x84(\x00x\xc1\x1f\x03 \x0en\x99u,\xc2~:\xc0\xd7\x00H\xb5\x013\"pM\x00\x03 \x1a6\x1d\f\xa47\x01i\xb7\xb2\xff\x0e\x03\xa0;\bA\x00\xe4\xea=L\xe1&?\x81\xc8\x00\b\xc6gf\x9c\x10\xea}\x02|\r\x80.\xefY\x82P?J\x98\x01\x10~\x1b\x87\x00\xe9gv\x1eS\f\x00\xe3@9\x00\xde\\\xb0\x05_>\xb1]}A\xb4E\x06@p\xae\xbd\xff\x02\f\x1e\x1d\xce}\x02\x02\t\x80\xb4\aÜ¹\x00\x18\x14\xd2}\x02\x18\x00\xe1\xb6q\xd8n\xc3\xdfc\x00\xf8\x01\x14\x03`\xc7B\x0fg\u007f\x95\xdf\xfc\x19\x00\xf15}\xe7\xd58\"\x84\xbf\x04\x04\x16\x00i\x0f\xb8+\x15\xceÍ\x18\x00\xe1\xb5é ½\x86\xbf\xc7\x00\xf0\x03(\x06\x00\x9f\xea\xc7\x00\xb0\xc1Ew\\\x83A\xa3\xc2uM@\xa0\x01\x90j+<E0l\xa7\x03\x18\x00\xe14\xf3\x81^\xe6\n\x03\xc08P\b\x80Î\x87+x\xc1\x1f\x03\xc0\"7>tV\xa8\xae\t\b4\x00\xba\xbc{Q\xb8.\fd\x00\x84Ï\x8f\xa0p\xc1_O\xc7\x10\x03\xc08\b8\x00\xf2)\x0f×\xf7\xb2\xfa\x02h\xab\f\x00=\x9b\x1f934\x8f\x12V\t\x80\xb4W\xb80P{\xf03\x00\xc2i\xf3\x81@\xba\xb5\x8f\xe3\x87\x01`\x1c\x04\x18\x00\x9d\x1c\xfe\xea2\x00t}\xe6\xc9\x13Õ\x01\xd5\x00H{\x85[\x04Ã°c \x03 <6\u007f\xb2\x8fo\xfe]2\x00\x8c\x83\x00\x03\x80?\xfb\xeb\xcb\x00\xd0\xf7\xf9\xb9\xb5\xeaÇj\x00\xa4=\xe0\xf1u\xfa\x11\xc0\x00\b\x87M\x87\x16\x86{\xbf\xc7\r\x03\xc08\b \x00v,\xe4\x05\u007fa\x91\x01\x10\x0e[\xa7OV=\x1d\xa0\x1e\x00i\x0f\xb8{1p\xf8\x04\x06\x80\xcd6\x8cD\xf7\xab\xfd{\x93\x01`\x1c\xf8\x1c\x00o\xce\xdf\xc2[\xfdB$\x03 <6?r\x86Ú\x81\xa1\b\x80\xb4\xb7s\xb3 \xa5\b`\x00\xe8Z\xd2\xf0\xf7\x18\x00~\x00\x1f\x03 W\xefq\x93\x9f\x90\xc9\x00\b\x97M\x8f\x9c\xae\xf2K@h\x02 \xed\x01\x0f.\xd7\xd9,\x88\x01\xa0gÓ¡%\x0e\u007f\x8f\x01\xe0\a\xf01\x00\xa6\x9c\xc2o\xfea\x93\x01\x10>\x17\xdd\xf1\xed\xc0w\f\fU\x00\xa4Ú;\x17\x06\xbfY\x10\x03@\xc7\xe6O\xa2\xb8s\xfe{\xcb\x000\x0e|\b\x80\\=\x1f\xec\x13V\x19\x00\xe14u\xe75\x18<:\xb8\xd3\x01\xa1\n\x80.\xef\\\b\f\fp\xb3 \x06@\xf06\x1f\x88\xfe\xaf\xf6\xefM\x06\x80q`8\x00\xf2)>\xd27\xcc2\x00\xc2\xeb\xba\xfb\xcfÃ d0\x11\x10\xca\x00H{\x85\x1d\x03\x83\xda,\x88\x01\x10\xac-\x1fA\xdf\xf7\xf9\xf7'\x03\xc080\x1c\x00W\x9c\xc3o\xfea\x96\x01\x10n\u007f;k\xa2\xdd\x01\x90\xf6\x80\xa7\x1d\x06@\xdc\xcc|\xa0\x82o\xfe]2\x00\x8c\x03\x83\x01p\xe5\x14~\xf3\x0f\xbb\f\x80\xf0\xbb\xe5\xa9Iv\a@\xda\x03\x1e\\\xc9\x00\x88\x8b\xcd\au\xfb\xa2\xc8\x00\b\t0\x10\x00\xb9z\x0fW\xf3g\xffH\xc8\x00\x88\x86\x9b\xa6\u007f\xc5\xee\x00H{\xc0\xbdK\xe1\xebfA\f\x00\xff\xed\xf6H\xdfJd\x00\x18\a\x15\x06\xc0\x8ez\x97\x17\xfcEH\x06@tl\x9d>\x19\t\x9fn\x11\x8cD\x00\xa4=\xe0\x91\xd5\xfem\x16\xc4\x00\xf0\xd7\xc6!\x06\x87\xbf\xc7\x00\xf0\x03T\x18\x00SN\xf9\xaf\xfaP\xa3\f\x80\xb8\xbae\xd61\xf0#\x02\"\x13\x00\xa96\xe0\xf1\xf5\xf0\xe5Q\xc2\f\x00\xffl<\xd8\xf0\xf0\xf7\x18\x00~\x80\n\x03`X\xcdV\xf5\xa1F\x19\x00qv\xdd\xfd\xe7c\xf0(\xb3\xfb\x04D&\x00\xba\xbck!p\xc4$\x06@\x14l<\x02\x95_\xf0×\f\x00\xe3\x80\x01`\x95\f\x80h\x9a\xba\xe3\x1a\f1\xb8YP\xe4\x02 \xed\x01\xb7\xcf\a\x06Md\x00\x84Ù¦C`\xfe\x9b\u007f\x97\f\x00\xe3\x80\x01`\x95\f\x80\xe8\xba\xf8\xae\xab1h\x94\x99\xd3\x01\x91\f\x80\xb4W\xd8'\xc0Ô³\x03\x18\x00fm\xf90\xfc\xf9\xe6\xdf%\x03\xc08`\x00X%\x03 Úº\xd3N\x82\x89k\x02\"\x1b\x00\xa96\xe0\xd15f6\vb\x00\x98\xd3\xd9\x17\xe5m\xef[\x8a\f\x00\xe3\x80\x01`\x95\f\x80\xe8\xdb\xf2\xe8i\x15?@(\xb2\x01\xd0\xe5=K\x18\x00a\xb1\xa2\xed}K\x91\x01`\x1c0\x00\xac\x92\x01\x10\x0f\x9d\xc7N\xb3;\x00\xd2\x1e\xf0\xc02\x06\x80\xb6M\x87\x054\xfc=\x06\x80\x1f\x80\x01`\x95\f\x80\xf8\xf8l\x05\xdb\x06\xc7\"\x00\xd2\x1e0\xc7AÙ\x051\x00*\xd3\xd7\v\xfez\x92\x01`\x1c0\x00\xac\x92\x01\x10/\x9f\x9f;\x16\xe5\\\x13\x10\x9b\x00H\xb7\x95\xbfY\x10\x03\xa0|\x9b>\x87\xe0\xbe\xf9w\xc9\x000\x0e\x18\x00V\xc9\x00\x88\x9f\r\x0f\x9d\x83A\xa3J{\x8a`|\x02`\xa7S\xd3(y\xb3 \x06@y6\x8c@\xb0\xdf\xfc\xbbd\x00\x18\a\f\x00\xabd\x00\xc4\xd3u\xf7\x9f\x8f#J\x88\x80\xd8\x05@W\x04\f<\x96\x01à§\x83\x94\x86\xbf\xc7\x00\xf0\x030\x00\xac\x92\x01\x10_WL\xbd\xc2\xee\x00H{;\xf7\t(\xf2\x97\x00\x06@i\xb6\xec\xaf8\xfc=\x06\x80\x1f\x80\x01`\x95\f\x80x\xbb\ue04b\x8a:\x1d\x10\xdb\x00(%\x02\x18\x00\xc5\xdb\xf2\x11 Ýª\xfc\xde2\x00\x8c\x03\x06\x80U2\x00\xe2\xef\x9a{\xbf\xde\uf381\xb1\x0e\x80\xb4\aÜ½\xa8\xffÍ\x18\x00\xc5\xd9|\x00\x82\xbf\xe0\xaf'\x19\x00\xc6\x01\x03\xc0*\x19\x00v\xd8\xfc\xc8\x19\xe8\xeb\xee\x80\xd8\a@\xda\x03\x1eZ\xd5w\x040\x00\xfa\xb7\xf9\x00\xe8\u007f\xf3\xef\x92\x01`\x1c0\x00\xac\x92\x01`\x8f\xcfÎ\xd0k\x04X\x11\x00\xe96`f#\x03\xa0\\\x9b?\x0e\xa4\xb3!x\x1f\xbbd\x00\x18\a\f\x00\xabd\x00\xd8\xe5\x96Y\xc7Y\x1c\x00;}hEÏ\x051\x00z7\xd0\x1d\xfe\x8a\x95\x01`\x1c0\x00\xac\x92\x01`\x9f\r\x0f\x9d\xd7\xed\xd9\x01V\x05@\xda\x03\xee[\xd2\xfdt\x00\x03\xa0g\x1b\x87\x86p\xf8{\f\x00?\x00\x03\xc0*\x19\x00v\x9a\x9d\xf6\xe5=\"\xc0\xba\x00H{\x85\x1d\x03w\u007f\x940\x03\xa0\xbb\x8d\x87C\xf7V\xbf\xbed\x00\x18\a\f\x00\xabd\x00Ø«;m2\xba\xae\t\xb02\x00\xd2m\xc0\xfd\xcbÞ\x00\x06\xc0\x9e6\u007f*\xc4\xc3\xdfc\x00\xf8\x01\x18\x00V\xc9\x00\xb0\xdb5\xf7^\x82A\xa3\xf2\x96\x06\xc0N\xef^T\xd81\x90\x01\xf0\x96\xcd\a\x87|\xf8{\f\x00?\x00\x03\xc0*\x19\x00t\xf9\xd4\xcbq\xf6\x97\xdf\b\xc1\x82\xae\xe8\u074b\x80\xea/\xa8\xbf\x17\xa1\xb0\xf9\xd3\x11\x18\xfe\x1e\x03\xc0\x0fPa\x00<rÔx`ÌHx\xf3Y\u007f\u008d\xdfx\xc9j7\xff\xdfu\xc0Ï\xd9\xed\x9c)\xc0\x9a\xef[\xed\vO,\x00R\xda\v\xba\xb2\xb3V\xe9\x0f_m[>\x82p^\xf0\xc7\x00\b\x84J\x03\x00GÔ\xf7,n\ro_\x10\x82\x83XÙ³\xae\xd5\u007f\x1f4\xbd\xf4g@\xaaM\xff}Ð´k\xf0\xdb\xfe:\xa4[\xf4\a\xb0\xfa\xf0wB\xf0>\x14+\x03\xc08\f\x00Ë´9\x00.\xfd\xb9\xddC/Õ¶\xf3ß¿\xfbk\xd0f\xf1/\x01\x16\a@\xf3\xa7\x11\x9do\xfe]2\x00\x8c\xc3\x00\xb0L[\x03\xe0\xfc\xeb\xf5_{m{\x8b\x1fk\xa3\xc8\xd2\x00\x88\xc4\x05\u007f=\xc9\x000\x0e\x03\xc02m\f\x80\xcb\u007f\xa9\xff\xba\x87]+#\xc0\xc2\x00\x88\xcc\x05\u007f=\xc9\x000\x0e\x03\xc02m\v\x80+~e\xe9p\xdbÍ¢\xff\xfdm\x96\xbdV\x96\x05@S\x02\xd1\x1d\xfe\x1e\x18\x00>\xc0\x00\xb0L\x9b\x02\xe0\xa2\x1b-\x1bh{\x99*c\xa0\x97\xf3\xff\x89\xac\x16\x05@\xe3PD{\xf8{`\x00\xf8\x00\x03\xc02m\t\x00\xdb\xcf\xf9W4\xc8\xf7\xbeP0\xaeZ\x12\x00\xa1|\xb0O92\x00\x8c\xc3\x00\xb0L\x1b\x02\xe0\xfc\xeb-\xfa\x16Û\x95\xfe\xfbS6\xdc\x1d`A\x00\xb4|\x1c\xf1\x18\xfe\x1e\x18\x00>\xc0\x00\xb0Ì¸\a\xc09\xd7\x01\xf5\x9b\xf5_gMM\xc5O\xec#*\xe6\x01\xd0r\x00\x90Î\xe0u6%\x03\xc08\f\x00Ës\x00\\\xf8c\xfd\xd7W[\xd3\xdf\xdac\x1d\x011\x0e\x80\x96\x03\x80tk\b^c\x932\x00\x8c\xc3\x00\xb0Ì¸\x06\xc0\x85?\xd1\u007fm5\xf5\xf5'\xfb\xb8\x9e\x0e\x88i\x00Dj{\xdfRd\x00\x18\x87\x01`\x99q\f\x80+\u007f\x1d\xf3o\xaaE\xe8\xf7\xbf?\x96\xafo\f\x03\xa0e\u007f\xc4\xef\x9b\u007f\x97\f\x00\xe30\x00,3n\x01p\xd9-1\x1dN%\x18Ô·\xf3Ø½\xce1\v\x80\xc6#\x10\xfd[\xfd\xfa\x92\x01`\x1c\x06\x80e\xc6)\x00.\xf9\xa9\xfe\xeb\xa9m\xe0C9N\xfb\x04\xc4(\x00\x1aG \xde\xc3\xdf\x03\x03\xc0\a\x18\x00\x96\x19\x97\x00\xb8\xf8&\xfd\xd7RS\xd5\r{\xe2\x12\x011\t\x80\xa6\xcf!\xfe\xc3\xdf\x03\x03\xc0\a\x18\x00\x96\x19\x87\x00\xe0#}C\xf0\xef\x8fC\x04\xc4 \x00\x9a\x0fE</\xf8\xebI\x06\x80q\x18\x00\x96\x19\xf5\x008\xe7\a1\x18<\x15\x18\xa6\xadz\xc3\xf4\xb7\x94e\xc4\x03\xa0\xe90\xd8\xf1Í¿K\x06\x80q\x18\x00\x96\x19\xe5\x008\xe7\a\xfa\xaf\x9f\xaam@js\xc8n\xc9c\x00\xa8\xd8| \xec\xf9\xe6\xdf%\x03\xc08\f\x00Ëj\x00\\p\xbd\xfek\xa7mX\xbfm\x87\xf5\xef\xea\u05c8\x06@f_\xd87\xfc=0\x00|\x80\x01`\x99Q\f\x80+n\x8d\xf0\x901d\xe8\u007fn\x8f\xe2fA\x11\f\x80\x96\x0f\x03i7\x04\xaf\x9d\x86\f\x00\xe30\x00,3j\x01p\xc9OC>\xf8\x020\xe5!\x12?\xb5G\xee}\x8aX\x00Xu\xc1_O2\x00\x8cSq\x00d\x048q\xb8\xfe\xa0`\x00\x14g\x94\x02\xe0\x1b?\xd3\u007f\xbd\xb4\x8d\xca\xf0\xdf\xf5\xf7F\xe8o\x8dR\x004\r\x86]\x17\xfc\xedå²\x80S\xc5\x000M\xc5\x01\xd0å·\x01\x83\xc6\xe9\x0f\r\x06@\xdfF%\x00.\xbb9b\xc3\xc4\x0f#\xfa\xef\x8f\xcc\xfb\x16\x91\x00h:\x04H\xd9\xfaÍ¿\x15\xc8\xecg\xe6ud\x00t\xc7X\x00tY\xb7\xbf\xfe\xf0`\x00\xf4n\x14\x02\xe0\xf2_Dh\x88\xf8d\xaa\r\x91\r\x80\xb4\x87h\\\x13\x10\x81\x00h\x1c\nk\xbf\xf9o8\xd1\xeck\xc9\x00\xe8\x8e\xf1\x00(\xbc\xd0\xc07\x0f\xd3\x1f$\f\x80\xee\x86=\x00l\u007f\xa4\xef\xae\xc1\x1f\xe5\xe1\xdfe\xd8/\\\fy\x004\x0e\aR\x16\x0e\xffU7T\xfes?\x03\xa08|\t\x80\xddC\xe0\x98\xa4\xfePa\x00\xbce\x98\x03\xc0\xf6\xfb\xfc#\xff\xad\xbf'\xc3\x1c\x01!\x0e\x80\xe6\x83`\xdd7\xff%\xf5\x80\xeb\xc3\xe0g\x00\xf4\x8e\xaf\x01\xd0e\xfd{\x80\xc4Q\xfa\x03\x86\x01\x10\xde\x008\xeb\u007f\x81\xfa\xcd\xfa\xaf\x8f\xaaQ\xf8Ù¼\f\x19\x00\xa5\xd9\xf2\x01 \xed\x84\xe0\xf5\t\xcaÍ\xeb\x1c\xfc~]\x19\x00\xdd\t$\x00\xba\xfc\xe5\x81\f\x00m\xc3\x18\x00\x17\xdd\xc8\xe1\x1f\xd7\xe1\xdfe(# \x84\x01Ð²?\xac\xba\xd5o\xfd\x19\xc1\xbd\xb6\f\x80\xee\x04\x1a\x00\xae\x14n\x1b<g \x03@Ë°\x05\x00\x9f\xea\x87p\xffLnÒ°EN\xc8\x02\xa0\xf9@ \xdd\x1a\x82\xd7%\x00W\xdc\xe9\xcfy~\x06@i\x04\x1e\x00\xbb[3\x86\x01\x10\xb4a\n\x80Ky\x9f\u007f\xfc\xce\xf9\xf7c\xa8B'D\x01\xd0\xf2)X\xf1\xcd\u007f\xf1J\xbd×\x01\xd0\x1d\xb8\xb2?\\\xf9\x8bÚ2\xf3\x03\f\x80 \rK\x00p{_\xc4\xe7j\xff\x12\r\xcd\xfb\x1e\x92\x00h>\x14Vl\xef\xdb8B\xf3u\xfe;6\xc9G\xb5\xe7mhAFFÃ\x0e\xa52\x03n\xf8\x14\x03 \b\xc3\x10\x00\x97\xfe,DC@K\xcb\xff\xfd\xa90\x9c\x0e\bA\x004\x8c\x8c\xff\xad~k/.\xac\xf1:\xafq\a\xb22V{\xbeF\x068\xf2]\xb8\xb2C\xe5\xcd\xca\b\xf0\xd5!\f\x00?\xd5\x0e\x80\x8bo\xd4\u007f\r4\x8d\xd5}\xfe\x06^\v\xd5\x10T\x0e\x80\x86#\x11\xeb[\xfd\x96=\x1c\xfcy\xfe.\x1d\xc9!+\xd7i\xcf\xd3\xc8\x02G\xd6\xc1\x95N\xb5\x0fÇ\x1a\x06\x80\x1fj\x06\xc0E\x1c\xfe\x1c\xfcazM\x14\x03\xa0\xe9\xb0\xf8~\xf3_\xd4\b8o\xd7{m\x1diÐ\x9f\xb1\x00\x19\xf94\\\xf9\x97\xda\x1b\xf9Ð\x18\x00\xa6\xd5\n\x803\xbf\xcf[\xfd\xac\xb9Ú¿D\xd5~\tP\n\x80\xe6O!\xb6\xe7\xfc7\x1e\xad7\xf8\xb3\xf2_4\xc8g\xb4\xe7f\xec\x80#\x9f\x87\xe6\xf5\x01\xdf>\x98\x01`J\x8d\x008\xe7\av\x0f\xff]\xb7\xfa\x85\xe0o\t\xab\xb6\x04@\xf3\xc7\x11Ë«\xfdW\u007fO\xef\xe7~W:\xe0È\xb4\xe7d\xec\x81+7Ã\x9cZ\b\x9c0\x82\x01P\xa9A\a\xc0\x857\xe8\xff\x9b\xd5\xe5\xf0/\xca\xc0# \xe0\x00h\xd9\x1f\xb1\xbb\xcf\u007f\xe9,\xf8\xba}o\xdf\xe6\xe0\xc8o\xb4\xe7\xa2u\xc0\x11O\xe9\r\a\x1a\xf6)\u007f[a\x06@\xb0\x01\xf0\xcd[\xf4\xff\xbd\xea\xf2'\xff\x92\f4\x02\x02\f\x80\xcc\a\x10\xafo\xfe\x9b\x81Ì¾Z\x83\x1fp\xe59\xed9h5\xc8\xc8\xe1p\xe4\x15\xb5\x03\xe0\xce\xfd\x19\x00\xe5\x18T\x00\\v3\xcfw\x87\xe2V\xb7\b\x1a\xd8q\x13P\x004\u007f\x06\xb1\xda\xdb\u007fÃ\xf4\x06\xbf#o\xc0\x95\x81\xda\xf3\x8f\xec\x04\x8e|\rZ\xd7\ad\x04\xb8d\x00\x03\xa0\x14\x83\b\x00\xde\xe7\x0f\xde\xeaW\xa1\x81\x1c?\x01\x04@\xe3p\xc4\xe6V\xbf\x95?\xd7=\xcf\xdf*gk\xcf;\xd2\vpd&\\É«\x95\xe1\x84$\x03\xa0\x18\xfd\x0e\x80K,\xdf\xdb?íß\xbe\xff\x82\xe2s\x004\x0e\x8dÇ­~KRZC\x1f\xc8J\x1e\x8e\xccÖo\xa4\b\xe0\xc9;\xe1\xca\xf3j\a\xcb\xd2w1\x00\xfa\xd3\xcf\x00\xb8\xfc\x97\xfc\xe6\x9f\xf2\xc0\x000\xf9z\xfay\x8b\xa0\x8f\x01\xd0t(b\xf1Í¿\xf9\x93z\xc3ß?!-\xefÒk\xa4D\xd0*\xa3\xe0\xca6\xb5\x03\xe7\xe7\x9f`\x00\xf4\xa6_\x01p\xc1\xf5\x1c\xfe\xdc\xe8'b\xaf\xabO\x01\xd04\x18HE\xfc\x82\xbfu\xe7hn\u07fb\x03\xaeTk\xcf1R!p\xe4\x12h^\x1fp\xd6 \x06\xc0\xde\xfa\x11\x00\xe7\xfc@\xffß¥*\a\u007f0\xaf\xb1\xe9\xff\xa6\x0f\x01\x10\xf5o\xfe+\xee\xd2<Ï¿\x03\x19\xb9B{n\x11\xc3 +K\xa0\xb9\xad\xf0\x981\f\x80.M\a\xc09\xff\xab\xffoÒ\xdf\xfa#\xac\xe1\x00h\xfe\b\"{\xab\xdf\xe25ZC\x1f;g\xc3\n\xed9E|\x04\x8d\xf2\x01h>vx\xee\xfb\x18\x00i\xcfl\x00\xf0j\u007fp\x93\x9f\x805z\xbc\x19\f\x80Ì¾\x88\xec\xf6\xbeM\x035\x87\xff?\x90\x91\xfd\xb4\xe7\x13\t\b82\x0e\x9a\xdb\n\xaf\xbdD\xff\x03\xa7\xa9\xa9\x00\xb8\xf8&\xbb\x87\u007f\xaa\rHo\xe6\xf0\xd7zí¼\xee\x86\x02 \xaa\xdb\xfb\xae\xfd\xa6\xf6m}\x13\xb4\xe7\x11Q\x02\x19\xf9>\xb4\x1e;\xecT\x01\xcb\x1f\xd4\xff\x00jh\"\x00.\xf9\xa9\xfe\xbfC[n\xb4#\xe4V\x00\x00\x0f\x9aIDAT\xf2\xa3\xff\xfaW\xfc\xdf1\x10\x00M\x87!r\xc3\u007f\xf9#\xba\x8f\xe9u\xe4z\xed\xf9CB\x02\\iP*\xd0\xc2#+\x175\xe9\u007f \x83\xb4\xd2\x00\xb8\xecf\xfd\u007f\x83\xba\x16\xff\xf2\x11&+\x8e\x80\n\x03\xa0\xe90Dê¿E-\x80\xf3n\x9d\xb5\xb6`\x8b\xf6\xbc!!\x04\x199\x10\x8e\xbc\xa8v`6\x8c\xd1\xffp\x06e%\x01p\xe5\xaf\xec\xfe\xd9?\xed\xf1\xdf\x1f6+\xfa%\xa6\x82\x00h:<Z\xb7\xfa5\x8c\xd5\x1c\xfc/\xa1U>\xa1=gH\xc8AVN\x84\xda\xf5\x01U\xc0\xeak\xf5?\xa8~[n\x00\\\xf8c\xbb\x87ß®Ac\xf1k\x10VS^\x99\xc7f\x99\x01\xd08\x12\x91\xf9\xe6\xbf\xfa\a\xba\xe7\xf93\xf2e\xed\xb9B\"\x06\xb2\xf20\\\xa5\xc7\x0e\xbbU\xc0Ò§\xf5?\xb8~YN\x00\\\xf8c\xfd\xbf[[\xde\xee\x17n\xcbz\u007f\xca\b\x80\xa6\xc1\xd1\xd8\xdew\xe9\x1c(>\xa67\x0fW\x1eÓ#$\xe2\xc0U|\xecpf_ \xbdY\xff\x83l\xdaR\x03\xc0\xfaM~<p\xf0GE\x9f\x03 \xb3?\"\xf1\xcd?\xf3A\xad\xc1\x0f\xb8\xf2;\xed\xb9Ab\x046\xcb!p\xa4]\xed\x80\xde8Q\xff\x03m\xd2R\x02\xe0\xfc\x1f\x01\xf51\x8c\xa0\x92\xf4s/zjÜ~\t(!\x00\x9a\xf7\aÒ­\xfa\xff\xbe\xbe\xdcp\xbc\xde\xe0wd\aZ\xe5s\xda\xf3\x82\xc4\x14d\xe4Lh^\x1f\xb02&\xb7\xbe\x15\x1b\x00\xe7_o\xf9\xe0\xdb9Hx\xab_\xf4,\xfa\xb8-2\x00\x9a\x0fD\xa8o\xf5[y\x8b\xf6y\xfes\xb5\xe7\x03\xb1\x048\xf244\xb7\x15^\x92\xd6\xff\xc0Wb1\x01pÑ\xfa\u007f\xa7\xa6)\x0e\xff\xc8[\xd4\xdd\x01E\x04@\x98\x87\xff\x92\xc5ZC\x1fp\xa5\x13\x8e\xccÕ\a\xc4B\x90\x96w!+\u007fP;\xf8\x9b\x0f\xd2\xff\xf0\x97k\u007f\x01\xc0G\xfar\x93\x9f\xb8\xd8\xef\xfb\xd8O\x00\xb4|\x02\xa1\xfdÙ¿\xf9`\xbdá?\xe3y>\xa6\x97(\x83\xcd2\x04\xaelW\xf9\x108\x02\xac\x9f\xac\xbf\x10\x94j_\x01\xc0\xe1\xbfS\xbe\x06\xb1\xb1\xcfã¹\x00h\x1a\x80P~\xf3_\u007f\x8a\xdecz\x1d\xe9@\xab\f\xd7^\xf7\t\xd9\x03d\xe5j8J\xdb\n\xbb\xfb\x00+\xa6\xea/\f\xc5\xda[\x00\x9c\xff#\xfd\xbfM]\x0e\xfeX\xda\xeb/\x01\xbd\x04@\xe3\xb0\xf0m\xf2\xb3\xfc\xde\xc2Z\xa3\xf3\xad\u007f\a\xb2r\xad\xf6:OH\x9f\xc0\x91%J\x1f\x90\x82\x8bW\xeb/\x14\xfd\xd9S\x00\\\xfa3\xfd\xbfKS\xde\xe3\x1f\u007fS=\xdd\xcd\xd1C\x004\rB\xa8n\xf5[\xbc\xb6\xb0e\xb9Ö\xe6\xf01\xbd$B #\xfb\xc1U\xdcV\xb8q\xb0\xfe\xa2Ñ{\a\xc0%|\xa4/\x03\xc0\x12\xfb\v\x80\xe6\x83\x10\xaa\xe1\xdf8Lo\xf0g\xe5%<#\xff\xa3\xbd\x9e\x13R\x16\xd8$\xa3\xa1v}@\x15\xb0n\x8a\xfe\x02Ò\xbb\a\xc0y?\xb4{\xf8\xef\x1a\xfc\x16\xbf\x06\xb6\xb9\xc7vÎ»\x05@\xf3!\b\xcd\xc6_k\xcf\u05fb\xad/+Û\x95\xb1\xda\xeb7!F\x80+7\xc2Q\xdaVØ©\x02\x96=\xa6\xbf\xa0\xecnW\x00\x9c\xfb\u007f\xfa\u007f\x8b\xa6\xbc\xd5\xcf^w\x85\xdf\xce\x00h\n\xc97\xffe\xd3\x01G\xed<\u007f\x0eY\xb9E{\xbd&\xc4\x17\xa0\xf9\xd8\xe1\xcc\xfb\x80E\xcd\xfa\vL\xda+\x04\xc0\xb9?\xd4\xff;T\xe5\xb7~\xebM\xed\f\x80\x96\xfd\xa1?\xfc3@f?\xad\xc1\x0f\xf01\xbd\xc4\x06\xe0\xca\xc7\xe1\xc8kZ\x1f\xb4\xadk\xc6b\xe5/\xff\xa2\xeaÆ«\xd6a\xe5/\xfe\xac\xfewh\xfa\xf7i\xcf\xf1\x9b?\x05\xd2\x0e\x90vu\xff\x86\x86Z\xbd\xc1\xefH;\x1a\xe5\x93\xda\xeb2!\x81\x82M\xf2y8:\xd7\a\xe4\x9d*\xdcz\xdd\xcdH$A\x03\xb7\x13?\xb8\xe8%\xe49\xfc\xa9\xb6\xab\xaf\xd5Ü¾w;Z\xe5\x8b\xda\xeb0!\xaa +\x0f\xa1\xf0\xe8\xca\xc0?\x84\x9dN\x15&OÎ`(\xda\xe3\x95g\xbf\x8aN\x0e\u007f\xaa\xe9\xd2yP|Lo'\xb2\xf2\xa8\xf6\xbaKH\xa8\x80+\xbfW\xfa@\xe2?\xab?\xaa>\x18m\xf0\xeas_\xd1_\xfc\xa9Ý¶|Tk\xf0\x03\xae\xfcY{\x9d%$\xb4\xc0\x91C\x91\xd5y\xda`\xa7#Xr\xffWÕd\\\xbd\xf1\xb2\xff\xf0\x9b?\xd5s\xc3\x17\xf4\xb6\xef\xcdJ\aZd\x80\xf6\xfaJH$\x80+\xa7C\xe9\xb1\xc3y\xa7\n?\xbc\xfa>\xf5\x81\x19\x1f;\U00043bff\xc4\xe1Ou\\\xf9S\xdd\xc7\xf4\xb6\xca\xd9\xda\xeb)!\x91\x04\xaeÌ\xe2c\x87'\x9d\xf0|\b\x06h\x94\xed\xc47\xcf\xe29\u007f\xaa\xe0\x92\xa5\x80\xf3\x0e\xad\xc1\x0f>\xa6\x97\x10\x03\xe0yy\x17\xb2\xf2\x82\xd6\a\xf9\x8f\xe9\x01!\x18\xa4\xd1\xf4\xd23_\xe3\xf0\xa7\xc1\xdbt\xa8\xde\xe0\xcfÊ¿\xb0JÞ­\xbdn\x12\x12+\x90\x91\x11P\xdaV\xb8\xd3\x11Ì¼\xedb\xf5\x81\x1a%/8\xedu\xecX\x18\x82a@\xedq\xfd\x19\xba\xb7\xf55KR{\x9d$$\xd6\xc0\x95K\xe1\xea<v8\x9f\xa9\xc2U\x97\xccR\x1f\xae\xe1\xb6\x13\x17\x9d\xfe\x1ar\xf5!\x18\b\xd4\x0eWÜ¡9\xf8w #Wj\xaf\x8b\x84X\x05\x1cY\xa1\xf4\x81G{\xc3{Q3\xe1\xc5\x10\fÛ°Ùo\x9e\xfd\xaa\xfe@\xa0v\xb8h#\x90y\xbf\xd6\xe0\a\\Y\xa3\xbd\x0e\x12b-\xc8\xca\a\xe1\xca\u007f\xb5\x16\x80Ö§G\x87`\xe8\x86\xc7\xef_\xf82\xcf\xf9\xd3`l\x1c\xae7\xf8\x1dy\r\x9e|H{\xfd#\x84\x88\b\x1c\x19\a\xa5\xeb\x03\xf2N\x15\xee\xfb\xe9\xf7Õ\xaf\xb6?\xb9\xec\xbf\x1c\xfe\xd4\u007f\xd7^\xa6\xfd\x98Þ£\xb5\xd7;BH\x0f\xc0\x91\xeb\xb4\x1e;\x9c\xcfT\xe1\xc2)K\xd5\a\xb1\x86\xdf\xe37\u007f\xea\xb7\xcb\x1f\x82\xe2\xf6\xbdyd\xe5z\xed\xf5\x8d\x10R\x04p\xc5QZ(\xf0Êº\x0fahu\xbb\xfaP\x0e\xc6N|\xfbÜ\xf5\x87\x03\x8d\xb1.\xd0\xf2a\xad\xc1\x0f\xb8\xf2\x8c\xf6zF\b)\x114Ë§\xe0\xc8V\xad\x85cÍ£_\b\xc1\x80\xf6\xff\x9b?\x9f\xeaG}s\xe3\x04\xbd\xed{\x1d\xe9\x80+\ai\xafc\x84\x90\n@VN\x84\xd6\xf5\x01\x99*\xdc\xf2\x83[\xd5\a\xb5\x1f\xdf\xfc\xbfq\xd6k\xd8\xc1[\xfd\xa8\x1f\xae\xfe\x81\xee\xf6\xbdY9Y{\xdd\"\x84\x18\x04\x8e\xd4A\xe9\xb1\xc3p\x05\xa7\x9c\xd2\x12\x82\xc1mf\xf8\x9f\xf5\x957\x90\xe7\xf0\xa7\xa6]\xfa\xb4\xd6\xd0\a\\\xe9\x84#\xf7j\xafS\x84\x10\x1fAV\xfe\xa8\xb5\xc8\xfck\xe5\x81!\x18\xe0\x95y\xee\xa9o\xe8\x0f\n\x1a?[\x0e\xd4\x1c\xfe/h\xafK\x84\x90\x80@F\x0e\x87\xe2\xb6Â©{NW\x1f\xe4\xe5x\xed\x05/s\x87?j\xd6\r_\xd4>\xcf?P{=\"\x84(\x00G\u0382\xe2c\x87\xaf\xbb\xeaA\xf5\xa1^\xac\xffw\xf1K\xfcÙ\x9as\xe5Í\xbb\x8f\xd6\xe0ß\xac\x9c\xab\xbd\xfe\x10BB\x00\xb2\xf2\xb8\xcaB\xe4\nv\xb4\xbc\x1d'|\xf1\xb7\xea\x03\xbe\xbfo\xfe\xbcÏ\x1aq\xc9\"\xc0y\x97\xce\xe0/\xf8\xa4\xf6zC\b\t\x19\xd8(\xef\x81+\xff\xd0Z\x98\x9e]0X}\xd0\xf7\xe4\xf7/|\x89Ã\x9a\xb1)\xa19\xf8\xff\x8b\x8c\xbcW{\x9d!\x84\x84\x18\xdd\xc7\x0eW\xe1\xc9\xdb.Q\x1f\xfa]\xfe\xf0bn\xefK\r\xb8\xfel\xed\xed{\xf9\x98^BH\xf1\xa0U\xbe\x05\xc5\xc7\x0e_v\xe1|\xc5\xe1ß\xef\x9c\xff2\xcf\xf9\xd3\xca\\~\x8f\xde\xe0w$\aG\xae\xd5^G\b!\x11\x06\x8e,TY\xc0\\\xc1\xeb\x1bÞ\xf1\x13_\b|\xf8_t\xfa\xeb\xfaÃF\xd7\xc5k\x80\xcc~:\x83\xbf\xe0\"\xedu\x83\x10\x12\x13\xd0$\x1f\x86#\xedZ\vZffm`\x01p\xc6ä­¼Õ\x96o\xc3(\xbd\xc1\xef\xc8\x0e\xb8\xb2\xbf\xf6zA\b\x89!pe<\x14\x1f;|\xf7\x8d\xff\xe7\xeb7\xff\x8b\xcfx\r\x1d\vC0Dh\xf4\\s\x85\xe6\xcf\xfd\x1d\xd8$\xc7h\xaf\x0f\x84\x10\v\x80+?\x86Ò¶\u009dN\x15\xa6\x9c\xb9\xca\xf8\xf0\xbf\xe6\xbcW\xf8Í\x96\xee\xb2Ç¡\xf8\x98\xdeN\xb8\xf23\xed\xf5\x80\x10b!pe\xbd\xd2\u0087\x17W}\f\xa3\x8ez\xd9H\x00|\xe7|>Ò\x96\xe8\xa2F\xa0\xe5cZ\x83\x1fp\xa5I\xfb\xf3O\b\xb1\x1cd\xe4\xd3P\xdaM\xb0\xd3\x11\xac~\xf4Ä\x86\xff\x8f.\xe1}\xfe\xb4D7\x1e\xa3\xb7}oV:\xd0 \x9f\xd1\xfe\xdc\x13B\xc8.\xd0*\x93\x91\xd5{\xec\xf0O\xbes\x17\x87?\xf5\xd7U7h?\xa6\xf7T\xed\xcf9!\x84\xf4\xca\xce\xc7\x0ek-\x92\xf8\xeaW3E\x9d\xf3\xff\xce\xf9\xdcÞ\x16\xe9\xd29\x80\xf3v\xb5c\x1a\x8eÜ§\xfd\xb9&\x84\x90\xa2\x81+\xcfk-\x98\u007f[\xf6i\f\xa9\xde\xd6\xe7\x05\u007f\xeaC\x85F\xc0,\xd0\xfc)\xbd\xc1\xefÊ\x01\xa9\xd2\xfe,\x13BH\xc9\xc0\x91\x04\x14\xb7\x15^x\xf7\x99\xdd\x02\xe0\xe23^\xe3\xd5\xfe\xb4\u007f7\x9c\xa4\xf9s\xffv\xb4\xca \xed\xcf/!\x84T\f\\\xb9\x00\x8a\xdb\n\u007f\xe7\x9bÓHv\xe2\x8c\xc9[y\x9f?\xedÛ\xbf\xd6\u07be\xf7\x12\xed\xcf+!\x84\x18\a\xaeLW\xfaF\x85\xedM\xefC~qZ\u007f\xc0\xd0p\xbad1\x90\xf9\x80\xd67~ +3\xb5?\x9f\x84\x10\xe2+\xb8A\xf6\x81#\xaf\xa8-\xb4Í\xd6\x1f64\\6\u007fVo\xf0;Ò\xa7\xe4mÚKB\b\t\f\xb4\xca(d\xe5M\x9dE\xb7\nX{\x9e\xfe\u087a\xae\xbdH\xf7<\xbf+\xd5ÚCB\bQ\x03\xae|\x1b\xae\xe4t\x16\xe1*`\xc5T\xfdAD\x83u\xf9}PÜ¾7\x0fW\xbe\xaf\xfd\xb9#\x84\x90\xd0\x00G\x96(-\xc8@\xcb\a\v\x8fp\xd5\x1eL\xd4_\x17\xad\x05Z>\xa25\xf8\x01GVj\u007f\xce\b!$\x94`\x93\xbc\x0f\x8eÎ¶\xc2p\x04h\x1a\xa8?\xa4\xa8?6\x0e\xd6Û¾×\x0e\xac\x97\xf7k\u007f\xbe\b!$\xf4\xa0E\x8e\x83\xd2\xf3\x05\xe0T\x01k\xae\xd6\x1fXÔ\xab\xbf\xab\xbb}\xaf#\x9f\xd7\xfe<\x11BH\xe4@VnBá§\n\x8bw\x15\xb0\xecQ\xfd\x01F\xcbs\xd9t\xdd\xed{\xb3r\x8b\xf6\xe7\x87\x10B\"\x0f\\iQ[\xc8[>Zx\xf4\xab\xf6@\xa3Å¹\xa8\th>Po\xf0\xbbÒª\xfdy!\x84\x90X\x81\xcd\xf21\xb8Z\xb7\r\n\xd00F\u007f\xb8Ñ¾m\xa8\xd1;\xcf\xef\xcavd\xe4@\xed\xcf\t!\x84\xc4\x16\xb8r\n4\xaf\x0fX\xf5#\xfdAG\xf7tÕ\x9a\xe7\xf9w\xc0\x95Óµ?\x17\x84\x10b\rp\xe5~\xa5\x05\x1fp\xde\t,\x9d\xab?\xf8lw\xc9\x02 \xf3^\xad\xc1\x0f8\xf2\xb0\xf6\xe7\x80\x10B\xac\x04\"Up\xe5Oj\x03\xa0\xf9\x13@:\xab?\b\xad3[\xd8\xd2Y\xeb}\xcf\xca\v\xb8A\xf6\xd1>\xfe\t!\xc4z\xd0\"\a\xebm+,\xc0\xc6\xe3C0\x14-qÃt\xcf\xf3;r\xa8\xf6\xf1N\b!d/\x90\x95\x8b\xa0\xf4\xd8a8U\xc0\xca[\xf5\ad\\]\xf1\x1b\xcd\xf3\xfc9\xb8\xf2\r\xed\xe3\x9b\x10BH?\xc0\x95YJ\x83\x02È¼\x1fX\xb2T\u007f`\xc6\xc5\xc5Ë\xcc\a\xb5\x06?\x90\x95\xb9\xda\xc73!\x84\x90\x12\xc0*y;\x1cyCmp4\x1f\xac?<\xa3n\xd3az\x83ß\x1d\xc8\xc8;\xb4\x8fcB\b!e\x82gd0\x1cÙ®3D\xaa\x80ug\xe8\x0fÒ¨\xb9\xee\\\xdd\xc7\xf4fe\x98\xf6qK\b!\xc4\x10p\xe4:\x14\x1eÅª0T\xaa\x80\xe5\xf7\xeb\x0fÖ°\xbb\xfca(>\xa6\xb7\x13\x8e\\\xaf}\x9c\x12B\b\xf1\t\xb8\xb2\\i\xc0\x00-\x1f\xe6c\x87{r\xf1\xba\u0096\xcbZ\xef\x8b+k\xb4\x8fKB\b!\x01\x80g\xe5\xfdP\xdbMP\x80\xa6!\xfaC7,6\rÓ¼\xad\xaf\x03\x19\xd9O\xfbx$\x84\x10\x120\xc8\xcaX\xb8\x8a\xd7\a\xac\xfd\x86\xfe\x00\xd6rÍ\xba\x8f\xe9u\xe5(\xed\xe3\x8f\x10B\x882p\xe5WJ\x83\bp\xde\x06,{B\u007f \a\xe5Ò§\n[)k\xbdÞ®Ü®}\xbc\x11B\b\t\x11\x80T!+\xae\xda`j\xfeD\xe1Q\xb6\xda\x03\xda/\x175io\xdf\xdb\x06p\xfb^B\b!\xbd\x00O\x0eÐ»mP\x80\x86j\xfdamÚG\xebn\u07fb\x85\x8f\xe9%\x84\x10R$p\xe5$h](\xe8V\x01\xab\u007f\xa8?\xb8+uÕ\xa1x[\xdf\x0e\xb8\xf2U\xed\xe3\x88\x10BHD\x81#\x0f*\r0 \xf3\x1e`\xe9|\xfdA^\xaaK\xea\x81Ì¾Z\x83\x1fp\xe5Q\xed\xe3\x86\x10BH\f\xc0S\xf268\xf2/\xb5\x81\xd6\xfc\x19D\xe3\xb1Ã­@\xf3!z\x83ß\x97\xb1JÞ®}\xbc\x10B\b\x89\x19\xc8\xc8!\xaa\x8f\x1d^\xff\xc5\x10\f\xf9^\\\xff\x15\xed\xed{\x0f\xd3>>\b!\x84\xc4\x1c8r\x1e\xb4\xb6\x15v\xaa\x80\x95\xbf\xd0\x1f\xf8]\xae\xfc\xb5\xe6\xe0\xef\x84#\x17i\x1f\x0f\x84\x10B,\x03\xae\xccV\x1a|\x85m\x855\x1f;\xbcx\xb9\xf6\xf6\xbd\v\xb4\xdf\u007fB\b!\x16\x03\xc8\xdb\xe1h\xdd- @\xd3!\xc1\x0f\xff\xa6\xcf\xe9\r~G:\xf8\x98^B\b!\xa1\x01\xad2\x1c\xaa\xdb\n_\xe0\xff\xe0_{\xa9\xde\xcf\xfdYÙgd\xa4\xf6\xfbL\b!\x84\xf4\b\\\xb9F\xedÛ±[\x05\xac\x98j~\xf0/\xbf\xb7\xb0e\xb1Ö¿++\xd7j\xbf\xaf\x84\x10BHQ\xc0\x95\xf5j\x03\xb3\xe5\x80\xc2#v+\x1d\xfc\x8b\xd6\x17\xb6(\xd6\x1b\xfcM\x80Ti\xbf\x97\x84\x10BHI\xa0Q>\x00W\xf1\xb6\xc1J\x1e;Ü¨\xfa\x98\xde\xed|L/!\x84\x90È\xac\x1c\r\xadm\x85\x9d*`\xf5\xb7\x8a\x1f\xfc\xab\xafÕ¼\xado\a\\9V\xfb\xfd\"\x84\x10B\x8c\x02WnT\x1a\xac\x80\xf3n`Ù£\xbd\x0f\xfeeÓ\xcc\xfb\xb4\x06?\xe0\xcaÏµ\xdf\x1fB\b!\xc47p\x83\xec\x03G\x9eU\x1b\xb4Í\x04\x165\xefv\x9e\xbf\x05h>Ho\xf0g\xe5\x0fxJÞ¦\xfd\xbe\x10B\b!\x81\x80\xf5\xf2qh^\x1f\xb0q\"\xb0\xe1\x04\xdd\xf3\xfc\x1b\xe5\x13\xda\xef\x03!\x84\x10\xa2\x02\x1c\x99\fGrj\xdf\xc0\x837\x0fGN\xd3~\xdd\t!\x84\x90P\x00G\xee\t\xc1p\xf6\xdb\a\xb4_gB\b!$t\x00\xf26\xb8\xf2\xdf\x10\fjÓ¾\x04\xf01\xbd\x84\x10BH\x9f\xa0I>\a\xadm\x85M\xeaH\a6\xc9\x00\xed×\x10B\b\x89\x14p\xe5Bd\x95\x1e;\\\xb9\x97j\xbf~\x84\x10BH\xa4\x81#3C0Ð\xfd\xd6?G\xfb\xf5\"\x84\x10Bb\x032\xf2\x0edC}Z\xa0\x03\x9e\xbcS\xfbu\"\x84\x10Bb\t\x9e\x91\x91!\v\x81\x0e\xb4IR\xfbu!\x84\x10B\xac\x00Y\xf9_\xf5á\x1fi\xbf\x0e\x84\x10B\x88u@\xa4\nYY\xa60\xfc\xd7\xe0\x06\xd9G\xfb\xdfO\b!\x84X\r\xfe \xfb\xc1\t\xe4\xb4\xc0v\xfcI>\xa8\xfd\xef%\x84\x10B\xc8n\xa0U&\xa0\xf0H]\xb3\x83ß\x1cZe\x92\xf6\xbf\x8f\x10B\b!}\x80\xac\xdcbl\xf8g\xe5\xd7\xda\xff\x1eB\b!\x84\x14\xc9\xcem\x85\xb3\x15|\xeb\xf7\xb8}/!\x84\x10\x12Q\xe0\xca\xc7QÊ¶\xc2YÙV>\xa6\x97\x10B\b\x89\x05p\xe5\f\xb8}<v\xb8\xb0\xe5\xf0\x14\xed\xbf\x93\x10B\b!>\x00G\xee\xeb\xe1\xe7\xfe\x87\xb5\xff.B\b!\x84\xf8\f o\x87#\u007f\x81+\u007fEFÞ¡\xfd\xf7\x10B\x82\xe7\xff\x03#\x94\xff00\xd1\xddr\x00\x00\x00\x00IEND\xaeB`\x82"
var _Assets8adebf81a81a55248a107972d373b02d60a4d498 = "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\xc0\x00\x00\x00\xc0\b\x06\x00\x00\x00R\xdcl\a\x00\x00 \x00IDATx\x9c\xed\x9dy\x94\x14\xd5\xf9\xbf_\x90\xdd%\xe2\x12\x15×\xe8\x80\x11\x03#\x03\x8a\xe2\xa0\x11qCA\x14\x1c\x16Q\x83h\\\x93\x98\x18\xcdbT\xdc\x12\xf3\x8d\x9a\xc4\x18\x04\xc1\x1dD%\xa0L\xcf0+\xb3/]U=\x03\xd3?\x8d\xc6h\x04\x11\xa3FAv\xa1\x9f\xdf\x1f\xb7{\x86ef\xfa\xf6R]\xd5\xd3\xf5\x9e\xf3\x9e\xe39\xeatÕ­\xcfs\xebs\xef}\xef-\x11/R\x1e \xdd\xf1K\x16\x96\xbc\x8c)Kh\x96,\x16\xcb~N_\x97\x17^\xd8\x1e\x04\xe4$\fy\x00K>\u0092P8\xd7`È£\x982\xc8\xe9\xeb\xf3\xc2\v[\x82\xa0\xf4\u0094[\xb0$\x88);\xb1\x84\xbdr'\x96\xfc\x13Sn\xa1V\xfa:}\xbd^x\x91\x94\xa0\\\xfa`\xcai\x98RÚ\xe8\xdbOS\xaa\xf0\xcbPÊ¥\x8f\xd3\xd7\xef\x85\x17q\a\x86dc\xca\x1cLÙ¨-\xfe6\b\xb6\x10\x909\x182\xc2\xe9\xfb\xf0\u008b\x98\x82f\xf96\x96<\x8a)\x1fu`wts'\x96\xacÅ'h\x96o;}_^x\xd1i\xd0,\xfb\xd3 \xa3\xb0\xa4E\xa3\x87\ac\u007f0\x0eP\xff\x1c\x1d\x86 ~\x19CP\x0ep\xfa>\xbd\xf0b\x8f\xa0\\z`Ê\x18\xf2\x1a\x96\xec\x8a.\xfe\x1eP3\x06J\x9e\x86\xe2yPs\x01\x98\xbd\xa3C\x10\x90]X\xb2\x14K.\"(\xbd\x9c\xbeo/\xbc\x10\x9a\xe5\x18\x02\xf2<\x96\xfcWK\xfc\x8d'@é \xa0\x16|-*\vj\xa1\xf4Ih\xf8\xaeÎ \x14\xfe\xadW\xb0\xe4x\xa7\xefß\f\r\f\xf9\x16\x96\xfc\bK\xbeÐ²;\xfe\x83\xa1r\x06\x14Ô/\xd8A\x9aPy-\xf8\x0fÑµE_\x13\x90\x99\xac\x92\xfeN\xb7\x87\x17\x19\x12\x04\xe4`L\x99\x8a%\xc5Q{\xfc\x88\xf0\xab&B\xf1K\xe1\x1e\xbf#\xf1G\xb2\x05\x8a\x16A\xd5\xd5\xe0\xef\xaf\x03\xc2.,Y\x89)\xd7\x12\x90\x83\x9dn\x1f/\xbap`\xca L)\xc0\x94\rZ\xb38\xf5\x83\xa1x>\xf8\f\r\xe1\xb7\xf36(^\x00u\xc3tg\x8c\xbeÆB\f\xc9v\xba\x9d\xbc\xe8B\x01\xd2\rK\x0eÇ\xd9:\x1e\u007f\x97Ñ\xcf\xca\a\xf0\xf5\x8a\xdf\xc4!\xfa\x0e\xb2\xec\x01h<\x02\xcc\xee: \xec\" \x8fa\xc9\xe1\xdc'Ýn?/\xd280\xe4(,\xb9\rSV\xe9\x88\u007f]É±\xcc}\xf8.\xc6^\xfc.7O\xfd\x8a\x8f_\xf9g\x92 h\x81\x15>\xa8\xb8\x11\x1a\a\xe8\x0e\x94W\xd1$?\xa5V\x8ev\xba\x1d\xbdH\xb3\bWk^\x86%~,\xd9\x1cMp\xdf\xf8{\xb0\xecoS\x19?!\xc0iglcP\x0e\f\xca\t1y\xfcf>z)Y\x10\x04\xc1\xd7\x04+\x96A\xcd80{ê°\x05K\x9a\b\xc8\xe5\x94K\x0f\xa7\xdb\xd5\v\x97\a\x86\xf4Ä\xa30\xe5\xd9\xf0\x9c{\xa7\x02\xdb\xdeØ5E\xc7sÛ¬\xd7Â¢\xdf;C\xdc:\xfd+>}\xf5\x9d$B\x10Î\xa7\xa0\xf1\x18=\x10Ô½\xbc\x8c%\x030\xa4\xa7\xd3\xed\xec\x85\v\x83f\xf9\x0e\x01y\x90\x80\xac\xd1\x19t\xbe\xb7|\x10\x8f\xde\xf3\u007f\x9c1\xfa\xb3\x0e\xc4\xdf\x06\xc1MS7\xb0.ivh\xb7,\xa8\x87\x95wA\xc3\xc9z\x03å¬Ç\x87\xf0K\x96\xd3\xed\xed\x85K\x82\xa0\xf4\u0090\x9b\xb1\xe4=,\xd9\x1eMD_\xd7\x1c\xc8\xdf\x1f\xbc\x87\x1f^\xf8oN\x1d\xb1#\x8a\xf8\xdb \xb8z\xc2fÖ¼l\x03\x04\xbef(,\x86\x8a[UiEt\x10\xb6\x13\x90\xf7\xb1\xe4g\xdejr\x06\a\xefIo\f\x19H@\xca\u0083\xc6N\xe7\xf3CFo>\xf0\rf\xd2U\xf5\x9a\xa2\xdf\x17\x82\x9b\xa7m\xe0\xd3Ev@\x10\u03a2EP\u007f\x1a\x18}t\xd6\x0fBXR\x8e)\xa7ye\xd7\x19\x14 Ý±\xe4L,y\x1aS\xbe\x8c\xdac\x9a\xdd\t\xd5\xe5P9\xe7\t.\x18\xbb!N\xf1\xb7Ap\xe3\x14\x9b\xecPkZP\xfa{\xa8\xcbQ5G\xd1\xdf\b_a\xc9<,9\x13\xbcm\x99]:@zbÊX\xb2\x16K\xa3L\xd98\x80P\xf9=T\xfe\xc5`Ì\xad\t\x8a\xbf\r\x82\xbc\t\x9bl\x86`5\x14V@\xf9\xbd\xe0?Ho\xed@\x95]?\x86Oz;\xfd\x9c\xbcHr`H?\x9ad,\x01\xf9w\xf4\x1e_\xc0\xe8\a5c\b\x15T\xf0\xf6\xfc\u007fq\xde\x0f\xb7'I\xfcm\x10\xfcx\xea\x06\xd6\xdbi\x87Z\a\xcau\xaa\xda\xd4\xd8_\xb7\xbeh=\xa6\\H\xb3\xec\xef\xf4s\xf3\"\xc1\xe0=\xe9M@.& \xafb\xc9\xd7\xd1{\xfc\xbePs>\x94\xfe\x85\x90/@Õ\x1fp\xfe\x98d\x8b\xbf\r\x82Yy\x1b\x93\xb8X\xd6Y\x06T\xe9u\xf5\x85\n\xee\xe8\x10l\" K\xc2\xeb\a\xde\xf8 \x1d\x83*\xe9\x8f%/\xa0J\x87\xa3?\xf4\xc6Ã¡\xf4\t(\xa8%\x94\x1f\xa4\xea\xc9\x0f\x183f\x9bM\xe2\xdf\xcd\x0e]\xb1\x89O\x16\xa6\x02\x82\xa0\x9a6-}B\xad\x1fè´%\x9f\x13\x90\x17i\x94#\x9d~\x9e^h\x06\x019\x18K\xae\xc1\x92\xff\xe9ÙoA\xd5T\xd5K\xfa\x82\x84\xf2\x83\xbc=\xff_6\xf6\xfc\xed\xcc\x0e\xa5\xca\x0e\xb5f\x13T^\xaf\xee\xdd\xec\xa67P\x0e\xc8L\x02r0H7\xa7\x9f\xb1\x17\xed\x04\xb5\xd27\\\xa6\\\x81\xc6|>ÆP=\x11\x8a\x16\x82oU\xab\xf8+\x9f\xfc\x90\xf3\xceO\x95\xf8\xdb \xb8!o#kmY'\xe8(W\xab{\xaf\x9a\f\x86\xd6@\xf9\x1b,\xa9  \xd7bH?\xa7\x9f\xb7\x17\xbb\x05\xa6\x9c\x8e%\xa5\x98\xf2\x95V\xaf_7,\\\x9f\xdf\xd8*\x88P~\x90\xca'>dL\xcaz\xfev\xecÐ\x14Ú¡\xd6\xf4CÑ«\xe1iS-[\xb4\x01K\xaa\xb1d\x98\xd3\xcf=\xa3\x83Å²\x1f\x86\x1c\x86)\xbf\b?\x94(\xc2\xdfO\xed\xb4ZyG\xab\xdd\xd9]\xfc\xef\xcc\xff\x17\x17\\`\xb7\xe7\x8f\x0e\xc1\xadÓ¿\xe2\xd3E6\xd4\x0e\xe9Ø¢\x95w\x81\xffP\xd5V\xd1;\x92\x8dXr/5\xf2m\xefX\xc7\x14\a\xefË·\xb0\xe4g\x98\xb2Zk0\xe7?\x14*oT%\xc5{=\xf8P~\x90\x95O|È¹I\x9f\xea\x8c\x1f\x82Yy\x1b\xf9\xcfK\xef:\x00A\x10\n\x8bT[5\x1e\xa9;P~\x1bK\xeeÄÃ\xd6EF\x04\x96\\\x14\xae\xcfßF\t\x03\xd5\x17Ã\xe5\xe0\xb3\xda\x15\u007f\xe5\x13\x1f\xa6p\xc0\xab\x0f\xc1\xe4\xf1\x9b\x1d\xb0C\x91\xb4TgQ5Ag\x90\x1c\n?\x8b \xa6LpZ\x1f]2(\x97\x1e\x04\xe4\x04L\x99\x8f%Û¢\xbf\x9e{@Ã±P\xfa8\xf8\x9a\xdb}È¡\xfc \xff\\\xf0\x1e\x17\x8eu\xda\xf6t\f\xc1\xed\xd7|\xc5\u007f\xed(\xa5\xd6\xce\xd5jÚ´\xe1D\xdd\xfd\a;0e\x01\xf5r\x92\xb7\xff IA\x93\x9c\x1c._\xf80\xba\xf0\xbb\xa9\xd2\xe0\x95wA\xe1\xca\x0e\x1fl(?H\xf9\xe3\x1f\xf2Ã\xcf\xf6\xc4\x0e\xc1MS6\xf0\xe1\x8b\x0eÙ¡V[T\tå¿\x86,\xddi\xd35\x04\xe4\xf7^\xd9u\x82\x81\x9a\xcf\xff'\x96\xec\xd0\xf2\xa3\x95\xd3UipxZ\xb3#\xf1W<\x91\x0e\xe2o\x83`\x92\xa3v(\x92\xabU\xdbV\xceÔ-RGB\xbe\x8b)7:\xad\xa3\xb4\n\x82Òf\x19\x81\xa5y\x9a\xb2\xd9KMk\x16-\x8e\xfa\x10C\xf9A\xdeu\xb5\xed\xe9\x18\x82;\x1c\xb7C\xbb\xe5\x8ae\xaa\xcd\r\x8d\xd3\xecT\xd6b\xca\x19^\xa1]\x94\xc0\x90\x11\xa82\xe5Ï¢\v\xbf;\xd4\r\x87\xb2\x87\xa2\x1c6\x15\xc9\x16\xd6/|\x87\xbbg\xfe\x8fi\x137ÙW~n\xdfß\xb8\x89y\xf7|\xc27\xffhr\x1e\x00_P\xb5y\xd9\xef\xa1n\xa4\xeei\x15\x9fa\xc9<L\x19\xe5\xb4\xce\\\x17\xd4J_\f\x99\x1d\xf6\xf9\x9d\xcf\xecX\xa2\x8a\xd6\xca\u007fÕ©\xcf\xdf[\xfcä·°e\xe9\xffã¿¯\xbecO.\xae\xe3\xbf\xf97\xd9\xf7\xf7Ã¹\xeb'\u007f\x82\x17+\x9d\a\xa0\x15\x84J(\xff\xb5\xeejr\bUv\xfd\x10\xf5r\x90Óºs<h\x96\xfd\t\xc8\x18b9M\xb9\xe6\x87j\xaeZ\xf7\x01å·´\xa5m\"hPe\x15\xf5\xa7\xd8/\xb8\xc9?\x83+\xef\x80E\xb5\u038b\u007f\xf7,,\rW\x9bj\x97]\xbf\x8d!\x97dl\xd95\x86\\\x80%o\xa0\x8e\xee\x88>\xbbSs>\x94\xfc\x9d\xbdWq\xb5\x01\xb0\xed\xc1WA\xd5Uj\xf5\xb4!+5\x00d\xe5\u0084[\xe1\xa5*ç¿G6C\xc9\x1c\xa8\xb9H\xd7\x16mÇ%\x98r\xa9\xd3zLY\x10\x90\x13\xb0\xe49,\xf94\xaa\xdd1\x05\x1a\xbe\x03\xa5\u007f\x0e\x9f\xa6\x1c\xe3\x03\xb1\xbdç¯\x9a\xf3\xda\x1ev*\x01\xc8Ê13\xe0\x85\n\x17\b\u007f\xefv\xa9S\x9dU\xc3wt\xf7&\xff\x17K\x16\x11\x90\x13\x9cÖ§m\x11>Tv2\x96Æ±#f\xb7p\x99\xf2UP\x10G/\x972\xdbs\xf9\x9e\xf3\xe2\xa9\x06 +\x17&\xde\x06\v]f\x87ZÛ¨JMM\x1b\a\xeb\xae\x1f\xacÅ\xebX%\xfd\x91.Rv\x1d\xfe:\xe24,)\xd7\x1b\xe0\xf6R%\xbaE\v\xe3l\xf8T\x88\xbf\x1a\xaa&\xed[4\xe6\x04\x00Y\xb90\xe1\x16\x17Ú¡Ý²\xe8\xf5pÙµ\xd6n\xb4\x10\x96\xd4`\xc9\xf4\xb4/\xbb\xa6Q\x86`I>\xea\xe4\x81\xe8v\xa7n(\x14\xbd\x00\x05\xfe\xf8\x1b;\x15â¯¹\xa0\xfd\x8aI\xa7\x00\xc8Ê\v\xae\x85\x17]h\x87Z\xdb\xcd\x0fE/\xeb\x96]\x87P\x9bpV\x90\x8ee\u05ec\x96#0\xe5w\x044\xbe\x8ehv\x03\xff\x11\xaa|\xc1g&.|[\xc5_\x0f\xd5\xe3:~\x9d;\t@V.\\q\x1b,\xacq^\xec\x9df@=\xeb\xc6\x01z\x03eS\xb6b\xca}\xd4\xcaÑ®\xb7E4Ê\x18r;\xa6XZv\xc7\u007f$T\xcc\nWk& Ü\x88\xbf\xa6m\xb6\xa7\xa3\xfbq\x1a\x80\xac\\\x18\u007f3\xbc\xecb;\x14\xc9B\x1fTÜ¢4\xa0c\x8bLYM@~\xee\xda\xfd\xc94É¹XR\x8d)[5n\bj\xcfS\xdeÐ\x84\x95\xcdT\x88_gj\xcf\r\x00d\xe5\xc2\xd8k\xd3\x03\x02\xdf*\xa5\x81\x9a\x8bt \x00\xb5Õµ\x06C.qZ\xef\"\x12>eÍ\xef\x85Ë5^g\xfb\xa9j\xcd\xd2'\x93Ô-\xf6\xf7\xfe\x05\xf5P}\x99\xde,\x86[\x00\x88\xac\x13\xbcR\xed\x02\x91kf\xf1ß6\xf4N\xb3\x03K\x16\x12\x90\x93\x1cÛ\x86!\xdf\r\xfb\xfc\x0f\xb4\xecN\xc3wa\xe5\xcfc(_\x88A\xfcv=\x94\x82Z\xa8\xbeBwQ\xc7]\x00d\xe5\xc2\xe5?v\xf7\xec\xd0\xdeY\xb8\x12\xca\xefQ\xed\xa8c\x8b,\xf9\x90\x80<H\x93\x9c\x9cJ\xe1\xf7Ä\x1b\t\xc8jL\xf9&z\xaf\xdf\v*\xaf\x83\x15\xf9\xe0[\x9d<\xf1\xfbR!\xfe\x8b\xf5\xc5\xefF\x00\"v(\x9d\xde\x04\xbe\x16XQ\x18>\xb6\xa5\xafN\xbb\u007f\x83)\xef`\xc8M)9ÄF9\x96h_M1E}\xf8\xb9\xfe\a\xe1\xd3\x17\x92\xdcH)\x99í¡\xe7w3\x00\xe9h\x87\"Y\xb4\b\xea\xb3\xc1\xd4:\xedz\x1b\x86\fv\x1e\x00S\x94\xf0\xcb\x1e&\xbe\xaf#j\b\xdf\xee\x01o\xf5e\xb1\x8b\xdf\xcd\x00Dì\xaaH\xb53\x00e\x8f\xa8\xfd\a\x9dC\xe0\x02\x00\xfc\x87)\x0fWXF\xf2\xecN$S1à­\xea\x8bt\x97\xed\xd3\v\x80\xb4\xb4C\x91\\\xad\xc6\ae\xf7\x81\xffp\x97\x02\xe0?$\xec\xf3mj\x84TØ\xaa\xab\xe2\xeb\xf9\xd3\x05\x80\xd6\xda!\xb7/\x96u\x92+|\x1d\x9dm\xea4\x00\x03H~\xaf\x9f*\xf1W\x87Wx5\x0e\x84Jw\x00\"vè\u038b9\xae\\\xdd\xd1,Q\x17\x04 ?E\xe2\xaf\x19\x1b\xbf\xedIG\x00\xb2rU)u\xbaÚ¡\xcc\x01 \x05%\xcdU\x93\x13\xef\xf9\xd3\x11\x80\xac\\\xb8\xea\x0e\xf7\x96Rg6\x00\xa9\x98\xed\xa9\n\xd7\xf3'I\xfc\xe9\b@V\xae\xaa\x1dz\xbe\xdc\x05\xc2\xf6\x00P\x992\xdb\xf3\xc3\xe4Øt\a +\x17\xc6\\\x93&\xb5C\x19\x01@*lO;\x9bY2\x19\x80\x88\x1dr\xdbF\xfb\x8c\x02 %\x8b\\UP5\xd1\x1e\xf1\xa7;\x00Y\xb9j\xc5\xd8Íj\xba4\x00o\xad\x82\x9b\x1f\x86\v\xae\xb3/\xc7\xe6\xc1\xc5g\xc0%9\xb6\xe4\xa7\xe3&2e\xc2&[s\xfa\xa8\xf7\x991l\x95mY1\xf1\x95\x14}\xb8\xcf\x03`\xdf|\xdd\x0f\x17^\a\x03G\xdb\xd7\xcbÙk\xbe?\xc5\x05\xc7(ÆCr\xb61'\xfby><u\x86\xbb\x8ea\xcc(\x00|Ax\xb5\x1e\xae\xfa\t\f:\xd7qAg\n\x00Cs\xb61?{\x1e[\x06\x8e\xe5\x83Sg0('\xc4\xcd\xd3\xec\xfe\xa2\xbd\a@\xfb\x99\xdf\x02\xaf\xd4\xc0\xb8\x1b\x1d\x17t\xa6\x000'\xfb\x05\xb6\f\x1c\vY\xb9a\x00`PN\x88\xab\xc7of\xcdKn\x83\xa0\xab\x03\x10\xc97\f\x18{]ZÙ¡t\x03`\xc80e{v\xbf\x876\x00\x14\x04\xb7Mw\x9b\x1d\xca\x14\x00|A\xb5Jy\xd5\x1d\xa4\x8b\x1dJ'\x00\x86\xe6lc\xfe\xd0y\xad=\u007f\xfb\x00(\b\xdce\x872\t\x804\xb3C\xe9\x04\xc03\xd9Ï³u/\xf1\xb7\x0f\x80\x82 o\xc2\xe6\x14\u007f\xc7\xd8\x03\xa0-\x97\x98pÑ\\o\x87\xd2\x01\x80!Ã¶1\xf7\xf4\xe7:\xbc\x87\xf6\x01P\x10\xdc2Í©O\xb8f:\x00\xbe\xa0\xb2CWÞ\x9b\xed\x90\xdb\x01\x18\x9a\xb3\x8dgÛ±=z\x00(\bn\x9a\xb2\x81u\x8e~\xae)S\x01\xc8oQå»\xb9\xd7\x0e\xb9\x1d\x80gNo\xdf\xf6\xe8\x03\xa0 È»b\x93\x83c\x82L\x05 \x92K-\xb8x\xa6+\xed\x90;\x01\b1d\xd86\x9e\x1d\xf6\x1c!\x8d{\x88\x0e\x80\xfa\x9b7O\xdb\xc0\xfaEN@\x90\xe9\x00\xf8\x82\xb0\xa8Nm\xeds\x99\x1dr#\x00C\x86mc\xee\x90\xcemO\xec\x00(\bf\xe591;\xe4\x01\xa0\xec\xd0\xcbU\xae\x9b\x1dr\x1f\x00!\xe6\x0e{\x8e-\x03\xc7j\xf5\xfe\xb1\x01\xa0\xfe\xfe\x94+6\xa5\xf8M\xe0\x01ÐË\xe0\"\xf7\xd8!\xf7\x00\xa0l\xcf\xdca\x1d\xcf\xf6$\a\x00\xf5[\xa9\xb5C\x1e\x00{\xe6\xab\xee\xb1Cn\x01 VÛ\x18\x00\n\x82Yy\x1bS\xb4N\xe0\x01\xb0gæ·¨\xf3/\xc7\xdd\xe4\x01\x10\xceg\x87-\x88\xc9\xf6$\x0e\x80\x82 /%v\xc8\x03\xa0\xfd\\\x1ap|v\xc8i\x00\x86\xe6l\xe3\x99\xec\xe7\xe3\x12~\xe2\x00(\bn\x9bn\xf7b\x99\a@Ç¹\xb8\xde\xd1\xc52'\x01\x182L-rE\x9b\xe7\xb7\x17\x00\x05\xc1\xac\xbc\r|\xf4Ò»\x1e\x00)\xcf\xfc\x16u\xfe\xe5\xa5\xce\xcc\x0e9\t\xc0\xbcÓ\x8b\xcb\xf3'\x1f\x00\x05\xc1\xe4\xf1\x9b\xf9Ä\x15c\x0f\x80\xe8\xb9Ä\x8bS_;\xe4\x04\x00\x11Û\xac{H\x0e\x00\n\x82;f\xd8QJ\xed\x01\xa0\x97\x8b\x1bR^J\x9dj\x00\x86\fS%Í\xda\x1e{\x00P\x10\xdc4e\x03\xffI\xaa\x1d\xf2\x00\xd0\xcb\xc8\xecÐ¥7tY\x00\xe6d'\xc7\xf6\xd8\a\x80\x82`RR\xed\x90\a@l\xf9\x86\x91\xb2R\xeaT\x0104gß\\\xee\x05@A\x90<;\xe4\x01\x10{.nH\xc9F\xfbT\x000d\xb7\r\xec\xe9\x03\x80\x82\xe0\xe6\xa9\x1bX\x93\xf0b\x99\a@\xec\x99\xdfB\xe8\xe5j\xb6]8#\xed\x01\xf8\xfd\x04\x8b-W\xff\n&\xfdÌ|\xff\x8a?\xd8x\xfd!&]\xbe\x99\x8f\x13\x82\xc0\x03 \xe6Ü¹<\xc8Ò\xd7P\xf3\xb7\x190n\x18\f<'m\x01\xf0=\xba\xc6Ö¶\xfa\xe7\xfc\u007f\xd9|\x0f!nO\xe8\xdc!\x0f\x80\x98\xf3\xadG\xd6pÎ¹;(\x983\x05\xca{\xc3\xf4\xc1pJ\xf2!\xf0\x00Ð\xe0\xe6\xa9\x1b\xe2<\x81\xce\x03@;C\xf9A\x16\xde\xff1#F}Ã \x1c\x14\x00\xa6@I\x1f\x988\xd4\x03\xc01\x00\x14\x04\x93\xc7oæ£\xcf\x1d\xf2\x00\xd0ÊË,yp-9g\xeflm\xf4\x829SÚ®\xb7\xba\x17\\\x9a\\;\xe4\x01\x10;\x04\xb7N\x8b\xd5\x0ey\x00he\xc4\xf6\xec\xde\xe0{\x00`\t\x94\xf6\x81iÉ³C\x1e\x00\xf1A\xf0ã©±\xec,\xf3\x00\xe84C\xf9A\x16\xcf^\xdbj{:\x05\xc0\x14(\xee\x03\x13\x87x\x008\x06\x80\x82\xe0j\xeds\x87<\x00:ÌË\xbc\xf1Ð\xb6\xa7S\x00\"Y\xd3\x03.;=a;\xe4\x01\x90\x18\x04z\xe7\x0ey\x00t\x98o>\xb2\x86Q{\xd9\x1e-\x00\xac\xf0\xc0xjbv\xc8\x03 q\bn\x9a\x12\xcd\x0ey\x00ì¡\xfc \xafw`{\xb4\x010\x05\x8a\xfb\u0095\xf1\xcf\x0ey\x00$\a\x82\xbc\t\x9d\x9d;\xe4\x01\xb0G\xee\\\x1e\xe4\x1f\x0f\xade\xf8\xa8\xf6m\x8f6\x00\x91\xac\xed\x01\x97g\xc7e\x87<\x00\x92\aA\xc7\x1b\xed=\x00\xf6\xe8\xf9\x97>\xbc\x86\xb3Fw\xde\xf3\xc7\x04\x80%P\xd6\a\xa6\x9c\x06\x83b\x83\xc0\x03 \xb9\x10\xcc\xca\xdb\xd8Î\xc0\x03\xa0U\xfco<\xb8\x96\x11\x1a=\u007f\xcc\x00\x98\x02E}c\x9e\x1d\xf2\x00H>\x04yWlb\xfd\x1e\xa5\xd4\x1e\x00\xad\xb5=\xb1\x88?&\x00\"Y\x17\x9b\x1d\xf2\x00\xb0\a\x82=\xedP\x86\x03\x10\xcaW\x9e_\xd7\xf6$\x04\x80%P\xd6[\xdb\x0ey\x00\xd8\aAÛ¹C\x19\x0e\xc0\xeb\xb3\xf5\x06\xbcI\x03\xc0\x14X\xd1\x0f\xae\x8cn\x87<\x00\xec\x85 o\xc2&\xd6/|;3\x01Ø¹\\\xcd\xf3\xc7j{\x12\x06`\xf7Ù¡\xf1\xa7\xd3Ù\xc0\x03\xc0~\bn\x9d\xfe%_\xae<%\xb3\x00\b\xe5\xab\x15\xde\xce\x16\xb9l\a\xc0\x12UJ=up\x87\x10x\x00Ø\xdf\x1f\xbe\x93\xb7\x97\x9d\x96Y\x00,\x9e\xddqyCJ\x010\x05\n\xfbuXJ\xed\x01`\u007f\x9e2|\x17o/\xfbAf\x00\xd0f{b\x1f\xf0\xda\x02@$kz\xc2\xe5\xfb\xda!\x0f\x00\x0f\x80\xa4=\x88\xc8<\xff\xde%Í®\x00\xc0\x12X\xd9K\x95R\xef\x06\x81\a\x80\a@\xd2\x1e\xc4+\xf7}\x9c\x14\xdbc\x1b\x00\x91Ù¡\t\xd9\x1e\x00\x1e\x00\xc9\x03 Ù¶\xc76\x00\"Y\xddK\x95R\x0f:\xc7\x03\xc0\x03 1\x00\"\xb5=É´=\xb6\x03\x10\xb1C\xd3\a\xb3fp\x9e\a\x80\a@\xfc\xe2\u007f\xf1\xdeuq/r9\n@\xb8\x94zÍ¤\xcb<\x00<\x00bo\xf4Hm\x8f\x9d\xe2\xb7\x15\x80pn\xa9>\x88iW\xd7\xf2\xfd\xe1\xf6Ý\xef\xfa\x128w*\x9c}\xa5-\xb9}\xfc\x04>(8\xc9Õ¹\xbd\xa1W\xd7\x02\xe0\xcdv6\xb0\xa7#\x00X\xc2\x17+\x8f\xe0'\xb3\xde`\xf0\b{\xee\xc7\xf7\xd0\a\xf0\xab\xa7aÈ\tm\xdf\xec0\xcf;\xd3\xf66\xb2)\xd3\x0f\x80P\xbe\x9a\xed\xb1c\xc0\xeb\x14\x00!S\xf8\xb4\xf4hfN/\xb5\a\x80G×¨\xafc\xfe\xf6\x19\x0f\x80t\x06`\xe7r5Ï\xec\xa9N\xa7\x01\x88\xe4\xa6\xea\xfeL\x9b\\\x97t;\xb4\xc7\x18\xe0w\xf3\xe0\xd41\x1e\x00\xe9\b@\xaal\x8fS\x00`\t\x9f\x95\r\xe0\x8eYK\x92j\x87\xf6\x00\xe0\xcdf\xf8\xd5ßk\x87<\x00\xec\x05 \x94\x1fd\xf1\x03\xd17\xb0w\x05\x00\x94\x1d:\x86\x99\xd3K\xec\x01\xc0\x17L\xbe\x1d\xf2\x00\xb0\x0f\x00'l\x8f\x93\x00Drs\xedA\\\x93W\x95\x14;\xd4\xe14\xe8}\xf3ap\x12\xec\x90\a\x80}\x00,\x8brnOW\x05\x00K\xf8\xac\xechn\xbfai\xc2v\xa8C\x00\xdel\x86{\x92`\x87<\x00\x92\x0f@(?\xc8k\xb3c\xdb\xc0\xde\xd5\x00\b\x99\xc2\xfa\x92\xe3\x98yMbv\xa8Ó\xb0eMp\xefÜ®\r@\xe31`\xf4K\x1f\x00b9\xb7\xa7+\x03\x10É­u\xfb3cJE\xdcv(\xeaJp~\vÜ¿ \xfe\xd9!7\x03\xe0?\x14J\xfe\x9a>[\"c=\xb7'\x13\x00\xc0\x12>+?\x8a\xdbf\xbeÉ©#bo\x17\xadR\x887\x9b\xe1\xee\xa7\xe0\aq\xd8!\xb7\x02\xd0x$\x94\xfc\r|\xab\xd2\x03\x80\xb6\xe3\n\x9d\xef\xf9\xdd\x06@\xc8\x14>)>\x9e\x99Ó\xed\x01 \xbfEÙ¡\xdf\xcd\xeb\x1a\x004\x0e\x80\xe2\xf9\xe0k!-N\x85\x88\xf7ÜL\x01 \x92\xdb\xea\xfb1cJl\xb3C1\x17\xc3\xdd7?6;\xe46\x00\xfc\x87B\xc9\xd3a\xf1\a\xdd\x0f@\"\xe7\xf6d\x1a\x00X\xc2\xe7\xe5G\xc6d\x87b\x06\xe0\xcdf\xb8\xe7)};\xe4&\x00\x1a\a\xec%\xfe4\x00\xe0\xb5\x04\xce\xed\xc9D\x00B\xa6\xb0\xae\xf8\x04n\xb8\xa6\xc8\x1e\x00\xf2[`Y\x00\xee{6\xbd\x00h<r7\xdb\x13t?\x00;\x1b\x06\xb0\xec\x91\xff\xb8\xce\xf6\xb8\x1d\x80Hn\xad;\x80\x19S*\xa3Ú¡\x84\xf6\x03\xfc\xee\xd9\xe8\x8ben\x00\xc0\u007fhx\xc0\xbb\xb7\xf8]\f\xc0\xa7e\xc7qÎ¹\xdb\x1c\x17y\xba\x02\x80%\xfco\xe5\x11\xdc~\xc3\xd2N\xedPB\x00\xbc\xb5J-\x96uf\x87\x9c\x06\xa0\xf1\xd8N\xc4\xefb\x00\xd6\x16\x1f\xcf)6n\x04\xc9\x04\x00B\xa6\xf0qÑ\xfc\xa8\x93R\xea\x84w\x84-\v\xc0\xbd\x9d\xcc\x0e9\t\x80\xff\b(^Ð\xf8=\x00\xba4\x00\x91\xdc\\s\x103\xf2\xaa\xf8\xfe\xf0}\xdf\x04I\xdb\x12\xf9\xbby\xed\xdb!\xa7\x00\xf0\x1f\xa2\x16\xb9:\x15\xbf\a@F\x00\x80%|Yq8w\xccZ\xb2\x8f\x1dJ\x1a\x00o\xadR;\xcb\xf6\xb6CN\x00\xd0p\x1c\x94<\xa5!~\x0f\x80\x8c\x01@\xcd\x0e}\x87\xeb\xa7U\xd8\x03\x80/\xd8~)u\xaa\x01h<\n\x8a\x9f\xd3\x14\xbf\a@\xc6\x00\x10É¯\xab\xfb\xefQJmË©\x10\xbbÛ¡T\x02\xe0\xef\x0f\xa5\u007f\x89A\xfc\x1e\x00\x19\a\x00\x96\xb2C?\x99\xb5\x84SG\xec\xb0\a\x80\xb7\x9a\xe1\xd7a;\x94*\x00\x1ac\xb1=\x1e\x00\x19\r@\xa4\x94\xfa\xfai\xe5\xf6\x9d\v\xb4,\xa0\xec\xd0y#S \xfe\xa3\xa1\xf8\xf98\xc4\xefb\x00\xfeW|\x04w\xe5T\xf0\x8baUq\xe5\x9dg\xf9\xb9u\xf2\xe7\xdc2u\x83mi>x#\xcc9Æ|\xe68x#\x1b\xaa/\xb7-7\x16]Ï»\xf3[\xd4\xea\xae\x1d\x10\xf8\x82\xf0\xf7\xa7\xec\x15\u007f\\\xb6'\r\x00`Eï¸¾\xadÛ\xe7N\x85\x97\xab\xec{\xb0\xbe L\xfaib\x9bE:Ê\xa3a\xdcM\xb0\xa0Ì¾k\xcfo\xd97\xed\xf8\x9d\x15>{{\xfe\x84\xc4\xef\x01\xe0N\x00Î¹\x1a\x9e+\xb3O\x94\xed\x89?\xdd\x00h<.\x01\xdb\xe3\x01\xe0R\x00FÃ¨\xc9\xf0r\xb5}\xd7Ü¡\xd8m\x02\xc1\x0e\x00\xfc\xfd\xa1\xf4\xa9$\x88\xdf\x03\xc0=\x00Dl\xcf\xfcR\aÄ¿\u05ffO&\x04\xc9\x06\xa0\xf1\xa8$\xd8\x1e\x0f\x00\xf7\x01\x90\x9bB\xdb\xd3\xe1\u007f\xe7r\x00\x1a\x8f\x8bq\x91\xcb\x03 =\x008\xe7j\x1bmO<\xa2N\"\b\xc9\x02\xc0\u007fH\x9c\xf3\xfc\x1e\x00\xee\x05`\xe0h\xb8\xf4F\x98_b\xdf5\xc6+\xe4dÙ¡d\x00\xd0x\x84fa[W\x02\xa0\xac'\x9c5\xbck\x03\xe0\n\xdb\xe3r\x00\x1a\x8f\xd5(iN \vW\xa8\xdfp\x1d\x00\x96@qo\xf8Q\x16d\x8f\x84\xac\x18\xdf\x06n\a 7\x0f^\xa9q\x9f\xf0\x93\xfd\xb7\x12\x01 \xb2\x81=\xe9\x1dD\v\x14\xd4A\xe9\x9f\xd4V\xc9\xf6\u007f\xdf\x05\x00X\xa2>\x17\xf4\xcaAp\xdd@\x18|v\x17\x00`4\\2\v\x16\xa4b\xb6'I\xc2I\x04\x82x\x01\x88\x9cÛt\xf1\a\xa0\xf4\x0fP7\\i\xab\xe3kp\t\x00\x11\b\xaa\xf6\x83g\xfb\xc3\xd8\xec\xf4\x06 \xf7j%~7\xda\x1e\xb7\x00\xb0Ç¹=Il\x9b\x15K\xa0v4\x18\aD\x13\u007f\n\x01\bJ/,\xb9\x13K>\xc0\x92]Q\x1b\xa7\xbe;\xfc\xf2x8\xe3\x8c\xcem\x91\xeb\x00\x18\xadÄ¿\xb0\xd6^\xe1\xfb\x92\xd8\xf3'\x03\x84X\x01\xd8\xe7ÜD\xb3\x05\n+\xa0â¶\xce\x00\xdd;wa\xc9\x1a\x02\xf2s\f\xe9g;\x00\xad \x04\xe4$\x02\xf2 \x96\xfc\aKBQ\xdf\bK\xfb\xc1\x1d'\xc2\xf03\xd3\x03\x00;m\xcf\x1eÂ´\xb1\xb0-\x1e\bb\x01\xa0\xdds{\x12\xc8\xc2\n(\xff\r4\f\xd2\xe9\xf1CX\xf2\x11\xa6\xfc\x01C\x06\xa6L\xf8{@P.=0$\x1bK^\xd3j\xb0\x86nj|pÕ©\xee\x06 7\x0f\x16\x94\xa4\x97\xedI5\x00\x1d\x9e\xdb\x13g\x16/\x80\xfal0{\xeb\xfd\xbe)\xcb1\xe5t\x16K/GÄ¿w`Ê¥X\xb2\nKvh\xdd\xc0\x93ßQ\xc3\xdb\xd6\x0e\xdc\x00\xc0\xc0\xb0\xed\xb1k\xb6g\x0fA\xda,\xfcxA\xd0\x01\xa0\xd3s{b\xc9Õ°\xa2\x10\xaa\xae\xd0}\xeb|\x83)\xab1\xe4*\xa7\xf5\xden`\xc9\x00\f\xb9\x13K\x9a\xa3\xda\"K\xd4\xe2Ù¯\x8f\x83sr\xdc\x01\xc0\xa57\xaay~[~?\x85\xbd~4\b:\x13n4\x00\x1a\x8fM\xceTga\xa1\xf2\xf9\x8d\x03t\x84\x1f\u0092 \x96\xdcM\xad\x1c\xed\xb4\xce;\r\x90n\x18\xf2]L\xf9\x13\x96l\x8aÞ\b\xbc\xd5\x17f\x9f\a\x8b+\x9c\x03\xe0\x9c\xab\xd5\noW\xb0=\x89\\Cg\x004\x86\xcf\xedI\xe8\x1e\x9a\xa0\xec>h\xf8\x1e\x98\xfb\xe9\x88\u007f\x1b\xa6<\x8e_\xb2\xb8O\xba;\xad\uf602&\x19\x8e)\xb5\x98\xb2%\xea\x1b\xc1\x14\xa8=\x03V,\x03_ u\x00DlO*J\x9aSm{\xe2\x01\xa1#\x00\x12\xae\xed\t\xc0\x8a\xb7\xa0v\x94\xee\x00w\v\x964\x12\x90\xb3\x9c\xd6qB\xc1{Ò\x80\\\x8b%\xd5Z\xb6\xc8\xe8\rUyP\xf4j\n\x00\x18\r\xe3\xec\xb4=A\xe7{\xfdX!h\x0f\x80\xc6\xe3\x12\xf3\xfcEK\xa0j\n\x18\xfb\xebÚ\x06\x9a\xe4:\x9ae\u007f\xa7\xf5\x9b\x94\bÛ¢\xa3\xb0\xe4Ç\xf2I\xd4F0\xbb\xabc\xf2*\xaf\x85\x82$\x0eH\xf7\x06`Ô¤\xaeo{:\xbc\xb6\x0e\xe0\xdc\x1b\x80\x98\xcf\xed\xd9-\vj\xa1\xe2&\xf0\x1f\xa5\x9eit\xf1\xaf\xa7I~J\x93\x1c\r\xd2\xcdi\xdd\xda\x12\xd4\xcbI\x18\xb2\x1cS6hÙ¢\x86\x93\xc2\x0f\xc0\x9f<\x00\x06\x8e\xb6\xb9\xa49\xe8>Û£\v\xe9\xee\x00Ä½\x81Ý\xa2\x85\xd0p\xb2\x9e\xdd1e#\x96\x94\x10\x90\x93\x9c\xd6gÊ\x80\\\x8c)\xcb0e\xab\xd6\x1b\xa1\xe6\x02(y\x86\x84\xc6\a\x93~Ú¶\x93\xcb.Û³Ç¾]\x17\b<\xd6k\x8e\x00\x10\u05f9=\xcdP2\x17j.\xd1\x1d\xe0nÇe\x182\xdei=:\x12\x04\xe5\x10\x02r\x15\x96\xbc\x1b\x1d\x82\xf0@\xacz<\x14\x96\xc7\x0f\xc0\xa8É©\xa9\xed\xb1{\x85\xd7N\x00\x1a\x8fQ\x1b\xd8ci\xa3\x82\n\xa8\xbaR=#\xb3[t\xf1\x9b\xf2>\x01\x99BP\x0eA\xba\xa8\xdd\xd1\r\f\xe9\x87)\u007f\xc1\x92Ï´\x06\xca\xfe~\x84\xca\x1ef\xdb[\r|\xf1\xda;\xfay\xddc|\xf1Lml\xffO\f\xb9yi0\xbdz\xfe\xf6@\xf0\x95\xc7f{\n\x1a\xa0\xec\x11\xf0\x1f\xac;\xc0\xfd\x02S\xfe\x8a!\xdfrZw\xae\n\x90n\x04d$\x96\xccÅÏ£5f\xc8\u070f\x8f\vF1\xf7\xfe\xb9L\x99\xb8\x9e\xcb.\xde\x1a=\xc7n\xd2\xfb\xef\xe2È\x93\xbf\xc6z\xfa\xfd\xf4\x15\u007fkj\xbe\xbd\n\x1a\xa0\xec1\xa8=[\xd7\xee|\x81%\xcfaIn\x97\x1d\xe0&#0\xa4\x1f\x01\x19\x83%\xb5\x1a\x8d\xca\xd75\aR:\xffR.\x1d\xb7Ú±#\x17\xb3G\xeed\xc9Ck\xd9\xf1\xa6\xd3\xe2MQ\x16\x16B\xcdhU\xa6\xac\xf1\x8c0\xc5\u0090\v\b\xca\x01N\xeb+\xad\x02CnÇu\x98\xb2S\xa7\xa1\xffz\xff\xbd\x9c9\xfa3N\x19\xbe+E\xe2\x0f1\xf4\xcc]Ì»\xe7\x13Bi\xdf\xf3G\xcb\xd5PP\r+\u007f\xa23\xb3\x03\xaaLy\x1d\xa6\xdcå´\xd2:0e\x10\x96<\x8a%\x1fEk\xf4]f7\x82K\x87\xf0\xd0/\x9f`ä¹\xda\x0e@\xeey;x\xf5\xfe\x8f\xbb\xbe\xf8\v\xaaw+SÖ\xcf\xff\x18K\xfe\x0fS\x06e\xfc\x007\x19\x81Oz\xd3,\xa7bÉ¢\xf0\xd4Y\xa7\x0f`k}_Z\xfe1\x94\x1b\xae\xf5\xc5\xf4\x11\xea\xd8l\xcf.\x96<\xb8\x96\x1do\xb9@\xa0v\xf6\xfa%s\xa0~0\x18}t\x84\xff\r\xa6\xbc\x8a!Ù¼'\xbd\x9d\xd6M\x97\fL\x99\x84)\xff\t\x83\xd0\xe9\x8c\xd1.\xa3\x1b\x8b\x1e\x9f\xc59\xe7\u007f\xcc\xe0\x11;\x92j{\x9e\xfb\xcd:\x17\bÔ®l\x86\u0095P9]gJ3\x14~\x16k\xb0\xe4\x1a\xa7\xf5\x91\x11A\xad\x1c\x82)w\xa1Jd\xa3\xf6L\xebK\a\xf0\xd4\x03\xbfe\xccE\xffJ\x18\x80s\xce\xdd\xc1\xa2\xael{\nK\xa0\xf2Çºe\xca`É»\x98r\x17\xf5r\x84ÓºÈ¨\xc0\x90\x9e\x04\xe4\x04\f\x99M\xb4M\xfa\x96\xb0\xbd\xa1\x17\x1f\x16\x9e\xc8\xec_\xfc\x99S\xe3|\x1bd\x8f\xdc\xc5\x1b]\xd6\xf64C\xd9\xfdj\x05\xd8\xec\xa93\xb3\xb3\x05C\xfe\x88_NÄ\x9eN\xeb!\xa3\x03\xbf\x9c\x85%\x86\x0e\b\xbb\xccnT\xbe0\x96q\x97\xaf\xe2\agnÕ·=#w\xf1\xc2o\xbbb\xcf\x1f\x80\x15\xf9\xe1\xf9|\x8d\x15\\K\xb6\x10\x90\xd54\xc9\xd9N?w/v\v\x9ae\u007f,\xb9\x06S\xaa\xd0Ø\xf9ee\u007f\x16=>\x8b+\xafll\xf7{\xbc\xbb\x8b\xff\xec\xd1;X\xfc\xc0\xda.&\xfe\xd5P\xb4X\x95)\xeb\xad\xe2~\x83%\xd5\x182Ó\xcfwi\xb4\x96]7É­h\xecF\xdbetc]\xc91\xfc\xed\x81_w8[\x94=r\x17\xaf\xcd^\xcb\xf6.\xb5ÈµJmG\xf4\x1f\xa1;\xad\xb9\x19K\xeeÄ\xa3\xd2nWV\xa6\x06\x96\x1cN@\x96\x86Km\xa3>\xe45+\x8e\xe7\xba\xe9E\f=kSkÏ=r\x17/\u07bb\xae\v\xf5\xfc&\x94Ì\x86\x13u\a\xb8_c\xc92\x1a\xe5X\xa7\x9f\xa7\x17q\x04\xb5\xd2\x17S\xc6a\xc9\xeb:o\x84M\xb5\aP\xf0Ì\xdcx\xdd[\x9c{\xfe&^\x9b\xddUlO\x93*%\xaf\xbeXwW\xd6f,Y\x86)WP+}\x9d~\x8e^$\x18\x04\xe4`\x9ad\x12\xa6|\x1c\xed\xe1\x87L\xe1\u007f\x15\x87\xf2ï¥Ù¾\xdc\xc6\xe3QR\x95\x05\x8dP}E\xb8LY\xa3\xd7\x0f\xc8\x17\x982\x99\xa0\x1c\xe2\xf4s\xf3\"\xc9A\xad\xf4Å?\xa3*\x13\xa3\x1f\xeb\xe8\xef\x0fe\x0fCA=\xf8V;/f\xedlQ\xd7\\\xfa\x184\x1e\xaa\xd3\xe3\xab2\xe5\x80\xccI\xe9\xf1\x82^\xa4>@\xba\x13\x90\xb3\b\xc8\x1c,\xd9\x10U\x1c\xe6~P7BÕ¼\xdbuZER\xb3\tJ\xff\bug\x80\xd9C\xa7\xc7\xdfH@\xe6c\xc8ÙK\x0f\xa7\x9f\x8f\x17)\n\xca\xe5\x80\xf0\xb1-u\xe8\xecM6\x0e\x80\xba\x1cu\u0081\xe3\"\xef \x8b\x96\xa8\xf9|\xe3@Ý½\xb8\xf5\x982\x8aj9\xd0\xe9\xe7\xe1\x85C\x11\xb6Ewc\xc9z\xd4\\w\xe7\xc21\x0eT%\xc1\x05U\xe0[\xe5\xbc\xe8}\xab\xc2Õw\x83q\x90\xee|\xfe\xa7Xr\xbf7\xc0\xf5\xa250\xe5{X\xf2\b\x96\xacÓ\"l\xf8\x1e\xac\xbc[\x1d\xfd\xe1\x98\xf8\x1b\xa1\xfc\x1e\xa8\x1f\xa8;\xad\xf9\x19\x96<\x82)\x83\x9cno/\\\x18\x94K\x1f\xfc\x92\x85!\x8b\xf5lQ\x1f\xf5\xc1\xb6\x929\xa9\x17\u007f\xf1|\xa8?E]\x83\x9e\xddY\x86)\x83(\x97>N\xb7\xb3\x17.\x0f\x16\xcb~\xf8%\x0fS\xdeAc\xff\x01f\x0f\xa8\x9a\xa4\xb6\n\xdaj\x8bVAa1TM\x06\xb3\x97N\x8f\xbf\x1dS\xdeÇ)^\xc1\x9a\x171\a\x96\f  w\x10\x90\x16\x02Q\xa6MMQ%Ä7\xa8#\xbf\x93z,J\x8b\xfa\x9b\x157\xab#K\xf4\xce\xd6\f\x12\x90\x9f\xd3,\xc78Ý^\xa4qp\x9ft\xc7/'\x12\x90Ç£B`\x89\xaa\xadi8\x11\xca\x1eJ\x1e\x00\xa5\u007f\x84\x86\xefê¾\x10\u0092\xa7Y%'\xb2X\xf6s\xba\xfd\xbc\xe8B\x11\xfe\x1aN\r\xea\xe4\xe2\xe8b\xac\xcbQ\x15\x97q\xad\x1f4\xa9\xff\xb7v\x94\xee\x00w+\xa6\xb2\t\x1f\x9e\x00\x00\x01ZIDAT\xd4\xe2O\xf3Ó\xbdpw\xb0J\xfac\xc9tL)\xd3\x1a(\xfb\x0fQ\x9e\xbdh\xa1\xbe\xf8\x8b\x16C\xd54\xdd\xf2\x85P\xb8\x04\xfczVI\u007f\xa7\xdbÇ\f\t\x82rd\xf8k8_F\xb7E\xa2NY^y\xab\xaa\xcd\xe9P\xfc\x16\xac\xbcM\xd7\xe7\x83*\xf0\xbb\x93&\x97\u007f5Å\xae\x1b\xf8\xe5D\xacÖ²\xeb\xe8\xc7:6\x9c\f\xc5s\xc1g\xd0v\n\x9b\xd16\xad\xa9\xe3\xf1M\xd9H@\x96\xd3$';}\xff^x\xa1\xbe\x96\x19\x90K\b\xc8\x12-\b\x8c\x9ePs\xa1*Q.^\x005\x17\xa9\x0f\x83\xe8\x89\u007f9\xa6\\\xea\x1d;\xe2\x85ë \x1c\x82%\x97a\xc6pÚµ\xff0]\xbb\xf3.\xa6L\u0090Ã\xbeO/\xbc\xe84P_\xcb|\x1aS>G\xa7\xec\xba\xe3Ü*S\x9e\x8f%\x03\x9c\xbe//\xbc\x88)h\x94\x1c,\x99\x87\xdaZ\x18\xab\xf8\xb7`É³\x04d\xa4\xd3\xf7\xe1\x85\x17q\a\xd5r \x96\xe4\xa2\xd6\x0ft\xc5\xdfH\xb3\x9c\xe7\x95){\xd1e\x02\x9f\xf4Æ_\x86\x8fu\xdc\xd7\x16\xa9U\xe6\xb5X\xf2KoW\x96\x17]6h\x96,,y8,\xf6P8\xd7b\xcac4\xc9\xf7\x9d\xbe>/\xbc\xb0=(\x97\x1e4J\x0e\xa6\xfc\x03S\n\bH\x0eA\xe9\xe5\xf4ueb\xfc\u007fK\x13\xb8F\xdb\x0f\xfc#\x00\x00\x00\x00IEND\xaeB`\x82"
var _Assets73d5f881dc044ff1def628efb1b6c854a3374148 = "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00 \x00\x00\x00 \b\x06\x00\x00\x00szz\xf4\x00\x00\x04$IDATX\x85\xb5\xd7]L\x9bU\x1c\xc7\xf1?\xf8\x12\x02ax\xab\xf3\x02_B\xc5D\xbc\xd0Bb\"$@\xc8tnJ\x16\xb7Ev\xe1\v\xcc9]\x06\xc38\x88A\xcd\u0605/@\xe6\x92y\xa5\xbb\x9a\xdb\xc4\x172lK\xdbÄ\x97nÅµ\xcf)0\x1a3\xa3Ü°M\x91Hbf 0x\xbe^\xb4<\xf0\xf4yZh\xe7H\xfe\tiz\xce\xefs\xce\xd3\xf3\x9csD\xb2\xfccLJ\xd0Ä&.Æ¤$\xdb~2\x0f\x8eH\x11c\xd2E\xa4p\x91\xc1\xa3\x10h\x03\xadp\x11%\xddD\xa4\xe8\xce\x05#\xb9D\xa5i9r\xd7\xccÙ\x03\xbc\xd74\xc5b\u007f\f<1\x18\b\xc2\xc8nP\xb93h\xb2\x1f$\xf7\xff\rWR\x89\x92\xe8\xc2p\x05\xaf5D(uB\xa9\x13\xdej\xf8g\rá\xff\a\b\x95\x83\x92(J*o?8$\xc5(\xe9%\xbcU\x9f\xf7~Î«\xbbo\x1a\xe1)\x11\x9eI\xf8\xe9\x04\x84\xb7\xea(\xe9%$Å\a\x8fK\x01\x11\xe9$\x92?\xcf\xd0at\xb7\xe2\xe3C\xb3\xbc\xf4\xc2B\xa2n\xae\xfb\u007f\x81\x13\xad3\xe8?N\xacC\xc4\xc0\xa3`\xf00D\xf2\xe7\x89H'\xe3R\xb0q\xb0H\x0e\x9a4\xa0r\xa6\t\xee\x04o\x00Ü\xf12:\x1e\x83\xe0sIa1\xd8\xdb\n\xfd\xe3\xd6Ï½\x01\b\xee\x04\x953MT\x1a\x10É±\x0f\x8f\x8a\x13%\x97\x18-\x03\xff\xb9xc\xbb\xf0\x8b5\xa0\xddk\rz\xa2\x0e\xeaß¶Gxb\xf1>G\xcb@\xc9%\xc2Rn\x05(\xf9\x8d@G\xfc\x19\xa6\vW\x92\x1a\xe0\xa8J\x8f\xf0LB\xa0\x034\xf9\xdd\x1e\xe0\xf3Å¿\xe8\xba\x02g\x86\xe1\xccH\xa2\x86\xe1\xc2v\xf0\xe5\x81/\x0f\xdd[\xc8\xf5\xb3WMu\xa3\xac\x81\x1b\xa5/\xc7k\xd71\x96\xfb\xaf\xd8#|\xbeM\x00Ü\xf0\xe6\xb1\xf8\x88lj\xc9QcY\r\xebë²\xd3t\xbe\xf2k\xd2\xea\xc8\x04\xb0\x01\"5@\xe7T\xd9ipTQ\xf3Ô6K4\x13@\x1aD*\xc0j\xf8*\xc0\xf6=\x91\x11 \x81Ð\x10v\x80SÎ¯\xa1\xacÎ¨\xea\xa7g\xec_V\x99\x02\x96]1\xba[cp\xe4á´\u007f\xfb~1\xb5\xab\xae]\xb2\u007fcf\x02Xq\xc5hk\x9c\xa3\xb2\xf6:h\x02-\x8fd\r0\x10n\xff\xe6\x00Ë®\x18G\x1b\xe7(u\x12\a(1\x10\xd9\x02J\x9d\xd0\xfcFlc\xc0rbä«\f@\x02\xb1tÄ5\xa0v\xdbTz@r\xb8\x05\xa0\x04]\x13>m\xff\xcc\f8t\x12\x1e\xaf6\xea\xd6@!K\x97\xef\xb1Ô­\xf0Ý©\x01+\x03>c\xda\xd3\x01V\x11\x9f\xb4w\x99g\xa0\xb9km\xb5\xf8\xf3,mP\x02?\x97\xa4\x06t\x1c\x9c\xb0\x9d6;@2\xc2x\x04-]\xa9\x01\xa1\n\xf0]H\r\xa8\xdd6\x95\x11`=\xc2\xf4\x1bh\xe9\xb6\x02B\x15\xe0\xd1\xd2/Ã¿\x9f\xadc\xf6\xb1z\xfe\xaa<\xc0\xcc7W\x8d\x9a\xfdj\x14*\x9eY\xabw\xdf\a\xef\x90Q\xfa\xc0\x10\xbai\xe7\x8c\xc1\xe5\xfb\x93\xc2#\x9bx\x11\x1d|\x14\x1c\x95P\xb5\xd7\xdcÙ¹\x8bkÏ¶\xf1#\xf36ml\xdbI\xdbw\xf8\x01\xf3\xc87\u070e\xc3R\x8e&!\xce\x17\xc2\xeb\xdb\xed\x01\x8d\x1fZ\xc3=v\x98\x04`}\xb8\xff<\x8c>\t\x9a\x84\x18\xb39\x90\x88\x18G\xb2}\xa8\x9ckÆl\x15\x90r\xe4Ö½\x03\xf7$\x04\xeb\xe3\xe1\xde\x00\x04_\x04\x95s\rM\xf6\xa5<\x92\x99 \xe3R\x80&\xc7\xf5H\xfe|\xff\xc9\x0fØµc\x8e\x1d\xcf/\x18\xf5e\xfb\x1f\xf6á¦\t\xc3`s\xfcP\xaa\xc9\xf1M\x1dJ-\x90\xa8\x14\x13\x95\xdei\xffC\xfa;M\xdfS\xea\xd4ik\x9ccÅ\"\xd8t,\u007fPGÉ·D\xb38\x96[ J\xaaP\x12\x9d\xf8\xae\x8a\x15o_\xeap\u007f\xdf\xfa\x8bI\xd5m\a\x9b\x10H.\x9a\xecG\xe5\xce0\xb2'~\x1d[\r\x1e\b\xc2È;w53A\"R\x84&=h[\x16\t\xb4%.\xa7[\x16Ñ¤\x87\x80\xdcwÇ-\x90\xb08P\xe2F\x89\x9b\xb08\xb2\xed\xe7?-S\x12\xc4\x17x'L\x00\x00\x00\x00IEND\xaeB`\x82"
var _Assets131cd67b6dd480f64ec4b1e6dc1172c43a81c7a9 = "{{define \"header\"}}\n<!doctype html>\n    <html lang=\"en\">\n        <head>\n            <meta charset=\"utf-8\">\n            <title>{{.}}</title>\n            <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"public/img/apple-touch-icon.png\">\n            <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"public/img/favicon-32x32.png\">\n            <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"public/img/favicon-16x16.png\">\n            <link rel=\"manifest\" href=\"public/img/site.webmanifest\">\n            <link rel=\"stylesheet\" href=\"public/css/all.min.css\">\n            <link rel=\"stylesheet\" href=\"public/css/style.css\">\n        </head>\n        <body>\n            <div class=\"logo\">\n                <img src=\"public/img/hex.svg\" height=\"40\" alt=\"textile\"/>\n            </div>\n{{end}}\n\n{{define \"menu\"}}\n            <ul class=\"navbar\">\n            {{range .MenuItems}}\n                {{if .Selected}}\n                    <li><a class=\"selected\" href=\"{{.Path}}\">{{.Name}}</a></li>\n                {{else}}\n                    <li><a href=\"{{.Path}}\">{{.Name}}</a></li>\n                {{end}}\n            {{end}}\n            </ul>\n{{end}}\n\n{{define \"table\"}}\n            <div class=\"title\">{{.Title}}</div>\n            <div class=\"subtitle\">{{.Subtitle}}</div>\n            <table>\n                <tr>\n                {{range $header := .Headers}}\n                    <th>{{$header}}</th>\n                {{end}}\n                </tr>\n            {{range $row := .Rows}}\n                <tr>\n                {{range $value := $row}}\n                    <td>{{$value}}</td>\n                {{end}}\n                </tr>\n            {{end}}\n            </table>\n{{end}}\n\n{{define \"footer\"}}\n        </body>\n    </html>\n{{end}}\n"
var _Assets4bf0d0667fe4719e513a3edfeb3a25a2377cf2b7 = "{{template \"header\" \"404 Not Found\"}}\n<div class=\"aligner\">\n    <div class=\"aligner-item\">\n        <i class=\"fas fa-sad-cry icon-big\"></i>\n    </div>\n    <div class=\"aligner-item\">\n        <p>Nothing to see here!</p>\n    </div>\n</div>\n{{template \"footer\"}}\n"
var _Assets8391991a0f9445efcc483e87a0508f7472f04dab = "{\"name\":\"\",\"short_name\":\"\",\"icons\":[{\"src\":\"/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\"}"
var _Assets0f3873af67026ef9adff5293b531a01d11ae6c96 = "/*!\n * Font Awesome Free 5.12.0 by @fontawesome - https://fontawesome.com\n * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)\n */\n.fa,.fab,.fad,.fal,.far,.fas{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;line-height:1}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:.08em solid #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s linear infinite;animation:fa-spin 2s linear infinite}.fa-pulse{-webkit-animation:fa-spin 1s steps(8) infinite;animation:fa-spin 1s steps(8) infinite}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.fa-rotate-90{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";-webkit-transform:scaleX(-1);transform:scaleX(-1)}.fa-flip-vertical{-webkit-transform:scaleY(-1);transform:scaleY(-1)}.fa-flip-both,.fa-flip-horizontal.fa-flip-vertical,.fa-flip-vertical{-ms-filter:\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\"}.fa-flip-both,.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1);transform:scale(-1)}:root .fa-flip-both,:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;line-height:2em;position:relative;vertical-align:middle;width:2.5em}.fa-stack-1x,.fa-stack-2x{left:0;position:absolute;text-align:center;width:100%}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-500px:before{content:\"\\f26e\"}.fa-accessible-icon:before{content:\"\\f368\"}.fa-accusoft:before{content:\"\\f369\"}.fa-acquisitions-incorporated:before{content:\"\\f6af\"}.fa-ad:before{content:\"\\f641\"}.fa-address-book:before{content:\"\\f2b9\"}.fa-address-card:before{content:\"\\f2bb\"}.fa-adjust:before{content:\"\\f042\"}.fa-adn:before{content:\"\\f170\"}.fa-adobe:before{content:\"\\f778\"}.fa-adversal:before{content:\"\\f36a\"}.fa-affiliatetheme:before{content:\"\\f36b\"}.fa-air-freshener:before{content:\"\\f5d0\"}.fa-airbnb:before{content:\"\\f834\"}.fa-algolia:before{content:\"\\f36c\"}.fa-align-center:before{content:\"\\f037\"}.fa-align-justify:before{content:\"\\f039\"}.fa-align-left:before{content:\"\\f036\"}.fa-align-right:before{content:\"\\f038\"}.fa-alipay:before{content:\"\\f642\"}.fa-allergies:before{content:\"\\f461\"}.fa-amazon:before{content:\"\\f270\"}.fa-amazon-pay:before{content:\"\\f42c\"}.fa-ambulance:before{content:\"\\f0f9\"}.fa-american-sign-language-interpreting:before{content:\"\\f2a3\"}.fa-amilia:before{content:\"\\f36d\"}.fa-anchor:before{content:\"\\f13d\"}.fa-android:before{content:\"\\f17b\"}.fa-angellist:before{content:\"\\f209\"}.fa-angle-double-down:before{content:\"\\f103\"}.fa-angle-double-left:before{content:\"\\f100\"}.fa-angle-double-right:before{content:\"\\f101\"}.fa-angle-double-up:before{content:\"\\f102\"}.fa-angle-down:before{content:\"\\f107\"}.fa-angle-left:before{content:\"\\f104\"}.fa-angle-right:before{content:\"\\f105\"}.fa-angle-up:before{content:\"\\f106\"}.fa-angry:before{content:\"\\f556\"}.fa-angrycreative:before{content:\"\\f36e\"}.fa-angular:before{content:\"\\f420\"}.fa-ankh:before{content:\"\\f644\"}.fa-app-store:before{content:\"\\f36f\"}.fa-app-store-ios:before{content:\"\\f370\"}.fa-apper:before{content:\"\\f371\"}.fa-apple:before{content:\"\\f179\"}.fa-apple-alt:before{content:\"\\f5d1\"}.fa-apple-pay:before{content:\"\\f415\"}.fa-archive:before{content:\"\\f187\"}.fa-archway:before{content:\"\\f557\"}.fa-arrow-alt-circle-down:before{content:\"\\f358\"}.fa-arrow-alt-circle-left:before{content:\"\\f359\"}.fa-arrow-alt-circle-right:before{content:\"\\f35a\"}.fa-arrow-alt-circle-up:before{content:\"\\f35b\"}.fa-arrow-circle-down:before{content:\"\\f0ab\"}.fa-arrow-circle-left:before{content:\"\\f0a8\"}.fa-arrow-circle-right:before{content:\"\\f0a9\"}.fa-arrow-circle-up:before{content:\"\\f0aa\"}.fa-arrow-down:before{content:\"\\f063\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.fa-arrow-up:before{content:\"\\f062\"}.fa-arrows-alt:before{content:\"\\f0b2\"}.fa-arrows-alt-h:before{content:\"\\f337\"}.fa-arrows-alt-v:before{content:\"\\f338\"}.fa-artstation:before{content:\"\\f77a\"}.fa-assistive-listening-systems:before{content:\"\\f2a2\"}.fa-asterisk:before{content:\"\\f069\"}.fa-asymmetrik:before{content:\"\\f372\"}.fa-at:before{content:\"\\f1fa\"}.fa-atlas:before{content:\"\\f558\"}.fa-atlassian:before{content:\"\\f77b\"}.fa-atom:before{content:\"\\f5d2\"}.fa-audible:before{content:\"\\f373\"}.fa-audio-description:before{content:\"\\f29e\"}.fa-autoprefixer:before{content:\"\\f41c\"}.fa-avianex:before{content:\"\\f374\"}.fa-aviato:before{content:\"\\f421\"}.fa-award:before{content:\"\\f559\"}.fa-aws:before{content:\"\\f375\"}.fa-baby:before{content:\"\\f77c\"}.fa-baby-carriage:before{content:\"\\f77d\"}.fa-backspace:before{content:\"\\f55a\"}.fa-backward:before{content:\"\\f04a\"}.fa-bacon:before{content:\"\\f7e5\"}.fa-bahai:before{content:\"\\f666\"}.fa-balance-scale:before{content:\"\\f24e\"}.fa-balance-scale-left:before{content:\"\\f515\"}.fa-balance-scale-right:before{content:\"\\f516\"}.fa-ban:before{content:\"\\f05e\"}.fa-band-aid:before{content:\"\\f462\"}.fa-bandcamp:before{content:\"\\f2d5\"}.fa-barcode:before{content:\"\\f02a\"}.fa-bars:before{content:\"\\f0c9\"}.fa-baseball-ball:before{content:\"\\f433\"}.fa-basketball-ball:before{content:\"\\f434\"}.fa-bath:before{content:\"\\f2cd\"}.fa-battery-empty:before{content:\"\\f244\"}.fa-battery-full:before{content:\"\\f240\"}.fa-battery-half:before{content:\"\\f242\"}.fa-battery-quarter:before{content:\"\\f243\"}.fa-battery-three-quarters:before{content:\"\\f241\"}.fa-battle-net:before{content:\"\\f835\"}.fa-bed:before{content:\"\\f236\"}.fa-beer:before{content:\"\\f0fc\"}.fa-behance:before{content:\"\\f1b4\"}.fa-behance-square:before{content:\"\\f1b5\"}.fa-bell:before{content:\"\\f0f3\"}.fa-bell-slash:before{content:\"\\f1f6\"}.fa-bezier-curve:before{content:\"\\f55b\"}.fa-bible:before{content:\"\\f647\"}.fa-bicycle:before{content:\"\\f206\"}.fa-biking:before{content:\"\\f84a\"}.fa-bimobject:before{content:\"\\f378\"}.fa-binoculars:before{content:\"\\f1e5\"}.fa-biohazard:before{content:\"\\f780\"}.fa-birthday-cake:before{content:\"\\f1fd\"}.fa-bitbucket:before{content:\"\\f171\"}.fa-bitcoin:before{content:\"\\f379\"}.fa-bity:before{content:\"\\f37a\"}.fa-black-tie:before{content:\"\\f27e\"}.fa-blackberry:before{content:\"\\f37b\"}.fa-blender:before{content:\"\\f517\"}.fa-blender-phone:before{content:\"\\f6b6\"}.fa-blind:before{content:\"\\f29d\"}.fa-blog:before{content:\"\\f781\"}.fa-blogger:before{content:\"\\f37c\"}.fa-blogger-b:before{content:\"\\f37d\"}.fa-bluetooth:before{content:\"\\f293\"}.fa-bluetooth-b:before{content:\"\\f294\"}.fa-bold:before{content:\"\\f032\"}.fa-bolt:before{content:\"\\f0e7\"}.fa-bomb:before{content:\"\\f1e2\"}.fa-bone:before{content:\"\\f5d7\"}.fa-bong:before{content:\"\\f55c\"}.fa-book:before{content:\"\\f02d\"}.fa-book-dead:before{content:\"\\f6b7\"}.fa-book-medical:before{content:\"\\f7e6\"}.fa-book-open:before{content:\"\\f518\"}.fa-book-reader:before{content:\"\\f5da\"}.fa-bookmark:before{content:\"\\f02e\"}.fa-bootstrap:before{content:\"\\f836\"}.fa-border-all:before{content:\"\\f84c\"}.fa-border-none:before{content:\"\\f850\"}.fa-border-style:before{content:\"\\f853\"}.fa-bowling-ball:before{content:\"\\f436\"}.fa-box:before{content:\"\\f466\"}.fa-box-open:before{content:\"\\f49e\"}.fa-boxes:before{content:\"\\f468\"}.fa-braille:before{content:\"\\f2a1\"}.fa-brain:before{content:\"\\f5dc\"}.fa-bread-slice:before{content:\"\\f7ec\"}.fa-briefcase:before{content:\"\\f0b1\"}.fa-briefcase-medical:before{content:\"\\f469\"}.fa-broadcast-tower:before{content:\"\\f519\"}.fa-broom:before{content:\"\\f51a\"}.fa-brush:before{content:\"\\f55d\"}.fa-btc:before{content:\"\\f15a\"}.fa-buffer:before{content:\"\\f837\"}.fa-bug:before{content:\"\\f188\"}.fa-building:before{content:\"\\f1ad\"}.fa-bullhorn:before{content:\"\\f0a1\"}.fa-bullseye:before{content:\"\\f140\"}.fa-burn:before{content:\"\\f46a\"}.fa-buromobelexperte:before{content:\"\\f37f\"}.fa-bus:before{content:\"\\f207\"}.fa-bus-alt:before{content:\"\\f55e\"}.fa-business-time:before{content:\"\\f64a\"}.fa-buy-n-large:before{content:\"\\f8a6\"}.fa-buysellads:before{content:\"\\f20d\"}.fa-calculator:before{content:\"\\f1ec\"}.fa-calendar:before{content:\"\\f133\"}.fa-calendar-alt:before{content:\"\\f073\"}.fa-calendar-check:before{content:\"\\f274\"}.fa-calendar-day:before{content:\"\\f783\"}.fa-calendar-minus:before{content:\"\\f272\"}.fa-calendar-plus:before{content:\"\\f271\"}.fa-calendar-times:before{content:\"\\f273\"}.fa-calendar-week:before{content:\"\\f784\"}.fa-camera:before{content:\"\\f030\"}.fa-camera-retro:before{content:\"\\f083\"}.fa-campground:before{content:\"\\f6bb\"}.fa-canadian-maple-leaf:before{content:\"\\f785\"}.fa-candy-cane:before{content:\"\\f786\"}.fa-cannabis:before{content:\"\\f55f\"}.fa-capsules:before{content:\"\\f46b\"}.fa-car:before{content:\"\\f1b9\"}.fa-car-alt:before{content:\"\\f5de\"}.fa-car-battery:before{content:\"\\f5df\"}.fa-car-crash:before{content:\"\\f5e1\"}.fa-car-side:before{content:\"\\f5e4\"}.fa-caravan:before{content:\"\\f8ff\"}.fa-caret-down:before{content:\"\\f0d7\"}.fa-caret-left:before{content:\"\\f0d9\"}.fa-caret-right:before{content:\"\\f0da\"}.fa-caret-square-down:before{content:\"\\f150\"}.fa-caret-square-left:before{content:\"\\f191\"}.fa-caret-square-right:before{content:\"\\f152\"}.fa-caret-square-up:before{content:\"\\f151\"}.fa-caret-up:before{content:\"\\f0d8\"}.fa-carrot:before{content:\"\\f787\"}.fa-cart-arrow-down:before{content:\"\\f218\"}.fa-cart-plus:before{content:\"\\f217\"}.fa-cash-register:before{content:\"\\f788\"}.fa-cat:before{content:\"\\f6be\"}.fa-cc-amazon-pay:before{content:\"\\f42d\"}.fa-cc-amex:before{content:\"\\f1f3\"}.fa-cc-apple-pay:before{content:\"\\f416\"}.fa-cc-diners-club:before{content:\"\\f24c\"}.fa-cc-discover:before{content:\"\\f1f2\"}.fa-cc-jcb:before{content:\"\\f24b\"}.fa-cc-mastercard:before{content:\"\\f1f1\"}.fa-cc-paypal:before{content:\"\\f1f4\"}.fa-cc-stripe:before{content:\"\\f1f5\"}.fa-cc-visa:before{content:\"\\f1f0\"}.fa-centercode:before{content:\"\\f380\"}.fa-centos:before{content:\"\\f789\"}.fa-certificate:before{content:\"\\f0a3\"}.fa-chair:before{content:\"\\f6c0\"}.fa-chalkboard:before{content:\"\\f51b\"}.fa-chalkboard-teacher:before{content:\"\\f51c\"}.fa-charging-station:before{content:\"\\f5e7\"}.fa-chart-area:before{content:\"\\f1fe\"}.fa-chart-bar:before{content:\"\\f080\"}.fa-chart-line:before{content:\"\\f201\"}.fa-chart-pie:before{content:\"\\f200\"}.fa-check:before{content:\"\\f00c\"}.fa-check-circle:before{content:\"\\f058\"}.fa-check-double:before{content:\"\\f560\"}.fa-check-square:before{content:\"\\f14a\"}.fa-cheese:before{content:\"\\f7ef\"}.fa-chess:before{content:\"\\f439\"}.fa-chess-bishop:before{content:\"\\f43a\"}.fa-chess-board:before{content:\"\\f43c\"}.fa-chess-king:before{content:\"\\f43f\"}.fa-chess-knight:before{content:\"\\f441\"}.fa-chess-pawn:before{content:\"\\f443\"}.fa-chess-queen:before{content:\"\\f445\"}.fa-chess-rook:before{content:\"\\f447\"}.fa-chevron-circle-down:before{content:\"\\f13a\"}.fa-chevron-circle-left:before{content:\"\\f137\"}.fa-chevron-circle-right:before{content:\"\\f138\"}.fa-chevron-circle-up:before{content:\"\\f139\"}.fa-chevron-down:before{content:\"\\f078\"}.fa-chevron-left:before{content:\"\\f053\"}.fa-chevron-right:before{content:\"\\f054\"}.fa-chevron-up:before{content:\"\\f077\"}.fa-child:before{content:\"\\f1ae\"}.fa-chrome:before{content:\"\\f268\"}.fa-chromecast:before{content:\"\\f838\"}.fa-church:before{content:\"\\f51d\"}.fa-circle:before{content:\"\\f111\"}.fa-circle-notch:before{content:\"\\f1ce\"}.fa-city:before{content:\"\\f64f\"}.fa-clinic-medical:before{content:\"\\f7f2\"}.fa-clipboard:before{content:\"\\f328\"}.fa-clipboard-check:before{content:\"\\f46c\"}.fa-clipboard-list:before{content:\"\\f46d\"}.fa-clock:before{content:\"\\f017\"}.fa-clone:before{content:\"\\f24d\"}.fa-closed-captioning:before{content:\"\\f20a\"}.fa-cloud:before{content:\"\\f0c2\"}.fa-cloud-download-alt:before{content:\"\\f381\"}.fa-cloud-meatball:before{content:\"\\f73b\"}.fa-cloud-moon:before{content:\"\\f6c3\"}.fa-cloud-moon-rain:before{content:\"\\f73c\"}.fa-cloud-rain:before{content:\"\\f73d\"}.fa-cloud-showers-heavy:before{content:\"\\f740\"}.fa-cloud-sun:before{content:\"\\f6c4\"}.fa-cloud-sun-rain:before{content:\"\\f743\"}.fa-cloud-upload-alt:before{content:\"\\f382\"}.fa-cloudscale:before{content:\"\\f383\"}.fa-cloudsmith:before{content:\"\\f384\"}.fa-cloudversify:before{content:\"\\f385\"}.fa-cocktail:before{content:\"\\f561\"}.fa-code:before{content:\"\\f121\"}.fa-code-branch:before{content:\"\\f126\"}.fa-codepen:before{content:\"\\f1cb\"}.fa-codiepie:before{content:\"\\f284\"}.fa-coffee:before{content:\"\\f0f4\"}.fa-cog:before{content:\"\\f013\"}.fa-cogs:before{content:\"\\f085\"}.fa-coins:before{content:\"\\f51e\"}.fa-columns:before{content:\"\\f0db\"}.fa-comment:before{content:\"\\f075\"}.fa-comment-alt:before{content:\"\\f27a\"}.fa-comment-dollar:before{content:\"\\f651\"}.fa-comment-dots:before{content:\"\\f4ad\"}.fa-comment-medical:before{content:\"\\f7f5\"}.fa-comment-slash:before{content:\"\\f4b3\"}.fa-comments:before{content:\"\\f086\"}.fa-comments-dollar:before{content:\"\\f653\"}.fa-compact-disc:before{content:\"\\f51f\"}.fa-compass:before{content:\"\\f14e\"}.fa-compress:before{content:\"\\f066\"}.fa-compress-alt:before{content:\"\\f422\"}.fa-compress-arrows-alt:before{content:\"\\f78c\"}.fa-concierge-bell:before{content:\"\\f562\"}.fa-confluence:before{content:\"\\f78d\"}.fa-connectdevelop:before{content:\"\\f20e\"}.fa-contao:before{content:\"\\f26d\"}.fa-cookie:before{content:\"\\f563\"}.fa-cookie-bite:before{content:\"\\f564\"}.fa-copy:before{content:\"\\f0c5\"}.fa-copyright:before{content:\"\\f1f9\"}.fa-cotton-bureau:before{content:\"\\f89e\"}.fa-couch:before{content:\"\\f4b8\"}.fa-cpanel:before{content:\"\\f388\"}.fa-creative-commons:before{content:\"\\f25e\"}.fa-creative-commons-by:before{content:\"\\f4e7\"}.fa-creative-commons-nc:before{content:\"\\f4e8\"}.fa-creative-commons-nc-eu:before{content:\"\\f4e9\"}.fa-creative-commons-nc-jp:before{content:\"\\f4ea\"}.fa-creative-commons-nd:before{content:\"\\f4eb\"}.fa-creative-commons-pd:before{content:\"\\f4ec\"}.fa-creative-commons-pd-alt:before{content:\"\\f4ed\"}.fa-creative-commons-remix:before{content:\"\\f4ee\"}.fa-creative-commons-sa:before{content:\"\\f4ef\"}.fa-creative-commons-sampling:before{content:\"\\f4f0\"}.fa-creative-commons-sampling-plus:before{content:\"\\f4f1\"}.fa-creative-commons-share:before{content:\"\\f4f2\"}.fa-creative-commons-zero:before{content:\"\\f4f3\"}.fa-credit-card:before{content:\"\\f09d\"}.fa-critical-role:before{content:\"\\f6c9\"}.fa-crop:before{content:\"\\f125\"}.fa-crop-alt:before{content:\"\\f565\"}.fa-cross:before{content:\"\\f654\"}.fa-crosshairs:before{content:\"\\f05b\"}.fa-crow:before{content:\"\\f520\"}.fa-crown:before{content:\"\\f521\"}.fa-crutch:before{content:\"\\f7f7\"}.fa-css3:before{content:\"\\f13c\"}.fa-css3-alt:before{content:\"\\f38b\"}.fa-cube:before{content:\"\\f1b2\"}.fa-cubes:before{content:\"\\f1b3\"}.fa-cut:before{content:\"\\f0c4\"}.fa-cuttlefish:before{content:\"\\f38c\"}.fa-d-and-d:before{content:\"\\f38d\"}.fa-d-and-d-beyond:before{content:\"\\f6ca\"}.fa-dashcube:before{content:\"\\f210\"}.fa-database:before{content:\"\\f1c0\"}.fa-deaf:before{content:\"\\f2a4\"}.fa-delicious:before{content:\"\\f1a5\"}.fa-democrat:before{content:\"\\f747\"}.fa-deploydog:before{content:\"\\f38e\"}.fa-deskpro:before{content:\"\\f38f\"}.fa-desktop:before{content:\"\\f108\"}.fa-dev:before{content:\"\\f6cc\"}.fa-deviantart:before{content:\"\\f1bd\"}.fa-dharmachakra:before{content:\"\\f655\"}.fa-dhl:before{content:\"\\f790\"}.fa-diagnoses:before{content:\"\\f470\"}.fa-diaspora:before{content:\"\\f791\"}.fa-dice:before{content:\"\\f522\"}.fa-dice-d20:before{content:\"\\f6cf\"}.fa-dice-d6:before{content:\"\\f6d1\"}.fa-dice-five:before{content:\"\\f523\"}.fa-dice-four:before{content:\"\\f524\"}.fa-dice-one:before{content:\"\\f525\"}.fa-dice-six:before{content:\"\\f526\"}.fa-dice-three:before{content:\"\\f527\"}.fa-dice-two:before{content:\"\\f528\"}.fa-digg:before{content:\"\\f1a6\"}.fa-digital-ocean:before{content:\"\\f391\"}.fa-digital-tachograph:before{content:\"\\f566\"}.fa-directions:before{content:\"\\f5eb\"}.fa-discord:before{content:\"\\f392\"}.fa-discourse:before{content:\"\\f393\"}.fa-divide:before{content:\"\\f529\"}.fa-dizzy:before{content:\"\\f567\"}.fa-dna:before{content:\"\\f471\"}.fa-dochub:before{content:\"\\f394\"}.fa-docker:before{content:\"\\f395\"}.fa-dog:before{content:\"\\f6d3\"}.fa-dollar-sign:before{content:\"\\f155\"}.fa-dolly:before{content:\"\\f472\"}.fa-dolly-flatbed:before{content:\"\\f474\"}.fa-donate:before{content:\"\\f4b9\"}.fa-door-closed:before{content:\"\\f52a\"}.fa-door-open:before{content:\"\\f52b\"}.fa-dot-circle:before{content:\"\\f192\"}.fa-dove:before{content:\"\\f4ba\"}.fa-download:before{content:\"\\f019\"}.fa-draft2digital:before{content:\"\\f396\"}.fa-drafting-compass:before{content:\"\\f568\"}.fa-dragon:before{content:\"\\f6d5\"}.fa-draw-polygon:before{content:\"\\f5ee\"}.fa-dribbble:before{content:\"\\f17d\"}.fa-dribbble-square:before{content:\"\\f397\"}.fa-dropbox:before{content:\"\\f16b\"}.fa-drum:before{content:\"\\f569\"}.fa-drum-steelpan:before{content:\"\\f56a\"}.fa-drumstick-bite:before{content:\"\\f6d7\"}.fa-drupal:before{content:\"\\f1a9\"}.fa-dumbbell:before{content:\"\\f44b\"}.fa-dumpster:before{content:\"\\f793\"}.fa-dumpster-fire:before{content:\"\\f794\"}.fa-dungeon:before{content:\"\\f6d9\"}.fa-dyalog:before{content:\"\\f399\"}.fa-earlybirds:before{content:\"\\f39a\"}.fa-ebay:before{content:\"\\f4f4\"}.fa-edge:before{content:\"\\f282\"}.fa-edit:before{content:\"\\f044\"}.fa-egg:before{content:\"\\f7fb\"}.fa-eject:before{content:\"\\f052\"}.fa-elementor:before{content:\"\\f430\"}.fa-ellipsis-h:before{content:\"\\f141\"}.fa-ellipsis-v:before{content:\"\\f142\"}.fa-ello:before{content:\"\\f5f1\"}.fa-ember:before{content:\"\\f423\"}.fa-empire:before{content:\"\\f1d1\"}.fa-envelope:before{content:\"\\f0e0\"}.fa-envelope-open:before{content:\"\\f2b6\"}.fa-envelope-open-text:before{content:\"\\f658\"}.fa-envelope-square:before{content:\"\\f199\"}.fa-envira:before{content:\"\\f299\"}.fa-equals:before{content:\"\\f52c\"}.fa-eraser:before{content:\"\\f12d\"}.fa-erlang:before{content:\"\\f39d\"}.fa-ethereum:before{content:\"\\f42e\"}.fa-ethernet:before{content:\"\\f796\"}.fa-etsy:before{content:\"\\f2d7\"}.fa-euro-sign:before{content:\"\\f153\"}.fa-evernote:before{content:\"\\f839\"}.fa-exchange-alt:before{content:\"\\f362\"}.fa-exclamation:before{content:\"\\f12a\"}.fa-exclamation-circle:before{content:\"\\f06a\"}.fa-exclamation-triangle:before{content:\"\\f071\"}.fa-expand:before{content:\"\\f065\"}.fa-expand-alt:before{content:\"\\f424\"}.fa-expand-arrows-alt:before{content:\"\\f31e\"}.fa-expeditedssl:before{content:\"\\f23e\"}.fa-external-link-alt:before{content:\"\\f35d\"}.fa-external-link-square-alt:before{content:\"\\f360\"}.fa-eye:before{content:\"\\f06e\"}.fa-eye-dropper:before{content:\"\\f1fb\"}.fa-eye-slash:before{content:\"\\f070\"}.fa-facebook:before{content:\"\\f09a\"}.fa-facebook-f:before{content:\"\\f39e\"}.fa-facebook-messenger:before{content:\"\\f39f\"}.fa-facebook-square:before{content:\"\\f082\"}.fa-fan:before{content:\"\\f863\"}.fa-fantasy-flight-games:before{content:\"\\f6dc\"}.fa-fast-backward:before{content:\"\\f049\"}.fa-fast-forward:before{content:\"\\f050\"}.fa-fax:before{content:\"\\f1ac\"}.fa-feather:before{content:\"\\f52d\"}.fa-feather-alt:before{content:\"\\f56b\"}.fa-fedex:before{content:\"\\f797\"}.fa-fedora:before{content:\"\\f798\"}.fa-female:before{content:\"\\f182\"}.fa-fighter-jet:before{content:\"\\f0fb\"}.fa-figma:before{content:\"\\f799\"}.fa-file:before{content:\"\\f15b\"}.fa-file-alt:before{content:\"\\f15c\"}.fa-file-archive:before{content:\"\\f1c6\"}.fa-file-audio:before{content:\"\\f1c7\"}.fa-file-code:before{content:\"\\f1c9\"}.fa-file-contract:before{content:\"\\f56c\"}.fa-file-csv:before{content:\"\\f6dd\"}.fa-file-download:before{content:\"\\f56d\"}.fa-file-excel:before{content:\"\\f1c3\"}.fa-file-export:before{content:\"\\f56e\"}.fa-file-image:before{content:\"\\f1c5\"}.fa-file-import:before{content:\"\\f56f\"}.fa-file-invoice:before{content:\"\\f570\"}.fa-file-invoice-dollar:before{content:\"\\f571\"}.fa-file-medical:before{content:\"\\f477\"}.fa-file-medical-alt:before{content:\"\\f478\"}.fa-file-pdf:before{content:\"\\f1c1\"}.fa-file-powerpoint:before{content:\"\\f1c4\"}.fa-file-prescription:before{content:\"\\f572\"}.fa-file-signature:before{content:\"\\f573\"}.fa-file-upload:before{content:\"\\f574\"}.fa-file-video:before{content:\"\\f1c8\"}.fa-file-word:before{content:\"\\f1c2\"}.fa-fill:before{content:\"\\f575\"}.fa-fill-drip:before{content:\"\\f576\"}.fa-film:before{content:\"\\f008\"}.fa-filter:before{content:\"\\f0b0\"}.fa-fingerprint:before{content:\"\\f577\"}.fa-fire:before{content:\"\\f06d\"}.fa-fire-alt:before{content:\"\\f7e4\"}.fa-fire-extinguisher:before{content:\"\\f134\"}.fa-firefox:before{content:\"\\f269\"}.fa-firefox-browser:before{content:\"\\f907\"}.fa-first-aid:before{content:\"\\f479\"}.fa-first-order:before{content:\"\\f2b0\"}.fa-first-order-alt:before{content:\"\\f50a\"}.fa-firstdraft:before{content:\"\\f3a1\"}.fa-fish:before{content:\"\\f578\"}.fa-fist-raised:before{content:\"\\f6de\"}.fa-flag:before{content:\"\\f024\"}.fa-flag-checkered:before{content:\"\\f11e\"}.fa-flag-usa:before{content:\"\\f74d\"}.fa-flask:before{content:\"\\f0c3\"}.fa-flickr:before{content:\"\\f16e\"}.fa-flipboard:before{content:\"\\f44d\"}.fa-flushed:before{content:\"\\f579\"}.fa-fly:before{content:\"\\f417\"}.fa-folder:before{content:\"\\f07b\"}.fa-folder-minus:before{content:\"\\f65d\"}.fa-folder-open:before{content:\"\\f07c\"}.fa-folder-plus:before{content:\"\\f65e\"}.fa-font:before{content:\"\\f031\"}.fa-font-awesome:before{content:\"\\f2b4\"}.fa-font-awesome-alt:before{content:\"\\f35c\"}.fa-font-awesome-flag:before{content:\"\\f425\"}.fa-font-awesome-logo-full:before{content:\"\\f4e6\"}.fa-fonticons:before{content:\"\\f280\"}.fa-fonticons-fi:before{content:\"\\f3a2\"}.fa-football-ball:before{content:\"\\f44e\"}.fa-fort-awesome:before{content:\"\\f286\"}.fa-fort-awesome-alt:before{content:\"\\f3a3\"}.fa-forumbee:before{content:\"\\f211\"}.fa-forward:before{content:\"\\f04e\"}.fa-foursquare:before{content:\"\\f180\"}.fa-free-code-camp:before{content:\"\\f2c5\"}.fa-freebsd:before{content:\"\\f3a4\"}.fa-frog:before{content:\"\\f52e\"}.fa-frown:before{content:\"\\f119\"}.fa-frown-open:before{content:\"\\f57a\"}.fa-fulcrum:before{content:\"\\f50b\"}.fa-funnel-dollar:before{content:\"\\f662\"}.fa-futbol:before{content:\"\\f1e3\"}.fa-galactic-republic:before{content:\"\\f50c\"}.fa-galactic-senate:before{content:\"\\f50d\"}.fa-gamepad:before{content:\"\\f11b\"}.fa-gas-pump:before{content:\"\\f52f\"}.fa-gavel:before{content:\"\\f0e3\"}.fa-gem:before{content:\"\\f3a5\"}.fa-genderless:before{content:\"\\f22d\"}.fa-get-pocket:before{content:\"\\f265\"}.fa-gg:before{content:\"\\f260\"}.fa-gg-circle:before{content:\"\\f261\"}.fa-ghost:before{content:\"\\f6e2\"}.fa-gift:before{content:\"\\f06b\"}.fa-gifts:before{content:\"\\f79c\"}.fa-git:before{content:\"\\f1d3\"}.fa-git-alt:before{content:\"\\f841\"}.fa-git-square:before{content:\"\\f1d2\"}.fa-github:before{content:\"\\f09b\"}.fa-github-alt:before{content:\"\\f113\"}.fa-github-square:before{content:\"\\f092\"}.fa-gitkraken:before{content:\"\\f3a6\"}.fa-gitlab:before{content:\"\\f296\"}.fa-gitter:before{content:\"\\f426\"}.fa-glass-cheers:before{content:\"\\f79f\"}.fa-glass-martini:before{content:\"\\f000\"}.fa-glass-martini-alt:before{content:\"\\f57b\"}.fa-glass-whiskey:before{content:\"\\f7a0\"}.fa-glasses:before{content:\"\\f530\"}.fa-glide:before{content:\"\\f2a5\"}.fa-glide-g:before{content:\"\\f2a6\"}.fa-globe:before{content:\"\\f0ac\"}.fa-globe-africa:before{content:\"\\f57c\"}.fa-globe-americas:before{content:\"\\f57d\"}.fa-globe-asia:before{content:\"\\f57e\"}.fa-globe-europe:before{content:\"\\f7a2\"}.fa-gofore:before{content:\"\\f3a7\"}.fa-golf-ball:before{content:\"\\f450\"}.fa-goodreads:before{content:\"\\f3a8\"}.fa-goodreads-g:before{content:\"\\f3a9\"}.fa-google:before{content:\"\\f1a0\"}.fa-google-drive:before{content:\"\\f3aa\"}.fa-google-play:before{content:\"\\f3ab\"}.fa-google-plus:before{content:\"\\f2b3\"}.fa-google-plus-g:before{content:\"\\f0d5\"}.fa-google-plus-square:before{content:\"\\f0d4\"}.fa-google-wallet:before{content:\"\\f1ee\"}.fa-gopuram:before{content:\"\\f664\"}.fa-graduation-cap:before{content:\"\\f19d\"}.fa-gratipay:before{content:\"\\f184\"}.fa-grav:before{content:\"\\f2d6\"}.fa-greater-than:before{content:\"\\f531\"}.fa-greater-than-equal:before{content:\"\\f532\"}.fa-grimace:before{content:\"\\f57f\"}.fa-grin:before{content:\"\\f580\"}.fa-grin-alt:before{content:\"\\f581\"}.fa-grin-beam:before{content:\"\\f582\"}.fa-grin-beam-sweat:before{content:\"\\f583\"}.fa-grin-hearts:before{content:\"\\f584\"}.fa-grin-squint:before{content:\"\\f585\"}.fa-grin-squint-tears:before{content:\"\\f586\"}.fa-grin-stars:before{content:\"\\f587\"}.fa-grin-tears:before{content:\"\\f588\"}.fa-grin-tongue:before{content:\"\\f589\"}.fa-grin-tongue-squint:before{content:\"\\f58a\"}.fa-grin-tongue-wink:before{content:\"\\f58b\"}.fa-grin-wink:before{content:\"\\f58c\"}.fa-grip-horizontal:before{content:\"\\f58d\"}.fa-grip-lines:before{content:\"\\f7a4\"}.fa-grip-lines-vertical:before{content:\"\\f7a5\"}.fa-grip-vertical:before{content:\"\\f58e\"}.fa-gripfire:before{content:\"\\f3ac\"}.fa-grunt:before{content:\"\\f3ad\"}.fa-guitar:before{content:\"\\f7a6\"}.fa-gulp:before{content:\"\\f3ae\"}.fa-h-square:before{content:\"\\f0fd\"}.fa-hacker-news:before{content:\"\\f1d4\"}.fa-hacker-news-square:before{content:\"\\f3af\"}.fa-hackerrank:before{content:\"\\f5f7\"}.fa-hamburger:before{content:\"\\f805\"}.fa-hammer:before{content:\"\\f6e3\"}.fa-hamsa:before{content:\"\\f665\"}.fa-hand-holding:before{content:\"\\f4bd\"}.fa-hand-holding-heart:before{content:\"\\f4be\"}.fa-hand-holding-usd:before{content:\"\\f4c0\"}.fa-hand-lizard:before{content:\"\\f258\"}.fa-hand-middle-finger:before{content:\"\\f806\"}.fa-hand-paper:before{content:\"\\f256\"}.fa-hand-peace:before{content:\"\\f25b\"}.fa-hand-point-down:before{content:\"\\f0a7\"}.fa-hand-point-left:before{content:\"\\f0a5\"}.fa-hand-point-right:before{content:\"\\f0a4\"}.fa-hand-point-up:before{content:\"\\f0a6\"}.fa-hand-pointer:before{content:\"\\f25a\"}.fa-hand-rock:before{content:\"\\f255\"}.fa-hand-scissors:before{content:\"\\f257\"}.fa-hand-spock:before{content:\"\\f259\"}.fa-hands:before{content:\"\\f4c2\"}.fa-hands-helping:before{content:\"\\f4c4\"}.fa-handshake:before{content:\"\\f2b5\"}.fa-hanukiah:before{content:\"\\f6e6\"}.fa-hard-hat:before{content:\"\\f807\"}.fa-hashtag:before{content:\"\\f292\"}.fa-hat-cowboy:before{content:\"\\f8c0\"}.fa-hat-cowboy-side:before{content:\"\\f8c1\"}.fa-hat-wizard:before{content:\"\\f6e8\"}.fa-hdd:before{content:\"\\f0a0\"}.fa-heading:before{content:\"\\f1dc\"}.fa-headphones:before{content:\"\\f025\"}.fa-headphones-alt:before{content:\"\\f58f\"}.fa-headset:before{content:\"\\f590\"}.fa-heart:before{content:\"\\f004\"}.fa-heart-broken:before{content:\"\\f7a9\"}.fa-heartbeat:before{content:\"\\f21e\"}.fa-helicopter:before{content:\"\\f533\"}.fa-highlighter:before{content:\"\\f591\"}.fa-hiking:before{content:\"\\f6ec\"}.fa-hippo:before{content:\"\\f6ed\"}.fa-hips:before{content:\"\\f452\"}.fa-hire-a-helper:before{content:\"\\f3b0\"}.fa-history:before{content:\"\\f1da\"}.fa-hockey-puck:before{content:\"\\f453\"}.fa-holly-berry:before{content:\"\\f7aa\"}.fa-home:before{content:\"\\f015\"}.fa-hooli:before{content:\"\\f427\"}.fa-hornbill:before{content:\"\\f592\"}.fa-horse:before{content:\"\\f6f0\"}.fa-horse-head:before{content:\"\\f7ab\"}.fa-hospital:before{content:\"\\f0f8\"}.fa-hospital-alt:before{content:\"\\f47d\"}.fa-hospital-symbol:before{content:\"\\f47e\"}.fa-hot-tub:before{content:\"\\f593\"}.fa-hotdog:before{content:\"\\f80f\"}.fa-hotel:before{content:\"\\f594\"}.fa-hotjar:before{content:\"\\f3b1\"}.fa-hourglass:before{content:\"\\f254\"}.fa-hourglass-end:before{content:\"\\f253\"}.fa-hourglass-half:before{content:\"\\f252\"}.fa-hourglass-start:before{content:\"\\f251\"}.fa-house-damage:before{content:\"\\f6f1\"}.fa-houzz:before{content:\"\\f27c\"}.fa-hryvnia:before{content:\"\\f6f2\"}.fa-html5:before{content:\"\\f13b\"}.fa-hubspot:before{content:\"\\f3b2\"}.fa-i-cursor:before{content:\"\\f246\"}.fa-ice-cream:before{content:\"\\f810\"}.fa-icicles:before{content:\"\\f7ad\"}.fa-icons:before{content:\"\\f86d\"}.fa-id-badge:before{content:\"\\f2c1\"}.fa-id-card:before{content:\"\\f2c2\"}.fa-id-card-alt:before{content:\"\\f47f\"}.fa-ideal:before{content:\"\\f913\"}.fa-igloo:before{content:\"\\f7ae\"}.fa-image:before{content:\"\\f03e\"}.fa-images:before{content:\"\\f302\"}.fa-imdb:before{content:\"\\f2d8\"}.fa-inbox:before{content:\"\\f01c\"}.fa-indent:before{content:\"\\f03c\"}.fa-industry:before{content:\"\\f275\"}.fa-infinity:before{content:\"\\f534\"}.fa-info:before{content:\"\\f129\"}.fa-info-circle:before{content:\"\\f05a\"}.fa-instagram:before{content:\"\\f16d\"}.fa-intercom:before{content:\"\\f7af\"}.fa-internet-explorer:before{content:\"\\f26b\"}.fa-invision:before{content:\"\\f7b0\"}.fa-ioxhost:before{content:\"\\f208\"}.fa-italic:before{content:\"\\f033\"}.fa-itch-io:before{content:\"\\f83a\"}.fa-itunes:before{content:\"\\f3b4\"}.fa-itunes-note:before{content:\"\\f3b5\"}.fa-java:before{content:\"\\f4e4\"}.fa-jedi:before{content:\"\\f669\"}.fa-jedi-order:before{content:\"\\f50e\"}.fa-jenkins:before{content:\"\\f3b6\"}.fa-jira:before{content:\"\\f7b1\"}.fa-joget:before{content:\"\\f3b7\"}.fa-joint:before{content:\"\\f595\"}.fa-joomla:before{content:\"\\f1aa\"}.fa-journal-whills:before{content:\"\\f66a\"}.fa-js:before{content:\"\\f3b8\"}.fa-js-square:before{content:\"\\f3b9\"}.fa-jsfiddle:before{content:\"\\f1cc\"}.fa-kaaba:before{content:\"\\f66b\"}.fa-kaggle:before{content:\"\\f5fa\"}.fa-key:before{content:\"\\f084\"}.fa-keybase:before{content:\"\\f4f5\"}.fa-keyboard:before{content:\"\\f11c\"}.fa-keycdn:before{content:\"\\f3ba\"}.fa-khanda:before{content:\"\\f66d\"}.fa-kickstarter:before{content:\"\\f3bb\"}.fa-kickstarter-k:before{content:\"\\f3bc\"}.fa-kiss:before{content:\"\\f596\"}.fa-kiss-beam:before{content:\"\\f597\"}.fa-kiss-wink-heart:before{content:\"\\f598\"}.fa-kiwi-bird:before{content:\"\\f535\"}.fa-korvue:before{content:\"\\f42f\"}.fa-landmark:before{content:\"\\f66f\"}.fa-language:before{content:\"\\f1ab\"}.fa-laptop:before{content:\"\\f109\"}.fa-laptop-code:before{content:\"\\f5fc\"}.fa-laptop-medical:before{content:\"\\f812\"}.fa-laravel:before{content:\"\\f3bd\"}.fa-lastfm:before{content:\"\\f202\"}.fa-lastfm-square:before{content:\"\\f203\"}.fa-laugh:before{content:\"\\f599\"}.fa-laugh-beam:before{content:\"\\f59a\"}.fa-laugh-squint:before{content:\"\\f59b\"}.fa-laugh-wink:before{content:\"\\f59c\"}.fa-layer-group:before{content:\"\\f5fd\"}.fa-leaf:before{content:\"\\f06c\"}.fa-leanpub:before{content:\"\\f212\"}.fa-lemon:before{content:\"\\f094\"}.fa-less:before{content:\"\\f41d\"}.fa-less-than:before{content:\"\\f536\"}.fa-less-than-equal:before{content:\"\\f537\"}.fa-level-down-alt:before{content:\"\\f3be\"}.fa-level-up-alt:before{content:\"\\f3bf\"}.fa-life-ring:before{content:\"\\f1cd\"}.fa-lightbulb:before{content:\"\\f0eb\"}.fa-line:before{content:\"\\f3c0\"}.fa-link:before{content:\"\\f0c1\"}.fa-linkedin:before{content:\"\\f08c\"}.fa-linkedin-in:before{content:\"\\f0e1\"}.fa-linode:before{content:\"\\f2b8\"}.fa-linux:before{content:\"\\f17c\"}.fa-lira-sign:before{content:\"\\f195\"}.fa-list:before{content:\"\\f03a\"}.fa-list-alt:before{content:\"\\f022\"}.fa-list-ol:before{content:\"\\f0cb\"}.fa-list-ul:before{content:\"\\f0ca\"}.fa-location-arrow:before{content:\"\\f124\"}.fa-lock:before{content:\"\\f023\"}.fa-lock-open:before{content:\"\\f3c1\"}.fa-long-arrow-alt-down:before{content:\"\\f309\"}.fa-long-arrow-alt-left:before{content:\"\\f30a\"}.fa-long-arrow-alt-right:before{content:\"\\f30b\"}.fa-long-arrow-alt-up:before{content:\"\\f30c\"}.fa-low-vision:before{content:\"\\f2a8\"}.fa-luggage-cart:before{content:\"\\f59d\"}.fa-lyft:before{content:\"\\f3c3\"}.fa-magento:before{content:\"\\f3c4\"}.fa-magic:before{content:\"\\f0d0\"}.fa-magnet:before{content:\"\\f076\"}.fa-mail-bulk:before{content:\"\\f674\"}.fa-mailchimp:before{content:\"\\f59e\"}.fa-male:before{content:\"\\f183\"}.fa-mandalorian:before{content:\"\\f50f\"}.fa-map:before{content:\"\\f279\"}.fa-map-marked:before{content:\"\\f59f\"}.fa-map-marked-alt:before{content:\"\\f5a0\"}.fa-map-marker:before{content:\"\\f041\"}.fa-map-marker-alt:before{content:\"\\f3c5\"}.fa-map-pin:before{content:\"\\f276\"}.fa-map-signs:before{content:\"\\f277\"}.fa-markdown:before{content:\"\\f60f\"}.fa-marker:before{content:\"\\f5a1\"}.fa-mars:before{content:\"\\f222\"}.fa-mars-double:before{content:\"\\f227\"}.fa-mars-stroke:before{content:\"\\f229\"}.fa-mars-stroke-h:before{content:\"\\f22b\"}.fa-mars-stroke-v:before{content:\"\\f22a\"}.fa-mask:before{content:\"\\f6fa\"}.fa-mastodon:before{content:\"\\f4f6\"}.fa-maxcdn:before{content:\"\\f136\"}.fa-mdb:before{content:\"\\f8ca\"}.fa-medal:before{content:\"\\f5a2\"}.fa-medapps:before{content:\"\\f3c6\"}.fa-medium:before{content:\"\\f23a\"}.fa-medium-m:before{content:\"\\f3c7\"}.fa-medkit:before{content:\"\\f0fa\"}.fa-medrt:before{content:\"\\f3c8\"}.fa-meetup:before{content:\"\\f2e0\"}.fa-megaport:before{content:\"\\f5a3\"}.fa-meh:before{content:\"\\f11a\"}.fa-meh-blank:before{content:\"\\f5a4\"}.fa-meh-rolling-eyes:before{content:\"\\f5a5\"}.fa-memory:before{content:\"\\f538\"}.fa-mendeley:before{content:\"\\f7b3\"}.fa-menorah:before{content:\"\\f676\"}.fa-mercury:before{content:\"\\f223\"}.fa-meteor:before{content:\"\\f753\"}.fa-microblog:before{content:\"\\f91a\"}.fa-microchip:before{content:\"\\f2db\"}.fa-microphone:before{content:\"\\f130\"}.fa-microphone-alt:before{content:\"\\f3c9\"}.fa-microphone-alt-slash:before{content:\"\\f539\"}.fa-microphone-slash:before{content:\"\\f131\"}.fa-microscope:before{content:\"\\f610\"}.fa-microsoft:before{content:\"\\f3ca\"}.fa-minus:before{content:\"\\f068\"}.fa-minus-circle:before{content:\"\\f056\"}.fa-minus-square:before{content:\"\\f146\"}.fa-mitten:before{content:\"\\f7b5\"}.fa-mix:before{content:\"\\f3cb\"}.fa-mixcloud:before{content:\"\\f289\"}.fa-mizuni:before{content:\"\\f3cc\"}.fa-mobile:before{content:\"\\f10b\"}.fa-mobile-alt:before{content:\"\\f3cd\"}.fa-modx:before{content:\"\\f285\"}.fa-monero:before{content:\"\\f3d0\"}.fa-money-bill:before{content:\"\\f0d6\"}.fa-money-bill-alt:before{content:\"\\f3d1\"}.fa-money-bill-wave:before{content:\"\\f53a\"}.fa-money-bill-wave-alt:before{content:\"\\f53b\"}.fa-money-check:before{content:\"\\f53c\"}.fa-money-check-alt:before{content:\"\\f53d\"}.fa-monument:before{content:\"\\f5a6\"}.fa-moon:before{content:\"\\f186\"}.fa-mortar-pestle:before{content:\"\\f5a7\"}.fa-mosque:before{content:\"\\f678\"}.fa-motorcycle:before{content:\"\\f21c\"}.fa-mountain:before{content:\"\\f6fc\"}.fa-mouse:before{content:\"\\f8cc\"}.fa-mouse-pointer:before{content:\"\\f245\"}.fa-mug-hot:before{content:\"\\f7b6\"}.fa-music:before{content:\"\\f001\"}.fa-napster:before{content:\"\\f3d2\"}.fa-neos:before{content:\"\\f612\"}.fa-network-wired:before{content:\"\\f6ff\"}.fa-neuter:before{content:\"\\f22c\"}.fa-newspaper:before{content:\"\\f1ea\"}.fa-nimblr:before{content:\"\\f5a8\"}.fa-node:before{content:\"\\f419\"}.fa-node-js:before{content:\"\\f3d3\"}.fa-not-equal:before{content:\"\\f53e\"}.fa-notes-medical:before{content:\"\\f481\"}.fa-npm:before{content:\"\\f3d4\"}.fa-ns8:before{content:\"\\f3d5\"}.fa-nutritionix:before{content:\"\\f3d6\"}.fa-object-group:before{content:\"\\f247\"}.fa-object-ungroup:before{content:\"\\f248\"}.fa-odnoklassniki:before{content:\"\\f263\"}.fa-odnoklassniki-square:before{content:\"\\f264\"}.fa-oil-can:before{content:\"\\f613\"}.fa-old-republic:before{content:\"\\f510\"}.fa-om:before{content:\"\\f679\"}.fa-opencart:before{content:\"\\f23d\"}.fa-openid:before{content:\"\\f19b\"}.fa-opera:before{content:\"\\f26a\"}.fa-optin-monster:before{content:\"\\f23c\"}.fa-orcid:before{content:\"\\f8d2\"}.fa-osi:before{content:\"\\f41a\"}.fa-otter:before{content:\"\\f700\"}.fa-outdent:before{content:\"\\f03b\"}.fa-page4:before{content:\"\\f3d7\"}.fa-pagelines:before{content:\"\\f18c\"}.fa-pager:before{content:\"\\f815\"}.fa-paint-brush:before{content:\"\\f1fc\"}.fa-paint-roller:before{content:\"\\f5aa\"}.fa-palette:before{content:\"\\f53f\"}.fa-palfed:before{content:\"\\f3d8\"}.fa-pallet:before{content:\"\\f482\"}.fa-paper-plane:before{content:\"\\f1d8\"}.fa-paperclip:before{content:\"\\f0c6\"}.fa-parachute-box:before{content:\"\\f4cd\"}.fa-paragraph:before{content:\"\\f1dd\"}.fa-parking:before{content:\"\\f540\"}.fa-passport:before{content:\"\\f5ab\"}.fa-pastafarianism:before{content:\"\\f67b\"}.fa-paste:before{content:\"\\f0ea\"}.fa-patreon:before{content:\"\\f3d9\"}.fa-pause:before{content:\"\\f04c\"}.fa-pause-circle:before{content:\"\\f28b\"}.fa-paw:before{content:\"\\f1b0\"}.fa-paypal:before{content:\"\\f1ed\"}.fa-peace:before{content:\"\\f67c\"}.fa-pen:before{content:\"\\f304\"}.fa-pen-alt:before{content:\"\\f305\"}.fa-pen-fancy:before{content:\"\\f5ac\"}.fa-pen-nib:before{content:\"\\f5ad\"}.fa-pen-square:before{content:\"\\f14b\"}.fa-pencil-alt:before{content:\"\\f303\"}.fa-pencil-ruler:before{content:\"\\f5ae\"}.fa-penny-arcade:before{content:\"\\f704\"}.fa-people-carry:before{content:\"\\f4ce\"}.fa-pepper-hot:before{content:\"\\f816\"}.fa-percent:before{content:\"\\f295\"}.fa-percentage:before{content:\"\\f541\"}.fa-periscope:before{content:\"\\f3da\"}.fa-person-booth:before{content:\"\\f756\"}.fa-phabricator:before{content:\"\\f3db\"}.fa-phoenix-framework:before{content:\"\\f3dc\"}.fa-phoenix-squadron:before{content:\"\\f511\"}.fa-phone:before{content:\"\\f095\"}.fa-phone-alt:before{content:\"\\f879\"}.fa-phone-slash:before{content:\"\\f3dd\"}.fa-phone-square:before{content:\"\\f098\"}.fa-phone-square-alt:before{content:\"\\f87b\"}.fa-phone-volume:before{content:\"\\f2a0\"}.fa-photo-video:before{content:\"\\f87c\"}.fa-php:before{content:\"\\f457\"}.fa-pied-piper:before{content:\"\\f2ae\"}.fa-pied-piper-alt:before{content:\"\\f1a8\"}.fa-pied-piper-hat:before{content:\"\\f4e5\"}.fa-pied-piper-pp:before{content:\"\\f1a7\"}.fa-pied-piper-square:before{content:\"\\f91e\"}.fa-piggy-bank:before{content:\"\\f4d3\"}.fa-pills:before{content:\"\\f484\"}.fa-pinterest:before{content:\"\\f0d2\"}.fa-pinterest-p:before{content:\"\\f231\"}.fa-pinterest-square:before{content:\"\\f0d3\"}.fa-pizza-slice:before{content:\"\\f818\"}.fa-place-of-worship:before{content:\"\\f67f\"}.fa-plane:before{content:\"\\f072\"}.fa-plane-arrival:before{content:\"\\f5af\"}.fa-plane-departure:before{content:\"\\f5b0\"}.fa-play:before{content:\"\\f04b\"}.fa-play-circle:before{content:\"\\f144\"}.fa-playstation:before{content:\"\\f3df\"}.fa-plug:before{content:\"\\f1e6\"}.fa-plus:before{content:\"\\f067\"}.fa-plus-circle:before{content:\"\\f055\"}.fa-plus-square:before{content:\"\\f0fe\"}.fa-podcast:before{content:\"\\f2ce\"}.fa-poll:before{content:\"\\f681\"}.fa-poll-h:before{content:\"\\f682\"}.fa-poo:before{content:\"\\f2fe\"}.fa-poo-storm:before{content:\"\\f75a\"}.fa-poop:before{content:\"\\f619\"}.fa-portrait:before{content:\"\\f3e0\"}.fa-pound-sign:before{content:\"\\f154\"}.fa-power-off:before{content:\"\\f011\"}.fa-pray:before{content:\"\\f683\"}.fa-praying-hands:before{content:\"\\f684\"}.fa-prescription:before{content:\"\\f5b1\"}.fa-prescription-bottle:before{content:\"\\f485\"}.fa-prescription-bottle-alt:before{content:\"\\f486\"}.fa-print:before{content:\"\\f02f\"}.fa-procedures:before{content:\"\\f487\"}.fa-product-hunt:before{content:\"\\f288\"}.fa-project-diagram:before{content:\"\\f542\"}.fa-pushed:before{content:\"\\f3e1\"}.fa-puzzle-piece:before{content:\"\\f12e\"}.fa-python:before{content:\"\\f3e2\"}.fa-qq:before{content:\"\\f1d6\"}.fa-qrcode:before{content:\"\\f029\"}.fa-question:before{content:\"\\f128\"}.fa-question-circle:before{content:\"\\f059\"}.fa-quidditch:before{content:\"\\f458\"}.fa-quinscape:before{content:\"\\f459\"}.fa-quora:before{content:\"\\f2c4\"}.fa-quote-left:before{content:\"\\f10d\"}.fa-quote-right:before{content:\"\\f10e\"}.fa-quran:before{content:\"\\f687\"}.fa-r-project:before{content:\"\\f4f7\"}.fa-radiation:before{content:\"\\f7b9\"}.fa-radiation-alt:before{content:\"\\f7ba\"}.fa-rainbow:before{content:\"\\f75b\"}.fa-random:before{content:\"\\f074\"}.fa-raspberry-pi:before{content:\"\\f7bb\"}.fa-ravelry:before{content:\"\\f2d9\"}.fa-react:before{content:\"\\f41b\"}.fa-reacteurope:before{content:\"\\f75d\"}.fa-readme:before{content:\"\\f4d5\"}.fa-rebel:before{content:\"\\f1d0\"}.fa-receipt:before{content:\"\\f543\"}.fa-record-vinyl:before{content:\"\\f8d9\"}.fa-recycle:before{content:\"\\f1b8\"}.fa-red-river:before{content:\"\\f3e3\"}.fa-reddit:before{content:\"\\f1a1\"}.fa-reddit-alien:before{content:\"\\f281\"}.fa-reddit-square:before{content:\"\\f1a2\"}.fa-redhat:before{content:\"\\f7bc\"}.fa-redo:before{content:\"\\f01e\"}.fa-redo-alt:before{content:\"\\f2f9\"}.fa-registered:before{content:\"\\f25d\"}.fa-remove-format:before{content:\"\\f87d\"}.fa-renren:before{content:\"\\f18b\"}.fa-reply:before{content:\"\\f3e5\"}.fa-reply-all:before{content:\"\\f122\"}.fa-replyd:before{content:\"\\f3e6\"}.fa-republican:before{content:\"\\f75e\"}.fa-researchgate:before{content:\"\\f4f8\"}.fa-resolving:before{content:\"\\f3e7\"}.fa-restroom:before{content:\"\\f7bd\"}.fa-retweet:before{content:\"\\f079\"}.fa-rev:before{content:\"\\f5b2\"}.fa-ribbon:before{content:\"\\f4d6\"}.fa-ring:before{content:\"\\f70b\"}.fa-road:before{content:\"\\f018\"}.fa-robot:before{content:\"\\f544\"}.fa-rocket:before{content:\"\\f135\"}.fa-rocketchat:before{content:\"\\f3e8\"}.fa-rockrms:before{content:\"\\f3e9\"}.fa-route:before{content:\"\\f4d7\"}.fa-rss:before{content:\"\\f09e\"}.fa-rss-square:before{content:\"\\f143\"}.fa-ruble-sign:before{content:\"\\f158\"}.fa-ruler:before{content:\"\\f545\"}.fa-ruler-combined:before{content:\"\\f546\"}.fa-ruler-horizontal:before{content:\"\\f547\"}.fa-ruler-vertical:before{content:\"\\f548\"}.fa-running:before{content:\"\\f70c\"}.fa-rupee-sign:before{content:\"\\f156\"}.fa-sad-cry:before{content:\"\\f5b3\"}.fa-sad-tear:before{content:\"\\f5b4\"}.fa-safari:before{content:\"\\f267\"}.fa-salesforce:before{content:\"\\f83b\"}.fa-sass:before{content:\"\\f41e\"}.fa-satellite:before{content:\"\\f7bf\"}.fa-satellite-dish:before{content:\"\\f7c0\"}.fa-save:before{content:\"\\f0c7\"}.fa-schlix:before{content:\"\\f3ea\"}.fa-school:before{content:\"\\f549\"}.fa-screwdriver:before{content:\"\\f54a\"}.fa-scribd:before{content:\"\\f28a\"}.fa-scroll:before{content:\"\\f70e\"}.fa-sd-card:before{content:\"\\f7c2\"}.fa-search:before{content:\"\\f002\"}.fa-search-dollar:before{content:\"\\f688\"}.fa-search-location:before{content:\"\\f689\"}.fa-search-minus:before{content:\"\\f010\"}.fa-search-plus:before{content:\"\\f00e\"}.fa-searchengin:before{content:\"\\f3eb\"}.fa-seedling:before{content:\"\\f4d8\"}.fa-sellcast:before{content:\"\\f2da\"}.fa-sellsy:before{content:\"\\f213\"}.fa-server:before{content:\"\\f233\"}.fa-servicestack:before{content:\"\\f3ec\"}.fa-shapes:before{content:\"\\f61f\"}.fa-share:before{content:\"\\f064\"}.fa-share-alt:before{content:\"\\f1e0\"}.fa-share-alt-square:before{content:\"\\f1e1\"}.fa-share-square:before{content:\"\\f14d\"}.fa-shekel-sign:before{content:\"\\f20b\"}.fa-shield-alt:before{content:\"\\f3ed\"}.fa-ship:before{content:\"\\f21a\"}.fa-shipping-fast:before{content:\"\\f48b\"}.fa-shirtsinbulk:before{content:\"\\f214\"}.fa-shoe-prints:before{content:\"\\f54b\"}.fa-shopping-bag:before{content:\"\\f290\"}.fa-shopping-basket:before{content:\"\\f291\"}.fa-shopping-cart:before{content:\"\\f07a\"}.fa-shopware:before{content:\"\\f5b5\"}.fa-shower:before{content:\"\\f2cc\"}.fa-shuttle-van:before{content:\"\\f5b6\"}.fa-sign:before{content:\"\\f4d9\"}.fa-sign-in-alt:before{content:\"\\f2f6\"}.fa-sign-language:before{content:\"\\f2a7\"}.fa-sign-out-alt:before{content:\"\\f2f5\"}.fa-signal:before{content:\"\\f012\"}.fa-signature:before{content:\"\\f5b7\"}.fa-sim-card:before{content:\"\\f7c4\"}.fa-simplybuilt:before{content:\"\\f215\"}.fa-sistrix:before{content:\"\\f3ee\"}.fa-sitemap:before{content:\"\\f0e8\"}.fa-sith:before{content:\"\\f512\"}.fa-skating:before{content:\"\\f7c5\"}.fa-sketch:before{content:\"\\f7c6\"}.fa-skiing:before{content:\"\\f7c9\"}.fa-skiing-nordic:before{content:\"\\f7ca\"}.fa-skull:before{content:\"\\f54c\"}.fa-skull-crossbones:before{content:\"\\f714\"}.fa-skyatlas:before{content:\"\\f216\"}.fa-skype:before{content:\"\\f17e\"}.fa-slack:before{content:\"\\f198\"}.fa-slack-hash:before{content:\"\\f3ef\"}.fa-slash:before{content:\"\\f715\"}.fa-sleigh:before{content:\"\\f7cc\"}.fa-sliders-h:before{content:\"\\f1de\"}.fa-slideshare:before{content:\"\\f1e7\"}.fa-smile:before{content:\"\\f118\"}.fa-smile-beam:before{content:\"\\f5b8\"}.fa-smile-wink:before{content:\"\\f4da\"}.fa-smog:before{content:\"\\f75f\"}.fa-smoking:before{content:\"\\f48d\"}.fa-smoking-ban:before{content:\"\\f54d\"}.fa-sms:before{content:\"\\f7cd\"}.fa-snapchat:before{content:\"\\f2ab\"}.fa-snapchat-ghost:before{content:\"\\f2ac\"}.fa-snapchat-square:before{content:\"\\f2ad\"}.fa-snowboarding:before{content:\"\\f7ce\"}.fa-snowflake:before{content:\"\\f2dc\"}.fa-snowman:before{content:\"\\f7d0\"}.fa-snowplow:before{content:\"\\f7d2\"}.fa-socks:before{content:\"\\f696\"}.fa-solar-panel:before{content:\"\\f5ba\"}.fa-sort:before{content:\"\\f0dc\"}.fa-sort-alpha-down:before{content:\"\\f15d\"}.fa-sort-alpha-down-alt:before{content:\"\\f881\"}.fa-sort-alpha-up:before{content:\"\\f15e\"}.fa-sort-alpha-up-alt:before{content:\"\\f882\"}.fa-sort-amount-down:before{content:\"\\f160\"}.fa-sort-amount-down-alt:before{content:\"\\f884\"}.fa-sort-amount-up:before{content:\"\\f161\"}.fa-sort-amount-up-alt:before{content:\"\\f885\"}.fa-sort-down:before{content:\"\\f0dd\"}.fa-sort-numeric-down:before{content:\"\\f162\"}.fa-sort-numeric-down-alt:before{content:\"\\f886\"}.fa-sort-numeric-up:before{content:\"\\f163\"}.fa-sort-numeric-up-alt:before{content:\"\\f887\"}.fa-sort-up:before{content:\"\\f0de\"}.fa-soundcloud:before{content:\"\\f1be\"}.fa-sourcetree:before{content:\"\\f7d3\"}.fa-spa:before{content:\"\\f5bb\"}.fa-space-shuttle:before{content:\"\\f197\"}.fa-speakap:before{content:\"\\f3f3\"}.fa-speaker-deck:before{content:\"\\f83c\"}.fa-spell-check:before{content:\"\\f891\"}.fa-spider:before{content:\"\\f717\"}.fa-spinner:before{content:\"\\f110\"}.fa-splotch:before{content:\"\\f5bc\"}.fa-spotify:before{content:\"\\f1bc\"}.fa-spray-can:before{content:\"\\f5bd\"}.fa-square:before{content:\"\\f0c8\"}.fa-square-full:before{content:\"\\f45c\"}.fa-square-root-alt:before{content:\"\\f698\"}.fa-squarespace:before{content:\"\\f5be\"}.fa-stack-exchange:before{content:\"\\f18d\"}.fa-stack-overflow:before{content:\"\\f16c\"}.fa-stackpath:before{content:\"\\f842\"}.fa-stamp:before{content:\"\\f5bf\"}.fa-star:before{content:\"\\f005\"}.fa-star-and-crescent:before{content:\"\\f699\"}.fa-star-half:before{content:\"\\f089\"}.fa-star-half-alt:before{content:\"\\f5c0\"}.fa-star-of-david:before{content:\"\\f69a\"}.fa-star-of-life:before{content:\"\\f621\"}.fa-staylinked:before{content:\"\\f3f5\"}.fa-steam:before{content:\"\\f1b6\"}.fa-steam-square:before{content:\"\\f1b7\"}.fa-steam-symbol:before{content:\"\\f3f6\"}.fa-step-backward:before{content:\"\\f048\"}.fa-step-forward:before{content:\"\\f051\"}.fa-stethoscope:before{content:\"\\f0f1\"}.fa-sticker-mule:before{content:\"\\f3f7\"}.fa-sticky-note:before{content:\"\\f249\"}.fa-stop:before{content:\"\\f04d\"}.fa-stop-circle:before{content:\"\\f28d\"}.fa-stopwatch:before{content:\"\\f2f2\"}.fa-store:before{content:\"\\f54e\"}.fa-store-alt:before{content:\"\\f54f\"}.fa-strava:before{content:\"\\f428\"}.fa-stream:before{content:\"\\f550\"}.fa-street-view:before{content:\"\\f21d\"}.fa-strikethrough:before{content:\"\\f0cc\"}.fa-stripe:before{content:\"\\f429\"}.fa-stripe-s:before{content:\"\\f42a\"}.fa-stroopwafel:before{content:\"\\f551\"}.fa-studiovinari:before{content:\"\\f3f8\"}.fa-stumbleupon:before{content:\"\\f1a4\"}.fa-stumbleupon-circle:before{content:\"\\f1a3\"}.fa-subscript:before{content:\"\\f12c\"}.fa-subway:before{content:\"\\f239\"}.fa-suitcase:before{content:\"\\f0f2\"}.fa-suitcase-rolling:before{content:\"\\f5c1\"}.fa-sun:before{content:\"\\f185\"}.fa-superpowers:before{content:\"\\f2dd\"}.fa-superscript:before{content:\"\\f12b\"}.fa-supple:before{content:\"\\f3f9\"}.fa-surprise:before{content:\"\\f5c2\"}.fa-suse:before{content:\"\\f7d6\"}.fa-swatchbook:before{content:\"\\f5c3\"}.fa-swift:before{content:\"\\f8e1\"}.fa-swimmer:before{content:\"\\f5c4\"}.fa-swimming-pool:before{content:\"\\f5c5\"}.fa-symfony:before{content:\"\\f83d\"}.fa-synagogue:before{content:\"\\f69b\"}.fa-sync:before{content:\"\\f021\"}.fa-sync-alt:before{content:\"\\f2f1\"}.fa-syringe:before{content:\"\\f48e\"}.fa-table:before{content:\"\\f0ce\"}.fa-table-tennis:before{content:\"\\f45d\"}.fa-tablet:before{content:\"\\f10a\"}.fa-tablet-alt:before{content:\"\\f3fa\"}.fa-tablets:before{content:\"\\f490\"}.fa-tachometer-alt:before{content:\"\\f3fd\"}.fa-tag:before{content:\"\\f02b\"}.fa-tags:before{content:\"\\f02c\"}.fa-tape:before{content:\"\\f4db\"}.fa-tasks:before{content:\"\\f0ae\"}.fa-taxi:before{content:\"\\f1ba\"}.fa-teamspeak:before{content:\"\\f4f9\"}.fa-teeth:before{content:\"\\f62e\"}.fa-teeth-open:before{content:\"\\f62f\"}.fa-telegram:before{content:\"\\f2c6\"}.fa-telegram-plane:before{content:\"\\f3fe\"}.fa-temperature-high:before{content:\"\\f769\"}.fa-temperature-low:before{content:\"\\f76b\"}.fa-tencent-weibo:before{content:\"\\f1d5\"}.fa-tenge:before{content:\"\\f7d7\"}.fa-terminal:before{content:\"\\f120\"}.fa-text-height:before{content:\"\\f034\"}.fa-text-width:before{content:\"\\f035\"}.fa-th:before{content:\"\\f00a\"}.fa-th-large:before{content:\"\\f009\"}.fa-th-list:before{content:\"\\f00b\"}.fa-the-red-yeti:before{content:\"\\f69d\"}.fa-theater-masks:before{content:\"\\f630\"}.fa-themeco:before{content:\"\\f5c6\"}.fa-themeisle:before{content:\"\\f2b2\"}.fa-thermometer:before{content:\"\\f491\"}.fa-thermometer-empty:before{content:\"\\f2cb\"}.fa-thermometer-full:before{content:\"\\f2c7\"}.fa-thermometer-half:before{content:\"\\f2c9\"}.fa-thermometer-quarter:before{content:\"\\f2ca\"}.fa-thermometer-three-quarters:before{content:\"\\f2c8\"}.fa-think-peaks:before{content:\"\\f731\"}.fa-thumbs-down:before{content:\"\\f165\"}.fa-thumbs-up:before{content:\"\\f164\"}.fa-thumbtack:before{content:\"\\f08d\"}.fa-ticket-alt:before{content:\"\\f3ff\"}.fa-times:before{content:\"\\f00d\"}.fa-times-circle:before{content:\"\\f057\"}.fa-tint:before{content:\"\\f043\"}.fa-tint-slash:before{content:\"\\f5c7\"}.fa-tired:before{content:\"\\f5c8\"}.fa-toggle-off:before{content:\"\\f204\"}.fa-toggle-on:before{content:\"\\f205\"}.fa-toilet:before{content:\"\\f7d8\"}.fa-toilet-paper:before{content:\"\\f71e\"}.fa-toolbox:before{content:\"\\f552\"}.fa-tools:before{content:\"\\f7d9\"}.fa-tooth:before{content:\"\\f5c9\"}.fa-torah:before{content:\"\\f6a0\"}.fa-torii-gate:before{content:\"\\f6a1\"}.fa-tractor:before{content:\"\\f722\"}.fa-trade-federation:before{content:\"\\f513\"}.fa-trademark:before{content:\"\\f25c\"}.fa-traffic-light:before{content:\"\\f637\"}.fa-trailer:before{content:\"\\f941\"}.fa-train:before{content:\"\\f238\"}.fa-tram:before{content:\"\\f7da\"}.fa-transgender:before{content:\"\\f224\"}.fa-transgender-alt:before{content:\"\\f225\"}.fa-trash:before{content:\"\\f1f8\"}.fa-trash-alt:before{content:\"\\f2ed\"}.fa-trash-restore:before{content:\"\\f829\"}.fa-trash-restore-alt:before{content:\"\\f82a\"}.fa-tree:before{content:\"\\f1bb\"}.fa-trello:before{content:\"\\f181\"}.fa-tripadvisor:before{content:\"\\f262\"}.fa-trophy:before{content:\"\\f091\"}.fa-truck:before{content:\"\\f0d1\"}.fa-truck-loading:before{content:\"\\f4de\"}.fa-truck-monster:before{content:\"\\f63b\"}.fa-truck-moving:before{content:\"\\f4df\"}.fa-truck-pickup:before{content:\"\\f63c\"}.fa-tshirt:before{content:\"\\f553\"}.fa-tty:before{content:\"\\f1e4\"}.fa-tumblr:before{content:\"\\f173\"}.fa-tumblr-square:before{content:\"\\f174\"}.fa-tv:before{content:\"\\f26c\"}.fa-twitch:before{content:\"\\f1e8\"}.fa-twitter:before{content:\"\\f099\"}.fa-twitter-square:before{content:\"\\f081\"}.fa-typo3:before{content:\"\\f42b\"}.fa-uber:before{content:\"\\f402\"}.fa-ubuntu:before{content:\"\\f7df\"}.fa-uikit:before{content:\"\\f403\"}.fa-umbraco:before{content:\"\\f8e8\"}.fa-umbrella:before{content:\"\\f0e9\"}.fa-umbrella-beach:before{content:\"\\f5ca\"}.fa-underline:before{content:\"\\f0cd\"}.fa-undo:before{content:\"\\f0e2\"}.fa-undo-alt:before{content:\"\\f2ea\"}.fa-uniregistry:before{content:\"\\f404\"}.fa-unity:before{content:\"\\f949\"}.fa-universal-access:before{content:\"\\f29a\"}.fa-university:before{content:\"\\f19c\"}.fa-unlink:before{content:\"\\f127\"}.fa-unlock:before{content:\"\\f09c\"}.fa-unlock-alt:before{content:\"\\f13e\"}.fa-untappd:before{content:\"\\f405\"}.fa-upload:before{content:\"\\f093\"}.fa-ups:before{content:\"\\f7e0\"}.fa-usb:before{content:\"\\f287\"}.fa-user:before{content:\"\\f007\"}.fa-user-alt:before{content:\"\\f406\"}.fa-user-alt-slash:before{content:\"\\f4fa\"}.fa-user-astronaut:before{content:\"\\f4fb\"}.fa-user-check:before{content:\"\\f4fc\"}.fa-user-circle:before{content:\"\\f2bd\"}.fa-user-clock:before{content:\"\\f4fd\"}.fa-user-cog:before{content:\"\\f4fe\"}.fa-user-edit:before{content:\"\\f4ff\"}.fa-user-friends:before{content:\"\\f500\"}.fa-user-graduate:before{content:\"\\f501\"}.fa-user-injured:before{content:\"\\f728\"}.fa-user-lock:before{content:\"\\f502\"}.fa-user-md:before{content:\"\\f0f0\"}.fa-user-minus:before{content:\"\\f503\"}.fa-user-ninja:before{content:\"\\f504\"}.fa-user-nurse:before{content:\"\\f82f\"}.fa-user-plus:before{content:\"\\f234\"}.fa-user-secret:before{content:\"\\f21b\"}.fa-user-shield:before{content:\"\\f505\"}.fa-user-slash:before{content:\"\\f506\"}.fa-user-tag:before{content:\"\\f507\"}.fa-user-tie:before{content:\"\\f508\"}.fa-user-times:before{content:\"\\f235\"}.fa-users:before{content:\"\\f0c0\"}.fa-users-cog:before{content:\"\\f509\"}.fa-usps:before{content:\"\\f7e1\"}.fa-ussunnah:before{content:\"\\f407\"}.fa-utensil-spoon:before{content:\"\\f2e5\"}.fa-utensils:before{content:\"\\f2e7\"}.fa-vaadin:before{content:\"\\f408\"}.fa-vector-square:before{content:\"\\f5cb\"}.fa-venus:before{content:\"\\f221\"}.fa-venus-double:before{content:\"\\f226\"}.fa-venus-mars:before{content:\"\\f228\"}.fa-viacoin:before{content:\"\\f237\"}.fa-viadeo:before{content:\"\\f2a9\"}.fa-viadeo-square:before{content:\"\\f2aa\"}.fa-vial:before{content:\"\\f492\"}.fa-vials:before{content:\"\\f493\"}.fa-viber:before{content:\"\\f409\"}.fa-video:before{content:\"\\f03d\"}.fa-video-slash:before{content:\"\\f4e2\"}.fa-vihara:before{content:\"\\f6a7\"}.fa-vimeo:before{content:\"\\f40a\"}.fa-vimeo-square:before{content:\"\\f194\"}.fa-vimeo-v:before{content:\"\\f27d\"}.fa-vine:before{content:\"\\f1ca\"}.fa-vk:before{content:\"\\f189\"}.fa-vnv:before{content:\"\\f40b\"}.fa-voicemail:before{content:\"\\f897\"}.fa-volleyball-ball:before{content:\"\\f45f\"}.fa-volume-down:before{content:\"\\f027\"}.fa-volume-mute:before{content:\"\\f6a9\"}.fa-volume-off:before{content:\"\\f026\"}.fa-volume-up:before{content:\"\\f028\"}.fa-vote-yea:before{content:\"\\f772\"}.fa-vr-cardboard:before{content:\"\\f729\"}.fa-vuejs:before{content:\"\\f41f\"}.fa-walking:before{content:\"\\f554\"}.fa-wallet:before{content:\"\\f555\"}.fa-warehouse:before{content:\"\\f494\"}.fa-water:before{content:\"\\f773\"}.fa-wave-square:before{content:\"\\f83e\"}.fa-waze:before{content:\"\\f83f\"}.fa-weebly:before{content:\"\\f5cc\"}.fa-weibo:before{content:\"\\f18a\"}.fa-weight:before{content:\"\\f496\"}.fa-weight-hanging:before{content:\"\\f5cd\"}.fa-weixin:before{content:\"\\f1d7\"}.fa-whatsapp:before{content:\"\\f232\"}.fa-whatsapp-square:before{content:\"\\f40c\"}.fa-wheelchair:before{content:\"\\f193\"}.fa-whmcs:before{content:\"\\f40d\"}.fa-wifi:before{content:\"\\f1eb\"}.fa-wikipedia-w:before{content:\"\\f266\"}.fa-wind:before{content:\"\\f72e\"}.fa-window-close:before{content:\"\\f410\"}.fa-window-maximize:before{content:\"\\f2d0\"}.fa-window-minimize:before{content:\"\\f2d1\"}.fa-window-restore:before{content:\"\\f2d2\"}.fa-windows:before{content:\"\\f17a\"}.fa-wine-bottle:before{content:\"\\f72f\"}.fa-wine-glass:before{content:\"\\f4e3\"}.fa-wine-glass-alt:before{content:\"\\f5ce\"}.fa-wix:before{content:\"\\f5cf\"}.fa-wizards-of-the-coast:before{content:\"\\f730\"}.fa-wolf-pack-battalion:before{content:\"\\f514\"}.fa-won-sign:before{content:\"\\f159\"}.fa-wordpress:before{content:\"\\f19a\"}.fa-wordpress-simple:before{content:\"\\f411\"}.fa-wpbeginner:before{content:\"\\f297\"}.fa-wpexplorer:before{content:\"\\f2de\"}.fa-wpforms:before{content:\"\\f298\"}.fa-wpressr:before{content:\"\\f3e4\"}.fa-wrench:before{content:\"\\f0ad\"}.fa-x-ray:before{content:\"\\f497\"}.fa-xbox:before{content:\"\\f412\"}.fa-xing:before{content:\"\\f168\"}.fa-xing-square:before{content:\"\\f169\"}.fa-y-combinator:before{content:\"\\f23b\"}.fa-yahoo:before{content:\"\\f19e\"}.fa-yammer:before{content:\"\\f840\"}.fa-yandex:before{content:\"\\f413\"}.fa-yandex-international:before{content:\"\\f414\"}.fa-yarn:before{content:\"\\f7e3\"}.fa-yelp:before{content:\"\\f1e9\"}.fa-yen-sign:before{content:\"\\f157\"}.fa-yin-yang:before{content:\"\\f6ad\"}.fa-yoast:before{content:\"\\f2b1\"}.fa-youtube:before{content:\"\\f167\"}.fa-youtube-square:before{content:\"\\f431\"}.fa-zhihu:before{content:\"\\f63f\"}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}@font-face{font-family:\"Font Awesome 5 Brands\";font-style:normal;font-weight:normal;font-display:auto;src:url(../webfonts/fa-brands-400.eot);src:url(../webfonts/fa-brands-400.eot?#iefix) format(\"embedded-opentype\"),url(../webfonts/fa-brands-400.woff2) format(\"woff2\"),url(../webfonts/fa-brands-400.woff) format(\"woff\"),url(../webfonts/fa-brands-400.ttf) format(\"truetype\"),url(../webfonts/fa-brands-400.svg#fontawesome) format(\"svg\")}.fab{font-family:\"Font Awesome 5 Brands\"}@font-face{font-family:\"Font Awesome 5 Free\";font-style:normal;font-weight:400;font-display:auto;src:url(../webfonts/fa-regular-400.eot);src:url(../webfonts/fa-regular-400.eot?#iefix) format(\"embedded-opentype\"),url(../webfonts/fa-regular-400.woff2) format(\"woff2\"),url(../webfonts/fa-regular-400.woff) format(\"woff\"),url(../webfonts/fa-regular-400.ttf) format(\"truetype\"),url(../webfonts/fa-regular-400.svg#fontawesome) format(\"svg\")}.far{font-weight:400}@font-face{font-family:\"Font Awesome 5 Free\";font-style:normal;font-weight:900;font-display:auto;src:url(../webfonts/fa-solid-900.eot);src:url(../webfonts/fa-solid-900.eot?#iefix) format(\"embedded-opentype\"),url(../webfonts/fa-solid-900.woff2) format(\"woff2\"),url(../webfonts/fa-solid-900.woff) format(\"woff\"),url(../webfonts/fa-solid-900.ttf) format(\"truetype\"),url(../webfonts/fa-solid-900.svg#fontawesome) format(\"svg\")}.fa,.far,.fas{font-family:\"Font Awesome 5 Free\"}.fa,.fas{font-weight:900}"
var _Assetsd13d7a53abf40be3e0fd76e8a51bb4835b035bb0 = "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x10\x00\x00\x00\x10\b\x06\x00\x00\x00\x1f\xf3\xffa\x00\x00\x02\x17IDAT8\x8d\x85\xd3?h\x13a\x18\xc7\xf1\x97`\xba(d-\xd4E\x04c:$H\xcd\x16H\xa2c\xd1%\x8b\"V\xb1\x10\xa9D\xa4\xb4\x15Z\b\x884 mc;T\xdc\x04\x1dD\xa4\xa9P{W\x9aAb.\x91\x98\xbb\xfcAs-N\x82\x834\xd88\xd4,1\xe9}\x1d.1M\xda\xe8\xc1\x03\xc7\xfb\xbeÏ\x17\x9e\xdf+D\x8f\x8f\xa28CÆµNÆµ\x8e*\xec\xbd\xce\x1dnÔ\xad\xfe\xb1?\xfahz\xa9\xf6`l\x87}\xa9\b\x89\xe9\x1aj\u007f\x14M\xd8z7\",\xa8\xd6 \xcaHy~\xfc\v\x1e\xdfo<\xbe:K\x13e\f\xa9\x04\x1b\n(#eTk\x10\x84\xa5\xb39+\xbc\xa4\xfd\x056c \x95@\xfe\f\xca\x15\x90u\xb3n\x85\x9b\xeb:\xc4c\x90\xf6\x17\xc8\no\x1bH\a*H%XQ!\xa6\xc2\xe6U\f\xa5\x8f\xbd\xd5m\xb3\x06/\xb1wcÖ¼\x89\xac\x83\\\x82T\xe0g\x1bPFM\xe0N\x04\xec^\xb0{i\xd8\xfd8\xdc4\xcb`\xd9\xf9\x8c\xb9\xe07\xf6\xa5æ­\xa3]\x80\xac\x83T\xc2h\"\a\x81\xe5s/`\xf0\x02\xee\xf3\xbf\bß®\x98\xc8Q\x80!\xe9,N|\x85\xa9S\x1d@mm\vd\x1d\xb7\xa7\x81Ã\x89\xbc\xef\x02\fI'\x12\xdaeÈ³\a9Ac\xeatO\xc0á\v\x93\x9d@$\xb4\x8bÃ\t\xe4\x05FN\xf08\x1c1\x81\xbbQ8ë£ì£¡Yhh\x16\f\xedx\x1bx\xbd8Yi\xc9-\xe0 R[Û{\xf3\x90:f\xee\xa5.C\xf2f\x1b\xa8/\x9c\xacT\x87\x02T\xdflS}\x95\a\x97\a\xc6\x1f\u0086\x8a!g\xdb\xe3\xd3N\x98\xcd\xf2\xa7\xae1f\x85\x97\xe7\x03\x05\xe21X\xcd\xc1Ø¬\x19\x1c\xa9dÎ¼\xf5\xaf\\\x83\xf8\n|\xb8X \u007f H\u007f\xa3\x9c\xb3\x06\xdf>\t\x95\x87\x87\xbf\xf3\xf4\xfeN;}\xb2Þ\xf2\xf52\xb9#\xa2\xdc\x01i\xc2\xf6\xe3\xdd@\x94\xc4L\r\xb9\br\x11\x123\xff\u007fL\x87 U\xd8\xc98%2N\xe9_\xcf\xf9\x0fb\x85\x18@\x16\xc7I_\x00\x00\x00\x00IEND\xaeB`\x82"
var _Assets0d77b2008fc5e76d7d489317fc8f0df507d753c5 = "\x00\x00\x01\x00\x03\x00\x10\x10\x00\x00\x01\x00 \x00h\x04\x00\x006\x00\x00\x00  \x00\x00\x01\x00 \x00(\x11\x00\x00\x9e\x04\x00\x0000\x00\x00\x01\x00 \x00h&\x00\x00\xc6\x15\x00\x00(\x00\x00\x00\x10\x00\x00\x00 \x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xff'.\xc8\xfe\xb5.\xc8\xfe\xb5\x00\xca\xff'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x0f\x1b\xbd\xeb\x8dy\xbf\xfe\xf9Ð¶\xff\xffÐ¶\xff\xffy\xbf\xfe\xf9\x17\xca\xfe\x8d\x00\xcc\xff\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x02\x05\xcd\xfffl\x94\xb3\xe9\xe6KK\xff\xe8v\x97\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÃ·\xff\xff]\xc2\xfe\xe9\x05\xcd\xfff\x00\xff\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xff?\x1b\xa1\xfeÏ­\xba\xff\xffÍ®\xff\xff\x84i\xff\xffÔµ\xff\xffÔµ\xff\xffÔ¶\xff\xffÔµ\xff\xffÔµ\xff\xff[\xc3\xff\xff\xac\xba\xff\xffB\xc6\xfe\xcf\x00\xce\xff?\x00\x00\x00\x00\x00\x00\x00\x00\x1b\x8b\xfa\xedS3\xf4\xff×¯\xf4\xffÎ¨\xf4\xff</\xff\xff\x82q\xff\xffË·\xff\xffÊ¶\xfe\xffÔµ\xfe\xffÕ¶\xff\xff\f\xcc\xff\xffN\xc4\xff\xffÒ¶\xff\xffR\xc4\xfe\xee\x00\x00\x00\x00\x00\x00\x00\x00t\x8f\xa9\xed\xff5)\xff\xff5)\xff\xf2<3\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x85}\x8e\xffÖ²\xf9\xff\x8bo\xff\xff\x04\xc4\xff\xff\x00\xce\xff\xffN\xc4\xff\xff`\xc1\xfe\xee\x00\x00\x00\x00\x00\x00\x00\x00b\xc2\xfe\xed\xecl\x85\xff\xff5)\xff\xf2<3\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x85}\x8e\xff\xff5)\xff\x8dm\xf9\xff@(\xff\xff\x06\xc2\xfc\xff\x02\xcc\xfc\xff\x02\xcc\xfc\xff\n\xcb\xfd\xee\x00\x00\x00\x00\x00\x00\x00\x00b\xc2\xfe\xedÕµ\xfe\xff\xecl\x85\xff\xf2<3\xff\x00\xcd\xff\xff#u\xfc\xff\xff5)\xff\xff5)\xffÖ²\xf9\xffÕ¶\xff\xff\xfc<5\xff\xff5)\xff\xff5)\xffs\x8c\xa6\xee\x00\x00\x00\x00\x00\x00\x00\x00b\xc2\xfe\xedÕ¶\xff\xffÕµ\xfe\xff\xdfs\x8f\xff!u\xff\xffA'\xfc\xff\xff5)\xff\xff5)\xffÖ²\xf9\xffÕ¶\xff\xff\xfc<5\xff\xff5)\xff\xedg}\xffb\xc0\xfc\xee\x00\x00\x00\x00\x00\x00\x00\x00b\xc2\xfe\xedÕ¶\xff\xffÔµ\xff\xff\x85j\xfe\xff?'\xff\xffA'\xfc\xff\xff5)\xff\xff5)\xff\xa21\x94\xffB*\xff\xff\xf345\xff\xedg}\xffÕµ\xfd\xffb\xc1\xfe\xee\x00\x00\x00\x00\x00\x00\x00\x00b\xc2\xfe\xedÔµ\xff\xff\x85j\xff\xff?'\xff\xff?'\xff\xffA'\xfc\xff\xff5)\xff\xff5)\xff\xfe5)\xff\x9e.\x94\xff\xe2f\x8a\xffÕµ\xfd\xffÕ¶\xff\xffb\xc1\xfe\xee\x00\x00\x00\x00\x00\x00\x00\x00R\xc4\xfe\xedÔµ\xff\xffË¬\xff\xffË­\xff\xffY\xb9\xff\xff\x06\xc3\xfe\xff\u05ee\xf2\xff\u05ee\xf2\xffM*\xf2\xff\x84_\xf2\xffÔµ\xfe\xffÕ¶\xff\xffÔ¶\xff\xffR\xc4\xfe\xee\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xff?A\xc5\xfeÏ­\xb9\xff\xffÔµ\xff\xffÓ¶\xff\xffX\xc3\xff\xffÕ¶\xff\xffÕ¶\xff\xff}b\xff\xffÔµ\xff\xffÕ¶\xff\xff\xad\xba\xff\xffA\xc5\xfe\xcf\x00\xca\xff?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x02\x05\xca\xfff^\xc2\xfe\xe9\xd9q\x8b\xff\xfa@<\xff\xfb@<\xff\xe9s\x90\xffÔµ\xfe\xffÃ·\xff\xff^\xc2\xfe\xe9\x05\xca\xfff\x00\xff\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x0f\x17\xc8\xfb\x8d\x90x\x88\xf9\xe8i\x80\xffÐµ\xfd\xffx\xbf\xfe\xf9\x17\xca\xfe\x8d\x00\xcc\xff\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xff&.\xc7\xfe\xb4.\xc7\xfe\xb4\x00\xca\xff'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(\x00\x00\x00 \x00\x00\x00@\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xff'\x00\xcd\xfe\xb5\x00\xcd\xfe\xb5\x00\xca\xff'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x0f\x00\xcc\xff\x8e\x0e\xcc\xfe\xf9x\xbf\xff\xffx\xbf\xff\xff\x0e\xcc\xfe\xf9\x00\xcc\xff\x8e\x00\xbf\xff\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x02\x00\xcd\xfff\x02\xcd\xfe\xe9W\xc3\xff\xffÄ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÄ·\xff\xffW\xc3\xff\xff\x02\xcd\xfe\xe9\x00\xcd\xfff\x00\xff\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff?\x00\xcd\xfe\xcf?\xac\xd2\xff\xaf\xb8\xfd\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xaf\xba\xff\xff6\xc7\xff\xff\x00\xcd\xfe\xcf\x00\xce\xff?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcf\xff \x00\xcf\xff\xaa!\xb9\xe2\xfe\xadel\xff\xfe5)\xff\xeedx\xffÕ´\xfd\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\x90\xbd\xff\xff\x1c\xca\xfe\xfe\x00\xcd\xfe\xab\x00\xcf\xff \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xfe\v\x00\xcc\xfe\x84\n\xcc\xfd\xf6~\x92\xb2\xff\xeeMS\xff\xf7JM\xff\xf7JM\xff\xf7JM\xff\xe7y\x9c\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffË¶\xff\xffp\xc0\xff\xff\n\xcc\xfe\xf6\x00\xcc\xfe\x84\x00\xd0\xfe\v\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\x00\xcd\xfe\\\x01\xcd\xfe\xe4N\xc4\xff\xff\xbf\xb8\xff\xffÕ¶\xff\xffÅ§\xff\xff\x80d\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffQ\xc4\xff\xffÍ¶\xff\xff\xbf\xb8\xff\xffO\xc4\xff\xff\x01\xcd\xfe\xe4\x00\xcd\xfe\\\x00\x00\xff\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcb\xff6\x00\xcd\xfe\xc7\r\xa8\xff\xffKb\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÅ§\xff\xff?'\xff\xff\u007fd\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xff\x1a\xcb\xff\xff7\xc7\xff\xffÍ¶\xff\xffÕ¶\xff\xff\xa8\xba\xff\xff/\xc8\xff\xff\x00\xcd\xfe\xc7\x00\xcf\xff6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\xdc$j\xff\xff>'\xff\xffX?\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÅ§\xff\xff?'\xff\xff?'\xff\xff\x80d\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔ¶\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xff\x1a\xcb\xff\xff\x00\xce\xff\xff7\xc7\xff\xffÍ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff}\xbf\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\xdcF=\xed\xffQ(\xeb\xffh>\xea\xffÙ©\xe9\xffÙ©\xe9\xffÙ©\xe9\xffÈ\xeb\xff:7\xff\xff:7\xff\xff:7\xff\xff{t\xff\xff\xc1\xb8\xff\xff\xc1\xb8\xff\xff\xc1\xb8\xff\xff\xc1\xb7\xfe\xffÔµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\x19\xca\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff7\xc7\xff\xffÌ¶\xff\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\xdc\xdeHD\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x8cy\x89\xff×¯\xf4\xffÕ¶\xff\xffÕ¶\xff\xff\x8dq\xff\xff\b\xba\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff7\xc7\xff\xffÍ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\xdc\xd2j}\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x8cy\x89\xff\xff5)\xff×¯\xf4\xffÕ¶\xff\xff\x8cq\xff\xff?'\xff\xff\b\xba\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff7\xc7\xff\xff\xb1\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb7\xfd\xff\xeedw\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x8cy\x89\xff\xff5)\xff\xff5)\xff×¯\xf4\xff\x8cp\xff\xff?'\xff\xff?'\xff\xff\b\xba\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff&\xc9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ´\xfc\xff\xeedx\xff\xff5)\xff\xff5)\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x8by\x8a\xff\xff5)\xff\xff5)\xff\xff5)\xff\x92m\xf4\xffB*\xff\xffB*\xff\xffB*\xff\xff\r\xb7\xfb\xff\x05\xca\xfa\xff\x05\xca\xfa\xff\x05\xca\xfa\xff\x05\xca\xfa\xff\x05\xca\xfa\xff\x04\xcb\xfb\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ´\xfc\xff\xeedx\xff\xff5)\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xff\xff'r\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff×¯\xf4\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xfaDB\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xdeHD\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ´\xfc\xff\xeedw\xff\xff5)\xff\xe5D>\xff\x00\xce\xff\xff\x00\xcd\xff\xff#q\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff×¯\xf4\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xfaDB\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5cp\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ´\xfd\xff\xeedx\xff\xe5D>\xff\x00\xcd\xff\xff#q\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff×¯\xf4\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xfaDB\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf1[i\xff\xba\xb5\xf9\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ´\xfc\xff\xd5s\x8d\xff\"r\xff\xff?'\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff×¯\xf4\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xfaDB\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf1[i\xffÕ²\xf9\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xff\x82g\xfe\xff?'\xff\xff?'\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xa55\x95\xffF.\xff\xffF.\xff\xffF.\xff\xff\xe94B\xff\xff5)\xff\xff5)\xff\xf1[i\xffÕ²\xf9\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xff\x82g\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\x9e.\x95\xff?'\xff\xff?'\xff\xff\xe83C\xff\xff5)\xff\xf1[i\xffÕ²\xf9\xffÕ¶\xff\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xff\x82g\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe5)\xff\x9e.\x95\xff?'\xff\xff\xe83C\xff\xf1[i\xffÕ²\xf9\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÔµ\xff\xff\x82g\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffC'\xfa\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\x9e.\x96\xff\xdaZ\x83\xffÕ²\xf9\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfeÜ¹\xb9\xff\xffÕ¶\xff\xffÓ´\xff\xffÂ¤\xff\xffÃ¤\xff\xffÃ¤\xff\xffÂ¤\xff\xffK\xb1\xff\xff\b\xb9\xff\xff\b\xb9\xff\xff\r\xb8\xfe\xffÙ¦\xe5\xffÙ¦\xe5\xffÙ¦\xe5\xffÙ¦\xe5\xff[.\xe6\xffU)\xe6\xffU)\xe6\xff\x82S\xe6\xffÓ²\xfc\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xb9\xb9\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\xdc}\xbf\xff\xffÔ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÐ¶\xff\xffC\xc5\xff\xff\x00\xce\xff\xff\x06\xcd\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffF-\xff\xff?'\xff\xffkQ\xff\xffÑ²\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff}\xbf\xff\xff\x00\xcd\xfe\xdd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff5\x00\xce\xfe\xc6.\xc8\xff\xff\xa7\xba\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÐ¶\xff\xffC\xc5\xff\xff\x06\xcd\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffF-\xff\xffkQ\xff\xffÑ²\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xa7\xba\xff\xff.\xc8\xff\xff\x00\xce\xfe\xc6\x00\xcb\xff6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\x00\xcc\xff[\x01\xcd\xfe\xe3N\xc4\xff\xff\xbf\xb8\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÐ¶\xff\xffI\xc4\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffsX\xff\xffÑ²\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbf\xb8\xff\xffN\xc4\xff\xff\x01\xcd\xfe\xe3\x00\xcf\xff[\x00\x00\xff\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xfe\v\x00\xcc\xfe\x83\n\xcc\xfe\xf6o\xc1\xff\xffÎµ\xfe\xff\xebm\x88\xff\xf7LP\xff\xf7LP\xff\xf3LP\xff\xf7LP\xff\xf7LP\xff\xf7LP\xff\xe9s\x90\xffÒ³\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffo\xc0\xff\xff\n\xcc\xfe\xf6\x00\xcc\xfe\x83\x00\xd0\xfe\v\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc7\xff \x00\xcd\xff\xaa\x1b\xca\xfe\xfe\x91\xb8\xf6\xff\xf3V`\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf1[i\xffÕ²\xf9\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\x90\xbd\xff\xff\x1b\xca\xfe\xfe\x00\xcd\xff\xaa\x00\xc7\xff \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcd\xff>\x00\xcd\xfe\xcf7\xc2\xf7\xff\xcc[a\xff\xff5)\xff\xff5)\xff\xf1[i\xffÕ²\xf9\xffÕ¶\xff\xffÕ¶\xff\xff\xae\xba\xff\xff6\xc7\xff\xff\x00\xcd\xfe\xcf\x00\xcd\xff>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x02\x00\xcf\xffe\x03\xcb\xfb\xe9h\x8e\xa6\xff\xdeev\xffÕ²\xf9\xffÕ¶\xff\xffÄ·\xff\xffV\xc3\xff\xff\x02\xcd\xfe\xe9\x00\xcd\xfff\x00\xff\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x0f\x00\xcf\xfe\x8c\r\xcb\xfe\xf9w\xc0\xff\xffx\xbf\xff\xff\r\xcc\xfe\xf9\x00\xce\xfe\x8d\x00\xcc\xff\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xff&\x00\xcd\xfe\xb4\x00\xcd\xfe\xb4\x00\xd0\xff&\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(\x00\x00\x000\x00\x00\x00`\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x05\x00\xcd\xff4\x00\xcc\xff\xad\x00\xcd\xfe\xb5\x00\xcd\xff4\x00\xb6\xff\a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcd\xff)\x00\xcd\xfe\x86\x00\xcd\xfe\xe1$\xc8\xfe\xfe'\xc8\xfe\xfe\x00\xcd\xfe\xe1\x00\xce\xfe\x8a\x00\xd0\xff,\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd4\xff\x06\x00\xcd\xfev\x00\xce\xfe\xe1\x06\xcd\xfe\xfce\xc1\xff\xff\xbd\xb8\xff\xff\xc0\xb8\xff\xfff\xc1\xff\xff\t\xcd\xfe\xfc\x00\xce\xfe\xe5\x00\xcb\xfew\x00\xcc\xff\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc4\xfe\r\x00\xce\xff?\x00\xce\xff\xc2\v\xcc\xfe\xfe6\xc7\xff\xff\xa5\xba\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xa9\xb9\xff\xff9\xc6\xff\xff\v\xcc\xfe\xfe\x00\xcd\xfe\xc7\x00\xcc\xffB\x00\xc4\xfe\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff7\x00\xcd\xff\x9c\x00\xcd\xff\xf00\xc8\xff\xff\x84\xbe\xff\xffÉ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÌ¶\xff\xff\x84\xbe\xff\xff4\xc7\xff\xff\x00\xcd\xfe\xf3\x00\xcd\xff\x9c\x00\xcc\xff<\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd2\xfe\x17\x00\xcb\xfe\x96\x00\xce\xfe\xec\x19\xbd\xe8\xfd\x93\x83\x9b\xffÇ³\xf8\xffÓ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÓ¶\xff\xffÇ·\xff\xff\x86\xbd\xff\xff\x15\xca\xff\xfd\x00\xce\xfe\xed\x00\xce\xfe\x9e\x00\xc9\xff\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd4\xfe\x12\x00\xce\xffO\x00\xcd\xfd\xd8\x13\xc1\xee\xfeR\x9b\xb8\xff\xdaJG\xff\xfe5)\xff\xf2Yf\xffØª\xec\xffÕµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\xb6\xb9\xff\xffK\xc5\xff\xff\x11\xcb\xfe\xfe\x00\xcd\xfe\xd8\x00\xcd\xfeW\x00\xcc\xff\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x05\x00\xcd\xffM\x00\xcd\xfe\xae\x05\xca\xf9\xf9P\x9d\xbb\xff\xb0cj\xff\xfa7,\xff\xff5)\xff\xff5)\xff\xfe7,\xff\xeedx\xffØª\xeb\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÑ¶\xff\xff\x97\xbc\xff\xffB\xc6\xff\xff\x06\xcc\xff\xfa\x00\xcd\xfe\xb3\x00\xd0\xffM\x00\xda\xff\a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcf\xff \x00\xcd\xfe\xae\x00\xcd\xfe\xf2\x1d\xc7\xfa\xfe\xa4\x87\xa7\xff\xe5ar\xff\xecVh\xff\xf1Yh\xff\xf1Zh\xff\xf1Zh\xff\xf1Zh\xff\xf1\\k\xff\xe5\u007f\xa5\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÌ¶\xff\xffÊ·\xff\xff\x97\xbc\xff\xff\x1f\xc8\xfe\xfe\x00\xcd\xfe\xf2\x00\xce\xff\xb2\x00\xcc\xff#\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcb\xfe\x19\x00\xce\xffs\x00\xce\xfe\xec\x16\xcb\xff\xffb\xc1\xff\xffÇ·\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbb\x9d\xff\xffw\\\xff\xffË¬\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffO\xc4\xff\xff\xb2\xb9\xff\xffÓ¶\xff\xffË¶\xff\xffb\xc1\xff\xff\x18\xca\xff\xff\x00\xce\xff\xf1\x00\xce\xffs\x00\xc8\xfe\x1c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc6\xfe\x12\x00\xcb\xfe_\x00\xce\xfe\xbe\x04\xc0\xff\xfa-\xa2\xff\xff\xa1\xbb\xff\xffÑ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbb\x9d\xff\xffB*\xff\xff\x80d\xff\xffË¬\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xff.\xc8\xff\xff7\xc7\xff\xff\xb3\xb9\xff\xffÕ¶\xff\xffÒ¶\xff\xff\xa4\xba\xff\xffU\xc3\xff\xff\x10\xcc\xff\xfa\x00\xcd\xfe\xc3\x00\xcc\xffd\x00\xc6\xfe\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc9\xff0\x00\xce\xff\xc2\x00\xce\xfe\xf6\f\xab\xff\xff0L\xff\xfffS\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbb\x9d\xff\xff?'\xff\xffB*\xff\xffv\\\xff\xffÓ´\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xff-\xc8\xff\xff\x01\xcd\xff\xff!\xc9\xff\xff\xbc\xb8\xff\xffÕ¶\xff\xffÕ¶\xff\xffÏ¶\xff\xff\xa5\xbb\xff\xff1\xc7\xff\xff\x00\xce\xfe\xf7\x00\xcd\xfe\xc3\x00\xcc\xff8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2\x05\xbd\xff\xff\"o\xff\xff=(\xff\xff?'\xff\xffhN\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbb\x9d\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffw\\\xff\xffË¬\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÔ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff-\xc8\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff!\xc9\xff\xff\xb3\xb9\xff\xffÓ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÒ¶\xff\xff~\xbe\xff\xff\x14\xcb\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2\x16\x90\xff\xff;/\xff\xff?'\xff\xff?'\xff\xffhN\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xbb\x9d\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffB*\xff\xff\x80d\xff\xffË¬\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff-\xc8\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x01\xcd\xff\xff7\xc7\xff\xff\xb2\xb9\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÍ¶\xff\xffN\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2#\x90\xf1\xffZ1\xdd\xff_)\xdc\xff_)\xdc\xff\x82J\xdb\xffÜ\xd9\xffÜ\xd9\xffÜ\xd9\xffÜ\xd9\xffÜ\xd9\xff\xbf\x8f\xdf\xff6C\xff\xff6C\xff\xff6C\xff\xff6C\xff\xff9F\xff\xffnx\xff\xff\xb2\xb9\xff\xff\xb2\xb9\xff\xff\xb2\xb9\xff\xff\xb2\xb9\xff\xff\xb2\xb9\xff\xff\xb3\xb7\xfd\xffÔ³\xfc\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff+\xc6\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x01\xcd\xff\xff\"\xc9\xff\xff\xbb\xb8\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2_\x94\xaf\xff\xf2<3\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x0e\xc4\xf2\xff\x90w\x85\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¯\xff\xff\x8er\xff\xff\x0e\xab\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\"\xc9\xff\xff\xb2\xb9\xff\xffÓ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2]\x98\xb4\xff\xf2=5\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\n\xc7\xf6\xff\x8cy\x89\xff\xf5:1\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÐ±\xff\xff\x8dq\xff\xffF.\xff\xff\x0e\xab\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x01\xcd\xff\xff7\xc7\xff\xff\xb3\xb9\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2Q\xbd\xf2\xff\xe5br\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x93u\x84\xff\xf88.\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xff\x8dr\xff\xffD+\xff\xff?'\xff\xff\x0e\xab\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x01\xcd\xff\xff!\xc9\xff\xff\xb5\xb9\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffË³\xf9\xff\xef`r\xff\xfd8.\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x0e\xc4\xf2\xff\x91v\x85\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÎ¯\xff\xff\x8dq\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff\x0e\xab\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x1b\xca\xff\xff3\xc7\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xff\u05ed\xf1\xff\xeedw\xff\xfd8.\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\n\xc7\xf6\xff\x8cy\x89\xff\xf5:1\xff\xff5)\xff\xff5)\xff\xff5)\xffÔ¦\xec\xff\x8dq\xff\xffF.\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff\x0e\xab\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xff\xff\x01\xcd\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕµ\xfe\xff\u05ed\xf0\xff\xefas\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xfe\xff\x91v\x85\xff\xf88.\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\x97k\xec\xffI1\xff\xffD,\xff\xffD,\xff\xffD,\xff\xffD,\xff\xff\x16\xa7\xf8\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc7\xf7\xff\b\xc8\xf7\xff\x03\xcb\xfb\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ²\xf9\xff\xefas\xff\xfd8.\xff\xff5)\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xff\xff\x03\xc4\xff\xff+o\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf69/\xff_\x94\xaf\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\u05ed\xf0\xff\xeedw\xff\xfd8.\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\x02\xc7\xff\xff#r\xff\xffC.\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf6:0\xff^\x96\xb1\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕµ\xfe\xff\u05ed\xf1\xff\xefar\xff\xff5)\xff\xff5)\xff\xd5NK\xff\x00\xce\xff\xff\x00\xce\xff\xff\x00\xcd\xff\xff%l\xff\xff=+\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xeeQV\xffR\xb9\xec\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ²\xf9\xff\xefas\xff\xfd8.\xff\xd5NK\xff\x00\xcd\xff\xff\x03\xc4\xff\xff$n\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe6,\xff\xf4S[\xffÐ­\xf0\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\u05ed\xf1\xff\xeedw\xff\xd4QQ\xff\x02\xc7\xff\xff#r\xff\xff<-\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe6+\xff\xf1[i\xffÙ¥\xe3\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕµ\xfe\xff\u05ed\xf0\xff\xc6y\x96\xff$m\xff\xff=+\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xffØª\xec\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xf6OT\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf4PW\xffØ¨\xe8\xffÕµ\xfe\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÌ­\xff\xff\u007fd\xfe\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xaf9\x8f\xffT3\xf5\xffK2\xff\xffK2\xff\xffK2\xff\xffK2\xff\xff\xd94U\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe6,\xff\xf3S]\xff\u05ec\xef\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ°\xff\xff\x82g\xff\xffD,\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf84/\xff\x9e.\x96\xffG'\xf4\xff?'\xff\xff?'\xff\xff?'\xff\xff\xd62V\xff\xff5)\xff\xff5)\xff\xfe6+\xff\xf1[i\xffÙ¥\xe3\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xff~c\xff\xffB*\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf84/\xff\xa3/\x90\xff?'\xff\xff?'\xff\xff?'\xff\xff\xd62V\xff\xff5)\xff\xff5)\xff\xf5PW\xffØ¨\xe9\xffÕµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÌ­\xff\xff\u007fd\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe5)\xff\xa3/\x90\xffG'\xf4\xff?'\xff\xff\xd62V\xff\xfe6,\xff\xf4S\\\xff\u05ec\xf0\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ°\xff\xff\x82g\xff\xffD,\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf84/\xff\x9e.\x96\xffG'\xf5\xff\xd63X\xff\xf1[i\xffÙ¥\xe3\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xff~c\xff\xffB*\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xff?'\xff\xffE'\xf7\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf84/\xff\xa3/\x90\xff\xcdN\x85\xffØ¨\xe8\xffÕµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2O\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÏ°\xff\xff\xb7\x99\xff\xff\xb7\x99\xff\xff\xb7\x99\xff\xff\xb7\x99\xff\xff\xb7\x99\xff\xff\xb5\x99\xff\xffH\xa5\xff\xff\x10\xac\xff\xff\r\xac\xff\xff\r\xac\xff\xff\r\xac\xff\xff\x16\xab\xfd\xffÜ\xd5\xffÜ\xd5\xffÜ\xd5\xffÜ\xd5\xffÜ\xd5\xffÜ\xd5\xffm3\xd6\xffc*\xd7\xffc*\xd7\xffc*\xd7\xffe,\xd7\xff\x88L\xd7\xffÐ¬\xf8\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÎ¶\xff\xffO\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2N\xc5\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xc1\xb7\xff\xffC\xc5\xff\xff\x03\xcd\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\t\xcc\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffK2\xff\xff?'\xff\xff?'\xff\xff@(\xff\xffkQ\xff\xff\xc1\xa3\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÍ¶\xff\xffN\xc5\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xff\xc2\x0f\xcc\xff\xffp\xc0\xff\xffÑ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\xc1\xb7\xff\xff:\xc6\xff\xff\x00\xce\xff\xff\x00\xce\xff\xff\t\xcc\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffK2\xff\xff?'\xff\xff?'\xff\xff^E\xff\xffÅ§\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÒ¶\xff\xffw\xbf\xff\xff\x0f\xcc\xff\xff\x00\xcd\xff\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xff,\x00\xcd\xff\xb6\x00\xcd\xfe\xf2'\xc9\xff\xff\x9a\xbc\xff\xffÊ·\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÉ¶\xff\xff:\xc6\xff\xff\x03\xcd\xff\xff\t\xcc\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffK2\xff\xffA(\xff\xffbI\xff\xffÊ¬\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÌ¶\xff\xff\x9a\xbc\xff\xff-\xc8\xff\xff\x00\xcd\xfe\xf3\x00\xcd\xff\xb6\x00\xcd\xff3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd2\xff\x11\x00\xce\xff^\x00\xcd\xfe\xbe\x0f\xcc\xff\xfaP\xc4\xff\xff\xa1\xbb\xff\xffÑ¶\xff\xffÕ¶\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xff\xc1\xb7\xff\xffC\xc5\xff\xff\r\xcb\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffL3\xff\xffkQ\xff\xff\xc1\xa3\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÑ¶\xff\xff\xa4\xba\xff\xffT\xc3\xff\xff\x0f\xcc\xff\xfa\x00\xce\xff\xc2\x00\xce\xffc\x00\xd2\xff\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd2\xff\x11\x00\xcd\xfeh\x00\xcd\xfe\xea\x0f\xcc\xff\xffZ\xc3\xff\xffÅ·\xff\xffÔµ\xff\xffÔµ\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\xc0\xb7\xff\xffD\xc4\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffkQ\xff\xffÅ¦\xff\xffÔµ\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÉ¶\xff\xffZ\xc3\xff\xff\x11\xcb\xff\xff\x00\xce\xff\xf0\x00\xcd\xfeh\x00\xd6\xfe\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xfe\x1d\x00\xcd\xff\xa1\x00\xce\xfe\xeb\x1a\xca\xff\xfd\x89\xbd\xff\xffÅ·\xff\xffÔ´\xfc\xff\xe8v\x96\xff\xf1\\k\xff\xf2[i\xff\xf2[i\xff\xf2[i\xff\xe8[i\xff\xf2[i\xff\xf2[i\xff\xf2[i\xff\xf2[i\xff\xf1\\l\xff\xe7z\x9d\xffÍ®\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xffÅ·\xff\xff\x8d\xbd\xff\xff\x1d\xc9\xfe\xfe\x00\xce\xfe\xeb\x00\xcd\xfe\xa6\x00\xcd\xfe\x1f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcc\xff\x05\x00\xcd\xffM\x00\xcd\xfe\xae\x04\xcc\xfe\xf9B\xc6\xff\xff\x92\xbd\xff\xffÖ¤\xe2\xff\xf3V`\xff\xfe6*\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xfe6+\xff\xf1[i\xffÙ¥\xe3\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÑ¶\xff\xff\x96\xbc\xff\xffB\xc6\xff\xff\x06\xcc\xfe\xf9\x00\xce\xff\xb2\x00\xcd\xffM\x00\xda\xff\a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbf\xff\f\x00\xcc\xffB\x00\xcc\xfe\xd4\n\xcc\xfe\xfe:\xc6\xfe\xff\xb8\xa8\xe2\xff\xf5OU\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xff5)\xff\xf5PV\xffØ¨\xe9\xffÕµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÔ¶\xff\xff\xb3\xb9\xff\xff@\xc6\xff\xff\v\xcc\xfe\xfe\x00\xcd\xfe\xd4\x00\xce\xffJ\x00\xc4\xfe\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\xfe\x15\x00\xcd\xfe\x8a\x00\xcd\xfe\xe3\x13\xcb\xfe\xfcz\xb3\xe9\xff\xdeRU\xff\xfc6+\xff\xff5)\xff\xff5)\xff\xfe6,\xff\xf4S[\xff\u05ec\xf0\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÓ¶\xff\xff\xc0\xb8\xff\xff|\xbf\xff\xff\x13\xcb\xfe\xfc\x00\xce\xfe\xe5\x00\xce\xff\x92\x00\xce\xfe\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcf\xff6\x00\xcd\xfe\x9b\x00\xcd\xfe\xef4\xb8\xe3\xff\x9doz\xff\xf0=4\xff\xfe6+\xff\xf1[i\xffÙ¥\xe3\xffÕ¶\xff\xffÕ¶\xff\xffÕ¶\xff\xffÌ¶\xff\xff\x84\xbe\xff\xff3\xc7\xff\xff\x00\xcd\xfe\xf3\x00\xcd\xfe\x9b\x00\xcb\xff;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdf\xff\b\x00\xcc\xff2\x00\xcd\xfd\xbd\t\xc7\xf6\xfe4\xad\xd1\xff\xb9o\u007f\xffÙ¨\xe8\xffÕµ\xfe\xffÕ¶\xff\xffÕ¶\xff\xff\xa4\xba\xff\xff-\xc8\xff\xff\a\xcc\xfe\xfe\x00\xce\xfe\xc1\x00\xcd\xff4\x00\xdf\xff\b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd4\xff\x06\x00\xcd\xffm\x00\xcd\xfe\xd7\x05\xcd\xfe\xfb]\xc2\xff\xff\xb4\xb9\xff\xff\xb7\xb8\xff\xff^\xc2\xff\xff\b\xcd\xfe\xfb\x00\xcd\xfe\xda\x00\xcd\xffm\x00\xc6\xfe\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd2\xff(\x00\xcd\xfe\x85\x00\xce\xff\xe0#\xc8\xfe\xfe&\xc8\xfe\xfe\x00\xce\xff\xe0\x00\xcd\xfe\x8a\x00\xca\xff,\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x03\x00\xcc\xff(\x00\xcd\xfe\xa5\x00\xcc\xff\xad\x00\xcc\xff(\x00\xbf\xff\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
var _Assetsd02de8458478b9207bcc182c71f64095eebd83f2 = "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\xb4\x00\x00\x00\xb4\b\x06\x00\x00\x00=\xcd\x062\x00\x00\x1f\x04IDATx\x9c\xed\x9dytUÕ½\xc7\u007fa\x16\x87\xd6\xf2\x04\x15Q\xb4*\x860\xc3E\xe6\x04\x01\x15q|\xd5\xda\xd6>\xeb\xf0lk\x9fU[\x87\xb6j-R-3\"\x88\x88L\x82 \x0e\xa0L\xb9\x99\x80$\x90\x84\xe4\xde{\xf6M\x80kU\xaa\x12\xb0\xab\xf5i\xab>[\x81\f\xf7\xf3\xfe8\xf7\x82\x81$\xe7\xdc\xe4\x9c{N\x92\xf3]ë»kI\x92}\xf7\xf9\xe4\x97\xdf\xfe\xed\xdf\xdeGÄ\xadB\x93T4Y\x83\x92\xf5\x84\xa4\xbf\xd3\xe3\xf1\xe4\xa9I\" \xbd\xd0d>J*Q\x12\x8d\xf9cB\xb2\x982\xb9\xd0\xe9\xf1y\xf2dZ\x94Ë(\xf9\x18%4\xe0\xbf\x13\x96\x1b\x9c\x1e\xa7'O\x8d\n%\x93\xd1\xe4\xedF@>Ñ(\xb9\xde\xe9q{\xf2TG\x94H\xcf\x18\xc8_\xc5R\v\xb3@GQ\xf2/\x94d\x13\x96\xdeN\u007f\x0eOm\\\xec\x95^h\xf2+\x83\xf4Â¬\xff\x86&\x8fz\xf9\xb5'GD@~\x8c&!\x94\xd46\n\xaa\x96\x02%\xa3\xa1d\xbc\xfe\xdf\xc6`\x87)\x97\xbb\x9c\xfe|\x9eÚÈ\x0eh\x92\x8a\x12\xbf!\x98Z{\bv\x83\xfc'\xc1_\x01\xfe=\xb0\xfdO\x10\xfc\x0f\xfd\xff\x19}}X\xf2\xd1d\x00!\xe9\xe8\xf4\xe7\xf6\xd4\nE\xb9\\\x8a\x92\x17Q\xf2\x89!\x8c\xc13\xa0ð½\x1d\xfc\x91\xba\xce.\x80\x82_\xeb`\x1bG\xebO\xd1d\x05\x15\xd2\xcf\xe9\xcf\xef\xa9\x15\x89\xb0Ü\x92j\xe3\xa8,zj\xe1\xdf{2\xc8'y/\x14_\xad\u007f\x8d\xf1\xf7\xadA\x93\a\x9d\x9e\aO-X\x94\xc8)\x84\xe5F\x94\xe4\x19\x03\xd7\x11v\x0f\x83\xeds\xc0\x1f6\x01s\xdc\xe5\xb0}\x01\x94\\\x0eZ'3\x11\xbb\x90\xb0\xdcBH\xba:=?\x9eZ\x90\xd0\xe4b4É\x95\xe1\x1a\x85\xac6\xd4\tvL\x87\xac\xdd\t\x80|\x82\xb3J\xf5_\x86P\x173P\xff\v%\x85\x94K\x9a\xd3\xf3\xe4\xc9\xe5\",\xbd\xd1\xe4q\x94\xfc\xdb\b\xacO\v\xba\xf3Ê\xffa\xc8\xe8\xaf\xd8>\xb7\x92\x9a\xadM\x84\xf9Ä\xbd\xf3\x0es\xf9\xb5&\x87\t\xcbT\xc2\xd2\x1b$\xc5\xe9\xb9\xf3\xe4\"\x11\x92\xae\x84\xe4\xb7h\xf2.Jj\x1a\x03\xe9HYg6,\xbc\x83\x9b\xbf\x17\xa4\xff\x88\xa3\xa4\xfa`LF\x159\xb3+-\x00:\xa2WDr\xd7C\xd1-\xa0u6\xaa\x84\xd4\xc6\xc6\xfc$\xf9r\x9a\xd3\xf3\xe8\xc9a\x81\xb4\xa7T.AI\xb9QD\xac\t\xb5\xe3\x1f\x85\xdd\xf8\xf9]\x9bI\xf5Q\x8f\xa3\x94>\xff!\xb5\x99V@\x1ds\xdeR\b~\a\xb4vf\xca|\xef\x12\x92\xfe\xe4K\a\xa7\xe7Õ\x03B\x93\xa1(y!\x96\x936\nË¡\x9c\xde\xcc~|\x06\xbe\xb1\x9f7\x00\xb3\xee\xb1\xe3\xabÈcU\xa4\x8e;\x04\x05\x8fB\xe0\x023\xf9\xf5\xbf\t\xcbR\x94\x8ctz~=%I\xec\x97\xceh2;\x96'7\xdawQ\x15\xe8È\xb9\xf72d\xccW\xf4\xf5\xd56\ns<J\x0f\x1aYK\xd1s\x1fY\f\xf5^\xc8\n\xea\xf9\xb5q5$\x8a&_\xa3\xc9\">\x92.NÏ·'\x9bD\x99tC\x93[QRa\x04r4ÔÈ\xab\xb9\xfdG\x05& >\xd9\x03GÔ5ë µ\xe9GÜ¹k\xa1x\x02\x84\xba\x9aY8\xfe\x99r\xf91J\xcerz\xfe=Y(\x94\x8cD\xc964\xf9\xda\x10\x82\xc0\xf9\xec\u007f\xedyn\xb8\xee\xd3&\xc1\x1c\x8f\xd4c3\xaa\b\xbd\xf0\xa1\xf5@\xfb#\xe0\x0f\xc2\xf6\xe7\xa0\xecBs\xd5\x10%\x85\x84d\xbc\xd3\xcf\xc1S3\x85\x92\v\xd0d\xa1QDF\x13\b\x9eE\xb4\xf0g\x1cZ\xbb\x87\x1b\xa6\x1cn\x06\xccÇæ²}^%Õ\x94\xf4\xeas\x05\x14\xfe\x1c\x82=\xcc\xec8FQ\xb2\x94\xa0\\\x84xe\xbe\x16%J\xa5\aJ\xa6\x11\x96w\ra\x0eu\x86]?$\x9a\xbb\x01\xf5\xe2\a\\3\xf9\x88%0\xc7=*\xbd\x9a\xec\xd9\am\x02:\x02\xfe}\x90\xb3\x11v\xfe\xc4L\x1a\x12E\x93\x0fP2\x1d%\xe7:\xfd\x9c<\x19\x887\xa4\x13\x9a\x8cEÉ\xc6\u007f\x8a\xdbCÙ¥\x90\xb3\x81hf\x84O\xdfx\x97\xc9W[\x13\x99Ot__\x94\xddV\x97\xf4\xeas\xceF(\xed\vZ\a3e\xbeChr\x15\x11\xe9\xe4\xf4s\xf3T\x8fP2\x11%\x1b\f#\xb2\x12(M\x83\x1dOCV\x90hf\x04\xf5â¶\xc1\x1c\xf7\xc8q\xd5dÍ²3RÇ­\xc1\xf6\x99P:\xd0L\x99/\x8a\x92\xcd(\x99\xec\xf4\xf3\xf3\x14\x13{\xa5\aaY\x89&_\x18\xe7\xca\xed\xa1\xf0\x17\x90\xb5K\xffS\xed\x8fph\xed{\x96\xa7\x19\r-\x14}\xa3k(Z`uI\xaf>\uf0ec\x12(\xf8\x95\xd92ß(y\x8dR9\xcf\xe9\xe7\xd9fED\xceF\xc9\xed(\xd9o\x18\x89B\xa7B\xf1d\xc8\xd9p\xec\xa1G3#\xec\u007fy\xbfe\v\xc0DÒ\xdc9V\xf5~\x98p\xceF(\xbe\x16B\xa7\x9b\x89\xd8\a\xd0\xe4\x1eÊ¥\xa7\xd3Ï·M\x89\x90Ü\x92\x80\xa9\xf4b\xf7`\xc8[\x05~U\xe7A\xef[\xf6\x17n\xb86\xb90\xc7=:\xbd\x9a\x82g\x0f$\ah\u007f\x04\xfca\xc8[\x03\xbb\x87\x9bKCÂ¢(\x97[\x9d~Î­Z \xedP2\x10%\x1b\x8d\x17|\xed \xd0\x13\xf2\u007fË\xfd\xc9\xd1\xcc\b\a\u05fcÇ¤+\x93\x91f4\x1e\xa9\xf3\xe6TR\xbd%YPG\xc0_\x01\xf9\u007f\x80\xc0\xf9æ)\xc9F\x93\xa1 \xed\x9c~\xfe\xadJ\xe8\xf5\xe4yh\xc7n!j$\xbd\xe8\x02;\xef\x81\x1c\xffI\x0f4\x9a\xa9G\xe6)\x93\x9d\x89\xcc'Ú\xde\x0f\x13\xce\xce\xd1\xd7\x12\xc6i\x88~\xdbSX\x9eG\x93\x8b\x9d\xe6\xa0U\x88r\xb9\t%\x9f\x1aGe\x81\xddC \xab\xa8\xc1\a\xf9\xaf\xb7\xdf\xe1\xbak\xdc\x01s\xdciÃ£\x84^\xf8 \xf9P\xfb#\xfa\xc2q\xf7\bs\xc7\xc0\x94\xfc\x13Mns\x9a\x87\x16)\x90vhr\x13J\xb2\x8dAn\x0f\xbb}\xb1\xe3O\xa1z\x1f\\43Bx\xc9\a\\}\x95\xb3iFC\x1e6\xba\x06\xff\xccd\x94\xf4\xea\xb3Ò·\xd1w\x8f4\x9b\x86\xe4\xa3\xc9\xf7yC\xda;\xcdI\x8b\x10\xbb\xa57\x9a\xec@o\xeb4^\xf4\xed\xf8#d\x955\xfa\xd0\xfe\xb2j\xbfka\xd6\x1de\xe8\xe8\x1a\xe7\"\xb5?\x02Y\x01\xd81\vB\x1dÍ¤!\xffF\x93R\xca\xe4R\xa7yq\xa5\x10I\xa1TÎ£\\\xeeC\xc9\xdf\r!\x0e~\v\x8an\x80\xac\xc2F\x1fR43\xc2G\xab\xdf\xe7\xc6k\xbfv\x01\xb4&ÒX\xefG\xd2Jz\xf5\x82\xbd\v\x8a\xbe\a\xc13\x8d\xa3\xb5&\x9f\xa2\xe4×\xe4|\xef\x18XL\x88\xa4\xa0\xe4\xe7\xe8m\x9d\x06\xb7\x10\xb5\x83\xe2I\x90\xb7\x96\x13\xcbp\xf5\xf9\xcb\r\xef\xb0\xf0\xe1Ox\xe0\xf6/\xac\xf7\x1d\x1f\xdb\xf2}\xa7\xfd\xe23>Y\xbd\xc79\xa0\xfd\x11\xf0\x97C\xeekP<\xc5\xdci\x19%\xfb\xd0\xe4\xc16\r5\x11\xe9\x84&\x03PRd*O\x0e\x9e\xa5oé¹\xf3\"s\xdfq[\xfe\xb0\xf7B\xee:(\xba\xd6>\xa0\x1e\x98\r3\xd7\xc1V3\xf7{\xd8\xe9}z~\x1d\xecn\xae?D\x13\x85\x92am\xae?\x04%\x03\t\xcb\n\x94|f\x9c^t\x87\x82\x87 k\xa7\xb9\x87`+\xcc\x11\xc8]\xa3\xd7q\x8b'\xd9\a\xd2\xfd\xb3a\xc8\x14\x98\xb1\xd6a\xa0c\xce*\x81\x82\xdf\xe8\xb5}sÕ5\x84\xc5\xe74gI\x11!\xf95\x9a\xfc\x9f\xe1\x82O\x13(\xbaZ_\xac\x98\xba\x89\xe8\x04\xa0m\x81y3\x04\xce\xd2\xc7f7\xd0}Ò¡\xdfDX\xb0\xd1y\xa0\xfd\x11\xfd\x19d\x05\xa0\xe8F3\x97NFQ\xf2\x15\x9a<\xee4o\xb6\x88\x88\x9cFXn1\x97^t\x86\x92\x11\xb0m\x11\xf8\x13\xc8%\xed\x8e\xccy+\xf4\xcb\x17\xe3\xe3L\x06\xd0}\xd2!m\x02<\xbd\n2\x9dN?\xe2\xde\x03\xdb^\xd2oT5w1N\x00Mn\xa3T\xcep\x9aCK\x84\xbe]]\x80\x89\xcb[\bt\x83\xed\xf3\f\xcbp\x8d\x02m\xc7C\xcc\u0382\xc09u7 \x92\x05t\x9ft\x184\x19\x9e]\xef\x02\x98\xbfá¬~\x8dY\xe0,3P\u007f\x8d\x92\x124\x19\xe14\x8fM\x12\")\xb1ë´AI\x95aj\x11\xec\x0e;\xef\x04\u007fy\xd3&\xd7\xce\x05`\xde+\xfam\xa2'\x8e;\x99@\xc7=\xf3U\xd8\xe2t\x05\xa4\x1e\x17\xfe\x1c\x02g\x9b\xd9q\xacF\xc9\x1c4\xb9\x98\xa9-\xa4?\x84R9\x03M\x1eAI\x04\xc32\\'\xbd\x9e\x9c\xfb*\t\xa5\x17I\x819\x02y\xab\xa1\xec\xa2\xfa\xc7\xee\x04Ð¾\xeb\xe1O\xaf8\x0f\xf0I\xde\x03\xb9\xafÃ®\x9bÍ¤!Q\x94D\b\xcbc\x84\xe5\xdbN\xf3Ú È\x0e(\x19\x88&\u007f6Îc\xddpy/\x13o\xb4o2È¶\xc0\xbc\x0fr6Aè?\x83\x13@\xc7=\xefM\xfb~\x89\x9b\xebÜµP\xd6\xcb\xec6\xfa\x87\x94\xc9H\xd7\xdd\xf6DXF\xa1d9J\x8e\x1a\xe7\xc9\x17\xc6\xda:\xb5\xe6M\\æ¾¦\xff2\x189/V\x9ak\xecs8\t\xf4\xe0\xc90}\x8d\xf3\xf06\xe8\n\xc8\xff=\x94]b\x06\xea*\x94\xac&(\x19Ns,\x14\xc9\xe9(Y\x1cK\xfa\r\xcap\x9d`\xe7]\xfa\r@\xcd\x05\xd1\xce4#\xe7m}k\xdd(\x1ft\x12\xe8x\xf5c\xee\x1b.\x80\xb7!\xef\x03\u007f(Ö¦j\"\r\xd1\xef\x0fYMH\xbe\x95|\x90#\xf2\x9d\xd8e\xe0\xfb\x8cA\xee\x02%c\xf4\xdd5+&\xc9\xce4#o\xb5\xd9WE8\x0ft\x9ftH\x9b\b\xb3Ü°\xa3h\xe0\xdc7\xa1$\xc3\xdcmOJ\xdeG\x93[\t\xc9\u007f$\a\xe6\xa0LD\x93BS\xe9E\xe9e\xb1zr\xd0:\xe8l\x8bÌ\xf5\v\x11\xcd\xf5\x06\xbb\x03\xe8>\xe90\xec:\x98\xfb\xa6\xf3\xd0\x1aZ\xc1\xb6%\xfa\x89{\xa3\xb9\r\xcbQ\x94\x14\x13\x92)\xf6\x03\xad\xe4\x8b\xc6#\xb2@\xf0\x1c\xfdÄ±\x89\x06\"Ó¶\xb57c\xad~\x90\xd6\f\xc8n\x03:\xee\xe9k\xdcY\xd2;\xc9\x15\xfaK\x93\x02\xe7\x19\a\x0fM\xbev\x16\xe8\xd0)z=9'\xd3z\x90m\xdb\xce^\xa7On\"0\xbb\x11\xe8!S`\xbaKz?\xcc8;\v\n\u007f\x06\xc1\xd3\\\ntÙ¥\x90\xb3Õ\x0foc5#;[_\x00&\n\xb3\x1b\x81\xee\x93\x0e\x97e\xc0b;\x9e\x81\x8d\xce\xc9\xd2o{r\x15\xd0%\x19\xe0\x0fX\xffam\xdd4Yi\xee\xf6Î\x04t\x9ft\x18r\r<\xb3\xdayP\x13\xb2\xa6\xf7^\xbb\x06\xe8\xe2\xeb\xb1<\x8a\xdaZ\x9a\xdb\x1a{\xd5C\x13av3\xd0}\xd2a\xc0\x95\xfa\xe6\x8bã \xf5>\xd8u[+\x05:3b\xe3\xa6É¾Xo\xc6w\x9a\x0erK\x00:\xee\x19k\xdd_\xd2k\xfd@\xdb\x19\x997B\xd9w\x9b\x17\x99[\x12Ð¾\xeba\x9eËº\xf4\xda\f\xd0\xf1\xc8l\xe7\xb1)s\xfd\xbb\xad\a\xe8\xb8g\xba=R\xb76\xa0m/Í½jÜÑ\x81v\xd3q\xae6\x05\xb4\x1d\x93\x95\x9divËµ\xf5\x02\x1d\xf7\xc2M.\x80\xb7\xb5\x03\xbdu\xaf~\xc2y\xdaJ\xeb\xfd\xc7E0o\x18<w\xb6\xe5\xfe\xdfy?`\xf3\xf4C\xb6xë¶\x90\xd9\u007f\x9a\xe5\xce\xf3\xcd\xe0ã¹\xf6\xbfI\xa0M\x03\x9d\xb9\x0ff\xbd\xa6\x1f3\xba,\xc3\x06\xa7\xdb\xe2\x92\x01\x8f\x90\xe6\x8b\xda\xe4Z\xfa\xf9j,\xf7\xb2\xa1\xabxv\xf4fJ\x9f\xb7\xeb\xed\\\x1e\xd0Ç¡\xfe\xc32\x1dj;\xfe\xd4\xda\xe0\x92\xfe\x0f;~ÓY\x0f\xf6\x1d\xe1\xc5!\xab\xa9\xed\x93\xc1Ó\xde&\xd5\r74\xb5j\xa0\xfd\x11=\xf5\x98\xb7\x1e\x06_\xe38\xac\xad\r\xe8\xc5CV\xf3\xf5eW\x11=\x064\x8cÉ¨\"wv\xa5\v`n\xad@\xc7\xfd\xf4*\xe8\u007f\xa5\xe3\xc0\xb6\x06\xa0\xfb\r\xaba\xe9Ð\x8f\x8d\xf9\x9b@\xa7\xfa\xf4K\xd7\xcb\x16%\xe1\xed\\m\x1a\xe8-{\xf4\xf4\xc3åº%\x00\xbdx\xc8j\x8e\xf6\x99\xd8 Ð©>\xfd\xd2\xf5<'.]o3@\xfb#zN=\xe7u\x18t\xb5\xe3\xe0\xb6T\xa0\x97\x0f[EM\x9f+ê¹>\xa0S}Q\x06\x8f\xac\xa58)o\xe7j\xab@\xfb#zN=m%\f\xbc\xcaqx[\x12Ð\x87\x1d\xe6\x85\xc1\xab\xeb\x1ds\xfd@\xeb\x1e8\xa2\x96\xecY\a\x1dJ?\xda\x02\xd0\xfe\x88\x9e~\xccZ\xa7\x9frv\x01\xc4-\x01\xe8\xa5\xc3V\xf1\xaf\xcb\ua7efÆN\xf5E\x19;\xbe\x8a\xd0b'Jzm\x05h\u007fDO?\xa6\xad\x80\x01\xee\x8a\xd4n\x03z\x90\xef(K\x86\xaejtÌ\x03\xad;mx\x94\x1d\xf3*\xa9NjI\xaf-\x01\xed\x8f\xe8\xe9Ç^qU\x9d\xda]@GY4X/\xcd5\x17\xe8T\x9f\xfe\x1eÅ\xa4\x96\xf4\xda\x1a\xd0q\xcfZç\xa2;\x80\x8e\xd2\xcfW\xcdÒ¡/\x1351f\xb3@\xa7\xfa\xf4\x92^\xe9\xf3\xc9*\xe9\xb5U\xa0\xe3\x91\xda\x05%=7\x00\xdd\xcfWÍ!K\xeb\x94\xe6\xac\x02:\xd5\a#\xc7U\x93=;\x19o\xe7j\xab@\xfb#\xc7Kz\x0eW?\x9c\a:\xcaÒ¡/\x9b\x86\xb9)@\xa7\xfa\xa2\xf8\xc6\xd4P\xb2\xf0#\x0fh\xdb#\xf5\x13/\xc2@\xe7\xd2\x0f'\x81\x1e\xe4;Â¢\xc1\xabM\xa5\x19\xcd\x03\xfax\xfa\x917\xc7\xceÞ\xb6\x0et\x1c\xea\x85\x1b\x1dK?\x9c\x04zÉU\x86\v@+\x81N\xf5\xc1\xe8\x8cj\n\xe7\x1f\xf0\x80\xb6\xdd3\xd68R\xfdp\x02\xe8\xc1\xc3\x0e\xd7\xe9\xcdH&\xd0\xc7\"\xf5\xdcJ\xaa\xb7x@\xdb\xe7-{`\xea\xf2\xa4o\xbe8\x01\xf4\v\x83\x1b\xde4I\x06Ð©>\xbd\xf7#\xd7\xf2\xde\x0f\x0f\xe8\x93=k]R\x17\x8a\xc9\x06z\xf9\xb0\xa6Gf+\x81N\xf5\xe9\x9b/\xdab+_\xe3\xec\x01}\xb2\xb7\xee\xd5[O\x93T\xa7N\x16\xd0\xfd\x86Õ°x\xc8ÉFN\x02\x9d\xea\x83acj\xf0Ï²\xaa\xa4\xe7\x01]\xbf3\xf7\xc1\xfc\rI\x81:Y@'Z\x9aK\x16Ð©\xbe(CG\xd7\x10\xb2$R{@7\x1e\xa9\xff\xb0L\xbf\x0e\xab\x05\x03=\xd8w\x84\xc5CVY:fk\x81>\x9e~4\xff8\x97\a\xb41Ô³\xd6\xe9\xf7Q\xb4H\xa0\xa3\xbc\xd8\xc4\xd2\\\xb2\x81N\xf5\xe9Ç¹\xb6Ï«\xf4\x80\xb6\xd3\xd1\xcc\b\x9fO]A\xcd\xc0\x8c\x16\a\xf4\x937\xef'z\xdf\f\xb0Øµ\xf7\xcddÚµÊ¶_\xc2\xfcy\a\x9a\x18\xa9=\xa0\ra\xf6\xcf<\xc8S\xf7\xbf\xcd\xe1\xf9\x17\xc1\xd0\xd1-\n\xe8\x85\x0f}bË¼\xd4n\x8d\xf0Ô½\xff\xb0mÜ£Ó«ÉÛH\xed\x01Ý¨wÌ«d\xc0\x88Z~q\xf7\x16\x0e\xef\xee\nËºÃ 1\x1e\xd06\x03\xad\x1f\xe7j\xcaB\xd1\x03\xbaAo\x9b[I\xfa\x15U\xa4\xfaÐ.=\x05B\x02s{Z\n\xb5\at\xc3\x1e8\xa2\x16\xff\xccD\x8esy@\x9f\xe4hf\x04\xff\xac\x83\xf8\xc6\xd4\x1c\x9b\xd8c@+\x81P\n\xbc|\x16\f\xb1\x06j\x0f\xe8\xc6#\xf5\x88\xb1\xd5\xec^h\xf68\x97\a\xf4I0\xe7Í­d\xdc\xf8\xaa:\x13[\ah}\x82`\xd1\xd90\xa4\xf99\xb5\a\xb4\xb1\xd3|Q\xb6Ï­\xa4Ê°\xf7\xc3\x03\xba\x8e\xb7\xcc8t,\xcdh\x14h%\x10L\x81\x17z4\x1bj\x0fhs\x1e7\xbe\xca\xc4q.\x0f\xe8c\xde>\xaf\x92!\xa3j\xeb\x9d\xccz\x81\x8e{\xc1\xb9\xcdÊ©=\xa0Í»\xaf/J\xf1\x82\x8f\x1aÉ©=\xa0\x89fF(\x98_\xc9\x15\x13\x8e68\x91\x8d\x02\x1dL\xd1Ó&\x96\xf4<\xa0\x13\xf3\x88q\xd5\xe46x\x9c\xab\x8d\x03\x1dÍ\xb0y\xfa!\x06\x8c\xa8?2\x9b\x02:\x9eS\xaf=\x13\x06'\x0e\xb5\at\xa2\x8e2hd-E\xcf}\xe4\x01}\"\xcc\xf9\xcf\x1e`L\xc6\xc99s\xc2@Ç«\x1f\xb3\u0383\x81\x89\xa5\x1f\x1e\xd0M\U000e0475\xec8\xa9\xf7\xa3\x8d\x02\x1dÍ\x903\xbb\x92Q\xe9Õ¦&\xcf\x14\xd0\xf1\xf4ci\xf7\x84\x16\x8a\x1e\xd0M\x8f\xd4\xe3\xc6WQT\xe7.\xbd6\bt<2\x9b\x859!\xa0\xe3\xe9\xc7sç\xda\x03\xbay\xeeë;'~CS\x1b\x03:\x9a\x19a\xd3\xf4C\xa6Ò&\x03]\xa7\xa4g\x9c~x@7ß£Ò«cW\xf9\xb61\xa0\v\xe6W\x1a.\x00-\x01:\xee\x97z\x18\xe6\xd4\x1e\xd0\xd68\xcd\x17\xa5b\xc9_\xda\x0e\xd0\xdb\xe75^\x9a\xb3\x05\xe8P\n<Û³\xd1\xf4\xc3\x03\xda:\x8fJ\xafb\xf7\ua7f6n\xa0\xa3\x99\xfa\x0e`C\x9b&\xb6\x02\xadDohZ\xda\x1d\x06\x8d\xf5\x80\xb6\xddQV\xcf\xfee\xeb\x05:ÞQ\xdfvvÒ\x8e\xe7\xd4\vÎ©wG\xd1\x03\xda\x03Ú´\xfd3\x0f\x9e\xd4h\xe4\b\xd0q\xa8\x97u?iG\xd1\x03\xda\x03Ú\xb7Í­\xac\xd3\x02\xea8\xd0q?wn\x9d\x85\xa2\a\xb4\a\xb4a\x9a\xb1}^%ãf\xd8\x06t0E\x87z\xe8\x18\x0fh\x0fhc\x983g\x1a\xf7f8\nt\xdck\xbf\x03\x83\xc7x@{@7\f\xf36\v\x16\x80I\x03:\x98\x02s{R2\xfc!\x0fh\x0f\xe8\x93a\xf6\xcf<hYÎ\x14\xa0\x95@(\x85\xf7\x97\x8fd\xf8\xd8/\xed\x01\xfa'\xfb\xe0\x96\a,w\xf4\x96\ax\xe7\xc9;\xc8Y\xf6\x9f\xae\xf3\x81\xec\xef\xb6|\xa0\v\xe7\x1f`L\x86\xf9\xde\f\xd7\x00\xad\x84\xdaP\no/\xbc\x8b\x11\xe9\xd6G\xbc\x85\x0f}\x02O,\xb1\xfe\xcd_\x97\xa5Ã\xf3l\x99\x0f[\xdcR\x80\x8efFxë\x19kAi\xce)\xa0QBM\xb0\x03%\xaf\\Å¨\x8cÏ¬\azs\x05<\xb6\xd8\x03\xda\xed@\xc7s\xe6\xe6\xec\x00\xba\x05è¸³\x96\xfc\x88\xa1c\xbe\xb2\x16\xe8\xf8\x9c=\xb5\x02R\x9b\u007f\xf3\xa8\a\xb4M@\x17<{\x80\x8c&\xf6f\xb8\x15\xe8\xea`G6>\u007f\x17#-\x8a\xd4u\x80\u07ba\x17\x1e{\x01\xfaZ\x00\xb5\a\xb4u@G3#\xe4\xceiZ×ÛF\tQ-\x85]\xab\xa6p\xf9\xb8Ï­\x05:\x0e\xf5S+=\xa0\xdd\x02t43B\xd6,k\xb6\xb3\xdd\n4J\xa8\t\xb5g\xeb\xe2\xffjv\xf5\xa3\xc1\xb2\xddc\x8b\x9b\xf7\xe6/\x0fhk\x80Î}\x90\x91\xe3\xec\xabf\xb8\x05h\x94\xbeP\xcc_y\x13#\x9bQ\xfdh\x10\xe8Maxr\xa9\a\xb4S@G3\xf5\xd2\\\"Ç¦Z:\xd0(=\xfdØ¼\xe8'\fkb\xa46\xdcXyr)\xf4o\u0085\xeen\x05:p\x1e\x94\xa6\xba\x1b\xe8\xf8U\x03\xc9N3\xdc\x004JO?\xb2_\xba\x95\x11\xe9\x89\xe7Ô@o\xae\x80ß½\xd0:\x80.\xbb\x10r_s\xf7\x89\x95x\xce<t\x94=;\x80-\x01\xe8\xb8\vVÜ\xf0B\xd1\xd4\xd6w\xe6>}\xa1\x98H\xf5\xc3m@\aÎ\x9c\xb7q\xf5\x99\xc28\xccv\xf4f\xb4D\xa0kB\xed\xc9y\xe9\xfb\x8c\xca0\x9fS\x9b\xee\xe5ØºW_(\xf6\x9b\xd4\xf2\x80\x0e\xf4\x86\xbcU1n\\\nt<\xcdp:2\xbb\th\x94\x9eS\xef|\xf9:\x86\x8f\xfd\xc2Z\xa0\xe3\xe9\xc7\xd4e-\v\xe8@o\xc8\xd9\xfc\x8d\xbf\xea.\x05\xbap\xfe\x01Gsf\xb7\x02\x8d\xd2#\xf5\x9b\xf3\xefe\xf88c\xa8\x13\xee\xb6\xcbÜ§Gj\xa3\xde\x0f7\x00\x1d8\xfb\x1b\x919\xe2N\xa0\xa3E×\x95\xc0\x8dFm\x11h\x94P\x13lO\xe8\xb5\f\xc3Þ&\xb5\x8fn\xae\xd0\x1b\x9a\xdc\ftÙ\xc7s\xe6:\xe3w\x19Ð»_\xf9\x01#\xd3\xdd\x13\x99\xdd\nt\xdcyKofD\xfa?\xad\x05:\xee?,o\xf8\x1d\x8dN\x02\x1d\xe8\x05\xb9\xaf70n\x97\x01\xfd\xf6\xa2\xff\"\u0557\xbc-\xed\x96\x0etM\xb0\x03\x9b\x9eo\xb8\xf5\xb4Y@o*o\xb8\xa4\xe7\x14\xd0\xc1\xb3!ou=\x91\xd9\x03\xbaU\x00\x1dw\xc1\x8a\x1b\xf1Õ³\xf9bÉ\x95\xa7W\xbb\x03\xe8\xc09\xb14\xa3\xb1\xf1z@\xb7\n\xa0kC\xed\xc8Z\xf2Ã\xeaÔ\x1d\xc1zl1\xa4Mt\x0e\xe8\xb2\xf3\r\"\xb3\at\xab\x02Z\x87:\x85ÒµWq\xf97\xaa\x1f\x96\x01\xbde\x8f\xfe\xdes'\x80\x0e\xf4\x84\xec\\\x130{@\xb7*\xa0u\xa8\xdb\xf1Ö\xff>vH\xc0\xf2C\xb2\xf1\xe3\\\xc9\x02:\xd8\x1d\xb6-3\t\xb3\at\xab\x03:\x0eu\xfeÊ\x18\x9d\xf1\xa9\xf5@o\xae\x80'^L\x0e\xd0e\x17Åª\x19\x89\x9c1u\x19Ð\x17\xdd\xc6 \xdf\x11\x06\xf9\x8e&ì¾*\x06\x8c\xa8\xb5\xc5\xf7\xff\xf7\x16\x0e\x17\x9d\x06e\xed\xadw\xb0\x03h\x9d-\xf7\xf6e?b\xd5\x13\x89\xbeZ\xd8$4S\x97\xc3Ü\xec\x839\xd0\x13r\xd77mln\x02\xfa\xaf\v\x06\x92;`*\xb9\xfd\x9fJ\xd8\xd9\x13_\"s\xc6![\x1c|b=5w\x0e\x83;\xfa[\xeb\x9f\x0e\x83\xf5O\xc2\xf6\x05\x96\xbb&w\x11\x9f\xbdY\xa6\xef\xfeY\r\xf5\x96=\x90\xf7\x9f6\xc1\xdc\v\xf2^I02\xbb\x14h\xe6w\x87>\xe3\x9a\xd6t>\xe5\xa76D\xa3\x98g\xbdZw\x95o\x85\xfbNÐ«\a[\xf7\xda3\xe6\xcc}umu\x94\xae\x0f\x9c\xe6:\xd8\x03r66\x11f\x0fh\xe7\x80N\x9b\b\x0f\xce\xd5sR\xbb@\xfe\xe6C\xb6\x1cj\x1b\x80\x0e\x9e\x03y+\x9a\x01\xb3\a\xb43@\xf7\x9b\xa8\xe7\xa0I\x81\xd9.\xa8-\x06:\xd0\vr\xb2\x9b\t\xb3\at\xf2\x81N\x9b\x00\xbfyÞ4\xc3\x10X+\xa1\xb6\x10\xe8@\xafØ¦\x89\x8d\xbfh\x1e\xd06\x00\xddo\xa2\xde\x1b\xb1\xa9\xdc\x01\x98O\xf8wÍ\xda\"\xa0\x03\xe7C\xee:\xac\xbb\xe4\xde\x03:9@\xa7M\x80\x87\xe6\xdb3\xb6\xa6\x00\xdal\xa8-\x00:pn#]s\xad\x05\xe8%Ý \u007fb\xaf\x16v=\xd0\xfd'\xc1o\x179\x1b\x99\x1b\xfa\xba&C\xddL\xa0\x03\x17@\xdeJ\xac\u007fã\xe2\xeb\\\x04t0\x05^=\x03F\x0fo\x1d@\xa7M\x84i+\xed/\xcd5\xe7k\x9b\xf4\xf5\xcd\x00:\xd0\v\xb2\xcc\xf6f$\xe0\xecm\xb0{8h\x1d\\\x04t\xdcE\xed\xe1\xd1\xde0\xea\xf2\x96\vt\xda\x04\xb8\u007f\xb6\xcd\xd5\f\vr\xe1&A\xddD\xa0\x83\xdd o\xb9\xb5%\xc4\xec\xedP\xf00\x04\xcfh\xf8\xe7:\x0e\xb4\x12\xfd\xfd~\x9b\xbb\xc2}\x17CZ\xfd\xef\xf8s-\xd0\xfd'\xe9=\x0fv\xa6\x19\x99V\u007f?\vz&\f\x17\x80\x1b,\xf8%\x8c{\x0f\xe4?\x01e\x97\x82\x96\xd2\xf8\xcfN\x12\xd0×£DC\x93\x1a\xc3\xc9x\xfdt\xb8~`\xe3`\xbb\x05è´z\xcelu\x9aQ'*[\xfc\xe7:a\xa8\x13\x04:p\xbe\x85\v\xc0r\xc8[\v\xbb\a\x9b\xf9\xd95(\xa9\xa0\\\xbeo;\xd0\"\"\xec\x95\x1e(\xb9\x1b%\xef\xa3$\xda\xe8\xe0\x8a\xdb\xc3Â³`\xd2P\xf7\x02\xddo\xa2\xbe\x9d\xed\xea4\xc3\n\xa8\x13\x00\xfa\x18\xcc\x16\x8c;g#\x14]\x0f\xa1\xd3\xcd\xfc\xec\x8f\b\xc9/PrnR`\xae\x03\xf6.9\x13%o\x98\x9a\xa0\xdd\xed\xe07\x17\xb8\x0f\xe8\xbeW\xc0\xef\x16\xd97\x06+\xd3\fS\xbf8\x16\x00\x1d\xec\x16K3,\x18W\xc1#\x10\xeaj\xf6\xafB&e\xd2-\xe9 \x9f\x04vP&\xa1d=J\xaa\r\a\xbd\xe1T\xb8\xa7\xcf\xf14\xc4I\xa0\xfbM\x82_\xcfk\x199\xb3\xe9\x9fg\xb0\xebh\x04t\xa0\x97\xbe\x00lVd\xde\x03;fBi?c\x88\xf5\xd4u\x13a\xb9\xc6i\x8eët%,\x19(\xd9o\xf8!\xcaR`\xfd\xa9p\xcd`\xe7\x80N\x8bu\xcdm\xd9\xe3\x10\\6B\x9d\xe8\xe9\xeac0_\xa0\x97\xe6\x9a3\xee\xdc7t\x90\xb5Nf`>\x88\x92É\xa4\xab\xd3\xfc6(Ê¤\x1bay\x1aM>@I\xada\x1a\xb2\xd2\x17;\x15lCÍ·!\xa0\xd3&\xc0#\xcf\xc1f\x17m\x9a$e\f\x8d\x00\x1d8\xb7\x19\x9b&{\xf5\xab\xbdv\xfe\xc4Lz\x11EÉh2\x8bb\xe9\xee4\xaf\xa6\x04\x92\x82&\x03\xd0d\x91a5D\x8b\xfd\x99+\xb8\x1f\xfc\x16\x03V\x1f\xd0\xfd&\xc1\xe3-\xa44\xd7\xecq\x9c\bg\x03@7w\x01X\xf00\x94\xf5Öe\xe30× d9\x9a\f\xe0\ri\xef4\xa7M\x12\x9a\x8c@I\x18%G\r\xff\x04\x05z\xc0\xb6%\xe0\xd7\xec\x01\xba\xef\x15\xf0Ð³6w\xcd9\x1c\x9d\xeb\x1dS#@\az\xc5\x1a\x8d\x12\xfd\xfe\n\xb6\xad\xd0#\xbb\xf1b\xef(J\"\x84d\xbc\xd3<Z\"\xf6È(\xb9\x1bM\x94\xe1\x87\x0f\x9d\x02\xc5\x13bM\xe3\xcd\x04\xef\x9b@\xf7\x9b\x04\x0f?\a\x1b\xc3I\x00\xc7->1R\x9f\x00\xf4\xb1\x16\xd0DÆ¾W\xff\x9a\xe2+\xcdU/Â²\x17%\xf7\xba\xa2za\x87P2\xcd0\xb7V\xa2\xef\"\x15\xddd\r\xd0i\x13\xf4\xcb\xc1\xed\x02\xc7\ri\x86\xa9_\xb8o\x00\x1d<'Ö\x9f\xe0\xf7\xda\xf5C\xd0Ú\x89\xcaQ\xc22\xdbiÞ\"4\x19\x81&\x1b0\xdaFW\xa2\xbf\u007f#\xffI\xc8*i\x1aÐ\xae\x86_Íµ>gv\xaa\x92\xd1Ü±\xee\xba-v\xd7\xdc\n\xf3c\xcf\n\xc0\x8e?\xeay\xb21\xc8_\xa2d3J\xd2\x11Iq\x9a\xb5\xa4)V\xe6\x1bm*\r\xd1:é¹m\x01\t\xfdy\x9c\xf7\xa6~\x19xk*\xcd5k\xbc{!\xff\xb7\t\x1chÝ§\xafi\xca.2W\x86S\xf2\x0e\xe52\x9e\x1c9\xd5i\xbe\x1c\x13oH{4y\x14%\u007f!\xdcx*\x12\xd5Ú³\xff\xad[x\xe6\x81\xdd\xdc\xf3\x83\u007fr\xc7-_5\xea;\xbf\xf7%w\xdc\xfc\u007f\x86\xff.Q?p\xfb\x17\xbc\xb7b\xbf\xbbÓ\x86\x00\xf5\xef5\x01s\x85^\x86\xdbus\xfdm\x9d'\xfb#B\xf2\xfb\x16[\xb9\xb0Z )\x84\xe5\x12\x94<\x81&\x9f\x19M\xe0';\xcef\xf5\xec\xfb\xb8|\\\xd3\xdf\x05\xd8T\x8f\x1cWMæD[\x1c\xcc&\x9dU\xaa×\x83=Ì\xfcO\x94<EH.c\xaa\xb4s\x9a#W*\x06v9J\xaa0j|R\xc2/\xefYÏ\x11G\x92\x00s\x94\xfe\x97GY\xf3\xe4_[)\xcc\xe5\xb0m1\x84:\x1b/\xf6\xf4g\xf3\x1e\x15\xd2\xcfi^Z\x84@:\xa0\xe4vÂ²\xcb\b\xe8\xaa@Gv\xac\x9c\xc2\xcf\xee\xdc\xca\xc0\x91\x87m\x03zLF\x15\x1b\x9f9\xd4\na\x0eÃ¶\xa5z\xa9T\xebh\xa6\fW\x8a\x92\xbb\tIG\xa79iq\"_\xba\xa0\xc9\x1dh\xf2\xb9\xd1D\x1f-\xebÄ\x95S\x18f\xf2MS\x89z\xeb\x8cCÔ¶:\x98\x03P2\x11B\xa6\xfa.\xbeDÉ½\x94\xc8)Ns\xd1\xe2E\x99\\JXV\xa0\xc9ßÒ\xaf\x8aOg\xce\xe33\x18\u007f\xe5AKÒQ\xe9\xd5l\xfa\xd3!\x17\xc0g\xa1\xb3w@\xc1\xa3\x10\xfc\xb6\x99\xf4\xe2\x13\x94\xac\xa5\\Ò\xe6\xa0U\x89|\xe9@\xb9\x8c!,9\xc6iH\a\xde\xdbÒ\xc7\x1fXF\xff\x11G\x9b\f\xf4\xb015\xbc1\xed\xe3V\x94fT\xc0\x8e\x19P\x96j\xb6zQHHÆtp\xfa\xf9\xb7j\xa1\xc9mh\xf2\xaeQ\xb4\x8ejBÑ\x89\\\u007fCE\xc2`\x0f\x1fS\xc3[O\xb7\x16\x98+ g\x13\x94\xa4\x9b\x818\x8a\xde\x02|\xb7\xd3Ï¹M\t%\x17\xa0É(\xa94zH_\xec:\x93×\xfd)\x93\xa7\xfc\xd9\\i.\xbd\x9a\xad\xad\xa54\x97\xe3\u05f7\xab\x83g\x9a\x81\xf9\xafh\xf2(!\xf9\xae\xd3Ï·Í\x12\xe9IX\xdeF\xc9a\xa3\x88]\x1d\xec\xc0\xf4\xdf\xcee\xc8\xe8\xafH\xf5Eë¹\xffåµ¬\x9b\xda\xd2Ks\xfb\xc0\xaf\xe9-\x03\x9a\xa92\xdc\x114\xc9A\xc9\x05N?OO1\xa1\xc9U(\xd9h&\r)_?\x9cG\xfegu\f\xec\xe30gL\xa8bË\x96^\x9a\xd3`\xfb\x1c(5u\xba:JX2\xd1\xe4:\xa7\x9f\x9f\xa7zDDN#,7\xa0\xe4\x90\xd1\xc3<\\z\n\x81\xd7\xc61\xe5\xbaÈ±È¼e\xc6!j\xb6:\rd3\x9c\x93\t%# \xd4\xc5L\x19\xeeo(\xf9\x01\xa5r\x86\xd3\xcfÍ\x81(\x97\x9eh\xb2\x10M*\x8d\"\xf6\xbfKNe\xf1\x1f\x1fc\xdd\xd3\xc5-72\xe7dC\xe1}\x10<\xcdLz\xf11\x9a\xbc\xe8\xa5\x17-P\x94K\x1aaYi&\r\x89\x06z\xe9G\x89\xfc\xcay@M\xbbB\xbf& \xd0\xdb\xcc\xf1\xa7(JÖ¡d \xb4\xa1\xb6\xce\xd6(\x94L@I\x19f\x8e\x81\x95]\x1c;\x06\x16r\x01\xb0\rY\xe9W\r\x94^f&O\xaeB\x89FH\xa68\xfd\x1c<Y(\xf6J\x0f4\xf9\x99\x99\xfa5\xa1S\xa1\xe8Z\x1b\xeeA\xb6\xc0\xb9\xeb\xf5\x93<fn!\xd2\xe4\x034\xb9\x0f'n!\xf2\x94\x1c\x11\x92\xae\x84d\x99\x89È¦7\xeb\xec\xbc\xcby\x88\xe3.\xbc\x0f4\x13\v>Ý¯\x92/\xa79=ß\x92$4\x19\x8b&k\xd0\xe4\xb0q\x1a\xd2\x1b\xf2\u007f\x0f\xfe\xa03\xe9ÅiPv\x89\x19\x88\x8f\xa0\xc9\xebhr\x85\xd3\xf3\xeb\xc9\x01\x91/](\x93a(y\xc78Zw\xd0\xef\xaf\xc8[\x9e<\x98\xf3^\x89\xddw\xd1\xd1xÑ§\xc9\a\x94\xcb\x18\xaf\x1bÎP*g\x10\x92\xe9(9\x80Ñt\xad3\xec\xbc\rr\xb6\x80ß\xb3\x8a\xfe=z=y\xe7\x9d\xfa\x95\x0eF\x95\v\xbd49\x87\x90|\xcb\xe9y\xf4\xe4\"\x81\xa4\xa0\xa4/\x9a\xcc$,G\f\xa2!\x04\u0381\xc2{\xb0\xb6Ì·GÏ\x03=Í\xe1\xaa\xd0\xe4Y\x94\xf4\x05\xef\xf8\x93\xa7F\x14\xab_\x97\xa1L\xe4×¡Sa\xfbB\x9aW\xe6\xd3`Û\x8d\xbf\x9e\xe1\x9by\xb2\x92r4\x19\xea\xf4<yjA\"\"\xa7\xa1\xe4v\x94\x14\x19\xe7×\xa1d\x1cl{\x81\xc4\xeeç«mË \xf8\n3\xe9\x05(\t\xa0\xe4no\xbb\xdaS\x93E\x89\x9c\x82&\x8f\x18\xe7\xd61\xb0\x8b\xae3\x0f\xf4\xae\x9b\xf5\xbe\vs\xbb|O\x12\x92\xaem\xea\xf2\x16O\xf6\tM\x06\xa0o\x1d\xff\xc30\x92\x06\xbaA\xfe\xef k\xe7\xc9\x10g\x15\xebm\x9d\x81s\xccD\xe4\xcfQ\xb2\x01%Ã\xfe\xfc\x9eZ\xa1È.\x94\xcbp\x94\x14\x18\xa7!\x1d\xa1\xec|\xfd&{\xff\x1e\xf0\xef\x85\xed\xf3\x8f\x97\xe1\f\xbf^J\t\xcbh>\x92.N\u007fnOm@(\xb9\x17%\u007f6NER\xa0x\"\x14M1~\x8d\x99\xee\xf7\tËN\u007f>OmP\x84\xe5\x124\x99\x8a~2\xda\f\xac\x8d\xf9S4y\x06MR\xbdn8O\x8e\x8a\x90\x9c\x8f&\x85\xe8\xdd|\x86\xb7=\x9d\xb0\xd8;\x8a\x92\x00\x9a\\\xec\xf4\xe7\xf0ä©\xd0\xe4V\x94\xe4%\x00t\x01\x9a\xfc\xd8\xe9q{\xf2Ô \xd8/\x9d\xd1\xe4\xfb(\xf9{\xa3é\xdb\xc9\xf7\x16|\x9eZ\x88\xa8\x90\vQ\xb2\x1auì¶§(J\xfe\x97\xb0\xbcN\xb9\\\xea\xf4\xf8<yJX )\x04e8ay\v%\x99\x84e\x94\xb7\xe0\xb3W\xff\x0fe\x94v,'\x16\xaf\x19\x00\x00\x00\x00IEND\xaeB`\x82"

// Assets returns go-assets FileSystem
var Assets = assets.NewFileSystem(map[string][]string{"/": []string{"gateway.go", "Makefile"}, "/public": []string{}, "/public/css": []string{"all.min.css", "style.css"}, "/public/html": []string{"error.gohtml", "miners.gohtml", "faults.gohtml", "index.gohtml", "asks.gohtml", "reputation.gohtml", "404.gohtml"}, "/public/img": []string{"favicon-16x16.png", "hex.svg", "favicon.ico", "android-chrome-192x192.png", "apple-touch-icon.png", "android-chrome-512x512.png", "site.webmanifest", "favicon-32x32.png"}}, map[string]*assets.File{
	"/public/img/site.webmanifest": &assets.File{
		Path:     "/public/img/site.webmanifest",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936054702978),
		Data:     []byte(_Assets8391991a0f9445efcc483e87a0508f7472f04dab),
	}, "/public/css/all.min.css": &assets.File{
		Path:     "/public/css/all.min.css",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936051573164),
		Data:     []byte(_Assets0f3873af67026ef9adff5293b531a01d11ae6c96),
	}, "/public/img/favicon-16x16.png": &assets.File{
		Path:     "/public/img/favicon-16x16.png",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936053904631),
		Data:     []byte(_Assetsd13d7a53abf40be3e0fd76e8a51bb4835b035bb0),
	}, "/public/img/favicon.ico": &assets.File{
		Path:     "/public/img/favicon.ico",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936054244377),
		Data:     []byte(_Assets0d77b2008fc5e76d7d489317fc8f0df507d753c5),
	}, "/public/img/apple-touch-icon.png": &assets.File{
		Path:     "/public/img/apple-touch-icon.png",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936053722691),
		Data:     []byte(_Assetsd02de8458478b9207bcc182c71f64095eebd83f2),
	}, "/public/html/error.gohtml": &assets.File{
		Path:     "/public/html/error.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936052382584),
		Data:     []byte(_Assets86cd0824fababa1fde259c0e52ec8ca0455e8965),
	}, "/public/html/miners.gohtml": &assets.File{
		Path:     "/public/html/miners.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936052658998),
		Data:     []byte(_Assets610f90f49cdc96fabb5ee57a1f077cfc00c6295e),
	}, "/public/html/asks.gohtml": &assets.File{
		Path:     "/public/html/asks.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936052195770),
		Data:     []byte(_Assets19d4daaf5fda2bea44d5a868092320a88976ec0f),
	}, "/public/html/reputation.gohtml": &assets.File{
		Path:     "/public/html/reputation.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936052791728),
		Data:     []byte(_Assetsff87a1af2b558b9c75d6a7149f7e7b3cc4566919),
	}, "/gateway.go": &assets.File{
		Path:     "/gateway.go",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1598021791, 1598021791125629342),
		Data:     []byte(_Assetsb289e24e7683deca2454781b8d3914d88103d97a),
	}, "/Makefile": &assets.File{
		Path:     "/Makefile",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936048375174),
		Data:     []byte(_Assets5e70439c4378bfd4d8fad0377484821d8d3176bb),
	}, "/public": &assets.File{
		Path:     "/public",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1591014936, 1591014936053015654),
		Data:     nil,
	}, "/public/css/style.css": &assets.File{
		Path:     "/public/css/style.css",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936051787332),
		Data:     []byte(_Assetsdde0973434b88ffc53b81b28400233e4fde8bb40),
	}, "/public/img/hex.svg": &assets.File{
		Path:     "/public/img/hex.svg",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936054529114),
		Data:     []byte(_Assets747353a94cf1b19b7a2e5c9fbc50b3ea0972f088),
	}, "/public/css": &assets.File{
		Path:     "/public/css",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1591014936, 1591014936051714575),
		Data:     nil,
	}, "/public/html/faults.gohtml": &assets.File{
		Path:     "/public/html/faults.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591360575, 1591360575185851657),
		Data:     []byte(_Assetsdd23384c8fb75cba24325da13db5e88f27edd970),
	}, "/public/img": &assets.File{
		Path:     "/public/img",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1591014936, 1591014936054642169),
		Data:     nil,
	}, "/public/img/android-chrome-512x512.png": &assets.File{
		Path:     "/public/img/android-chrome-512x512.png",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936053501192),
		Data:     []byte(_Assets5505a97055e70f2214132a49de39b49ea42721ef),
	}, "/public/img/android-chrome-192x192.png": &assets.File{
		Path:     "/public/img/android-chrome-192x192.png",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936053203474),
		Data:     []byte(_Assets8adebf81a81a55248a107972d373b02d60a4d498),
	}, "/public/img/favicon-32x32.png": &assets.File{
		Path:     "/public/img/favicon-32x32.png",
		FileMode: 0x1ed,
		Mtime:    time.Unix(1591014936, 1591014936054041540),
		Data:     []byte(_Assets73d5f881dc044ff1def628efb1b6c854a3374148),
	}, "/": &assets.File{
		Path:     "/",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1598021836, 1598021836257769183),
		Data:     nil,
	}, "/public/html": &assets.File{
		Path:     "/public/html",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1591360575, 1591360575185295483),
		Data:     nil,
	}, "/public/html/index.gohtml": &assets.File{
		Path:     "/public/html/index.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1598021175, 1598021175150364816),
		Data:     []byte(_Assets131cd67b6dd480f64ec4b1e6dc1172c43a81c7a9),
	}, "/public/html/404.gohtml": &assets.File{
		Path:     "/public/html/404.gohtml",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1591014936, 1591014936052044627),
		Data:     []byte(_Assets4bf0d0667fe4719e513a3edfeb3a25a2377cf2b7),
	}}, "")

'''
'''--- Filecoin/powergate/gateway/gateway.go ---
package gateway

import (
	"context"
	"fmt"
	"html/template"
	"io/ioutil"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-contrib/location"
	"github.com/gin-contrib/static"
	"github.com/gin-gonic/gin"
	logger "github.com/ipfs/go-log/v2"
	assets "github.com/jessevdk/go-assets"
	"github.com/rs/cors"
	gincors "github.com/rs/cors/wrapper/gin"
	askRunner "github.com/textileio/powergate/v2/index/ask/runner"
	faultsModule "github.com/textileio/powergate/v2/index/faults/module"
	minerModule "github.com/textileio/powergate/v2/index/miner/lotusidx"
	"github.com/textileio/powergate/v2/reputation"
)

const numTopMiners = 100

var log = logger.Logger("gateway")

// fileSystem extends the binary asset file system with Exists,
// enabling its use with the static middleware.
type fileSystem struct {
	*assets.FileSystem
}

// Exists returns whether or not the path exists in the binary assets.
func (f *fileSystem) Exists(prefix, path string) bool {
	pth := strings.TrimPrefix(path, prefix)
	if pth == "/" {
		return false
	}
	_, ok := f.Files[pth]
	return ok
}

// Gateway provides HTTP-based access to Textile.
type Gateway struct {
	addr             string
	server           *http.Server
	askIndex         *askRunner.Runner
	minerIndex       *minerModule.Index
	faultsIndex      *faultsModule.Index
	reputationModule *reputation.Module
}

// NewGateway returns a new gateway.
func NewGateway(
	addr string,
	askIndex *askRunner.Runner,
	minerIndex *minerModule.Index,
	faultsIndex *faultsModule.Index,
	reputationModule *reputation.Module,
) *Gateway {
	return &Gateway{
		addr:             addr,
		askIndex:         askIndex,
		minerIndex:       minerIndex,
		faultsIndex:      faultsIndex,
		reputationModule: reputationModule,
	}
}

// Start the gateway.
func (g *Gateway) Start(basePath string) {
	gin.SetMode(gin.ReleaseMode)
	router := gin.Default()
	router.Use(location.Default())

	// @todo: Config based headers
	options := cors.Options{}
	router.Use(gincors.New(options))

	temp, err := loadTemplate()
	if err != nil {
		log.Fatal(err)
	}
	router.SetHTMLTemplate(temp)

	if basePath == "/" {
		basePath = ""
	}
	router.Use(static.Serve(basePath, &fileSystem{Assets}))
	rg := router.Group(basePath)
	rg.GET("/asks", g.asksHandler)
	rg.GET("/miners", g.minersHandler)
	rg.GET("/faults", g.faultsHandler)
	rg.GET("/reputation", g.reputationHandler)

	rg.GET("/", func(c *gin.Context) {
		c.Request.URL.Path = basePath + "/asks"
		router.HandleContext(c)
	})

	router.NoRoute(func(c *gin.Context) {
		g.render404(c)
	})

	g.server = &http.Server{
		Addr:    g.addr,
		Handler: router,
	}

	errc := make(chan error)
	go func() {
		errc <- g.server.ListenAndServe()
		close(errc)
	}()
	go func() {
		for err := range errc {
			if err != nil {
				if err != http.ErrServerClosed {
					log.Errorf("gateway error: %s", err)
				}
				return
			}
		}
		log.Info("gateway was shutdown")
	}()
	log.Infof("gateway listening at %s", g.server.Addr)
}

// Addr returns the gateway's address.
func (g *Gateway) Addr() string {
	return g.server.Addr
}

// Stop the gateway.
func (g *Gateway) Stop() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	if err := g.server.Shutdown(ctx); err != nil {
		log.Errorf("error shutting down gateway: %s", err)
		return err
	}
	return nil
}

func (g *Gateway) asksHandler(c *gin.Context) {
	menuItems := makeMenuItems(0)

	index := g.askIndex.Get()

	subtitle := fmt.Sprintf("Last updated: %v, storage median price: %v", timeToString(index.LastUpdated), index.StorageMedianPrice)
	headers := []string{"Miner", "Price", "Verified Price", "Min Piece Size", "Max Piece Size", "Timestamp", "Expiry"}

	rows := make([][]interface{}, len(index.Storage))
	i := 0
	for _, ask := range index.Storage {
		rows[i] = []interface{}{
			ask.Miner,
			ask.Price,
			ask.VerifiedPrice,
			ask.MinPieceSize,
			ask.MaxPieceSize,
			ask.Timestamp,
			ask.Expiry,
		}
		i++
	}
	sort.Slice(rows, func(i, j int) bool {
		return rows[i][0].(string) <= rows[j][0].(string)
	})

	c.HTML(http.StatusOK, "/public/html/asks.gohtml", gin.H{
		"MenuItems": menuItems,
		"Title":     "Available Asks",
		"Subtitle":  subtitle,
		"Headers":   headers,
		"Rows":      rows,
	})
}

func (g *Gateway) minersHandler(c *gin.Context) {
	menuItems := makeMenuItems(1)

	index := g.minerIndex.Get()

	metaHeaders := []string{"Miner", "Location", "User Agent", "Updated"}
	metaRows := make([][]interface{}, len(index.Meta.Info))
	i := 0
	for id, meta := range index.Meta.Info {
		metaRows[i] = []interface{}{
			id,
			meta.Location.Country,
			meta.UserAgent,
			timeToString(meta.LastUpdated),
		}
		i++
	}

	chainSubtitle := fmt.Sprintf("Last updated %v", timeToString(epochToTime(index.OnChain.LastUpdated)))
	chainHeaders := []string{"Miner", "Power", "RelativePower", "SectorSize", "SectorsActive", "SectorsLive", "SectorsFaulty"}
	var chainRows [][]interface{}
	i = 0
	for id, onchainData := range index.OnChain.Miners {
		if onchainData.Power == 0 {
			continue
		}
		chainRows = append(chainRows, []interface{}{
			id,
			onchainData.Power,
			onchainData.RelativePower,
			onchainData.SectorSize,
			onchainData.SectorsActive,
			onchainData.SectorsLive,
			onchainData.SectorsFaulty,
		})
		i++
	}

	sort.Slice(chainRows, func(i, j int) bool {
		l := chainRows[i][0].(string)
		r := chainRows[j][0].(string)
		return index.OnChain.Miners[l].RelativePower >= index.OnChain.Miners[r].RelativePower
	})

	c.HTML(http.StatusOK, "/public/html/miners.gohtml", gin.H{
		"MenuItems": menuItems,
		"MetaData": gin.H{
			"Title":   "Miner Metadata",
			"Headers": metaHeaders,
			"Rows":    metaRows,
		},
		"ChainData": gin.H{
			"Title":    "Miner On-Chain Data",
			"Subtitle": chainSubtitle,
			"Headers":  chainHeaders,
			"Rows":     chainRows,
		},
	})
}

func (g *Gateway) faultsHandler(c *gin.Context) {
	menuItems := makeMenuItems(2)

	index := g.faultsIndex.Get()

	subtitle := fmt.Sprintf("Current tip set key: %v", index.TipSetKey)

	headers := []string{"Miner", "Faults Epochs"}

	rows := make([][]interface{}, len(index.Miners))
	i := 0
	for id, faults := range index.Miners {
		epochs := make([]string, len(faults.Epochs))
		for j, epoch := range faults.Epochs {
			epochs[j] = strconv.FormatInt(epoch, 10)
		}
		rows[i] = []interface{}{
			id,
			strings.Join(epochs, ", "),
		}
		i++
	}

	sort.Slice(rows, func(i, j int) bool {
		l := rows[i][0].(string)
		r := rows[j][0].(string)
		return len(index.Miners[l].Epochs) >= len(index.Miners[r].Epochs)
	})

	c.HTML(http.StatusOK, "/public/html/faults.gohtml", gin.H{
		"MenuItems": menuItems,
		"Title":     "Miner Faults",
		"Subtitle":  subtitle,
		"Headers":   headers,
		"Rows":      rows,
	})
}

func (g *Gateway) reputationHandler(c *gin.Context) {
	menuItems := makeMenuItems(3)

	topMiners, err := g.reputationModule.GetTopMiners(numTopMiners)
	if err != nil {
		g.renderError(c, http.StatusInternalServerError, err)
		return
	}

	headers := []string{"Miner", "Score"}

	rows := make([][]interface{}, len(topMiners))
	for i, minerScore := range topMiners {
		rows[i] = []interface{}{
			minerScore.Addr,
			minerScore.Score,
		}
	}

	c.HTML(http.StatusOK, "/public/html/reputation.gohtml", gin.H{
		"MenuItems": menuItems,
		"Title":     fmt.Sprintf("Top %v Miners", numTopMiners),
		"Headers":   headers,
		"Rows":      rows,
	})
}

func epochToTime(value int64) time.Time {
	genesisEpochTime := int64(1598295600)
	return time.Unix(genesisEpochTime+value*30, 0)
}

func timeToString(t time.Time) string {
	return t.Format("01/02/06 3:04 PM")
}

type menuItem struct {
	Name     string
	Path     string
	Selected bool
}

func makeMenuItems(selectedIndex int) []menuItem {
	menuItems := []menuItem{
		{
			Name:     "Asks",
			Path:     "asks",
			Selected: false,
		},
		{
			Name:     "Miners",
			Path:     "miners",
			Selected: false,
		},
		{
			Name:     "Faults",
			Path:     "faults",
			Selected: false,
		},
		{
			Name:     "Reputation",
			Path:     "reputation",
			Selected: false,
		},
	}
	menuItems[selectedIndex].Selected = true
	return menuItems
}

// render404 renders the 404 template.
func (g *Gateway) render404(c *gin.Context) {
	c.HTML(http.StatusNotFound, "/public/html/404.gohtml", nil)
}

// renderError renders the error template.
func (g *Gateway) renderError(c *gin.Context, code int, err error) {
	c.HTML(code, "/public/html/error.gohtml", gin.H{
		"Code":  code,
		"Error": formatError(err),
	})
}

// loadTemplate loads HTML templates.
func loadTemplate() (*template.Template, error) {
	t := template.New("")
	for name, file := range Assets.Files {
		if file.IsDir() || !strings.HasSuffix(name, ".gohtml") {
			continue
		}
		h, err := ioutil.ReadAll(file)
		if err != nil {
			return nil, err
		}
		t, err = t.New(name).Parse(string(h))
		if err != nil {
			return nil, err
		}
	}
	return t, nil
}

// formatError formats a go error for browser display.
func formatError(err error) string {
	words := strings.SplitN(err.Error(), " ", 2)
	words[0] = strings.Title(words[0])
	return strings.Join(words, " ") + "."
}

'''
'''--- Filecoin/powergate/gateway/public/css/all.min.css ---
/*!
 * Font Awesome Free 5.12.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
.fa,.fab,.fad,.fal,.far,.fas{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;line-height:1}.fa-lg{font-size:1.33333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:.08em solid #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s linear infinite;animation:fa-spin 2s linear infinite}.fa-pulse{-webkit-animation:fa-spin 1s steps(8) infinite;animation:fa-spin 1s steps(8) infinite}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";-webkit-transform:scaleX(-1);transform:scaleX(-1)}.fa-flip-vertical{-webkit-transform:scaleY(-1);transform:scaleY(-1)}.fa-flip-both,.fa-flip-horizontal.fa-flip-vertical,.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)"}.fa-flip-both,.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1);transform:scale(-1)}:root .fa-flip-both,:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;line-height:2em;position:relative;vertical-align:middle;width:2.5em}.fa-stack-1x,.fa-stack-2x{left:0;position:absolute;text-align:center;width:100%}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-500px:before{content:"\f26e"}.fa-accessible-icon:before{content:"\f368"}.fa-accusoft:before{content:"\f369"}.fa-acquisitions-incorporated:before{content:"\f6af"}.fa-ad:before{content:"\f641"}.fa-address-book:before{content:"\f2b9"}.fa-address-card:before{content:"\f2bb"}.fa-adjust:before{content:"\f042"}.fa-adn:before{content:"\f170"}.fa-adobe:before{content:"\f778"}.fa-adversal:before{content:"\f36a"}.fa-affiliatetheme:before{content:"\f36b"}.fa-air-freshener:before{content:"\f5d0"}.fa-airbnb:before{content:"\f834"}.fa-algolia:before{content:"\f36c"}.fa-align-center:before{content:"\f037"}.fa-align-justify:before{content:"\f039"}.fa-align-left:before{content:"\f036"}.fa-align-right:before{content:"\f038"}.fa-alipay:before{content:"\f642"}.fa-allergies:before{content:"\f461"}.fa-amazon:before{content:"\f270"}.fa-amazon-pay:before{content:"\f42c"}.fa-ambulance:before{content:"\f0f9"}.fa-american-sign-language-interpreting:before{content:"\f2a3"}.fa-amilia:before{content:"\f36d"}.fa-anchor:before{content:"\f13d"}.fa-android:before{content:"\f17b"}.fa-angellist:before{content:"\f209"}.fa-angle-double-down:before{content:"\f103"}.fa-angle-double-left:before{content:"\f100"}.fa-angle-double-right:before{content:"\f101"}.fa-angle-double-up:before{content:"\f102"}.fa-angle-down:before{content:"\f107"}.fa-angle-left:before{content:"\f104"}.fa-angle-right:before{content:"\f105"}.fa-angle-up:before{content:"\f106"}.fa-angry:before{content:"\f556"}.fa-angrycreative:before{content:"\f36e"}.fa-angular:before{content:"\f420"}.fa-ankh:before{content:"\f644"}.fa-app-store:before{content:"\f36f"}.fa-app-store-ios:before{content:"\f370"}.fa-apper:before{content:"\f371"}.fa-apple:before{content:"\f179"}.fa-apple-alt:before{content:"\f5d1"}.fa-apple-pay:before{content:"\f415"}.fa-archive:before{content:"\f187"}.fa-archway:before{content:"\f557"}.fa-arrow-alt-circle-down:before{content:"\f358"}.fa-arrow-alt-circle-left:before{content:"\f359"}.fa-arrow-alt-circle-right:before{content:"\f35a"}.fa-arrow-alt-circle-up:before{content:"\f35b"}.fa-arrow-circle-down:before{content:"\f0ab"}.fa-arrow-circle-left:before{content:"\f0a8"}.fa-arrow-circle-right:before{content:"\f0a9"}.fa-arrow-circle-up:before{content:"\f0aa"}.fa-arrow-down:before{content:"\f063"}.fa-arrow-left:before{content:"\f060"}.fa-arrow-right:before{content:"\f061"}.fa-arrow-up:before{content:"\f062"}.fa-arrows-alt:before{content:"\f0b2"}.fa-arrows-alt-h:before{content:"\f337"}.fa-arrows-alt-v:before{content:"\f338"}.fa-artstation:before{content:"\f77a"}.fa-assistive-listening-systems:before{content:"\f2a2"}.fa-asterisk:before{content:"\f069"}.fa-asymmetrik:before{content:"\f372"}.fa-at:before{content:"\f1fa"}.fa-atlas:before{content:"\f558"}.fa-atlassian:before{content:"\f77b"}.fa-atom:before{content:"\f5d2"}.fa-audible:before{content:"\f373"}.fa-audio-description:before{content:"\f29e"}.fa-autoprefixer:before{content:"\f41c"}.fa-avianex:before{content:"\f374"}.fa-aviato:before{content:"\f421"}.fa-award:before{content:"\f559"}.fa-aws:before{content:"\f375"}.fa-baby:before{content:"\f77c"}.fa-baby-carriage:before{content:"\f77d"}.fa-backspace:before{content:"\f55a"}.fa-backward:before{content:"\f04a"}.fa-bacon:before{content:"\f7e5"}.fa-bahai:before{content:"\f666"}.fa-balance-scale:before{content:"\f24e"}.fa-balance-scale-left:before{content:"\f515"}.fa-balance-scale-right:before{content:"\f516"}.fa-ban:before{content:"\f05e"}.fa-band-aid:before{content:"\f462"}.fa-bandcamp:before{content:"\f2d5"}.fa-barcode:before{content:"\f02a"}.fa-bars:before{content:"\f0c9"}.fa-baseball-ball:before{content:"\f433"}.fa-basketball-ball:before{content:"\f434"}.fa-bath:before{content:"\f2cd"}.fa-battery-empty:before{content:"\f244"}.fa-battery-full:before{content:"\f240"}.fa-battery-half:before{content:"\f242"}.fa-battery-quarter:before{content:"\f243"}.fa-battery-three-quarters:before{content:"\f241"}.fa-battle-net:before{content:"\f835"}.fa-bed:before{content:"\f236"}.fa-beer:before{content:"\f0fc"}.fa-behance:before{content:"\f1b4"}.fa-behance-square:before{content:"\f1b5"}.fa-bell:before{content:"\f0f3"}.fa-bell-slash:before{content:"\f1f6"}.fa-bezier-curve:before{content:"\f55b"}.fa-bible:before{content:"\f647"}.fa-bicycle:before{content:"\f206"}.fa-biking:before{content:"\f84a"}.fa-bimobject:before{content:"\f378"}.fa-binoculars:before{content:"\f1e5"}.fa-biohazard:before{content:"\f780"}.fa-birthday-cake:before{content:"\f1fd"}.fa-bitbucket:before{content:"\f171"}.fa-bitcoin:before{content:"\f379"}.fa-bity:before{content:"\f37a"}.fa-black-tie:before{content:"\f27e"}.fa-blackberry:before{content:"\f37b"}.fa-blender:before{content:"\f517"}.fa-blender-phone:before{content:"\f6b6"}.fa-blind:before{content:"\f29d"}.fa-blog:before{content:"\f781"}.fa-blogger:before{content:"\f37c"}.fa-blogger-b:before{content:"\f37d"}.fa-bluetooth:before{content:"\f293"}.fa-bluetooth-b:before{content:"\f294"}.fa-bold:before{content:"\f032"}.fa-bolt:before{content:"\f0e7"}.fa-bomb:before{content:"\f1e2"}.fa-bone:before{content:"\f5d7"}.fa-bong:before{content:"\f55c"}.fa-book:before{content:"\f02d"}.fa-book-dead:before{content:"\f6b7"}.fa-book-medical:before{content:"\f7e6"}.fa-book-open:before{content:"\f518"}.fa-book-reader:before{content:"\f5da"}.fa-bookmark:before{content:"\f02e"}.fa-bootstrap:before{content:"\f836"}.fa-border-all:before{content:"\f84c"}.fa-border-none:before{content:"\f850"}.fa-border-style:before{content:"\f853"}.fa-bowling-ball:before{content:"\f436"}.fa-box:before{content:"\f466"}.fa-box-open:before{content:"\f49e"}.fa-boxes:before{content:"\f468"}.fa-braille:before{content:"\f2a1"}.fa-brain:before{content:"\f5dc"}.fa-bread-slice:before{content:"\f7ec"}.fa-briefcase:before{content:"\f0b1"}.fa-briefcase-medical:before{content:"\f469"}.fa-broadcast-tower:before{content:"\f519"}.fa-broom:before{content:"\f51a"}.fa-brush:before{content:"\f55d"}.fa-btc:before{content:"\f15a"}.fa-buffer:before{content:"\f837"}.fa-bug:before{content:"\f188"}.fa-building:before{content:"\f1ad"}.fa-bullhorn:before{content:"\f0a1"}.fa-bullseye:before{content:"\f140"}.fa-burn:before{content:"\f46a"}.fa-buromobelexperte:before{content:"\f37f"}.fa-bus:before{content:"\f207"}.fa-bus-alt:before{content:"\f55e"}.fa-business-time:before{content:"\f64a"}.fa-buy-n-large:before{content:"\f8a6"}.fa-buysellads:before{content:"\f20d"}.fa-calculator:before{content:"\f1ec"}.fa-calendar:before{content:"\f133"}.fa-calendar-alt:before{content:"\f073"}.fa-calendar-check:before{content:"\f274"}.fa-calendar-day:before{content:"\f783"}.fa-calendar-minus:before{content:"\f272"}.fa-calendar-plus:before{content:"\f271"}.fa-calendar-times:before{content:"\f273"}.fa-calendar-week:before{content:"\f784"}.fa-camera:before{content:"\f030"}.fa-camera-retro:before{content:"\f083"}.fa-campground:before{content:"\f6bb"}.fa-canadian-maple-leaf:before{content:"\f785"}.fa-candy-cane:before{content:"\f786"}.fa-cannabis:before{content:"\f55f"}.fa-capsules:before{content:"\f46b"}.fa-car:before{content:"\f1b9"}.fa-car-alt:before{content:"\f5de"}.fa-car-battery:before{content:"\f5df"}.fa-car-crash:before{content:"\f5e1"}.fa-car-side:before{content:"\f5e4"}.fa-caravan:before{content:"\f8ff"}.fa-caret-down:before{content:"\f0d7"}.fa-caret-left:before{content:"\f0d9"}.fa-caret-right:before{content:"\f0da"}.fa-caret-square-down:before{content:"\f150"}.fa-caret-square-left:before{content:"\f191"}.fa-caret-square-right:before{content:"\f152"}.fa-caret-square-up:before{content:"\f151"}.fa-caret-up:before{content:"\f0d8"}.fa-carrot:before{content:"\f787"}.fa-cart-arrow-down:before{content:"\f218"}.fa-cart-plus:before{content:"\f217"}.fa-cash-register:before{content:"\f788"}.fa-cat:before{content:"\f6be"}.fa-cc-amazon-pay:before{content:"\f42d"}.fa-cc-amex:before{content:"\f1f3"}.fa-cc-apple-pay:before{content:"\f416"}.fa-cc-diners-club:before{content:"\f24c"}.fa-cc-discover:before{content:"\f1f2"}.fa-cc-jcb:before{content:"\f24b"}.fa-cc-mastercard:before{content:"\f1f1"}.fa-cc-paypal:before{content:"\f1f4"}.fa-cc-stripe:before{content:"\f1f5"}.fa-cc-visa:before{content:"\f1f0"}.fa-centercode:before{content:"\f380"}.fa-centos:before{content:"\f789"}.fa-certificate:before{content:"\f0a3"}.fa-chair:before{content:"\f6c0"}.fa-chalkboard:before{content:"\f51b"}.fa-chalkboard-teacher:before{content:"\f51c"}.fa-charging-station:before{content:"\f5e7"}.fa-chart-area:before{content:"\f1fe"}.fa-chart-bar:before{content:"\f080"}.fa-chart-line:before{content:"\f201"}.fa-chart-pie:before{content:"\f200"}.fa-check:before{content:"\f00c"}.fa-check-circle:before{content:"\f058"}.fa-check-double:before{content:"\f560"}.fa-check-square:before{content:"\f14a"}.fa-cheese:before{content:"\f7ef"}.fa-chess:before{content:"\f439"}.fa-chess-bishop:before{content:"\f43a"}.fa-chess-board:before{content:"\f43c"}.fa-chess-king:before{content:"\f43f"}.fa-chess-knight:before{content:"\f441"}.fa-chess-pawn:before{content:"\f443"}.fa-chess-queen:before{content:"\f445"}.fa-chess-rook:before{content:"\f447"}.fa-chevron-circle-down:before{content:"\f13a"}.fa-chevron-circle-left:before{content:"\f137"}.fa-chevron-circle-right:before{content:"\f138"}.fa-chevron-circle-up:before{content:"\f139"}.fa-chevron-down:before{content:"\f078"}.fa-chevron-left:before{content:"\f053"}.fa-chevron-right:before{content:"\f054"}.fa-chevron-up:before{content:"\f077"}.fa-child:before{content:"\f1ae"}.fa-chrome:before{content:"\f268"}.fa-chromecast:before{content:"\f838"}.fa-church:before{content:"\f51d"}.fa-circle:before{content:"\f111"}.fa-circle-notch:before{content:"\f1ce"}.fa-city:before{content:"\f64f"}.fa-clinic-medical:before{content:"\f7f2"}.fa-clipboard:before{content:"\f328"}.fa-clipboard-check:before{content:"\f46c"}.fa-clipboard-list:before{content:"\f46d"}.fa-clock:before{content:"\f017"}.fa-clone:before{content:"\f24d"}.fa-closed-captioning:before{content:"\f20a"}.fa-cloud:before{content:"\f0c2"}.fa-cloud-download-alt:before{content:"\f381"}.fa-cloud-meatball:before{content:"\f73b"}.fa-cloud-moon:before{content:"\f6c3"}.fa-cloud-moon-rain:before{content:"\f73c"}.fa-cloud-rain:before{content:"\f73d"}.fa-cloud-showers-heavy:before{content:"\f740"}.fa-cloud-sun:before{content:"\f6c4"}.fa-cloud-sun-rain:before{content:"\f743"}.fa-cloud-upload-alt:before{content:"\f382"}.fa-cloudscale:before{content:"\f383"}.fa-cloudsmith:before{content:"\f384"}.fa-cloudversify:before{content:"\f385"}.fa-cocktail:before{content:"\f561"}.fa-code:before{content:"\f121"}.fa-code-branch:before{content:"\f126"}.fa-codepen:before{content:"\f1cb"}.fa-codiepie:before{content:"\f284"}.fa-coffee:before{content:"\f0f4"}.fa-cog:before{content:"\f013"}.fa-cogs:before{content:"\f085"}.fa-coins:before{content:"\f51e"}.fa-columns:before{content:"\f0db"}.fa-comment:before{content:"\f075"}.fa-comment-alt:before{content:"\f27a"}.fa-comment-dollar:before{content:"\f651"}.fa-comment-dots:before{content:"\f4ad"}.fa-comment-medical:before{content:"\f7f5"}.fa-comment-slash:before{content:"\f4b3"}.fa-comments:before{content:"\f086"}.fa-comments-dollar:before{content:"\f653"}.fa-compact-disc:before{content:"\f51f"}.fa-compass:before{content:"\f14e"}.fa-compress:before{content:"\f066"}.fa-compress-alt:before{content:"\f422"}.fa-compress-arrows-alt:before{content:"\f78c"}.fa-concierge-bell:before{content:"\f562"}.fa-confluence:before{content:"\f78d"}.fa-connectdevelop:before{content:"\f20e"}.fa-contao:before{content:"\f26d"}.fa-cookie:before{content:"\f563"}.fa-cookie-bite:before{content:"\f564"}.fa-copy:before{content:"\f0c5"}.fa-copyright:before{content:"\f1f9"}.fa-cotton-bureau:before{content:"\f89e"}.fa-couch:before{content:"\f4b8"}.fa-cpanel:before{content:"\f388"}.fa-creative-commons:before{content:"\f25e"}.fa-creative-commons-by:before{content:"\f4e7"}.fa-creative-commons-nc:before{content:"\f4e8"}.fa-creative-commons-nc-eu:before{content:"\f4e9"}.fa-creative-commons-nc-jp:before{content:"\f4ea"}.fa-creative-commons-nd:before{content:"\f4eb"}.fa-creative-commons-pd:before{content:"\f4ec"}.fa-creative-commons-pd-alt:before{content:"\f4ed"}.fa-creative-commons-remix:before{content:"\f4ee"}.fa-creative-commons-sa:before{content:"\f4ef"}.fa-creative-commons-sampling:before{content:"\f4f0"}.fa-creative-commons-sampling-plus:before{content:"\f4f1"}.fa-creative-commons-share:before{content:"\f4f2"}.fa-creative-commons-zero:before{content:"\f4f3"}.fa-credit-card:before{content:"\f09d"}.fa-critical-role:before{content:"\f6c9"}.fa-crop:before{content:"\f125"}.fa-crop-alt:before{content:"\f565"}.fa-cross:before{content:"\f654"}.fa-crosshairs:before{content:"\f05b"}.fa-crow:before{content:"\f520"}.fa-crown:before{content:"\f521"}.fa-crutch:before{content:"\f7f7"}.fa-css3:before{content:"\f13c"}.fa-css3-alt:before{content:"\f38b"}.fa-cube:before{content:"\f1b2"}.fa-cubes:before{content:"\f1b3"}.fa-cut:before{content:"\f0c4"}.fa-cuttlefish:before{content:"\f38c"}.fa-d-and-d:before{content:"\f38d"}.fa-d-and-d-beyond:before{content:"\f6ca"}.fa-dashcube:before{content:"\f210"}.fa-database:before{content:"\f1c0"}.fa-deaf:before{content:"\f2a4"}.fa-delicious:before{content:"\f1a5"}.fa-democrat:before{content:"\f747"}.fa-deploydog:before{content:"\f38e"}.fa-deskpro:before{content:"\f38f"}.fa-desktop:before{content:"\f108"}.fa-dev:before{content:"\f6cc"}.fa-deviantart:before{content:"\f1bd"}.fa-dharmachakra:before{content:"\f655"}.fa-dhl:before{content:"\f790"}.fa-diagnoses:before{content:"\f470"}.fa-diaspora:before{content:"\f791"}.fa-dice:before{content:"\f522"}.fa-dice-d20:before{content:"\f6cf"}.fa-dice-d6:before{content:"\f6d1"}.fa-dice-five:before{content:"\f523"}.fa-dice-four:before{content:"\f524"}.fa-dice-one:before{content:"\f525"}.fa-dice-six:before{content:"\f526"}.fa-dice-three:before{content:"\f527"}.fa-dice-two:before{content:"\f528"}.fa-digg:before{content:"\f1a6"}.fa-digital-ocean:before{content:"\f391"}.fa-digital-tachograph:before{content:"\f566"}.fa-directions:before{content:"\f5eb"}.fa-discord:before{content:"\f392"}.fa-discourse:before{content:"\f393"}.fa-divide:before{content:"\f529"}.fa-dizzy:before{content:"\f567"}.fa-dna:before{content:"\f471"}.fa-dochub:before{content:"\f394"}.fa-docker:before{content:"\f395"}.fa-dog:before{content:"\f6d3"}.fa-dollar-sign:before{content:"\f155"}.fa-dolly:before{content:"\f472"}.fa-dolly-flatbed:before{content:"\f474"}.fa-donate:before{content:"\f4b9"}.fa-door-closed:before{content:"\f52a"}.fa-door-open:before{content:"\f52b"}.fa-dot-circle:before{content:"\f192"}.fa-dove:before{content:"\f4ba"}.fa-download:before{content:"\f019"}.fa-draft2digital:before{content:"\f396"}.fa-drafting-compass:before{content:"\f568"}.fa-dragon:before{content:"\f6d5"}.fa-draw-polygon:before{content:"\f5ee"}.fa-dribbble:before{content:"\f17d"}.fa-dribbble-square:before{content:"\f397"}.fa-dropbox:before{content:"\f16b"}.fa-drum:before{content:"\f569"}.fa-drum-steelpan:before{content:"\f56a"}.fa-drumstick-bite:before{content:"\f6d7"}.fa-drupal:before{content:"\f1a9"}.fa-dumbbell:before{content:"\f44b"}.fa-dumpster:before{content:"\f793"}.fa-dumpster-fire:before{content:"\f794"}.fa-dungeon:before{content:"\f6d9"}.fa-dyalog:before{content:"\f399"}.fa-earlybirds:before{content:"\f39a"}.fa-ebay:before{content:"\f4f4"}.fa-edge:before{content:"\f282"}.fa-edit:before{content:"\f044"}.fa-egg:before{content:"\f7fb"}.fa-eject:before{content:"\f052"}.fa-elementor:before{content:"\f430"}.fa-ellipsis-h:before{content:"\f141"}.fa-ellipsis-v:before{content:"\f142"}.fa-ello:before{content:"\f5f1"}.fa-ember:before{content:"\f423"}.fa-empire:before{content:"\f1d1"}.fa-envelope:before{content:"\f0e0"}.fa-envelope-open:before{content:"\f2b6"}.fa-envelope-open-text:before{content:"\f658"}.fa-envelope-square:before{content:"\f199"}.fa-envira:before{content:"\f299"}.fa-equals:before{content:"\f52c"}.fa-eraser:before{content:"\f12d"}.fa-erlang:before{content:"\f39d"}.fa-ethereum:before{content:"\f42e"}.fa-ethernet:before{content:"\f796"}.fa-etsy:before{content:"\f2d7"}.fa-euro-sign:before{content:"\f153"}.fa-evernote:before{content:"\f839"}.fa-exchange-alt:before{content:"\f362"}.fa-exclamation:before{content:"\f12a"}.fa-exclamation-circle:before{content:"\f06a"}.fa-exclamation-triangle:before{content:"\f071"}.fa-expand:before{content:"\f065"}.fa-expand-alt:before{content:"\f424"}.fa-expand-arrows-alt:before{content:"\f31e"}.fa-expeditedssl:before{content:"\f23e"}.fa-external-link-alt:before{content:"\f35d"}.fa-external-link-square-alt:before{content:"\f360"}.fa-eye:before{content:"\f06e"}.fa-eye-dropper:before{content:"\f1fb"}.fa-eye-slash:before{content:"\f070"}.fa-facebook:before{content:"\f09a"}.fa-facebook-f:before{content:"\f39e"}.fa-facebook-messenger:before{content:"\f39f"}.fa-facebook-square:before{content:"\f082"}.fa-fan:before{content:"\f863"}.fa-fantasy-flight-games:before{content:"\f6dc"}.fa-fast-backward:before{content:"\f049"}.fa-fast-forward:before{content:"\f050"}.fa-fax:before{content:"\f1ac"}.fa-feather:before{content:"\f52d"}.fa-feather-alt:before{content:"\f56b"}.fa-fedex:before{content:"\f797"}.fa-fedora:before{content:"\f798"}.fa-female:before{content:"\f182"}.fa-fighter-jet:before{content:"\f0fb"}.fa-figma:before{content:"\f799"}.fa-file:before{content:"\f15b"}.fa-file-alt:before{content:"\f15c"}.fa-file-archive:before{content:"\f1c6"}.fa-file-audio:before{content:"\f1c7"}.fa-file-code:before{content:"\f1c9"}.fa-file-contract:before{content:"\f56c"}.fa-file-csv:before{content:"\f6dd"}.fa-file-download:before{content:"\f56d"}.fa-file-excel:before{content:"\f1c3"}.fa-file-export:before{content:"\f56e"}.fa-file-image:before{content:"\f1c5"}.fa-file-import:before{content:"\f56f"}.fa-file-invoice:before{content:"\f570"}.fa-file-invoice-dollar:before{content:"\f571"}.fa-file-medical:before{content:"\f477"}.fa-file-medical-alt:before{content:"\f478"}.fa-file-pdf:before{content:"\f1c1"}.fa-file-powerpoint:before{content:"\f1c4"}.fa-file-prescription:before{content:"\f572"}.fa-file-signature:before{content:"\f573"}.fa-file-upload:before{content:"\f574"}.fa-file-video:before{content:"\f1c8"}.fa-file-word:before{content:"\f1c2"}.fa-fill:before{content:"\f575"}.fa-fill-drip:before{content:"\f576"}.fa-film:before{content:"\f008"}.fa-filter:before{content:"\f0b0"}.fa-fingerprint:before{content:"\f577"}.fa-fire:before{content:"\f06d"}.fa-fire-alt:before{content:"\f7e4"}.fa-fire-extinguisher:before{content:"\f134"}.fa-firefox:before{content:"\f269"}.fa-firefox-browser:before{content:"\f907"}.fa-first-aid:before{content:"\f479"}.fa-first-order:before{content:"\f2b0"}.fa-first-order-alt:before{content:"\f50a"}.fa-firstdraft:before{content:"\f3a1"}.fa-fish:before{content:"\f578"}.fa-fist-raised:before{content:"\f6de"}.fa-flag:before{content:"\f024"}.fa-flag-checkered:before{content:"\f11e"}.fa-flag-usa:before{content:"\f74d"}.fa-flask:before{content:"\f0c3"}.fa-flickr:before{content:"\f16e"}.fa-flipboard:before{content:"\f44d"}.fa-flushed:before{content:"\f579"}.fa-fly:before{content:"\f417"}.fa-folder:before{content:"\f07b"}.fa-folder-minus:before{content:"\f65d"}.fa-folder-open:before{content:"\f07c"}.fa-folder-plus:before{content:"\f65e"}.fa-font:before{content:"\f031"}.fa-font-awesome:before{content:"\f2b4"}.fa-font-awesome-alt:before{content:"\f35c"}.fa-font-awesome-flag:before{content:"\f425"}.fa-font-awesome-logo-full:before{content:"\f4e6"}.fa-fonticons:before{content:"\f280"}.fa-fonticons-fi:before{content:"\f3a2"}.fa-football-ball:before{content:"\f44e"}.fa-fort-awesome:before{content:"\f286"}.fa-fort-awesome-alt:before{content:"\f3a3"}.fa-forumbee:before{content:"\f211"}.fa-forward:before{content:"\f04e"}.fa-foursquare:before{content:"\f180"}.fa-free-code-camp:before{content:"\f2c5"}.fa-freebsd:before{content:"\f3a4"}.fa-frog:before{content:"\f52e"}.fa-frown:before{content:"\f119"}.fa-frown-open:before{content:"\f57a"}.fa-fulcrum:before{content:"\f50b"}.fa-funnel-dollar:before{content:"\f662"}.fa-futbol:before{content:"\f1e3"}.fa-galactic-republic:before{content:"\f50c"}.fa-galactic-senate:before{content:"\f50d"}.fa-gamepad:before{content:"\f11b"}.fa-gas-pump:before{content:"\f52f"}.fa-gavel:before{content:"\f0e3"}.fa-gem:before{content:"\f3a5"}.fa-genderless:before{content:"\f22d"}.fa-get-pocket:before{content:"\f265"}.fa-gg:before{content:"\f260"}.fa-gg-circle:before{content:"\f261"}.fa-ghost:before{content:"\f6e2"}.fa-gift:before{content:"\f06b"}.fa-gifts:before{content:"\f79c"}.fa-git:before{content:"\f1d3"}.fa-git-alt:before{content:"\f841"}.fa-git-square:before{content:"\f1d2"}.fa-github:before{content:"\f09b"}.fa-github-alt:before{content:"\f113"}.fa-github-square:before{content:"\f092"}.fa-gitkraken:before{content:"\f3a6"}.fa-gitlab:before{content:"\f296"}.fa-gitter:before{content:"\f426"}.fa-glass-cheers:before{content:"\f79f"}.fa-glass-martini:before{content:"\f000"}.fa-glass-martini-alt:before{content:"\f57b"}.fa-glass-whiskey:before{content:"\f7a0"}.fa-glasses:before{content:"\f530"}.fa-glide:before{content:"\f2a5"}.fa-glide-g:before{content:"\f2a6"}.fa-globe:before{content:"\f0ac"}.fa-globe-africa:before{content:"\f57c"}.fa-globe-americas:before{content:"\f57d"}.fa-globe-asia:before{content:"\f57e"}.fa-globe-europe:before{content:"\f7a2"}.fa-gofore:before{content:"\f3a7"}.fa-golf-ball:before{content:"\f450"}.fa-goodreads:before{content:"\f3a8"}.fa-goodreads-g:before{content:"\f3a9"}.fa-google:before{content:"\f1a0"}.fa-google-drive:before{content:"\f3aa"}.fa-google-play:before{content:"\f3ab"}.fa-google-plus:before{content:"\f2b3"}.fa-google-plus-g:before{content:"\f0d5"}.fa-google-plus-square:before{content:"\f0d4"}.fa-google-wallet:before{content:"\f1ee"}.fa-gopuram:before{content:"\f664"}.fa-graduation-cap:before{content:"\f19d"}.fa-gratipay:before{content:"\f184"}.fa-grav:before{content:"\f2d6"}.fa-greater-than:before{content:"\f531"}.fa-greater-than-equal:before{content:"\f532"}.fa-grimace:before{content:"\f57f"}.fa-grin:before{content:"\f580"}.fa-grin-alt:before{content:"\f581"}.fa-grin-beam:before{content:"\f582"}.fa-grin-beam-sweat:before{content:"\f583"}.fa-grin-hearts:before{content:"\f584"}.fa-grin-squint:before{content:"\f585"}.fa-grin-squint-tears:before{content:"\f586"}.fa-grin-stars:before{content:"\f587"}.fa-grin-tears:before{content:"\f588"}.fa-grin-tongue:before{content:"\f589"}.fa-grin-tongue-squint:before{content:"\f58a"}.fa-grin-tongue-wink:before{content:"\f58b"}.fa-grin-wink:before{content:"\f58c"}.fa-grip-horizontal:before{content:"\f58d"}.fa-grip-lines:before{content:"\f7a4"}.fa-grip-lines-vertical:before{content:"\f7a5"}.fa-grip-vertical:before{content:"\f58e"}.fa-gripfire:before{content:"\f3ac"}.fa-grunt:before{content:"\f3ad"}.fa-guitar:before{content:"\f7a6"}.fa-gulp:before{content:"\f3ae"}.fa-h-square:before{content:"\f0fd"}.fa-hacker-news:before{content:"\f1d4"}.fa-hacker-news-square:before{content:"\f3af"}.fa-hackerrank:before{content:"\f5f7"}.fa-hamburger:before{content:"\f805"}.fa-hammer:before{content:"\f6e3"}.fa-hamsa:before{content:"\f665"}.fa-hand-holding:before{content:"\f4bd"}.fa-hand-holding-heart:before{content:"\f4be"}.fa-hand-holding-usd:before{content:"\f4c0"}.fa-hand-lizard:before{content:"\f258"}.fa-hand-middle-finger:before{content:"\f806"}.fa-hand-paper:before{content:"\f256"}.fa-hand-peace:before{content:"\f25b"}.fa-hand-point-down:before{content:"\f0a7"}.fa-hand-point-left:before{content:"\f0a5"}.fa-hand-point-right:before{content:"\f0a4"}.fa-hand-point-up:before{content:"\f0a6"}.fa-hand-pointer:before{content:"\f25a"}.fa-hand-rock:before{content:"\f255"}.fa-hand-scissors:before{content:"\f257"}.fa-hand-spock:before{content:"\f259"}.fa-hands:before{content:"\f4c2"}.fa-hands-helping:before{content:"\f4c4"}.fa-handshake:before{content:"\f2b5"}.fa-hanukiah:before{content:"\f6e6"}.fa-hard-hat:before{content:"\f807"}.fa-hashtag:before{content:"\f292"}.fa-hat-cowboy:before{content:"\f8c0"}.fa-hat-cowboy-side:before{content:"\f8c1"}.fa-hat-wizard:before{content:"\f6e8"}.fa-hdd:before{content:"\f0a0"}.fa-heading:before{content:"\f1dc"}.fa-headphones:before{content:"\f025"}.fa-headphones-alt:before{content:"\f58f"}.fa-headset:before{content:"\f590"}.fa-heart:before{content:"\f004"}.fa-heart-broken:before{content:"\f7a9"}.fa-heartbeat:before{content:"\f21e"}.fa-helicopter:before{content:"\f533"}.fa-highlighter:before{content:"\f591"}.fa-hiking:before{content:"\f6ec"}.fa-hippo:before{content:"\f6ed"}.fa-hips:before{content:"\f452"}.fa-hire-a-helper:before{content:"\f3b0"}.fa-history:before{content:"\f1da"}.fa-hockey-puck:before{content:"\f453"}.fa-holly-berry:before{content:"\f7aa"}.fa-home:before{content:"\f015"}.fa-hooli:before{content:"\f427"}.fa-hornbill:before{content:"\f592"}.fa-horse:before{content:"\f6f0"}.fa-horse-head:before{content:"\f7ab"}.fa-hospital:before{content:"\f0f8"}.fa-hospital-alt:before{content:"\f47d"}.fa-hospital-symbol:before{content:"\f47e"}.fa-hot-tub:before{content:"\f593"}.fa-hotdog:before{content:"\f80f"}.fa-hotel:before{content:"\f594"}.fa-hotjar:before{content:"\f3b1"}.fa-hourglass:before{content:"\f254"}.fa-hourglass-end:before{content:"\f253"}.fa-hourglass-half:before{content:"\f252"}.fa-hourglass-start:before{content:"\f251"}.fa-house-damage:before{content:"\f6f1"}.fa-houzz:before{content:"\f27c"}.fa-hryvnia:before{content:"\f6f2"}.fa-html5:before{content:"\f13b"}.fa-hubspot:before{content:"\f3b2"}.fa-i-cursor:before{content:"\f246"}.fa-ice-cream:before{content:"\f810"}.fa-icicles:before{content:"\f7ad"}.fa-icons:before{content:"\f86d"}.fa-id-badge:before{content:"\f2c1"}.fa-id-card:before{content:"\f2c2"}.fa-id-card-alt:before{content:"\f47f"}.fa-ideal:before{content:"\f913"}.fa-igloo:before{content:"\f7ae"}.fa-image:before{content:"\f03e"}.fa-images:before{content:"\f302"}.fa-imdb:before{content:"\f2d8"}.fa-inbox:before{content:"\f01c"}.fa-indent:before{content:"\f03c"}.fa-industry:before{content:"\f275"}.fa-infinity:before{content:"\f534"}.fa-info:before{content:"\f129"}.fa-info-circle:before{content:"\f05a"}.fa-instagram:before{content:"\f16d"}.fa-intercom:before{content:"\f7af"}.fa-internet-explorer:before{content:"\f26b"}.fa-invision:before{content:"\f7b0"}.fa-ioxhost:before{content:"\f208"}.fa-italic:before{content:"\f033"}.fa-itch-io:before{content:"\f83a"}.fa-itunes:before{content:"\f3b4"}.fa-itunes-note:before{content:"\f3b5"}.fa-java:before{content:"\f4e4"}.fa-jedi:before{content:"\f669"}.fa-jedi-order:before{content:"\f50e"}.fa-jenkins:before{content:"\f3b6"}.fa-jira:before{content:"\f7b1"}.fa-joget:before{content:"\f3b7"}.fa-joint:before{content:"\f595"}.fa-joomla:before{content:"\f1aa"}.fa-journal-whills:before{content:"\f66a"}.fa-js:before{content:"\f3b8"}.fa-js-square:before{content:"\f3b9"}.fa-jsfiddle:before{content:"\f1cc"}.fa-kaaba:before{content:"\f66b"}.fa-kaggle:before{content:"\f5fa"}.fa-key:before{content:"\f084"}.fa-keybase:before{content:"\f4f5"}.fa-keyboard:before{content:"\f11c"}.fa-keycdn:before{content:"\f3ba"}.fa-khanda:before{content:"\f66d"}.fa-kickstarter:before{content:"\f3bb"}.fa-kickstarter-k:before{content:"\f3bc"}.fa-kiss:before{content:"\f596"}.fa-kiss-beam:before{content:"\f597"}.fa-kiss-wink-heart:before{content:"\f598"}.fa-kiwi-bird:before{content:"\f535"}.fa-korvue:before{content:"\f42f"}.fa-landmark:before{content:"\f66f"}.fa-language:before{content:"\f1ab"}.fa-laptop:before{content:"\f109"}.fa-laptop-code:before{content:"\f5fc"}.fa-laptop-medical:before{content:"\f812"}.fa-laravel:before{content:"\f3bd"}.fa-lastfm:before{content:"\f202"}.fa-lastfm-square:before{content:"\f203"}.fa-laugh:before{content:"\f599"}.fa-laugh-beam:before{content:"\f59a"}.fa-laugh-squint:before{content:"\f59b"}.fa-laugh-wink:before{content:"\f59c"}.fa-layer-group:before{content:"\f5fd"}.fa-leaf:before{content:"\f06c"}.fa-leanpub:before{content:"\f212"}.fa-lemon:before{content:"\f094"}.fa-less:before{content:"\f41d"}.fa-less-than:before{content:"\f536"}.fa-less-than-equal:before{content:"\f537"}.fa-level-down-alt:before{content:"\f3be"}.fa-level-up-alt:before{content:"\f3bf"}.fa-life-ring:before{content:"\f1cd"}.fa-lightbulb:before{content:"\f0eb"}.fa-line:before{content:"\f3c0"}.fa-link:before{content:"\f0c1"}.fa-linkedin:before{content:"\f08c"}.fa-linkedin-in:before{content:"\f0e1"}.fa-linode:before{content:"\f2b8"}.fa-linux:before{content:"\f17c"}.fa-lira-sign:before{content:"\f195"}.fa-list:before{content:"\f03a"}.fa-list-alt:before{content:"\f022"}.fa-list-ol:before{content:"\f0cb"}.fa-list-ul:before{content:"\f0ca"}.fa-location-arrow:before{content:"\f124"}.fa-lock:before{content:"\f023"}.fa-lock-open:before{content:"\f3c1"}.fa-long-arrow-alt-down:before{content:"\f309"}.fa-long-arrow-alt-left:before{content:"\f30a"}.fa-long-arrow-alt-right:before{content:"\f30b"}.fa-long-arrow-alt-up:before{content:"\f30c"}.fa-low-vision:before{content:"\f2a8"}.fa-luggage-cart:before{content:"\f59d"}.fa-lyft:before{content:"\f3c3"}.fa-magento:before{content:"\f3c4"}.fa-magic:before{content:"\f0d0"}.fa-magnet:before{content:"\f076"}.fa-mail-bulk:before{content:"\f674"}.fa-mailchimp:before{content:"\f59e"}.fa-male:before{content:"\f183"}.fa-mandalorian:before{content:"\f50f"}.fa-map:before{content:"\f279"}.fa-map-marked:before{content:"\f59f"}.fa-map-marked-alt:before{content:"\f5a0"}.fa-map-marker:before{content:"\f041"}.fa-map-marker-alt:before{content:"\f3c5"}.fa-map-pin:before{content:"\f276"}.fa-map-signs:before{content:"\f277"}.fa-markdown:before{content:"\f60f"}.fa-marker:before{content:"\f5a1"}.fa-mars:before{content:"\f222"}.fa-mars-double:before{content:"\f227"}.fa-mars-stroke:before{content:"\f229"}.fa-mars-stroke-h:before{content:"\f22b"}.fa-mars-stroke-v:before{content:"\f22a"}.fa-mask:before{content:"\f6fa"}.fa-mastodon:before{content:"\f4f6"}.fa-maxcdn:before{content:"\f136"}.fa-mdb:before{content:"\f8ca"}.fa-medal:before{content:"\f5a2"}.fa-medapps:before{content:"\f3c6"}.fa-medium:before{content:"\f23a"}.fa-medium-m:before{content:"\f3c7"}.fa-medkit:before{content:"\f0fa"}.fa-medrt:before{content:"\f3c8"}.fa-meetup:before{content:"\f2e0"}.fa-megaport:before{content:"\f5a3"}.fa-meh:before{content:"\f11a"}.fa-meh-blank:before{content:"\f5a4"}.fa-meh-rolling-eyes:before{content:"\f5a5"}.fa-memory:before{content:"\f538"}.fa-mendeley:before{content:"\f7b3"}.fa-menorah:before{content:"\f676"}.fa-mercury:before{content:"\f223"}.fa-meteor:before{content:"\f753"}.fa-microblog:before{content:"\f91a"}.fa-microchip:before{content:"\f2db"}.fa-microphone:before{content:"\f130"}.fa-microphone-alt:before{content:"\f3c9"}.fa-microphone-alt-slash:before{content:"\f539"}.fa-microphone-slash:before{content:"\f131"}.fa-microscope:before{content:"\f610"}.fa-microsoft:before{content:"\f3ca"}.fa-minus:before{content:"\f068"}.fa-minus-circle:before{content:"\f056"}.fa-minus-square:before{content:"\f146"}.fa-mitten:before{content:"\f7b5"}.fa-mix:before{content:"\f3cb"}.fa-mixcloud:before{content:"\f289"}.fa-mizuni:before{content:"\f3cc"}.fa-mobile:before{content:"\f10b"}.fa-mobile-alt:before{content:"\f3cd"}.fa-modx:before{content:"\f285"}.fa-monero:before{content:"\f3d0"}.fa-money-bill:before{content:"\f0d6"}.fa-money-bill-alt:before{content:"\f3d1"}.fa-money-bill-wave:before{content:"\f53a"}.fa-money-bill-wave-alt:before{content:"\f53b"}.fa-money-check:before{content:"\f53c"}.fa-money-check-alt:before{content:"\f53d"}.fa-monument:before{content:"\f5a6"}.fa-moon:before{content:"\f186"}.fa-mortar-pestle:before{content:"\f5a7"}.fa-mosque:before{content:"\f678"}.fa-motorcycle:before{content:"\f21c"}.fa-mountain:before{content:"\f6fc"}.fa-mouse:before{content:"\f8cc"}.fa-mouse-pointer:before{content:"\f245"}.fa-mug-hot:before{content:"\f7b6"}.fa-music:before{content:"\f001"}.fa-napster:before{content:"\f3d2"}.fa-neos:before{content:"\f612"}.fa-network-wired:before{content:"\f6ff"}.fa-neuter:before{content:"\f22c"}.fa-newspaper:before{content:"\f1ea"}.fa-nimblr:before{content:"\f5a8"}.fa-node:before{content:"\f419"}.fa-node-js:before{content:"\f3d3"}.fa-not-equal:before{content:"\f53e"}.fa-notes-medical:before{content:"\f481"}.fa-npm:before{content:"\f3d4"}.fa-ns8:before{content:"\f3d5"}.fa-nutritionix:before{content:"\f3d6"}.fa-object-group:before{content:"\f247"}.fa-object-ungroup:before{content:"\f248"}.fa-odnoklassniki:before{content:"\f263"}.fa-odnoklassniki-square:before{content:"\f264"}.fa-oil-can:before{content:"\f613"}.fa-old-republic:before{content:"\f510"}.fa-om:before{content:"\f679"}.fa-opencart:before{content:"\f23d"}.fa-openid:before{content:"\f19b"}.fa-opera:before{content:"\f26a"}.fa-optin-monster:before{content:"\f23c"}.fa-orcid:before{content:"\f8d2"}.fa-osi:before{content:"\f41a"}.fa-otter:before{content:"\f700"}.fa-outdent:before{content:"\f03b"}.fa-page4:before{content:"\f3d7"}.fa-pagelines:before{content:"\f18c"}.fa-pager:before{content:"\f815"}.fa-paint-brush:before{content:"\f1fc"}.fa-paint-roller:before{content:"\f5aa"}.fa-palette:before{content:"\f53f"}.fa-palfed:before{content:"\f3d8"}.fa-pallet:before{content:"\f482"}.fa-paper-plane:before{content:"\f1d8"}.fa-paperclip:before{content:"\f0c6"}.fa-parachute-box:before{content:"\f4cd"}.fa-paragraph:before{content:"\f1dd"}.fa-parking:before{content:"\f540"}.fa-passport:before{content:"\f5ab"}.fa-pastafarianism:before{content:"\f67b"}.fa-paste:before{content:"\f0ea"}.fa-patreon:before{content:"\f3d9"}.fa-pause:before{content:"\f04c"}.fa-pause-circle:before{content:"\f28b"}.fa-paw:before{content:"\f1b0"}.fa-paypal:before{content:"\f1ed"}.fa-peace:before{content:"\f67c"}.fa-pen:before{content:"\f304"}.fa-pen-alt:before{content:"\f305"}.fa-pen-fancy:before{content:"\f5ac"}.fa-pen-nib:before{content:"\f5ad"}.fa-pen-square:before{content:"\f14b"}.fa-pencil-alt:before{content:"\f303"}.fa-pencil-ruler:before{content:"\f5ae"}.fa-penny-arcade:before{content:"\f704"}.fa-people-carry:before{content:"\f4ce"}.fa-pepper-hot:before{content:"\f816"}.fa-percent:before{content:"\f295"}.fa-percentage:before{content:"\f541"}.fa-periscope:before{content:"\f3da"}.fa-person-booth:before{content:"\f756"}.fa-phabricator:before{content:"\f3db"}.fa-phoenix-framework:before{content:"\f3dc"}.fa-phoenix-squadron:before{content:"\f511"}.fa-phone:before{content:"\f095"}.fa-phone-alt:before{content:"\f879"}.fa-phone-slash:before{content:"\f3dd"}.fa-phone-square:before{content:"\f098"}.fa-phone-square-alt:before{content:"\f87b"}.fa-phone-volume:before{content:"\f2a0"}.fa-photo-video:before{content:"\f87c"}.fa-php:before{content:"\f457"}.fa-pied-piper:before{content:"\f2ae"}.fa-pied-piper-alt:before{content:"\f1a8"}.fa-pied-piper-hat:before{content:"\f4e5"}.fa-pied-piper-pp:before{content:"\f1a7"}.fa-pied-piper-square:before{content:"\f91e"}.fa-piggy-bank:before{content:"\f4d3"}.fa-pills:before{content:"\f484"}.fa-pinterest:before{content:"\f0d2"}.fa-pinterest-p:before{content:"\f231"}.fa-pinterest-square:before{content:"\f0d3"}.fa-pizza-slice:before{content:"\f818"}.fa-place-of-worship:before{content:"\f67f"}.fa-plane:before{content:"\f072"}.fa-plane-arrival:before{content:"\f5af"}.fa-plane-departure:before{content:"\f5b0"}.fa-play:before{content:"\f04b"}.fa-play-circle:before{content:"\f144"}.fa-playstation:before{content:"\f3df"}.fa-plug:before{content:"\f1e6"}.fa-plus:before{content:"\f067"}.fa-plus-circle:before{content:"\f055"}.fa-plus-square:before{content:"\f0fe"}.fa-podcast:before{content:"\f2ce"}.fa-poll:before{content:"\f681"}.fa-poll-h:before{content:"\f682"}.fa-poo:before{content:"\f2fe"}.fa-poo-storm:before{content:"\f75a"}.fa-poop:before{content:"\f619"}.fa-portrait:before{content:"\f3e0"}.fa-pound-sign:before{content:"\f154"}.fa-power-off:before{content:"\f011"}.fa-pray:before{content:"\f683"}.fa-praying-hands:before{content:"\f684"}.fa-prescription:before{content:"\f5b1"}.fa-prescription-bottle:before{content:"\f485"}.fa-prescription-bottle-alt:before{content:"\f486"}.fa-print:before{content:"\f02f"}.fa-procedures:before{content:"\f487"}.fa-product-hunt:before{content:"\f288"}.fa-project-diagram:before{content:"\f542"}.fa-pushed:before{content:"\f3e1"}.fa-puzzle-piece:before{content:"\f12e"}.fa-python:before{content:"\f3e2"}.fa-qq:before{content:"\f1d6"}.fa-qrcode:before{content:"\f029"}.fa-question:before{content:"\f128"}.fa-question-circle:before{content:"\f059"}.fa-quidditch:before{content:"\f458"}.fa-quinscape:before{content:"\f459"}.fa-quora:before{content:"\f2c4"}.fa-quote-left:before{content:"\f10d"}.fa-quote-right:before{content:"\f10e"}.fa-quran:before{content:"\f687"}.fa-r-project:before{content:"\f4f7"}.fa-radiation:before{content:"\f7b9"}.fa-radiation-alt:before{content:"\f7ba"}.fa-rainbow:before{content:"\f75b"}.fa-random:before{content:"\f074"}.fa-raspberry-pi:before{content:"\f7bb"}.fa-ravelry:before{content:"\f2d9"}.fa-react:before{content:"\f41b"}.fa-reacteurope:before{content:"\f75d"}.fa-readme:before{content:"\f4d5"}.fa-rebel:before{content:"\f1d0"}.fa-receipt:before{content:"\f543"}.fa-record-vinyl:before{content:"\f8d9"}.fa-recycle:before{content:"\f1b8"}.fa-red-river:before{content:"\f3e3"}.fa-reddit:before{content:"\f1a1"}.fa-reddit-alien:before{content:"\f281"}.fa-reddit-square:before{content:"\f1a2"}.fa-redhat:before{content:"\f7bc"}.fa-redo:before{content:"\f01e"}.fa-redo-alt:before{content:"\f2f9"}.fa-registered:before{content:"\f25d"}.fa-remove-format:before{content:"\f87d"}.fa-renren:before{content:"\f18b"}.fa-reply:before{content:"\f3e5"}.fa-reply-all:before{content:"\f122"}.fa-replyd:before{content:"\f3e6"}.fa-republican:before{content:"\f75e"}.fa-researchgate:before{content:"\f4f8"}.fa-resolving:before{content:"\f3e7"}.fa-restroom:before{content:"\f7bd"}.fa-retweet:before{content:"\f079"}.fa-rev:before{content:"\f5b2"}.fa-ribbon:before{content:"\f4d6"}.fa-ring:before{content:"\f70b"}.fa-road:before{content:"\f018"}.fa-robot:before{content:"\f544"}.fa-rocket:before{content:"\f135"}.fa-rocketchat:before{content:"\f3e8"}.fa-rockrms:before{content:"\f3e9"}.fa-route:before{content:"\f4d7"}.fa-rss:before{content:"\f09e"}.fa-rss-square:before{content:"\f143"}.fa-ruble-sign:before{content:"\f158"}.fa-ruler:before{content:"\f545"}.fa-ruler-combined:before{content:"\f546"}.fa-ruler-horizontal:before{content:"\f547"}.fa-ruler-vertical:before{content:"\f548"}.fa-running:before{content:"\f70c"}.fa-rupee-sign:before{content:"\f156"}.fa-sad-cry:before{content:"\f5b3"}.fa-sad-tear:before{content:"\f5b4"}.fa-safari:before{content:"\f267"}.fa-salesforce:before{content:"\f83b"}.fa-sass:before{content:"\f41e"}.fa-satellite:before{content:"\f7bf"}.fa-satellite-dish:before{content:"\f7c0"}.fa-save:before{content:"\f0c7"}.fa-schlix:before{content:"\f3ea"}.fa-school:before{content:"\f549"}.fa-screwdriver:before{content:"\f54a"}.fa-scribd:before{content:"\f28a"}.fa-scroll:before{content:"\f70e"}.fa-sd-card:before{content:"\f7c2"}.fa-search:before{content:"\f002"}.fa-search-dollar:before{content:"\f688"}.fa-search-location:before{content:"\f689"}.fa-search-minus:before{content:"\f010"}.fa-search-plus:before{content:"\f00e"}.fa-searchengin:before{content:"\f3eb"}.fa-seedling:before{content:"\f4d8"}.fa-sellcast:before{content:"\f2da"}.fa-sellsy:before{content:"\f213"}.fa-server:before{content:"\f233"}.fa-servicestack:before{content:"\f3ec"}.fa-shapes:before{content:"\f61f"}.fa-share:before{content:"\f064"}.fa-share-alt:before{content:"\f1e0"}.fa-share-alt-square:before{content:"\f1e1"}.fa-share-square:before{content:"\f14d"}.fa-shekel-sign:before{content:"\f20b"}.fa-shield-alt:before{content:"\f3ed"}.fa-ship:before{content:"\f21a"}.fa-shipping-fast:before{content:"\f48b"}.fa-shirtsinbulk:before{content:"\f214"}.fa-shoe-prints:before{content:"\f54b"}.fa-shopping-bag:before{content:"\f290"}.fa-shopping-basket:before{content:"\f291"}.fa-shopping-cart:before{content:"\f07a"}.fa-shopware:before{content:"\f5b5"}.fa-shower:before{content:"\f2cc"}.fa-shuttle-van:before{content:"\f5b6"}.fa-sign:before{content:"\f4d9"}.fa-sign-in-alt:before{content:"\f2f6"}.fa-sign-language:before{content:"\f2a7"}.fa-sign-out-alt:before{content:"\f2f5"}.fa-signal:before{content:"\f012"}.fa-signature:before{content:"\f5b7"}.fa-sim-card:before{content:"\f7c4"}.fa-simplybuilt:before{content:"\f215"}.fa-sistrix:before{content:"\f3ee"}.fa-sitemap:before{content:"\f0e8"}.fa-sith:before{content:"\f512"}.fa-skating:before{content:"\f7c5"}.fa-sketch:before{content:"\f7c6"}.fa-skiing:before{content:"\f7c9"}.fa-skiing-nordic:before{content:"\f7ca"}.fa-skull:before{content:"\f54c"}.fa-skull-crossbones:before{content:"\f714"}.fa-skyatlas:before{content:"\f216"}.fa-skype:before{content:"\f17e"}.fa-slack:before{content:"\f198"}.fa-slack-hash:before{content:"\f3ef"}.fa-slash:before{content:"\f715"}.fa-sleigh:before{content:"\f7cc"}.fa-sliders-h:before{content:"\f1de"}.fa-slideshare:before{content:"\f1e7"}.fa-smile:before{content:"\f118"}.fa-smile-beam:before{content:"\f5b8"}.fa-smile-wink:before{content:"\f4da"}.fa-smog:before{content:"\f75f"}.fa-smoking:before{content:"\f48d"}.fa-smoking-ban:before{content:"\f54d"}.fa-sms:before{content:"\f7cd"}.fa-snapchat:before{content:"\f2ab"}.fa-snapchat-ghost:before{content:"\f2ac"}.fa-snapchat-square:before{content:"\f2ad"}.fa-snowboarding:before{content:"\f7ce"}.fa-snowflake:before{content:"\f2dc"}.fa-snowman:before{content:"\f7d0"}.fa-snowplow:before{content:"\f7d2"}.fa-socks:before{content:"\f696"}.fa-solar-panel:before{content:"\f5ba"}.fa-sort:before{content:"\f0dc"}.fa-sort-alpha-down:before{content:"\f15d"}.fa-sort-alpha-down-alt:before{content:"\f881"}.fa-sort-alpha-up:before{content:"\f15e"}.fa-sort-alpha-up-alt:before{content:"\f882"}.fa-sort-amount-down:before{content:"\f160"}.fa-sort-amount-down-alt:before{content:"\f884"}.fa-sort-amount-up:before{content:"\f161"}.fa-sort-amount-up-alt:before{content:"\f885"}.fa-sort-down:before{content:"\f0dd"}.fa-sort-numeric-down:before{content:"\f162"}.fa-sort-numeric-down-alt:before{content:"\f886"}.fa-sort-numeric-up:before{content:"\f163"}.fa-sort-numeric-up-alt:before{content:"\f887"}.fa-sort-up:before{content:"\f0de"}.fa-soundcloud:before{content:"\f1be"}.fa-sourcetree:before{content:"\f7d3"}.fa-spa:before{content:"\f5bb"}.fa-space-shuttle:before{content:"\f197"}.fa-speakap:before{content:"\f3f3"}.fa-speaker-deck:before{content:"\f83c"}.fa-spell-check:before{content:"\f891"}.fa-spider:before{content:"\f717"}.fa-spinner:before{content:"\f110"}.fa-splotch:before{content:"\f5bc"}.fa-spotify:before{content:"\f1bc"}.fa-spray-can:before{content:"\f5bd"}.fa-square:before{content:"\f0c8"}.fa-square-full:before{content:"\f45c"}.fa-square-root-alt:before{content:"\f698"}.fa-squarespace:before{content:"\f5be"}.fa-stack-exchange:before{content:"\f18d"}.fa-stack-overflow:before{content:"\f16c"}.fa-stackpath:before{content:"\f842"}.fa-stamp:before{content:"\f5bf"}.fa-star:before{content:"\f005"}.fa-star-and-crescent:before{content:"\f699"}.fa-star-half:before{content:"\f089"}.fa-star-half-alt:before{content:"\f5c0"}.fa-star-of-david:before{content:"\f69a"}.fa-star-of-life:before{content:"\f621"}.fa-staylinked:before{content:"\f3f5"}.fa-steam:before{content:"\f1b6"}.fa-steam-square:before{content:"\f1b7"}.fa-steam-symbol:before{content:"\f3f6"}.fa-step-backward:before{content:"\f048"}.fa-step-forward:before{content:"\f051"}.fa-stethoscope:before{content:"\f0f1"}.fa-sticker-mule:before{content:"\f3f7"}.fa-sticky-note:before{content:"\f249"}.fa-stop:before{content:"\f04d"}.fa-stop-circle:before{content:"\f28d"}.fa-stopwatch:before{content:"\f2f2"}.fa-store:before{content:"\f54e"}.fa-store-alt:before{content:"\f54f"}.fa-strava:before{content:"\f428"}.fa-stream:before{content:"\f550"}.fa-street-view:before{content:"\f21d"}.fa-strikethrough:before{content:"\f0cc"}.fa-stripe:before{content:"\f429"}.fa-stripe-s:before{content:"\f42a"}.fa-stroopwafel:before{content:"\f551"}.fa-studiovinari:before{content:"\f3f8"}.fa-stumbleupon:before{content:"\f1a4"}.fa-stumbleupon-circle:before{content:"\f1a3"}.fa-subscript:before{content:"\f12c"}.fa-subway:before{content:"\f239"}.fa-suitcase:before{content:"\f0f2"}.fa-suitcase-rolling:before{content:"\f5c1"}.fa-sun:before{content:"\f185"}.fa-superpowers:before{content:"\f2dd"}.fa-superscript:before{content:"\f12b"}.fa-supple:before{content:"\f3f9"}.fa-surprise:before{content:"\f5c2"}.fa-suse:before{content:"\f7d6"}.fa-swatchbook:before{content:"\f5c3"}.fa-swift:before{content:"\f8e1"}.fa-swimmer:before{content:"\f5c4"}.fa-swimming-pool:before{content:"\f5c5"}.fa-symfony:before{content:"\f83d"}.fa-synagogue:before{content:"\f69b"}.fa-sync:before{content:"\f021"}.fa-sync-alt:before{content:"\f2f1"}.fa-syringe:before{content:"\f48e"}.fa-table:before{content:"\f0ce"}.fa-table-tennis:before{content:"\f45d"}.fa-tablet:before{content:"\f10a"}.fa-tablet-alt:before{content:"\f3fa"}.fa-tablets:before{content:"\f490"}.fa-tachometer-alt:before{content:"\f3fd"}.fa-tag:before{content:"\f02b"}.fa-tags:before{content:"\f02c"}.fa-tape:before{content:"\f4db"}.fa-tasks:before{content:"\f0ae"}.fa-taxi:before{content:"\f1ba"}.fa-teamspeak:before{content:"\f4f9"}.fa-teeth:before{content:"\f62e"}.fa-teeth-open:before{content:"\f62f"}.fa-telegram:before{content:"\f2c6"}.fa-telegram-plane:before{content:"\f3fe"}.fa-temperature-high:before{content:"\f769"}.fa-temperature-low:before{content:"\f76b"}.fa-tencent-weibo:before{content:"\f1d5"}.fa-tenge:before{content:"\f7d7"}.fa-terminal:before{content:"\f120"}.fa-text-height:before{content:"\f034"}.fa-text-width:before{content:"\f035"}.fa-th:before{content:"\f00a"}.fa-th-large:before{content:"\f009"}.fa-th-list:before{content:"\f00b"}.fa-the-red-yeti:before{content:"\f69d"}.fa-theater-masks:before{content:"\f630"}.fa-themeco:before{content:"\f5c6"}.fa-themeisle:before{content:"\f2b2"}.fa-thermometer:before{content:"\f491"}.fa-thermometer-empty:before{content:"\f2cb"}.fa-thermometer-full:before{content:"\f2c7"}.fa-thermometer-half:before{content:"\f2c9"}.fa-thermometer-quarter:before{content:"\f2ca"}.fa-thermometer-three-quarters:before{content:"\f2c8"}.fa-think-peaks:before{content:"\f731"}.fa-thumbs-down:before{content:"\f165"}.fa-thumbs-up:before{content:"\f164"}.fa-thumbtack:before{content:"\f08d"}.fa-ticket-alt:before{content:"\f3ff"}.fa-times:before{content:"\f00d"}.fa-times-circle:before{content:"\f057"}.fa-tint:before{content:"\f043"}.fa-tint-slash:before{content:"\f5c7"}.fa-tired:before{content:"\f5c8"}.fa-toggle-off:before{content:"\f204"}.fa-toggle-on:before{content:"\f205"}.fa-toilet:before{content:"\f7d8"}.fa-toilet-paper:before{content:"\f71e"}.fa-toolbox:before{content:"\f552"}.fa-tools:before{content:"\f7d9"}.fa-tooth:before{content:"\f5c9"}.fa-torah:before{content:"\f6a0"}.fa-torii-gate:before{content:"\f6a1"}.fa-tractor:before{content:"\f722"}.fa-trade-federation:before{content:"\f513"}.fa-trademark:before{content:"\f25c"}.fa-traffic-light:before{content:"\f637"}.fa-trailer:before{content:"\f941"}.fa-train:before{content:"\f238"}.fa-tram:before{content:"\f7da"}.fa-transgender:before{content:"\f224"}.fa-transgender-alt:before{content:"\f225"}.fa-trash:before{content:"\f1f8"}.fa-trash-alt:before{content:"\f2ed"}.fa-trash-restore:before{content:"\f829"}.fa-trash-restore-alt:before{content:"\f82a"}.fa-tree:before{content:"\f1bb"}.fa-trello:before{content:"\f181"}.fa-tripadvisor:before{content:"\f262"}.fa-trophy:before{content:"\f091"}.fa-truck:before{content:"\f0d1"}.fa-truck-loading:before{content:"\f4de"}.fa-truck-monster:before{content:"\f63b"}.fa-truck-moving:before{content:"\f4df"}.fa-truck-pickup:before{content:"\f63c"}.fa-tshirt:before{content:"\f553"}.fa-tty:before{content:"\f1e4"}.fa-tumblr:before{content:"\f173"}.fa-tumblr-square:before{content:"\f174"}.fa-tv:before{content:"\f26c"}.fa-twitch:before{content:"\f1e8"}.fa-twitter:before{content:"\f099"}.fa-twitter-square:before{content:"\f081"}.fa-typo3:before{content:"\f42b"}.fa-uber:before{content:"\f402"}.fa-ubuntu:before{content:"\f7df"}.fa-uikit:before{content:"\f403"}.fa-umbraco:before{content:"\f8e8"}.fa-umbrella:before{content:"\f0e9"}.fa-umbrella-beach:before{content:"\f5ca"}.fa-underline:before{content:"\f0cd"}.fa-undo:before{content:"\f0e2"}.fa-undo-alt:before{content:"\f2ea"}.fa-uniregistry:before{content:"\f404"}.fa-unity:before{content:"\f949"}.fa-universal-access:before{content:"\f29a"}.fa-university:before{content:"\f19c"}.fa-unlink:before{content:"\f127"}.fa-unlock:before{content:"\f09c"}.fa-unlock-alt:before{content:"\f13e"}.fa-untappd:before{content:"\f405"}.fa-upload:before{content:"\f093"}.fa-ups:before{content:"\f7e0"}.fa-usb:before{content:"\f287"}.fa-user:before{content:"\f007"}.fa-user-alt:before{content:"\f406"}.fa-user-alt-slash:before{content:"\f4fa"}.fa-user-astronaut:before{content:"\f4fb"}.fa-user-check:before{content:"\f4fc"}.fa-user-circle:before{content:"\f2bd"}.fa-user-clock:before{content:"\f4fd"}.fa-user-cog:before{content:"\f4fe"}.fa-user-edit:before{content:"\f4ff"}.fa-user-friends:before{content:"\f500"}.fa-user-graduate:before{content:"\f501"}.fa-user-injured:before{content:"\f728"}.fa-user-lock:before{content:"\f502"}.fa-user-md:before{content:"\f0f0"}.fa-user-minus:before{content:"\f503"}.fa-user-ninja:before{content:"\f504"}.fa-user-nurse:before{content:"\f82f"}.fa-user-plus:before{content:"\f234"}.fa-user-secret:before{content:"\f21b"}.fa-user-shield:before{content:"\f505"}.fa-user-slash:before{content:"\f506"}.fa-user-tag:before{content:"\f507"}.fa-user-tie:before{content:"\f508"}.fa-user-times:before{content:"\f235"}.fa-users:before{content:"\f0c0"}.fa-users-cog:before{content:"\f509"}.fa-usps:before{content:"\f7e1"}.fa-ussunnah:before{content:"\f407"}.fa-utensil-spoon:before{content:"\f2e5"}.fa-utensils:before{content:"\f2e7"}.fa-vaadin:before{content:"\f408"}.fa-vector-square:before{content:"\f5cb"}.fa-venus:before{content:"\f221"}.fa-venus-double:before{content:"\f226"}.fa-venus-mars:before{content:"\f228"}.fa-viacoin:before{content:"\f237"}.fa-viadeo:before{content:"\f2a9"}.fa-viadeo-square:before{content:"\f2aa"}.fa-vial:before{content:"\f492"}.fa-vials:before{content:"\f493"}.fa-viber:before{content:"\f409"}.fa-video:before{content:"\f03d"}.fa-video-slash:before{content:"\f4e2"}.fa-vihara:before{content:"\f6a7"}.fa-vimeo:before{content:"\f40a"}.fa-vimeo-square:before{content:"\f194"}.fa-vimeo-v:before{content:"\f27d"}.fa-vine:before{content:"\f1ca"}.fa-vk:before{content:"\f189"}.fa-vnv:before{content:"\f40b"}.fa-voicemail:before{content:"\f897"}.fa-volleyball-ball:before{content:"\f45f"}.fa-volume-down:before{content:"\f027"}.fa-volume-mute:before{content:"\f6a9"}.fa-volume-off:before{content:"\f026"}.fa-volume-up:before{content:"\f028"}.fa-vote-yea:before{content:"\f772"}.fa-vr-cardboard:before{content:"\f729"}.fa-vuejs:before{content:"\f41f"}.fa-walking:before{content:"\f554"}.fa-wallet:before{content:"\f555"}.fa-warehouse:before{content:"\f494"}.fa-water:before{content:"\f773"}.fa-wave-square:before{content:"\f83e"}.fa-waze:before{content:"\f83f"}.fa-weebly:before{content:"\f5cc"}.fa-weibo:before{content:"\f18a"}.fa-weight:before{content:"\f496"}.fa-weight-hanging:before{content:"\f5cd"}.fa-weixin:before{content:"\f1d7"}.fa-whatsapp:before{content:"\f232"}.fa-whatsapp-square:before{content:"\f40c"}.fa-wheelchair:before{content:"\f193"}.fa-whmcs:before{content:"\f40d"}.fa-wifi:before{content:"\f1eb"}.fa-wikipedia-w:before{content:"\f266"}.fa-wind:before{content:"\f72e"}.fa-window-close:before{content:"\f410"}.fa-window-maximize:before{content:"\f2d0"}.fa-window-minimize:before{content:"\f2d1"}.fa-window-restore:before{content:"\f2d2"}.fa-windows:before{content:"\f17a"}.fa-wine-bottle:before{content:"\f72f"}.fa-wine-glass:before{content:"\f4e3"}.fa-wine-glass-alt:before{content:"\f5ce"}.fa-wix:before{content:"\f5cf"}.fa-wizards-of-the-coast:before{content:"\f730"}.fa-wolf-pack-battalion:before{content:"\f514"}.fa-won-sign:before{content:"\f159"}.fa-wordpress:before{content:"\f19a"}.fa-wordpress-simple:before{content:"\f411"}.fa-wpbeginner:before{content:"\f297"}.fa-wpexplorer:before{content:"\f2de"}.fa-wpforms:before{content:"\f298"}.fa-wpressr:before{content:"\f3e4"}.fa-wrench:before{content:"\f0ad"}.fa-x-ray:before{content:"\f497"}.fa-xbox:before{content:"\f412"}.fa-xing:before{content:"\f168"}.fa-xing-square:before{content:"\f169"}.fa-y-combinator:before{content:"\f23b"}.fa-yahoo:before{content:"\f19e"}.fa-yammer:before{content:"\f840"}.fa-yandex:before{content:"\f413"}.fa-yandex-international:before{content:"\f414"}.fa-yarn:before{content:"\f7e3"}.fa-yelp:before{content:"\f1e9"}.fa-yen-sign:before{content:"\f157"}.fa-yin-yang:before{content:"\f6ad"}.fa-yoast:before{content:"\f2b1"}.fa-youtube:before{content:"\f167"}.fa-youtube-square:before{content:"\f431"}.fa-zhihu:before{content:"\f63f"}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}@font-face{font-family:"Font Awesome 5 Brands";font-style:normal;font-weight:normal;font-display:auto;src:url(../webfonts/fa-brands-400.eot);src:url(../webfonts/fa-brands-400.eot?#iefix) format("embedded-opentype"),url(../webfonts/fa-brands-400.woff2) format("woff2"),url(../webfonts/fa-brands-400.woff) format("woff"),url(../webfonts/fa-brands-400.ttf) format("truetype"),url(../webfonts/fa-brands-400.svg#fontawesome) format("svg")}.fab{font-family:"Font Awesome 5 Brands"}@font-face{font-family:"Font Awesome 5 Free";font-style:normal;font-weight:400;font-display:auto;src:url(../webfonts/fa-regular-400.eot);src:url(../webfonts/fa-regular-400.eot?#iefix) format("embedded-opentype"),url(../webfonts/fa-regular-400.woff2) format("woff2"),url(../webfonts/fa-regular-400.woff) format("woff"),url(../webfonts/fa-regular-400.ttf) format("truetype"),url(../webfonts/fa-regular-400.svg#fontawesome) format("svg")}.far{font-weight:400}@font-face{font-family:"Font Awesome 5 Free";font-style:normal;font-weight:900;font-display:auto;src:url(../webfonts/fa-solid-900.eot);src:url(../webfonts/fa-solid-900.eot?#iefix) format("embedded-opentype"),url(../webfonts/fa-solid-900.woff2) format("woff2"),url(../webfonts/fa-solid-900.woff) format("woff"),url(../webfonts/fa-solid-900.ttf) format("truetype"),url(../webfonts/fa-solid-900.svg#fontawesome) format("svg")}.fa,.far,.fas{font-family:"Font Awesome 5 Free"}.fa,.fas{font-weight:900}
'''
'''--- Filecoin/powergate/gateway/public/css/style.css ---
html {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    height: 100%;
}

*, *:before, *:after {
    box-sizing: inherit;
}

body {
    margin: 0;
    padding: 2em;
    font-family: monospace, sans-serif;
    color: #666666;
    background-color: #222222;
    height: 100%;
}

.logo {
    position: absolute;
}

.title {
    margin-bottom: 0.5em;
    color: white;
    font-weight: bold;
}

.subtitle {
    font-size: 0.8em;
    margin-bottom: 0.5em;
}

.navbar {
    list-style: none;
    text-align: center;
    margin-bottom: 2em;
    margin-top: 2em;
    font-size: 0.8em;
    text-transform: uppercase;
}

.navbar li {
    display: inline;
}

.navbar a{
    display: inline-block;
    padding: 10px;
}

.navbar a.selected {
    color: white;
    font-weight: bold;
}

a {
    text-decoration: none;
    color: #666666;
}

a:hover {
    text-decoration: underline;
}

table {
    border-collapse: collapse;
    width: 100%;
    margin-bottom: 1em;
}

td, th {
    border: 1px solid #666666;
    padding: 8px;
}

tr:nth-child(odd){background-color: #252525;}

tr:hover {background-color: rgb(49, 49, 49);}

th {
    padding-top: 12px;
    padding-bottom: 12px;
    text-align: left;
    background-color: rgb(15, 15, 15);
    color: white;
    font-size: 0.8em;
    text-transform: uppercase;
}

.aligner {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 100%;
}

.aligner-item {
    max-width: 60%;
}

.aligner-item p {
    text-align: center;
    line-height: 1.5em;
}

.icon-big {
    font-size: 4em;
}

'''
'''--- Filecoin/powergate/gateway/public/img/hex.svg ---
<?xml version="1.0" encoding="UTF-8"?>
<svg width="1200px" height="1400px" viewBox="0 0 1200 1400" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch -->
    <title>Artboard</title>
    <desc>Created with Sketch.</desc>
    <defs>
        <polygon id="path-1" points="650 0 1212.91651 325 1212.91651 975 650 1300 87.0834875 975 87.0834875 325"></polygon>
    </defs>
    <g id="Artboard" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group" transform="translate(-100.000000, 0.000000)">
            <polygon id="Polygon" fill="#FFCE00" points="700 0 1306.21778 350 1306.21778 1050 700 1400 93.7822174 1050 93.7822174 350"></polygon>
            <g id="Textile_Icon_A_1200px-copy" transform="translate(50.000000, 50.000000)">
                <mask id="mask-2" fill="white">
                    <use xlink:href="#path-1"></use>
                </mask>
                <use id="Mask" fill="#FFB6D5" xlink:href="#path-1"></use>
                <image mask="url(#mask-2)" x="25" y="25" width="1250" height="1250" xlink:href="data:image/png;base64,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"></image>
            </g>
        </g>
    </g>
</svg>
'''
'''--- Filecoin/powergate/index/ask/internal/store/store.go ---
package store

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/textileio/powergate/v2/index/ask"
)

var (
	dsKey = datastore.NewKey("index")
)

// Store persists ask index into a datastore.
type Store struct {
	ds datastore.Datastore
}

// New returns a new store for ask index.
func New(ds datastore.Datastore) *Store {
	return &Store{
		ds: ds,
	}
}

// Save persist the index into the datastore.
func (s *Store) Save(idx ask.Index) error {
	buf, err := json.Marshal(idx)
	if err != nil {
		return fmt.Errorf("marshaling new index: %s", err)
	}
	if err = s.ds.Put(dsKey, buf); err != nil {
		return fmt.Errorf("saving to datastore: %s", err)
	}
	return nil
}

// Get returns the last saved ask index. If no ask index was persisted,
// it returns an valid empty index.
func (s *Store) Get() (ask.Index, error) {
	buf, err := s.ds.Get(dsKey)
	if err != nil {
		if err == datastore.ErrNotFound {
			return ask.Index{Storage: make(map[string]ask.StorageAsk)}, nil
		}
		return ask.Index{}, err
	}
	idx := ask.Index{}
	if err = json.Unmarshal(buf, &idx); err != nil {
		return ask.Index{}, err
	}
	return idx, nil
}

'''
'''--- Filecoin/powergate/index/ask/runner/metrics.go ---
package runner

import (
	"context"

	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
	"go.opentelemetry.io/otel/unit"
)

// Init register all views.
func (ai *Runner) initMetrics() {
	meter := global.Meter("powergate")

	_ = metric.Must(meter).NewFloat64ValueObserver("powergate.index.ask.progress", ai.progressValueObserver, metric.WithDescription("Ask index refresh progress"), metric.WithUnit(unit.Dimensionless))
	ai.refreshDuration = metric.Must(meter).NewInt64ValueRecorder("powergate.index.ask.refresh.duration", metric.WithDescription("Refresh duration"), metric.WithUnit(unit.Milliseconds))
}

func (ai *Runner) progressValueObserver(ctx context.Context, result metric.Float64ObserverResult) {
	ai.metricLock.Lock()
	defer ai.metricLock.Unlock()

	result.Observe(ai.progress)
}

'''
'''--- Filecoin/powergate/index/ask/runner/runner.go ---
package runner

import (
	"context"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/index/ask"
	"github.com/textileio/powergate/v2/index/ask/internal/store"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/signaler"
	"go.opentelemetry.io/otel/metric"
)

var (
	log = logging.Logger("index-ask")
)

// Runner contains cached information about markets.
type Runner struct {
	clientBuilder lotus.ClientBuilder
	store         *store.Store
	signaler      *signaler.Signaler
	config        Config

	lock        sync.Mutex
	index       ask.Index
	orderedAsks []*ask.StorageAsk

	ctx      context.Context
	cancel   context.CancelFunc
	finished chan struct{}
	clsLock  sync.Mutex
	closed   bool

	// Metrics
	refreshDuration metric.Int64ValueRecorder
	metricLock      sync.Mutex
	progress        float64
}

// Config contains parameters for index updating.
type Config struct {
	Disable         bool
	QueryAskTimeout time.Duration
	MaxParallel     int
	RefreshInterval time.Duration
	RefreshOnStart  bool
}

// New returns a new ask index runner. It load a persisted ask index, and immediately starts building a new fresh one.
func New(ds datastore.TxnDatastore, clientBuilder lotus.ClientBuilder, config Config) (*Runner, error) {
	store := store.New(ds)
	idx, err := store.Get()
	if err != nil {
		return nil, fmt.Errorf("loading from store: %s", err)
	}
	log.Infof("loaded persisted index with %d entries", len(idx.Storage))
	ctx, cancel := context.WithCancel(context.Background())
	ai := &Runner{
		signaler:      signaler.New(),
		clientBuilder: clientBuilder,
		store:         store,
		config:        config,

		index:       idx,
		orderedAsks: generateOrderedAsks(idx.Storage),

		ctx:      ctx,
		cancel:   cancel,
		finished: make(chan struct{}),
	}
	ai.initMetrics()

	go ai.start(config.RefreshOnStart, config.Disable)

	return ai, nil
}

// Get returns a copy of the current index data.
func (ai *Runner) Get() ask.Index {
	ai.lock.Lock()
	defer ai.lock.Unlock()
	index := ask.Index{
		LastUpdated:        ai.index.LastUpdated,
		StorageMedianPrice: ai.index.StorageMedianPrice,
		Storage:            make(map[string]ask.StorageAsk, len(ai.index.Storage)),
	}
	for addr, v := range ai.index.Storage {
		index.Storage[addr] = v
	}
	return index
}

// Query executes a query to retrieve active Asks.
func (ai *Runner) Query(q ask.Query) ([]ask.StorageAsk, error) {
	ai.lock.Lock()
	defer ai.lock.Unlock()
	var res []ask.StorageAsk
	offset := q.Offset
	for _, sa := range ai.orderedAsks {
		if q.MaxPrice != 0 && sa.Price > q.MaxPrice {
			break
		}
		if q.PieceSize != 0 && sa.MinPieceSize > q.PieceSize {
			continue
		}
		if q.PieceSize != 0 && sa.MaxPieceSize < q.PieceSize {
			continue
		}
		if offset > 0 {
			offset--
			continue
		}
		res = append(res, *sa)
		if q.Limit != 0 && len(res) == q.Limit {
			break
		}
	}
	return res, nil
}

// Listen returns a new channel signaler that notifies when the index gets
// updated.
func (ai *Runner) Listen() <-chan struct{} {
	return ai.signaler.Listen()
}

// Unregister unregisters a channel signaler from the signaler hub.
func (ai *Runner) Unregister(c chan struct{}) {
	ai.signaler.Unregister(c)
}

// Close closes the AskIndex.
func (ai *Runner) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	ai.clsLock.Lock()
	defer ai.clsLock.Unlock()
	if ai.closed {
		return nil
	}
	ai.cancel()
	<-ai.finished
	ai.signaler.Close()
	ai.closed = true
	return nil
}

// start is a long running job that updates asks information in the market.
func (ai *Runner) start(refreshOnStart bool, disable bool) {
	defer close(ai.finished)
	if refreshOnStart {
		if err := ai.update(); err != nil {
			log.Errorf("updating miners asks: %s", err)
		}
	}
	for {
		select {
		case <-ai.ctx.Done():
			log.Info("graceful shutdown of ask index background job")
			return
		case <-time.After(ai.config.RefreshInterval):
			if disable {
				log.Infof("skipping update since disabled")
				continue
			}
			if err := ai.update(); err != nil {
				log.Errorf("updating miners asks: %s", err)
			}
		}
	}
}

// update triggers a full-scan generates and saves a new fresh index and builds
// views for better querying.
func (ai *Runner) update() error {
	start := time.Now()
	log.Info("updating ask index...")
	defer log.Info("ask index updated")

	client, cls, err := ai.clientBuilder(context.Background())
	if err != nil {
		return fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	newIndex, cache, err := ai.generateIndex(ai.ctx, client)
	if err != nil {
		return fmt.Errorf("generating index: %s", err)
	}
	if len(cache) == 0 {
		log.Warnf("ignoring asks save since size is 0")
		return nil
	}

	ai.lock.Lock()
	ai.index = newIndex
	ai.orderedAsks = cache
	ai.lock.Unlock()

	if err := ai.store.Save(newIndex); err != nil {
		return fmt.Errorf("persisting ask index: %s", err)
	}
	ai.signaler.Signal()

	ai.refreshDuration.Record(context.Background(), time.Since(start).Milliseconds())

	return nil
}

// generateIndex returns a fresh index.
func (ai *Runner) generateIndex(ctx context.Context, api *api.FullNodeStruct) (ask.Index, []*ask.StorageAsk, error) {
	addrs, err := api.StateListMiners(ctx, types.EmptyTSK)
	if err != nil {
		return ask.Index{}, nil, err
	}

	rateLim := make(chan struct{}, ai.config.MaxParallel)
	var lock sync.Mutex
	newAsks := make(map[string]ask.StorageAsk)
	for i, addr := range addrs {
		if ctx.Err() != nil {
			break
		}
		rateLim <- struct{}{}
		go func(addr address.Address) {
			defer func() { <-rateLim }()
			sask, ok, err := getMinerStorageAsk(ctx, api, addr, ai.config.QueryAskTimeout)
			if err != nil {
				log.Errorf("getting miner storage ask: %s", err)
				return
			}
			if !ok {
				return
			}
			lock.Lock()
			newAsks[addr.String()] = sask
			lock.Unlock()
		}(addr)
		if i%5000 == 0 {
			log.Infof("progress %d/%d", i, len(addrs))
		}
		ai.metricLock.Lock()
		ai.progress = float64(i) / float64(len(addrs))
		ai.metricLock.Unlock()
	}
	for i := 0; i < ai.config.MaxParallel; i++ {
		rateLim <- struct{}{}
	}
	ai.metricLock.Lock()
	ai.progress = 1
	ai.metricLock.Unlock()

	if ctx.Err() != nil {
		return ask.Index{}, nil, fmt.Errorf("refresh was canceled")
	}

	cache := generateOrderedAsks(newAsks)
	return ask.Index{
		LastUpdated:        time.Now(),
		StorageMedianPrice: calculateMedian(cache),
		Storage:            newAsks,
	}, cache, nil
}

// getMinerStorage ask returns the result of querying the miner for its current Storage Ask.
// If the miner has zero power, it won't be queried returning false.
func getMinerStorageAsk(ctx context.Context, api *api.FullNodeStruct, addr address.Address, askTimeout time.Duration) (ask.StorageAsk, bool, error) {
	ctx, cancel := context.WithTimeout(ctx, askTimeout)
	defer cancel()
	power, err := api.StateMinerPower(ctx, addr, types.EmptyTSK)
	if err != nil {
		return ask.StorageAsk{}, false, fmt.Errorf("getting power %s: %s", addr, err)
	}
	if power.MinerPower.RawBytePower.IsZero() {
		return ask.StorageAsk{}, false, nil
	}
	mi, err := api.StateMinerInfo(ctx, addr, types.EmptyTSK)
	if err != nil {
		return ask.StorageAsk{}, false, fmt.Errorf("getting miner %s info: %s", addr, err)
	}

	if mi.PeerId == nil {
		return ask.StorageAsk{}, false, nil
	}

	sask, err := api.ClientQueryAsk(ctx, *mi.PeerId, addr)
	if err != nil {
		return ask.StorageAsk{}, false, nil
	}
	return ask.StorageAsk{
		Miner:         sask.Miner.String(),
		Price:         sask.Price.Uint64(),
		VerifiedPrice: sask.VerifiedPrice.Uint64(),
		MinPieceSize:  uint64(sask.MinPieceSize),
		MaxPieceSize:  uint64(sask.MaxPieceSize),
		Timestamp:     int64(sask.Timestamp),
		Expiry:        int64(sask.Expiry),
	}, true, nil
}

func calculateMedian(orderedAsks []*ask.StorageAsk) uint64 {
	if len(orderedAsks) == 0 {
		return 0
	}
	len := len(orderedAsks)
	if len < 2 {
		return orderedAsks[0].Price
	}
	if len%2 == 1 {
		return orderedAsks[len/2].Price
	}
	return (orderedAsks[len/2-1].Price + orderedAsks[len/2].Price) / 2
}

func generateOrderedAsks(asks map[string]ask.StorageAsk) []*ask.StorageAsk {
	cache := make([]*ask.StorageAsk, 0, len(asks))
	for _, v := range asks {
		cache = append(cache, &v)
	}
	sort.Slice(cache, func(i, j int) bool {
		return cache[i].Price < cache[j].Price
	})
	return cache
}

'''
'''--- Filecoin/powergate/index/ask/runner/runner_test.go ---
package runner

import (
	"context"
	"os"
	"reflect"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/index/ask"
	"github.com/textileio/powergate/v2/tests"
)

func TestMain(m *testing.M) {
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestFreshBuild(t *testing.T) {
	// Skipped since current interop devnet returns
	// "must resolve ID addresses before using them to verify a signature"
	// when querying Asks.
	t.SkipNow()
	ctx := context.Background()
	clientBuilder, _, miners := tests.CreateLocalDevnet(t, 1, 300)
	c, cls, err := clientBuilder(ctx)
	require.NoError(t, err)
	defer cls()

	ai := &Runner{
		config: Config{
			MaxParallel:     1,
			QueryAskTimeout: time.Second * 5,
		},
	}
	index, _, err := ai.generateIndex(ctx, c)
	require.NoError(t, err)

	// We should have storage info about every miner in devnet
	for _, m := range miners {
		info, ok := index.Storage[m.String()]
		if !ok {
			t.Fatalf("missing storage ask info for miner %s", m.String())
		}
		if info.Miner != m.String() || info.Price == 0 ||
			info.MinPieceSize == 0 || info.Expiry == 0 {
			t.Fatalf("invalid storage state for miner %s: %v", m.String(), info)
		}
	}
	if index.StorageMedianPrice == 0 {
		t.Fatalf("median storage price should be greater than zero")
	}
}

func TestQueryAsk(t *testing.T) {
	t.Parallel()
	dm := Runner{}
	dm.orderedAsks = []*ask.StorageAsk{
		{Price: uint64(20), MinPieceSize: 128, Miner: "t01"},
		{Price: uint64(30), MinPieceSize: 64, MaxPieceSize: 128, Miner: "t02"},
		{Price: uint64(40), MinPieceSize: 256, Miner: "t03"},
		{Price: uint64(50), MinPieceSize: 16, Miner: "t04"},
	}

	facr := []ask.StorageAsk{
		{Price: 20, MinPieceSize: 128, Miner: "t01"},
		{Price: 30, MinPieceSize: 64, MaxPieceSize: 128, Miner: "t02"},
		{Price: 40, MinPieceSize: 256, Miner: "t03"},
		{Price: 50, MinPieceSize: 16, Miner: "t04"},
	}

	tests := []struct {
		name   string
		q      ask.Query
		expect []ask.StorageAsk
	}{
		{name: "All", q: ask.Query{}, expect: facr},
		{name: "LeqPrice35", q: ask.Query{MaxPrice: 35}, expect: []ask.StorageAsk{facr[0], facr[1]}},
		{name: "LeqPrice50", q: ask.Query{MaxPrice: 50}, expect: facr},
		{name: "LeqPrice40Piece96", q: ask.Query{MaxPrice: 35, PieceSize: 96}, expect: []ask.StorageAsk{facr[1]}},
		{name: "AllLimit2Offset1", q: ask.Query{Limit: 2, Offset: 1}, expect: []ask.StorageAsk{facr[1], facr[2]}},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got, err := dm.Query(tt.q)
			if err != nil {
				t.Fatal(err)
			}
			if !reflect.DeepEqual(tt.expect, got) {
				t.Fatalf("expected %v, got %v", tt.expect, got)
			}
		})
	}
}

'''
'''--- Filecoin/powergate/index/ask/types.go ---
package ask

import (
	"time"
)

// Module provides information about storage asks.
type Module interface {
	Get() Index
	Query(q Query) ([]StorageAsk, error)
	Listen() <-chan struct{}
	Unregister(c chan struct{})
}

// Index contains Ask information from markets.
type Index struct {
	LastUpdated        time.Time
	StorageMedianPrice uint64
	Storage            map[string]StorageAsk
}

// StorageAsk has information about an active ask from a storage miner.
type StorageAsk struct {
	Miner         string
	Price         uint64
	VerifiedPrice uint64
	MinPieceSize  uint64
	MaxPieceSize  uint64
	Timestamp     int64
	Expiry        int64
}

// Query specifies filtering and paging data to retrieve active Asks.
type Query struct {
	MaxPrice  uint64
	PieceSize uint64
	Limit     int
	Offset    int
}

'''
'''--- Filecoin/powergate/index/faults/module/faults.go ---
package module

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/chainstore"
	"github.com/textileio/powergate/v2/chainsync"
	"github.com/textileio/powergate/v2/index/faults"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/signaler"
	txndstr "github.com/textileio/powergate/v2/txndstransform"
)

const (
	batchSize = 2000
)

var (
	// hOffset is the # of tipsets from the heaviest chain to
	// consider for index updating; this to reduce sensibility to
	// chain reorgs.
	hOffset = abi.ChainEpoch(20)

	// updateInterval is the interval duration where the fault index
	// will be updated.
	// Note: currently the Fault index is disabled until Lotus re-enables
	// StateAllMinersFaults() API.
	updateInterval = time.Hour * 24 * 365

	log = logging.Logger("index-faults")
)

// Index builds and provides faults history of miners.
type Index struct {
	clientBuilder lotus.ClientBuilder
	store         *chainstore.Store
	signaler      *signaler.Signaler

	lock  sync.Mutex
	index faults.IndexSnapshot

	ctx      context.Context
	cancel   context.CancelFunc
	finished chan struct{}
}

// New returns a new FaultIndex. It will load previous state from ds, and
// immediately start getting in sync with new on-chain.
func New(ds datastore.TxnDatastore, clientBuilder lotus.ClientBuilder, disable bool) (*Index, error) {
	cs := chainsync.New(clientBuilder)
	store, err := chainstore.New(txndstr.Wrap(ds, "chainstore"), cs)
	if err != nil {
		return nil, err
	}
	ctx, cancel := context.WithCancel(context.Background())
	s := &Index{
		clientBuilder: clientBuilder,
		store:         store,
		signaler:      signaler.New(),
		index: faults.IndexSnapshot{
			Miners: make(map[string]faults.Faults),
		},
		ctx:      ctx,
		cancel:   cancel,
		finished: make(chan struct{}),
	}
	if err := s.loadFromDS(); err != nil {
		return nil, err
	}

	go s.start(disable)

	return s, nil
}

// Get returns a copy of the current index information.
func (s *Index) Get() faults.IndexSnapshot {
	s.lock.Lock()
	defer s.lock.Unlock()
	ii := faults.IndexSnapshot{
		TipSetKey: s.index.TipSetKey,
		Miners:    make(map[string]faults.Faults, len(s.index.Miners)),
	}
	for addr, v := range s.index.Miners {
		history := make([]int64, len(v.Epochs))
		copy(history, v.Epochs)
		ii.Miners[addr] = faults.Faults{
			Epochs: history,
		}
	}
	return ii
}

// Listen returns a a signaler channel which signals that index information
// has been updated.
func (s *Index) Listen() <-chan struct{} {
	return s.signaler.Listen()
}

// Unregister frees a channel from the signaler hub.
func (s *Index) Unregister(c chan struct{}) {
	s.signaler.Unregister(c)
}

// Close closes the FaultIndex.
func (s *Index) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	s.cancel()
	<-s.finished
	return nil
}

// start is a long running job that keeps the index up to date with chain updates.
func (s *Index) start(disabled bool) {
	defer close(s.finished)
	for {
		select {
		case <-s.ctx.Done():
			log.Info("graceful shutdown of background faults updater")
			return
		case <-time.After(updateInterval):
			if disabled {
				log.Infof("skipping updating since it's disabled")
				continue
			}
			if err := s.updateIndex(); err != nil {
				log.Errorf("updating faults history: %s", err)
				continue
			}
		}
	}
}

// updateIndex updates current index.
func (s *Index) updateIndex() error {
	client, cls, err := s.clientBuilder(context.Background())
	if err != nil {
		return fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	log.Info("updating faults index...")

	chainHead, err := client.ChainHead(s.ctx)
	if err != nil {
		return fmt.Errorf("getting chain head: %s", err)
	}
	// If the chain is very young, wait a bit for start building the index.
	if chainHead.Height()-hOffset <= 0 {
		return nil
	}

	// Get the tipset hOffset before current head as the target tipset
	// to let the index be built.
	targetTs, err := client.ChainGetTipSetByHeight(s.ctx, chainHead.Height()-hOffset, chainHead.Key())
	if err != nil {
		return fmt.Errorf("getting offseted tipset from head: %s", err)
	}

	var index faults.IndexSnapshot
	// Load the last saved index snapshot which is a child of the target TipSet.
	// Might not be s.index because of reorgs.
	indexTs, err := s.store.LoadAndPrune(s.ctx, targetTs.Key(), &index)
	if err != nil {
		return fmt.Errorf("load tipset state: %s", err)
	}
	if index.Miners == nil {
		index.Miners = make(map[string]faults.Faults)
	}

	// Get the tipset path between the indexTs and the targetTs, so to
	// calculate the faults that happened between last saved index and target.
	_, path, err := chainsync.ResolveBase(s.ctx, client, indexTs, targetTs.Key())
	if err != nil {
		return fmt.Errorf("resolving base path: %s", err)
	}

	for i := 0; i < len(path); i += batchSize {
		j := i + batchSize
		if j > len(path) {
			j = len(path)
		}

		// Get section head and length, and get all faults happened
		// in this section and include it into the updating index.
		sectionLength := abi.ChainEpoch(j - i)
		sectionHeadTs := path[j-1].Key()
		fs, err := client.StateAllMinerFaults(s.ctx, sectionLength, sectionHeadTs)
		if err != nil {
			return fmt.Errorf("getting faults from path section: %s", err)
		}
		index.TipSetKey = sectionHeadTs.String()
		for _, f := range fs {
			currFaults := index.Miners[f.Miner.String()]
			currFaults.Epochs = append(currFaults.Epochs, int64(f.Epoch))
			index.Miners[f.Miner.String()] = currFaults
		}

		// Persist partial progress in each finished section-path.
		if err := s.store.Save(s.ctx, types.NewTipSetKey(path[j-1].Cids()...), index); err != nil {
			return fmt.Errorf("saving new index state: %s", err)
		}
		log.Infof("processed from %d to %d", path[i].Height(), path[j-1].Height())

		// Already make available this section-path proccessed information for external
		// use.
		s.lock.Lock()
		s.index = faults.IndexSnapshot{
			TipSetKey: index.TipSetKey,
			Miners:    make(map[string]faults.Faults, len(index.Miners)),
		}
		for k, v := range index.Miners {
			s.index.Miners[k] = v
		}
		s.lock.Unlock()

		// Signal external actors that updated index information is available.
		s.signaler.Signal()
	}

	log.Info("faults index updated")

	return nil
}

// loadFromDS loads persisted indexes to memory datastructures. No locks needed
// since its only called from New().
func (s *Index) loadFromDS() error {
	var index faults.IndexSnapshot
	if _, err := s.store.GetLastCheckpoint(&index); err != nil {
		return err
	}
	s.index = index
	return nil
}

'''
'''--- Filecoin/powergate/index/faults/module/faults_test.go ---
package module

import (
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 100
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestFreshIndex(t *testing.T) {
	// Skipped until #235 lands.
	t.SkipNow()
	client, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	time.Sleep(time.Millisecond * 500) // Allow the network to some tipsets

	sh, err := New(tests.NewTxMapDatastore(), client, false)
	require.NoError(t, err)

	// Wait for some rounds of faults updating
	for i := 0; i < 10; i++ {
		select {
		case <-time.After(time.Second):
			t.Fatal("timeout waiting for miner index full refresh")
		case <-sh.Listen():
		}
	}
	index := sh.Get()
	if index.TipSetKey == "" {
		t.Fatalf("miner info state is invalid: %s %d", index.TipSetKey, len(index.Miners))
	}
}

'''
'''--- Filecoin/powergate/index/faults/types.go ---
package faults

// IndexSnapshot contains faults histoy information up-to a TipSetKey.
type IndexSnapshot struct {
	TipSetKey string
	Miners    map[string]Faults
}

// Faults contains epochs where a fault was detected for a miner.
type Faults struct {
	Epochs []int64
}

// Module provides faults information about the Filecoin network.
type Module interface {
	Get() IndexSnapshot
	Listen() <-chan struct{}
	Unregister(c chan struct{})
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/meta.go ---
package lotusidx

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/multiformats/go-multiaddr"
	"github.com/textileio/powergate/v2/index/miner"
	"github.com/textileio/powergate/v2/iplocation"
	"github.com/textileio/powergate/v2/lotus"
)

var (
	metaRefreshInterval = time.Hour * 6
	metaRateLim         = 1
)

func (mi *Index) startMetaWorker() {
	mi.wg.Add(1)

	startRun := make(chan struct{}, 1)

	if mi.conf.RefreshOnStart {
		startRun <- struct{}{}
	}

	go func() {
		defer mi.wg.Done()

		for {
			select {
			case <-mi.ctx.Done():
				log.Info("graceful shutdown of meta updater")
				return
			case <-time.After(metaRefreshInterval):
				if err := mi.tickUpdateMetaIndex(); err != nil {
					log.Error(err)
				}
			case <-startRun:
				if err := mi.tickUpdateMetaIndex(); err != nil {
					log.Error(err)
				}
			}
		}
	}()
}

func (mi *Index) tickUpdateMetaIndex() error {
	start := time.Now()
	log.Info("updating meta index...")
	defer log.Info("meta index updated")

	mi.lock.Lock()
	addrs := make([]string, 0, len(mi.index.OnChain.Miners))
	for addr, miner := range mi.index.OnChain.Miners {
		if miner.Power > 0 {
			addrs = append(addrs, addr)
		}
	}
	mi.lock.Unlock()

	newIndex := mi.updateMetaIndex(mi.ctx, mi.cb, addrs)
	if err := mi.store.SaveMetadata(newIndex); err != nil {
		return fmt.Errorf("persisting meta index: %s", err)
	}

	mi.lock.Lock()
	mi.index.Meta = newIndex
	mi.lock.Unlock()

	mi.signaler.Signal()

	mi.meterRefreshDuration.Record(context.Background(), time.Since(start).Milliseconds(), metaSubindex)

	return nil
}

// updateMetaIndex generates a new index that contains fresh metadata information
// of addrs miners.
func (mi *Index) updateMetaIndex(ctx context.Context, clientBuilder lotus.ClientBuilder, addrs []string) miner.MetaIndex {
	client, cls, err := clientBuilder(ctx)
	if err != nil {
		log.Errorf("creating lotus client: %s", err)
		return miner.MetaIndex{}
	}
	defer cls()
	index := miner.MetaIndex{
		Info: make(map[string]miner.Meta),
	}
	rl := make(chan struct{}, metaRateLim)
	var lock sync.Mutex
	for i, a := range addrs {
		if ctx.Err() != nil {
			log.Infof("update meta index canceled")
			return miner.MetaIndex{}
		}
		rl <- struct{}{}
		go func(a string) {
			defer func() { <-rl }()
			si, err := getMeta(ctx, client, mi.h, mi.lr, a)
			if err != nil {
				log.Debugf("getting static info: %s", err)
				return
			}
			lock.Lock()
			index.Info[a] = merge(index.Info[a], si)
			lock.Unlock()
		}(a)
		mi.metricLock.Lock()
		mi.metaProgress = float64(i) / float64(len(addrs))
		mi.metricLock.Unlock()
	}
	for i := 0; i < metaRateLim; i++ {
		rl <- struct{}{}
	}
	mi.metricLock.Lock()
	mi.metaProgress = float64(1)
	mi.metricLock.Unlock()

	return index
}

func merge(old miner.Meta, upt miner.Meta) miner.Meta {
	if upt.Location.Country == "" {
		upt.Location.Country = old.Location.Country
	}

	if upt.Location.Latitude == 0 {
		upt.Location.Latitude = old.Location.Latitude
	}

	if upt.Location.Longitude == 0 {
		upt.Location.Longitude = old.Location.Longitude
	}

	return upt
}

// getMeta returns fresh metadata information about a miner.
func getMeta(ctx context.Context, c *api.FullNodeStruct, h P2PHost, lr iplocation.LocationResolver, straddr string) (miner.Meta, error) {
	si := miner.Meta{
		LastUpdated: time.Now(),
	}
	addr, err := address.NewFromString(straddr)
	if err != nil {
		return si, err
	}
	mi, err := c.StateMinerInfo(ctx, addr, types.EmptyTSK)
	if err != nil {
		return si, err
	}

	if mi.PeerId != nil {
		if av := h.GetAgentVersion(*mi.PeerId); av != "" {
			si.UserAgent = av
		}
	}

	if len(mi.Multiaddrs) == 0 {
		return si, nil
	}
	var maddrs []multiaddr.Multiaddr
	for _, ma := range mi.Multiaddrs {
		pma, err := multiaddr.NewMultiaddrBytes(ma)
		if err != nil {
			continue
		}
		maddrs = append(maddrs, pma)
	}
	if l, err := lr.Resolve(maddrs); err == nil {
		si.Location = miner.Location{
			Country:   l.Country,
			Latitude:  l.Latitude,
			Longitude: l.Longitude,
		}
	}
	return si, nil
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/metrics.go ---
package lotusidx

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
	"go.opentelemetry.io/otel/unit"
)

var (
	onchainSubindex = attribute.Key("subindex").String("onchain")
	metaSubindex    = attribute.Key("subindex").String("meta")
)

func (mi *Index) initMetrics() {
	meter := global.Meter("powergate")

	_ = metric.Must(meter).NewFloat64ValueObserver("powergate.index.miner.progress", mi.progressValueObserver, metric.WithDescription("Miner index refresh progress"), metric.WithUnit(unit.Dimensionless))
	mi.meterRefreshDuration = metric.Must(meter).NewInt64ValueRecorder("powergate.index.miner.refresh.duration", metric.WithDescription("Refresh duration"), metric.WithUnit(unit.Milliseconds))
}

func (mi *Index) progressValueObserver(ctx context.Context, result metric.Float64ObserverResult) {
	mi.metricLock.Lock()
	defer mi.metricLock.Unlock()
	result.Observe(mi.onchainProgress, onchainSubindex)
	result.Observe(mi.metaProgress, metaSubindex)
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/miner.go ---
package lotusidx

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ipfs/go-datastore"
	kt "github.com/ipfs/go-datastore/keytransform"
	logging "github.com/ipfs/go-log/v2"
	"github.com/libp2p/go-libp2p-core/peer"
	"github.com/multiformats/go-multiaddr"
	"github.com/textileio/powergate/v2/index/miner"
	"github.com/textileio/powergate/v2/index/miner/lotusidx/store"
	"github.com/textileio/powergate/v2/iplocation"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/signaler"
	"go.opentelemetry.io/otel/metric"
)

var (
	log = logging.Logger("index-miner")
)

// P2PHost provides a client to connect to a libp2p peer.
type P2PHost interface {
	Addrs(pid peer.ID) []multiaddr.Multiaddr
	Ping(ctx context.Context, pid peer.ID) bool
	GetAgentVersion(pid peer.ID) string
}

// Index builds and provides information about FC miners.
type Index struct {
	cb       lotus.ClientBuilder
	store    *store.Store
	h        P2PHost
	lr       iplocation.LocationResolver
	signaler *signaler.Signaler
	conf     Config

	lock  sync.Mutex
	index miner.IndexSnapshot

	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup
	closed bool

	// Meters
	metricLock           sync.RWMutex
	onchainProgress      float64
	metaProgress         float64
	meterRefreshDuration metric.Int64ValueRecorder
}

// Config provides configuration parametrs to the miner index.
type Config struct {
	RefreshOnStart     bool
	Disable            bool
	OnChainMaxParallel int
	OnChainFrequency   time.Duration
}

// New returns a new MinerIndex. It loads from ds any previous state and starts
// immediately making the index up to date.
func New(ds datastore.Datastore, clientBuilder lotus.ClientBuilder, h P2PHost, lr iplocation.LocationResolver, conf Config) (*Index, error) {
	store, err := store.New(kt.Wrap(ds, kt.PrefixTransform{Prefix: datastore.NewKey("store")}))
	if err != nil {
		return nil, fmt.Errorf("creating store: %s", err)
	}

	savedIndex, err := store.GetIndex()
	if err != nil {
		return nil, fmt.Errorf("loading saved index: %s", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	mi := &Index{
		cb:       clientBuilder,
		store:    store,
		signaler: signaler.New(),
		h:        h,
		lr:       lr,
		index:    savedIndex,
		conf:     conf,

		ctx:    ctx,
		cancel: cancel,
	}

	mi.initMetrics()

	if !conf.Disable {
		mi.startMinerWorker()
		mi.startMetaWorker()
	}
	return mi, nil
}

// Get returns a copy of the current index information.
func (mi *Index) Get() miner.IndexSnapshot {
	mi.lock.Lock()
	defer mi.lock.Unlock()
	ii := miner.IndexSnapshot{
		Meta: miner.MetaIndex{
			Info: make(map[string]miner.Meta, len(mi.index.Meta.Info)),
		},
		OnChain: miner.ChainIndex{
			LastUpdated: mi.index.OnChain.LastUpdated,
			Miners:      make(map[string]miner.OnChainMinerData, len(mi.index.OnChain.Miners)),
		},
	}
	for addr, v := range mi.index.Meta.Info {
		ii.Meta.Info[addr] = v
	}
	for addr, v := range mi.index.OnChain.Miners {
		ii.OnChain.Miners[addr] = v
	}
	return ii
}

// Listen returns a channel signaler to notify when new index information is
// available.
func (mi *Index) Listen() <-chan struct{} {
	return mi.signaler.Listen()
}

// Unregister unregisters a channel signaler from the signaler hub.
func (mi *Index) Unregister(c chan struct{}) {
	mi.signaler.Unregister(c)
}

// Close closes a MinerIndex.
func (mi *Index) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	mi.lock.Lock()
	defer mi.lock.Unlock()
	if mi.closed {
		return nil
	}
	mi.cancel()
	mi.wg.Wait()
	mi.signaler.Close()

	mi.closed = true
	return nil
}

func (mi *Index) startMinerWorker() {
	mi.wg.Add(1)
	go func() {
		defer mi.wg.Done()

		startRun := make(chan struct{}, 1)
		if mi.conf.RefreshOnStart {
			startRun <- struct{}{}
		}

		for {
			select {
			case <-mi.ctx.Done():
				log.Info("graceful shutdown of background miner index")
				return
			case <-time.After(mi.conf.OnChainFrequency):
				if err := mi.updateOnChainIndex(mi.ctx); err != nil {
					log.Errorf("updating miner index: %s", err)
				}
			case <-startRun:
				if err := mi.updateOnChainIndex(mi.ctx); err != nil {
					log.Errorf("updating miner index on first-run: %s", err)
				}
			}
		}
	}()
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/miner_test.go ---
package lotusidx

import (
	"context"
	"os"
	"testing"
	"time"

	logging "github.com/ipfs/go-log/v2"
	"github.com/libp2p/go-libp2p-core/peer"
	"github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/iplocation"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestMain(m *testing.M) {
	util.AvgBlockTime = time.Millisecond * 10
	metaRefreshInterval = time.Millisecond * 10
	logging.SetAllLoggers(logging.LevelInfo)
	//logging.SetLogLevel("index-miner", "debug")
	os.Exit(m.Run())
}

func TestFullRefresh(t *testing.T) {
	client, _, miners := tests.CreateLocalDevnet(t, 1, 300)
	time.Sleep(time.Second * 15) // Allow the network to some tipsets

	cfg := Config{
		RefreshOnStart:     true,
		Disable:            false,
		OnChainFrequency:   time.Minute,
		OnChainMaxParallel: 1,
	}
	mi, err := New(tests.NewTxMapDatastore(), client, &p2pHostMock{}, &lrMock{}, cfg)
	require.NoError(t, err)

	l := mi.Listen()
	// Wait for some rounds of on-chain and meta updates
	for i := 0; i < 10; i++ {
		select {
		case <-time.After(time.Second * 30):
			t.Fatal("timeout waiting for miner index full refresh")
		case <-l:
		}
	}

	index := mi.Get()
	require.Greater(t, index.OnChain.LastUpdated, int64(0))
	require.Equal(t, len(miners), len(index.OnChain.Miners))
	for _, m := range miners {
		chainInfo, ok := index.OnChain.Miners[m.String()]
		require.True(t, ok)
		require.False(t, chainInfo.Power == 0 || chainInfo.RelativePower == 0)

		metaInfo, ok := index.Meta.Info[m.String()]
		require.True(t, ok)

		emptyTime := time.Time{}
		require.False(t, metaInfo.LastUpdated == emptyTime || metaInfo.UserAgent == "")
	}
}

func TestIntegration(t *testing.T) {
	t.SkipNow()
	metaRefreshInterval = time.Hour

	lotusHost, err := multiaddr.NewMultiaddr("/ip4/127.0.0.1/tcp/5555")
	require.NoError(t, err)
	lotusToken := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBbGxvdyI6WyJyZWFkIiwid3JpdGUiLCJzaWduIiwiYWRtaW4iXX0.4KpuySIvV4n6kBEXQOle-hi1Ec3lyUmRYCknz4NQyLM"

	cb, err := lotus.NewBuilder(lotusHost, lotusToken, 1)
	require.NoError(t, err)

	cfg := Config{
		RefreshOnStart:     true,
		Disable:            false,
		OnChainFrequency:   time.Minute,
		OnChainMaxParallel: 1,
	}
	mi, err := New(tests.NewTxMapDatastore(), cb, &p2pHostMock{}, &lrMock{}, cfg)
	require.NoError(t, err)

	<-time.After(time.Second * 15)
	_ = mi.Close()
}

var _ P2PHost = (*p2pHostMock)(nil)

type p2pHostMock struct{}

func (hm *p2pHostMock) Addrs(id peer.ID) []multiaddr.Multiaddr {
	return nil
}
func (hm *p2pHostMock) GetAgentVersion(id peer.ID) string {
	return "fakeAgentVersion"
}
func (hm *p2pHostMock) Ping(ctx context.Context, pid peer.ID) bool {
	return true
}

var _ iplocation.LocationResolver = (*lrMock)(nil)

type lrMock struct{}

func (lr *lrMock) Resolve(mas []multiaddr.Multiaddr) (iplocation.Location, error) {
	return iplocation.Location{
		Country:   "USA",
		Latitude:  0.1,
		Longitude: 0.1,
	}, nil
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/onchain.go ---
package lotusidx

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/textileio/powergate/v2/index/miner"
)

func (mi *Index) updateOnChainIndex(ctx context.Context) error {
	start := time.Now()
	log.Info("updating on-chain index...")
	defer log.Info("on-chain index updated")

	client, cls, err := mi.cb(context.Background())
	if err != nil {
		return fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	listStart := time.Now()
	addrs, err := client.StateListMiners(ctx, types.EmptyTSK)
	if err != nil {
		return fmt.Errorf("calling state-list-miners: %s", err)
	}
	log.Infof("listing all on-chain miners took %.2f seconds", time.Since(listStart).Seconds())

	newIndex := miner.ChainIndex{
		Miners: map[string]miner.OnChainMinerData{},
	}
	if err := mi.updateForAddrs(ctx, client, &newIndex, addrs); err != nil {
		return fmt.Errorf("updating for addresses: %s", err)
	}
	chainHead, err := client.ChainHead(ctx)
	if err != nil {
		return fmt.Errorf("getting chain head: %s", err)
	}
	newIndex.LastUpdated = int64(chainHead.Height())

	mi.lock.Lock()
	mi.index.OnChain = newIndex
	mi.lock.Unlock()

	if err := mi.store.SaveOnChain(ctx, newIndex); err != nil {
		return fmt.Errorf("saving on-chain index to store: %s", err)
	}
	mi.signaler.Signal()
	mi.meterRefreshDuration.Record(ctx, time.Since(start).Milliseconds(), onchainSubindex)

	return nil
}

// updateForAddrs updates chainIndex information for a particular set of addrs.
func (mi *Index) updateForAddrs(ctx context.Context, api *api.FullNodeStruct, chainIndex *miner.ChainIndex, addrs []address.Address) error {
	var l sync.Mutex
	rl := make(chan struct{}, mi.conf.OnChainMaxParallel)
	for i, a := range addrs {
		if ctx.Err() != nil {
			return fmt.Errorf("update on-chain index canceled")
		}
		rl <- struct{}{}
		go func(addr address.Address) {
			defer func() { <-rl }()
			ocd, err := getOnChainData(ctx, api, addr)
			if err != nil {
				log.Debugf("getting onchain data: %s", err)
				return
			}
			l.Lock()
			chainIndex.Miners[addr.String()] = ocd
			l.Unlock()
		}(a)
		if i%10000 == 0 {
			log.Infof("on-chain idx progress %d/%d", i, len(addrs))
		}
		mi.metricLock.Lock()
		mi.onchainProgress = float64(i) / float64(len(addrs))
		mi.metricLock.Unlock()
	}
	for i := 0; i < mi.conf.OnChainMaxParallel; i++ {
		rl <- struct{}{}
	}
	mi.metricLock.Lock()
	mi.onchainProgress = 1
	mi.metricLock.Unlock()

	if ctx.Err() != nil {
		return fmt.Errorf("update on-chain index canceled")
	}

	return nil
}

func getOnChainData(ctx context.Context, c *api.FullNodeStruct, addr address.Address) (miner.OnChainMinerData, error) {
	// Power of miner.
	mp, err := c.StateMinerPower(ctx, addr, types.EmptyTSK)
	if err != nil {
		return miner.OnChainMinerData{}, fmt.Errorf("getting miner power: %s", err)
	}

	// Sector size
	info, err := c.StateMinerInfo(ctx, addr, types.EmptyTSK)
	if err != nil {
		return miner.OnChainMinerData{}, fmt.Errorf("getting sector size: %s", err)
	}

	// Sectors
	sectors, err := c.StateMinerSectorCount(ctx, addr, types.EmptyTSK)
	if err != nil {
		return miner.OnChainMinerData{}, fmt.Errorf("getting sectors count: %s", err)
	}

	p := mp.MinerPower.RawBytePower.Uint64()
	return miner.OnChainMinerData{
		Power:         p,
		RelativePower: float64(p) / float64(mp.TotalPower.RawBytePower.Uint64()),
		SectorSize:    uint64(info.SectorSize),
		SectorsLive:   sectors.Live,
		SectorsActive: sectors.Active,
		SectorsFaulty: sectors.Faulty,
	}, nil
}

'''
'''--- Filecoin/powergate/index/miner/lotusidx/store/store.go ---
package store

import (
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-datastore"
	kt "github.com/ipfs/go-datastore/keytransform"
	"github.com/ipfs/go-datastore/query"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/index/miner"
)

var (
	dsMetadata      = datastore.NewKey("meta")
	dsOnChainMiner  = datastore.NewKey("onchain/miner")
	dsOnChainHeight = datastore.NewKey("onchain/height")

	log = logger.Logger("lotusidx-store")
)

// Store is a store to save on-chain and metadata information about the chain.
type Store struct {
	ds *kt.Datastore
}

// New returns a new *Store.
func New(ds *kt.Datastore) (*Store, error) {
	return &Store{
		ds: ds,
	}, nil
}

// SaveMetadata creates/updates metadata information of miners.
func (s *Store) SaveMetadata(index miner.MetaIndex) error {
	for addr, meta := range index.Info {
		key := makeMinerMetadataKey(addr)
		buf, err := json.Marshal(meta)
		if err != nil {
			return fmt.Errorf("marshaling metadata for miner %s: %s", addr, err)
		}
		if err := s.ds.Put(key, buf); err != nil {
			return fmt.Errorf("saving metadata in store: %s", err)
		}
	}
	return nil
}

// SaveOnChain creates/updates on-chain information of miners.
func (s *Store) SaveOnChain(ctx context.Context, index miner.ChainIndex) error {
	var i int64
	b, err := s.ds.Batch()
	if err != nil {
		return fmt.Errorf("creating batch: %s", err)
	}
	for addr, onchain := range index.Miners {
		i++
		if i%1000 == 0 {
			if err := b.Commit(); err != nil {
				return fmt.Errorf("committing batch: %s", err)
			}
			b, err = s.ds.Batch()
			if err != nil {
				return fmt.Errorf("creating batch: %s", err)
			}
		}
		if ctx.Err() != nil {
			return fmt.Errorf("context signal: %s", ctx.Err())
		}
		key := makeMinerOnChainKey(addr)
		buf, err := json.Marshal(onchain)
		if err != nil {
			return fmt.Errorf("marshaling onchain for miner %s: %s", addr, err)
		}
		if err := b.Put(key, buf); err != nil {
			return fmt.Errorf("saving onchain in store: %s", err)
		}
	}
	if err := b.Commit(); err != nil {
		return fmt.Errorf("committing batch: %s", err)
	}

	buf := make([]byte, 8)
	binary.LittleEndian.PutUint64(buf, uint64(index.LastUpdated))
	if err := s.ds.Put(dsOnChainHeight, buf); err != nil {
		return fmt.Errorf("saving metadata in store: %s", err)
	}

	return nil
}

// GetIndex gets the complete stored metadata and on-chain index.
func (s *Store) GetIndex() (miner.IndexSnapshot, error) {
	metaIndex, err := s.getMetaIndex()
	if err != nil {
		return miner.IndexSnapshot{}, fmt.Errorf("get meta index: %s", err)
	}
	onChain, err := s.getOnChainIndex()
	if err != nil {
		return miner.IndexSnapshot{}, fmt.Errorf("get onchain index: %s", err)
	}

	return miner.IndexSnapshot{
		Meta:    metaIndex,
		OnChain: onChain,
	}, nil
}

func (s *Store) getMetaIndex() (miner.MetaIndex, error) {
	q := query.Query{Prefix: dsMetadata.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return miner.MetaIndex{}, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing meta-index query: %s", err)
		}
	}()

	info := map[string]miner.Meta{}
	for v := range res.Next() {
		if v.Error != nil {
			return miner.MetaIndex{}, fmt.Errorf("fetching query result: %s", v.Error)
		}
		key := datastore.NewKey(v.Key)
		minerAddr := key.Namespaces()[1]
		var m miner.Meta
		if err := json.Unmarshal(v.Value, &m); err != nil {
			return miner.MetaIndex{}, fmt.Errorf("unmarshaling meta info: %s", err)
		}
		info[minerAddr] = m
	}

	return miner.MetaIndex{
		Info: info,
	}, nil
}

func (s *Store) getOnChainIndex() (miner.ChainIndex, error) {
	q := query.Query{Prefix: dsOnChainMiner.String()}
	res, err := s.ds.Query(q)
	if err != nil {
		return miner.ChainIndex{}, fmt.Errorf("executing query: %s", err)
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("closing on-chain index query: %s", err)
		}
	}()

	info := map[string]miner.OnChainMinerData{}
	for v := range res.Next() {
		if v.Error != nil {
			return miner.ChainIndex{}, fmt.Errorf("fetching query result: %s", v.Error)
		}
		key := datastore.NewKey(v.Key)
		minerAddr := key.Namespaces()[2]
		var m miner.OnChainMinerData
		if err := json.Unmarshal(v.Value, &m); err != nil {
			return miner.ChainIndex{}, fmt.Errorf("unmarshaling onchain info: %s", err)
		}
		info[minerAddr] = m
	}

	buf, err := s.ds.Get(dsOnChainHeight)
	if err != nil && err != datastore.ErrNotFound {
		return miner.ChainIndex{}, fmt.Errorf("get onchain height: %s", err)
	}
	var lastUpdated int64
	if err != datastore.ErrNotFound {
		lastUpdated = int64(binary.LittleEndian.Uint64(buf))
	}

	return miner.ChainIndex{
		Miners:      info,
		LastUpdated: lastUpdated,
	}, nil
}

func makeMinerMetadataKey(addr string) datastore.Key {
	return dsMetadata.ChildString(addr)
}

func makeMinerOnChainKey(addr string) datastore.Key {
	return dsOnChainMiner.ChildString(addr)
}

'''
'''--- Filecoin/powergate/index/miner/types.go ---
package miner

import (
	"time"
)

// IndexSnapshot contains on-chain and off-chain information about miners.
type IndexSnapshot struct {
	Meta    MetaIndex
	OnChain ChainIndex
}

// ChainIndex contains on-chain information about miners.
type ChainIndex struct {
	LastUpdated int64
	Miners      map[string]OnChainMinerData
}

// OnChainMinerData contains on-chain data about a miner.
type OnChainMinerData struct {
	Power         uint64
	RelativePower float64
	SectorSize    uint64
	SectorsLive   uint64
	SectorsActive uint64
	SectorsFaulty uint64
}

// MetaIndex contains off-chain information about miners.
type MetaIndex struct {
	Info map[string]Meta
}

// Meta contains off-chain information of a miner.
type Meta struct {
	LastUpdated time.Time
	UserAgent   string
	Location    Location
}

// Location contains geeoinformation.
type Location struct {
	Country   string
	Longitude float64
	Latitude  float64
}

// Module provides information about miners in the
// Filecoin network.
type Module interface {
	Get() IndexSnapshot
	Listen() <-chan struct{}
	Unregister(c chan struct{})
}

'''
'''--- Filecoin/powergate/iplocation/iplocation.go ---
package iplocation

import (
	"errors"

	"github.com/multiformats/go-multiaddr"
)

var (
	// ErrCantResolve indicates that geoinformation couldn't be resolved for a host.
	ErrCantResolve = errors.New("can't resolve multiaddr location information")
)

// Location contains geoinformation.
type Location struct {
	Country   string
	Latitude  float64
	Longitude float64
}

// LocationResolver resolver gets location information from a set of multiaddresses of
// a single host.
type LocationResolver interface {
	Resolve(mas []multiaddr.Multiaddr) (Location, error)
}

'''
'''--- Filecoin/powergate/iplocation/maxmind/maxmind.go ---
package maxmind

import (
	"fmt"
	"net"
	"sync"

	logger "github.com/ipfs/go-log/v2"
	"github.com/multiformats/go-multiaddr"
	geoip2 "github.com/oschwald/geoip2-golang"
	"github.com/textileio/powergate/v2/iplocation"
	"github.com/textileio/powergate/v2/util"
)

var (
	log = logger.Logger("maxmind")
)

// MaxMind is an iplocation resolver using the MaxMind database.
type MaxMind struct {
	lock sync.Mutex
	db   *geoip2.Reader
}

// New returns a new MaxMind iplocation resolver.
func New(db string) (*MaxMind, error) {
	r, err := geoip2.Open(db)
	if err != nil {
		return nil, fmt.Errorf("opening geolite2 database: %s", err)
	}
	return &MaxMind{db: r}, nil
}

// Resolve returns Location information from multiaddrs.
func (mm *MaxMind) Resolve(mas []multiaddr.Multiaddr) (iplocation.Location, error) {
	for _, ma := range mas {
		ipport, err := util.TCPAddrFromMultiAddr(ma)
		if err != nil {
			log.Debugf("transforming %s to tcp addr: %s", ma, err)
			continue
		}
		strIP, _, err := net.SplitHostPort(ipport)
		if err != nil {
			log.Debugf("parsing ip/port from %s: %s", ipport, err)
			continue
		}
		ip := net.ParseIP(strIP)
		city, err := mm.db.City(ip)
		if err != nil {
			log.Debugf("querying maxmind db for %s: %s", ipport, err)
			continue
		}
		if city.Country.IsoCode != "" || (city.Location.Latitude != 0 && city.Location.Longitude != 0) {
			return iplocation.Location{
				Country:   city.Country.IsoCode,
				Latitude:  city.Location.Latitude,
				Longitude: city.Location.Longitude,
			}, nil
		}
		log.Debugf("no info for addr %s", ip)
	}
	return iplocation.Location{}, iplocation.ErrCantResolve
}

// Close closes the iplocation resolver.
func (mm *MaxMind) Close() error {
	mm.lock.Lock()
	defer mm.lock.Unlock()
	if err := mm.db.Close(); err != nil {
		return fmt.Errorf("closing geolite2 database: %s", err)
	}
	return nil
}

'''
'''--- Filecoin/powergate/iplocation/maxmind/maxmind_test.go ---
package maxmind

import (
	"testing"

	"github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
)

func TestResolve(t *testing.T) {
	mm := setup(t)

	tests := []struct {
		Name       string
		Maddr      multiaddr.Multiaddr
		CountryISO string
		Error      bool
	}{
		{
			Name:       "China IP4",
			Maddr:      multiaddr.StringCast("/ip4/59.110.242.123/tcp/1234"),
			CountryISO: "CN",
		},
		{
			Name:       "Uruguay IP4",
			Maddr:      multiaddr.StringCast("/ip4/186.52.85.100/tcp/1234"),
			CountryISO: "UY",
		},
		{
			Name:       "DNS",
			Maddr:      multiaddr.StringCast("/dns4/google.com/tcp/80"),
			CountryISO: "US",
		},
		{
			Name:       "USA IP6",
			Maddr:      multiaddr.StringCast("/ip6/2001:4b0:85a3:0000:0000:8a2e:0370:7334/tcp/1234"),
			CountryISO: "US",
		},
		{
			Name:  "Unresolvable IP4",
			Maddr: multiaddr.StringCast("/ip4/127.0.233.233/tcp/1234"),
			Error: true,
		},
	}
	for _, tc := range tests {
		l, err := mm.Resolve([]multiaddr.Multiaddr{tc.Maddr})
		require.Equal(t, tc.Error, err != nil)
		if tc.Error {
			continue
		}
		require.Equal(t, tc.CountryISO, l.Country)
		require.NotZero(t, l.Latitude)
		require.NotZero(t, l.Longitude)
	}
}

func setup(t *testing.T) *MaxMind {
	mm, err := New("GeoLite2-City.mmdb")
	require.NoError(t, err)
	t.Cleanup(func() { _ = mm.Close() })
	return mm
}

'''
'''--- Filecoin/powergate/lotus/client.go ---
package lotus

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/filecoin-project/go-jsonrpc"
	"github.com/filecoin-project/lotus/api"
	logging "github.com/ipfs/go-log/v2"
	ma "github.com/multiformats/go-multiaddr"

	"github.com/textileio/powergate/v2/util"
)

var (
	log = logging.Logger("lotus-client")
)

// ClientBuilder creates a new Lotus client.
type ClientBuilder func(ctx context.Context) (*api.FullNodeStruct, func(), error)

// NewBuilder creates a new ClientBuilder.
func NewBuilder(maddr ma.Multiaddr, authToken string, connRetries int) (ClientBuilder, error) {
	addr, err := util.TCPAddrFromMultiAddr(maddr)
	if err != nil {
		return nil, err
	}
	headers := http.Header{
		"Authorization": []string{"Bearer " + authToken},
	}

	return func(ctx context.Context) (*api.FullNodeStruct, func(), error) {
		var api api.FullNodeStruct
		var closer jsonrpc.ClientCloser
		var err error
		for i := 0; i < connRetries; i++ {
			if ctx.Err() != nil {
				return nil, nil, fmt.Errorf("canceled by context")
			}
			closer, err = jsonrpc.NewMergeClient(context.Background(), "ws://"+addr+"/rpc/v0", "Filecoin",
				[]interface{}{
					&api.Internal,
					&api.CommonStruct.Internal,
				}, headers)
			if err == nil {
				break
			}
			log.Warnf("failed to connect to Lotus client %s, retrying...", err)
			time.Sleep(time.Second * 10)
		}
		if err != nil {
			return nil, nil, fmt.Errorf("couldn't connect to Lotus API: %s", err)
		}

		return &api, closer, nil
	}, nil
}

'''
'''--- Filecoin/powergate/lotus/client_test.go ---
package lotus_test

import (
	"bytes"
	"context"
	"crypto/rand"
	"io"
	"io/ioutil"
	"os"
	"testing"
	"time"

	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	logging "github.com/ipfs/go-log/v2"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

const (
	tmpDir = "/tmp/powergate/lotusclienttest"
)

func TestMain(m *testing.M) {
	if err := os.RemoveAll(tmpDir); err != nil {
		panic(err)
	}
	if _, err := os.Stat(tmpDir); os.IsNotExist(err) {
		if err := os.MkdirAll(tmpDir, os.ModePerm); err != nil {
			panic("can't create temp dir")
		}
	}
	logging.SetAllLoggers(logging.LevelError)
	os.Exit(m.Run())
}

func TestClientImport(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()

	f, err := ioutil.TempFile(tmpDir, "")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, f.Close())
		require.NoError(t, os.Remove(f.Name()))
	}()
	bts := make([]byte, 4)
	_, err = rand.Read(bts)
	require.NoError(t, err)
	_, err = io.Copy(f, bytes.NewReader(bts))
	require.NoError(t, err)

	ref := api.FileRef{
		Path: f.Name(),
	}
	res, err := client.ClientImport(context.Background(), ref)
	require.NoError(t, err)
	if !res.Root.Defined() {
		t.Errorf("undefined cid from import")
	}
}

func TestClientChainNotify(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()

	ch, err := client.ChainNotify(context.Background())
	require.NoError(t, err)

	// ch is guaranteed to push always current tipset
	h := <-ch
	if len(h) != 1 {
		t.Fatalf("first pushed notification should have length 1")
	}
	if h[0].Type != "current" || len(h[0].Val.Cids()) == 0 || h[0].Val.Height() == 0 {
		t.Fatalf("current head has invalid values")
	}

	select {
	case <-time.After(time.Second * 10):
		t.Fatalf("a new block should be received in less than ~10s")
	case <-ch:
		return
	}
}

func TestChainHead(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()
	ts, err := client.ChainHead(context.Background())
	require.NoError(t, err)
	if len(ts.Cids()) == 0 || len(ts.Blocks()) == 0 || ts.Height() == 0 {
		t.Fatalf("invalid tipset")
	}
}

func TestChainGetTipset(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()

	ts, err := client.ChainHead(context.Background())
	require.NoError(t, err)
	pts, err := client.ChainGetTipSet(context.Background(), types.NewTipSetKey(ts.Blocks()[0].Parents...))
	require.NoError(t, err)
	if len(pts.Cids()) == 0 || len(pts.Blocks()) == 0 || pts.Height() != ts.Height()-1 {
		t.Fatalf("invalid tipset")
	}
}

func TestGetPeerID(t *testing.T) {
	clientBuilder, _, _ := tests.CreateLocalDevnet(t, 1, 300)
	client, cls, err := clientBuilder(context.Background())
	require.NoError(t, err)
	defer cls()

	miners, err := client.StateListMiners(context.Background(), types.EmptyTSK)
	require.NoError(t, err)

	mi, err := client.StateMinerInfo(context.Background(), miners[0], types.EmptyTSK)
	require.NoError(t, err)
	require.NoError(t, mi.PeerId.Validate())
}

'''
'''--- Filecoin/powergate/lotus/metrics.go ---
package lotus

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/filecoin-project/lotus/api"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

const (
	metricHeightInterval = time.Second * 120
)

// SyncMonitor provides information about the Lotus
// syncing status.
type SyncMonitor struct {
	cb ClientBuilder

	lock       sync.Mutex
	height     int64
	heightDiff int64
	remaining  int64
}

// NewSyncMonitor creates a new LotusSyncMonitor.
func NewSyncMonitor(cb ClientBuilder) (*SyncMonitor, error) {
	lsm := &SyncMonitor{cb: cb}
	lsm.initMetrics()

	if err := lsm.refreshSyncDiff(); err != nil {
		return nil, fmt.Errorf("getting initial sync height diff: %s", err)
	}

	go func() {
		for {
			lsm.evaluate()
			time.Sleep(metricHeightInterval)
		}
	}()
	return lsm, nil
}

// SyncHeightDiff returns the height difference between the tip of the chain
// and the current synced height.
func (lsm *SyncMonitor) SyncHeightDiff() int64 {
	lsm.lock.Lock()
	defer lsm.lock.Unlock()
	return lsm.heightDiff
}

func (lsm *SyncMonitor) evaluate() {
	if err := lsm.refreshHeightMetric(); err != nil {
		log.Errorf("refreshing height metric: %s", err)
	}
	if err := lsm.checkSyncStatus(); err != nil {
		log.Errorf("checking sync status: %s", err)
	}
}

func (lsm *SyncMonitor) refreshHeightMetric() error {
	c, cls, err := lsm.cb(context.Background())
	if err != nil {
		return fmt.Errorf("creating lotus client for monitoring: %s", err)
	}
	defer cls()

	heaviest, err := c.ChainHead(context.Background())
	if err != nil {
		return fmt.Errorf("getting chain head: %s", err)
	}
	lsm.lock.Lock()
	lsm.height = int64(heaviest.Height())
	lsm.lock.Unlock()

	return nil
}

func (lsm *SyncMonitor) checkSyncStatus() error {
	if err := lsm.refreshSyncDiff(); err != nil {
		return fmt.Errorf("refreshing height difference: %s", err)
	}

	lsm.lock.Lock()
	defer lsm.lock.Unlock()
	if lsm.heightDiff > 10 {
		log.Warnf("Louts behind in syncing with height diff %d, todo: %d", lsm.heightDiff, lsm.remaining)
	}
	return nil
}

func (lsm *SyncMonitor) refreshSyncDiff() error {
	c, cls, err := lsm.cb(context.Background())
	if err != nil {
		return fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	ctx, cls := context.WithTimeout(context.Background(), time.Second*5)
	defer cls()
	ss, err := c.SyncState(ctx)
	if err != nil {
		return fmt.Errorf("calling sync state: %s", err)
	}

	var maxHeightDiff, remaining int64
	for _, as := range ss.ActiveSyncs {
		if as.Stage != api.StageSyncComplete {
			var heightDiff int64
			if as.Base != nil {
				heightDiff = int64(as.Base.Height())
			}
			if as.Target != nil {
				heightDiff = int64(as.Target.Height()) - heightDiff
			} else {
				heightDiff = 0
			}

			if heightDiff > maxHeightDiff {
				maxHeightDiff = heightDiff
				remaining = int64(as.Target.Height() - as.Height)
			}
		}
	}

	lsm.lock.Lock()
	lsm.heightDiff = maxHeightDiff
	lsm.remaining = remaining
	lsm.lock.Unlock()

	return nil
}

func (lsm *SyncMonitor) initMetrics() {
	meter := global.Meter("powergate")

	_ = metric.Must(meter).NewInt64ValueObserver("powergate.lotus.height",
		func(ctx context.Context, result metric.Int64ObserverResult) {
			lsm.lock.Lock()
			defer lsm.lock.Unlock()
			result.Observe(lsm.height)
		}, metric.WithDescription("Lotus node height"))

	_ = metric.Must(meter).NewInt64ValueObserver("powergate.lotus.height.diff",
		func(ctx context.Context, result metric.Int64ObserverResult) {
			lsm.lock.Lock()
			defer lsm.lock.Unlock()
			result.Observe(lsm.heightDiff)
		}, metric.WithDescription("Lotus node height syncing diff"))
}

'''
'''--- Filecoin/powergate/migration/migration.go ---
package migration

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logger "github.com/ipfs/go-log/v2"
)

var (
	log = logger.Logger("migrations")

	keyCurrentVersion = datastore.NewKey("version")
)

// Migrator ensures a datastore goes through all the needed
// Migrations to upgrade its current version to the latest version.
type Migrator struct {
	ds         datastore.TxnDatastore
	migrations map[int]Migration
}

type datastoreReaderWriter interface {
	datastore.Read
	datastore.Write
}

// Migration runs a vA->v(A+1) migration. UseTxn indicates
// if this migration should be run in a transaction.
type Migration struct {
	Run    func(datastoreReaderWriter) error
	UseTxn bool
}

// New returns a new Migrator.
func New(ds datastore.TxnDatastore, migrations map[int]Migration) *Migrator {
	m := &Migrator{
		ds:         ds,
		migrations: migrations,
	}
	return m
}

// Ensure detects the current datastore version, and runs all the known migrations
// to upgrade to the latest known version.
func (m *Migrator) Ensure() error {
	currentVersion, emptyDS, err := m.getCurrentVersion()
	if err != nil {
		return fmt.Errorf("getting current version: %s", err)
	}

	targetVersion := m.getTargetVersion()

	// If the database is empty, we can assume Powergate started fresh
	// and requires no migration. Set current version to latest version
	// in migrations script.
	if emptyDS {
		if err := m.bootstrapEmptyDatastore(targetVersion); err != nil {
			return fmt.Errorf("bootstrapping empty database: %s", err)
		}

		return nil
	}

	log.Infof("Current datastore version is %d, target version %d", currentVersion, targetVersion)

	if currentVersion == targetVersion {
		return nil
	}

	if currentVersion > targetVersion {
		return fmt.Errorf("migrations are forward only, current version %d, target version %d", currentVersion, targetVersion)
	}

	for i := currentVersion + 1; i <= targetVersion; i++ {
		log.Infof("Running v%d migration...", i)
		if err := m.run(i); err != nil {
			return fmt.Errorf("running migration %d: %s", i, err)
		}
		log.Infof("Migration %d ran successfully", i)
	}

	return nil
}

type currentVersion struct {
	Version int
}

// getCurrentVersion returns the current database version. If it isn't one
// defined wil be 0. If the datastore is considered to be completely empty,
// it returns true in the second return parameter.
func (m *Migrator) getCurrentVersion() (int, bool, error) {
	isDSEmpty, err := m.isDSEmpty()
	if err != nil {
		return 0, false, fmt.Errorf("detecting if datastore is empty: %s", err)
	}
	if isDSEmpty {
		return 0, true, nil
	}

	var current currentVersion
	buf, err := m.ds.Get(keyCurrentVersion)
	if err == datastore.ErrNotFound {
		return 0, false, nil
	}
	if err != nil {
		return 0, false, fmt.Errorf("getting version from datastore: %s", err)
	}

	if err := json.Unmarshal(buf, &current); err != nil {
		return 0, false, fmt.Errorf("unmarshaling current version: %s", err)
	}

	return current.Version, false, nil
}

func (m *Migrator) run(version int) error {
	var dsReaderWriter datastoreReaderWriter

	migration, ok := m.migrations[version]
	if !ok {
		return fmt.Errorf("migration script not found")
	}

	dsReaderWriter = m.ds
	if migration.UseTxn {
		txn, err := m.ds.NewTransaction(false)
		if err != nil {
			return fmt.Errorf("creating txn for migration: %s", err)
		}
		defer txn.Discard()
		dsReaderWriter = txn
	}

	if err := migration.Run(dsReaderWriter); err != nil {
		return fmt.Errorf("running migration script: %s", err)
	}

	newVer := currentVersion{Version: version}
	newVerBuf, err := json.Marshal(newVer)
	if err != nil {
		return fmt.Errorf("marshaling new version: %s", err)
	}
	if err := dsReaderWriter.Put(keyCurrentVersion, newVerBuf); err != nil {
		return fmt.Errorf("saving new version: %s", err)
	}

	if migration.UseTxn {
		txn := dsReaderWriter.(datastore.Txn)
		if err := txn.Commit(); err != nil {
			return fmt.Errorf("committing transaction: %s", err)
		}
	}

	return nil
}

func (m *Migrator) isDSEmpty() (bool, error) {
	q := query.Query{Limit: 1}
	res, err := m.ds.Query(q)
	if err != nil {
		return false, fmt.Errorf("executing query: %s", err)
	}
	defer func() { _ = res.Close() }()

	all, err := res.Rest()
	if err != nil {
		return false, fmt.Errorf("getting query results: %s", err)
	}

	return len(all) == 0, nil
}

func (m *Migrator) getTargetVersion() int {
	var maxVersion int
	for ver := range m.migrations {
		if ver > maxVersion {
			maxVersion = ver
		}
	}
	return maxVersion
}

func (m *Migrator) bootstrapEmptyDatastore(version int) error {
	newVer := currentVersion{Version: version}
	newVerBuf, err := json.Marshal(newVer)
	if err != nil {
		return fmt.Errorf("marshaling new version: %s", err)
	}
	if err := m.ds.Put(keyCurrentVersion, newVerBuf); err != nil {
		return fmt.Errorf("saving new version: %s", err)
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1.go ---
package migration

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

// V1MultitenancyMigration contains the logic to upgrade a datastore from
// version 0 to version 1. Transactionality is disabled since is a big migration.
var V1MultitenancyMigration = Migration{
	UseTxn: false,
	Run: func(ds datastoreReaderWriter) error {
		cidOwners, err := v0CidOwners(ds)
		if err != nil {
			return fmt.Errorf("getting cid owners: %s", err)
		}
		log.Infof("Starting job logger migration...")
		if err := migrateJobLogger(ds, cidOwners); err != nil {
			return fmt.Errorf("migrating job logger: %s", err)
		}
		log.Infof("Job logger migration finished")

		log.Infof("Starting storage info migration...")
		if err := migrateStorageInfo(ds, cidOwners); err != nil {
			return fmt.Errorf("migrating storage info: %s", err)
		}
		log.Infof("Storage info migration finished")

		log.Infof("Starting trackstore migration...")
		if err := migrateTrackstore(ds, cidOwners); err != nil {
			return fmt.Errorf("migrating trackstore: %s", err)
		}
		log.Infof("Trackstore migration finished")

		log.Infof("Starting started deals migration...")
		if err := migrateStartedDeals(ds); err != nil {
			return fmt.Errorf("migrating trackstore: %s", err)
		}
		log.Infof("Started deals migration finished")

		log.Infof("Starting pinstore filling migration...")
		if err := pinstoreFilling(ds, cidOwners); err != nil {
			return fmt.Errorf("filling pinstore: %s", err)
		}
		log.Infof("Pinstore filling migration finished")

		return nil
	},
}

func v0CidOwners(ds datastoreReaderWriter) (map[cid.Cid][]ffs.APIID, error) {
	iids, err := v0APIIDs(ds)
	if err != nil {
		return nil, fmt.Errorf("getting v0 iids: %s", err)
	}

	lim := make(chan struct{}, 1000)
	var lock sync.Mutex
	var errors []string
	owners := map[cid.Cid][]ffs.APIID{}
	for _, iid := range iids {
		lim <- struct{}{}
		iid := iid
		go func() {
			defer func() { <-lim }()
			cids, err := v0GetCidsFromIID(ds, iid)
			if err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("getting cids from iid: %s", err))
				lock.Unlock()
				return
			}
			lock.Lock()
			for _, c := range cids {
				owners[c] = append(owners[c], iid)
			}
			lock.Unlock()
		}()
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	if len(errors) > 0 {
		for _, m := range errors {
			log.Error(m)
		}
		return nil, fmt.Errorf("building cidowners had %d errors", len(errors))
	}

	return owners, nil
}

func v0GetCidsFromIID(ds datastoreReaderWriter, iid ffs.APIID) ([]cid.Cid, error) {
	q := query.Query{Prefix: "/ffs/manager/api/" + iid.String() + "/istore/cidstorageconfig"}
	res, err := ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("getting cids from iid: %s", err)
	}
	defer func() {
		_ = res.Close()
	}()

	var ret []cid.Cid
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("query result: %s", r.Error)
		}

		// /ffs/manager/api/<iid>/istore/cidstorageconfig/<cid>
		cidStr := datastore.NewKey(r.Key).Namespaces()[6]
		c, err := util.CidFromString(cidStr)
		if err != nil {
			return nil, fmt.Errorf("discovered invalid cid: %s", err)
		}
		ret = append(ret, c)
	}

	return ret, nil
}

func v0APIIDs(ds datastoreReaderWriter) ([]ffs.APIID, error) {
	q := query.Query{Prefix: "/ffs/manager/api"}
	res, err := ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("getting iids: %s", err)
	}
	defer func() {
		_ = res.Close()
	}()

	iids := map[ffs.APIID]struct{}{}
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("query result: %s", r.Error)
		}

		k := datastore.NewKey(r.Key)
		iid := ffs.APIID(k.Namespaces()[3]) // /ffs/manager/api/<iid>/...
		if !iid.Valid() {
			return nil, fmt.Errorf("discovered invalid iid: %s", err)
		}
		iids[iid] = struct{}{}
	}

	ret := make([]ffs.APIID, 0, len(iids))
	for iid := range iids {
		ret = append(ret, iid)
	}

	return ret, nil
}

func v0GetStorageConfig(ds datastoreReaderWriter, iid ffs.APIID, c cid.Cid) (ffs.StorageConfig, error) {
	if !iid.Valid() {
		return ffs.StorageConfig{}, fmt.Errorf("invalid iid %s", iid)
	}
	if !c.Defined() {
		return ffs.StorageConfig{}, fmt.Errorf("undefined cid")
	}
	key := datastore.NewKey("/ffs/manager/api/" + iid.String() + "/istore/cidstorageconfig/" + util.CidToString(c))

	buf, err := ds.Get(key)
	if err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("getting storage config: %s", err)
	}
	var conf ffs.StorageConfig
	if err := json.Unmarshal(buf, &conf); err != nil {
		return ffs.StorageConfig{}, fmt.Errorf("unmarshaling cid config from datastore: %s", err)
	}

	return conf, nil
}

func v0GetExecutingJobs(ds datastoreReaderWriter) (map[cid.Cid]ffs.APIID, error) {
	q := query.Query{Prefix: "/ffs/scheduler/sjstore/job"} // /ffs/scheduler/sjstore/job/<job-id>
	res, err := ds.Query(q)
	if err != nil {
		return nil, fmt.Errorf("getting jobs: %s", err)
	}
	defer func() {
		_ = res.Close()
	}()

	lim := make(chan struct{}, 1000)
	var lock sync.Mutex
	var errors []string
	ret := map[cid.Cid]ffs.APIID{}
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("getting result from query: %s", r.Error)
		}
		lim <- struct{}{}
		r := r
		go func() {
			defer func() { <-lim }()

			var j ffs.StorageJob
			if err := json.Unmarshal(r.Value, &j); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("unmarshalling job: %s", err))
				lock.Unlock()
				return
			}
			if j.Status == ffs.Executing {
				lock.Lock()
				ret[j.Cid] = j.APIID
				lock.Unlock()
			}
		}()
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	if len(errors) > 0 {
		for _, m := range errors {
			log.Error(m)
		}
		return nil, fmt.Errorf("building executing jobs map had %d errors", len(errors))
	}

	return ret, nil
}

'''
'''--- Filecoin/powergate/migration/migration1_joblogger.go ---
package migration

import (
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

func migrateJobLogger(ds datastoreReaderWriter, cidOwners map[cid.Cid][]ffs.APIID) error {
	q := query.Query{Prefix: "/ffs/joblogger"}
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying joblogger: %s", err)
	}
	defer func() { _ = res.Close() }()

	var lock sync.Mutex
	var errors []string
	lim := make(chan struct{}, 1000)
	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating result: %s", r.Error)
		}
		lim <- struct{}{}

		r := r
		go func() {
			defer func() { <-lim }()

			originalKey := datastore.NewKey(r.Key)
			cidStr := originalKey.Namespaces()[2] // /ffs/joblogger/<cid>/<timestamp>
			cid, err := util.CidFromString(cidStr)
			if err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("parsing cid %s: %s", cidStr, err))
				lock.Unlock()
				return
			}
			timestampStr := originalKey.Namespaces()[3]

			owners := cidOwners[cid]

			// Step 1/2:
			// For each cid owner, we create the same registry
			// in the new key version.
			for _, iid := range owners {
				newKey := datastore.NewKey("/ffs/joblogger_v2/").ChildString(iid.String()).ChildString(cidStr).ChildString(timestampStr)
				if err := ds.Put(newKey, r.Value); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("copying job log: %s", err))
					lock.Unlock()
					return
				}
			}

			// Step 2/2:
			// Delete old datastore key.
			if err := ds.Delete(originalKey); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("deleting old key: %s", err))
				lock.Unlock()
				return
			}
		}()
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	if len(errors) > 0 {
		for _, m := range errors {
			log.Error(m)
		}
		return fmt.Errorf("migration had %d errors", len(errors))
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1_joblogger_test.go ---
package migration

import (
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestV1_JobLogger(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_JobLogger.pre")

	c1, _ := util.CidFromString("QmPewMLNZEgnLxaenjo9Q5qwQwW3zHZ7Ac973UmeJ6VWHE")
	c2, _ := util.CidFromString("QmZTMaDfCMWqhUXYDnKup8ctCTyPxnriYW7G4JR8KXoX5M")
	cidOwners := map[cid.Cid][]ffs.APIID{
		c1: {ffs.APIID("ID1"), ffs.APIID("ID2")},
		c2: {ffs.APIID("ID3")},
	}
	txn, _ := ds.NewTransaction(false)
	err := migrateJobLogger(txn, cidOwners)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v1_JobLogger.post")
}

'''
'''--- Filecoin/powergate/migration/migration1_pinstore.go ---
package migration

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/textileio/powergate/v2/ffs"
)

// The following two datastructures are
// what Pinstore in v1 expects to be saved
// in the datastore. We can't use pinstore.PinnedCid
// struct directly because is an `internal` package.
type v1PinstorePinnedCid struct {
	Cid  cid.Cid
	Pins []v1PinstorePin
}
type v1PinstorePin struct {
	APIID     ffs.APIID
	Staged    bool
	CreatedAt int64
}

func pinstoreFilling(ds datastoreReaderWriter, cidOwners map[cid.Cid][]ffs.APIID) error {
	// This migration should fill Pinstore. Pinstore keeps track of
	// which IIDs are pinning a Cid in hot-storage.

	// Step 1/2:
	// - Iterate over all cidOwners and make a list of
	//   IIDs that are pinning a Cid in hot-storage.
	var lock sync.Mutex
	var errors []string
	lim := make(chan struct{}, 1000)
	cidsPinstore := map[cid.Cid][]ffs.APIID{}
	for c, iids := range cidOwners {
		lim <- struct{}{}
		c := c
		iids := iids
		go func() {
			defer func() { <-lim }()
			for _, iid := range iids {
				sc, err := v0GetStorageConfig(ds, iid, c)
				if err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("getting storage config: %s", err))
					lock.Unlock()
					return
				}
				if sc.Hot.Enabled {
					lock.Lock()
					cidsPinstore[c] = append(cidsPinstore[c], iid)
					lock.Unlock()
				}
			}
		}()
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	// Step 2/2:
	// - Include this generated data in Pinstore.
	for c, iids := range cidsPinstore {
		if len(iids) == 0 {
			continue
		}
		r := v1PinstorePinnedCid{
			Cid:  c,
			Pins: make([]v1PinstorePin, len(iids)),
		}
		for i := range iids {
			r.Pins[i] = v1PinstorePin{
				APIID:     iids[i],
				CreatedAt: 0,
			}
		}
		k := datastore.NewKey("/ffs/coreipfs/pinstore/pins/" + r.Cid.String())
		buf, err := json.Marshal(r)
		if err != nil {
			return fmt.Errorf("marshaling to datastore: %s", err)
		}
		if err := ds.Put(k, buf); err != nil {
			return fmt.Errorf("put in datastore: %s", err)
		}
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1_pinstore_test.go ---
package migration

import (
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestV1_Pinstore(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_Pinstore.pre")

	c1, _ := util.CidFromString("QmY7gN6AfKSoR7DNEjcUyXRYS85giD1YXN62cWVzS5zfus")
	c2, _ := util.CidFromString("QmX5J6NujFycQyoMvHXjTNmtvqDnn8TN6wAVQJ4Ap2GMnq")
	cidOwners := map[cid.Cid][]ffs.APIID{
		c1: {ffs.APIID("ad2f3b0c-e356-43d4-a483-fba79479d7e4"), ffs.APIID("fb79f525-a3c4-47f0-94e5-e344c5b1dec5")},
		c2: {ffs.APIID("2bef4790-a47a-4a48-90da-a89f93ab6310")},
	}
	txn, _ := ds.NewTransaction(false)
	err := pinstoreFilling(txn, cidOwners)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v1_Pinstore.post")
}

'''
'''--- Filecoin/powergate/migration/migration1_starteddeals.go ---
package migration

import (
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/util"
)

func migrateStartedDeals(ds datastoreReaderWriter) error {
	executingJobs, err := v0GetExecutingJobs(ds)
	if err != nil {
		return fmt.Errorf("getting executing jobs: %s", err)
	}
	q := query.Query{Prefix: "/ffs/scheduler/sjstore/starteddeals"}
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying started deals in sjstore: %s", err)
	}
	defer func() { _ = res.Close() }()

	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating result: %s", r.Error)
		}

		originalKey := datastore.NewKey(r.Key)
		cidStr := originalKey.Namespaces()[4] // /ffs/scheduler/sjstore/starteddeals/<cid>
		cid, err := util.CidFromString(cidStr)
		if err != nil {
			return fmt.Errorf("discovered invalid cid: %s", err)
		}

		owner, ok := executingJobs[cid]
		if ok {
			// Step 1/2:
			// Add corresponding iid in started deals key namespace.
			newKey := datastore.NewKey("/ffs/scheduler/sjstore/starteddeals_v2").ChildString(owner.String()).ChildString(cidStr)
			if err := ds.Put(newKey, r.Value); err != nil {
				return fmt.Errorf("copying started deal to new key: %s", err)
			}
		}

		// Step 2/2:
		// Delete old datastore key.
		if err := ds.Delete(originalKey); err != nil {
			return fmt.Errorf("deleting old key: %s", err)
		}
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1_starteddeals_test.go ---
package migration

import (
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestV1_StartedDeals(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_StartedDeals.pre")

	txn, _ := ds.NewTransaction(false)
	err := migrateStartedDeals(txn)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v1_StartedDeals.post")
}

func TestV0_ExecutingJobs(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_StartedDeals.pre")

	txn, _ := ds.NewTransaction(false)
	execJobsOwners, err := v0GetExecutingJobs(txn)
	require.NoError(t, err)

	require.Len(t, execJobsOwners, 2)

	c1, _ := util.CidFromString("QmbcKgdxWfZzePsrc6rWq2yk12GE1MnW8JJiubHAJovKb5")
	iid1 := ffs.APIID("a9aeaecc-4c94-4bb6-bd14-13927d8cede0")
	require.Equal(t, iid1, execJobsOwners[c1])

	c2, _ := util.CidFromString("QmaPndBy99qcz7rCAooak8SY34Rk9oXWpEBp4dUyhbmq1q")
	iid2 := ffs.APIID("ad2f3b0c-e356-43d4-a483-fba79479d7e4")
	require.Equal(t, iid2, execJobsOwners[c2])
}

'''
'''--- Filecoin/powergate/migration/migration1_storageinfo.go ---
package migration

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

func migrateStorageInfo(ds datastoreReaderWriter, cidOwners map[cid.Cid][]ffs.APIID) error {
	q := query.Query{Prefix: "/ffs/scheduler/cistore"}
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying cistore: %s", err)
	}
	defer func() { _ = res.Close() }()

	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating result: %s", r.Error)
		}

		originalKey := datastore.NewKey(r.Key)
		cidStr := originalKey.Namespaces()[3] // /ffs/scheduler/cistore/<cid>
		cid, err := util.CidFromString(cidStr)
		if err != nil {
			return fmt.Errorf("discovered invalid cid: %s", err)
		}

		owners := cidOwners[cid]
		// Step 1/2:
		// For each cid owner, we create the same registry
		// prexifing the iid considering the new namespace structure.
		for _, iid := range owners {
			var si ffs.StorageInfo
			if err := json.Unmarshal(r.Value, &si); err != nil {
				return fmt.Errorf("unmarshaling storageconfig: %s", err)
			}
			si.APIID = iid
			buf, err := json.Marshal(si)
			if err != nil {
				return fmt.Errorf("marshaling now entry: %s", err)
			}

			newKey := datastore.NewKey("/ffs/scheduler/cistore_v2").ChildString(iid.String()).ChildString(cidStr)
			if err := ds.Put(newKey, buf); err != nil {
				return fmt.Errorf("copying storageinfo: %s", err)
			}
		}

		// Step 2/2:
		// Delete old datastore key.
		if err := ds.Delete(originalKey); err != nil {
			return fmt.Errorf("deleting old key: %s", err)
		}
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1_storageinfo_test.go ---
package migration

import (
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestV1_StorageInfo(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_StorageInfo.pre")

	c1, _ := util.CidFromString("QmbtfAvVRVgEa9RH6vYpKg1HWbBQjxiZ6vNG1AAvt3vyfR")
	c2, _ := util.CidFromString("QmZTMaDfCMWqhUXYDnKup8ctCTyPxnriYW7G4JR8KXoX5M")
	cidOwners := map[cid.Cid][]ffs.APIID{
		c1: {ffs.APIID("ID1"), ffs.APIID("ID2")},
		c2: {ffs.APIID("ID2"), ffs.APIID("ID3")},
	}
	txn, _ := ds.NewTransaction(false)
	err := migrateStorageInfo(txn, cidOwners)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v1_StorageInfo.post")
}

'''
'''--- Filecoin/powergate/migration/migration1_trackstore.go ---
package migration

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/util"
)

type v0trackedStorageConfig struct {
	IID           ffs.APIID
	StorageConfig ffs.StorageConfig
}

// In v1 we persist the same struct but as an array, instead
// of a single element.
type v1trackedStorageConfig v0trackedStorageConfig

func migrateTrackstore(ds datastoreReaderWriter, cidOwners map[cid.Cid][]ffs.APIID) error {
	q := query.Query{Prefix: "/ffs/scheduler/tstore"}
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying tstore: %s", err)
	}
	defer func() { _ = res.Close() }()

	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating result: %s", r.Error)
		}

		originalKey := datastore.NewKey(r.Key)
		cidStr := originalKey.Namespaces()[3] // /ffs/scheduler/tstore/<cid>
		cid, err := util.CidFromString(cidStr)
		if err != nil {
			return fmt.Errorf("discovered invalid cid: %s", err)
		}

		// Step 1/2:
		// For each cid owner, we replace the registry
		// with a slice of owners.
		owners := cidOwners[cid]
		newEntry := make([]v1trackedStorageConfig, len(owners))
		for i, iid := range owners {
			sg, err := v0GetStorageConfig(ds, iid, cid)
			if err != nil {
				return fmt.Errorf("get storage config of cid from owner: %s", err)
			}

			if sg.Repairable || (sg.Cold.Enabled && sg.Cold.Filecoin.Renew.Enabled) {
				newEntry[i] = v1trackedStorageConfig{IID: iid, StorageConfig: sg}
			}
		}

		// Step 2/2:
		// Replace original entry with new entry.
		buf, err := json.Marshal(newEntry)
		if err != nil {
			return fmt.Errorf("marshaling new entry: %s", err)
		}

		if err := ds.Put(originalKey, buf); err != nil {
			return fmt.Errorf("put new entry in datastore: %s", err)
		}
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration1_trackstore_test.go ---
package migration

import (
	"sort"
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/ffs"
	"github.com/textileio/powergate/v2/tests"
	"github.com/textileio/powergate/v2/util"
)

func TestV1_Trackstore(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_Trackstore.pre")

	c1, _ := util.CidFromString("QmY7gN6AfKSoR7DNEjcUyXRYS85giD1YXN62cWVzS5zfus")
	c2, _ := util.CidFromString("QmX5J6NujFycQyoMvHXjTNmtvqDnn8TN6wAVQJ4Ap2GMnq")
	cidOwners := map[cid.Cid][]ffs.APIID{
		c1: {ffs.APIID("ad2f3b0c-e356-43d4-a483-fba79479d7e4"), ffs.APIID("fb79f525-a3c4-47f0-94e5-e344c5b1dec5")},
		c2: {ffs.APIID("2bef4790-a47a-4a48-90da-a89f93ab6310")},
	}
	txn, _ := ds.NewTransaction(false)
	err := migrateTrackstore(txn, cidOwners)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v1_Trackstore.post")
}

func TestV0_APIIDs(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_Trackstore.pre")

	txn, _ := ds.NewTransaction(false)
	iids, err := v0APIIDs(txn)
	require.NoError(t, err)

	sort.Slice(iids, func(i, j int) bool {
		return iids[i].String() < iids[j].String()
	})

	require.Len(t, iids, 3)
	require.Equal(t, "2bef4790-a47a-4a48-90da-a89f93ab6310", iids[0].String())
	require.Equal(t, "ad2f3b0c-e356-43d4-a483-fba79479d7e4", iids[1].String())
	require.Equal(t, "fb79f525-a3c4-47f0-94e5-e344c5b1dec5", iids[2].String())
}

func TestV0_GetCidsFromIID(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_Trackstore.pre")

	txn, _ := ds.NewTransaction(false)
	cids, err := v0GetCidsFromIID(txn, "ad2f3b0c-e356-43d4-a483-fba79479d7e4")
	require.NoError(t, err)

	require.Len(t, cids, 1)
	require.Equal(t, "QmY7gN6AfKSoR7DNEjcUyXRYS85giD1YXN62cWVzS5zfus", cids[0].String())
}

func TestV0_CidOwners(t *testing.T) {
	t.Parallel()
	c1, _ := util.CidFromString("QmY7gN6AfKSoR7DNEjcUyXRYS85giD1YXN62cWVzS5zfus")
	c2, _ := util.CidFromString("QmX5J6NujFycQyoMvHXjTNmtvqDnn8TN6wAVQJ4Ap2GMnq")
	expectedOwners := map[cid.Cid][]ffs.APIID{
		c1: {ffs.APIID("ad2f3b0c-e356-43d4-a483-fba79479d7e4"), ffs.APIID("fb79f525-a3c4-47f0-94e5-e344c5b1dec5")},
		c2: {ffs.APIID("2bef4790-a47a-4a48-90da-a89f93ab6310")},
	}
	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v1_Trackstore.pre")

	txn, _ := ds.NewTransaction(false)
	owners, err := v0CidOwners(txn)
	require.NoError(t, err)

	require.Equal(t, len(expectedOwners), len(owners))
	for k1, v1 := range expectedOwners {
		v2, ok := owners[k1]
		require.True(t, ok)
		sort.Slice(v2, func(i, j int) bool {
			return v2[i].String() < v2[j].String()
		})
		require.Equal(t, v1, v2)
	}
}

'''
'''--- Filecoin/powergate/migration/migration2.go ---
package migration

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/ffs"
)

// V2StorageInfoDealIDs contains the logic to upgrade a datastore from
// version 1 to version 2. Transactionality is disabled since is a big migration.
var V2StorageInfoDealIDs = Migration{
	UseTxn: false,
	Run: func(ds datastoreReaderWriter) error {
		propDealIDMap, err := v2GenProposalCidToDealID(ds)
		if err != nil {
			return fmt.Errorf("getting cid owners: %s", err)
		}
		log.Infof("Starting DealID filling...")
		if err := v2MigrationDealIDFilling(ds, propDealIDMap); err != nil {
			return fmt.Errorf("migrating job logger: %s", err)
		}
		log.Infof("DealID filling migration finished")

		return nil
	},
}

func v2GenProposalCidToDealID(ds datastoreReaderWriter) (map[cid.Cid]uint64, error) {
	ret := map[cid.Cid]uint64{}
	qs := []query.Query{{Prefix: "/deals/storage-pending"}, {Prefix: "/deals/storage-final"}}

	for _, q := range qs {
		var lock sync.Mutex
		var errors []string
		lim := make(chan struct{}, 1000)

		res, err := ds.Query(q)
		if err != nil {
			return nil, fmt.Errorf("querying storage info: %s", err)
		}
		defer func() {
			_ = res.Close()
		}()

		for r := range res.Next() {
			if r.Error != nil {
				return nil, fmt.Errorf("query result: %s", r.Error)
			}
			lim <- struct{}{}

			r := r
			go func() {
				defer func() { <-lim }()
				var dr deals.StorageDealRecord
				if err := json.Unmarshal(r.Value, &dr); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("unmarshaling query result: %s", err))
					lock.Unlock()
					return
				}
				if dr.DealInfo.DealID != 0 {
					lock.Lock()
					ret[dr.DealInfo.ProposalCid] = dr.DealInfo.DealID
					lock.Unlock()
				}
			}()
		}
		for i := 0; i < cap(lim); i++ {
			lim <- struct{}{}
		}

		if len(errors) > 0 {
			for _, m := range errors {
				log.Error(m)
			}
			return nil, fmt.Errorf("map build had %d errors", len(errors))
		}
	}

	return ret, nil
}

type v1PartialStorageInfo struct {
	Cold v1PartialCold
}

type v1PartialCold struct {
	Filecoin v1PartialFilecoinInfo
}

type v1PartialFilecoinInfo struct {
	Proposals []v1PartialFilStorage
}

type v1PartialFilStorage struct {
	ProposalCid cid.Cid
}

func v2MigrationDealIDFilling(ds datastoreReaderWriter, propsDealID map[cid.Cid]uint64) error {
	log.Infof("Total map size: %d", len(propsDealID))
	q := query.Query{Prefix: "/ffs/scheduler/cistore_v2"} // /ffs/scheduler/cistore_v2/<iid>/<cid>
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying storage info store: %s", err)
	}
	defer func() { _ = res.Close() }()

	var lock sync.Mutex
	var errors []string
	lim := make(chan struct{}, 1000)

	var cantBeMapped, canBeMapped int
	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating result: %s", r.Error)
		}
		lim <- struct{}{}

		r := r
		go func() {
			defer func() { <-lim }()

			var oldCi v1PartialStorageInfo
			var newCi ffs.StorageInfo
			if err := json.Unmarshal(r.Value, &oldCi); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("unmarshaling storage info from datastore: %s", err))
				lock.Unlock()
				return
			}
			if err := json.Unmarshal(r.Value, &newCi); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("unmarshaling storage info from datastore: %s", err))
				lock.Unlock()
				return
			}

			var filledProposals []ffs.FilStorage
			for i, p := range oldCi.Cold.Filecoin.Proposals {
				dealID, ok := propsDealID[p.ProposalCid]
				if !ok {
					lock.Lock()
					cantBeMapped++
					lock.Unlock()
					continue
				}
				lock.Lock()
				canBeMapped++
				lock.Unlock()
				newCi.Cold.Filecoin.Proposals[i].DealID = dealID
				filledProposals = append(filledProposals, newCi.Cold.Filecoin.Proposals[i])
			}
			newCi.Cold.Filecoin.Proposals = filledProposals

			buf, err := json.Marshal(newCi)
			if err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("marshaling storage info for datastore: %s", err))
				lock.Unlock()
			}
			if err := ds.Put(datastore.NewKey(r.Key), buf); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("put storage info in datastore: %s", err))
				lock.Unlock()
			}
		}()
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	log.Infof("Couldn't be mapped %d, Could be mapped %d", cantBeMapped, canBeMapped)

	if len(errors) > 0 {
		for _, m := range errors {
			log.Error(m)
		}
		return fmt.Errorf("migration had %d errors", len(errors))
	}

	return nil
}

'''
'''--- Filecoin/powergate/migration/migration2_storageinfo_test.go ---
package migration

import (
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

func TestV2_StorageInfo(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v2_StorageInfo.pre")

	propDealID, err := v2GenProposalCidToDealID(ds)
	require.NoError(t, err)

	txn, _ := ds.NewTransaction(false)
	err = v2MigrationDealIDFilling(txn, propDealID)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v2_StorageInfo.post")
}

'''
'''--- Filecoin/powergate/migration/migration3.go ---
package migration

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
)

type storageJob struct {
	ID        string
	APIID     string
	Cid       cid.Cid
	CreatedAt int64
}

// V3StorageJobsIndexMigration contains the logic to upgrade a datastore from
// version 2 to version 3.
var V3StorageJobsIndexMigration = Migration{
	UseTxn: false,
	Run: func(ds datastoreReaderWriter) error {
		q := query.Query{Prefix: "/ffs/scheduler/sjstore/job"}
		res, err := ds.Query(q)
		if err != nil {
			return fmt.Errorf("querying sjstore jobs: %s", err)
		}
		defer func() { _ = res.Close() }()

		var count int
		var lock sync.Mutex
		var errors []string
		lim := make(chan struct{}, 1000)
		for r := range res.Next() {
			if r.Error != nil {
				return fmt.Errorf("iterating results: %s", r.Error)
			}

			lim <- struct{}{}

			r := r
			go func() {
				defer func() { <-lim }()

				var job storageJob
				if err := json.Unmarshal(r.Value, &job); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("unmarshaling job: %s", err))
					lock.Unlock()
					return
				}

				apiidKey := datastore.NewKey("/ffs/scheduler/sjstore/apiid").ChildString(job.APIID).ChildString(job.Cid.String()).ChildString(fmt.Sprintf("%d", job.CreatedAt))
				cidKey := datastore.NewKey("/ffs/scheduler/sjstore/cid").ChildString(job.Cid.String()).ChildString(job.APIID).ChildString(fmt.Sprintf("%d", job.CreatedAt))

				if err := ds.Put(apiidKey, []byte(job.ID)); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("putting apiid index record in datastore: %s", err))
					lock.Unlock()
					return

				}
				if err := ds.Put(cidKey, []byte(job.ID)); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("putting cid index record in datastore: %s", err))
					lock.Unlock()
					return

				}

			}()
			count++
		}

		for i := 0; i < cap(lim); i++ {
			lim <- struct{}{}
		}

		if len(errors) > 0 {
			for _, m := range errors {
				log.Error(m)
			}
			return fmt.Errorf("migration had %d errors", len(errors))
		}

		log.Infof("migration indexed %d storage-jobs", count)

		return nil
	},
}

'''
'''--- Filecoin/powergate/migration/migration3_test.go ---
package migration

import (
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

func TestV3(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v3_StorageJobs.pre")
	txn, _ := ds.NewTransaction(false)

	err := V3StorageJobsIndexMigration.Run(txn)
	require.NoError(t, err)
	require.NoError(t, txn.Commit())

	post(t, ds, "testdata/v3_StorageJobs.post")
}

'''
'''--- Filecoin/powergate/migration/migration4.go ---
package migration

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/textileio/powergate/v2/deals"
	"github.com/textileio/powergate/v2/util"
)

// V4RecordsMigration contains the logic to upgrade a datastore from
// version 3 to version 4.
var V4RecordsMigration = Migration{
	UseTxn: false,
	Run: func(ds datastoreReaderWriter) error {
		if err := v4IncludeIDInRetrievalRecords(ds); err != nil {
			return fmt.Errorf("including ids in retrieval records: %s", err)
		}

		if err := v4PopulateUpdatedAtIndex(ds); err != nil {
			return fmt.Errorf("populating updated at index: %s", err)
		}

		return nil
	},
}

type v4PartialRecordTime struct {
	Time int64
}

func v4PopulateUpdatedAtIndex(ds datastoreReaderWriter) error {
	prefixes := []string{"/deals/storage-pending", "/deals/storage-final", "/deals/retrieval"}

	for _, prefix := range prefixes {
		q := query.Query{Prefix: prefix}
		res, err := ds.Query(q)
		if err != nil {
			return fmt.Errorf("querying records: %s", err)
		}
		defer func() { _ = res.Close() }()

		var count int
		var lock sync.Mutex
		var errors []string
		lim := make(chan struct{}, 1000)
		var nanoCounter int64
		for r := range res.Next() {
			if r.Error != nil {
				return fmt.Errorf("iterating results: %s", r.Error)
			}

			lim <- struct{}{}

			r := r
			go func() {
				defer func() { <-lim }()

				var rec v4PartialRecordTime
				if err := json.Unmarshal(r.Value, &rec); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("unmarshaling record: %s", err))
					lock.Unlock()
					return
				}

				// This shouldn't happen.
				if rec.Time == 0 {
					lock.Lock()
					errors = append(errors, "time is zero")
					lock.Unlock()
					return
				}

				// The index stores at the nano precision.
				lock.Lock()
				updatedAtTime := time.Unix(rec.Time, nanoCounter).UnixNano()
				nanoCounter++
				lock.Unlock()

				var indexKey datastore.Key
				if strings.HasPrefix(r.Key, "/deals/storage-") {
					indexKey = datastore.NewKey("/deals/updatedatidx/storage").ChildString(strconv.FormatInt(updatedAtTime, 10))
					var sdr deals.StorageDealRecord
					if err := json.Unmarshal(r.Value, &sdr); err != nil {
						lock.Lock()
						errors = append(errors, fmt.Sprintf("unmarshaling storage deal record: %s", r.Key))
						lock.Unlock()
						return
					}
					sdr.UpdatedAt = updatedAtTime
					buf, err := json.Marshal(sdr)
					if err != nil {
						lock.Lock()
						errors = append(errors, fmt.Sprintf("marshaling storage deal record: %s", r.Key))
						lock.Unlock()
						return
					}
					r.Value = buf
				} else if strings.HasPrefix(r.Key, "/deals/retrieval") {
					indexKey = datastore.NewKey("/deals/updatedatidx/retrieval").ChildString(strconv.FormatInt(updatedAtTime, 10))
					var rr deals.RetrievalDealRecord
					if err := json.Unmarshal(r.Value, &rr); err != nil {
						lock.Lock()
						errors = append(errors, fmt.Sprintf("unmarshaling retrieval record: %s", r.Key))
						lock.Unlock()
						return
					}
					rr.UpdatedAt = updatedAtTime
					buf, err := json.Marshal(rr)
					if err != nil {
						lock.Lock()
						errors = append(errors, fmt.Sprintf("marshaling retrieval record: %s", r.Key))
						lock.Unlock()
						return
					}
					r.Value = buf
				} else {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("unknown prefix: %s", r.Key))
					lock.Unlock()
					return
				}

				// With TrimPrefix since the Key should be relative
				// to the namespace of the store, and not the full-key.
				if err := ds.Put(indexKey, []byte(strings.TrimPrefix(r.Key, "/deals"))); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("saving updated-at index: %s", err))
					lock.Unlock()
					return
				}

				if err := ds.Put(datastore.NewKey(r.Key), r.Value); err != nil {
					lock.Lock()
					errors = append(errors, fmt.Sprintf("saving updated-at field: %s", err))
					lock.Unlock()
					return
				}
			}()
			count++
		}

		for i := 0; i < cap(lim); i++ {
			lim <- struct{}{}
		}

		if len(errors) > 0 {
			for _, m := range errors {
				log.Error(m)
			}
			return fmt.Errorf("migration had %d errors", len(errors))
		}

		log.Infof("migration indexed %d %s records", count, prefix)
	}
	return nil
}

func v4IncludeIDInRetrievalRecords(ds datastoreReaderWriter) error {
	q := query.Query{Prefix: "/deals/retrieval"}
	res, err := ds.Query(q)
	if err != nil {
		return fmt.Errorf("querying retrieval records: %s", err)
	}
	defer func() { _ = res.Close() }()

	var count int
	var lock sync.Mutex
	var errors []string
	lim := make(chan struct{}, 1000)
	for r := range res.Next() {
		if r.Error != nil {
			return fmt.Errorf("iterating results: %s", r.Error)
		}

		lim <- struct{}{}

		r := r
		go func() {
			defer func() { <-lim }()

			var rr deals.RetrievalDealRecord
			if err := json.Unmarshal(r.Value, &rr); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("unmarshaling retrieval record: %s", err))
				lock.Unlock()
				return
			}

			rr.ID = v4RetrievalID(rr)
			buf, err := json.Marshal(rr)
			if err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("marshaling retrieval record: %s", err))
				lock.Unlock()
				return
			}

			if err := ds.Put(datastore.NewKey(r.Key), buf); err != nil {
				lock.Lock()
				errors = append(errors, fmt.Sprintf("put retrieval record: %s", err))
				lock.Unlock()
				return
			}
		}()
		count++
	}

	for i := 0; i < cap(lim); i++ {
		lim <- struct{}{}
	}

	if len(errors) > 0 {
		for _, m := range errors {
			log.Error(m)
		}
		return fmt.Errorf("migration had %d errors", len(errors))
	}

	log.Infof("migration populated %d retrieval records ids", count)

	return nil
}

func v4RetrievalID(rr deals.RetrievalDealRecord) string {
	str := fmt.Sprintf("%v%v%v%v", rr.Time, rr.Addr, rr.DealInfo.Miner, util.CidToString(rr.DealInfo.RootCid))
	sum := md5.Sum([]byte(str))

	return fmt.Sprintf("%x", sum[:])
}

'''
'''--- Filecoin/powergate/migration/migration4_test.go ---
package migration

import (
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/tests"
)

func TestV4(t *testing.T) {
	t.Parallel()

	ds := tests.NewTxMapDatastore()

	pre(t, ds, "testdata/v4_Records.pre")

	err := V4RecordsMigration.Run(ds)
	require.NoError(t, err)

	post(t, ds, "testdata/v4_Records.post")
}

'''
'''--- Filecoin/powergate/migration/migration5.go ---
package migration

import (
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
)

// V5DeleteOldMinerIndex contains the logic to upgrade a datastore from
// version 4 to version 5.
var V5DeleteOldMinerIndex = Migration{
	UseTxn: false,
	Run: func(ds datastoreReaderWriter) error {
		q := query.Query{Prefix: "/index/miner/chainstore"}
		res, err := ds.Query(q)
		if err != nil {
			return fmt.Errorf("querying records: %s", err)
		}
		defer func() { _ = res.Close() }()

		var count int
		for v := range res.Next() {
			if err := ds.Delete(datastore.NewKey(v.Key)); err != nil {
				return fmt.Errorf("deleting miner chainstore key: %s", err)
			}
			count++
		}
		log.Infof("deleted %d chainstore keys", count)

		return nil
	},
}

'''
'''--- Filecoin/powergate/migration/migration_test.go ---
package migration

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	badger "github.com/ipfs/go-ds-badger2"
	"github.com/stretchr/testify/require"
	mongods "github.com/textileio/go-ds-mongo"
	"github.com/textileio/powergate/v2/tests"

	logger "github.com/ipfs/go-log/v2"
)

func TestEmptyDatastore(t *testing.T) {
	t.Parallel()

	ms := map[int]Migration{
		1: {
			UseTxn: true,
			Run: func(_ datastoreReaderWriter) error {
				return fmt.Errorf("This migration shouldn't be run on empty database")
			},
		},
	}
	m := newMigrator(ms, true)

	v, empty, err := m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 0, v)
	require.True(t, empty)

	err = m.Ensure()
	require.NoError(t, err)

	v, _, err = m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 1, v)
}

func TestNonEmptyDatastore(t *testing.T) {
	t.Parallel()

	ms := map[int]Migration{
		1: {
			UseTxn: true,
			Run: func(_ datastoreReaderWriter) error {
				return nil
			},
		},
	}
	m := newMigrator(ms, false)

	v, empty, err := m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 0, v)
	require.False(t, empty)

	err = m.Ensure()
	require.NoError(t, err)

	v, _, err = m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 1, v)
}

func TestForwardOnly(t *testing.T) {
	t.Parallel()

	ms := map[int]Migration{
		1: {
			UseTxn: true,
			Run: func(_ datastoreReaderWriter) error {
				return nil
			},
		},
	}

	m := newMigrator(ms, false)
	err := m.bootstrapEmptyDatastore(10)
	require.NoError(t, err)

	v, _, err := m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 10, v)

	err = m.Ensure()
	require.Error(t, err)
}

func TestNoop(t *testing.T) {
	t.Parallel()

	ms := map[int]Migration{
		1: {
			UseTxn: true,
			Run: func(_ datastoreReaderWriter) error {
				return nil
			},
		},
	}
	m := newMigrator(ms, false)

	err := m.Ensure()
	require.NoError(t, err)

	err = m.Ensure()
	require.NoError(t, err)
}

func TestFailingMigration(t *testing.T) {
	ms := map[int]Migration{
		1: {
			UseTxn: true,
			Run: func(_ datastoreReaderWriter) error {
				return fmt.Errorf("I failed")
			},
		},
	}
	m := newMigrator(ms, false)

	v, _, err := m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 0, v)

	err = m.Ensure()
	require.Error(t, err)

	v, _, err = m.getCurrentVersion()
	require.NoError(t, err)
	require.Equal(t, 0, v)
}

func TestRealDataBadgerFromV0(t *testing.T) {
	logger.SetDebugLogging()
	_ = logger.SetLogLevel("badger", "error")
	tmpDir := t.TempDir()
	err := copyDir("testdata/badgerdumpv0", tmpDir+"/badgerdump")
	require.NoError(t, err)

	opts := &badger.DefaultOptions
	ds, err := badger.NewDatastore(tmpDir+"/badgerdump", opts)
	require.NoError(t, err)
	defer func() { require.NoError(t, ds.Close()) }()

	migrations := map[int]Migration{
		1: V1MultitenancyMigration,
	}
	m := New(ds, migrations)
	err = m.Ensure()
	require.NoError(t, err)
}

func TestRealDataBadgerFromV1(t *testing.T) {
	logger.SetDebugLogging()
	_ = logger.SetLogLevel("badger", "error")
	tmpDir := t.TempDir()
	err := copyDir("testdata/badgerdumpv1", tmpDir+"/badgerdump")
	require.NoError(t, err)

	opts := &badger.DefaultOptions
	ds, err := badger.NewDatastore(tmpDir+"/badgerdump", opts)
	require.NoError(t, err)
	defer func() { require.NoError(t, ds.Close()) }()

	migrations := map[int]Migration{
		1: V1MultitenancyMigration,
		2: V2StorageInfoDealIDs,
	}
	m := New(ds, migrations)
	err = m.Ensure()
	require.NoError(t, err)
}

func TestRealDataBadgerFromV2(t *testing.T) {
	logger.SetDebugLogging()
	_ = logger.SetLogLevel("badger", "error")
	tmpDir := t.TempDir()
	err := copyDir("testdata/badgerdumpv1", tmpDir+"/badgerdump")
	require.NoError(t, err)

	opts := &badger.DefaultOptions
	ds, err := badger.NewDatastore(tmpDir+"/badgerdump", opts)
	require.NoError(t, err)
	defer func() { require.NoError(t, ds.Close()) }()

	migrations := map[int]Migration{
		1: V1MultitenancyMigration,
		2: V2StorageInfoDealIDs,
		3: V3StorageJobsIndexMigration,
	}
	m := New(ds, migrations)
	err = m.Ensure()
	require.NoError(t, err)
}

func TestRealDataBadgerFromV3(t *testing.T) {
	logger.SetDebugLogging()
	_ = logger.SetLogLevel("badger", "error")
	tmpDir := t.TempDir()
	err := copyDir("testdata/badgerdumpv1", tmpDir+"/badgerdump")
	require.NoError(t, err)

	opts := &badger.DefaultOptions
	ds, err := badger.NewDatastore(tmpDir+"/badgerdump", opts)
	require.NoError(t, err)
	defer func() { require.NoError(t, ds.Close()) }()

	migrations := map[int]Migration{
		1: V1MultitenancyMigration,
		2: V2StorageInfoDealIDs,
		3: V3StorageJobsIndexMigration,
		4: V4RecordsMigration,
		5: V5DeleteOldMinerIndex,
	}
	m := New(ds, migrations)
	err = m.Ensure()
	require.NoError(t, err)
}

func TestRealDataRemoteMongo(t *testing.T) {
	t.SkipNow()
	logger.SetDebugLogging()
	mongoCtx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()
	mongoURI := ""
	mongoDB := ""
	ds, err := mongods.New(mongoCtx, mongoURI, mongoDB, mongods.WithCollName("migration_kvstore"), mongods.WithOpTimeout(time.Hour), mongods.WithTxnTimeout(time.Hour))
	require.NoError(t, err)
	defer func() { require.NoError(t, ds.Close()) }()

	migrations := map[int]Migration{
		1: V1MultitenancyMigration,
		2: V2StorageInfoDealIDs,
	}
	m := New(ds, migrations)
	err = m.Ensure()
	require.NoError(t, err)
}

func newMigrator(migrations map[int]Migration, empty bool) *Migrator {
	ds := tests.NewTxMapDatastore()
	m := New(ds, migrations)

	if !empty {
		_ = ds.Put(datastore.NewKey("foo"), []byte("bar"))
	}

	return m
}

func pre(t *testing.T, ds datastore.TxnDatastore, path string) {
	t.Helper()
	f, err := os.Open(path)
	require.NoError(t, err)
	defer func() { require.NoError(t, f.Close()) }()

	s := bufio.NewScanner(f)
	for s.Scan() {
		parts := strings.SplitN(s.Text(), ",", 2)
		err = ds.Put(datastore.NewKey(parts[0]), []byte(parts[1]))
		require.NoError(t, err)
	}
}

func post(t *testing.T, ds datastore.TxnDatastore, path string) {
	t.Helper()

	f, err := os.Open(path)
	require.NoError(t, err)
	defer func() { require.NoError(t, f.Close()) }()

	current := map[string][]byte{}
	q := query.Query{}
	res, err := ds.Query(q)
	require.NoError(t, err)
	defer func() { require.NoError(t, res.Close()) }()
	for r := range res.Next() {
		require.NoError(t, r.Error)
		current[r.Key] = r.Value
	}

	expected := map[string][]byte{}
	s := bufio.NewScanner(f)
	for s.Scan() {
		parts := strings.SplitN(s.Text(), ",", 2)
		expected[parts[0]] = []byte(parts[1])
	}

	require.Equal(t, len(expected), len(current))
	for k1, v1 := range current {
		v2, ok := expected[k1]
		if !bytes.Equal(v2, v1) {
			fmt.Printf("%s,%s\n", k1, v2)
			fmt.Printf("%s,%s\n\n", k1, v1)
		}
		require.True(t, ok)
		require.Equal(t, v2, v1)
	}
}

func copyFile(src, dst string) (err error) {
	in, err := os.Open(src)
	if err != nil {
		return
	}
	defer func() { _ = in.Close() }()

	out, err := os.Create(dst)
	if err != nil {
		return
	}
	defer func() {
		if e := out.Close(); e != nil {
			err = e
		}
	}()

	_, err = io.Copy(out, in)
	if err != nil {
		return
	}

	err = out.Sync()
	if err != nil {
		return
	}

	si, err := os.Stat(src)
	if err != nil {
		return
	}
	err = os.Chmod(dst, si.Mode())
	if err != nil {
		return
	}

	return
}

func copyDir(src string, dst string) (err error) {
	src = filepath.Clean(src)
	dst = filepath.Clean(dst)

	si, err := os.Stat(src)
	if err != nil {
		return err
	}
	if !si.IsDir() {
		return fmt.Errorf("source is not a directory")
	}

	_, err = os.Stat(dst)
	if err != nil && !os.IsNotExist(err) {
		return
	}
	if err == nil {
		return fmt.Errorf("destination already exists")
	}

	err = os.MkdirAll(dst, si.Mode())
	if err != nil {
		return
	}

	entries, err := ioutil.ReadDir(src)
	if err != nil {
		return
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			err = copyDir(srcPath, dstPath)
			if err != nil {
				return
			}
		} else {
			// Skip symlinks.
			if entry.Mode()&os.ModeSymlink != 0 {
				continue
			}

			err = copyFile(srcPath, dstPath)
			if err != nil {
				return
			}
		}
	}

	return
}

'''
'''--- Filecoin/powergate/reputation/internal/source/source.go ---
package source

import (
	"context"
	"time"

	ma "github.com/multiformats/go-multiaddr"
)

// Source is an external source of reputation information.
type Source struct {
	ID          string
	Weight      float64
	Scores      map[string]int
	Maddr       ma.Multiaddr
	LastFetched *time.Time
}

// Refresh pulls fresh information from source.
func (s *Source) Refresh(ctx context.Context) error {
	// ToDo: pull from Maddr fresh reputation information
	return nil
}

'''
'''--- Filecoin/powergate/reputation/internal/source/store.go ---
package source

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	logging "github.com/ipfs/go-log/v2"
)

var (
	log = logging.Logger("reputation-source-store")

	// ErrAlreadyExists returns when the soure already exists in Store.
	ErrAlreadyExists = errors.New("source already exists")
	// ErrDoesntExists returns when the source isn't in the Store.
	ErrDoesntExists = errors.New("source doesn't exist")

	baseKey = datastore.NewKey("/reputation/store")
)

// Store contains Sources information.
type Store struct {
	ds datastore.TxnDatastore
}

// NewStore returns a new SourceStore.
func NewStore(ds datastore.TxnDatastore) *Store {
	return &Store{
		ds: ds,
	}
}

// Add adds a new Source to the store.
func (ss *Store) Add(s Source) error {
	txn, err := ss.ds.NewTransaction(false)
	if err != nil {
		return err
	}
	defer txn.Discard()

	k := genKey(s.ID)
	ok, err := txn.Has(k)
	if err != nil {
		return err
	}
	if ok {
		return ErrAlreadyExists
	}
	return ss.put(txn, s)
}

// Update updates a Source.
func (ss *Store) Update(s Source) error {
	txn, err := ss.ds.NewTransaction(false)
	if err != nil {
		return err
	}
	k := genKey(s.ID)
	ok, err := txn.Has(k)
	if err != nil {
		return err
	}
	if !ok {
		return ErrDoesntExists
	}
	return ss.put(txn, s)
}

// GetAll returns all Sources.
func (ss *Store) GetAll() ([]Source, error) {
	txn, err := ss.ds.NewTransaction(true)
	if err != nil {
		return nil, err
	}
	defer txn.Discard()
	q := query.Query{Prefix: baseKey.String()}
	res, err := txn.Query(q)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err := res.Close(); err != nil {
			log.Errorf("error when closing query result: %s", err)
		}
	}()
	var ret []Source
	for r := range res.Next() {
		if r.Error != nil {
			return nil, fmt.Errorf("iter next: %s", r.Error)
		}
		s := Source{}
		if err := json.Unmarshal(r.Value, &s); err != nil {
			return nil, err
		}
		ret = append(ret, s)
	}
	return ret, nil
}

func (ss *Store) put(txn datastore.Txn, s Source) error {
	b, err := json.Marshal(s)
	if err != nil {
		return err
	}
	if err := txn.Put(genKey(s.ID), b); err != nil {
		return err
	}
	return txn.Commit()
}

func genKey(id string) datastore.Key {
	return baseKey.ChildString(id)
}

'''
'''--- Filecoin/powergate/reputation/reputation.go ---
package reputation

import (
	"context"
	"fmt"
	"math"
	"sort"
	"sync"
	"time"

	"github.com/ipfs/go-datastore"
	logging "github.com/ipfs/go-log/v2"
	ma "github.com/multiformats/go-multiaddr"
	"github.com/textileio/powergate/v2/index/ask"
	"github.com/textileio/powergate/v2/index/faults"
	"github.com/textileio/powergate/v2/index/miner"
	"github.com/textileio/powergate/v2/reputation/internal/source"
)

var (
	updateSourcesInterval = time.Second * 90
	log                   = logging.Logger("reputation")
)

// Module consolidates different sources of information to create a
// reputation rank of FC miners.
type Module struct {
	ds      datastore.TxnDatastore
	sources *source.Store

	mi miner.Module
	fi faults.Module
	ai ask.Module

	lockIndex sync.Mutex
	mIndex    miner.IndexSnapshot
	fIndex    faults.IndexSnapshot
	aIndex    ask.Index

	lockScores sync.Mutex
	rebuild    chan struct{}
	scores     []MinerScore

	ctx      context.Context
	cancel   context.CancelFunc
	finished chan struct{}
}

// MinerScore contains a score for a miner.
type MinerScore struct {
	Addr  string
	Score int
}

// New returns a new reputation Module.
func New(ds datastore.TxnDatastore, mi miner.Module, fi faults.Module, ai ask.Module) *Module {
	ctx, cancel := context.WithCancel(context.Background())
	rm := &Module{
		ds: ds,
		mi: mi,
		fi: fi,
		ai: ai,

		mIndex: mi.Get(),
		fIndex: fi.Get(),
		aIndex: ai.Get(),

		rebuild:  make(chan struct{}, 1),
		ctx:      ctx,
		cancel:   cancel,
		sources:  source.NewStore(ds),
		finished: make(chan struct{}),
	}

	go rm.updateSources()
	go rm.indexBuilder()
	go rm.subscribeIndexes()

	return rm
}

// AddSource adds a new external Source to be considered for reputation generation.
func (rm *Module) AddSource(id string, maddr ma.Multiaddr) error {
	return rm.sources.Add(source.Source{ID: id, Maddr: maddr})
}

// QueryMiners makes a filtered query on the scored-sorted miner list.
// Empty filter slices represent no-filters applied.
func (rm *Module) QueryMiners(excludedMiners []string, countryCodes []string, trustedMiners []string) ([]MinerScore, error) {
	rm.lockScores.Lock()
	defer rm.lockScores.Unlock()

	var mr []MinerScore
	pmr := make(map[string]struct{})
	for _, tm := range trustedMiners {
		for _, m := range rm.scores {
			if m.Addr == tm {
				pmr[tm] = struct{}{}
				mr = append(mr, m)
				break
			}
		}
	}
	for _, m := range rm.scores {
		if _, ok := pmr[m.Addr]; ok {
			continue
		}
		skip := false
		for _, mb := range excludedMiners {
			if mb == m.Addr {
				skip = true
				break
			}
		}
		if skip {
			continue
		}

		if len(countryCodes) != 0 {
			minerMeta, ok := rm.mIndex.Meta.Info[m.Addr]
			if !ok {
				continue
			}
			skip := true
			for _, country := range countryCodes {
				if country == minerMeta.Location.Country {
					skip = false
					break
				}
			}
			if skip {
				continue
			}
		}
		mr = append(mr, m)
	}
	return mr, nil
}

// GetTopMiners gets the top n miners with best score.
func (rm *Module) GetTopMiners(n int) ([]MinerScore, error) {
	if n < 1 {
		return nil, fmt.Errorf("the number of miners should be greater than zero")
	}
	rm.lockScores.Lock()
	if n > len(rm.scores) {
		n = len(rm.scores)
	}
	mr := make([]MinerScore, 0, n)
	for i := 0; i < n; i++ {
		mr = append(mr, rm.scores[i])
	}
	rm.lockScores.Unlock()
	return mr, nil
}

// Close closes the reputation Module.
func (rm *Module) Close() error {
	log.Info("closing...")
	defer log.Info("closed")
	rm.cancel()
	<-rm.finished
	return nil
}

// subscribeIndexes listen to all sources changes to trigger score regeneration.
func (rm *Module) subscribeIndexes() {
	defer close(rm.finished)
	subMi := rm.mi.Listen()
	subSi := rm.fi.Listen()
	subAi := rm.ai.Listen()

	rm.rebuild <- struct{}{}
	for {
		select {
		case <-rm.ctx.Done():
			log.Info("terminating background index update")
			return
		case <-subMi:
			rm.lockIndex.Lock()
			rm.mIndex = rm.mi.Get()
		case <-subSi:
			rm.lockIndex.Lock()
			rm.fIndex = rm.fi.Get()
		case <-subAi:
			rm.lockIndex.Lock()
			rm.aIndex = rm.ai.Get()
		}
		rm.lockIndex.Unlock()
		select {
		case rm.rebuild <- struct{}{}:
		default:
		}
	}
}

// indexBuilder regenerates score information from all known sources.
func (rm *Module) indexBuilder() {
	for range rm.rebuild {
		log.Info("rebuilding index")
		start := time.Now()

		sources, err := rm.sources.GetAll()
		if err != nil {
			log.Errorf("getting sources: %s", err)
			return
		}
		rm.lockIndex.Lock()
		minerIndex := rm.mIndex
		faultsIndex := rm.fIndex
		askIndex := rm.aIndex
		rm.lockIndex.Unlock()

		scores := make([]MinerScore, 0, len(askIndex.Storage))
		for addr := range askIndex.Storage {
			score := calculateScore(addr, minerIndex, faultsIndex, askIndex, sources)
			scores = append(scores, score)
		}
		sort.Slice(scores, func(i, j int) bool {
			return scores[i].Score > scores[j].Score
		})

		rm.lockScores.Lock()
		rm.scores = scores
		rm.lockScores.Unlock()

		log.Infof("built scores for %d miners in %dms", len(scores), time.Since(start).Milliseconds())
	}
}

// calculateScore calculates the score for a miner.
func calculateScore(addr string, mi miner.IndexSnapshot, si faults.IndexSnapshot, ai ask.Index, ss []source.Source) MinerScore {
	miner := mi.OnChain.Miners[addr]
	powerScore := miner.RelativePower

	var faultsScore float64
	if faults, ok := si.Miners[addr]; ok {
		faultsScore = 1 / math.Pow(2, float64(len(faults.Epochs)))
	}

	var externalScore float64
	for _, s := range ss {
		score, exist := s.Scores[addr]
		if !exist {
			continue
		}
		externalScore = s.Weight * float64(score)
	}

	var askScore float64
	if a, ok := ai.Storage[addr]; ok && a.Price < ai.StorageMedianPrice {
		askScore = 1
	}

	score := 50*faultsScore + 20*powerScore + 20*externalScore + 100*askScore
	return MinerScore{
		Addr:  addr,
		Score: int(score),
	}
}

func (rm *Module) updateSources() {
	for {
		select {
		case <-rm.ctx.Done():
			log.Info("terminating background sources update")
			return
		case <-time.After(updateSourcesInterval):
			sources, err := rm.sources.GetAll()
			if err != nil {
				log.Errorf("error getting all sources from store: %s", err)
				continue
			}
			var wg sync.WaitGroup
			wg.Add(len(sources))
			for _, s := range sources {
				go func(s source.Source) {
					defer wg.Done()
					if err := s.Refresh(rm.ctx); err != nil {
						log.Error("error refreshing source %s: %s", s.ID, err)
						return
					}
					if err := rm.sources.Update(s); err != nil {
						log.Error("error persisting updated source %s: %s", s.ID, err)
						return
					}
				}(s)
			}
			wg.Wait()
			log.Debug("all sources refreshed successfully")
		}
	}
}

'''
'''--- Filecoin/powergate/scripts/gen-js-protos.sh ---
LIB_VERSION=$1
PROTOS_PATH=$2
OUT_PATH=$3

LIB_PREFIX="@textile"
LIB_POSTFIX="grpc-powergate-client"
LIB_NAME="$LIB_PREFIX/$LIB_POSTFIX"
LIB_SRC_DIR="dist"

PROTOC_GEN_TS_PATH="$OUT_PATH/node_modules/.bin/protoc-gen-ts"
PTOTOC_GEN_OUT_DIR="$OUT_PATH/$LIB_SRC_DIR"

if [ -d "$OUT_PATH" ] 
then
  rm -rf $OUT_PATH
fi

mkdir -p $PTOTOC_GEN_OUT_DIR

printf '{"name":"%s", "version":"%s", "files":["%s"]}' $LIB_NAME $LIB_VERSION $LIB_SRC_DIR > $OUT_PATH/package.json

(cd $OUT_PATH && npm install --save-dev ts-protoc-gen)
(cd $OUT_PATH && npm install google-protobuf@^3.12.2 @improbable-eng/grpc-web @types/google-protobuf@^3.7.2)

ABS_OUT_PATH="$( cd $OUT_PATH >/dev/null 2>&1 ; pwd -P )"
ABS_PROTOS_PATH="$( cd $PROTOS_PATH >/dev/null 2>&1 ; pwd -P )"

PROTOS=$(find $ABS_PROTOS_PATH -path $ABS_OUT_PATH -prune -o -iname "*.proto" -print)

protoc \
    --plugin="protoc-gen-ts=${PROTOC_GEN_TS_PATH}" \
    --js_out="import_style=commonjs,binary:${PTOTOC_GEN_OUT_DIR}" \
    --ts_out="service=grpc-web:${PTOTOC_GEN_OUT_DIR}" \
    -I $ABS_PROTOS_PATH \
    ${PROTOS}
    

'''
'''--- Filecoin/powergate/scripts/gen-py-protos.sh ---
LIB_VERSION=$1
PROTOS_PATH=$2
OUT_PATH=$3
SRC_PATH=$OUT_PATH/src

if [ -d "$OUT_PATH" ] 
then
  rm -rf $OUT_PATH
fi

mkdir -p $SRC_PATH

cat << EOF > $OUT_PATH/setup.py
import setuptools

setuptools.setup(
    name="grpc_powergate_client",
    version="${LIB_VERSION}",
    author="Textile",
    author_email="contact@textile.io",
    url="https://github.com/textileio/powergate",
    packages=setuptools.find_packages(where="src"),
    package_dir={'': 'src'},
    install_requires=[
      'protobuf',
      'grpcio',
    ],
)
EOF

ABS_OUT_PATH="$( cd $OUT_PATH >/dev/null 2>&1 ; pwd -P )"
ABS_PROTOS_PATH="$( cd $PROTOS_PATH >/dev/null 2>&1 ; pwd -P )"

PROTOS=$(find $ABS_PROTOS_PATH -path $ABS_OUT_PATH -prune -o -iname "*.proto" -print)

python3 -m pip install grpcio-tools 
python3 -m grpc_tools.protoc -I$ABS_PROTOS_PATH --python_out=$SRC_PATH --grpc_python_out=$SRC_PATH $PROTOS

find $SRC_PATH -type d -exec touch {}/__init__.py \;

python3 -m pip install --user --upgrade setuptools wheel
cd $OUT_PATH && python3 setup.py sdist bdist_wheel

'''
'''--- Filecoin/powergate/signaler/signaler.go ---
package signaler

import (
	"sync"

	logging "github.com/ipfs/go-log/v2"
)

var (
	log = logging.Logger("broadcaster")
)

// Signaler allows subscribing to a singnaling hub.
type Signaler struct {
	lock      sync.Mutex
	listeners []chan struct{}
}

// New returns a new Signaler.
func New() *Signaler {
	return &Signaler{}
}

// Listen returns a new channel signaler.
func (s *Signaler) Listen() <-chan struct{} {
	c := make(chan struct{}, 1)
	s.lock.Lock()
	s.listeners = append(s.listeners, c)
	s.lock.Unlock()
	return c
}

// Unregister unregisters a channel signaler from the hub.
func (s *Signaler) Unregister(c chan struct{}) {
	s.lock.Lock()
	defer s.lock.Unlock()
	for i := range s.listeners {
		if s.listeners[i] == c {
			if len(s.listeners) == 1 {
				s.listeners = nil
				return
			}
			s.listeners[i] = s.listeners[len(s.listeners)-1]
			s.listeners = s.listeners[:len(s.listeners)-1]
			close(s.listeners[i])
			return
		}
	}
}

// Signal triggers a new notification to all listeners.
func (s *Signaler) Signal() {
	s.lock.Lock()
	defer s.lock.Unlock()
	for _, c := range s.listeners {
		select {
		case c <- struct{}{}:
		default:
			log.Warn("dropping signal on blocked listener")
		}
	}
}

// Close closes the Signaler. Any channel that wasn't explicitly unregistered,
// is closed.
func (s *Signaler) Close() {
	s.lock.Lock()
	defer s.lock.Unlock()
	for _, c := range s.listeners {
		close(c)
	}
}

'''
'''--- Filecoin/powergate/tests/auth.go ---
package tests

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	ma "github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
)

const (
	lotusHost = "127.0.0.1"
	lotusPort = 1234
)

// GetLotusToken returns the lotus token from a Lotus repo path.
func GetLotusToken(lotusFolderPath string) (string, error) {
	tokenFullPath := filepath.Join(lotusFolderPath, "token")
	if _, err := os.Stat(tokenFullPath); err != nil {
		if os.IsNotExist(err) {
			return createAdminToken()
		}
		return "", err
	}
	cmd := exec.Command("cat", tokenFullPath)
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return string(out), nil
}

func createAdminToken() (string, error) {
	cmd := exec.Command("lotus", "auth", "create-token", "--perm", "admin")
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return string(out), err
}

// ClientConfigMA returns the prepared multiaddress and Lotus token,
// to connect to a Lotus node.
func ClientConfigMA(t *testing.T) (ma.Multiaddr, string) {
	addr := fmt.Sprintf("/ip4/%v/tcp/%v", lotusHost, lotusPort)
	multi, err := ma.NewMultiaddr(addr)
	require.NoError(t, err)
	authToken, ok := os.LookupEnv("TEXTILE_LOTUS_TOKEN")
	if !ok {
		home, err := os.UserHomeDir()
		require.NoError(t, err)
		path := filepath.Join(home, ".lotus")
		authToken, err = GetLotusToken(path)
		require.NoError(t, err)
	}

	return multi, authToken
}

'''
'''--- Filecoin/powergate/tests/docker.go ---
package tests

import (
	"time"

	"github.com/ory/dockertest/v3"
	"github.com/stretchr/testify/require"
)

// LaunchIPFSDocker runs a fresh go-ipfs docker image and returns the resource for
// container metadata.
func LaunchIPFSDocker(t require.TestingT) (*dockertest.Resource, func()) {
	pool, err := dockertest.NewPool("")
	require.NoError(t, err)

	ipfsDocker, err := pool.Run("ipfs/go-ipfs", "v0.7.0", []string{"IPFS_PROFILE=test"})
	require.NoError(t, err)

	err = ipfsDocker.Expire(180)
	require.NoError(t, err)

	time.Sleep(time.Second * 3)
	return ipfsDocker, func() {
		err = pool.Purge(ipfsDocker)
		require.NoError(t, err)
	}
}

'''
'''--- Filecoin/powergate/tests/flaky.go ---
package tests

import (
	"runtime"
	"sync"
	"testing"

	"github.com/stretchr/testify/require"
)

// FlakyT provides retry mechanisms to test.
type FlakyT struct {
	t      *testing.T
	failed bool
	cls    []func()
}

// NewFlakyT creates a new FlakyT.
func NewFlakyT(t *testing.T) *FlakyT {
	return &FlakyT{
		t: t,
	}
}

var _ require.TestingT = (*FlakyT)(nil)

// Errorf registers an error message.
func (ft *FlakyT) Errorf(format string, args ...interface{}) {
	ft.t.Logf(format, args...)
}

// FailNow indicates to fail the test.
func (ft *FlakyT) FailNow() {
	ft.failed = true
	runtime.Goexit()
}

// Cleanup registers a cleanup function.
func (ft *FlakyT) Cleanup(cls func()) {
	ft.cls = append([]func(){cls}, ft.cls...)
}

var numRetries = 5

// RunFlaky runs a flaky test with retries.
func RunFlaky(t *testing.T, f func(ft *FlakyT)) {
	for i := 0; i < numRetries; i++ {
		var wg sync.WaitGroup
		wg.Add(1)
		ft := NewFlakyT(t)
		go func() {
			defer wg.Done()
			f(ft)
		}()
		wg.Wait()
		for _, f := range ft.cls {
			f()
		}
		if !ft.failed {
			return
		}
		ft.t.Logf("test %s attempt %d/%d failed, retrying...", t.Name(), i+1, numRetries)
	}
	t.Fatalf("test failed after %d retries", numRetries)
}

'''
'''--- Filecoin/powergate/tests/ldevnet.go ---
package tests

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ory/dockertest/v3"
	"github.com/ory/dockertest/v3/docker"
	"github.com/stretchr/testify/require"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/util"
)

// TestingTWithCleanup is an augmented require.TestingT with a Cleanup function.
type TestingTWithCleanup interface {
	require.TestingT
	Cleanup(func())
}

// LaunchDevnetDocker launches the devnet docker image.
func LaunchDevnetDocker(t TestingTWithCleanup, numMiners, speed int, ipfsMaddr string, mountVolumes bool) *dockertest.Resource {
	pool, err := dockertest.NewPool("")
	require.NoError(t, err)
	envs := []string{
		devnetEnv("NUMMINERS", strconv.Itoa(numMiners)),
		devnetEnv("SPEED", strconv.Itoa(speed)),
		devnetEnv("IPFSADDR", ipfsMaddr),
		devnetEnv("BIGSECTORS", false),
	}
	var mounts []string
	if mountVolumes {
		mounts = append(mounts, "/tmp/powergate:/tmp/powergate")
	}

	repository := "textile/lotus-devnet"
	tag := "v1.10.0"
	lotusDevnet, err := pool.RunWithOptions(&dockertest.RunOptions{Repository: repository, Tag: tag, Env: envs, Mounts: mounts})
	require.NoError(t, err)
	err = lotusDevnet.Expire(180)
	require.NoError(t, err)
	time.Sleep(time.Second * time.Duration(2+numMiners))
	t.Cleanup(func() {
		err := pool.Purge(lotusDevnet)
		require.NoError(t, err)
	})
	debug := false
	if debug {
		go func() {
			opts := docker.LogsOptions{
				Context: context.Background(),

				Stderr:      true,
				Stdout:      true,
				Follow:      true,
				Timestamps:  true,
				RawTerminal: true,

				Container: lotusDevnet.Container.ID,

				OutputStream: os.Stdout,
			}

			err := pool.Client.Logs(opts)
			require.NoError(t, err)
		}()
	}
	return lotusDevnet
}

// CreateLocalDevnetWithIPFS creates a local devnet connected to an IPFS node.
func CreateLocalDevnetWithIPFS(t TestingTWithCleanup, numMiners, speed int, ipfsMaddr string, mountVolumes bool) (lotus.ClientBuilder, address.Address, []address.Address) {
	lotusDevnet := LaunchDevnetDocker(t, numMiners, speed, ipfsMaddr, mountVolumes)
	cb, err := lotus.NewBuilder(util.MustParseAddr("/ip4/127.0.0.1/tcp/"+lotusDevnet.GetPort("7777/tcp")), "", 1)
	require.NoError(t, err)
	ctx, cls := context.WithTimeout(context.Background(), time.Second*10)
	defer cls()
	c, cls, err := cb(ctx)
	require.NoError(t, err)
	t.Cleanup(func() { cls() })
	ctx = context.Background()
	addr, err := c.WalletDefaultAddress(ctx)
	require.NoError(t, err)
	miners, err := c.StateListMiners(ctx, types.EmptyTSK)
	require.NoError(t, err)

	return cb, addr, miners
}

// CreateLocalDevnet returns an API client that targets a local devnet with numMiners number
// of miners. Refer to http://github.com/textileio/local-devnet for more information.
func CreateLocalDevnet(t TestingTWithCleanup, numMiners, speed int) (lotus.ClientBuilder, address.Address, []address.Address) {
	return CreateLocalDevnetWithIPFS(t, numMiners, speed, "", true)
}

func devnetEnv(name string, value interface{}) string {
	return fmt.Sprintf("TEXLOTUSDEVNET_%s=%s", name, value)
}

'''
'''--- Filecoin/powergate/tests/mocks/mocks.go ---
package mocks

import (
	"context"

	"github.com/libp2p/go-libp2p-core/peer"
	"github.com/multiformats/go-multiaddr"
	minerModule "github.com/textileio/powergate/v2/index/miner/lotusidx"
	"github.com/textileio/powergate/v2/iplocation"
)

var _ minerModule.P2PHost = (*P2pHostMock)(nil)

// P2pHostMock provides a mock P2PHost.
type P2pHostMock struct{}

// Addrs implements Addrs.
func (hm *P2pHostMock) Addrs(id peer.ID) []multiaddr.Multiaddr {
	return nil
}

// GetAgentVersion implements GetAgentVersion.
func (hm *P2pHostMock) GetAgentVersion(id peer.ID) string {
	return "fakeAgentVersion"
}

// Ping implements Ping.
func (hm *P2pHostMock) Ping(ctx context.Context, pid peer.ID) bool {
	return true
}

var _ iplocation.LocationResolver = (*LrMock)(nil)

// LrMock provides a mock LocationResolver.
type LrMock struct{}

// Resolve implements Resolve.
func (lr *LrMock) Resolve(mas []multiaddr.Multiaddr) (iplocation.Location, error) {
	return iplocation.Location{
		Country:   "USA",
		Latitude:  0.1,
		Longitude: 0.1,
	}, nil
}

'''
'''--- Filecoin/powergate/tests/txmapds.go ---
package tests

import (
	"fmt"
	"sync"

	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
)

// TxMapDatastore is a in-memory datastore that satisfies TxnDatastore.
type TxMapDatastore struct {
	*datastore.MapDatastore
	lock sync.RWMutex
}

// NewTxMapDatastore returns a new TxMapDatastore.
func NewTxMapDatastore() *TxMapDatastore {
	return &TxMapDatastore{
		MapDatastore: datastore.NewMapDatastore(),
	}
}

// Get returns the value for a key.
func (d *TxMapDatastore) Get(key datastore.Key) ([]byte, error) {
	d.lock.Lock()
	defer d.lock.Unlock()
	return d.MapDatastore.Get(key)
}

// Put sets the value of a key.
func (d *TxMapDatastore) Put(key datastore.Key, data []byte) error {
	d.lock.Lock()
	defer d.lock.Unlock()
	return d.MapDatastore.Put(key, data)
}

// Delete deletes a key.
func (d *TxMapDatastore) Delete(key datastore.Key) error {
	d.lock.Lock()
	defer d.lock.Unlock()
	return d.MapDatastore.Delete(key)
}

// Query executes a query in the datastore.
func (d *TxMapDatastore) Query(q query.Query) (query.Results, error) {
	d.lock.Lock()
	defer d.lock.Unlock()
	return d.MapDatastore.Query(q)
}

// Clone returns a cloned datastore.
func (d *TxMapDatastore) Clone() (*TxMapDatastore, error) {
	d.lock.Lock()
	defer d.lock.Unlock()

	q := query.Query{}
	res, err := d.MapDatastore.Query(q)
	if err != nil {
		return nil, fmt.Errorf("querying datastore: %s", err)
	}
	defer func() { _ = res.Close() }()

	t2 := &TxMapDatastore{
		MapDatastore: datastore.NewMapDatastore(),
	}
	for v := range res.Next() {
		if v.Error != nil {
			return nil, fmt.Errorf("iter next: %s", v.Error)
		}
		if err := t2.Put(datastore.NewKey(v.Key), v.Value); err != nil {
			return nil, fmt.Errorf("copying datastore value: %s", err)
		}
	}
	return t2, nil
}

// NewTransaction creates a transaction A read-only transaction should be
// indicated with readOnly equal true.
func (d *TxMapDatastore) NewTransaction(readOnly bool) (datastore.Txn, error) {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return NewSimpleTx(d), nil
}

type op struct {
	delete bool
	value  []byte
}

// SimpleTx implements the transaction interface for datastores who do
// not have any sort of underlying transactional support.
type SimpleTx struct {
	ops    map[datastore.Key]op
	lock   sync.RWMutex
	target datastore.Datastore
}

// NewSimpleTx creates a transaction.
func NewSimpleTx(ds datastore.Datastore) datastore.Txn {
	return &SimpleTx{
		ops:    make(map[datastore.Key]op),
		target: ds,
	}
}

// Query executes a query within the transaction scope.
func (bt *SimpleTx) Query(q query.Query) (query.Results, error) {
	bt.lock.RLock()
	defer bt.lock.RUnlock()
	return bt.target.Query(q)
}

// Get returns a key value within the transaction.
func (bt *SimpleTx) Get(k datastore.Key) ([]byte, error) {
	bt.lock.RLock()
	defer bt.lock.RUnlock()
	return bt.target.Get(k)
}

// Has returns true if the key exist, false otherwise.
func (bt *SimpleTx) Has(k datastore.Key) (bool, error) {
	bt.lock.RLock()
	defer bt.lock.RUnlock()
	return bt.target.Has(k)
}

// GetSize returns the size of the key value.
func (bt *SimpleTx) GetSize(k datastore.Key) (int, error) {
	bt.lock.RLock()
	defer bt.lock.RUnlock()
	return bt.target.GetSize(k)
}

// Put sets the value for a key.
func (bt *SimpleTx) Put(key datastore.Key, val []byte) error {
	bt.lock.Lock()
	defer bt.lock.Unlock()
	bt.ops[key] = op{value: val}
	return nil
}

// Delete deletes a key.
func (bt *SimpleTx) Delete(key datastore.Key) error {
	bt.lock.Lock()
	defer bt.lock.Unlock()
	bt.ops[key] = op{delete: true}
	return nil
}

// Discard cancels the changes done in the transaction.
func (bt *SimpleTx) Discard() {
	bt.lock.Lock()
	defer bt.lock.Unlock()
}

// Commit confirms changes done in the transaction.
func (bt *SimpleTx) Commit() error {
	bt.lock.Lock()
	defer bt.lock.Unlock()
	var err error
	for k, op := range bt.ops {
		if op.delete {
			err = bt.target.Delete(k)
		} else {
			err = bt.target.Put(k, op.value)
		}
		if err != nil {
			break
		}
	}

	return err
}

'''
'''--- Filecoin/powergate/txndstransform/txndstransform.go ---
package txndstransform

import (
	"strings"

	ds "github.com/ipfs/go-datastore"
	kt "github.com/ipfs/go-datastore/keytransform"
	dsq "github.com/ipfs/go-datastore/query"
)

// Wrap wraps a TxDatastore with a namespace prefix.
func Wrap(child ds.TxnDatastore, prefix string) *Datastore {
	parts := strings.Split(prefix, "/")
	prefixKey := ds.NewKey("/")
	for _, part := range parts {
		prefixKey = prefixKey.ChildString(part)
	}
	t := kt.PrefixTransform{Prefix: prefixKey}
	nds := &Datastore{
		child:        child,
		Datastore:    kt.Wrap(child, t),
		KeyTransform: t,
	}
	return nds
}

// Datastore keeps a KeyTransform function.
type Datastore struct {
	child ds.TxnDatastore
	kt.KeyTransform
	ds.Datastore
}

type txn struct {
	ds.Txn
	ds *Datastore
}

// NewTransaction returns a transaction wrapped by the selected namespace prefix.
func (d *Datastore) NewTransaction(readOnly bool) (ds.Txn, error) {
	t, err := d.child.NewTransaction(readOnly)
	if err != nil {
		return nil, err
	}

	return &txn{Txn: t, ds: d}, nil
}

func (t *txn) Commit() error {
	return t.Txn.Commit()
}

func (t *txn) Discard() {
	t.Txn.Discard()
}

// Put stores the given value, transforming the key first.
func (t *txn) Put(key ds.Key, value []byte) (err error) {
	return t.Txn.Put(t.ds.ConvertKey(key), value)
}

// Delete removes the value for given key.
func (t *txn) Delete(key ds.Key) (err error) {
	return t.Txn.Delete(t.ds.ConvertKey(key))
}

// Get returns the value for given key, transforming the key first.
func (t *txn) Get(key ds.Key) (value []byte, err error) {
	return t.Txn.Get(t.ds.ConvertKey(key))
}

// Has returns whether the datastore has a value for a given key, transforming
// the key first.
func (t *txn) Has(key ds.Key) (exists bool, err error) {
	return t.Txn.Has(t.ds.ConvertKey(key))
}

// GetSize returns the size of the value named by the given key, transforming
// the key first.
func (t *txn) GetSize(key ds.Key) (size int, err error) {
	return t.Txn.GetSize(t.ds.ConvertKey(key))
}

// Query implements Query, inverting keys on the way back out.
func (t *txn) Query(q dsq.Query) (dsq.Results, error) {
	nq, cq := t.prepareQuery(q)

	cqr, err := t.Txn.Query(cq)
	if err != nil {
		return nil, err
	}

	qr := dsq.ResultsFromIterator(q, dsq.Iterator{
		Next: func() (dsq.Result, bool) {
			r, ok := cqr.NextSync()
			if !ok {
				return r, false
			}
			if r.Error == nil {
				r.Entry.Key = t.ds.InvertKey(ds.RawKey(r.Entry.Key)).String()
			}
			return r, true
		},
		Close: func() error {
			return cqr.Close()
		},
	})
	return dsq.NaiveQueryApply(nq, qr), nil
}

// Split the query into a child query and a naive query. That way, we can make
// the child datastore do as much work as possible.
func (t *txn) prepareQuery(q dsq.Query) (naive, child dsq.Query) {
	// First, put everything in the child query. Then, start taking things
	// out.
	child = q

	// Always let the child handle the key prefix.
	child.Prefix = t.ds.ConvertKey(ds.NewKey(child.Prefix)).String()

	// Check if the key transform is order-preserving so we can use the
	// child datastore's built-in ordering.
	orderPreserving := false
	switch t.ds.KeyTransform.(type) {
	case kt.PrefixTransform, *kt.PrefixTransform:
		orderPreserving = true
	}

	// Try to let the child handle ordering.
orders:
	for i, o := range child.Orders {
		switch o.(type) {
		case dsq.OrderByValue, *dsq.OrderByValue,
			dsq.OrderByValueDescending, *dsq.OrderByValueDescending:
			// Key doesn't matter.
			continue
		case dsq.OrderByKey, *dsq.OrderByKey,
			dsq.OrderByKeyDescending, *dsq.OrderByKeyDescending:
			// if the key transform preserves order, we can delegate
			// to the child datastore.
			if orderPreserving {
				// When sorting, we compare with the first
				// Order, then, if equal, we compare with the
				// second Order, etc. However, keys are _unique_
				// so we'll never apply any additional orders
				// after ordering by key.
				child.Orders = child.Orders[:i+1]
				break orders
			}
		}

		// Can't handle this order under transform, punt it to a naive
		// ordering.
		naive.Orders = q.Orders
		child.Orders = nil
		naive.Offset = q.Offset
		child.Offset = 0
		naive.Limit = q.Limit
		child.Limit = 0
		break
	}

	// Try to let the child handle the filters.

	// don't modify the original filters.
	child.Filters = append([]dsq.Filter(nil), child.Filters...)

	for i, f := range child.Filters {
		switch f := f.(type) {
		case dsq.FilterValueCompare, *dsq.FilterValueCompare:
			continue
		case dsq.FilterKeyCompare:
			child.Filters[i] = dsq.FilterKeyCompare{
				Op:  f.Op,
				Key: t.ds.ConvertKey(ds.NewKey(f.Key)).String(),
			}
			continue
		case *dsq.FilterKeyCompare:
			child.Filters[i] = &dsq.FilterKeyCompare{
				Op:  f.Op,
				Key: t.ds.ConvertKey(ds.NewKey(f.Key)).String(),
			}
			continue
		case dsq.FilterKeyPrefix:
			child.Filters[i] = dsq.FilterKeyPrefix{
				Prefix: t.ds.ConvertKey(ds.NewKey(f.Prefix)).String(),
			}
			continue
		case *dsq.FilterKeyPrefix:
			child.Filters[i] = &dsq.FilterKeyPrefix{
				Prefix: t.ds.ConvertKey(ds.NewKey(f.Prefix)).String(),
			}
			continue
		}

		// Not a known filter, defer to the naive implementation.
		naive.Filters = q.Filters
		child.Filters = nil
		naive.Offset = q.Offset
		child.Offset = 0
		naive.Limit = q.Limit
		child.Limit = 0
		break
	}
	return
}

var _ ds.TxnDatastore = (*Datastore)(nil)

'''
'''--- Filecoin/powergate/util/util.go ---
package util

import (
	"context"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/filecoin-project/lotus/build"
	"github.com/ipfs/go-cid"
	ma "github.com/multiformats/go-multiaddr"
	dns "github.com/multiformats/go-multiaddr-dns"
)

var (
	// AvgBlockTime is the expected duration between block in two consecutive epochs.
	AvgBlockTime = time.Second * time.Duration(EpochDurationSeconds)
)

const (
	// EpochDurationSeconds is the expected duration in seconds of an epoch.
	// Defined at the filecoin spec level.
	EpochDurationSeconds = 30

	// MinDealDuration is the minium deal duration accepted in the Filecoin network.
	// Original calculation: 180 * EpochsInADay.
	MinDealDuration = 180 * (24 * 60 * 60 / EpochDurationSeconds)

	// CidUndef is a magic value to represent an undefined cid as a string.
	CidUndef = "CID_UNDEF"

	// DefaultCidUndef is the string generated by the cid module's String() func for an undefined cid.
	DefaultCidUndef = "b"
)

// TCPAddrFromMultiAddr converts a multiaddress to a string representation of a tcp address.
func TCPAddrFromMultiAddr(maddr ma.Multiaddr) (string, error) {
	if maddr == nil {
		return "", fmt.Errorf("invalid address")
	}

	var ip string
	if _, err := maddr.ValueForProtocol(ma.P_DNS4); err == nil {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second)
		defer cancel()
		maddrs, err := dns.Resolve(ctx, maddr)
		if err != nil {
			return "", fmt.Errorf("resolving dns: %s", err)
		}
		for _, m := range maddrs {
			if ip, err = getIPFromMaddr(m); err == nil {
				break
			}
		}
	} else {
		ip, err = getIPFromMaddr(maddr)
		if err != nil {
			return "", fmt.Errorf("getting ip from maddr: %s", err)
		}
	}

	tcp, err := maddr.ValueForProtocol(ma.P_TCP)
	if err != nil {
		return "", fmt.Errorf("getting port from maddr: %s", err)
	}
	return fmt.Sprintf("%s:%s", ip, tcp), nil
}

func getIPFromMaddr(maddr ma.Multiaddr) (string, error) {
	if ip, err := maddr.ValueForProtocol(ma.P_IP4); err == nil {
		return ip, nil
	}
	if ip, err := maddr.ValueForProtocol(ma.P_IP6); err == nil {
		return fmt.Sprintf("[%s]", ip), nil
	}
	return "", fmt.Errorf("no ip in multiaddr")
}

// MustParseAddr returns a parsed Multiaddr, or panics if invalid.
func MustParseAddr(str string) ma.Multiaddr {
	addr, err := ma.NewMultiaddr(str)
	if err != nil {
		panic(err)
	}
	return addr
}

// CidToString converts a cid to string, representing cid.Undef as an empty string.
func CidToString(c cid.Cid) string {
	if c == cid.Undef {
		return CidUndef
	}
	return c.String()
}

// CidFromString converts a string to a cid assuming that an empty string is cid.Undef.
func CidFromString(c string) (cid.Cid, error) {
	if c == DefaultCidUndef || c == CidUndef || c == "" {
		return cid.Undef, nil
	}
	return cid.Decode(c)
}

// AttoFilToFil transforms an attoFIL integer value, to a
// pretty FIL string.
func AttoFilToFil(attoFil uint64) string {
	r := new(big.Rat).SetFrac(big.NewInt(int64(attoFil)), big.NewInt(int64(build.FilecoinPrecision)))
	if r.Sign() == 0 {
		return "0"
	}
	return strings.TrimRight(strings.TrimRight(r.FloatString(18), "0"), ".")
}

'''
'''--- Filecoin/powergate/util/util_test.go ---
package util

import (
	"testing"

	"github.com/ipfs/go-cid"
	"github.com/stretchr/testify/require"
)

const cidString = "QmSqL792vF4fGjStbYHRgazsEahAQKZmx68jrnvFi9hXMp"

func TestCidToString(t *testing.T) {
	c, err := cid.Decode(cidString)
	require.NoError(t, err)
	s := CidToString(c)
	require.Equal(t, cidString, s)
	c = cid.Undef
	s = CidToString(c)
	require.Equal(t, CidUndef, s)
}

func TestCidFromString(t *testing.T) {
	orig, err := cid.Decode(cidString)
	require.NoError(t, err)
	c, err := CidFromString(cidString)
	require.NoError(t, err)
	require.Equal(t, orig, c)
	c, err = CidFromString(CidUndef)
	require.NoError(t, err)
	require.Equal(t, cid.Undef, c)
	c, err = CidFromString(DefaultCidUndef)
	require.NoError(t, err)
	require.Equal(t, cid.Undef, c)
	_, err = CidFromString("xyz")
	require.Error(t, err)
}

'''
'''--- Filecoin/powergate/wallet/lotuswallet/metrics.go ---
package lotuswallet

import (
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
)

var (
	tagAutofund = attribute.Key("autofunding")
)

func (m *Module) initMetrics() {
	meter := global.Meter("powergate")

	m.metricCreated = metric.Must(meter).NewInt64Counter("powergate.wallet.created")
	m.metricTransfer = metric.Must(meter).NewInt64ValueRecorder("powergate.wallet.transfer", metric.WithDescription("Transfers in nanoFIL"))
}

'''
'''--- Filecoin/powergate/wallet/lotuswallet/wallet.go ---
package lotuswallet

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"math/big"
	"net/http"
	"strings"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
	logger "github.com/ipfs/go-log/v2"
	"github.com/textileio/powergate/v2/lotus"
	"github.com/textileio/powergate/v2/wallet"
	"go.opentelemetry.io/otel/metric"
)

const (
	feeThreshold     = 1_000_000
	errActorNotFound = "actor not found"
)

var (
	log           = logger.Logger("lotus-wallet")
	networkFaucet = map[string]string{}
)

// Module exposes the filecoin wallet api.
type Module struct {
	clientBuilder lotus.ClientBuilder
	iAmount       *big.Int
	masterAddr    address.Address
	networkName   string

	metricCreated  metric.Int64Counter
	metricTransfer metric.Int64ValueRecorder
}

// New creates a new wallet module.
func New(clientBuilder lotus.ClientBuilder, maddr address.Address, iam big.Int, autocreate bool, networkName string) (*Module, error) {
	m := &Module{
		clientBuilder: clientBuilder,
		iAmount:       &iam,
		masterAddr:    maddr,
		networkName:   networkName,
	}

	if maddr == address.Undef && autocreate {
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
		defer cancel()
		newMasterAddr, err := m.NewAddress(ctx, "bls")
		if err != nil {
			return nil, fmt.Errorf("creating and funding master addr: %s", err)
		}
		log.Infof("Auto-created master wallet addr: %s", newMasterAddr)
		if err := m.FundFromFaucet(ctx, newMasterAddr); err != nil {
			return nil, fmt.Errorf("funding new master addr: %s", err)
		}
		log.Info("Autocreated master wallet addr funded successfully")
		maddr, _ = address.NewFromString(newMasterAddr)
		m = &Module{
			clientBuilder: clientBuilder,
			iAmount:       &iam,
			masterAddr:    maddr,
		}
	}
	m.initMetrics()

	return m, nil
}

// MasterAddr returns the master address.
// Will return address.Undef is Powergate was started with no master address.
func (m *Module) MasterAddr() address.Address {
	return m.masterAddr
}

// NewAddress creates a new address.
func (m *Module) NewAddress(ctx context.Context, typ string) (string, error) {
	var ty types.KeyType
	if typ == "bls" {
		ty = types.KTBLS
	} else if typ == "secp256k1" {
		ty = types.KTSecp256k1
	} else {
		return "", fmt.Errorf("unknown address type %s", typ)
	}

	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return "", fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	addr, err := client.WalletNew(ctx, ty)
	if err != nil {
		return "", err
	}
	m.metricCreated.Add(ctx, 1)

	if m.masterAddr != address.Undef {
		balance, err := client.WalletBalance(ctx, m.masterAddr)
		if err != nil {
			return "", fmt.Errorf("getting balance from master addr: %s", err)
		}
		if balance.LessThan(types.BigAdd(types.BigInt{Int: m.iAmount}, types.NewInt(feeThreshold))) {
			return "", fmt.Errorf("balance %d is less than allowed threshold", balance)
		}
		go func() {
			client, cls, err := m.clientBuilder(context.Background())
			if err != nil {
				log.Errorf("creating lotus client: %s", err)
				return
			}
			defer cls()

			msg := &types.Message{
				From:  m.masterAddr,
				To:    addr,
				Value: types.BigInt{Int: m.iAmount},
			}
			smsg, err := client.MpoolPushMessage(context.Background(), msg, nil)
			if err != nil {
				log.Errorf("transferring funds to new address: %s", err)
				return
			}

			nanoAmount := big.NewInt(0).Div(m.iAmount, big.NewInt(1_000_000_000))
			m.metricTransfer.Record(ctx, nanoAmount.Int64(), tagAutofund.Bool(true))
			log.Infof("%s funding transaction message: %s", addr, smsg.Message.Cid())
		}()
	}

	return addr.String(), nil
}

// Sign signs a message with an address.
func (m *Module) Sign(ctx context.Context, addr string, message []byte) ([]byte, error) {
	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return nil, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	waddr, err := address.NewFromString(addr)
	if err != nil {
		return nil, fmt.Errorf("parsing wallet address: %s", err)
	}
	sig, err := client.WalletSign(ctx, waddr, message)
	if err != nil {
		return nil, fmt.Errorf("lotus signing message: %s", err)
	}
	sigBytes, err := sig.MarshalBinary()
	if err != nil {
		return nil, fmt.Errorf("marshaling signature: %s", err)
	}

	return sigBytes, nil
}

// Verify verifies a message signature from an address.
func (m *Module) Verify(ctx context.Context, addr string, message, signature []byte) (bool, error) {
	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return false, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	waddr, err := address.NewFromString(addr)
	if err != nil {
		return false, fmt.Errorf("parsing wallet address: %s", err)
	}
	var sig crypto.Signature
	if err := sig.UnmarshalBinary(signature); err != nil {
		return false, fmt.Errorf("unmarshaling signature: %s", err)
	}
	return client.WalletVerify(ctx, waddr, message, &sig)
}

// List returns all wallet addresses.
func (m *Module) List(ctx context.Context) ([]string, error) {
	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return nil, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	addrs, err := client.WalletList(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting wallet addresses: %v", err)
	}
	ret := make([]string, len(addrs))
	for i, addr := range addrs {
		ret[i] = addr.String()
	}
	return ret, nil
}

// Balance returns the balance of the specified address.
func (m *Module) Balance(ctx context.Context, addr string) (*big.Int, error) {
	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return nil, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()
	a, err := address.NewFromString(addr)
	if err != nil {
		return nil, err
	}
	b, err := client.WalletBalance(ctx, a)
	if err != nil {
		return nil, fmt.Errorf("getting balance from lotus: %s", err)
	}
	return b.Int, nil
}

// SendFil sends fil from one address to another.
func (m *Module) SendFil(ctx context.Context, from string, to string, amount *big.Int) (cid.Cid, error) {
	f, err := address.NewFromString(from)
	if err != nil {
		return cid.Cid{}, err
	}
	t, err := address.NewFromString(to)
	if err != nil {
		return cid.Cid{}, err
	}
	msg := &types.Message{
		From:  f,
		To:    t,
		Value: types.BigInt{Int: amount},
	}
	client, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return cid.Cid{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	sm, err := client.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return cid.Cid{}, err
	}
	nanoAmount := big.NewInt(0).Div(amount, big.NewInt(1_000_000_000))
	m.metricTransfer.Record(ctx, nanoAmount.Int64(), tagAutofund.Bool(true))

	return sm.Message.Cid(), err
}

// FundFromFaucet make a faucet call to fund the provided wallet address.
func (m *Module) FundFromFaucet(ctx context.Context, addr string) error {
	faucet, ok := networkFaucet[m.networkName]
	if !ok {
		return fmt.Errorf("unknown faucet for network %s", m.networkName)
	}

	req, err := http.NewRequest("GET", faucet+"/send", nil)
	if err != nil {
		return fmt.Errorf("parsing fountain url: %s", err)
	}
	q := req.URL.Query()
	q.Add("address", addr)
	req.URL.RawQuery = q.Encode()
	r, err := http.Get(req.URL.String())
	if err != nil {
		return fmt.Errorf("calling the fountain: %s", err)
	}
	defer func() { _ = r.Body.Close() }()
	_, _ = io.Copy(ioutil.Discard, r.Body)
	if r.StatusCode != http.StatusOK {
		return fmt.Errorf("fountain request not OK: %s", r.Status)
	}
	return nil
}

// GetVerifiedClientInfo returns details about a wallet-address that's
// a verified client. If the wallet address isn't a verified client,
// it will return ErrNoVerifiedClient.
func (m *Module) GetVerifiedClientInfo(ctx context.Context, addr string) (wallet.VerifiedClientInfo, error) {
	c, cls, err := m.clientBuilder(ctx)
	if err != nil {
		return wallet.VerifiedClientInfo{}, fmt.Errorf("creating lotus client: %s", err)
	}
	defer cls()

	a, err := address.NewFromString(addr)
	if err != nil {
		return wallet.VerifiedClientInfo{}, fmt.Errorf("parsing wallet-address: %s", err)
	}

	return getVerifiedClientInfo(ctx, c, a)
}

func getVerifiedClientInfo(ctx context.Context, c *api.FullNodeStruct, addr address.Address) (wallet.VerifiedClientInfo, error) {
	sp, err := c.StateVerifiedClientStatus(ctx, addr, types.EmptyTSK)
	if err != nil && !strings.Contains(err.Error(), errActorNotFound) {
		return wallet.VerifiedClientInfo{}, fmt.Errorf("getting verified-client information: %s", err)
	}
	if sp == nil {
		return wallet.VerifiedClientInfo{}, wallet.ErrNoVerifiedClient
	}

	return wallet.VerifiedClientInfo{
		RemainingDatacapBytes: sp.Int,
	}, nil
}

'''
'''--- Filecoin/powergate/wallet/type.go ---
package wallet

import (
	"context"
	"errors"
	"math/big"

	"github.com/ipfs/go-cid"
)

var (
	// ErrNoVerifiedClient indicates that the provided
	// wallet-address isn't a verified client.
	ErrNoVerifiedClient = errors.New("the wallet-address isn't a verified client")
)

// VerifiedClientInfo contains information for a wallet address
// that is a verified-client.
type VerifiedClientInfo struct {
	RemainingDatacapBytes *big.Int
}

// Module provides wallet management access to a Filecoin client.
type Module interface {
	// NewAddress returns a new wallet address of the specified type.
	NewAddress(ctx context.Context, typ string) (string, error)
	// List lists all known wallet addresses.
	List(ctx context.Context) ([]string, error)
	// GetVerifiedClientInfo returns details about a wallet-address that's
	// a verified client. If the wallet address isn't a verified client,
	// it will return ErrNoVerifiedClient.
	GetVerifiedClientInfo(ctx context.Context, addr string) (VerifiedClientInfo, error)
	// Balance returns the balance of a wallet-address.
	Balance(ctx context.Context, addr string) (*big.Int, error)
	// SendFil sends `amount` attoFIL from `from` to `to` and returns the
	// message Cid.
	SendFil(ctx context.Context, from string, to string, amount *big.Int) (cid.Cid, error)
	// FundFromFaucet funds addr from the master address (if configured).
	FundFromFaucet(ctx context.Context, addr string) error
}

'''
'''--- LICENSE.txt ---
MIT License

Copyright (c) 2021 ArbÃ«r Salihi & Emmanuel Kellner

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- NEAR/Contracts/README.md ---
# Contracts

## Table of Contents
-   [Description](#description)
-   [Build](#build)
-   [Deploy](#deploy)
-   [License](#license)

## Description

The internal and public functions of each smart contract are defined in the __main.ts__ file.
The __model.ts__ file is used to specify the model of the objects being manipulated by the smart contracts.
The __out__ folder is where the compiled file is saved.

## Build

To build each contract manually, you should first install AssemblyScript tool, e.g., globally:
```bash
$ npm install -g asbuild
```

Then, for each smart contract, run:
```bash
asb main.ts
```

## Deploy

The smart contracts are deployed setting the *deployment* configuration property to *true* and deploying the server.
To manually deploy contracts using NEAR CLI (and assuming CLI is installed, as per NEAR official documentation), you can run:
```bash
near dev-deploy
```

Or for production deployment:
```bash
near deploy
```

## License

[MIT](LICENSE)

'''
'''--- NEAR/Contracts/assembly/identity-provider/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- NEAR/Contracts/assembly/identity-provider/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "./main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- NEAR/Contracts/assembly/identity-provider/main.ts ---
import { storage, context } from 'near-sdk-core';

import { Identity, identities, Role } from './model';

export function Initialize(): void {
  if(!storage.hasKey('provider')) {
    storage.set('provider', context.sender);
  }
}

export function ChangeProvider(new_provider: string): void {
  if(_VerifyProvider()) {
    storage.set('provider', new_provider);
  }
}

export function AddIdentity(identifier: string, address: string): void {
  const identity: Identity = new Identity(address);
  identities.set(identifier, identity);
}

export function RetrieveIdentity(identifier: string): Identity | null {
  return identities.get(identifier);
}

export function VerifyIdentity(identifier: string): bool {
  return identities.contains(identifier);
}

export function AddMetadata(identifier: string, key: string, value: string): void {
  if(VerifyIdentity(identifier)) {
    const identity: Identity = identities.get(identifier)!;
    identity.set_metadata(key, value);
  }
}

export function GetMetadata(identifier: string, key: string): string | null {
  if(VerifyIdentity(identifier)) {
    const identity: Identity = identities.get(identifier)!;
    return identity.get_metadata(key);
  } else return null;
}

export function AddRole(identifier: string, type: string): void {
  if(VerifyIdentity(identifier)) {
    const identity: Identity = identities.get(identifier)!;
    identity.add_role(type);
  }
}

export function GetRole(identifier: string, type: string): Role | null {
  if(VerifyIdentity(identifier)) {
    const identity: Identity = identities.get(identifier)!;
    return identity.get_role(type);
  } else return null;
}

function _VerifyProvider(): boolean {
  return storage.get<string>('provider') == context.sender;
}
'''
'''--- NEAR/Contracts/assembly/identity-provider/model.ts ---
import { PersistentMap } from 'near-sdk-as';

export class Role {
  type: string;
  metadata: PersistentMap<string, string>;

  constructor(type: string, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('mr')) {
    this.type = type;
    this.metadata = metadata;
  }

  get_type(): string {
    return this.type;
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

@nearBindgen
export class Identity {
  address: string;
  state: string;
  roles: PersistentMap<string, Role>;
  metadata: PersistentMap<string, string>;

  constructor(address: string, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('mi')) {
    this.address = address;
    this.state = 'active';
    this.roles = new PersistentMap<string, Role>('r');
    this.metadata = metadata;
  }

  activate(): void {
    if(this.state == 'inactive') this.state = 'active';
  }

  deactivate(): void {
    if(this.state == 'active') this.state = 'inactive';
  }

  add_role(type: string, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('r')): void {
    const role: Role = new Role(type, metadata);
    this.roles.set(type, role);
  }

  get_role(type: string): Role | null {
    return this.roles.get(type);
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

export const identities = new PersistentMap<string, Identity>('i');
'''
'''--- NEAR/Contracts/assembly/identity-provider/tsconfig.json ---
{
  "extends": "../../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- NEAR/Contracts/assembly/network/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- NEAR/Contracts/assembly/network/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "./main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- NEAR/Contracts/assembly/network/main.ts ---
import { storage, context, ContractPromise, u128 } from 'near-sdk-core';
import { PersistentMap } from 'near-sdk-as';

import { Provider, Publisher, publishers } from './model';

export const providers = new PersistentMap<string, Provider>('p');

export function Initialize(): void {
  if(!storage.hasKey('owner')) {
    storage.set('owner', context.sender);
  }
}

export function ChangeOwner(new_owner: string): void {
  if(_VerifyOwner()) {
    storage.set('owner', new_owner);
  }
}

export function AddPublisher(identifier: string): void {
  const publisher: Publisher = new Publisher(identifier);
  publishers.set(identifier, publisher);
}

export function RetrievePublisher(identifier: string): Publisher | null {
  return publishers.get(identifier);
}

export function AddProvider(identifier: string, contract: string): void {
  const provider: Provider = new Provider(identifier, contract);
  providers.set(identifier, provider);
}

export function RetrieveProvider(provider: string): Provider | null {
  return providers.get(provider);
}

export function VerifyIdentity(provider_identifier: string, identity_identifier: string): void {
  const provider: Provider | null = providers.get(provider_identifier);
  if(provider) {
    const promise = ContractPromise.create<string>(provider.get_contract(), 'VerifyIdentity', identity_identifier, 300000000000000, u128.Zero);
    promise.returnAsResult();
  } else {
    throw new Error('Provider does not exist');
  }
}

export function AddMetadata(identifier: string, key: string, value: string): void {
  if(_VerifyOwner()) {
    const publisher: Publisher | null = publishers.get(identifier)!;
    if(publisher) publisher.set_metadata(key, value);
  }
}

export function GetMetadata(identifier: string, key: string): string | null {
  if(_VerifyOwner()) {
    const publisher: Publisher | null = publishers.get(identifier)!;
    if(publisher) return publisher.get_metadata(key);
    else return null;
  } else return null;
}

function _VerifyOwner(): boolean {
  return storage.get<string>('owner') == context.sender;
}
'''
'''--- NEAR/Contracts/assembly/network/model.ts ---
import { context } from 'near-sdk-core';
import { PersistentMap } from 'near-sdk-as';

@nearBindgen
export class Publisher {
  publisher: string;
  metadata: PersistentMap<string, string>;

  constructor(publisher: string) {
    this.publisher = publisher;
    this.metadata = new PersistentMap<string, string>('publisher_m');
  }

  get_publisher(): string {
    return this.publisher;
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

@nearBindgen
export class Provider {
  identifier: string;
  contract: string;
  metadata: PersistentMap<string, string>;

  constructor(identifier: string, contract: string) {
    this.identifier = identifier;
    this.contract = contract;
    this.metadata = new PersistentMap<string, string>('provider_m');
  }

  get_identifier(): string {
    return this.identifier;
  }

  get_contract(): string {
    return this.contract;
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

export const publishers = new PersistentMap<string, Publisher>('p');
'''
'''--- NEAR/Contracts/assembly/network/neardev/dev-account.env ---
CONTRACT_NAME=dev-1635656116581-61306509694513
'''
'''--- NEAR/Contracts/assembly/network/tsconfig.json ---
{
  "extends": "../../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- NEAR/Contracts/assembly/publisher/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- NEAR/Contracts/assembly/publisher/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "./main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- NEAR/Contracts/assembly/publisher/main.ts ---
import { context } from "near-sdk-core";
import { PersistentSet } from "near-sdk-as";

import { repositories, Repository } from "./model";

export const administrators = new PersistentSet<string>('a');

export function Initialize(): void {
  if(administrators.size == 0) {
    administrators.add(context.sender);
  }
}

export function AddAdministrator(administrator: string): void {
  if(_VerifyAdministrator()) {
    administrators.add(administrator);
  }
}

export function RemoveAdministrator(administrator: string): void {
  if(_VerifyAdministrator()) {
    administrators.delete(administrator);
  }
}

export function AddRepository(name: string, contract: string): void {
  if(_VerifyAdministrator()) {
    const repository: Repository = new Repository(contract);
    repositories.set(name, repository);
  }
}

export function RetrieveRepository(name: string): Repository | null {
  return repositories.get(name);
}

export function RetrieveContract(repository: string): string | null {
  const entry: Repository | null = repositories.get(repository);
  return entry ? entry.get_contract() : null;
}

export function AddMetadata(identifier: string, key: string, value: string): void {
  if(_VerifyAdministrator()) {
    const repository: Repository | null = repositories.get(identifier)!;
    if(repository) repository.set_metadata(key, value);
  }
}

export function GetMetadata(identifier: string, key: string): string | null {
  if(_VerifyAdministrator()) {
    const repository: Repository | null = repositories.get(identifier)!;
    if(repository) return repository.get_metadata(key);
    else return null;
  } else return null;
}

function _VerifyAdministrator(): bool {
  return administrators.has(context.sender);
}

'''
'''--- NEAR/Contracts/assembly/publisher/model.ts ---
import { context } from 'near-sdk-core';
import { PersistentMap } from 'near-sdk-as';

@nearBindgen
export class Repository {
  status: string;
  contract: string;
  creation: u64;
  metadata: PersistentMap<string, string>;

  constructor(contract: string, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('m')) {
    this.contract = contract;
    this.status = 'active';
    this.creation = context.blockTimestamp;
    this.metadata = metadata;
  }

  get_contract(): string {
    return this.contract;
  }

  activate(): void {
    if(this.status == 'inactive') this.status = 'active';
  }

  deactivate(): void {
    if(this.status == 'active') this.status = 'inactive';
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

export const repositories = new PersistentMap<string, Repository>('r');
'''
'''--- NEAR/Contracts/assembly/publisher/tsconfig.json ---
{
  "extends": "../../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- NEAR/Contracts/assembly/repository/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- NEAR/Contracts/assembly/repository/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "./main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- NEAR/Contracts/assembly/repository/main.ts ---
import { context, ContractPromiseBatch, ContractPromiseResult, logging, storage, u128 } from 'near-sdk-core';
import { PersistentSet, ContractPromise } from 'near-sdk-as';

import { Article, collection, Comment, CommentType, Identity, Response, Version } from './model';

export const authors = new PersistentSet<string>('author');

export function Initialize(network: string): void {
  if (!_VerifyInitialization()) {
    storage.set('administrator', context.sender);
    storage.set('network', network);
  }
}

export function ChangeAdministrator(new_administrator: string): void {
  if (_VerifyAdministrator()) {
    storage.set('administrator', new_administrator);
  }
}

export function ChangeNetwork(network: string): void {
  if (_VerifyAdministrator()) {
    storage.set('network', network);
  }
}

export function AddAuthor(author: string): void {
  if (_VerifyAdministrator()) {
    authors.add(author);
  }
}

export function RemoveAuthor(author: string): void {
  authors.delete(author);
}

export function AddArticle(identifier: string, initial_version: string, signature: string, provider: string): bool {
  if (!_VerifyAuthor()) return false;

  const author: Identity = new Identity(provider, context.sender);
  const version: Version = new Version(identifier, initial_version, signature);
  const article: Article = new Article(identifier, author, version);
  collection.set(identifier, article);
  return true;
}

export function GetArticle(identifier: string): Article | null {
  return collection.get(identifier);
}

export function AddMetadataToArticle(article_identifier: string, key: string, value: string): void {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier);
    if(article) article.set_metadata(key, value);
  }
}

export function GetMetadataFromArticle(article_identifier: string, key: string): string | null {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier)!;
    if(article) return article.get_metadata(key);
    else return null;
  } else return null;
}

export function AddVersion(article_identifier: string, version_identifier: string, version_name: string, signature: string): bool {
  if (collection.contains(article_identifier)) return false;

  const article: Article = collection.get(article_identifier)!;
  if (article.get_author().get_identifier() !== context.sender) return false;

  const version: Version = new Version(version_identifier, version_name, signature);
  article.add_version(version);
  return true;
}

export function AddComment(article_identifier: string, version_identifier: string, comment_identifier: string, signature: string, provider: string, type: CommentType): bool {
  if (!collection.contains(article_identifier)) return false;

  // TODO: Handle eligibility
  // _VerifyContributorEligibility(provider);

  const author: Identity = new Identity(provider, context.sender);
  const comment: Comment = new Comment(comment_identifier, version_identifier, author, signature, type);
  const article: Article = collection.get(article_identifier)!;
  article.set_comment(comment);
  // In reality, how much we send here would depends on several factors (type and quality of the review, profile of the author of the comment, etc.)
  ContractPromiseBatch.create(context.sender).transfer(u128.from(100000000000000000000000));
  return true;
}

export function GetComment(article_identifier: string, comment_identifier: string): Comment | null {
  const article: Article | null = collection.get(article_identifier);
  if(article) {
    return article.get_comment(comment_identifier);
  } else {
    return null;
  }
}

export function AddMetadataToComment(article_identifier: string, comment_identifier: string, key: string, value: string): void {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier);
    if(article) {
      const comment: Comment | null = article.get_comment(comment_identifier);
      if(comment) comment.set_metadata(key, value);
    }
  }
}

export function GetMetadataFromComment(article_identifier: string, comment_identifier: string, key: string): string | null {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier)!;
    if(article) {
      const comment: Comment | null = article.get_comment(comment_identifier);
      if(comment) return comment.get_metadata(key);
      else return null;
    }
    else return null;
  } else return null;
}

export function AddResponse(article_identifier: string, comment_identifier: string, response_identifier: string, signature: string, provider: string): bool {
  if(!collection.contains(article_identifier)) return false;

  // TODO: Handle eligibility
  // _VerifyContributorEligibility(provider);

  const article: Article = collection.get(article_identifier)!;
  const author: Identity = new Identity(provider, context.sender);
  const comment: Comment | null = article.get_comment(comment_identifier);
  
  if(comment) {
    const response: Response = new Response(response_identifier, author, signature);
    comment.add_response(response);
    // In reality, how much we send here would depends on several factors (type and quality of the review, profile of the author of the comment, etc.)
  ContractPromiseBatch.create(context.sender).transfer(u128.from(10));
  }
  
  return true;
}

export function GetResponse(article_identifier: string, comment_identifier: string, response_identifier: string): Response | null {
  const article: Article | null = collection.get(article_identifier);
  if(article) {
    const comment: Comment | null = article.get_comment(comment_identifier);
    if(comment) {
      return comment.get_response(response_identifier);
    } else {
      return null;
    }
  } else {
    return null;
  }
}

export function AddMetadataToResponse(article_identifier: string, comment_identifier: string, response_identifier: string, key: string, value: string): void {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier);
    if(article) {
      const comment: Comment | null = article.get_comment(comment_identifier);
      if(comment) {
        const response: Response | null = comment.get_response(response_identifier);
        if(response) response.set_metadata(key, value);
      }
    }
  }
}

export function GetMetadataFromResponse(article_identifier: string, comment_identifier: string, response_identifier: string, key: string): string | null {
  if(_VerifyAdministrator()) {
    const article: Article | null = collection.get(article_identifier)!;
    if(article) {
      const comment: Comment | null = article.get_comment(comment_identifier);
      if(comment) {
        const response: Response | null = comment.get_response(response_identifier);
        if(response) return response.get_metadata(key);
        else return null;
      }
      else return null;
    }
    else return null;
  } else return null;
}

function _VerifyInitialization(): bool {
  return storage.hasKey('administrator') && storage.hasKey('network');
}

function _VerifyAdministrator(): bool {
  return storage.get<string>('administrator') == context.sender;
}

function _VerifyAuthor(): bool {
  return authors.has(context.sender);
}

function _VerifyContributorEligibility(provider: string): void {
  const promise = ContractPromise.create<string>(storage.get<string>('network') as string, 'RetrieveProvider', provider, 300000000000000, u128.Zero);
  const verification_of_identity = promise.then<string>(context.contractName, '_VerifyIdentity', context.sender, 300000000000000);
  verification_of_identity.returnAsResult();
}

function _VerifyIdentity(identity: string): void {
  const results: ContractPromiseResult[] = ContractPromise.getResults();
  const promise = ContractPromise.create<string>(results[0].buffer.toString(), 'VerifyIdentityExistence', identity, 300000000000000, u128.Zero);
  const verification_of_identity = promise.then<null>(context.contractName, '_ValidateResponse', null, 300000000000000);
  verification_of_identity.returnAsResult();
}

function _ValidateResponse(): void {
  const results: ContractPromiseResult[] = ContractPromise.getResults();
  if (bool(results[0].buffer.toString()) == false) throw new Error('Invalid identity');
}

'''
'''--- NEAR/Contracts/assembly/repository/model.ts ---
import { context } from 'near-sdk-core';
import { PersistentMap } from 'near-sdk-as';

export enum CommentType {
  ADDITION = 1,
  MODIFICATION = 2,
  CONTRADICTION = 3
}

@nearBindgen
export class Identity {
  provider: string;
  identifier: string;

  constructor(provider: string, identifier: string) {
    this.provider = provider;
    this.identifier = identifier;
  }

  get_provider(): string {
    return this.provider;
  }

  get_identifier(): string {
    return this.identifier;
  }
}

@nearBindgen
export class Response {
  identifier: string;
  author: Identity;
  signature: string;
  date: u64;
  metadata: PersistentMap<string, string>;

  constructor(identifier: string, author: Identity, signature: string, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('mr')) {
    this.identifier = identifier;
    this.author = author;
    this.signature = signature;
    this.date = context.blockTimestamp;
    this.metadata = metadata;
  }

  get_identifier(): string {
    return this.identifier;
  }

  get_author(): Identity {
    return this.author;
  }

  get_signature(): string {
    return this.signature;
  }

  set_metadata(key: string, value: string): void {
    // As a comment can have multiple responses and as Near uses a unique key/value store per contract, we mimic the management of the metadata by using sub-prefixes
    this.metadata.set(this.identifier + key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

@nearBindgen
export class Comment {
  identifier: string;
  article_version: string;
  author: Identity;
  signature: string;
  type: CommentType;
  date: u64;
  responses: PersistentMap<string, Response>;
  metadata: PersistentMap<string, string>;

  constructor(identifier: string, article_version: string, author: Identity, signature: string, type: CommentType, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('mc')) {
    this.identifier = identifier;
    this.author = author;
    this.signature = signature;
    this.type = type;
    this.date = context.blockTimestamp;
    this.metadata = metadata;
    this.article_version = article_version;
    this.responses = new PersistentMap<string, Response>('r');
  }

  get_identifier(): string {
    return this.identifier;
  }

  get_article_version(): string {
    return this.article_version;
  }

  get_author(): Identity {
    return this.author;
  }

  get_signature(): string {
    return this.signature;
  }

  get_type(): CommentType {
    return this.type;
  }

  add_response(response: Response): void {
    this.responses.set(response.get_identifier(), response);
  }

  get_response(identifier: string): Response | null {
    return this.responses.get(identifier);
  }

  set_metadata(key: string, value: string): void {
    // As an article can have multiple comments and as Near uses a unique key/value store per contract, we mimic the management of the metadata by using sub-prefixes
    this.metadata.set(this.identifier + key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

@nearBindgen
export class Version {
  identifier: string;
  version: string;
  signature: string;
  date: u64;

  constructor(identifier: string, version: string, signature: string) {
    this.identifier = identifier;
    this.version = version;
    this.signature = signature;
    this.date = context.blockTimestamp;
  }

  get_identifier(): string {
    return this.identifier;
  }

  get_version(): string {
    return this.version;
  }

  get_signature(): string {
    return this.signature;
  }
}

@nearBindgen
export class Article {
  identifier: string;
  author: Identity;
  versions: Version[];
  comments: PersistentMap<string, Comment>;
  metadata: PersistentMap<string, string>;

  constructor(identifier: string, author: Identity, version: Version, metadata: PersistentMap<string, string> = new PersistentMap<string, string>('ma')) {
    this.identifier = identifier;
    this.author = author;
    this.versions = [];
    this.versions.push(version);
    this.metadata = metadata;
    this.comments = new PersistentMap<string, Comment>('c');
  }

  get_identifier(): string {
    return this.identifier;
  }

  get_author(): Identity {
    return this.author;
  }

  add_version(version: Version): void {
    this.versions.push(version);
  }

  get_version(version: string): Version | null {
    const index: i32 = this.versions.findIndex((v: Version) => v['identifier'] == version);
    if(index != -1) return this.versions.at(index);
    else return null;
  }

  get_last_version(): Version {
    return this.versions.at(this.versions.length - 1);
  }

  set_comment(comment: Comment): void {
    this.comments.set(comment.get_identifier(), comment);
  }

  get_comment(identifier: string): Comment | null {
    return this.comments.get(identifier);
  }

  set_metadata(key: string, value: string): void {
    this.metadata.set(key, value);
  }

  get_metadata(key: string): string | null {
    return this.metadata.get(key);
  }
}

export const collection = new PersistentMap<string, Article>('article');
'''
'''--- NEAR/Contracts/assembly/repository/neardev/dev-account.env ---
CONTRACT_NAME=dev-1635670770533-92997932914997
'''
'''--- NEAR/Contracts/assembly/repository/tsconfig.json ---
{
  "extends": "../../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- NEAR/Contracts/package.json ---
{
  "name": "near-contract-builder",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "author": "Emmanuel Kellner, ArbÃ«r Salihi",
  "scripts": {
    "build": "asb",
    "build:debug": "asb --target debug",
    "deploy": "npm run build && near deploy",
    "dev": "npm run build:debug && near dev-deploy"
  },
  "devDependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- NEAR/Server/README.md ---
# Server

## Table of Contents

-   [Build](#build)
-   [Deploy](#deploy)
-   [Configuration](#configuration)
-   [Endpoints](#endpoints)
-   [License](#license)

## Build

To build this server, install npm packages:
```bash
$ npm install
```

Then start this script:
```bash
$ npm run build
```

## Deploy

For the first run, you should configure the tool appropriately and set the __deployment__ variable to *true* (see [Configuration](#configuration)).

Deployment of the server is done as follow:
```bash
$ npm install && npm run deploy
```

## Endpoints
Available endpoints are described below.

```bash
$ GET http://<host>:<port>/articles/:identifier
```
(where :identifier is the unique identifier of the article hosted on Filecoin)

```bash
$ POST http://<host>:<port>/articles
```
(where the submitted data are valid article metada, as per the model of the *repository* smart contract (see __Contracts__ folder))

```bash
$ GET http://<host>:<port>/articles/:article/version/:version/comments/:comment
```
(where :article is the unique identifier of the article hosted on Filecoin, :version the version of the article for which the comment should be added, and :comment the unique identifier of the comment hosted on Filecoin)

```bash
$ POST http://<host>:<port>/articles/:article/version/:version/comments
```
(with the same remarks as for the previous call, and the submitted data being valid comment metada, as per the model of the *repository* smart contract (see __Contracts__ folder))

## Configuration

A configuration file is available in __config/development.js__. Here, you can specify information about the NEAR blockchain and about the server.

For NEAR (*near* object of the configuration file):
- *network* is the network to use (by default, testnet)
- *credentials* is the folder where the keypairs of the keystore are hosted
- *deployment* should be *true* only during the initialization (i.e. when smart contracts should be deployed), otherwise the variable should be *false*
- endpoints are the different endpoints to use for the connection, as per NEAR documentation
- *accounts* is the list of accounts to use for the demonstration (each account having at least an *account* property referencing the address of the account, and a *private_key* related to this account)
- *contracts* is the set of contracts to deploy and use (*base* refers to where they are hosted, and each contract defines its own *file* (related to the base), its *name*, the *account* owning it, and the *methods* that it exposes)

## License

[MIT](LICENSE)

'''
'''--- NEAR/Server/config/custom-environment-variables.js ---
module.exports = {
    'core': {
        silent: 'CORE_SILENT_EXECUTION_MODE'
    },
    'near': {
        network: 'NEAR_NETWORK',
        credentials: 'NEAR_CREDENTIALS_FOLDER',
        deployment: 'NEAR_DEPLOYMENT',
        endpoints: {
            node: 'NEAR_ENDPOINTS_NODE',
            wallet: 'NEAR_ENDPOINTS_WALLET',
            helper: 'NEAR_ENDPOINTS_HELPER'
        },
        private_key: 'NEAR_PRIVATE_KEY',
        accounts: {
            provider: {
                name: 'NEAR_PROVIDER_NAME',
                account: 'NEAR_PROVIDER_ACCOUNT',
                private_key: 'NEAR_PROVIDER_PRIVATE_KEY'
            },
            publisher: {
                account: 'NEAR_PUBLISHER_ACCOUNT',
                private_key: 'NEAR_PUBLISHER_PRIVATE_KEY'
            },
            journalist: {
                account: 'NEAR_JOURNALIST_ACCOUNT',
                private_key: 'NEAR_JOURNALIST_PRIVATE_KEY'
            },
            commenter: {
                account: 'NEAR_COMMENTER_ACCOUNT',
                private_key: 'NEAR_COMMENTER_PRIVATE_KEY'
            },
            network: {
                account: 'NEAR_NETWORK_ACCOUNT',
                private_key: 'NEAR_NETWORK_PRIVATE_KEY'
            }
        },
        contracts: {
            base: 'NEAR_CONTRACTS_BASE_FOLDER',
            provider: {
                file: 'NEAR_PROVIDER_CONTRACT_FILE',
                name: 'NEAR_PROVIDER_CONTRACT_NAME',
                account: 'NEAR_PROVIDER_CONTRACT_PARENT'
            },
            repository: {
                file: 'NEAR_REPOSITORY_CONTRACT_FILE',
                name: 'NEAR_REPOSITORY_CONTRACT_NAME',
                account: 'NEAR_REPOSITORY_CONTRACT_PARENT'
            },
            network: {
                file: 'NEAR_NETWORK_CONTRACT_FILE',
                name: 'NEAR_NETWORK_CONTRACT_NAME',
                account: 'NEAR_NETWORK_CONTRACT_PARENT'
            }
        }
    },
    'server': {
        protocol: 'SERVER_PROTOCOL',
        host: 'SERVER_HOST',
        port: 'SERVER_PORT'
    }
};
'''
'''--- NEAR/Server/config/development.js ---
const cp = require('child_process');

const HOME_DIRECTORY = cp.execSync(`getent passwd \${SUDO_USER:-$USER} | cut -d: -f6 | tr -d '\n'`, { stdio: 'pipe' }).toString();

module.exports = {
    'env': 'development',
    'core': {
        silent: true
    },
    'near': {
        network: 'testnet',
        credentials: `${ HOME_DIRECTORY }/.near-credentials`,
        deployment: true,
        endpoints: {
            node: 'https://rpc.testnet.near.org',
            wallet: 'https://wallet.testnet.near.org',
            helper: 'https://helper.testnet.near.org'
        },
        accounts: {
            provider: {
                name: 'Geneva University Hospitals',
                account: 'geneva-university-hospitals.testnet',
                private_key: '3fySBSGw3QQxTMQ3gjP6aGcZAzbv8Qc2xHjKwUci1gh28egjUMmpjD5VU8tU9iU8gkZu7WKka833sQhos4KhYd6q'
            },
            publisher: {
                account: 'news-publisher.testnet',
                private_key: '64j1A6zm4SB22kRvsePTkGbeK8J3RFXBbU45KqDZYkaxr7SyLTsrsktYY8hL68ieuWqQQnbgZyrvNgfgtxvd9QZF'
            },
            journalist: {
                account: 'encode-journalist.testnet',
                private_key: '5zJU2CKckiZcCVMyDfvaTMHDr62N3gF6vMnAb5g2Jyt9RvP7C88PNYuShJj8rwA11HXjVbYFEYqaZRJvXYVmFRya'
            },
            commenter: {
                account: 'encode-commenter.testnet',
                private_key: '235a3QWWvxQFqfg9XGBCrA8HDnGmDdvASwk54GJmbGii9R5MDJAJEq9E8rcBWrboVQvzDMasuP1KVJhsLyJauP7E'
            },
            network: {        
                account: 'encode2021.testnet',
                private_key: 'RcSyYQ9tvEbdqGAHa3PrKAJaqM8MaDCmbKH89ZbhhjLh7xGeezzobfm2uX4Fm5V5xh4Bb13ijgPYoeJrGChqAdt'
            }
        },
        contracts: {
            base: `${ HOME_DIRECTORY }/NEAR/Contracts/assembly`,
            provider: {
                file: 'identity-provider/out/main.wasm',
                name: 'id-doctors-v2',
                account: 'geneva-university-hospitals.testnet',
                methods: {
                    viewMethods: ['RetrieveIdentity', 'GetMetadata', 'GetRole'],
                    changeMethods: ['Initialize', 'ChangeProvider', 'AddIdentity', 'VerifyIdentity', 'AddMetadata', 'AddRole']
                }
            },
            repository: {
                file: 'repository/out/main.wasm',
                name: 'repository-v2',
                account: 'news-publisher.testnet',
                methods: {
                    viewMethods: ['GetArticle', 'GetMetadataFromArticle', 'GetComment', 'GetMetadataFromComment', 'GetResponse', 'GetMetadataFromResponse'],
                    changeMethods: ['Initialize', 'ChangeAdministrator', 'ChangeNetwork', 'AddAuthor', 'RemoveAuthor', 'AddArticle', 'AddMetadataToArticle', 'AddVersion', 'AddComment', 'AddMetadataToComment', 'AddResponse', 'AddMetadataToResponse']
                }
            },
            network: {
                file: 'network/out/main.wasm',
                name: 'network-v2',
                account: 'encode2021.testnet',
                methods: {
                    viewMethods: ['RetrievePublisher', 'RetrieveProvider', 'GetMetadata'],
                    changeMethods: ['Initialize', 'ChangeOwner', 'AddPublisher', 'AddProvider', 'VerifyIdentity', 'AddMetadata']
                }
            }
        }
    },
    'server': {
        protocol: 'http',
        host: 'localhost',
        port: 3001,
        authorized_clients: []
    }
};
'''
'''--- NEAR/Server/package.json ---
{
  "name": "near-library",
  "version": "1.0",
  "description": "NEAR library to interact with the smart contracts",
  "main": "./dist/index.js",
  "author": "Emmanuel Kellner, ArbÃ«r Salihi",
  "scripts": {
    "clean": "ttsc --build --clean && shx rm -rf dist",
    "build": "npm run clean && ttsc",
    "start": "node -r ts-node/register -r tsconfig-paths/register ./dist/index.js",
    "deploy": "npm run build && npm run start"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/config": "^0.0.39",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/lodash": "^4.14.177",
    "@types/node": "^14.14.37",
    "@types/shelljs": "^0.8.9",
    "shx": "^0.3.3",
    "ts-loader": "^8.1.0",
    "tsconfig-paths": "^3.12.0",
    "ttypescript": "^1.5.12",
    "typescript": "^4.3.5",
    "typescript-transform-paths": "^2.2.3"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "config": "^3.3.6",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "lodash": "^4.17.21",
    "near-api-js": "^0.43.1",
    "shelljs": "^0.8.4"
  }
}

'''
'''--- NEAR/Server/src/controllers/near.ts ---
import config from 'config';
import BN from 'bn.js';
import { omit } from 'lodash';
import { Account, connect, ConnectConfig, Contract, keyStores, KeyPair, Near, WalletConnection } from 'near-api-js';

import { ReadFile } from '@server/helpers/functions';
import { AddAuthorToRepository, InitializeNetwork, InitializeRepository, RegisterIdentityProvider } from '@server/controllers/orchestrator';

export let KEYSTORE: keyStores.UnencryptedFileSystemKeyStore;
export let INSTANCE: Near;
export let WALLET: WalletConnection;
export let ACCOUNT: Account;
export const CONTRACTS: { [key: string]: Contract } = {};

export async function InitializeNEAR(): Promise<void> {
    console.log('Initializing NEAR..');
    await InitializeKeystore();
    await Connect();
    await InitializeContracts();

    if(config.get('near.deployment')) {
        await InitializeNetwork();
        await RegisterIdentityProvider(config.get('near.accounts.provider.name'), `${config.get('near.contracts.provider.name')}.${config.get('near.contracts.provider.account')}`)
        await InitializeRepository(`${config.get('near.contracts.network.name')}.${config.get('near.contracts.network.account')}`);
        AddAuthorToRepository(config.get('near.accounts.journalist.account'));
    }
    console.log('NEAR successfully initialized');
}

export async function InitializeKeystore(): Promise<void> {
    KEYSTORE = new keyStores.UnencryptedFileSystemKeyStore(config.get('near.credentials'));
    /* Main accounts should be added manually instead
    for (const data of Object.values<any>(config.get<any>('near.accounts'))) {
        console.log(`Registering account in keystore: ${data['account']}`);
        const pair = KeyPair.fromString(data['private_key']);
        await KEYSTORE.setKey(config.get('near.network'), data['account'], pair);
    }*/
}

export async function Connect(): Promise<void> {
    const configuration: ConnectConfig = {
        keyStore: KEYSTORE,
        networkId: config.get('near.network'),
        nodeUrl: config.get('near.endpoints.node'),
        walletUrl: config.get('near.endpoints.wallet'),
        helperUrl: config.get('near.endpoints.helper')
    };
    INSTANCE = await connect(configuration);
}

export async function LoadAccount(account: string): Promise<void> {
    ACCOUNT = await INSTANCE.account(account);
    console.log(`Account loaded: ${ACCOUNT.accountId}`);
}

export async function GetBalance(account: string): Promise<any> {
    return await ACCOUNT.getAccountBalance();
}

export async function InitializeContracts(): Promise<void> {
    const contracts = omit(config.get('near.contracts'), ['base']);
    for (const [reference, contract] of Object.entries<any>(contracts)) {
        if (config.get('near.deployment')) {
            console.log(`Deploying contract: ${contract['name']} (account: ${contract['account']})`);
            const pair = KeyPair.fromRandom('ed25519');
            const pub = pair.getPublicKey().toString();
            await LoadAccount(contract['account']);
            await KEYSTORE.setKey(config.get('near.network'), `${contract['name']}.${contract['account']}`, pair);
            await ACCOUNT.createAccount(`${contract['name']}.${contract['account']}`, pub, new BN('5000000000000000000000000'));
            await LoadAccount(`${contract['name']}.${contract['account']}`);
            await ACCOUNT.deployContract(ReadFile(`${config.get('near.contracts.base')}/${contract['file']}`));
        }

        await LoadAccount(contract['account']);
        CONTRACTS[reference] = new Contract(
            ACCOUNT,
            `${contract['name']}.${contract['account']}`,
            contract['methods']
        );
    }
}
'''
'''--- NEAR/Server/src/controllers/orchestrator.ts ---
import config from 'config';
import { Contract } from 'near-api-js';

import { ACCOUNT, CONTRACTS, LoadAccount } from '@server/controllers/near';
import { Article, Comment } from '@server/helpers/types';

export async function InitializeNetwork(): Promise<void> {
    await LoadAccount(`${config.get('near.contracts.network.name')}.${config.get('near.contracts.network.account')}`);

    await (CONTRACTS['network'] as any).Initialize({ args: {} });
}

export async function RegisterIdentityProvider(identifier: string, contract: string): Promise<void> {
    await LoadAccount(`${config.get('near.contracts.network.name')}.${config.get('near.contracts.network.account')}`);

    await (CONTRACTS['network'] as any).AddProvider({ args: { identifier, contract } });
}

export async function InitializeRepository(network: string): Promise<void> {
    await LoadAccount(`${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`);

    await (CONTRACTS['repository'] as any).Initialize({ args: { 'network': network } });
}

export async function AddAuthorToRepository(author: string): Promise<void> {
    await LoadAccount(`${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`);

    await (CONTRACTS['repository'] as any).AddAuthor({ args: { 'author': author } });
}

export async function AddArticleToRepository(article: Article, author: string): Promise<void> {
    await LoadAccount(author);

    const contract_called_by_author = new Contract(
        ACCOUNT,
        `${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`,
        config.get('near.contracts.repository.methods')
    );

    await (contract_called_by_author as any).AddArticle({ args: article });
}

export async function GetArticleFromRepository(identifier: string): Promise<Article> {
    await LoadAccount(`${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`);

    return await (CONTRACTS['repository'] as any).GetArticle({ identifier });
}

export async function AddCommentToRepository(comment: Comment, author: string): Promise<void> {
    await LoadAccount(author);

    const contract_called_by_author = new Contract(
        ACCOUNT,
        `${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`,
        config.get('near.contracts.repository.methods')
    );

    await (contract_called_by_author as any).AddComment({ args: comment });
}

export async function GetComment(article: string, version: string, comment: string): Promise<Comment> {
    await LoadAccount(`${config.get('near.contracts.repository.name')}.${config.get('near.contracts.repository.account')}`);

    return await (CONTRACTS['repository'] as any).GetComment({ article_identifier: article, version_identifier: version, comment_identifier: comment });
}
'''
'''--- NEAR/Server/src/helpers/constants.ts ---
import config from 'config';

import { ExecutionOptions, RecursivePartial } from '@server/helpers/types';

export const DEFAULT_EXECUTION_OPTIONS: RecursivePartial<ExecutionOptions> = { silent: config.has('core.silent') ? config.get('core.silent') : true, critical: true };

export const SERVER_ENDPOINT: string = `${config.get('server.protocol')}://${config.get('server.host')}:${config.get('server.port')}`;

export const SHUTDOWN_SIGNALS: NodeJS.Signals[] = ['SIGABRT', 'SIGBUS', 'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM'];
export const TIMEOUT_BEFORE_FORCED_SHUTDOWN: number = 10000;
export const SHUTDOWN_LISTENERS: { operation: string, listener: () => any | Promise<any> }[] = [];
'''
'''--- NEAR/Server/src/helpers/functions.ts ---
import { readFileSync } from 'fs';
import { omitBy as omit_by, isNil as is_nil } from 'lodash';
import { exec, ShellString } from 'shelljs';

import { ExecutionOptions, RecursivePartial } from '@server/helpers/types';
import { DEFAULT_EXECUTION_OPTIONS, TIMEOUT_BEFORE_FORCED_SHUTDOWN, SHUTDOWN_LISTENERS } from '@server/helpers/constants';

export function ReadFile(location: string): Buffer {
    try {
        return readFileSync(location);
    } catch {
        throw new Error(`Could not read file: ${ location }`);
    }
}

export function ExecuteCommand(command: string, options: RecursivePartial<ExecutionOptions> = DEFAULT_EXECUTION_OPTIONS): ShellString {
    options = Object.assign({}, DEFAULT_EXECUTION_OPTIONS, options);

    const result: ShellString = exec(command, { silent: options['silent'] });

    if (result.code !== 0) {
        console.log(result.stderr);

        if (options['critical']) {
            throw new Error(`An error occurred while executing command: ${command}`);
        }
        else return result;
    } else {
        if (options['silent'] === false) console.log(result.stdout);
        return result;
    }
}

export function RegisterProcessShutdownListener(operation: string, listener: () => any | Promise<any>): () => any | Promise<any> {
    SHUTDOWN_LISTENERS.push({ operation, listener });
    return listener;
}

export async function Shutdown(): Promise<void> {
    // console.clear();
    console.log('[CORE] Module is exiting gracefully...');

    for(const entry of SHUTDOWN_LISTENERS) {
        try {
            console.log(`[CORE] Executing operation: ${entry['operation']}`);
            await entry['listener']();
            console.log(`[CORE] Operation executed successfully: ${entry['operation']}`);
        } catch (error) {
            console.warn(`[CORE] Operation '${entry['operation']}' failed before completing: ${error}`);
        }
    }

    console.log('[CORE] All operations handled correctly. Exiting.');
    process.nextTick(() => process.exit(0));
}

export const FORCE_EXIT_FUNCTION = (timeout: number = TIMEOUT_BEFORE_FORCED_SHUTDOWN) => () => {
    setTimeout((): never => {
        console.warn(`[CORE] Module could not be stopped gracefully after ${timeout}ms: forcing shutdown`);
        return process.exit(1);
    }, timeout).unref();
};

// This function does not support complex objects where a custom function is needed to perform the sort
export function Sort(object: { [key: string]: any }): Object {
    return Object.keys(omit_by(object, is_nil)).sort().reduce((accumulator: Object, key: string) => {
        if (object[key]) {
            let element: any = (typeof object[key] == 'object') ? ((object[key] instanceof Array) ? [...object[key]].sort() : Sort(object[key])) : object[key];
            return { ...accumulator, [key]: element };
        } else {
            return { ...accumulator };
        }
    }, {});
}
'''
'''--- NEAR/Server/src/helpers/types.ts ---
export type RecursivePartial<T> = { [P in keyof T]?: RecursivePartial<T[P]> };
export type ExecutionOptions = { silent: boolean, critical: boolean };
export type Failure = { success: false, errors?: string[] };
export type Success<T> = { success: true, response: T };
export type Response<T> = Failure | Success<T>;

export type Article = { 'identifier': string, 'initial_version': string, 'signature': string, 'provider': string };
export type Comment = { 'article_identifier': string, 'version_identifier': string, 'comment_identifier': string, 'type': number, 'signature': string, 'provider': string };
'''
'''--- NEAR/Server/src/index.ts ---
import { SHUTDOWN_SIGNALS } from '@server/helpers/constants';
import { RegisterProcessShutdownListener, Shutdown, FORCE_EXIT_FUNCTION } from '@server/helpers/functions';
import { InitializeNEAR } from '@server/controllers/near';
import { Server, InitializeServer } from '@server/server/server';

async function Initialize(): Promise<void> {
    try {
        console.log('NEAR SERVER');
        console.log('***********');
        RegisterShutdownEvents();
        RegisterShutdownListeners();
        await InitializeNEAR();
        await InitializeServer();
    } catch(error) {
        console.error('AN ERROR OCCURRED DURING INITIALIZATION');
		console.error(error);
		return await Shutdown();
    }
}

function RegisterShutdownEvents(): void {
    console.log('Registering shutdown events...');

    SHUTDOWN_SIGNALS.forEach((signal: NodeJS.Signals) => {
        process.on(signal, FORCE_EXIT_FUNCTION());
        process.on(signal, Shutdown);
    });

    process.on('beforeExit', FORCE_EXIT_FUNCTION());
    process.on('beforeExit', Shutdown);

    console.log('Shutdown events registered successfully');
}

function RegisterShutdownListeners(): void {
    console.log('Registering shutdown listeners...');

    RegisterProcessShutdownListener('server shutdown', async () => Server.close());

    console.log('Shutdown listeners registered successfully');
}

Initialize();
'''
'''--- NEAR/Server/src/server/cors.ts ---
import config from 'config';
import cors = require('cors');

export const CORS_STRATEGY = cors({
	origin: (origin: string | undefined, callback: (error: Error | null, allow?: boolean) => void) => {
		if (!origin) callback(null, false);
		else VerifyCORS(origin, callback);
	}, credentials: true
});

const AUTHORIZED_ENDPOINTS: string[] = config.has('server.authorized_clients') ? config.get('server.authorized_clients') : [];

function VerifyCORS(origin: string, callback: (error: any, success: boolean) => void): void {
    if (AUTHORIZED_ENDPOINTS.includes(origin!)) {
        callback(null, true);
    } else {
        callback(null, false);
    };
}
'''
'''--- NEAR/Server/src/server/express.ts ---
import express from 'express';

import { CORS_STRATEGY } from '@server/server/cors';
import { Router as LocalRouter } from '@server/server/router';

const server: express.Express = express();

server.use(express.urlencoded({ extended: true }));
server.use(express.urlencoded({ extended: false }));
server.use(express.json());
server.use(CORS_STRATEGY);
server.use('/', LocalRouter);

export { server as ExpressServer };
'''
'''--- NEAR/Server/src/server/router.ts ---
import { Router } from 'express';

import { Routes } from '@server/server/routes';

const router: Router = Router({ mergeParams: true });

router.use('/', Routes);

export { router as Router };
'''
'''--- NEAR/Server/src/server/routes.ts ---
import { NextFunction, Request, Response, Router } from 'express';

import { AddArticleToRepository, AddCommentToRepository, GetArticleFromRepository, GetComment } from '@server/controllers/orchestrator';
import { Article, Comment } from '@server/helpers/types';

const router: Router = Router({ mergeParams: true });

router.get('/articles/:identifier', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const identifier: string = req.params['identifier'];

	try {
        const article: Article = await GetArticleFromRepository(identifier);
		res.status(200).send(article);
	} catch(error) {
		console.error(`[SERVER] Error while retrieving data from repository: ${ error }`);
		res.status(500).send('An internal error occurred while retrieving data from repository');
	}
});

router.post('/articles', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const article: Article = req.body['article'];
    const author: string = req.body['author'];

	if(!author|| !article['identifier'] || !article['initial_version'] || !article['signature'] || !article['provider']) {
		res.status(404).send('Malformed request');
	} else {
		try {
			await AddArticleToRepository(article, author);
			res.status(200).send(article);
		} catch(error) {
			console.error(`[SERVER] Error while storing article: ${ error }`);
			res.status(500).send('An internal error occurred while registering article in repository');
		}
	}
});

router.get('/articles/:article/version/:version/comments/:comment', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const article_identifier: string = req.params['article'];
    const article_version: string = req.params['version'];
    const comment_identifier: string = req.params['comment'];

	try {
        const comment: Comment = await GetComment(article_identifier, article_version, comment_identifier);
		res.status(200).send(comment);
	} catch(error) {
		console.error(`[SERVER] Error while retrieving data from repository: ${ error }`);
		res.status(500).send('An internal error occurred while retrieving data from repository');
	}
});

router.post('/articles/:article/version/:version/comments', async (req: Request, res: Response, next: NextFunction): Promise<void> => {
	const article: string = req.params['article'];
    const version: string = req.params['version'];
    const comment: Omit<Comment, 'article_identifier' | 'version_identifier'> = req.body['comment'];
    const author: string = req.body['author'];
    if(!author || !comment['comment_identifier'] || !comment['type'] || !comment['signature'] || !comment['provider']) {
		res.status(404).send('Malformed request');
	} else {
		try {
			await AddCommentToRepository(Object.assign(comment, { 'article_identifier': article, 'version_identifier': version }), author);
			res.status(200).send(comment);
		} catch(error) {
			console.error(`[SERVER] Error while storing comment: ${ error }`);
			res.status(500).send('An internal error occurred while associating comment to article');
		}
	}
});

export { router as Routes };
'''
'''--- NEAR/Server/src/server/server.ts ---
import config from 'config';
import { Server } from 'http';

import { ExpressServer } from '@server/server/express';
import { SERVER_ENDPOINT } from '@server/helpers/constants';

const server: Server = new Server(ExpressServer);

export async function InitializeServer(): Promise<void> {
    console.log('Initializing server...');
    server.listen(config.get('server.port'), () => { console.log(`Server started: ${SERVER_ENDPOINT}`) });
}

export { server as Server };
'''
'''--- NEAR/Server/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2015",
    "module": "commonjs",
    "lib": ["ES2021", "dom"],
    "outDir": "./dist",
    "strict": true,
    "baseUrl": "./src",
    "paths": {"@server/*": ["*"]},
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "plugins": [
      {
        "transform": "typescript-transform-paths"
      },
      {
        "transform": "typescript-transform-paths",
        "afterDeclarations": true
      }
    ]
  }
}

'''
'''--- README.md ---

# News For Trust

NewsForTrust aims to provide a platform for certifying and incentivize experts' contributions and comments on publishing platforms valuing high-quality dialogue.

Publishers joining the network are able to build expertise-defined collections of articles and allow for contributors to participate new information to them.
Whether these are from parties externally validated as experts in the field, or simply from readers voicing their takes with or without source, contributions and comments are keyed in with their writer' persona ID, and rewarded depending on a publisher-defined scheme.

Contracts are built on the NEAR Platform and allow:
- ChainedTrust to integrate new actors, Publishers and ID providers
- ID Providers to validate the real identity of an actor, linking their key to data representing their expertise field and level
- ID Providers to validate the real identity of an actor, linking their key to data representing their expertise field and level
- Collections to manage their sets of articles and corresponding comments, and value and reward contributions

## Project organisation and FILECOIN, NEAR, CLI tools codebases

_Please see the following repositories, and their respective README.md_

For Filecoin:
- the Server developed is hosted here: https://github.com/Ornythoma/NewsForTrust/tree/master/Filecoin/Server
- specifically, the controllers (main logic) are there: https://github.com/Ornythoma/NewsForTrust/tree/master/Filecoin/Server/src/controllers 

For NEAR:
- the smart contracts are here: https://github.com/Ornythoma/NewsForTrust/tree/master/NEAR/Contracts 
- the Server managing NEAR contracts, it is hosted here: https://github.com/Ornythoma/NewsForTrust/tree/master/NEAR/Server 
- specifically, the controllers (main logic) are there: https://github.com/Ornythoma/NewsForTrust/tree/master/NEAR/Server/src/controllers 
- the appropriate configuration is here: https://github.com/Ornythoma/NewsForTrust/blob/master/NEAR/Server/config/development.js 

For the CLI tool to manage the whole logic (submission of articles and comments to Filecoin (content) and NEAR (metadata)), we use:
- this repository : https://github.com/Ornythoma/NewsForTrust/tree/master/CLI .
- specifically, the logic related to the CLI is hosted in this file: https://github.com/Ornythoma/NewsForTrust/blob/master/CLI/src/controllers/cli.ts

## DEVELOPMENT 
- TypeScript
- Express.JS for REST API
- configuration (cf. configuration files + environment variables defined for that), 
- clear modularization (main entry point, controllers, ExpressJS server (including router and related routes), helpers, etc.)

## Why NEAR?

- Multichain support, which enables a whole ecosystem where identity providers and publishers may interact while being on different chains
- Design scalable-friendly and enforcement of low fees for transactions and contract calls, which is really important in this context, as articles, comments and responses are expected to be published regularly and in a consequent way
- Support for account names, which facilitates the identification of the actors of the ChainedTrust ecosystem easily, abstracting intrinsic complexity of traditional blockchain where users have to use private/public keys and long addresses
- Support of AssemblyScript in addition to Rust, which eases the integration within web applications where articles, comments and responses are expected to be submitted and verified

  
## Authors

ArbÃ«r Salihi & Emmanuel Kellner

'''
'''--- Website/cloud.html ---
<html>
  <head>
    <title></title>
    <meta content="">
    <style></style>
  </head>
  <body></body>
</html>
'''
'''--- Website/covid.html ---
<!DOCTYPE html>
<html lang="en">
<head>
	<title>Geneva News News: COVID</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
	<style>
	.fakeimg {
		height: 200px;
		background: #aaa;
	}
	</style>
</head>
<body>

<div class="jumbotron text-center" style="margin-bottom:0">
	<h1>Geneva News News</h1>
	<p>Proudly powered by ChainedTrust, your Trusted News Ecosystem!</p> 
</div>

<nav class="navbar navbar-expand-sm bg-dark navbar-dark">
	<a class="navbar-brand" href="#">Navbar</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="collapsibleNavbar">
		<ul class="navbar-nav">
			<li class="nav-item">
				<a class="nav-link" href="#">Health</a>
			</li>
			<li class="nav-item">
				<a class="nav-link" href="#">World</a>
			</li>
			<li class="nav-item">
				<a class="nav-link" href="#">Local</a>
			</li>    
		</ul>
	</div>  
</nav>

<div class="container" style="margin-top:30px">
	<div class="row">
		<div class="col-sm-3">
			<h2>Lesser value news</h2>
			<h5>Our latest expert:</h5>
			<div class="portrait">
				<img src="img/jhm.png" class="img-thumbnail" alt="jean-henry morin">
			</div>
			<p>Prof. Jean-Henry Morin, UNIGE IS</p>
			<h3>Activity</h3>
			<p>Latest comments on:</p>
			<ul class="nav nav-pills flex-column">
				<li class="nav-item">
					<a class="nav-link" href="#">Link</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#">Link</a>
				</li>
				<li class="nav-item">
					<a class="nav-link disabled" href="#">Disabled</a>
				</li>
			</ul>
			<hr class="d-sm-none">
		</div>
		<div class="col-sm-6">
		<div class="row position-relative">
			<a class="stretched-link" href="covid.html">
				<div class="col-12">
					<h2>Was COVID-19 Only A Lucky Wild Strain? Experts Disagree.</h2>
					<h5>Marin Jenicke, Oct 4, 2021</h5>
					<img src="img/covid.png" class="img-thumbnail" alt="covid is fake">
					<p>Experts agree: COVID might not be as natural as we thought. Medical practitionners around the world are surprised by its characteristics, and many dubbed them 'unnatural'...</p>
					<br>
				</div>
			</a>
		</div>
		<div class="row position-relative">
			<a class="stretched-link" href="cloud.html">
				<div class="col-12">
					<h2>Swiss Cloud: Never Fear The Future</h2>
					<h5>Schipe Bytyqi, Sep 29, 2021</h5>
					<img src="img/cloud.png" class="img-thumbnail" alt="cloud is good">
					<p>Should "Swiss Made" quality mandatory for a government, country-wise data-store? Majority of researchers agree that there is value in self-governance and determination of our digital twins...</p>
				</div>
			</a>
		</div>
	</div>
	<div class="col-sm-3">
		<h2>Local News</h2>
		<div class="row position-relative">
			<a class="stretched-link" href="foodwaste.html">
				<h5>Food waste is ignored</h5>
				<img src="img/foodwaste.png" class="img-thumbnail" alt="food waste">
				<p>Can we do better</p>
			</a>
		</div>
		<div class="row position-relative">
			<a class="stretched-link" href="vaccinodrome.html">
				<h5>Vaccinodromes are empty</h5>
				<img src="img/vaccine.jpg" class="img-thumbnail" alt="vaccine">
				<p>Local reporter hides to get exclusie footage</p>
			</a>
		</div>
		<hr class="d-sm-none">
	</div>
</div>

<div class="jumbotron text-center" style="margin-bottom:0">
	<p>Geneva News News, powered by ChainedTrust</p>
</div>

</body>
</html>

'''
'''--- Website/home.html ---
<!DOCTYPE html>
<html lang="en">
<head>
	<title>Geneva News News</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
	<style>
	.fakeimg {
		height: 200px;
		background: #aaa;
	}
	</style>
</head>
<body>

<div class="jumbotron text-center" style="margin-bottom:0">
	<h1>Geneva News News</h1>
	<p>Proudly powered by ChainedTrust, your Trusted News Ecosystem!</p> 
</div>

<nav class="navbar navbar-expand-sm bg-dark navbar-dark">
	<a class="navbar-brand" href="#">Navbar</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="collapsibleNavbar">
		<ul class="navbar-nav">
			<li class="nav-item">
				<a class="nav-link" href="#">Health</a>
			</li>
			<li class="nav-item">
				<a class="nav-link" href="#">World</a>
			</li>
			<li class="nav-item">
				<a class="nav-link" href="#">Local</a>
			</li>    
		</ul>
	</div>  
</nav>

<div class="container" style="margin-top:30px">
	<div class="row">
		<div class="col-sm-3">
			<h2>Lesser value news</h2>
			<h5>Our latest expert:</h5>
			<div class="portrait">
				<img src="img/jhm.png" class="img-thumbnail" alt="jean-henry morin">
			</div>
			<p>Prof. Jean-Henry Morin, UNIGE IS</p>
			<h3>Activity</h3>
			<p>Latest comments on:</p>
			<ul class="nav nav-pills flex-column">
				<li class="nav-item">
					<a class="nav-link" href="#">Link</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="#">Link</a>
				</li>
				<li class="nav-item">
					<a class="nav-link disabled" href="#">Disabled</a>
				</li>
			</ul>
			<hr class="d-sm-none">
		</div>
		<div class="col-sm-6">
		<div class="row position-relative">
			<a class="stretched-link" href="covid.html">
				<div class="col-12">
					<h2>Was COVID-19 Only A Lucky Wild Strain? Experts Disagree.</h2>
					<h5>Marin Jenicke, Oct 4, 2021</h5>
					<img src="img/covid.png" class="img-thumbnail" alt="covid is fake">
					<p>Experts agree: COVID might not be as natural as we thought. Medical practitionners around the world are surprised by its characteristics, and many dubbed them 'unnatural'...</p>
					<br>
				</div>
			</a>
		</div>
		<div class="row position-relative">
			<a class="stretched-link" href="cloud.html">
				<div class="col-12">
					<h2>Swiss Cloud: Never Fear The Future</h2>
					<h5>Schipe Bytyqi, Sep 29, 2021</h5>
					<img src="img/cloud.png" class="img-thumbnail" alt="cloud is good">
					<p>Should "Swiss Made" quality mandatory for a government, country-wise data-store? Majority of researchers agree that there is value in self-governance and determination of our digital twins...</p>
				</div>
			</a>
		</div>
	</div>
	<div class="col-sm-3">
		<h2>Local News</h2>
		<div class="row position-relative">
			<a class="stretched-link" href="foodwaste.html">
				<h5>Food waste is ignored</h5>
				<img src="img/foodwaste.png" class="img-thumbnail" alt="food waste">
				<p>Can we do better</p>
			</a>
		</div>
		<div class="row position-relative">
			<a class="stretched-link" href="vaccinodrome.html">
				<h5>Vaccinodromes are empty</h5>
				<img src="img/vaccine.jpg" class="img-thumbnail" alt="vaccine">
				<p>Local reporter hides to get exclusie footage</p>
			</a>
		</div>
		<hr class="d-sm-none">
	</div>
</div>

<div class="jumbotron text-center" style="margin-bottom:0">
	<p>Geneva News News, powered by ChainedTrust</p>
</div>

</body>
</html>

'''
'''--- article.json ---
{
    "identifier": "http://www.publisher.com/news/world/china-pneumonia-outbreak-virus-58450",
    "provider": "Geneva University Hospitals",
    "publisher": "Publisher Inc.",
    "date": "2020-01-08",
    "author": "A journalist",
    "content": "China officials alerted WHO about a new pneumonia outbreak identified two weeks ago now in the region of Wuhan. (...)",
    "metadata": {
        "metadata1": "value1",
        "metadata2": "value2"
    }
}

'''
'''--- comment.json ---
{
    "article": "http://www.publisher.com/news/world/china-pneumonia-outbreak-virus-58420/comments/comment5",
    "version": "version1",
    "comment": "http://www.publisher.com/news/world/china-pneumonia-outbreak-virus-58420/comments/comment5",
    "date": "2020-01-09",
    "provider": "Geneva University Hospitals",
    "author": "A commenter",
    "content": "As an international expert, I confirm that some local officials have reported new cases from an unidentified virus in the region of Wuhan to the Global Health Alert System (GHAS)."
}

'''