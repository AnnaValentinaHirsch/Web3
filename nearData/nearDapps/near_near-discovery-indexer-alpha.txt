*GitHub Repository "near/near-discovery-indexer-alpha"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# Indexer tutorials

This repository contains the code for indexer tutorials from official documentation.

## Contents

* example-indexer https://docs.near.org/docs/tools/near-indexer

'''
'''--- example-indexer/Cargo.toml ---
[package]
name = "example-indexer"
version = "0.3.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[dependencies]
actix = "=0.13.0"
actix-web = "4.3.0"
# actix-http = "=3.0.0-beta.6"
actix-tls = "3.0.0"
actix-rt = "2.2.0"
bigdecimal = "=0.1.0"
anyhow = "1.0.51"
diesel = { version = "1.4.7", features = ["postgres", "numeric", "serde_json"] }
diesel-derive-enum = { git = "https://github.com/khorolets/diesel-derive-enum.git", branch = "lookup-hack", features = ["postgres"] }

openssl-probe = { version = "0.1.2" }
# futures = "0.3.5"
tokio = { version = "1.1", features = ["time", "sync", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
dotenv = "0.15.0"
tracing = "0.1.13"
tracing-subscriber = "0.2.4"
paperclip = { version = "=0.7.0", features = ["actix4"] }
paperclip-actix = "=0.5.0"
paperclip-macros = "=0.6.0"

serde = { version = "1", features = [ "derive" ] }
serde_json = "1"

actix-diesel = { git = "https://github.com/frol/actix-diesel", branch="actix-0.13" }
near-indexer = { git = "https://github.com/near/nearcore", rev = "1.31.0" }

'''
'''--- example-indexer/README.md ---
# example-indexer

This repository contains finished code for Indexer tutorial from official docs https://docs.near.org/docs/tools/near-indexer

'''
'''--- example-indexer/diesel.toml ---
# For documentation on how to configure this file,
# see diesel.rs/guides/configuring-diesel-cli

[print_schema]
file = "src/schema.rs"
# patch_file = "src/schema.patch"
import_types = ["diesel::sql_types::*", "crate::models::enums::*"]
# Exclicitly setting `only_tables` to avoid technical tables created by diesel to be included in schema
filter = { only_tables = [
    "events", "receipts"
] }

'''
'''--- example-indexer/migrations/2022-03-18-000000_initial_scam/down.sql ---
DROP TABLE public.events;

DROP TYPE public.execution_outcome_status;

'''
'''--- example-indexer/migrations/2022-03-18-000000_initial_scam/up.sql ---
CREATE TYPE public.execution_outcome_status AS ENUM (
    'FAILURE',
    'SUCCESS'
);

CREATE TABLE public.events (
    block_height numeric(20,0) NOT NULL,
    block_hash text NOT NULL,
    block_timestamp numeric(20,0) NOT NULL,
    block_epoch_id text NOT NULL,
    receipt_id text NOT NULL,
    log_index integer NOT NULL,
    predecessor_id text NOT NULL,
    account_id text NOT NULL,
    status public.execution_outcome_status NOT NULL,
    event text NOT NULL
);

ALTER TABLE ONLY public.events
    ADD CONSTRAINT execution_outcome_receipt_pk PRIMARY KEY (receipt_id, log_index);

CREATE INDEX event_block_height_idx ON public.events USING btree (block_height);
CREATE INDEX event_account_id_idx ON public.events USING hash (account_id);
CREATE INDEX event_predecessor_id_idx ON public.events USING hash (predecessor_id);

'''
'''--- example-indexer/migrations/2022-10-10-000000_add_receipts/down.sql ---
DROP TABLE public.receipts;

'''
'''--- example-indexer/migrations/2022-10-10-000000_add_receipts/up.sql ---
CREATE TABLE public.receipts (
    block_height numeric(20,0) NOT NULL,
    block_hash text NOT NULL,
    block_timestamp numeric(20,0) NOT NULL,
    block_epoch_id text NOT NULL,
    outcome_index integer NOT NULL,
    receipt_id text NOT NULL,
    index_in_receipt integer NOT NULL,
    signer_public_key text NOT NULL,
    signer_id text NOT NULL,
    predecessor_id text NOT NULL,
    account_id text NOT NULL,
    status public.execution_outcome_status NOT NULL,
    deposit numeric(40,0) NOT NULL,
    gas numeric(20,0) NOT NULL,
    method_name text NOT NULL,
    args text NOT NULL
);

ALTER TABLE ONLY public.receipts
    ADD CONSTRAINT receipts_execution_outcome_receipt_pk PRIMARY KEY (receipt_id, index_in_receipt);

CREATE INDEX receipts_block_height_idx ON public.receipts USING btree (block_height, outcome_index);
CREATE INDEX receipts_account_id_idx ON public.receipts USING hash (account_id);
CREATE INDEX receipts_predecessor_id_idx ON public.receipts USING hash (predecessor_id);

'''
'''--- example-indexer/src/main.rs ---
mod models;
mod retriable;
mod schema;

#[macro_use]
extern crate diesel;

use actix_diesel::dsl::AsyncRunQueryDsl;
use actix_diesel::Database;
use diesel::PgConnection;
use dotenv::dotenv;
use near_indexer::near_primitives::views::{
    ActionView, ExecutionOutcomeView, ExecutionStatusView, ReceiptEnumView, ReceiptView,
};
use std::collections::HashSet;
use std::env;
use std::str::FromStr;
use tracing_subscriber::EnvFilter;

use crate::models::enums::ExecutionOutcomeStatus;
use crate::models::events::Event;
use crate::models::social::Receipt;

fn get_database_credentials() -> String {
    dotenv().ok();

    env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env file")
}

fn establish_connection() -> actix_diesel::Database<PgConnection> {
    let database_url = get_database_credentials();
    actix_diesel::Database::builder()
        .pool_max_size(30)
        .open(&database_url)
}

const SCAM_PROJECT: &str = "scam_project";
const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);

fn main() {
    openssl_probe::init_ssl_cert_env_vars();

    let whitelisted_accounts = HashSet::from(["social.near".to_string()]);

    let args: Vec<String> = std::env::args().collect();
    let home_dir = std::path::PathBuf::from(near_indexer::get_default_home());

    let mut env_filter = EnvFilter::new(
        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer=info,aggregated=info",
    );

    env_filter = env_filter.add_directive(
        "scam_project=info"
            .parse()
            .expect("Failed to parse directive"),
    );

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    eprintln!("Ignoring directive `{}`: {}", s, err);
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();

    let command = args
        .get(1)
        .map(|arg| arg.as_str())
        .expect("You need to provide a command: `init` or `run` as arg");

    match command {
        "init" => {
            let config_args = near_indexer::InitConfigArgs {
                chain_id: None,
                account_id: None,
                test_seed: None,
                num_shards: 4,
                fast: false,
                genesis: None,
                download_genesis: false,
                download_genesis_url: None,
                download_records_url: None,
                download_config: false,
                download_config_url: Some("https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/config.json".to_string()),
                boot_nodes: None,
                max_gas_burnt_view: None
            };
            near_indexer::indexer_init_configs(&home_dir, config_args).unwrap();
        }
        "run" => {
            let pool = establish_connection();
            let indexer_config = near_indexer::IndexerConfig {
                home_dir: std::path::PathBuf::from(near_indexer::get_default_home()),
                sync_mode: near_indexer::SyncModeEnum::FromInterruption,
                await_for_node_synced: near_indexer::AwaitForNodeSyncedEnum::WaitForFullSync,
                validate_genesis: false,
            };
            let sys = actix::System::new();
            sys.block_on(async move {
                let indexer = near_indexer::Indexer::new(indexer_config).unwrap();
                let stream = indexer.streamer();
                listen_blocks(stream, pool, &whitelisted_accounts).await;

                actix::System::current().stop();
            });
            sys.run().unwrap();
        }
        _ => panic!("You have to pass `init` or `run` arg"),
    }
}

async fn listen_blocks(
    mut stream: tokio::sync::mpsc::Receiver<near_indexer::StreamerMessage>,
    pool: Database<PgConnection>,
    whitelisted_accounts: &HashSet<String>,
) {
    while let Some(streamer_message) = stream.recv().await {
        extract_info(&pool, streamer_message, whitelisted_accounts)
            .await
            .unwrap();
    }
}

const EVENT_LOG_PREFIX: &str = "EVENT_JSON:";

async fn extract_info(
    pool: &Database<PgConnection>,
    msg: near_indexer::StreamerMessage,
    whitelisted_accounts: &HashSet<String>,
) -> anyhow::Result<()> {
    let block_height = msg.block.header.height;
    let block_hash = msg.block.header.hash.to_string();
    let block_timestamp = msg.block.header.timestamp_nanosec;
    let block_epoch_id = msg.block.header.epoch_id.to_string();

    let mut events = vec![];
    let mut receipts = vec![];
    for shard in msg.shards {
        for (outcome_index, outcome) in shard.receipt_execution_outcomes.into_iter().enumerate() {
            let ReceiptView {
                predecessor_id,
                receiver_id: account_id,
                receipt_id,
                receipt,
            } = outcome.receipt;
            let predecessor_id = predecessor_id.to_string();
            let account_id = account_id.to_string();
            let receipt_id = receipt_id.to_string();
            let ExecutionOutcomeView { logs, status, .. } = outcome.execution_outcome.outcome;
            let status = match status {
                ExecutionStatusView::Unknown => ExecutionOutcomeStatus::Failure,
                ExecutionStatusView::Failure(_) => ExecutionOutcomeStatus::Failure,
                ExecutionStatusView::SuccessValue(_) => ExecutionOutcomeStatus::Success,
                ExecutionStatusView::SuccessReceiptId(_) => ExecutionOutcomeStatus::Success,
            };
            for (log_index, log) in logs.into_iter().enumerate() {
                if log.starts_with(EVENT_LOG_PREFIX) {
                    events.push(Event {
                        block_height: block_height.into(),
                        block_hash: block_hash.clone(),
                        block_timestamp: block_timestamp.into(),
                        block_epoch_id: block_epoch_id.clone(),
                        receipt_id: receipt_id.clone(),
                        log_index: log_index as i32,
                        predecessor_id: predecessor_id.clone(),
                        account_id: account_id.clone(),
                        status,
                        event: log.as_str()[EVENT_LOG_PREFIX.len()..].to_string(),
                    })
                }
            }
            if whitelisted_accounts.contains(&account_id) {
                match receipt {
                    ReceiptEnumView::Action {
                        signer_id,
                        signer_public_key,
                        actions,
                        ..
                    } => {
                        for (index_in_receipt, action) in actions.into_iter().enumerate() {
                            match action {
                                ActionView::FunctionCall {
                                    method_name,
                                    args,
                                    gas,
                                    deposit,
                                } => {
                                    if let Ok(args) = String::from_utf8(args) {
                                        receipts.push(Receipt {
                                            block_height: block_height.into(),
                                            block_hash: block_hash.clone(),
                                            block_timestamp: block_timestamp.into(),
                                            block_epoch_id: block_epoch_id.clone(),
                                            outcome_index: outcome_index as i32,
                                            receipt_id: receipt_id.clone(),
                                            index_in_receipt: index_in_receipt as i32,
                                            signer_public_key: signer_public_key.to_string(),
                                            signer_id: signer_id.to_string(),
                                            predecessor_id: predecessor_id.clone(),
                                            account_id: account_id.clone(),
                                            status,
                                            deposit: bigdecimal::BigDecimal::from_str(
                                                deposit.to_string().as_str(),
                                            )
                                            .unwrap(),
                                            gas: gas.into(),
                                            method_name,
                                            args,
                                        });
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    ReceiptEnumView::Data { .. } => {}
                }
            }
        }
    }

    crate::await_retry_or_panic!(
        diesel::insert_into(schema::events::table)
            .values(events.clone())
            .on_conflict_do_nothing()
            .execute_async(&pool),
        10,
        "Events insert foilureee".to_string(),
        &events
    );

    crate::await_retry_or_panic!(
        diesel::insert_into(schema::receipts::table)
            .values(receipts.clone())
            .on_conflict_do_nothing()
            .execute_async(&pool),
        10,
        "Receipts insert foilureee".to_string(),
        &receipts
    );

    Ok(())
}

'''
'''--- example-indexer/src/models/enums.rs ---
use diesel_derive_enum::DbEnum;

#[derive(Debug, DbEnum, Clone, Copy)]
#[DbValueStyle = "SCREAMING_SNAKE_CASE"]
#[DieselType = "Execution_outcome_status"]
#[PgType = "execution_outcome_status"]
pub enum ExecutionOutcomeStatus {
    Failure,
    Success,
}

'''
'''--- example-indexer/src/models/events.rs ---
use crate::ExecutionOutcomeStatus;
use bigdecimal::BigDecimal;

use crate::schema;
use schema::events;

#[derive(Insertable, Clone, Debug)]
pub struct Event {
    pub block_height: BigDecimal,
    pub block_hash: String,
    pub block_timestamp: BigDecimal,
    pub block_epoch_id: String,
    pub receipt_id: String,
    pub log_index: i32,
    pub predecessor_id: String,
    pub account_id: String,
    pub status: ExecutionOutcomeStatus,
    pub event: String,
}

'''
'''--- example-indexer/src/models/mod.rs ---
pub mod enums;
pub mod events;
pub mod social;

'''
'''--- example-indexer/src/models/social.rs ---
use crate::ExecutionOutcomeStatus;
use bigdecimal::BigDecimal;

use crate::schema;
use schema::receipts;

#[derive(Insertable, Clone, Debug)]
pub struct Receipt {
    pub block_height: BigDecimal,
    pub block_hash: String,
    pub block_timestamp: BigDecimal,
    pub block_epoch_id: String,
    pub outcome_index: i32,
    pub receipt_id: String,
    pub index_in_receipt: i32,
    pub signer_public_key: String,
    pub signer_id: String,
    pub predecessor_id: String,
    pub account_id: String,
    pub status: ExecutionOutcomeStatus,
    pub deposit: BigDecimal,
    pub gas: BigDecimal,
    pub method_name: String,
    pub args: String,
}

'''
'''--- example-indexer/src/retriable.rs ---
#[macro_export]
macro_rules! await_retry_or_panic {
    ($query: expr, $number_of_retries: expr, $error_message: expr, $debug_structs: expr $(, $is_error_handled:expr)? $(,)?) => {
        {
            let mut interval = crate::INTERVAL;
            let mut retry_attempt = 0usize;
            loop {
                if retry_attempt == $number_of_retries {
                    return Err(
                        anyhow::anyhow!(
                            "Failed to perform query to database after {} attempts. Stop trying.",
                            $number_of_retries
                        )
                    );
                }
                retry_attempt += 1;

                match $query.await {
                    Ok(res) => break Some(res),
                    Err(async_error) => {
                        $(if $is_error_handled(&async_error).await {
                            break None;
                        })?

                        tracing::error!(
                             target: crate::SCAM_PROJECT,
                             "Error occurred during {}: \n{:#?} \n{:#?} \n Retrying in {} milliseconds...",
                             async_error,
                             &$error_message,
                             &$debug_structs,
                             interval.as_millis(),
                         );
                        tokio::time::sleep(interval).await;
                        if interval < crate::MAX_DELAY_TIME {
                            interval *= 2;
                        }
                    }
                }
            }
        }
    };
}

'''
'''--- example-indexer/src/schema.rs ---
table! {
    use diesel::sql_types::*;
    use crate::models::enums::*;

    events (receipt_id, log_index) {
        block_height -> Numeric,
        block_hash -> Text,
        block_timestamp -> Numeric,
        block_epoch_id -> Text,
        receipt_id -> Text,
        log_index -> Int4,
        predecessor_id -> Text,
        account_id -> Text,
        status -> Execution_outcome_status,
        event -> Text,
    }
}

table! {
    use diesel::sql_types::*;
    use crate::models::enums::*;

    receipts (receipt_id, index_in_receipt) {
        block_height -> Numeric,
        block_hash -> Text,
        block_timestamp -> Numeric,
        block_epoch_id -> Text,
        outcome_index -> Int4,
        receipt_id -> Text,
        index_in_receipt -> Int4,
        signer_public_key -> Text,
        signer_id -> Text,
        predecessor_id -> Text,
        account_id -> Text,
        status -> Execution_outcome_status,
        deposit -> Numeric,
        gas -> Numeric,
        method_name -> Text,
        args -> Text,
    }
}

allow_tables_to_appear_in_same_query!(
    events,
    receipts,
);

'''