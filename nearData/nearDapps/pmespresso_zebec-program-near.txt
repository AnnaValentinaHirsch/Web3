*GitHub Repository "pmespresso/zebec-program-near"*

'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
# Zebec contracts
Implementation of Zebec in near protocol

## Structures

#### Basic structs

```rust
pub struct Contract {
    current_id: u64,
    streams: UnorderedMap<u64, Stream>,
}

```

```
pub struct Stream {
    id: u64,
    sender: AccountId,
    receiver: AccountId,
    balance: Balance,
    rate: Balance,
    created: Timestamp,
    start_time: Timestamp,
    end_time: Timestamp,
    withdraw_time: Timestamp, // last withdraw time
    is_paused: bool,
    paused_time: Timestamp, // last paused time
}
```

## Main methods

### public functions
- `create_stream(&mut self, receiver: AccountId, stream_rate: U128, start: U64, end: U64)` - Create a new stream with given information

- `withdraw(&mut self, stream_id: U64)` - Withdraw amount accrued in the stream or the excess amount after the stream has ended
- `pause(&mut self, stream_id: U64)` - Pause the stream
- `resume(&mut self, stream_id: U64)` - Resume the stream
- `cancel(&mut self, stream_id: U64)` - Cancel the stream

### Views

- `get_stream(stream_id)` : returns all the details of the `stream_id`

'''
'''--- cargo-audit.md ---
```bash
cargo install cargo-audit
```

```
> cargo audit
    Fetching advisory database from `https://github.com/RustSec/advisory-db.git`
      Loaded 457 security advisories (from /Users/username/.cargo/advisory-db)
    Updating crates.io index
    Scanning Cargo.lock for vulnerabilities (139 crate dependencies)
Crate:     time
Version:   0.1.44
Title:     Potential segfault in the time crate
Date:      2020-11-18
ID:        RUSTSEC-2020-0071
URL:       https://rustsec.org/advisories/RUSTSEC-2020-0071
Solution:  Upgrade to >=0.2.23
Dependency tree:
time 0.1.44
└── chrono 0.4.20
    └── near-primitives 0.13.0
        ├── near-vm-logic 0.13.0
        │   └── near-sdk 4.0.0
        │       ├── zebec 1.0.0
        │       └── near-contract-standards 4.0.0
        │           └── zebec 1.0.0
        └── near-sdk 4.0.0

Crate:     wee_alloc
Version:   0.4.5
Warning:   unmaintained
Title:     wee_alloc is Unmaintained
Date:      2022-05-11
ID:        RUSTSEC-2022-0054
URL:       https://rustsec.org/advisories/RUSTSEC-2022-0054
Dependency tree:
wee_alloc 0.4.5
└── near-sdk 4.0.0
    ├── zebec 1.0.0
    └── near-contract-standards 4.0.0
        └── zebec 1.0.0

error: 1 vulnerability found!
warning: 1 allowed warning found
```
'''
'''--- contract/Cargo.toml ---
[package]
name = "zebec"
version = "1.0.0"
authors = ["Zebec"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-contract-standards = "4.0.0"
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
serde = { version = "1.0", features = ["derive"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
near-blank-project Smart Contract
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release

'''
'''--- contract/deploy.sh ---
#!/bin/sh

./build.sh

if [ $? -ne 0 ]; then
  echo ">> Error building contract"
  exit 1
fi

echo ">> Deploying contract"

# https://docs.near.org/tools/near-cli#near-dev-deploy
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/zebec.wasm

'''
'''--- contract/src/calls.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;

use near_sdk::{serde_json, PromiseOrValue};

pub use crate::views::*;

#[near_bindgen]
impl Contract {
    #[private]
    fn ft_create_stream(
        &mut self,
        stream_rate: U128,
        start_time: U64,
        end_time: U64,
        sender: AccountId,
        amount: U128,
        receiver: AccountId,
        contract_id: AccountId,
        can_cancel: bool,
        can_update: bool,
    ) -> bool {
        // check that the receiver and sender are not the same
        assert!(sender != receiver, "Sender and receiver cannot be the same");

        // convert id to native u128
        let rate: u128 = stream_rate.0;
        let start_time: u64 = start_time.0;
        let end_time: u64 = end_time.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;
        // Check the start and end timestamp is valid
        require!(
            start_time >= current_timestamp,
            "Start time cannot be in the past"
        );
        require!(end_time >= start_time, "Start time cannot be in the past");

        // check the rate is valid
        require!(rate > 0, "Rate cannot be zero");
        require!(rate < MAX_RATE, "Rate is too high");

        // calculate the balance is enough
        let stream_duration = end_time - start_time;
        let stream_amount = u128::from(stream_duration) * rate;

        // check the amount send to the stream
        require!(
            amount.0 == stream_amount,
            "The amount provided doesn't matches the stream"
        );

        let params_key = self.current_id;

        let stream_params = Stream {
            id: params_key,
            sender,
            receiver,
            rate,
            is_paused: false,
            is_cancelled: false,
            balance: amount.0,
            created: current_timestamp,
            start_time,
            end_time,
            withdraw_time: start_time,
            paused_time: start_time,
            contract_id,
            can_cancel,
            can_update,
            is_native: false,
        };

        self.streams.insert(&params_key, &stream_params);
        self.current_id += 1;
        log!("Saving streams {}", stream_params.id);
        return true;
    }

    pub fn valid_ft_sender(account: AccountId) -> bool {
        // can only be called by stablecoin contract
        // @todo add valid stablecoins (from mainnet) address here later
        let accounts: [AccountId; 2] = [
            "usdn.testnet".parse().unwrap(),
            "wrap.testnet".parse().unwrap(),
        ];
        if accounts.contains(&account) {
            // @todo: check if the accountID is in explicit (".near") or implicit format
            return true;
        } else {
            return false;
        }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId, // EOA
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert!(Self::valid_ft_sender(env::predecessor_account_id()));
        // msg contains the structure of the stream
        let res: Result<StreamView, _> = serde_json::from_str(&msg);
        if res.is_err() {
            // if err then return everything back
            return PromiseOrValue::Value(amount);
        }
        let _stream = res.unwrap();
        require!(_stream.method_name == "create_stream".to_string());
        if self.ft_create_stream(
            _stream.stream_rate,
            _stream.start,
            _stream.end,
            sender_id, // EOA 
            amount,
            _stream.receiver,
            env::predecessor_account_id(),
            _stream.can_cancel,
            _stream.can_update,
        ) {
            return PromiseOrValue::Value(U128::from(0));
        } else {
            return PromiseOrValue::Value(amount);
        }
    }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    Promise, PromiseOrValue, PromiseResult, Timestamp,
};

mod calls;
mod views;

pub const CREATE_STREAM_DEPOSIT: Balance = 100_000_000_000_000_000_000_000; // 0.1 NEAR
pub const ONE_YOCTO: Balance = 1;
pub const ONE_NEAR: Balance = 1_000_000_000_000_000_000_000_000; // 1 NEAR
pub const MAX_RATE: Balance = 100_000_000_000_000_000_000_000_000; // 100 NEAR
pub const NO_DEPOSIT: u128 = 0; // Attach no deposit.

/// 10T gas for basic operation
pub const GAS_FOR_BASIC_OP: Gas = Gas(10_000_000_000_000);

// @todo add gas as per the requirement of the mainnet before deployment

// const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
// const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

/// Amount of gas for fungible token transfers, increased to 20T
pub const GAS_FOR_FT_TRANSFER: Gas = Gas(20_000_000_000_000);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    current_id: u64,
    streams: UnorderedMap<u64, Stream>,
}
// Define the stream structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Stream {
    id: u64,
    sender: AccountId,
    receiver: AccountId,
    balance: Balance,
    rate: Balance,
    created: Timestamp,
    start_time: Timestamp,
    end_time: Timestamp,
    withdraw_time: Timestamp, // last withdraw time
    is_paused: bool,
    is_cancelled: bool,
    paused_time: Timestamp, // last paused time
    contract_id: AccountId, // will be ignored for native stream
    can_update: bool,
    can_cancel: bool,
    is_native: bool,
}

#[ext_contract(ext_ft_transfer)]
trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

// trait for self callbacks
#[ext_contract(ext_self)]
pub trait FTTokenResolver {
    fn resolve_ft_withdraw(&mut self, stream_id: U64, temp_stream: Stream) -> bool;
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        require!(!env::state_exists(), "Already initialized");
        Self {
            current_id: 1,
            streams: UnorderedMap::new(b"p"),
        }
    }

    #[payable]
    pub fn create_stream(
        &mut self,
        receiver: AccountId,
        stream_rate: U128,
        start: U64,
        end: U64,
        can_cancel: bool,
        can_update: bool,
    ) -> U64 {
        // convert id to native u128
        let rate: u128 = stream_rate.0;
        let start_time: u64 = start.0;
        let end_time: u64 = end.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;
        // Check the start and end timestamp is valid
        require!(
            start_time >= current_timestamp,
            "Start time cannot be in the past"
        );
        require!(end_time >= start_time, "Start time cannot be in the past");

        // Check the receiver and sender are not same
        require!(receiver != env::predecessor_account_id(), "Sender and receiver cannot be Same");

        // check the rate is valid
        require!(rate > 0, "Rate cannot be zero");
        require!(rate < MAX_RATE, "Rate is too high");

        // calculate the balance is enough
        let stream_duration = end_time - start_time;
        let stream_amount = u128::from(stream_duration) * rate;

        // check the amount send to the stream
        require!(
            env::attached_deposit() == stream_amount,
            "The amount provided doesn't matches the stream"
        );

        // check that the receiver and sender are not the same
        require!(
            env::predecessor_account_id() != receiver,
            "Sender and receiver cannot be the same"
        );

        let params_key = self.current_id;
        let near_token_id: AccountId = "near.testnet".parse().unwrap(); // this will be ignored for native stream

        let stream_params = Stream {
            id: params_key,
            sender: env::predecessor_account_id(),
            receiver,
            rate,
            is_paused: false,
            is_cancelled: false,
            balance: env::attached_deposit(),
            created: current_timestamp,
            start_time,
            end_time,
            withdraw_time: start_time,
            paused_time: 0,
            contract_id: near_token_id,
            can_cancel,
            can_update,
            is_native: true,
        };

        // Save the stream
        self.streams.insert(&params_key, &stream_params);

        // Update the global stream count for next stream
        self.current_id += 1;

        log!("Saving streams {}", stream_params.id);

        U64::from(params_key)
    }

    pub fn update(
        &mut self,
        stream_id: U64,
        start: Option<U64>,
        end: Option<U64>,
        rate: Option<U128>,
    ) {
        // convert to native u64
        let id: u64 = stream_id.0;
        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;

        // get the stream
        let mut stream = self.streams.get(&id).unwrap();

        // check the stream can be udpated
        require!(env::predecessor_account_id() == stream.sender, "You are not authorized to update this stream");
        require!(stream.can_update, "Stream cannot be updated");
        require!(!stream.is_cancelled, "Stream has already been cancelled");

        // convert id to native u128
        let rate = u128::from(rate.unwrap_or(U128(stream.rate)));
        let start_time = u64::from(start.unwrap_or(U64(stream.start_time)));
        let end_time = u64::from(end.unwrap_or(U64(stream.end_time)));

        // Check the start and end timestamp is valid
        require!(
            stream.start_time > current_timestamp,
            "Cannot update: stream already started"
        );
        require!(
            start_time < end_time,
            "Start time should be less than end time"
        );

        if start_time != stream.start_time {
            require!(
                start_time >= current_timestamp,
                "Start time cannot be in the past"
            );
        }
        require!(rate > 0, "Rate cannot be zero");

        // check the rate is valid
        require!(rate < MAX_RATE, "Rate is too high");

        stream.start_time = start_time;
        stream.withdraw_time = start_time;
        stream.end_time = end_time;
        stream.rate = rate;

        // calculate the balance is enough
        let stream_duration = stream.end_time - stream.start_time;
        let stream_amount = u128::from(stream_duration) * rate;

        if stream_amount > stream.balance {
            // check the amount send to the stream
            require!(
                env::attached_deposit() >= stream_amount - stream.balance,
                "The amount provided is not enough for the stream"
            );

            stream.balance += env::attached_deposit();
        }

        self.streams.insert(&id, &stream);
    }

    #[private]
    pub fn internal_resolve_ft_withdraw(&mut self, stream_id: U64, temp_stream: Stream) -> bool {
        let res: bool = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(_) => true,
            _ => false,
        };
        if res {
            self.streams.insert(&stream_id.into(), &temp_stream);
        }
        return res;
    }

    #[private]
    pub fn internal_resolve_ft_claim(&mut self, stream_id: U64, temp_stream: &mut Stream) -> bool {
        let res: bool = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(_) => true,
            _ => false,
        };
        if res {
            temp_stream.balance = 0;
            self.streams.insert(&stream_id.into(), &temp_stream);
        }
        return res;
    }

    #[payable]
    pub fn withdraw(&mut self, stream_id: U64) -> PromiseOrValue<bool> {
        // convert id to native u64
        let id: u64 = stream_id.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;

        // get the stream with id: stream_id
        let mut temp_stream = self.streams.get(&id).unwrap();

        require!(temp_stream.balance > 0, "No balance to withdraw");
        require!(
            !temp_stream.is_cancelled,
            "Stream is cancelled by sender already!"
        );

        // assert the stream has started
        require!(
            current_timestamp > temp_stream.start_time,
            "The stream has not started yet"
        );

        require!(
            env::predecessor_account_id() == temp_stream.sender
                || env::predecessor_account_id() == temp_stream.receiver,
            "You dont have permissions to withdraw"
        );

        // Case: sender withdraws excess amount from the stream after it has ended
        if env::predecessor_account_id() == temp_stream.sender {
            require!(
                current_timestamp > temp_stream.end_time,
                "Cannot withdraw before the stream has ended"
            );

            // Amount that has been streamed to the receiver
            let withdrawal_amount: u128;

            if temp_stream.is_paused {
                withdrawal_amount = temp_stream.rate
                    * u128::from(temp_stream.paused_time - temp_stream.withdraw_time);
            } else {
                if temp_stream.end_time > temp_stream.withdraw_time {
                    // receiver has not withdrawn after stream ended
                    withdrawal_amount = temp_stream.rate
                        * u128::from(temp_stream.end_time - temp_stream.withdraw_time);
                } else {
                    withdrawal_amount = 0;
                }
            }

            // Calculate the withdrawl amount
            let remaining_balance = temp_stream.balance - withdrawal_amount;
            require!(remaining_balance > 0, "Already withdrawn");

            // Update stream and save
            temp_stream.balance -= remaining_balance;
            // Transfer tokens to the sender
            let receiver = temp_stream.sender.clone();

            if temp_stream.is_native {
                self.streams.insert(&stream_id.into(), &temp_stream);
                Promise::new(receiver).transfer(remaining_balance).into()
            } else {
                // NEP141 : ft_transfer()
                ext_ft_transfer::ext(temp_stream.contract_id.clone())
                    .with_attached_deposit(1)
                    .ft_transfer(receiver, remaining_balance.into(), None)
                    .then(
                        Self::ext(env::current_account_id())
                            .internal_resolve_ft_withdraw(stream_id, temp_stream),
                    )
                    .into()
            }

        // Case: Receiver can withdraw the amount fromt the stream
        } else {
            let time_elapsed: u64;
            let withdraw_time: u64;

            // Calculate the elapsed time
            if current_timestamp >= temp_stream.end_time {
                require!(
                    temp_stream.withdraw_time < temp_stream.end_time,
                    "Already withdrawn"
                );
                withdraw_time = current_timestamp;

                if temp_stream.is_paused {
                    time_elapsed = temp_stream.paused_time - temp_stream.withdraw_time;
                } else {
                    time_elapsed = temp_stream.end_time - temp_stream.withdraw_time;
                }
            } else if temp_stream.is_paused {
                time_elapsed = temp_stream.paused_time - temp_stream.withdraw_time;
                withdraw_time = temp_stream.paused_time;
            } else {
                time_elapsed = current_timestamp - temp_stream.withdraw_time;
                withdraw_time = current_timestamp;
            }

            // Calculate the withdrawal amount
            let withdrawal_amount = temp_stream.rate * u128::from(time_elapsed);

            // Transfer the tokens to the receiver
            let receiver = temp_stream.receiver.clone();
            require!(withdrawal_amount > 0, "withdrawal_amount < 0");

            // Update the stream struct and save
            temp_stream.balance -= withdrawal_amount;
            temp_stream.withdraw_time = withdraw_time;

            if temp_stream.is_native {
                self.streams.insert(&stream_id.into(), &temp_stream);
                Promise::new(receiver).transfer(withdrawal_amount).into()
            } else {
                // NEP141 : ft_transfer()
                // require!(env::prepaid_gas() > GAS_FOR_FT_TRANSFER, "More gas is required");
                // log!("{:?}", temp_stream);
                ext_ft_transfer::ext(temp_stream.contract_id.clone())
                    // .with_static_gas(GAS_FOR_FT_TRANSFER)
                    .with_attached_deposit(1)
                    .ft_transfer(receiver, withdrawal_amount.into(), None)
                    .then(
                        // ext_self::ext(env::current_account_id())
                        // .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                        // .resolve_ft_withdraw(stream_id, temp_stream),
                        // ext_self::ft
                        Self::ext(env::current_account_id())
                            .internal_resolve_ft_withdraw(stream_id, temp_stream),
                    )
                    .into()
            }
        }
    }

    pub fn pause(&mut self, stream_id: U64) {
        // convert id to native u64
        let id: u64 = stream_id.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;

        // get the stream
        let mut stream = self.streams.get(&id).unwrap();

        // Only the sender can pause the stream
        require!(env::predecessor_account_id() == stream.sender);

        // Can only be paused after the stream has started and before it has ended
        let can_pause =
            current_timestamp > stream.start_time && current_timestamp < stream.end_time;
        require!(
            can_pause,
            "Can only be pause after stream starts and before it has ended"
        );

        // assert that the stream is already paused
        require!(!stream.is_paused, "Cannot pause already paused stream");

        // update the stream state
        stream.is_paused = true;
        stream.paused_time = current_timestamp;
        self.streams.insert(&id, &stream);

        // Log
        log!("Stream paused: {}", stream.id);
    }

    pub fn resume(&mut self, stream_id: U64) {
        // convert id to native u64
        let id: u64 = stream_id.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;
        // get the stream
        let mut stream = self.streams.get(&id).unwrap();

        // Only the sender can resume the stream
        require!(env::predecessor_account_id() == stream.sender);

        // assert that the stream is already paused
        let is_paused = self.streams.get(&id).unwrap().is_paused;
        require!(is_paused, "Cannot resume unpaused stream");

        // resume the stream
        stream.is_paused = false;

        // Update the withdraw_time so that the receiver will not be
        // able to withdraw fund for paused time
        if current_timestamp > stream.end_time {
            stream.withdraw_time += stream.end_time - stream.paused_time;
        } else {
            stream.withdraw_time += current_timestamp - stream.paused_time;
        }

        // Reset the paused_time and save
        stream.paused_time = 0;
        self.streams.insert(&id, &stream);

        // Log
        log!("Stream resumed: {}", stream.id);
    }

    #[payable]
    pub fn cancel(&mut self, stream_id: U64) -> PromiseOrValue<bool> {
        //  only tranfsers the tokens to receiver
        //  sender can claim using ft_claim_sender

        // convert id to native u64
        let id: u64 = stream_id.0;

        let current_timestamp: u64 = env::block_timestamp_ms() / 1000;
        // Get the stream
        let mut temp_stream = self.streams.get(&id).unwrap();

        // check that the stream can be cancelled
        require!(temp_stream.can_cancel, "Stream cannot be cancelled");

        // Only the sender can cancel the stream
        require!(env::predecessor_account_id() == temp_stream.sender);

        // Stream can only be cancelled if it has not ended
        require!(
            temp_stream.end_time > current_timestamp,
            "Stream already ended"
        );
        require!(!temp_stream.is_cancelled, "already cancelled!");

        // Amounts to refund to the sender and the receiver
        let sender_amt: u128;
        let receiver_amt: u128;

        // Calculate the amount to refund to the receiver
        if temp_stream.is_paused {
            receiver_amt =
                u128::from(temp_stream.paused_time - temp_stream.withdraw_time) * temp_stream.rate;
        } else {
            receiver_amt =
                u128::from(current_timestamp - temp_stream.withdraw_time) * temp_stream.rate;
        }

        // Calculate the amoun to refund to the sender
        sender_amt = temp_stream.balance - receiver_amt;

        // Refund the amounts to the sender and the receiver respectively
        let sender = temp_stream.sender.clone();
        let receiver = temp_stream.receiver.clone();

        // Update the stream balance and save
        temp_stream.balance = sender_amt;
        temp_stream.is_cancelled = true;
        // self.streams.insert(&id, &temp_stream);

        // log
        log!("Stream cancelled: {}", temp_stream.id);

        if temp_stream.is_native {
            temp_stream.balance = 0;
            self.streams.insert(&id, &temp_stream);
            Promise::new(sender)
                .transfer(sender_amt)
                .then(Promise::new(receiver).transfer(receiver_amt))
                .into()
        } else {
            ext_ft_transfer::ext(temp_stream.contract_id.clone())
                .with_attached_deposit(1)
                .ft_transfer(receiver, receiver_amt.into(), None)
                .then(
                    Self::ext(env::current_account_id())
                        .internal_resolve_ft_withdraw(stream_id, temp_stream),
                )
                .into()
        }
    }

    // allows the sender to withdraw funds if the stream is_cancelled.
    pub fn ft_claim_sender(&mut self, stream_id: U64) -> PromiseOrValue<bool> {
        // convert id to native u64
        let id: u64 = stream_id.0;

        // Get the stream
        let mut temp_stream = self.streams.get(&id).unwrap();
        require!(
            temp_stream.sender == env::predecessor_account_id(),
            "not sender"
        );
        require!(temp_stream.is_cancelled, "stream is not cancelled!");
        ext_ft_transfer::ext(temp_stream.contract_id.clone())
            .with_attached_deposit(1)
            .ft_transfer(temp_stream.sender.clone(), temp_stream.balance.into(), None)
            .then(
                Self::ext(env::current_account_id())
                    .internal_resolve_ft_claim(stream_id, &mut temp_stream),
            )
            .into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::accounts;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    const NEAR: u128 = 1000000000000000000000000;

    #[test]
    fn initializes() {
        let contract = Contract::new();
        assert_eq!(contract.current_id, 1);
        assert_eq!(contract.streams.len(), 0);
    }

    #[test]
    #[should_panic(expected = "The amount provided doesn't matches the stream")]
    fn create_stream_invalid_amount() {
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 172800);
        let sender = accounts(0);
        let receiver = accounts(1);
        let rate = U128::from(1 * NEAR);

        let mut contract = Contract::new();

        set_context_with_balance(sender, 200000 * NEAR);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
    }

    #[test]
    #[should_panic(expected = "Sender and receiver cannot be Same")]
    fn create_stream_invalid_receipient() {
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 172800); // 2 days
        let sender = &accounts(0); // alice
        let receiver = &accounts(0); // alice
        let rate = U128::from(1 * NEAR);

        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 172800 * NEAR);

        contract.create_stream(receiver.clone(), rate, start_time, end_time, true, false);
    }

    #[test]
    fn create_stream() {
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 172800); // 2 days
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);

        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 172800 * NEAR);

        contract.create_stream(receiver.clone(), rate, start_time, end_time, true, false);
        assert_eq!(contract.current_id, 2);
        let params_key = 1;
        let stream = contract.streams.get(&params_key).unwrap();
        require!(!stream.is_paused);
        assert_eq!(stream.id, 1);
        assert_eq!(stream.sender, sender.clone());
        assert_eq!(stream.receiver, accounts(1));
        assert_eq!(stream.balance, 172800 * NEAR);
        assert_eq!(stream.rate, rate.0);

        let stream_start_time: u64 = start_time.0;
        let stream_end_time: u64 = end_time.0;

        assert_eq!(stream.start_time, stream_start_time);
        assert_eq!(stream.end_time, stream_end_time);
        assert_eq!(stream.withdraw_time, stream_start_time);
        assert_eq!(stream.paused_time, 0);
        assert_eq!(stream.can_update, false);
        assert_eq!(stream.can_cancel, true);
    }

    #[test]
    fn withdraw_stream_receiver() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 10 * NEAR, start_time.0);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // 4. assert internal balance
        // Check the contract balance after stream is created
        set_context_with_balance_timestamp(env::current_account_id(), 10 * NEAR, start_time.0);
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        require!(internal_balance == 10 * NEAR);

        // 3. call withdraw (action)
        let stream_start_time: u64 = start_time.0;
        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 2);

        contract.withdraw(stream_id);

        // 4. assert internal balance
        let stream = contract.streams.get(&stream_id.0).unwrap();
        let internal_balance = stream.balance;

        assert_eq!(internal_balance, 8 * NEAR);
        assert_eq!(stream.withdraw_time, stream_start_time + 2);
    }

    #[test]
    #[should_panic(expected = "Cannot withdraw before the stream has ended")]
    fn withdraw_stream_sender_before_end() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 10 * NEAR, start_time.0);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // 3. call withdraw (action)
        let stream_start_time: u64 = start_time.0;
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 2);
        contract.withdraw(stream_id);
    }

    #[test]
    fn withdraw_stream_sender_after_end() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10);
        let sender = &accounts(0); // // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;
        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 10 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 2);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 4);
        contract.resume(stream_id);

        // 3. call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 11);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 8 * NEAR);
    }

    #[test]
    fn withdraw_stream_sender_after_end_paused_stream() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;
        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 10 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 4);
        contract.pause(stream_id);

        // 3. call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 11);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 4 * NEAR);
    }

    #[test]
    fn withdraw_stream_sender_after_end_multiple_pauses() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 4);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 6);
        contract.resume(stream_id);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 15);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 17);
        contract.resume(stream_id);

        // 3. call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 12 * NEAR);
    }

    #[test]
    fn withdraw_stream_receiver_after_end_multiple_pauses() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 4);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 6);
        contract.resume(stream_id);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 15);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 17);
        contract.resume(stream_id);

        // 3. call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 8 * NEAR);
    }

    #[test]
    fn test_sender_withdraws_before_sender() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // 3. sender call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 16 * NEAR);

        // 3. receiver call withdraw
        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 25);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 0);
    }

    #[test]
    fn test_receiver_withdraws_before_sender() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // 3. sender call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 4 * NEAR);

        // 3. receiver call withdraw
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 25);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 0);
    }

    #[test]
    #[should_panic(expected = "Already withdrawn")]
    fn test_receiver_tries_multiple_withdraw() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // 3. receiver call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 4 * NEAR);

        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id); // panics here
    }

    #[test]
    #[should_panic(expected = "Already withdrawn")]
    fn test_sender_tries_multiple_withdraw() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 13);
        contract.resume(stream_id);

        // 3. sender call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 16 * NEAR);

        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id); // panics here

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 16 * NEAR);
    }

    #[test]
    fn test_withdraw_after_end_on_paused() {
        // 1. create_stream contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        let stream_id = U64::from(1);

        let stream_start_time: u64 = start_time.0;

        // 2. create stream
        set_context_with_balance_timestamp(sender.clone(), 20 * NEAR, stream_start_time);
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);

        // pause and resume the stream
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 9);
        contract.pause(stream_id);

        // 3. sender call withdraw after stream has ended (action)
        set_context_with_balance_timestamp(sender.clone(), 0, stream_start_time + 21);
        contract.withdraw(stream_id);

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 9 * NEAR);

        set_context_with_balance_timestamp(receiver.clone(), 0, stream_start_time + 25);
        contract.withdraw(stream_id); // panics here

        // 4. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 0);
    }

    #[test]
    fn test_pause() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10000);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10000 * NEAR);

        // 2. create stream
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
        let stream_id = U64::from(1);

        set_context_with_balance_timestamp(sender.clone(), 0, start + 10);
        // 3. pause
        contract.pause(stream_id);

        // 4. assert
        require!(contract.streams.get(&stream_id.0).unwrap().is_paused);
    }

    #[test]
    #[should_panic(expected = "Cannot pause already paused stream")]
    fn double_pause_panic() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10000);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10000 * NEAR);

        // 2. create stream and pause
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
        let stream_id = U64::from(1);
        set_context_with_balance_timestamp(sender.clone(), 0, start + 10);
        contract.pause(stream_id);

        // 3. pause
        contract.pause(stream_id);
    }

    #[test]
    fn test_resume() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10000);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10000 * NEAR);

        // 2. create stream and pause
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
        let stream_id = U64::from(1);
        set_context_with_balance_timestamp(sender.clone(), 0, start + 1);
        contract.pause(stream_id);

        // 3. resume
        set_context_with_balance_timestamp(sender.clone(), 0, start + 4);
        contract.resume(stream_id);

        // 4. assert
        let stream = contract.streams.get(&stream_id.0).unwrap();
        require!(!stream.is_paused);
        assert_eq!(stream.withdraw_time, start + 3);
    }

    #[test]
    #[should_panic(expected = "Stream cannot be cancelled")]
    fn test_cancel_with_no_cancel() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10000);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10000 * NEAR);

        // 2. create stream and pause
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
        let stream_id = U64::from(1);
        set_context_with_balance_timestamp(sender.clone(), 0, start + 1);
        contract.cancel(stream_id);
    }

    #[test]
    fn test_cancel() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 10);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10 * NEAR);

        // 2. create stream and cancel
        contract.create_stream(receiver.clone(), rate, start_time, end_time, true, false);
        let stream_id = U64::from(1);
        set_context_with_balance_timestamp(sender.clone(), 0, start + 1);
        contract.cancel(stream_id);

        // 3. assert internal balance
        let internal_balance = contract.streams.get(&stream_id.0).unwrap().balance;
        assert_eq!(internal_balance, 0);
    }

    #[test]
    #[should_panic(expected = "You are not authorized to update this stream")]
    fn test_update_unauthorized() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start + 10);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10 * NEAR);

        // 2. create stream and cancel
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, true);
        let stream_id = U64::from(1);

        set_context_with_balance_timestamp(receiver.clone(), 0, start + 11);

        contract.update(
            stream_id,
            Option::Some(U64::from(start + 12)),
            Option::Some(U64::from(start + 14)),
            Option::Some(U128::from(2 * NEAR)),
        );
    }

    #[test]
    #[should_panic(expected = "Cannot update: stream already started")]
    fn test_update_after_stream_start() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start + 10);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10 * NEAR);

        // 2. create stream and cancel
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, true);
        let stream_id = U64::from(1);

        set_context_with_balance_timestamp(sender.clone(), 0, start + 11);

        contract.update(
            stream_id,
            Option::Some(U64::from(start + 12)),
            Option::Some(U64::from(start + 14)),
            Option::Some(U128::from(2 * NEAR)),
        );
    }

    #[test]
    #[should_panic(expected = "The amount provided is not enough for the stream")]
    fn test_update_stream_insufficient_balance_1() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start + 10);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10 * NEAR);

        // 2. create stream and cancel
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, true);
        let stream_id = U64::from(1);

        set_context_with_balance_timestamp(sender.clone(), 0, start + 1);

        contract.update(
            stream_id,
            Option::Some(U64::from(start + 12)),
            Option::Some(U64::from(start + 14)),
            Option::Some(U128::from(70 * NEAR)), // Rate = 70 NEAR with balance of just 10 Near (should fail)
        );
    }

    #[test]
    fn test_update_stream() {
        // 1. Create the contract
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start + 10);
        let end_time: U64 = U64::from(start + 20);
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);
        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 10 * NEAR);

        // 2. create stream and cancel
        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, true);
        let stream_id = U64::from(1);

        set_context_with_balance_timestamp(sender.clone(), 10 * NEAR, start + 1);

        contract.update(
            stream_id,
            Option::Some(U64::from(start + 12)),
            Option::Some(U64::from(start + 14)),
            Option::Some(U128::from(10 * NEAR)),
        );

        let params_key = 1;
        let stream = contract.streams.get(&params_key).unwrap();
        assert!(!stream.is_paused);
        assert_eq!(stream.id, 1);
        assert_eq!(stream.sender, sender.clone());
        assert_eq!(stream.receiver, accounts(1));
        assert_eq!(stream.balance, 20 * NEAR);
        assert_eq!(stream.rate, 10 * NEAR);
        assert_eq!(stream.start_time, start + 12);
        assert_eq!(stream.end_time, start + 14);
        assert_eq!(stream.withdraw_time, start + 12);
        assert_eq!(stream.paused_time, 0);
        assert_eq!(stream.can_update, true);
        assert_eq!(stream.can_cancel, false);
    }

    // fn set_context(predecessor: AccountId) {
    //     let mut builder = VMContextBuilder::new();
    //     builder.predecessor_account_id(predecessor);
    //     testing_env!(builder.build());
    // }

    fn set_context_with_balance(predecessor: AccountId, amount: Balance) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder.attached_deposit(amount);
        testing_env!(builder.build());
    }

    fn set_context_with_balance_timestamp(predecessor: AccountId, amount: Balance, ts: u64) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder.attached_deposit(amount);
        builder.block_timestamp(ts * 1e9 as u64);
        testing_env!(builder.build());
    }
}

'''
'''--- contract/src/views.rs ---
use crate::*;
use near_sdk::{near_bindgen, AccountId};

// mainly for `ft_on_transfer`
#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct StreamView {
    pub method_name: String,
    pub receiver: AccountId,
    pub stream_rate: U128,
    pub start: U64,
    pub end: U64,
    pub can_update: bool,
    pub can_cancel: bool,
}

#[near_bindgen]
impl Contract {
    pub fn get_stream(&self, stream_id: U64) -> Stream {
        let id: u64 = stream_id.into();
        self.streams.get(&id).unwrap()
    }

    pub fn get_streams(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<Stream> {
        let start = u128::from(from_index.unwrap_or(U128(0)));

        self.streams
            .keys()
            // skip to start
            .skip(start as usize)
            // take the first `limit` elements in the vec
            .take(limit.unwrap_or(U64(50)).0 as usize)
            .map(|id| self.streams.get(&id).unwrap())
            .collect()
    }

    pub fn get_streams_by_user(
        &self,
        user_id: AccountId,
        from_index: Option<U128>,
        limit: Option<U64>,
    ) -> Vec<Stream> {
        let start = u128::from(from_index.unwrap_or(U128(0)));

        self.streams
            .keys()
            // skip to start
            .skip(start as usize)
            // take the first `limit` elements in the vec
            .take(limit.unwrap_or(U64(50)).0 as usize)
            .map(|id| self.streams.get(&id).unwrap())
            .filter(|stream| stream.sender == user_id)
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::accounts;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    const NEAR: u128 = 1000000000000000000000000;

    #[test]
    fn initializes() {
        let contract = Contract::new();
        assert_eq!(contract.current_id, 1);
        assert_eq!(contract.streams.len(), 0);
    }
    fn set_context_with_balance(predecessor: AccountId, amount: Balance) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder.attached_deposit(amount);
        testing_env!(builder.build());
    }

    #[test]
    fn test_get_stream() {
        let start = env::block_timestamp();
        let start_time: U64 = U64::from(start);
        let end_time: U64 = U64::from(start + 172800); // 2 days
        let sender = &accounts(0); // alice
        let receiver = &accounts(1); // bob
        let rate = U128::from(1 * NEAR);

        let mut contract = Contract::new();

        set_context_with_balance(sender.clone(), 172800 * NEAR);

        contract.create_stream(receiver.clone(), rate, start_time, end_time, false, false);
        assert_eq!(contract.current_id, 2);
        let params_key = 1;
        let stream = contract.streams.get(&params_key).unwrap();
        require!(!stream.is_paused);
        assert_eq!(stream.id, 1);
        assert_eq!(stream.sender, sender.clone());
        assert_eq!(stream.receiver, accounts(1));
        assert_eq!(stream.balance, 172800 * NEAR);
        assert_eq!(stream.rate, rate.0);

        let stream_start_time: u64 = start_time.0;
        let stream_end_time: u64 = end_time.0;

        assert_eq!(stream.start_time, stream_start_time);
        assert_eq!(stream.end_time, stream_end_time);
        assert_eq!(stream.withdraw_time, stream_start_time);
        assert_eq!(stream.paused_time, 0);
        let res_stream = contract.get_stream(near_sdk::json_types::U64(stream.id));
        println!("{}", res_stream.id);
    }
}

'''
'''--- package.json ---
{
  "name": "zebec",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deploy": "cd contract && ./deploy.sh",
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "cd contract && ./build.sh",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "npm run build:contract && cd integration-tests && cargo run --example integration-tests \"../contract/target/wasm32-unknown-unknown/release/zebec.wasm\""
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}

'''
'''--- test-testnet.md ---

```bash

cargo build --all --target wasm32-unknown-unknown --release
near deploy stream.remora.testnet --wasmFile '/Users/user/development/blockchain/near-protocol/zebec-near/contract/target/wasm32-unknown-unknown/release/zebec.wasm'

near state stream.remora.testnet

near call stream.remora.testnet new ----accountId remora.testnet

near call stream.remora.testnet create_stream '{"receiver": "stream.remora.testnet", "stream_rate":"1", "start":"1762707445051569700", "end": "1862707445051569700"}' ----accountId remora.testnet

near call stream.remora.testnet get_stream '{"stream_id": "1"}' ----accountId remora.testnet

near call stream.remora.testnet  create_stream '{"receiver": "sub1.twojoy.testnet", "stream_rate": "10000000", "start": "1662709833946590000", "end": "1672707999000000000"}' --amount 0.000004 --account-id remora.testnet ----depositYocto 10000000010000000000

near call stream.remora.testnet  create_stream '{"receiver": "sub1.twojoy.testnet", "stream_rate": "1000", "start": "1663056149517379000", "end": "1663063349517379000"}' --depositYocto 600000000000000 --account-id remora.testnet
```

### script to calculate the stream_amount

```python
def calculate_stream_amount():
    #the caculations are done in nanoseconds
    near = 10 ** 24
    # 10 * 60 * 60 secs into nano seconds 
    start_after = 10 * 60 * 10 ** 9  # 10 minutes 
    stream_rate = 1000  # in yocto (10 ** 24)
    start_time = time.time_ns() + start_after
    two_hours = 2 * 60 * 60 * 10 ** 9 
    end_time = start_time + two_hours ## ends after 2 hours 
    amount = (end_time - start_time)  * stream_rate
    print(f"start: {start_time}, end: {end_time}, stream_rate={stream_rate} depositYocto:{amount}")
```

```bash
near call stream.remora.testnet  create_stream '{"receiver": "sub1.twojoy.testnet", "stream_rate": "1000", "start": "1663050047749232000", "end": "1663057247749232000"}' --depositYocto 7200000000000000 --account-id remora.testnet

# output
Scheduling a call: stream.remora.testnet.create_stream({"receiver": "sub1.twojoy.testnet", "stream_rate": "1000", "start": "1662711286687034000", "end": "1662711886687034000"}) with attached 0.0000000006 NEAR
Doing account.functionCall()
Receipt: EvnrhmDvuE8YfaoLFhF39Ya6BULFVVKBdv25tbJDVMtN
        Log [stream.remora.testnet]: Saving streams 2
Transaction Id 8qP8hGXxkyRsvJNqypv8v1wAPanUcUTKjFZvPpDdnJRh
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8qP8hGXxkyRsvJNqypv8v1wAPanUcUTKjFZvPpDdnJRh
```

#### Pause the stream

```bash
near call stream.remora.testnet pause '{"stream_id": "1"}' ----accountId remora.testnet
# check status 
near call stream.remora.testnet get_stream '{"stream_id": "1"}' ----accountId remora.testnet

# output
Scheduling a call: stream.remora.testnet.get_stream({"stream_id": "1"})
Doing account.functionCall()
Transaction Id Hkbb8fiBcSxnT1jgZwxNER5NUobd5oQNEzcsh8oQ68km
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/Hkbb8fiBcSxnT1jgZwxNER5NUobd5oQNEzcsh8oQ68km
{
  id: 1,
  sender: 'remora.testnet',
  receiver: 'sub1.twojoy.testnet',
  balance: 600000000000000,
  rate: 1000,
  created: 1662709960905007000,
  start_time: 1662710403284144000,
  end_time: 1662711003284144000,
  withdraw_time: 1662710403284144000,
  is_paused: true,
  paused_time: 1662710878421928000,
  contract_id: 'near.testnet'
}
```

### Resume the stream

```bash
near call stream.remora.testnet resume '{"stream_id": "1"}' ----accountId remora.testnet
# check status 
near view stream.remora.testnet get_stream '{"stream_id": "1"}' ----accountId remora.testnet

# output
View call: stream.remora.testnet.get_stream({"stream_id": "1"})
{
  id: 1,
  sender: 'remora.testnet',
  receiver: 'sub1.twojoy.testnet',
  balance: 600000000000000,
  rate: 1000,
  created: 1662709960905007000,
  start_time: 1662710403284144000,
  end_time: 1662711003284144000,
  withdraw_time: 1662710528146360000,
  is_paused: false,
  paused_time: 0,
  contract_id: 'near.testnet'
}
```

### withdraw the funds

```
near call stream.remora.testnet withdraw '{"stream_id": "1"}' ----accountId remora.testnet  
```

## Test for NEP-141 token

### 1. Create stream

1. Acquire wrapped Near to transfer from `wrap.testnet`

```bash
near call wrap.testnet near_deposit --deposit 1 --accountId remora.testnet
```

2. register both sender and receiver in the FT contract

- create receiver subaccount

```
near create-account receiver.remora.testnet --masterAccount remora.testnet
```

- deposit min to register

```
// register 
near call wrap.testnet storage_deposit --accountId remora.testnet --amount 0.00125
```

- get the storage bound
- `near view wrap.testnet storage_balance_bounds`
- 1250000000000000000000 = 0.0125
- we can register other too

```
near call wrap.testnet storage_deposit '{"account_id": "stream.remora.testnet"}' --accountId remora.testnet --amount 0.00125
```

```

near call wrap.testnet ft_transfer_call '{"amount": "7200000000000000","receiver_id": "stream.remora.testnet", "memo": "test", "msg":"{\"method_name\": \"create_stream\", \"receiver\":\"sub1.twojoy.testnet\",\"stream_rate\":\"1000\",\"start\":\"1663064453618110000\",\"end\":\"1663071653618110000\"}"}' --depositYocto 1 --gas 200000000000000 --accountId remora.testnet

{
  amount: 100,
  receiver: "twojoy",
"msg" : {
  method_name: "create_stream",
  "receiver": "sub1.twojoy.testnet",
  "stream_rate": "1000",
  "start":"1663050047749232000",
  "end": "1663057247749232000",
  }
}

near call stream.remora.testnet  create_stream '{"receiver": "sub1.twojoy.testnet", "stream_rate": "1000", "start": "1663050047749232000", "end": "1663057247749232000"}' --depositYocto 7200000000000000 --account-id remora.testnet
```

Tests:

1. fails when the sender contract is not whitelisted:

- In the call below the sender contract (wrap.testnet) is not valid_ft_sender

```
 near call wrap.testnet ft_transfer_call '{"amount": "7200000000000000","receiver_id": "stream.remora.testnet", "memo": "test", "msg":"{\"create_stream\":{\"receiver\":\"sub1.twojoy.testnet\",\"stream_rate\":\"1000\",\"start\":\"1663052207473710000\",\"end\":\"1663059407473710000\"}}"}' --depositYocto 1 --gas 200000000000000 --accountId remora.testnet

Scheduling a call: wrap.testnet.ft_transfer_call({"amount": "7200000000000000","receiver_id": "stream.remora.testnet", "memo": "test", "msg": "{\"create_stream\\\":{\\\"receiver\\\":\"sub1.twojoy.testnet\",\"stream_rate\":\"1000\",\"start\":\"1663052207473710000\",,\"end\":\"1663059407473710000\"}}"}) with attached 0.000000000000000000000001 NEAR
Doing account.functionCall()
Receipts: 3PGLvkCz2E8XwAx57bnXqFgxHLPC6VpNdR2v22Qg3sCq, HEVADECnhKhe6aKWxQUJrFgExMt3CqRb5hmhqEycYPDP, 93TAdbsCM2NUWH7hrPnNJ76N3ns22BDqRGvLBs9Ns7zz
 Log [wrap.testnet]: Transfer 7200000000000000 from remora.testnet to stream.remora.testnet
 Log [wrap.testnet]: Memo: test
Receipt: 69BYe42thSu19kboRCLna44PB5NU6BDUGmswuvgA9vJy
 Failure [wrap.testnet]: Error: {"index":0,"kind":{"ExecutionError":"Smart contract panicked: panicked at 'assertion failed: Self::valid_ft_sender(env::predecessor_account_id())', src/calls.rs:88:9"}}
Receipt: HySNDbG1GKMtpQa5HJiWMEx2hzvyfGJV5P1VPfVMJDnj
 Log [wrap.testnet]: Refund 7200000000000000 from stream.remora.testnet to remora.testnet
Transaction Id Cm9J5E83z3K1hA8rHUQZfD9jsoVhboA86GR2yqxsBMRB
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/Cm9J5E83z3K1hA8rHUQZfD9jsoVhboA86GR2yqxsBMRB
'0'
```
2. test of the functionality from a different user

```
// create a new sub-account
 near create-account sender.remora.testnet --masterAccount remora.testnet --initialBalance 10

// get wNear
near call wrap.testnet near_deposit --deposit 2 --accountId  sender.remora.testnet

// register to wrap.testnet 
// since the receiver, stream.remora.testnet is already registered, we don't need to
near call wrap.testnet storage_deposit '{"account_id": "stream.remora.testnet"}' --accountId sender.remora.testnet --amount 0.00125

// create_stream 
near call wrap.testnet ft_transfer_call '{"amount": "7200000000000000","receiver_id": "stream.remora.testnet", "memo": "test", "msg":"{\"method_name\": \"create_stream\", \"receiver\":\"receiver.remora.testnet\",\"stream_rate\":\"1000\",\"start\":\"1663067627775296000\",\"end\":\"1663074827775296000\"}"}' --depositYocto 1 --gas 200000000000000 --accountId sender.remora.testnet
```
'''