*GitHub Repository "JonathanLogan/near-price-oracle-bot"*

'''--- .docker/README.md ---
Build docker image with:

`docker build -t oracle-price-bot:latest -f Dockerfile .`

Create directory `/var/near/oracle` and copy near credentials file to `/var/near/oracle/key.json`

Start image with:

`docker run --init -d --name oracle-price-bot --restart always -v /var/near/oracle:/home/node:rw oracle-price-bot`

'''
'''--- README.md ---
# Near Price Oracle bot

### Hot to run a Near Price Oracle bot as a service (Linux)

- Update `/service/near-oracle.service` to specify user and path (ExecStart)
- Install service: `./install.sh`
- Check logs: `sudo journalctl -u near-oracle.service -f`
- Stop Service `sudo systemctl stop near-oracle.service`
- Start service `sudo systemctl start near-oracle.service`

'''
'''--- bot.js ---
const near = require("./near");
const config = require("./config");
const { IsDifferentEnough } = require("./functions");
const pjson = require('./package.json');

module.exports = {
  updatePrices: async function (relativeDiffs, old_prices, new_prices, state, liveAssets) {
    const current_time = new Date().getTime();
    let prices_to_update = [];
    const all_prices_updates = [];
    Object.entries(relativeDiffs).map(([ticker, relativeDiff]) => {
      const old_price = old_prices[ticker];
      const new_price = new_prices[ticker] || { multiplier: 0, decimals: 0 };
      console.log(
        `Compare ${ticker}: ${old_price.multiplier.toString()} and ${new_price.multiplier.toString()}`
      );
      if (liveAssets && !liveAssets.has(ticker)) {
        console.log(`!!! ${ticker} is not whitelisted. Skipping`);
        return;
      }
      if (new_price.multiplier > 0) {
        const price_update = {
          asset_id: ticker,
          price: {
            multiplier: Math.round(new_price.multiplier).toString(),
            decimals: new_price.decimals,
          },
        };
        all_prices_updates.push(price_update);
        if (IsDifferentEnough(relativeDiff, old_price, new_price)) {
          console.log(`!!! Update ${ticker} price`);
          prices_to_update.push(price_update);
        }
      }
    });

    if (
      state.lastFullUpdateTimestamp + config.FULL_UPDATE_PERIOD <=
      current_time
    ) {
      prices_to_update = all_prices_updates;
      state.lastFullUpdateTimestamp = current_time;
      console.log(`!!! Executing full price update`);
    }

    const txParameters = {
      prices: prices_to_update,
    };

    if (
        pjson?.version &&
        prices_to_update.length &&
        state.lastVersionReportTimestamp + config.VERSION_REPORT_PERIOD <= current_time
    ) {
      state.lastVersionReportTimestamp = current_time;
      txParameters.version = pjson?.version;
      console.log(`!!! Reporting version of the bot: ${pjson?.version}`);
    }

    const currentBalance = parseFloat(await near.CurrentBalance(config.NEAR_ACCOUNT_ID)) / 1e24;
    if (currentBalance < config.MIN_CLAIM_NEAR_BALANCE) {
      console.log(`!!! Current balance ${currentBalance} is less than ${config.MIN_CLAIM_NEAR_BALANCE}. Claiming NEAR`);
      txParameters.claim_near = true;
    }

    if (prices_to_update.length || !!txParameters.version ) {
      await near.NearCall(
        config.NEAR_ACCOUNT_ID,
        config.CONTRACT_ID,
        "report_prices",
          txParameters
      );
    }
  },
};

'''
'''--- config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || "oracle.testnet";

module.exports = {
  CONTRACT_ID: CONTRACT_NAME,
  NEAR_ACCOUNT_ID: process.env.NEAR_ACCOUNT_ID || "account.testnet",
  TELEGRAM_CHAT_ID: process.env.TELEGRAM_CHAT_ID,
  TELEGRAM_TOKEN: process.env.TELEGRAM_TOKEN,

  // Will report the prices at least every 50 seconds
  MAX_NO_REPORT_DURATION: process.env.MAX_NO_REPORT_DURATION
    ? parseFloat(process.env.MAX_NO_REPORT_DURATION)
    : 50000,
  // Relative difference. Default 0.005 or 0.5%
  RELATIVE_DIFF: process.env.RELATIVE_DIFF
    ? parseFloat(process.env.RELATIVE_DIFF)
    : 0.005,
  // Each price is reported with 4 digits after floating point.
  FRACTION_DIGITS: process.env.FRACTION_DIGITS
    ? parseInt(process.env.FRACTION_DIGITS)
    : 4,
  // Time out in milliseconds when the process is killed.
  REPORT_TIMEOUT: process.env.REPORT_TIMEOUT
    ? parseInt(process.env.REPORT_TIMEOUT)
    : 15000,

  // The filename to save bot state.
  STATE_FILENAME: process.env.STATE_FILENAME || "./data/state.json",

  // Time period in milliseconds to do full price refresh, helps save on gas.
  FULL_UPDATE_PERIOD: process.env.FULL_UPDATE_PERIOD
    ? parseInt(process.env.FULL_UPDATE_PERIOD)
    : 600000,

  // Time period in milliseconds to report about version of the bot
  VERSION_REPORT_PERIOD: process.env.VERSION_REPORT_PERIOD
      ? parseInt(process.env.VERSION_REPORT_PERIOD)
      : 86400000, // 1 day

  PRINT_DEBUG: !!process.env.PRINT_DEBUG,

  MIN_USN_LIQUIDITY_IN_POOL: process.env.MIN_USN_LIQUIDITY_IN_POOL
    ? parseFloat(process.env.MIN_USN_LIQUIDITY_IN_POOL)
    : 10_000 * 1e18,

  MIN_CLAIM_NEAR_BALANCE: process.env.MIN_CLAIM_NEAR_BALANCE ? parseFloat(process.env.MIN_CLAIM_NEAR_BALANCE) : 10,

  getConfig: (env) => {
    switch (env) {
      case "production":
      case "mainnet":
        return {
          networkId: "mainnet",
          nodeUrl: process.env.NODE_URL || "https://rpc.mainnet.near.org",
          contractName: CONTRACT_NAME || "null_address.near",
          walletUrl: "https://wallet.near.org",
          helperUrl: "https://helper.mainnet.near.org",
          explorerUrl: "https://explorer.mainnet.near.org",
          refContractName: "v2.ref-finance.near",
        };
      case "development":
      case "testnet":
        return {
          networkId: "testnet",
          nodeUrl: process.env.NODE_URL || "https://rpc.testnet.near.org",
          contractName: CONTRACT_NAME || "null_address.testnet",
          walletUrl: "https://wallet.testnet.near.org",
          helperUrl: "https://helper.testnet.near.org",
          explorerUrl: "https://explorer.testnet.near.org",
          refContractName: "ref-finance-101.testnet",
        };
      case "betanet":
        return {
          networkId: "betanet",
          nodeUrl: process.env.NODE_URL || "https://rpc.betanet.near.org",
          contractName: CONTRACT_NAME,
          walletUrl: "https://wallet.betanet.near.org",
          helperUrl: "https://helper.betanet.near.org",
          explorerUrl: "https://explorer.betanet.near.org",
        };
      case "local":
        return {
          networkId: "local",
          nodeUrl: "http://localhost:3030",
          keyPath: `${process.env.HOME}/.near/validator_key.json`,
          walletUrl: "http://localhost:4000/wallet",
          contractName: CONTRACT_NAME,
        };
      case "test":
      case "ci":
        return {
          networkId: "shared-test",
          nodeUrl: "https://rpc.ci-testnet.near.org",
          contractName: CONTRACT_NAME,
          masterAccount: "test.near",
        };
      case "ci-betanet":
        return {
          networkId: "shared-test-staging",
          nodeUrl: "https://rpc.ci-betanet.near.org",
          contractName: CONTRACT_NAME,
          masterAccount: "test.near",
        };
      default:
        throw Error(
          `Unconfigured environment '${env}'. Can be configured in src/config.js.`
        );
    }
  },
};

'''
'''--- feeds/binance-futures.js ---
const Binance = require("binance-api-node").default;

module.exports = {
    getPrices: async function (coins) {
        try {
            const client = Binance();

            let tickers_to_process = Object.keys(coins)
                .filter(ticker => coins[ticker].binance);

            let tickers_prepared = tickers_to_process.reduce((object, ticker) => {
                object[coins[ticker].binance] = ticker;
                return object
            }, {});

            const prices = await client.futuresPrices();

            let tickers = Object.keys(tickers_prepared);

            return tickers_to_process.reduce((object, ticker, index) => {
                const binanceTicker = tickers[index];
                if (binanceTicker in prices) {
                    object[ticker] = parseFloat(prices[binanceTicker]);
                }
                return object;
            }, {});
        } catch (error) {
            console.error(error);
        }
    },
};

'''
'''--- feeds/binance.js ---
const Binance = require("binance-api-node").default;

module.exports = {
    getPrices: async function (coins) {
        try {
            const client = Binance();

            let tickers_to_process = Object.keys(coins).filter(
                (ticker) => coins[ticker].binance
            );

            const promises = tickers_to_process.map((ticker) =>
                client.prices({symbol: coins[ticker].binance})
            );

            let tickers_prepared = tickers_to_process.reduce((object, ticker) => {
                object[coins[ticker].binance] = ticker;
                return object;
            }, {});

            return Promise.all(promises).then((values) => {
                return values.reduce((object, price) => {
                    let ticker = Object.keys(price)[0];
                    object[tickers_prepared[ticker]] = parseFloat(price[ticker]);
                    return object;
                }, {});
            });
        } catch (error) {
            console.error(error);
        }
    },
};

'''
'''--- feeds/chainlink.js ---
const Web3 = require("web3");

const {fetchWithTimeout} = require("../functions");

const getData = (address) => {
    return {
        "method": "eth_call",
        "params": [
            {
                "from": null,
                "to": address,
                "data": "0x50d25bcd" // latestAnswer
            }, "latest"
        ],
        "id": 1,
        "jsonrpc": "2.0"
    };
}

const web3 = new Web3();

module.exports = {
    getPrices: async function (coins) {
        let address_to_process = Object.keys(coins).filter(
            (address) => coins[address].chainlink
        );

        let prices = {};
        await Promise.all(
            address_to_process.map((address) =>
                (async () => {
                    let res = await fetchWithTimeout("https://rpc.ankr.com/eth", {
                        method: 'POST',
                        body: JSON.stringify(getData(coins[address].chainlink)),
                        headers: {'Content-Type': 'application/json'}

                    })
                        .then(resp => resp.json())
                        .then(resp => {
                            return (web3.utils.toDecimal(resp?.result ?? 0))
                        });
                    prices[address] = res / 100000000;
                })().catch(function (error) {
                    console.error(error);
                })
            )
        );

        //console.log("chainlink prices", prices)
        return prices;
    },
};

'''
'''--- feeds/coingecko.js ---
const {CoinGeckoClient} = require("coingecko-api-v3");

module.exports = {
    getPrices: async function (coins) {
        try {
            const tickers = Object.keys(coins);

            const client = new CoinGeckoClient({
                timeout: 5000,
                autoRetry: false,
            });

            let prices = await client.simplePrice({
                ids: tickers.map((ticker) => coins[ticker].coingecko).join(","),
                vs_currencies: "usd",
            });

            return tickers.reduce((object, ticker) => {
                object[ticker] = parseFloat(prices[coins[ticker].coingecko]?.usd || 0);
                return object;
            }, {});
        } catch (error) {
            console.error(error);
        }
    },
};

'''
'''--- feeds/crypto.com.js ---
const {GetAvgPrice, fetchWithTimeout} = require("../functions");
module.exports = {
  getPrices: async function (coins) {
    let tickers_to_process = Object.keys(coins).filter(
      (ticker) => coins[ticker].cryptocom
    );

    let tickers_prepared = tickers_to_process.reduce((object, ticker) => {
      object[coins[ticker].cryptocom] = ticker;
      return object;
    }, {});

    return Promise.all(
      tickers_to_process.map((ticker) =>
        fetchWithTimeout(
          `https://api.crypto.com/v2/public/get-ticker?instrument_name=${coins[ticker].cryptocom}`
        )
      )
    )
      .then((responses) => Promise.all(responses.map((res) => res.json())))
      .then((values) => {
        return values.reduce((object, price) => {
          if (object === undefined) {
            object = [];
          }
          if (price?.result?.data?.t >= Date.now() - 10000) {
            let ticker = price?.result?.data?.i;
            // https://exchange-docs.crypto.com/spot/index.html#public-get-ticker
            object[tickers_prepared[ticker]] = GetAvgPrice(price?.result?.data?.b, price?.result?.data?.k, price?.result?.data?.a);
            return object;
          }
        }, {});
      })
      .catch(function (error) {
        console.error(error);
      });
  },
};

'''
'''--- feeds/ftx.js ---
const {fetchWithTimeout} = require("../functions");

module.exports = {
    getPrices: async function (coins) {
        let tickers_to_process = Object.keys(coins)
            .filter(ticker => coins[ticker].ftx);

        let tickers_prepared = tickers_to_process.reduce((object, ticker) => {
            object[coins[ticker].ftx] = ticker;
            return object
        }, {});

        return Promise.all(tickers_to_process.map(ticker => fetchWithTimeout(`https://ftx.com/api/markets/${coins[ticker].ftx}`)))
            .then(responses => Promise.all(responses.map(res => res.json())))
            .then(values => {
                return values.reduce((object, price) => {
                    if(price.success) {
                        let ticker = price.result.name;
                        object [tickers_prepared[ticker]] = parseFloat(price.result.price)
                        return object;
                    }
                }, {})
            })
            .catch(function(error) {
                console.error(error)
            })
    }
}

'''
'''--- feeds/gate.js ---
const {GetAvgPrice, fetchWithTimeout} = require("../functions");
module.exports = {
  getPrices: async function (coins) {
    let tickers_to_process = Object.keys(coins).filter(
      (ticker) => coins[ticker].gate
    );

    return Promise.all(
      tickers_to_process.map((ticker) =>
        fetchWithTimeout(`https://data.gateapi.io/api2/1/ticker/${coins[ticker].gate}`)
      )
    )
      .then((responses) => Promise.all(responses.map((res) => res.json())))
      .then((values) => {
        return values.reduce((object, price, index) => {
          if (price.result === "true") {
            object[tickers_to_process[index]] = GetAvgPrice(price?.highestBid, price?.lowestAsk, price?.last);
            return object;
          }
        }, {});
      })
      .catch(function (error) {
        console.error(error);
      });
  },
};

'''
'''--- feeds/huobi.js ---
const {fetchWithTimeout} = require("../functions");
module.exports = {
    getPrices: async function (coins) {
        let tickers_to_process = Object.keys(coins).filter(
            (ticker) => coins[ticker].huobi
        );

        let prices = {};
        await Promise.all(
            tickers_to_process.map((ticker) =>
                (async () => {
                    let res = await fetchWithTimeout(
                        `https://api.huobi.pro/market/detail/merged?symbol=${coins[ticker].huobi}`
                    );
                    res = await res.json();
                    if(res?.tick?.bid[0] && res?.tick?.ask[0]) {
                        prices[ticker] = (res.tick.bid[0] + res.tick.ask[0]) / 2;
                    }
                })().catch(function (error) {
                    console.error(error);
                })
            )
        );
        return prices;
    },
};

'''
'''--- feeds/kucoin.js ---
const {GetAvgPrice, fetchWithTimeout} = require("../functions");

module.exports = {
  getPrices: async function (coins) {
    let tickers_to_process = Object.keys(coins).filter(
      (ticker) => coins[ticker].kucoin
    );

    return Promise.all(
      tickers_to_process.map((ticker) =>
        fetchWithTimeout(
          `https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${coins[ticker].kucoin}`
        )
      )
    )
      .then((responses) => Promise.all(responses.map((res) => res.json())))
      .then((values) => {
        return values.reduce((object, price, index) => {
          if (price.data) {
            object[tickers_to_process[index]] = GetAvgPrice(price?.data?.bestBid, price?.data?.bestAsk, price?.data?.price);
            return object;
          }
        }, {});
      })
      .catch(function (error) {
        console.error(error);
      });
  },
};

'''
'''--- feeds/pyth.js ---
const { EvmPriceServiceConnection } = require("@pythnetwork/pyth-evm-js");

const connection = new EvmPriceServiceConnection("https://hermes.pyth.network");

const MAX_TIME_DIFFERENCE = 120;

module.exports = {
  getPrices: async function (coins) {
    let address_to_process = Object.keys(coins)
      .filter((address) => !!coins[address].pyth)
      .map((address) => coins[address].pyth);

    let prices = {};
    await (async () => {
      const priceData = await connection.getLatestPriceFeeds(
        address_to_process
      );

      priceData.map((data) => {
        const priceObject = data.price;
        let decimalPrice =
          parseFloat(priceObject.price) * Math.pow(10, priceObject.expo);

        const now = Math.floor(Date.now() / 1000); // Convert current time to seconds
        const timeDifference = now - priceObject.publishTime;

        if (timeDifference <= MAX_TIME_DIFFERENCE) {
          const coin = Object.keys(coins).filter(
            (address) => coins[address].pyth === `0x${data.id}`
          );
          if (coin.length) {
            prices[coin[0]] = decimalPrice;
          }
        } else {
          console.error(
            `Pyth price fro ${data.id} is stale. Published more than ${MAX_TIME_DIFFERENCE} seconds ago.`
          );
        }
      });
    })().catch(function (error) {
      console.error("Pyth error", error);
    });
    //console.log("pyth prices", prices)
    return prices;
  },
};

'''
'''--- feeds/refExchange.js ---
//! The code below is based on skyward finance https://github.com/skyward-finance/app-ui.

const Big = require("big.js");
const config = require("../config");
const nearConfig = config.getConfig(process.env.NODE_ENV || "development");

const SimplePool = "SIMPLE_POOL";
const StablePool = "STABLE_SWAP";

const usdTokensDecimals =
  nearConfig.networkId === "mainnet"
    ? {
        "6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near": 18,
        "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near": 6,
        "dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near": 6,
        usn: 18,
      }
    : {
        "dai.fakes.testnet": 18,
        "usdt.fakes.testnet": 6,
        "usdc.fakes.testnet": 6,
        "usdn.testnet": 18,
      };

const usdTokens = Object.entries(usdTokensDecimals).reduce(
  (acc, [key, value]) => {
    acc[key] = Big(10).pow(value);
    return acc;
  },
  {}
);

function stablePoolGetReturn(pool, tokenIn, amountIn, tokenOut, ignoreFees) {
  let tokenInIndex = pool.tt.indexOf(tokenIn);
  let tokenOutIndex = pool.tt.indexOf(tokenOut);
  // Sub 1
  const cAmountIn = amountIn
    .sub(1)
    .mul(Big(10).pow(18 - usdTokensDecimals[tokenIn]));

  let y = stablePoolComputeY(
    pool,
    cAmountIn.add(pool.cAmounts[tokenInIndex]),
    tokenInIndex,
    tokenOutIndex
  );

  let dy = pool.cAmounts[tokenOutIndex].sub(y);
  let tradeFee = dy
    .mul(ignoreFees ? 0 : pool.fee)
    .div(10000)
    .round(0, 0);
  let amountSwapped = dy.sub(tradeFee);

  return amountSwapped
    .div(Big(10).pow(18 - usdTokensDecimals[tokenOut]))
    .round(0, 0);
}

function stablePoolGetInverseReturn(
  pool,
  tokenOut,
  amountOut,
  tokenIn,
  ignoreFees
) {
  let tokenInIndex = pool.tt.indexOf(tokenIn);
  let tokenOutIndex = pool.tt.indexOf(tokenOut);

  const amountOutWithFee = amountOut
    .mul(10000)
    .div(10000 - ignoreFees ? 0 : pool.fee)
    .round(0, 0);
  const cAmountOut = amountOutWithFee.mul(
    Big(10).pow(18 - usdTokensDecimals[tokenOut])
  );

  let y = stablePoolComputeY(
    pool,
    pool.cAmounts[tokenOutIndex].sub(cAmountOut),
    tokenOutIndex,
    tokenInIndex
  );

  let cAmountIn = y.sub(pool.cAmounts[tokenInIndex]);

  // Adding 1 for internal pool rounding
  return cAmountIn
    .div(Big(10).pow(18 - usdTokensDecimals[tokenIn]))
    .add(1)
    .round(0, 0);
}

function getRefReturn(pool, tokenIn, amountIn, tokenOut, ignoreFees) {
  if (!amountIn || amountIn.eq(0)) {
    return Big(0);
  }
  if (
    !(tokenIn in pool.tokens) ||
    !(tokenOut in pool.tokens) ||
    tokenIn === tokenOut
  ) {
    return null;
  }
  if (pool.stable) {
    return stablePoolGetReturn(pool, tokenIn, amountIn, tokenOut, ignoreFees);
  }
  const balanceIn = pool.tokens[tokenIn];
  const balanceOut = pool.tokens[tokenOut];
  let amountWithFee = Big(amountIn).mul(Big(10000 - ignoreFees ? 0 : pool.fee));
  return amountWithFee
    .mul(balanceOut)
    .div(Big(10000).mul(balanceIn).add(amountWithFee))
    .round(0, 0);
}

function getRefInverseReturn(pool, tokenOut, amountOut, tokenIn, ignoreFees) {
  if (!amountOut || amountOut.eq(0)) {
    return Big(0);
  }
  if (
    !(tokenIn in pool.tokens) ||
    !(tokenOut in pool.tokens) ||
    tokenIn === tokenOut
  ) {
    return null;
  }
  if (pool.stable) {
    return stablePoolGetInverseReturn(
      pool,
      tokenOut,
      amountOut,
      tokenIn,
      ignoreFees
    );
  }
  const balanceIn = pool.tokens[tokenIn];
  const balanceOut = pool.tokens[tokenOut];
  if (amountOut.gte(balanceOut)) {
    return null;
  }
  return Big(10000)
    .mul(balanceIn)
    .mul(amountOut)
    .div(Big(10000 - ignoreFees ? 0 : pool.fee).mul(balanceOut.sub(amountOut)))
    .round(0, 3);
}

function stablePoolComputeD(pool) {
  let sumX = pool.cAmounts.reduce((sum, v) => sum.add(v), Big(0));
  if (sumX.eq(0)) {
    return Big(0);
  } else {
    let d = sumX;
    let dPrev;

    for (let i = 0; i < 256; ++i) {
      let dProd = d;
      for (let j = 0; j < pool.nCoins; ++j) {
        dProd = dProd.mul(d).div(pool.cAmounts[j].mul(pool.nCoins)).round(0, 0);
      }
      dPrev = d;

      let leverage = sumX.mul(pool.ann);
      let numerator = dPrev.mul(dProd.mul(pool.nCoins).add(leverage));
      let denominator = dPrev
        .mul(pool.ann.sub(1))
        .add(dProd.mul(pool.nCoins + 1));
      d = numerator.div(denominator).round(0, 0);

      // Equality with the precision of 1
      if (d.gt(dPrev)) {
        if (d.sub(dPrev).lte(1)) {
          break;
        }
      } else if (dPrev.sub(d).lte(1)) {
        break;
      }
    }
    return d;
  }
}

function stablePoolComputeY(pool, xCAmount, indexX, indexY) {
  // invariant
  let d = pool.d;
  let s = xCAmount;
  let c = d.mul(d).div(xCAmount).round(0, 0);
  pool.cAmounts.forEach((c_amount, idx) => {
    if (idx !== indexX && idx !== indexY) {
      s = s.add(c_amount);
      c = c.mul(d).div(c_amount).round(0, 0);
    }
  });
  c = c.mul(d).div(pool.ann.mul(pool.nn)).round(0, 0);
  let b = d.div(pool.ann).round(0, 0).add(s); // d will be subtracted later

  // Solve for y by approximating: y**2 + b*y = c
  let yPrev;
  let y = d;
  for (let i = 0; i < 256; ++i) {
    yPrev = y;
    // $ y_{k+1} = \frac{y_k^2 + c}{2y_k + b - D} $
    let yNumerator = y.pow(2).add(c);
    let yDenominator = y.mul(2).add(b).sub(d);
    y = yNumerator.div(yDenominator).round(0, 0);
    if (y.gt(yPrev)) {
      if (y.sub(yPrev).lte(1)) {
        break;
      }
    } else if (yPrev.sub(y).lte(1)) {
      break;
    }
  }
  return y;
}

async function prepareRef(near, poolIds) {
  const promises = poolIds.map((pool_id) =>
    near.NearView(nearConfig.refContractName, "get_pool", { pool_id })
  );
  const rawPools = await Promise.all(promises);

  const poolsByToken = {};
  const poolsByPair = {};

  const addPools = (token, pool) => {
    let ps = poolsByToken[token] || [];
    ps.push(pool);
    poolsByToken[token] = ps;

    pool.ots[token].forEach((ot) => {
      const pair = `${token}:${ot}`;
      ps = poolsByPair[pair] || [];
      ps.push(pool);
      poolsByPair[pair] = ps;
    });
  };

  const pools = {};
  rawPools.forEach((pool, i) => {
    if (pool.pool_kind === SimplePool || pool.pool_kind === StablePool) {
      const tt = pool.token_account_ids;
      const p = {
        stable: pool.pool_kind === StablePool,
        index: i,
        tt,
        tokens: tt.reduce((acc, token, tokenIndex) => {
          acc[token] = Big(pool.amounts[tokenIndex]);
          return acc;
        }, {}),
        ots: tt.reduce((acc, token) => {
          acc[token] = tt.filter((t) => t !== token);
          return acc;
        }, {}),
        fee: pool.total_fee,
        shares: Big(pool.shares_total_supply),
        amp: pool.amp || 0,
      };
      if (p.stable) {
        p.cAmounts = [...pool.amounts].map((amount, idx) => {
          let factor = Big(10).pow(18 - usdTokensDecimals[tt[idx]]);
          return Big(amount).mul(factor);
        });
        p.nCoins = p.cAmounts.length;
        p.nn = Big(Math.pow(p.nCoins, p.nCoins));
        p.ann = Big(p.amp).mul(p.nn);
        p.d = stablePoolComputeD(p);
      }

      if (p.shares.gt(0)) {
        pools[p.index] = p;
        p.tt.forEach((t) => addPools(t, p));
      }
    }
  });

  return {
    pools,
    poolsByToken,
    poolsByPair,
  };
}

const findBestReturn = (
  refFinance,
  inTokenAccountId,
  outTokenAccountId,
  amountIn,
  ignoreFees
) => {
  let swapInfo = {
    amountIn,
    amountOut: Big(0),
  };
  // Computing path
  Object.values(refFinance.poolsByToken[inTokenAccountId] || {}).forEach(
    (pool) => {
      // 1 token
      if (outTokenAccountId in pool.tokens) {
        const poolReturn =
          getRefReturn(
            pool,
            inTokenAccountId,
            amountIn,
            outTokenAccountId,
            ignoreFees
          ) || Big(0);

        if (poolReturn.gt(swapInfo.amountOut)) {
          swapInfo = {
            amountIn,
            amountOut: poolReturn,
            pools: [pool],
            swapPath: [inTokenAccountId, outTokenAccountId],
          };
        }
      } else {
        // 2 tokens
        pool.ots[inTokenAccountId].forEach((middleTokenAccountId) => {
          const pair = `${middleTokenAccountId}:${outTokenAccountId}`;
          let poolReturn = false;
          Object.values(refFinance.poolsByPair[pair] || {}).forEach((pool2) => {
            poolReturn =
              poolReturn === false
                ? getRefReturn(
                    pool,
                    inTokenAccountId,
                    amountIn,
                    middleTokenAccountId,
                    ignoreFees
                  )
                : poolReturn;
            if (!poolReturn) {
              return;
            }
            const pool2Return =
              getRefReturn(
                pool2,
                middleTokenAccountId,
                poolReturn,
                outTokenAccountId,
                ignoreFees
              ) || Big(0);
            if (pool2Return.gt(swapInfo.amountOut)) {
              swapInfo = {
                amountIn,
                amountOut: pool2Return,
                pools: [pool, pool2],
                swapPath: [
                  inTokenAccountId,
                  middleTokenAccountId,
                  outTokenAccountId,
                ],
              };
            }
          });
        });
      }
    }
  );
  return Object.assign(swapInfo, {
    inTokenAccountId,
    outTokenAccountId,
    expectedAmountOut: Big(0),
  });
};

const findBestInverseReturn = (
  refFinance,
  inTokenAccountId,
  outTokenAccountId,
  availableInToken,
  outAmount,
  ignoreFees
) => {
  let swapInfo = {
    amountIn: availableInToken,
    amountOut: Big(0),
  };
  // Computing path
  Object.values(refFinance.poolsByToken[outTokenAccountId] || {}).forEach(
    (pool) => {
      // 1 token
      if (inTokenAccountId in pool.tokens) {
        const amountIn = getRefInverseReturn(
          pool,
          outTokenAccountId,
          outAmount,
          inTokenAccountId,
          ignoreFees
        );
        if (!amountIn) {
          return;
        }

        if (amountIn.lt(swapInfo.amountIn)) {
          swapInfo = {
            amountIn,
            amountOut: outAmount,
            pools: [pool],
            swapPath: [inTokenAccountId, outTokenAccountId],
          };
        }
      } else {
        // 2 tokens
        pool.ots[outTokenAccountId].forEach((middleTokenAccountId) => {
          const pair = `${middleTokenAccountId}:${inTokenAccountId}`;
          let middleAmountIn = false;
          Object.values(refFinance.poolsByPair[pair] || {}).forEach((pool2) => {
            middleAmountIn =
              middleAmountIn === false
                ? getRefInverseReturn(
                    pool,
                    outTokenAccountId,
                    outAmount,
                    middleTokenAccountId,
                    ignoreFees
                  )
                : middleAmountIn;
            if (!middleAmountIn) {
              return;
            }
            const amountIn = getRefInverseReturn(
              pool2,
              middleTokenAccountId,
              middleAmountIn,
              inTokenAccountId,
              ignoreFees
            );
            if (!amountIn) {
              return;
            }
            if (amountIn.lt(swapInfo.amountIn)) {
              swapInfo = {
                amountIn,
                amountOut: outAmount,
                pools: [pool2, pool],
                swapPath: [
                  inTokenAccountId,
                  middleTokenAccountId,
                  outTokenAccountId,
                ],
              };
            }
          });
        });
      }
    }
  );

  return Object.assign(swapInfo, {
    inTokenAccountId,
    outTokenAccountId,
    expectedAmountOut: outAmount,
  });
};

async function computeUsnPriceMultiplier(
  near,
  usnTokenId,
  usdtTokenId,
  stablePoolId
) {
  const refFinance = await prepareRef(near, [stablePoolId]);
  const humanAmountIn = Big(10000);
  const usnSwapInfo = findBestReturn(
    refFinance,
    usnTokenId,
    usdtTokenId,
    humanAmountIn.mul(Big(10).pow(18)),
    true
  );
  if (!usnSwapInfo) {
    console.error("Failed to compute USN swap info");
    return null;
  }
  const humanAmountOut = usnSwapInfo.amountOut.div(Big(10).pow(6));
  const usnPriceMultiplier = humanAmountOut.div(humanAmountIn).toNumber();
  if (usnPriceMultiplier < 0.95 || usnPriceMultiplier > 1.05) {
    console.error(`USN stable pool is unbalanced. Price: ${usnPriceMultiplier}`);
    return null;
  }
  return usnPriceMultiplier;
}

module.exports = {
  computeUsnPriceMultiplier,
};

'''
'''--- feeds/uniswap-v3.js ---
const { Token } = require("@uniswap/sdk-core");
const { ethers } = require("ethers");
const { computePoolAddress, FeeAmount } = require("@uniswap/v3-sdk");
const Quoter = require("@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json");
const IUniswapV3PoolABI = require("@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json");

const POOL_FACTORY_CONTRACT_ADDRESS =
  "0x1F98431c8aD98523631AE4a59f267346ea31F984";
const QUOTER_CONTRACT_ADDRESS = "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6";
const MAINNET_NETWORK_ID = 1;
const AMOUNT_IN = 10000;

const MAINNET_RPC = "https://rpc.ankr.com/eth";

function fromReadableAmount(amount, decimals) {
  return ethers.utils.parseUnits(amount.toString(), decimals);
}

function toReadableAmount(rawAmount, decimals) {
  return ethers.utils.formatUnits(rawAmount, decimals);
}

function getProvider() {
  return new ethers.providers.JsonRpcProvider(MAINNET_RPC);
}

async function getPoolConstantsV3(tokenIn, tokenOut, poolFee) {
  const currentPoolAddress = computePoolAddress({
    factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,
    tokenA: tokenIn,
    tokenB: tokenOut,
    fee: poolFee,
  });

  const poolContract = new ethers.Contract(
    currentPoolAddress,
    IUniswapV3PoolABI.abi,
    getProvider()
  );
  const [token0, token1, fee] = await Promise.all([
    poolContract.token0(),
    poolContract.token1(),
    poolContract.fee(),
  ]);

  return {
    token0,
    token1,
    fee,
  };
}

async function quoteV3(tokenIn, tokenOut, fee) {
  const quoterContract = new ethers.Contract(
    QUOTER_CONTRACT_ADDRESS,
    Quoter.abi,
    getProvider()
  );
  const poolConstants = await getPoolConstantsV3(tokenIn, tokenOut, fee);

  const quotedAmountOut = await quoterContract.callStatic.quoteExactInputSingle(
    poolConstants.token0,
    poolConstants.token1,
    poolConstants.fee,
    fromReadableAmount(AMOUNT_IN, tokenIn.decimals).toString(),
    0
  );

  return toReadableAmount(quotedAmountOut, tokenOut.decimals);
}

module.exports = {
  getPrices: async function (coins) {
    try {
      let address_to_process = Object.keys(coins).filter(
        (address) => coins[address].uniswapv3
      );

      let prices = {};
      await Promise.all(
        address_to_process.map((address) =>
          (async () => {
            let { tokenIn, tokenOut, fee } = coins[address].uniswapv3;

            tokenIn = new Token(
              MAINNET_NETWORK_ID,
              tokenIn.address,
              tokenIn.decimals,
              "",
              ""
            );

            tokenOut = new Token(
              MAINNET_NETWORK_ID,
              tokenOut.address,
              tokenOut.decimals,
              "",
              ""
            );

            prices[address] =
              (await quoteV3(tokenIn, tokenOut, fee)) / AMOUNT_IN;
          })().catch(function (error) {
            console.error(error);
          })
        )
      );

      return prices;
    } catch (error) {
      console.error(error);
    }
  },
};

'''
'''--- functions.js ---
const {AbortController} = require("node-abort-controller");
global.AbortController = AbortController;

const config = require("./config");
const fs = require("fs");

module.exports = {
  /**
   * @return {boolean}
   */
  IsDifferentEnough: function (relativeDiff, price_old, price_new) {
    const max_decimals = Math.max(price_new.decimals, price_old.decimals);
    const old_multiplier =
      price_old.multiplier *
      (price_old.decimals < price_new.decimals
        ? Math.pow(10, max_decimals - price_old.decimals)
        : 1);
    const new_multiplier =
      price_new.multiplier *
      (price_new.decimals < price_old.decimals
        ? Math.pow(10, max_decimals - price_new.decimals)
        : 1);

    return (
      Math.abs(new_multiplier - old_multiplier) >= old_multiplier * relativeDiff
    );
  },

  /**
   * @return {number}
   */
  GetAvgPrice: function (bid, ask, last){
    bid = parseFloat(bid);
    ask = parseFloat(ask);
    last = parseFloat(last);

    if (!(bid * ask) || bid > ask || ask < bid) {
      return 0;
    }

    if (last <= bid) {
      return bid;
    }
    if (last >= ask) {
      return ask;
    }

    return last;
  },

  /**
   * @return {number}
   */
  GetMedianPrice: function (data, ticker) {
    let values = data.reduce((object, prices) => {
      if (prices?.hasOwnProperty(ticker)) {
        object.push(prices[ticker]);
      }
      return object;
    }, []);

    if (config.PRINT_DEBUG) {
      const textPrices = values
        .map((price) => (price ? price.toFixed(4) : price))
        .join(" ");
      console.debug(`DEBUG: ${ticker} prices: ${textPrices}`);
    }

    if (!values.length) return 0;

    values.sort((a, b) => a - b);

    let half = Math.floor(values.length / 2);

    if (values.length % 2) return values[half];

    return (values[half - 1] + values[half]) / 2.0;
  },

  LoadJson: function (filename, ignoreError = true) {
    try {
      let rawData = fs.readFileSync(filename);
      return JSON.parse(rawData);
    } catch (e) {
      if (!ignoreError) {
        console.error("Failed to load JSON:", filename, e);
      }
    }
    return null;
  },

  SaveJson: function (json, filename) {
    try {
      const data = JSON.stringify(json);
      fs.writeFileSync(filename, data);
    } catch (e) {
      console.error("Failed to save JSON:", filename, e);
    }
  },

  fetchWithTimeout: async function (resource, options = {}) {
    const {timeout = 5000} = options;

    const controller = new AbortController();
    try {
      const id = setTimeout(() => {
        console.log(`!!!Abort on Fetch Timeout: ${resource}`);
        controller.abort();
      }, timeout);
      const response = await fetch(resource, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(id);
      return response;
    } catch (err) {
      if(!controller.signal.aborted){
        console.log(err);
      }
      return Promise.reject("fetchWithTimeout rejected");
    }
  }
};

'''
'''--- index.js ---
const near = require("./near");
const config = require("./config");
const bot = require("./bot");
const coingecko = require("./feeds/coingecko");
const binance = require("./feeds/binance");
const binanceFutures = require("./feeds/binance-futures");
const huobi = require("./feeds/huobi");
const cryptocom = require("./feeds/crypto.com");
const kucoin = require("./feeds/kucoin");
const gate = require("./feeds/gate");
const chainlink = require("./feeds/chainlink");
const pyth = require("./feeds/pyth");
const uniswapv3 = require("./feeds/uniswap-v3");
const refExchange = require("./feeds/refExchange");
const {
  GetMedianPrice,
  LoadJson,
  SaveJson,
  fetchWithTimeout,
} = require("./functions");
const pjson = require("./package.json");
const Web3 = require("web3");
const Big = require("big.js");
const { FeeAmount } = require("@uniswap/v3-sdk");

console.log(`NEAR Price Oracle Validator Bot, v.${pjson?.version}`);

const nearConfig = config.getConfig(process.env.NODE_ENV || "development");

const TestnetCoins = {
  "wrap.testnet": {
    decimals: 24,
    coingecko: "near",
    binance: "NEARUSDT",
    huobi: "nearusdt",
    cryptocom: "NEAR_USDT",
    kucoin: "NEAR-USDT",
    gate: "near_usdt",
    chainlink: "0xC12A6d1D827e23318266Ef16Ba6F397F2F91dA9b",
    pyth: "0xc415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750", // Crypto.NEAR/USD
  },
  aurora: {
    decimals: 18,
    coingecko: "ethereum",
    binance: "ETHUSDT",
    huobi: "ethusdt",
    cryptocom: "ETH_USDT",
    kucoin: "ETH-USDT",
    gate: "eth_usdt",
    chainlink: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419",
    pyth: "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace", // Crypto.ETH/USD
    fractionDigits: 2,
  },
  "usdt.fakes.testnet": {
    decimals: 6,
    stablecoin: true,
    coingecko: "tether",
    chainlink: "0x3E7d1eAB13ad0104d2750B8863b489D65364e32D",
    pyth: "0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b", // Crypto.USDT/USD
  },
  "usdc.fakes.testnet": {
    decimals: 6,
    stablecoin: true,
    coingecko: "usd-coin",
    cryptocom: "USDC_USDT",
    kucoin: "USDC-USDT",
    binance: "USDCUSDT",
    chainlink: "0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6",
    pyth: "0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a", // Crypto.USDC/USD
  },
  "dai.fakes.testnet": {
    decimals: 18,
    stablecoin: true,
    coingecko: "dai",
    huobi: "daiusdt",
    cryptocom: "DAI_USDT",
    gate: "dai_usdt",
    binance: "DAIUSDT",
    chainlink: "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9",
    pyth: "0xb0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd", // Crypto.DAI/USD
  },
  "wbtc.fakes.testnet": {
    decimals: 8,
    coingecko: "wrapped-bitcoin",
    binance: "BTCUSDT",
    huobi: "btcusdt",
    cryptocom: "BTC_USDT",
    kucoin: "BTC-USDT",
    gate: "btc_usdt",
    chainlink: "0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c",
    pyth: "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43", // Crypto.BTC/USD
    fractionDigits: 2,
  },
  "aurora.fakes.testnet": {
    decimals: 18,
    coingecko: "aurora-near",
    cryptocom: "AURORA_USDT",
    huobi: "aurorausdt",
    kucoin: "AURORA-USDT",
    gate: "aurora_usdt",
    pyth: "0x2f7c4f738d498585065a4b87b637069ec99474597da7f0ca349ba8ac3ba9cac5", // Crypto.AURORA/USD
    relativeDiff: 0.01, // 1%
    fractionDigits: 5,
  },
  "woo.orderly.testnet": {
    decimals: 18,
    coingecko: "woo-network",
    binance: "WOOUSDT",
    huobi: "woousdt",
    cryptocom: "WOO_USDT",
    kucoin: "WOO-USDT",
    gate: "woo_usdt",
    pyth: "0xb82449fd728133488d2d41131cffe763f9c1693b73c544d9ef6aaa371060dd25", // Crypto.WOO/USD
    relativeDiff: 0.01, // 1%
    fractionDigits: 6,
  },
  "fraxtoken.testnet": {
    decimals: 18,
    stablecoin: true,
    coingecko: "frax",
    chainlink: "0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD",
    pyth: "0xc3d5d8d6d17081b3d0bbca6e2fa3a6704bb9a9561d9f9e1dc52db47629f862ad",
    uniswapv3: {
      tokenIn: {
        address: "0x853d955acef822db058eb8505911ed77f175b99e", // Frax
        decimals: 18,
      },
      tokenOut: {
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
        decimals: 6,
      },
      fee: FeeAmount.LOW, // Most popular pool
    },
  },
};

const MainnetCoins = {
  "wrap.near": {
    decimals: 24,
    coingecko: "near",
    binance: "NEARUSDT",
    huobi: "nearusdt",
    cryptocom: "NEAR_USDT",
    kucoin: "NEAR-USDT",
    gate: "near_usdt",
    chainlink: "0xC12A6d1D827e23318266Ef16Ba6F397F2F91dA9b",
    pyth: "0xc415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750", // Crypto.NEAR/USD
  },
  aurora: {
    decimals: 18,
    coingecko: "ethereum",
    binance: "ETHUSDT",
    huobi: "ethusdt",
    cryptocom: "ETH_USDT",
    kucoin: "ETH-USDT",
    gate: "eth_usdt",
    chainlink: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419",
    pyth: "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace", // Crypto.ETH/USD
    fractionDigits: 2,
  },
  "dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near": {
    decimals: 6,
    stablecoin: true,
    coingecko: "tether",
    chainlink: "0x3E7d1eAB13ad0104d2750B8863b489D65364e32D",
    pyth: "0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b", // Crypto.USDT/USD
  },
  "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near": {
    decimals: 6,
    stablecoin: true,
    coingecko: "usd-coin",
    cryptocom: "USDC_USDT",
    kucoin: "USDC-USDT",
    binance: "USDCUSDT",
    chainlink: "0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6",
    pyth: "0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a", // Crypto.USDC/USD
  },
  "6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near": {
    decimals: 18,
    stablecoin: true,
    coingecko: "dai",
    huobi: "daiusdt",
    cryptocom: "DAI_USDT",
    gate: "dai_usdt",
    binance: "DAIUSDT",
    chainlink: "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9",
    pyth: "0xb0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd", // Crypto.DAI/USD
  },
  "2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near": {
    decimals: 8,
    coingecko: "wrapped-bitcoin",
    binance: "BTCUSDT",
    huobi: "btcusdt",
    cryptocom: "BTC_USDT",
    kucoin: "BTC-USDT",
    gate: "btc_usdt",
    chainlink: "0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c",
    pyth: "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43", // Crypto.BTC/USD
    fractionDigits: 2,
  },
  "aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near": {
    decimals: 18,
    coingecko: "aurora-near",
    cryptocom: "AURORA_USDT",
    huobi: "aurorausdt",
    kucoin: "AURORA-USDT",
    gate: "aurora_usdt",
    pyth: "0x2f7c4f738d498585065a4b87b637069ec99474597da7f0ca349ba8ac3ba9cac5", // Crypto.AURORA/USD
    relativeDiff: 0.01, // 1%
    fractionDigits: 5,
  },
  "4691937a7508860f876c9c0a2a617e7d9e945d4b.factory.bridge.near": {
    decimals: 18,
    coingecko: "woo-network",
    binance: "WOOUSDT",
    huobi: "woousdt",
    cryptocom: "WOO_USDT",
    kucoin: "WOO-USDT",
    gate: "woo_usdt",
    pyth: "0xb82449fd728133488d2d41131cffe763f9c1693b73c544d9ef6aaa371060dd25", // Crypto.WOO/USD
    relativeDiff: 0.01, // 1%
    fractionDigits: 6,
  },
  "853d955acef822db058eb8505911ed77f175b99e.factory.bridge.near": {
    decimals: 18,
    stablecoin: true,
    coingecko: "frax",
    chainlink: "0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD",
    pyth: "0xc3d5d8d6d17081b3d0bbca6e2fa3a6704bb9a9561d9f9e1dc52db47629f862ad",
    uniswapv3: {
      tokenIn: {
        address: "0x853d955acef822db058eb8505911ed77f175b99e", // Frax
        decimals: 18,
      },
      tokenOut: {
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
        decimals: 6,
      },
      fee: FeeAmount.LOW, // Most popular pool
    },
  },
};

const computeUsn = (usnTokenId, usdtTokenId, stablePoolId) => {
  return {
    dependencyCoin: usdtTokenId,
    computeCall: async (dependencyPrice) => {
      if (!dependencyPrice) {
        return null;
      }
      try {
        const usnPriceMultiplier = await refExchange.computeUsnPriceMultiplier(
          near,
          usnTokenId,
          usdtTokenId,
          stablePoolId
        );
        return usnPriceMultiplier
          ? {
              multiplier: Math.round(
                dependencyPrice.multiplier * usnPriceMultiplier
              ),
              decimals: dependencyPrice.decimals + 12,
            }
          : null;
      } catch (e) {
        console.log(e);
        return null;
      }
    },
  };
};

const computeSFrax = async (dependencyPrice) => {
  if (!dependencyPrice) {
    return null;
  }
  try {
    const web3 = new Web3();

    const getData = (address) => {
      return {
        method: "eth_call",
        params: [
          {
            from: null,
            to: address,
            data: "0x99530b06", // pricePerShare
          },
          "latest",
        ],
        id: 1,
        jsonrpc: "2.0",
      };
    };

    let resp = await fetchWithTimeout("https://rpc.ankr.com/eth", {
      method: "POST",
      body: JSON.stringify(
        getData("0xA663B02CF0a4b149d2aD41910CB81e23e1c41c32")
      ),
      headers: { "Content-Type": "application/json" },
    });
    resp = await resp.json();
    const pricePerShare = Big(web3.utils.toBN(resp?.result ?? 0).toString());
    const multiplier = pricePerShare.div(Big(10).pow(18));

    // TODO: Update 1.15 in about 1 year (Feb, 2025)
    if (multiplier.lt(1.01) || multiplier.gt(Big(1.15))) {
      console.error(
        "sFrax pricePerShare is out of range:",
        pricePerShare.toString()
      );
      return null;
    }

    return {
      multiplier: multiplier.mul(dependencyPrice.multiplier).toFixed(0),
      decimals: dependencyPrice.decimals,
    };
  } catch (e) {
    console.log(e);
    return null;
  }
};

const MainnetComputeCoins = {
  "meta-pool.near": {
    dependencyCoin: "wrap.near",
    computeCall: async (dependencyPrice) => {
      if (!dependencyPrice) {
        return null;
      }
      try {
        const metadata = await near.NearView(
          "meta-pool.near",
          "ft_metadata",
          {}
        );
        if (metadata.decimals !== 24) {
          return null;
        }
        const rawStNearState = await near.NearView(
          "meta-pool.near",
          "get_contract_state",
          {}
        );
        const stNearMultiplier =
          parseFloat(rawStNearState.st_near_price) / 1e24;
        // TODO: Update 1.34 in about 1 year (Jul, 2024)
        if (stNearMultiplier < 1.21 || stNearMultiplier > 1.34) {
          console.error("stNearMultiplier is out of range:", stNearMultiplier);
          return null;
        }
        return {
          multiplier: Math.round(dependencyPrice.multiplier * stNearMultiplier),
          decimals: dependencyPrice.decimals,
        };
      } catch (e) {
        console.log(e);
        return null;
      }
    },
  },
  "linear-protocol.near": {
    dependencyCoin: "wrap.near",
    computeCall: async (dependencyPrice) => {
      if (!dependencyPrice) {
        return null;
      }
      try {
        const rawLiNearPrice = await near.NearView(
          "linear-protocol.near",
          "ft_price",
          {}
        );
        const liNearMultiplier = parseFloat(rawLiNearPrice) / 1e24;
        // TODO: Update 1.25 in about 1 year (July, 2024)
        if (liNearMultiplier < 1.13 || liNearMultiplier > 1.25) {
          console.error("liNearMultiplier is out of range:", liNearMultiplier);
          return null;
        }
        return {
          multiplier: Math.round(dependencyPrice.multiplier * liNearMultiplier),
          decimals: dependencyPrice.decimals,
        };
      } catch (e) {
        console.log(e);
        return null;
      }
    },
  },
  "v2-nearx.stader-labs.near": {
    dependencyCoin: "wrap.near",
    computeCall: async (dependencyPrice) => {
      if (!dependencyPrice) {
        return null;
      }
      try {
        const nearXPrice = await near.NearView(
          "v2-nearx.stader-labs.near",
          "get_nearx_price",
          {}
        );
        const nearXMultiplier = parseFloat(nearXPrice) / 1e24;
        // TODO: Update 1.25 in about 1 year (July, 2024)
        if (nearXMultiplier < 1.13 || nearXMultiplier > 1.25) {
          console.error("nearXMultiplier is out of range:", nearXMultiplier);
          return null;
        }
        return {
          multiplier: Math.round(dependencyPrice.multiplier * nearXMultiplier),
          decimals: dependencyPrice.decimals,
        };
      } catch (e) {
        console.log(e);
        return null;
      }
    },
  },
  usn: computeUsn(
    "usn",
    "dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near",
    3020
  ),
  "usdt.tether-token.near": {
    dependencyCoin:
      "dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near",
    computeCall: async (dependencyPrice) => dependencyPrice,
  },
  "17208628f84f5d6ad33f0da3bbbeb27ffcb398eac501a31bd6ad2011e36133a1": {
    dependencyCoin:
      "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near",
    computeCall: async (dependencyPrice) => dependencyPrice,
  },
  "a663b02cf0a4b149d2ad41910cb81e23e1c41c32.factory.bridge.near": {
    dependencyCoin:
      "853d955acef822db058eb8505911ed77f175b99e.factory.bridge.near",
    computeCall: computeSFrax,
  },
};

const TestnetComputeCoins = {
  "weth.fakes.testnet": {
    dependencyCoin: "aurora",
    computeCall: async (dependencyPrice) => dependencyPrice,
  },
  "usdn.testnet": computeUsn("usdn.testnet", "usdt.fakes.testnet", 356),
  "3e2210e1184b45b64c8a434c0a7e7b23cc04ea7eb7a6c3c32520d03d4afcb8af": {
    dependencyCoin: "usdc.fakes.testnet",
    computeCall: async (dependencyPrice) => dependencyPrice,
  },
  "s.fraxtoken.testnet": {
    dependencyCoin: "fraxtoken.testnet",
    computeCall: computeSFrax,
  },
};

const mainnet = nearConfig.networkId === "mainnet";
const coins = mainnet ? MainnetCoins : TestnetCoins;
const computeCoins = mainnet ? MainnetComputeCoins : TestnetComputeCoins;

const DefaultState = {
  lastFullUpdateTimestamp: 0,
  lastVersionReportTimestamp: 0,
};

async function main() {
  const state = Object.assign(
    DefaultState,
    LoadJson(config.STATE_FILENAME) || {}
  );

  const values = await Promise.all([
    binance.getPrices(coins),
    coingecko.getPrices(coins),
    binanceFutures.getPrices(coins),
    huobi.getPrices(coins),
    cryptocom.getPrices(coins),
    kucoin.getPrices(coins),
    gate.getPrices(coins),
    chainlink.getPrices(coins),
    pyth.getPrices(coins),
    uniswapv3.getPrices(coins),
  ]);

  const new_prices = Object.keys(coins).reduce((object, ticker) => {
    let price = GetMedianPrice(values, ticker);
    coins[ticker].fractionDigits =
      coins[ticker].fractionDigits || config.FRACTION_DIGITS;

    const discrepancy_denominator = Math.pow(10, coins[ticker].fractionDigits);

    // Since stable coins rely only on coingecko price, to prevent further risks, we limit the range.
    if (coins[ticker].stablecoin && price > 0) {
      if (price < 0.95 || price > 1.05) {
        console.error(
          `Stablecoin price of ${ticker} is out of range: ${price}`
        );
        price = 0;
      }
    }

    object[ticker] = {
      multiplier: Math.round(price * discrepancy_denominator),
      decimals: coins[ticker].decimals + coins[ticker].fractionDigits,
    };
    return object;
  }, {});

  await Promise.all(
    Object.entries(computeCoins).map(
      ([key, { dependencyCoin, computeCall }]) => {
        return (async () => {
          new_prices[key] = await computeCall(new_prices[dependencyCoin]);
        })();
      }
    )
  );

  // console.log(JSON.stringify(new_prices, null, 2));

  const tickers = Object.keys(coins).concat(Object.keys(computeCoins));
  const relativeDiffs = tickers.reduce((agg, ticker) => {
    agg[ticker] =
      coins[ticker]?.relativeDiff ||
      computeCoins[ticker]?.relativeDiff ||
      config.RELATIVE_DIFF;
    return agg;
  }, {});

  const [raw_oracle_price_data, rawAssets] = await Promise.all([
    near.NearView(config.CONTRACT_ID, "get_oracle_price_data", {
      account_id: config.NEAR_ACCOUNT_ID,
      asset_ids: tickers,
      recency_duration_sec: Math.floor(config.MAX_NO_REPORT_DURATION / 1000),
    }),
    near.NearView(config.CONTRACT_ID, "get_assets", {}),
  ]);

  const liveAssets = new Set(rawAssets.map((asset) => asset[0]));

  const old_prices = raw_oracle_price_data.prices.reduce(
    (obj, item) =>
      Object.assign(obj, {
        [item.asset_id]: item.price
          ? { multiplier: item.price.multiplier, decimals: item.price.decimals }
          : { multiplier: 0, decimals: 0 },
      }),
    {}
  );

  await bot.updatePrices(
    relativeDiffs,
    old_prices,
    new_prices,
    state,
    liveAssets
  );

  SaveJson(state, config.STATE_FILENAME);
}

setTimeout(() => {
  process.exit(1);
}, config.REPORT_TIMEOUT);

main().then(() => {
  process.exit(0);
});

'''
'''--- install.sh ---
#! /bin/sh

# Other deployment actions here. Want to install (or bounce) service last.

if [ -f /etc/systemd/system/near-oracle.service ]; then
    sudo systemctl stop near-oracle.service
    sudo systemctl disable near-oracle.service
fi

sudo cp -f ./service/near-oracle.service /etc/systemd/system/near-oracle.service

sudo systemctl daemon-reload
sudo systemctl enable near-oracle.service
sudo systemctl start near-oracle.service

'''
'''--- near.js ---
const homedir = require("os").homedir();
const fs = require("fs");
const path = require("path");
const nearApi = require("near-api-js");
const {getConfig} = require("./config");
const {notify} = require("./utils/notification");

const nearConfig = getConfig(process.env.NODE_ENV || "development");
const CREDENTIALS_DIR =
  nearConfig.networkId === "mainnet"
    ? ".near-credentials/mainnet/"
    : ".near-credentials/testnet/";
const GAS = "50000000000000";

module.exports = {
  CurrentBalance: async function (accountId) {
    const nearRpc = new nearApi.providers.JsonRpcProvider(nearConfig.nodeUrl);
    const account = new nearApi.Account({ provider: nearRpc }, accountId);

    const state = await account.state();

    return state.amount;
  },

  NearView: async function (contract, operation, parameters) {
    const nearRpc = new nearApi.providers.JsonRpcProvider(nearConfig.nodeUrl);
    const account = new nearApi.Account({ provider: nearRpc });

    const view = await account.viewFunction(contract, operation, parameters);

    return view;
  },

  NearCall: async function (account_id, contract, operation, parameters) {
    try {
      const privateKey = await GetPrivateKey(account_id);

      const keyPair = nearApi.utils.KeyPair.fromString(privateKey);
      const keyStore = new nearApi.keyStores.InMemoryKeyStore();
      keyStore.setKey("default", account_id, keyPair);

      const near = await nearApi.connect({
        networkId: "default",
        deps: { keyStore },
        masterAccount: account_id,
        nodeUrl: nearConfig.nodeUrl,
      });

      const account = await near.account(account_id);

      const call = await account.functionCall({
        contractId: contract,
        methodName: operation,
        args: parameters,
        gas: GAS,
        attachedDeposit: "0",
      });

      if (call["status"].hasOwnProperty("SuccessValue")) {
        let logs = [];
        call["receipts_outcome"].map((receipts_outcome) => {
          if (receipts_outcome ?? ["outcome"] ?? ["logs"].length)
            receipts_outcome["outcome"]["logs"].map((log) => logs.push(log));
        });
        console.log(`Successful operation: ${operation}!\n\r${logs.join("\n\r")}`);
      } else {
        return notify(`Failed operation: ${operation}`);
      }
    } catch (e) {
      console.log(e.message);
      return notify(`Call processed with unknown result: ${e.message}`);
    }
  },
};

const GetPrivateKey = async function (account_id) {
  const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
  const keyPath = credentialsPath + account_id + ".json";
  try {
    const credentials = JSON.parse(fs.readFileSync(keyPath));
    return credentials.private_key;
  } catch (e) {
    throw new Error(
      "Key not found for account " + keyPath + ". Error: " + e.message
    );
  }
};

'''
'''--- package.json ---
{
  "name": "near-oracle-bot",
  "version": "1.4",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "@pythnetwork/pyth-evm-js": "^1.29.2",
    "big.js": "^6.1.1",
    "binance-api-node": "^0.11.13",
    "coingecko-api-v3": "0.0.13",
    "messaging-api-telegram": "^1.1.0",
    "near-api-js": "^0.42.0",
    "node-abort-controller": "^3.0.1",
    "web3": "^1.8.2",
    "ethers": "^5.7.2",
    "@uniswap/v3-sdk": "^3.9.0",
    "@uniswap/sdk-core": "^3.1.0"
  },
  "scripts": {
    "test": "jest func.test.js --useStderr --verbose false"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/NearDeFi/near-price-oracle-bot.git"
  },
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/NearDeFi/near-price-oracle-bot/issues"
  },
  "homepage": "https://github.com/NearDeFi/near-price-oracle-bot#readme",
  "devDependencies": {
    "jest": "^27.2.0",
    "prettier": "^2.4.1"
  }
}

'''
'''--- run.sh ---
#!/bin/bash
set -e

export NODE_ENV=mainnet
# TODO: Add your account ID
# export NEAR_ACCOUNT_ID=abc.near
export CONTRACT_NAME=priceoracle.near
export PRINT_DEBUG=true

cd $(dirname "$0")
mkdir -p logs

while :
do
  DATE=$(date "+%Y_%m_%d")
  date | tee -a logs/logs_$DATE.txt
  # TODO: Update your path to the node binary if necessary
  /usr/local/bin/node index.js 2>&1 | tee -a logs/logs_$DATE.txt
  sleep 5
done

'''
'''--- tests/func.test.js ---
const { IsDifferentEnough, GetMedianPrice, GetAvgPrice } = require("./../functions");

const MakeNum = (multiplier, decimals) => {
  return { multiplier, decimals };
};

test("Test GetAvgPrice", () => {
    expect(GetAvgPrice(20, 30, 25)).toBe(25);
    expect(GetAvgPrice(20, 30, 40)).toBe(30);
    expect(GetAvgPrice(20, 30, 10)).toBe(20);
    expect(GetAvgPrice(0, 30, 10)).toBe(0);
    expect(GetAvgPrice(20, 0, 10)).toBe(0);
    expect(GetAvgPrice(0, 0, 0)).toBe(0);
    expect(GetAvgPrice("20", "30", "25")).toBe(25);
    expect(GetAvgPrice("20", "30", "40")).toBe(30);
    expect(GetAvgPrice("20", "30", "10")).toBe(20);
    expect(GetAvgPrice(30, 20, 25)).toBe(0);
});

test("Test IsDifferentEnough", () => {
  const relDiff = 0.005;
  expect(IsDifferentEnough(relDiff, MakeNum(10, 0), MakeNum(11, 0))).toBe(true);
  expect(IsDifferentEnough(relDiff, MakeNum(11, 0), MakeNum(10, 0))).toBe(true);
  expect(IsDifferentEnough(relDiff, MakeNum(11, 0), MakeNum(11, 0))).toBe(
    false
  );

  expect(IsDifferentEnough(relDiff, MakeNum(10, 10), MakeNum(11, 10))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(11, 10), MakeNum(10, 10))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(11, 10), MakeNum(11, 10))).toBe(
    false
  );

  expect(IsDifferentEnough(relDiff, MakeNum(100, 10), MakeNum(10, 9))).toBe(
    false
  );
  expect(IsDifferentEnough(relDiff, MakeNum(10, 9), MakeNum(100, 10))).toBe(
    false
  );

  expect(IsDifferentEnough(relDiff, MakeNum(101, 10), MakeNum(10, 9))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(10, 9), MakeNum(101, 10))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(99, 10), MakeNum(10, 9))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(10, 9), MakeNum(99, 10))).toBe(
    true
  );

  expect(IsDifferentEnough(relDiff, MakeNum(101, 40), MakeNum(10, 0))).toBe(
    true
  );
  expect(IsDifferentEnough(relDiff, MakeNum(10, 0), MakeNum(101, 40))).toBe(
    true
  );

  expect(IsDifferentEnough(relDiff, MakeNum(101, 40), MakeNum(10100, 42))).toBe(
    false
  );
  expect(
    IsDifferentEnough(
      relDiff,
      MakeNum(100000000000000000000, 20),
      MakeNum(10, 1)
    )
  ).toBe(false);
});

test("Test GetMedianPrice", () => {
  expect(
    GetMedianPrice(
      [
        { ticker: 1.2 },
        { ticker: 1.3 },
        { ticker: 1.4 },
        { ticker: 1.5 },
        { ticker: 1.6 },
      ],
      "ticker"
    )
  ).toBe(1.4);

  expect(
    GetMedianPrice(
      [
        { ticker: 110.2 },
        { ticker: 210.3 },
        { ticker: 310.4 },
        { ticker: 410.5 },
        { ticker: 510.6 },
      ],
      "ticker"
    )
  ).toBe(310.4);

  expect(
    GetMedianPrice(
      [
        { ticker: 110.2 },
        { ticker: 210.3 },
        { ticker: 310.4 },
        { ticker: 410.5 },
      ],
      "ticker"
    )
  ).toBe((210.3 + 310.4) / 2);

  expect(GetMedianPrice([], "ticker")).toBe(0);

  expect(GetMedianPrice([{ ticker: 1 }], "ticker")).toBe(1);
});

'''
'''--- utils/notification.js ---
const { sendToTelegram } = require("./telegram");
const config = require("../config");

module.exports = {
    notify: async function(message){
        let token = config.TELEGRAM_TOKEN;
        let chatId = config.TELEGRAM_CHAT_ID;

        if(token && chatId) {
            await sendToTelegram(message, token, chatId);
        }
    }
}
'''
'''--- utils/telegram.js ---
const {TelegramClient} = require('messaging-api-telegram');

module.exports = {
    sendToTelegram: async function (message, accessToken, chatId) {
        try {
            if (accessToken && chatId) {
                const client = new TelegramClient({
                    accessToken
                });
                let resp = await client.sendMessage(chatId, message)
                    .catch(err => {
                        console.error(err);
                    });

                if(!resp.hasOwnProperty("messageId")) {
                    console.log(`sendToTelegram notification failed: ${JSON.stringify(resp)}`);
                }
            }
        }
        catch (err) {
            console.error(err)
        }
    },
}
'''