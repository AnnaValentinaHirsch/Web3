*GitHub Repository "agileurbanite/stats-sputnik-dao"*

'''--- client/main.html ---
<head>
  <base href="/">
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Sputnik DAO Analytics and Insights"/>
  <title>Sputnik DAO Stats</title>
</head>

<body>
<div id="react-target"></div>
</body>

'''
'''--- imports/api/data.js ---
import {Meteor} from 'meteor/meteor';
import {Mongo} from "meteor/mongo";
import {check} from "meteor/check";
import {ValidatedMethod} from "meteor/mdg:validated-method";

export const TxActions = new Mongo.Collection("txActions");
export const DaoData = new Mongo.Collection("daoData");
export const CoinGeckoCurrencies = new Mongo.Collection("coinGeckoCurrencies");
export const NearPrice = new Mongo.Collection("nearPrice");
export const ConsolidatedDataDeposits = new Mongo.Collection("consolidatedDataDeposits");

if (Meteor.isServer) {

  Meteor.publish("TxActions", function () {
    return TxActions.find({});
  });
  Meteor.publish("DaoData", function () {
    return DaoData.find({});
  });
  Meteor.publish("CoinGeckoCurrencies", function () {
    return CoinGeckoCurrencies.find({});
  });
    Meteor.publish("NearPrice", function () {
    return NearPrice.find({});
  });
    Meteor.publish("ConsolidatedDataDeposits", function () {
    return ConsolidatedDataDeposits.find({});
  });
}

'''
'''--- imports/utils/container.js ---
import React, {
  createContext,
  useContext,
  useReducer,
  useState,
  useEffect
} from 'react'
import {reducer, defaultState} from './store'
import CustomizedSnackbar from './snackbar-wrapper'
import Loading from '../ui/pages/Loading'

const StateContext = createContext({})
const MutationContext = createContext({})

export const ContainerProvider = ({children}) => {
  const [state, dispatch] = useReducer(reducer, defaultState)

  window.rootState = state

  const [toasts, updateToasts] = useState([])

  const methods = {
    startLoading() {
      dispatch({type: 'loading', payload: true})
    },
    stopLoading() {
      dispatch({type: 'loading', payload: false})
    },
    updateConfig(params) {
      dispatch({type: 'config', payload: {...state.config, ...params}})
    },
    removeTop() {
      const items = toasts.filter((e, idx) => idx > 0)
      updateToasts([...items])
    },
    toastSuccess(message) {
      updateToasts([
        ...toasts,
        {
          variant: 'success',
          message
        }
      ])
    },
    toastInfo(message) {
      updateToasts([
        ...toasts,
        {
          variant: 'info',
          message
        }
      ])
    },
    toastError(message) {
      updateToasts([
        ...toasts,
        {
          variant: 'error',
          message
        }
      ])
    },
  }

  useEffect(() => {
    window.localStorage.setItem(
      'near_tools_local_storage',
      JSON.stringify({
        darkMode: state.config.darkMode,
      })
    )
  }, [state])

  return (
    <StateContext.Provider value={state}>
      <MutationContext.Provider value={methods}>
        <CustomizedSnackbar toasts={toasts}/>
        {state.loading ? <Loading/> : null}
        {children}
      </MutationContext.Provider>
    </StateContext.Provider>
  )
}

export function useGlobalState() {
  return useContext(StateContext)
}

export function useGlobalMutation() {
  return useContext(MutationContext)
}

'''
'''--- imports/utils/snackbar-wrapper.js ---
import React, {useEffect} from 'react'
import {useGlobalMutation} from './container'

export default function CustomizedSnackbar(props) {
  const mutationCtx = useGlobalMutation()
  const handleClose = (evt) => {
  }

  return (
    <>
      {props.toasts !== []  ? props.toasts.map((item, index) => (
         <div
            //autohide={6000}
            bodyClassName="p-5 font-weight-bold white-text"
            className="stylish-color-dark"
            closeClassName="white-text"
            fade
            icon="bell"
            iconClassName="orange-text"
            message={item.message.toString()}
            show
            text=""
            title={item.variant}
            titleClassName="elegant-color-dark white-text"
            style={{
              position: "fixed",
              top: "60px",
              right: "10px",
              zIndex: 9999
            }}
          />
      )) : null}
    </>
  )
}

'''
'''--- imports/utils/store.js ---
const readDefaultState = () => {
  try {
    return JSON.parse(window.localStorage.getItem('near_tools_local_storage'))
  } catch (err) {
    return {}
  }
}

const defaultState = {
  loading: false,
  config: {
    darkMode: 'light',
    filterOpen: false,
    ...readDefaultState(),
  }
}

const reducer = (state, action) => {
  switch (action.type) {
    case 'config': {
      return {...state, config: action.payload}
    }
    case 'loading': {
      return {...state, loading: action.payload}
    }
    default:
      throw new Error('mutation type not defined')
  }
}

export {reducer, defaultState}

'''
'''--- imports/utils/use-router.js ---
import React, { useContext } from 'react'
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'

export const RouterContext = React.createContext({})

export const BrowserRouterHook = ({ children }) => (
  <Router>
    <Switch>
      <Route>
        {(routeProps) => (
          <RouterContext.Provider value={routeProps}>
            {children}
          </RouterContext.Provider>
        )}
      </Route>
    </Switch>
  </Router>
)

export default function useRouter () {
  return useContext(RouterContext)
}

'''
'''--- server/coingecko.js ---
import {SyncedCron} from 'meteor/littledata:synced-cron';
import {CoinGeckoCurrencies, NearPrice} from "../imports/api/data";
import {Meteor} from "meteor/meteor";

const CoinGecko = require('coingecko-api');
const CoinGeckoClient = new CoinGecko();

const getPrice = async () => {
  return CoinGeckoClient.coins.fetch('near');
};

const getCoinGeckoCurrencies = async () => {
  return CoinGeckoClient.simple.supportedVsCurrencies();
}

if (Meteor.isServer) {

  SyncedCron.add({
    name: 'Pull CoinGecko Currencies',
    schedule: function (parser) {
      return parser.text('every 7 days');
    },
    job: async function () {
      try {
        const currencies = await getCoinGeckoCurrencies();
        if (currencies.success === true) {
          console.log(currencies)
          CoinGeckoCurrencies.update(
            {},
            {
              currencies: currencies.data
            },
            {upsert: true}
          )
        }
      } catch (e) {
        console.log(e);
      }
    }
  });

  SyncedCron.add({
    name: 'Pull Near Price',
    schedule: function (parser) {
      return parser.text('every 10 min');
    },
    job: async function () {
      try {
        const result = await getPrice();
        if (result.success === true) {
          NearPrice.update(
            {},
            {
              near_price_data: result.data.market_data,
            },
            {upsert: true}
          )
        }
      } catch (e) {
        console.log(e);
      }
    }
  });

}

'''
'''--- server/daos.js ---
import nearApi from "near-api-js";
import {sha256} from "js-sha256";
import {Meteor} from "meteor/meteor";
import {SyncedCron} from 'meteor/littledata:synced-cron';
import {DaoData} from "../imports/api/data";
import {Decimal} from "decimal.js";

export const factory = 'sputnikdao.near';
export const todayDate = new Date().toISOString().slice(0, 10);

export const NEAR_RPC_URL = 'https://rpc.mainnet.near.org'
const provider = new nearApi.providers.JsonRpcProvider(NEAR_RPC_URL);
const connection = new nearApi.Connection(NEAR_RPC_URL, provider, {});
const account = new nearApi.Account(connection, '');

async function accountExists(accountId) {
  try {
    return await new nearApi.Account(connection, accountId).state();
  } catch (error) {
    return false;
  }
}

async function getDaoList(factory) {
  return await account.viewFunction(factory, 'get_dao_list', {})
}

async function getDaoData(dao) {
  const state = await accountExists(dao);
  if (state) {
    const council = await account.viewFunction(dao, 'get_council', {})
    const purpose = await account.viewFunction(dao, 'get_purpose', {})
    const votePeriod = await account.viewFunction(dao, 'get_vote_period', {})
    const bond = await account.viewFunction(dao, 'get_bond', {})

    let limit = 100;
    let fromIndex = 0;
    let numberProposals = await account.viewFunction(dao, 'get_num_proposals', {})
    console.log(dao + ": " + numberProposals);
    let proposals = [];

    if (numberProposals > 100) {
      let pages = new Decimal(numberProposals / limit).toFixed(0);
      let i;
      for (i = 0; i <= pages; i++) {
        fromIndex = limit * i;
        let proposals2;
        try {
          proposals2 = await account.viewFunction(dao, 'get_proposals', {from_index: fromIndex, limit: limit})
        } catch (e) {
          console.log(e)
        }
        Array.prototype.push.apply(proposals, proposals2);
      }
    } else {
      proposals = await account.viewFunction(dao, 'get_proposals', {from_index: fromIndex, limit: limit})
    }

    proposals.forEach(function (v) {
      delete v.votes;
    });

    return {
      council: council,
      purpose: purpose,
      proposals: proposals,
      votePeriod: votePeriod,
      bond: bond,
      amount: state.amount,
    }
  } else {
    return false;
  }
}

async function storeDaoList() {
  const daos = await getDaoList(factory);
  let stop = false
  console.log('total daos: ' + daos.length);
  for (const item of daos) {
    if (!stop) {
      const dao = await getDaoData(item);
      //stop = true;

      if (dao) {
        try {
          DaoData.update(
            {
              daoName: item,
            },
            {
              daoName: item,
              council: dao.council,
              purpose: dao.purpose,
              proposals: dao.proposals,
              votePeriod: dao.votePeriod,
              bond: dao.bond,
              amount: dao.amount,
            },
            {upsert: true}
          )
        } catch (e) {
          console.log(dao);
          console.log(e);
        }
      }

    }
  }
}

/*
storeDaoList().then().catch((e) => {
  console.log(e)
})
*/

if (Meteor.isServer) {
  SyncedCron.add({
    name: 'Fetch Dao Data',
    schedule: function (parser) {
      return parser.text('every 12 minutes');
    },
    job: async function () {
      await storeDaoList()
    }
  });
}

'''
'''--- server/indexer.js ---
import {Meteor} from "meteor/meteor";
import {SyncedCron} from 'meteor/littledata:synced-cron';

/*
async function queryPg(block_timestamp) {
  const {Client} = require('pg')
  const connectionString = 'postgres://public_readonly:nearprotocol@104.199.89.51/mainnet_explorer'

  let q =
    `SELECT *
     FROM transactions t,
          receipts r,
          blocks b,
          transaction_actions a,
          action_receipt_actions ra,
          execution_outcomes e
     WHERE t.transaction_hash = r.originated_from_transaction_hash
       AND r.receipt_id = e.receipt_id
       AND b.block_timestamp = r.included_in_block_timestamp
       AND ra.receipt_id = r.receipt_id
       AND t.transaction_hash = a.transaction_hash
       AND a.action_kind = 'FUNCTION_CALL'
       AND e.status = 'SUCCESS_VALUE'
       AND r.predecessor_account_id != 'system'
       AND t.receiver_account_id LIKE ('%.sputnikdao.near')
       AND t.block_timestamp >= $1
     ORDER BY t.block_timestamp ASC
     LIMIT 300
    `;

  const values = [block_timestamp]
  const client = new Client({
    connectionString: connectionString
  });
  await client.connect()
  const res = await client.query(q, values);
  console.log(res.rows.length);
  await client.end()
  return res.rows;
}

*/

const autobahn = require("autobahn");

import {TxActions} from "../imports/api/data";

let session = null;
const connection = new autobahn.Connection({
  url: "wss://near-explorer-wamp.onrender.com/ws",
  realm: "near-explorer",
  retry_if_unreachable: true,
  max_retries: 5,
  max_retry_delay: 10,
});

connection.onopen = async (s, details) => {
  session = s;
  session.log();
  console.log("started indexer update");
  await storeTransactions().then(
    () => {
      connection.close()
      console.log("finished indexer update");
    }
  );
};

connection.onclose = (reason, details) => {
  console.log('connection close');
  console.log('Reason:');
  console.log(reason);
  session = null;
};

connectAndStoreTransactions().then((r) => {
}).catch((e) => {
  console.log(e);
})

async function query(q) {
  const procedure = `com.nearprotocol.mainnet.explorer.select`;
  return session.call(procedure, q);
}

async function queryPostgres(q) {
  const procedure = `com.nearprotocol.mainnet.explorer.select:INDEXER_BACKEND`;
  return session.call(procedure, q);
}

async function queryNearCoreTx(q) {
  const procedure = `com.nearprotocol.mainnet.explorer.nearcore-tx`;
  return session.call(procedure, q);
}

async function getTransactions(block_timestamp) {
  return await queryPostgres([
    `SELECT *
     FROM transactions t,
          receipts r,
          blocks b,
          transaction_actions a,
          action_receipt_actions ra,
          execution_outcomes e
     WHERE t.transaction_hash = r.originated_from_transaction_hash
       AND r.receipt_id = e.receipt_id
       AND b.block_timestamp = r.included_in_block_timestamp
       AND ra.receipt_id = r.receipt_id
       AND t.transaction_hash = a.transaction_hash
       AND a.action_kind = 'FUNCTION_CALL'
       AND e.status = 'SUCCESS_VALUE'
       AND r.predecessor_account_id != 'system'
       AND t.receiver_account_id LIKE ('%.sputnikdao.near')
       AND t.block_timestamp >= :block_timestamp
     ORDER BY t.block_timestamp ASC
     LIMIT :limit
    `, {
      limit: 50,
      block_timestamp: block_timestamp
    }
  ]).then((data) => {
      //console.log(data)
      console.log(data.length);
      return data;
    }
  ).catch((e) => {
    console.log(e);
  });
}

if (Meteor.isServer) {
  SyncedCron.add({
    name: 'Fetch Transactions',
    schedule: function (parser) {
      return parser.text('every 5 minutes');
    },
    job: async function () {
      await connectAndStoreTransactions();
    }
  });
}

async function connectAndStoreTransactions() {
  if (!connection.isOpen) {
    connection.open();
  }
}

async function storeTransactions() {
  let d = new Date();
  d.setDate(d.getDate() - 3);
  let blockTimestamp = d.getTime() * 1000 * 1000;
  /* To received the data from Epoch2, uncomment below */
  //let blockTimestamp = 1598366209232845339;
  /* -------------------------------------------------- */
  let len = 50;
  let offset = 0;
  while (len > 0) {
    const transactions = await getTransactions(blockTimestamp);
    if (transactions) {
      len = transactions.length;
    } else {
      len = 0;
      console.log('most likely an error occurred');
    }
    if (len > 1) {

      blockTimestamp = transactions[len - 1].block_timestamp;
      offset = offset + len;

      transactions.map((item) => {
        try {
          TxActions.update(
            {
              transaction_hash: item.transaction_hash,
              block_timestamp: Number(item.block_timestamp),
              block_height: Number(item.block_height),
              signer_account_id: item.signer_account_id,
              receiver_account_id: item.receiver_account_id,
              receipt_receiver_account_id: item.receipt_receiver_account_id,
              predecessor_account_id: item.predecessor_account_id,
              gas: item.gas,
              action_kind: item.action_kind,
              method_name: item.args.method_name,
              args_base64: item.args.args_base64 ? Buffer.from(item.args.args_base64, 'base64').toString('utf-8') : null,
              args: !item.args.args_base64 ? item.args : null,
            },
            {
              transaction_hash: item.transaction_hash,
              block_timestamp: Number(item.block_timestamp),
              block_height: Number(item.block_height),
              signer_account_id: item.signer_account_id,
              receiver_account_id: item.receiver_account_id,
              receipt_receiver_account_id: item.receipt_receiver_account_id,
              predecessor_account_id: item.predecessor_account_id,
              gas: item.gas,
              action_kind: item.action_kind,
              method_name: item.args.method_name,
              args_base64: item.args.args_base64 ? Buffer.from(item.args.args_base64, 'base64').toString('utf-8') : null,
              args: !item.args.args_base64 ? item.args : null,
            },
            {upsert: true}
          )
        } catch (e) {
          console.log(e);
        }

      })
    }
  }
}

'''
'''--- server/main.js ---
import {SyncedCron} from 'meteor/littledata:synced-cron';

import "./daos";
import "./coingecko";
import './indexer';

SyncedCron.start();

'''
'''--- server/near_config.js ---
const CONTRACT_NAME = 'dev-1610115292586-3217148'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: 'sputnikdao.near',
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- tests/main.js ---
import assert from "assert";

describe("stats-sputnik-dao", function () {
  it("package.json has correct name", async function () {
    const { name } = await import("../package.json");
    assert.strictEqual(name, "stats-sputnik-dao");
  });

  if (Meteor.isClient) {
    it("client is not server", function () {
      assert.strictEqual(Meteor.isServer, false);
    });
  }

  if (Meteor.isServer) {
    it("server is not client", function () {
      assert.strictEqual(Meteor.isClient, false);
    });
  }
});

'''