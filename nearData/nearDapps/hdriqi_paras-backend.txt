*GitHub Repository "hdriqi/paras-backend"*

'''--- Cron.js ---
var cron = require('node-cron')

class Cron {
  constructor(state, storage, mail) {
    this.state = state
    this.storage = storage
    this.mail = mail
  }

  async _sendWalletEmail() {
    try {
      const endTime = new Date().getTime()
      const last12H = 24 * 60 * 60 * 1000
      const startTime = endTime - last12H
      const last12HTx = await this.storage.db.collection('transaction').find({
        createdAt: {
          // in nanosecond
          $gte: (startTime * 1000000).toString()
        }
      })
      const mappedTx = {}
      const arr = last12HTx.toArray()
      const iter = (await arr).map(x => x)
      for await (const tx of iter) {
        if (mappedTx[tx.to]) {
          mappedTx[tx.to].push(tx)
        }
        else {
          mappedTx[tx.to] = [tx]
        }
      }
      for await (const [key, value] of Object.entries(mappedTx)) {
        const verification = await this.storage.db.collection('verifications').findOne({
          userId: key
        })
        if (verification.status === 'confirmed') {
          this.mail.sendWalletEmail({
            txList: value,
            email: verification.email
          })
        }
      }
    } catch (err) {
      console.log(err)
    }
  }

  async _sendNotifyEmail() {
    try {
      const endTime = new Date().getTime()
      const last12H = 12 * 60 * 60 * 1000
      const startTime = endTime - last12H
      const last12HNotification = await this.storage.db.collection('notification').find({
        createdAt: {
          $gte: startTime.toString()
        }
      })
      const mappedNotification = {}
      const arr = last12HNotification.toArray()
      const iter = (await arr).map(x => x)
      for await (const notif of iter) {
        if (mappedNotification[notif.userId]) {
          mappedNotification[notif.userId].push(notif)
        }
        else {
          mappedNotification[notif.userId] = [notif]
        }
      }
      for await (const [key, value] of Object.entries(mappedNotification)) {
        const verification = await this.storage.db.collection('verifications').findOne({
          userId: key
        })
        if (verification.status === 'confirmed') {
          this.mail.sendNotificationEmail({
            notifyList: value,
            email: verification.email
          })
        }
      }
    } catch (err) {
      console.log(err)
    }
  }

  async init() {
    cron.schedule('0 9 * * *', async () => {
      await this._sendWalletEmail()
    }, {
      scheduled: true,
      timezone: 'America/Los_Angeles'
    })

    cron.schedule('0 8,20 * * *', async () => {
      await this._sendNotifyEmail()
    }, {
      scheduled: true,
      timezone: 'America/Los_Angeles'
    })
  }
}

module.exports = Cron
'''
'''--- Mail.js ---
const nodemailer = require('nodemailer')
const heml = require('heml')
const { prettyBalance } = require('./utils/common')
const templateVerifyEmail = require('./MailTemplate/verifyEmail')
const templateWalletEmail = require('./MailTemplate/walletEmail')
const templateNotifyEmail = require('./MailTemplate/notifyEmail')
const JSBI = require('jsbi')
const aws = require('aws-sdk')

const hemlOpts = {
  validate: 'soft',
  cheerio: {},
  juice: {},
  beautify: {},
  elements: []
}

class Mail {
  constructor() {
    this.transporter = null
    this.send = this.send.bind(this)
  }

  async init() {
    const SESConfig = new aws.SES({
      apiVersion: '2010-12-01',
      accessKeyId: process.env.SES_IAM_USER_KEY,
      secretAccessKey: process.env.SES_IAM_USER_SECRET,
      region: 'ap-southeast-1'
    })
    this.transporter = nodemailer.createTransport({
      SES: SESConfig
    })
  }

  send(data) {
    if(!this.transporter) {
      throw 'mail is not initialized'
    }
    return new Promise((resolve, reject) => {
      this.transporter.sendMail(data, (err) => {
        if(err) {
          return reject(err)
        }
        return resolve()
      })
    })
  }

  async sendVerifyEmail({ link, email }) {
    const tmpl = templateVerifyEmail(link)
    const { html } = await heml(tmpl, hemlOpts)
    console.log(`verify mail send to ${email}`)
    this.send({
      from: `"Paras Team" <hello@paras.id>`,
      to: email,
      subject: `[Paras] Email Verification`,
      html: html
    })
  }

  async sendWalletEmail({ txList, email }) {
    const tmpl = templateWalletEmail(txList)
    const totalGain = txList.map(tx => JSBI.BigInt(tx.value)).reduce((a, b) => JSBI.add(a, b))
    const { html } = await heml(tmpl, hemlOpts)
    const subject = `[Paras] You've received ${prettyBalance(totalGain, 18, 4)} PAC`
    console.log(`wallet mail send to ${email}`)
    this.send({
      from: `"Paras Team" <hello@paras.id>`,
      to: email,
      subject: subject,
      html: html
    })
  }

  async sendNotificationEmail({ notifyList, email }) {
    const tmpl = templateNotifyEmail(notifyList)
    const { html } = await heml(tmpl, hemlOpts)
    const subject = `[Paras] You've ${notifyList.length} notifications`
    console.log(`notification mail send to ${email}`)
    this.send({
      from: `"Paras Team" <hello@paras.id>`,
      to: email,
      subject: subject,
      html: html
    })
  }
}

module.exports = Mail
'''
'''--- MailTemplate/notifyEmail.js ---
const notifyEmail = (notifyList) => {
  const summary = notifyList.map(notify => {
    return `<li><p><a href="${notify.link}">${notify.message}</a></p></li>`
  }).join('')

  return `
  <heml>
  <head>
    <style>
    body {
      font-family: 'Inconsolata', monospace;
      background-color: #121212;
      padding: 48px 0px;
      line-height: 150%;
    }
    container {
      width: 100%;
      max-width: 480px;
      padding: 16px 24px;
      background: #2C2C2C;
      color: white;
      font-weight: 400;
      box-shadow: 0px 12px 32px rgba(0, 0, 0, 0.12);
      border-radius: 4px;
    }
    button {
      font-family: 'Inconsolata', monospace;
      padding: 8px 16px;
      font-style: normal;
      font-weight: 400;
      font-size: 16px;
      letter-spacing: .3px;
      line-height: 24px;
      text-align: center;
      background: #e13128;
      border-radius: 4px;
    }
    a {
      color: white;
      font-weight: 600;
    }
    </style>
  </head>
  <body>
    <container>
      <row style="margin-bottom: 8px">
        <col>
          <img style="width:60px; margin: auto" src="https://paras-media.s3-ap-southeast-1.amazonaws.com/Paras+Logo.png" />
        </col>
      </row>
      <row style="margin-bottom: 8px">
        <p>Here's some actions that related to your account in the past 12 hours:</p>
        <ul>
          ${summary}
        </ul>
      </row>
      <row>
        <p>If you have any question, feel free to ask us on <a href="mailto:hello@paras.id">hello@paras.id</a></p>
      </row>
    </container>
  </body>
</heml>
  `
}

module.exports = notifyEmail
'''
'''--- MailTemplate/verifyEmail.js ---
const confirmEmail = (link) => {
  return `
  <heml>
    <head>
      <style>
      body {
        font-family: 'Inconsolata', monospace;
        background-color: #121212;
        padding: 48px 0px;
        line-height: 150%;
      }
      container {
        width: 100%;
        max-width: 480px;
        padding: 16px 24px;
        background: #2C2C2C;
        color: white;
        font-weight: 400;
        box-shadow: 0px 12px 32px rgba(0, 0, 0, 0.12);
        border-radius: 4px;
      }
      button {
        font-family: 'Inconsolata', monospace;
        padding: 8px 16px;
        font-style: normal;
        font-weight: 400;
        font-size: 16px;
        letter-spacing: .3px;
        line-height: 24px;
        text-align: center;
        background: #e13128;
        border-radius: 4px;
      }
      a {
        color: white;
        font-weight: 600;
      }
      </style>
    </head>
    <body>
      <container>
        <row style="margin-bottom: 8px">
          <col>
            <img style="width:60px; margin: auto" src="https://paras-media.s3-ap-southeast-1.amazonaws.com/Paras+Logo.png" />
          </col>
        </row>
        <row style="margin-bottom: 8px">
          <p>Hi there,</p>
          <p>You have successfully created a Paras account. Please click on the link below to verify your email address and complete your registration.</p>
        </row>
        <button style="margin-bottom: 36px" href="${link}">Confirm Email</button>
        <row>
          <p>If you have any question, feel free to ask us on <a href="mailto:hello@paras.id">hello@paras.id</a></p>
        </row>
      </container>
    </body>
  </heml>
  `
}

module.exports = confirmEmail
'''
'''--- MailTemplate/walletEmail.js ---
const { prettyBalance } = require('../utils/common')

const walletEmail = (txList) => {
  const summary = txList.map((tx) => {
    return `<p>[#${tx.id}] ${prettyBalance(tx.value, 18, 4)} PAC from <a href="${process.env.FRONTEND_URL}/${tx.from}">${tx.from}</a></p>`
  }).join('')

  return `
<heml>
  <head>
    <style>
    body {
      font-family: 'Inconsolata', monospace;
      background-color: #121212;
      padding: 48px 0px;
      line-height: 150%;
    }
    container {
      width: 100%;
      max-width: 480px;
      padding: 16px 24px;
      background: #2C2C2C;
      color: white;
      font-weight: 400;
      box-shadow: 0px 12px 32px rgba(0, 0, 0, 0.12);
      border-radius: 4px;
    }
    button {
      font-family: 'Inconsolata', monospace;
      padding: 8px 16px;
      font-style: normal;
      font-weight: 400;
      font-size: 16px;
      letter-spacing: .3px;
      line-height: 24px;
      text-align: center;
      background: #e13128;
      border-radius: 4px;
    }
    a {
      color: white;
      font-weight: 600;
    }
    </style>
  </head>
  <body>
    <container>
      <row style="margin-bottom: 8px">
        <col>
          <img style="width:60px; margin: auto" src="https://paras-media.s3-ap-southeast-1.amazonaws.com/Paras+Logo.png" />
        </col>
      </row>
      <row style="margin-bottom: 8px">
        <p>Here's the summary of your gains in the past few hours:</p>
        ${summary}
      </row>
      <row>
        <p>Check out your balance and transaction details on Paras Wallet</p>
      </row>
      <button style="margin-bottom: 36px" href="${process.env.FRONTEND_URL}/wallet">Go To Wallet</button>
      <row>
        <p>If you have any question, feel free to ask us on <a href="mailto:hello@paras.id">hello@paras.id</a></p>
      </row>
    </container>
  </body>
</heml> 
  `
}

module.exports = walletEmail
'''
'''--- Near.js ---
const { Contract, KeyPair, connect } = require('near-api-js')
const { join } = require('path')
const { InMemoryKeyStore, MergeKeyStore, UnencryptedFileSystemKeyStore } = require('near-api-js').keyStores
const { parseNearAmount } = require('near-api-js').utils.format

const config = require('./config')(process.env.NODE_ENV || 'development')

const contractConfig = {
  viewMethods: [
    'getUserById',
    'getMementoById',
    'name',
    'symbol',
    'decimals',
    'balanceOf',
    'allowance',
    'getBalance'
  ],
  // Change methods can modify the state, but you don't receive the returned value when called
  changeMethods: [
    'createMemento',
    'updateMemento',
    'archiveMemento',
    'unarchiveMemento',
    'deleteMemento',
    'createPost',
    'transmitPost',
    'editPost',
    'deletePost',
    'redactPost',
    'toggleFollow',
    'createUser',
    'updateUser',
    'createComment',
    'deleteComment',
    'init',
    'transfer',
    'approve',
    'transferFrom',
    'piecePost'
  ],
}

class Near {
  constructor() {
    this.ctx = null
    this.masterAccount = null
    this.accountMap = new Map()
  }

  async init() {
    if (!process.env.ROOT_ACCOUNT) {
      throw "[env] ROOT_ACCOUNT not found"
    }
    if (!process.env.CONTRACT_ACCOUNT) {
      throw "[env] CONTRACT_ACCOUNT not found"
    }
    const rootAccount = JSON.parse(process.env.ROOT_ACCOUNT)
    const contractAccount = JSON.parse(process.env.CONTRACT_ACCOUNT)
    const keyStore = new InMemoryKeyStore()
    
    const rootKeyPair = KeyPair.fromString(rootAccount.secret_key || rootAccount.private_key)
    await keyStore.setKey(config.networkId, rootAccount.account_id, rootKeyPair)

    const contractKeyPair = KeyPair.fromString(contractAccount.secret_key || contractAccount.private_key)
    await keyStore.setKey(config.networkId, contractAccount.account_id, contractKeyPair)

    const near = await connect({
      deps: {
        keyStore: keyStore
      },
      ...config
    })
    this.ctx = near
    this.masterAccount = await near.account(rootAccount.account_id)
    this.contractAccount = await near.account(contractAccount.account_id)
    this.keyStore = keyStore
  }

  async checkAccount(accountId) {
    return new Promise(async (resolve) => {
      let account = null
      try {
        account = await this.ctx.account(accountId)
      } catch (err) {
        // console.log(err)
      }
      resolve(account)
    })
  }

  async loadAccount({ userId, secretKey }) {
    const accId = userId
    const accExist = await this.checkAccount(accId)
    if (!accExist) {
      throw new Error(`Account ${accId} not exist`)
    }
    const keyPair = KeyPair.fromString(secretKey)
    await this.keyStore.setKey(config.networkId, accId, keyPair)
    const contract = new Contract(accExist, `contract-beta-dev.paras.testnet`, contractConfig)

    this.accountMap.set(accId, {
      publicKey: accExist.public_key,
      contract: contract
    })

    return true
  }

  async createAccount({ userId, secretKey }) {
    const newAccId = userId
    const accExist = await this.checkAccount(newAccId)
    if (accExist) {
      throw new Error(`Account ${newAccId} already exist`)
    }
    const keyPair = KeyPair.fromString(secretKey)
    const newAccount = await this.masterAccount.createAccount(newAccId, keyPair.publicKey.toString(), parseNearAmount('0.1'))
    await this.loadAccount({ userId, secretKey })
    return newAccount
  }

  async deployContract() {
    console.log('Setting up and deploying contract')
    const contractPath = join(process.cwd(), 'out/main.wasm')
    await this.contractAccount.deployContract(require('fs').readFileSync(contractPath))
    console.log(`Contract ${this.contractAccount.accountId} deployed`)
  }
}

module.exports = Near

// const init = async () => {
//   if (!process.env.ROOT_KEY) {
//     throw "ROOT_KEY not found"
//   }
//   const rootKey = JSON.parse(process.env.ROOT_KEY)
//   const x = nearAPI.KeyPair.fromString(rootKey.secret_key || rootKey.private_key)
//   console.log(x)
//   // const near = await connect({
//   //   deps: nearAPI.KeyPair.fromString(creatorKeyJson.secret_key || creatorKeyJson.private_key),
//   //   masterAccount: creatorKeyJson && creatorKeyJson.account_id,
//   //   nodeUrl: process.env.NODE_URL
//   // })
// }

// const registerAccount = async ({ email, username, privateKey }) => {
//   const masterAccountName = `reddit-token-contract-${Date.now()}`
//   const contractName = masterAccountName
//   const keyPair = KeyPair.from
//   await keyStore.setKey(config.networkId, masterAccountName, keyPair)
//   const masterAccount = await near.createAccount(masterAccountName, keyPair.publicKey.toString())
//   await masterAccount.deployContract(require('fs').readFileSync('./out/main.wasm'))

//   const masterAccountAcc = await near.account(masterAccountName)
//   const masterAccountContract = new Contract(masterAccountAcc, contractName, contractConfig)

//   ownerAccount = {
//     accountId: masterAccountName,
//     publicKey: '1' + keyPair.publicKey.toString().substring(8),
//     contract: masterAccountContract
//   }

//   accountsMap.set(ownerAccount.accountId, {
//     publicKey: ownerAccount.publicKey,
//     contract: ownerAccount.contract,
//     privateKey: keyPair.secretKey
//   })

//   await masterAccountContract.init({ totalSupply: '20000' })
//   const response = await masterAccountContract.balanceOf({ tokenOwner: ownerAccount.publicKey })
//   console.log("balance:" + JSON.stringify(response))

//   console.log("https://explorer.testnet.near.org/accounts/" + masterAccountName)

//   console.log('Creating accounts')
//   console.time('create accounts')
//   const accountPrefix = `nrb-user-${Date.now()}`
//   for (let i = 0; i < numAccounts; i++) {
//     const accountId = `${accountPrefix}-${i}`
//     const keyPair = KeyPair.fromRandom('ed25519')
//     await keyStore.setKey(config.networkId, accountId, keyPair)
//     await masterAccount.createAccount(accountId, keyPair.publicKey, parseNearAmount('0.1'))
//     const account = await near.account(accountId)
//     const contract = new Contract(account, contractName, contractConfig)

//     accountsMap.set(accountId, {
//       publicKey: '1' + keyPair.publicKey.toString().substring(8),
//       contract: contract,
//       privateKey: keyPair.secretKey
//     })

//     process.stdout.write('-')
//   }
// }

// let ownerAccount
// let accountsMap = new Map()

// async function loadAccounts(accounts) {
//   let contractName
//   let masterPublicKey

//   // keystore instance
//   let keyStore = new InMemoryKeyStore()

//   accounts.forEach(async acc => {
//     if (acc.user_type == 'owner') {
//       console.log('owner -> ' + JSON.stringify(acc))
//       contractName = acc.account_id
//       masterPublicKey = acc.public_key
//     }
//     // generate a new keypair from privateKey
//     const keypair = KeyPair.fromString("ed25519:" + acc.private_key)

//     // await keyStore.setKey(nearConfig.networkId, account.name, random);
//     await keyStore.setKey(config.networkId, acc.account_id, keypair)
//   })

//   if (!contractName) {
//     console.error('Invalid contractName')
//     return false
//   }

//   const near = await connect({ ...config, keyStore })

//   const masterAccountAcc = await near.account(contractName)
//   const masterAccountContract = new Contract(masterAccountAcc, contractName, contractConfig)

//   ownerAccount = {
//     accountId: contractName,
//     publicKey: masterPublicKey,
//     contract: masterAccountContract
//   }

//   accountsMap.set(ownerAccount.accountId, {
//     publicKey: ownerAccount.publicKey,
//     contract: ownerAccount.contract
//   })

//   const response = await masterAccountContract.totalSupply({})
//   console.log("balance:" + JSON.stringify(response))

//   console.log('Loading accounts')
//   accounts.forEach(async acc => {
//     if (acc.user_type != 'owner') {
//       const account = await near.account(acc.account_id)
//       const contract = new Contract(account, contractName, contractConfig)

//       accountsMap.set(acc.account_id, {
//         publicKey: acc.public_key,
//         contract: contract
//       })
//     }
//   })
//   console.log('Loading accounts done')
// }

// async function createAccounts(numAccounts) {
//   const keyStore = new MergeKeyStore([
//     new InMemoryKeyStore(),
//     new UnencryptedFileSystemKeyStore('./neardev')
//   ])
//   const near = await connect({ ...config, keyStore })

//   console.log('Setting up and deploying contract')
//   const masterAccountName = `reddit-token-contract-${Date.now()}`
//   const contractName = masterAccountName
//   const keyPair = KeyPair.fromRandom('ed25519')
//   await keyStore.setKey(config.networkId, masterAccountName, keyPair)
//   const masterAccount = await near.createAccount(masterAccountName, keyPair.publicKey.toString())
//   await masterAccount.deployContract(require('fs').readFileSync('./out/main.wasm'))

//   const masterAccountAcc = await near.account(masterAccountName)
//   const masterAccountContract = new Contract(masterAccountAcc, contractName, contractConfig)

//   ownerAccount = {
//     accountId: masterAccountName,
//     publicKey: '1' + keyPair.publicKey.toString().substring(8),
//     contract: masterAccountContract
//   }

//   accountsMap.set(ownerAccount.accountId, {
//     publicKey: ownerAccount.publicKey,
//     contract: ownerAccount.contract,
//     privateKey: keyPair.secretKey
//   })

//   await masterAccountContract.init({ totalSupply: '20000' })
//   const response = await masterAccountContract.balanceOf({ tokenOwner: ownerAccount.publicKey })
//   console.log("balance:" + JSON.stringify(response))

//   console.log("https://explorer.testnet.near.org/accounts/" + masterAccountName)

//   console.log('Creating accounts')
//   console.time('create accounts')
//   const accountPrefix = `nrb-user-${Date.now()}`
//   for (let i = 0; i < numAccounts; i++) {
//     const accountId = `${accountPrefix}-${i}`
//     const keyPair = KeyPair.fromRandom('ed25519')
//     await keyStore.setKey(config.networkId, accountId, keyPair)
//     await masterAccount.createAccount(accountId, keyPair.publicKey, parseNearAmount('0.1'))
//     const account = await near.account(accountId)
//     const contract = new Contract(account, contractName, contractConfig)

//     accountsMap.set(accountId, {
//       publicKey: '1' + keyPair.publicKey.toString().substring(8),
//       contract: contract,
//       privateKey: keyPair.secretKey
//     })

//     process.stdout.write('-')
//   }
//   console.timeEnd('create accounts')

//   console.log('Creating accounts done')

//   return accountsMap
// }

// async function callContractMethod(contract, methodName, args) {
//   const rawResult = await contract.account.functionCall(contract.contractId, methodName, args)
//   console.log("callContractMethod[" + methodName + "] tx: " + JSON.stringify(rawResult.transaction.hash))

//   return rawResult.transaction.hash
// }

// async function getBalances() {
//   console.log('get balances')
//   for (const [accountId, account] of accountsMap.entries()) {
//     try {
//       const response = await account.contract.balanceOf({ tokenOwner: account.publicKey })
//       console.log("balance:" + JSON.stringify(response))
//     } catch (e) {
//       console.error(e)
//     }
//   }
// }

// // return int
// async function balanceOf(accountId) {
//   const account = accountsMap.get(accountId)
//   let response
//   try {
//     response = await account.contract.balanceOf({ tokenOwner: account.publicKey })
//     console.log("balance:" + JSON.stringify(response))
//   } catch (e) {
//     console.error(e)
//   }
//   return response
// }

// // return string
// async function totalSupply() {
//   let response
//   try {
//     response = await ownerAccount.contract.totalSupply({})
//     console.log("totalSupply:" + JSON.stringify(response))
//   } catch (e) {
//     console.error(e)
//   }
//   return response
// }

// // return true or false
// async function mint(accountId, value) {
//   const account = accountsMap.get(accountId)
//   let tx
//   try {
//     tx = await callContractMethod(account.contract, 'mint', { tokens: value })
//     console.log("mint:" + JSON.stringify(tx))
//   } catch (e) {
//     console.error(e)
//   }
//   return tx
// }

// // return true or false
// async function burn(accountId, value) {
//   const account = accountsMap.get(accountId)
//   let tx
//   try {
//     tx = await callContractMethod(account.contract, 'burn', { tokens: value })
//     console.log("burn:" + JSON.stringify(tx))
//   } catch (e) {
//     console.error(e)
//   }
//   return tx
// }

// // return true or false
// async function transfer(fromAccountId, toAccountId, value) {
//   const fromAccount = accountsMap.get(fromAccountId)
//   const toAccount = accountsMap.get(toAccountId)
//   let tx
//   try {
//     tx = await callContractMethod(fromAccount.contract, 'transfer', { to: toAccount.publicKey, tokens: value })
//     console.log("transfer:" + JSON.stringify(tx))
//   } catch (e) {
//     console.error(e)
//   }
//   return tx
// }

// // return true or false
// async function addModerator(accountId) {
//   const account = accountsMap.get(accountId)
//   let tx
//   try {
//     tx = await callContractMethod(ownerAccount.contract, 'addModerator', { moderator: account.publicKey })
//     console.log("addModerator:" + JSON.stringify(tx))
//   } catch (e) {
//     console.error(e)
//   }
//   return tx
// }

// // return true or false
// async function removeModerator(accountId) {
//   const account = accountsMap.get(accountId)
//   let tx
//   try {
//     tx = await callContractMethod(ownerAccount.contract, 'removeModerator', { moderator: account.publicKey })
//     console.log("removeModerator:" + JSON.stringify(tx))
//   } catch (e) {
//     console.error(e)
//   }
//   return tx
// }

// var args = process.argv.slice(2)
// if (args[0] === 'test') {
//   const test = async _ => {
//     await createAccounts(4).catch(console.error)

//     const accounts = Array.from(accountsMap)
//     console.log(JSON.stringify(accounts[0][0]))

//     //await getBalances();
//     await balanceOf(accounts[2][0])
//     await totalSupply()
//     await addModerator(accounts[2][0])
//     await mint(accounts[2][0], '1000')
//     await balanceOf(accounts[2][0])
//     await balanceOf(accounts[0][0])
//     await totalSupply()
//     await transfer(accounts[2][0], accounts[3][0], '100')
//     await removeModerator(accounts[2][0])
//     await burn(accounts[3][0], '50')
//     await getBalances()
//   }

//   test()
// }

// module.exports = {
//   createAccounts,
//   loadAccounts,
//   getBalances,
//   balanceOf,
//   totalSupply,
//   mint,
//   burn,
//   transfer,
//   addModerator,
//   removeModerator
// }
'''
'''--- State.js ---
const nearAPI = require('near-api-js')

const config = {
  nodeUrl: 'https://rpc.testnet.near.org',
  deps: {
    keyStore: new nearAPI.keyStores.UnencryptedFileSystemKeyStore()
  }
}

class State {
  constructor(storage) {
    this.data = {}
    this.storage = storage
    this.contractName = null
    this.__init__ = false
  }

  async start() {
    await this.fetchData()
    console.log('done wait 3sec')
    // setTimeout(() => {
    //   this.start()
    // }, 3000)
  }

  async init() {
    if (!process.env.CONTRACT_NAME) {
      throw 'CONTRACT_NAME is not defined on env'
    }
    this.contractName = process.env.CONTRACT_NAME
    this.__init__ = true
    this.near = await nearAPI.connect(config)
    this.account = await this.near.account(process.env.CONTRACT_NAME)
    this.start()
  }

  async processEvent(type, collection, data) {
    if (type === 'create') {
      // notify user about new/update comment on their post
      if (collection === 'comment') {
        if (data.postId) {
          console.log('add notification')
          const post = await this.storage.db.collection('post').findOne({
            id: data.postId
          })
          const newNotification = {
            link: `${process.env.FRONTEND_URL}/post/${data.postId}/comment`,
            message: `${data.owner} commented on your post`,
            userId: post.owner,
            createdAt: new Date().getTime().toString()
          }
          await this.storage.db.collection('notification').insertOne(newNotification)

          const splitRegex = /(@\[@.+?\]\(.+?\))/
          const captureRegex = /@\[@(.+)?\]\(.+?\)/
          const trim = data.body.toString().replace(/(\r\n|\r|\n){2,}/g, '$1\n')
          const bodyBlocks = trim.split(splitRegex)
          // do not send notification if mentioned user is:
          // post owner
          // already mentioned
          const mentionedUsers = bodyBlocks.map(block => {
            const match = block.match(captureRegex)
            if (match) {
              return match[1]
            }
            return null
          }).filter(userId => {
            if (userId === post.owner) {
              return null
            }
            return userId
          })
          const distinctUsers = [...new Set(mentionedUsers)]
          // create new notification
          for await (const user of distinctUsers) {
            const newNotification = {
              link: `${process.env.FRONTEND_URL}/post/${data.postId}/comment`,
              message: `${data.owner} mentioned you in a comment`,
              userId: user,
              createdAt: new Date().getTime().toString()
            }
            await this.storage.db.collection('notification').insertOne(newNotification)
          }
        }
      }
    }
  }

  async handleEvent(event) {
    // id, msg, params
    const [collection, type] = event.msg.split('_')
    const collectionCapitalize = collection.charAt(0).toUpperCase() + collection.slice(1)
    const methodName = `get${collectionCapitalize}ById`
    const args = {
      id: event.params
    }
    const data = await this.account.viewFunction(this.contractName, methodName, args)
    console.log(data)
    if (data) {
      this.processEvent(type, collection, data)
      if (type === 'create') {
        await this.storage.db.collection(collection).insertOne(data)
      }
      else if (type === 'update') {
        await this.storage.db.collection(collection).findOneAndUpdate({
          id: event.params
        }, {
          $set: data
        }, {
          upsert: true
        })
      }
    }
    if (type === 'delete') {
      await this.storage.db.collection(collection).deleteOne({
        id: event.params
      })
    }
    await this.storage.kv.findOneAndUpdate({
      key: 'latestEvent',
    }, {
      $set: {
        value: parseInt(event.id)
      }
    }, {
      upsert: true
    })
  }

  async fetchData() {
    try {
      console.log('check new data')
      const latestEvent = await this.storage.kv.findOne({
        key: 'latestEvent'
      })
      const latestLen = await this.account.viewFunction(this.contractName, 'getEventLength')
      const currentLen = latestEvent ? latestEvent.value : 0
      if (currentLen === 0) {
        return
      }
      if (latestEvent === null) {
        console.log('fetch new data')
        const newEvents = await this.account.viewFunction(this.contractName, 'getEvents', {
          start: 0
        })
        if (newEvents.length > 0) {
          for await (const event of newEvents) {
            await this.handleEvent(event)
          }
        }
      }
      else if (latestLen - 1 > currentLen) {
        console.log('fetch new data')
        const newEvents = await this.account.viewFunction(this.contractName, 'getEvents', {
          start: currentLen + 1
        })
        if (newEvents.length > 0) {
          for await (const event of newEvents) {
            await this.handleEvent(event)
          }
        }
        if (latestLen - 1 > currentLen + newEvents.length) {
          await this.fetchData()
        }
      }
    } catch (err) {
      console.log(err)
    }
  }

  get({
    collection,
    query = [],
    sort = 'desc',
    skip = 0,
    limit = 5,
    embed = []
  }) {
    return new Promise((resolve) => {
      let result = []
      let postList = this.data[collection]
      if (!postList) {
        resolve([])
      }
      if (sort === 'desc') {
        postList = this.data[collection].sort((a, b) => b.createdAt - a.createdAt)
      }
      else {
        postList = this.data[collection].sort((a, b) => a.createdAt - b.createdAt)
      }
      for (let i = 0; i < postList.length; i++) {
        const post = postList[i]
        if (query.length > 0) {
          const matches = []
          for (let j = 0; j < query.length; j++) {
            const [key, special] = query[j].key.split('_')
            const value = query[j].value.split(',')
            if (special === 'like' && post[key].toLowerCase().indexOf(value[0].toLowerCase()) > -1) {
              matches.push(true)
            }
            else if (value.includes(post[key])) {
              matches.push(true)
            }
          }
          if (matches.length === query.length && matches.every(Boolean)) {
            for (let k = 0; k < embed.length; k++) {
              const { col, key, targetCol, targetKey } = embed[k]
              post[col] = this.data[targetCol].find(d => d[targetKey] === post[key])
            }
            result.push(post)
          }
        }
        else {
          for (let k = 0; k < embed.length; k++) {
            const { col, key, targetCol, targetKey } = embed[k]
            post[col] = this.data[targetCol].find(d => d[targetKey] === post[key])
          }
          result.push(post)
        }
      }
      if (skip) {
        result.splice(0, skip)
      }

      if (limit) {
        result = result.slice(0, limit)
      }
      resolve(result)
    })
  }
}

module.exports = State
'''
'''--- Storage.js ---
const MongoClient = require('mongodb').MongoClient
var qpm = require('query-params-mongo')
var processQuery = qpm()

class Storage {
  constructor() {
    const uri = `${process.env.MONGO_URL}?retryWrites=true&w=majority`
    this.client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true })
    this.ready = null
  }

  async init() {
    try {
      await this.client.connect()
      this.db = this.client.db(process.env.DB_NAME)
      this.ready = true
      this.kv = this.db.collection('kv')
      this.feeds = this.db.collection('feeds')
      this.verifications = this.db.collection('verifications')
    } catch (err) {
      console.log(err)
    }
  }

  async get(collection, q, embed) {
    var query = processQuery(q)
    const data = await this.db.collection(collection).find(query.filter, {
      projection: {
        _id: 0
      }
    })
      .sort(query.sort)
      .skip(query.skip)
      .limit(query.limit)

    const arr = data.toArray()
    const iter = (await arr).map(x => x)
    const result = []
    for await (const d of iter) {
      if (embed &&  embed.length > 0) {
        for (const e of embed) {
          d[e.col] = await this.db.collection(e.targetCol).findOne({
            [e.targetKey]: d[e.key]
          })
        }
      }
      result.push(d)
    }
    return result
  }
}

module.exports = Storage
'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json", 
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
import { Memento, Img, Post, Content } from '../model'
import { createPost, createMemento, init, balanceOf, piecePost } from '../main'
import { u128 } from 'near-sdk-as'

var memento: Memento

describe('Memento ', () => {
  beforeEach(() => {
    const name = 'Hello World'
    const category = 'art'
    const img = new Img()
    const desc = 'Memento test'
    const type = 'personal'
    memento = createMemento(name, category, img, desc, type)

    init('bob')

    for (let i = 0; i < 5; i++) {
      const contentList: Content[] = []
      const mementoId = memento.id
      createPost(contentList, mementoId)
    }
  })
  afterEach(() => {

  })

  it('should create published post', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    expect(p instanceof Post).toBeTruthy()
  })

  it('should get balance', () => {
    const balance = balanceOf('bob')
    log(balance.toString())
  })

  it('should piecePost', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    if (p) {
      piecePost(p.id, "10")
    }
  })
})

'''
'''--- assembly/__tests__/memento.spec.ts ---
import { createMemento, updateMemento } from '../main'
import { Memento, mementoCollection, Img } from '../model'

describe('Memento ', () => {
  afterEach( () => {
    mementoCollection.delete('list')
  })

  it('should create memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newM = mementoCollection.getSome(m.id)
    expect(m.id).toBe(newM.id)
  })

  it('should update memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newDesc = 'Hello world'
    updateMemento(m.id, m.img, newDesc)

    const newM = mementoCollection.get(m.id)
    if(newM) {
      expect(newM.desc).toBe(newDesc)  
    }
  })

  // itThrows('should throw error Memento type', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'random'
  //   createMemento(name, desc, descRaw, type)
  // })

  // it('should get all memento list', () => {
  //   const len = 10
  //   for (let i = 0; i < len; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList()
  //   expect(result.length).toBe(len)
  // })

  // it('should get memento list by name', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 5; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name:=Hello World'])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list by name like', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name_like:=worl'])
  //   expect(result.length).toBe(6)
  // })

  // it('should get memento list by owner', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['owner:='.concat(context.sender)])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list with sort by desc', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 10
  //   })
  //   expect(result[0].createdAt).toBeGreaterThanOrEqual(result[1].createdAt)
  // })

  // it('should get memento list with limit', () => {
  //   for (let i = 0; i < 10; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 3
  //   })
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   const m = createMemento(name, desc, descRaw, type)
  //   const result = getMementoById(m.id)
  //   if(result) {
  //     expect(result.name).toBe(m.name)
  //   }
  //   else {
  //     expect(result).toBe(null)
  //   }
  // })

  // it('should delete memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   createMemento(name, desc, descRaw, type)

  //   const list = mementoCollection.get('list')
  //   if(list) {
  //     const id = list.data[0].id
  //     deleteMementoById(id)
  //     const mementoList = getMementoList()
  //     expect(mementoList.length).toBe(0)
  //   }
  // })
})

'''
'''--- assembly/__tests__/user.spec.ts ---
// import { createUser, getUserList, getUserById, getUserByUsername, updateUserById, getPostListByUserFollowing } from '../main'
// import { Img, User, userCollection } from '../model'

// let newUser: User = <User>{}

// describe('User ', () => {
//   beforeEach(() => {
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     newUser = createUser(imgAvatar, bio, bioRaw)
//   })
//   afterEach(() => {
//     userCollection.delete('list')
//   })

//   it('should create new user', () => {
//     userCollection.delete('list')
    
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     const newUser = createUser(imgAvatar, bio, bioRaw)
//     expect(newUser instanceof User).toBeTruthy()
//     const userList = userCollection.get('list')
//     if(userList) {
//       expect(userList.data.length).toBe(1)
//     }
//   })

//   it('should get all users', () => {
//     const userList = getUserList()
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by id', () => {
//     const userList = getUserList(['id:='.concat(newUser.id)])
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by username', () => {
//     const userList = getUserList(['username:=bo'])
//     expect(userList.length).toBe(0)
//   })

//   it('should get users by username_like', () => {
//     const userList = getUserList(['username_like:=bo'])
//     expect(userList.length).toBe(1)
//   })

//   it('should get user by id', () => {
//     const user = getUserById(newUser.id)
//     if(user) expect(user.id).toBe(newUser.id)
//   })

//   it('should get user by username', () => {
//     const user = getUserByUsername(newUser.username)
//     if(user) expect(user.username).toBe(newUser.username)
//   })

//   it('should update user', () => {
//     const newImgAvatar = new Img()
//     newImgAvatar.url = 'new avatar'
//     newImgAvatar.type = 'ipfs'
//     const newBio = 'new bio'
//     const newBioRaw = 'new bio'
//     const nUser = updateUserById(newUser.id, newImgAvatar, newBio, newBioRaw)
//     if(nUser) {
//       expect(nUser.imgAvatar.url).toBe(newImgAvatar.url)
//       expect(nUser.bio).toBe(newBio)
//       expect(nUser.bioRaw).toBe(newBioRaw)
//     }
//   })

//   it('should get postlist by user following', () => {
//     const postList = getPostListByUserFollowing('bob')
//     expect(postList.length).toBe(0)
//   })
// })

'''
'''--- assembly/main.ts ---
import { context, storage, u128 } from 'near-sdk-as'
import { Memento, Img, mementoCollection, User, userCollection, Post, Content, postCollection, Comment, commentCollection, balances, approves, transactionCollection, Transaction, Event, events } from './model'

const NAME: string = 'Paras Action Coin'
const SYMBOL: string = 'PAC'
const DECIMALS: u8 = 18
const TOTAL_SUPPLY: u128 = u128.fromString("230000000000000000000000000")

export function name(): string {
	return NAME
}

export function symbol(): string {
	return SYMBOL
}

export function decimals(): u8 {
	return DECIMALS
}

export function totalSupply(): u128 {
	return TOTAL_SUPPLY
}

export function init(initialOwner: string): void {
	assert(storage.get<string>("init") == null, "Already initialized token supply");
	balances.set(initialOwner, TOTAL_SUPPLY);
	const tx = new Transaction("0x", initialOwner, TOTAL_SUPPLY, 'Initial Supply')
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	storage.set("init", "done");
}

export function balanceOf(tokenOwner: string): u128 {
	if (!balances.contains(tokenOwner)) {
		return u128.fromI32(0);
	}
	const result = balances.getSome(tokenOwner);
	return result;
}

export function allowance(tokenOwner: string, spender: string): u128 {
	const key = tokenOwner + ":" + spender;
	if (!approves.contains(key)) {
		return u128.fromI32(0);
	}
	return approves.getSome(key);
}

export function transfer(to: string, tokens: u128, msg: string = ''): boolean {
	const fromAmount = getBalance(context.sender);
	assert(fromAmount >= tokens, "not enough tokens on account");
	assert(getBalance(to) <= u128.add(getBalance(to), tokens), "overflow at the receiver side");
	balances.set(context.sender, u128.sub(fromAmount, tokens));
	balances.set(to, u128.add(getBalance(to), tokens));
	const tx = new Transaction(context.sender, to, tokens, msg)
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	return true;
}

export function approve(spender: string, tokens: u128): boolean {
	approves.set(context.sender + ":" + spender, tokens);
	return true;
}

export function transferFrom(from: string, to: string, tokens: u128, msg: string = ''): boolean {
	const fromAmount = getBalance(from);
	assert(fromAmount >= tokens, "not enough tokens on account");
	const approvedAmount = allowance(from, to);
	assert(tokens <= approvedAmount, "not enough tokens approved to transfer");
	assert(getBalance(to) <= u128.add(getBalance(to), tokens), "overflow at the receiver side");
	balances.set(from, u128.sub(fromAmount, tokens));
	balances.set(to, u128.add(getBalance(to), tokens));
	const tx = new Transaction(from, to, tokens, msg)
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	return true;
}

function getBalance(owner: string): u128 {
	return balances.contains(owner) ? balances.getSome(owner) : u128.fromI32(0);
}

function _percent(value: u128, percent: u32): u128 {
	return u128.div(u128.mul(value, u128.from(percent)), u128.from(100))
}

export function piecePost(
	postId: string,
	value: string
): u128 {
	const tokens = u128.fromString(value)
	const senderBalance = getBalance(context.sender)
	assert(senderBalance >= tokens, 'not enough tokens on account')
	const post = getPostById(postId)
	if (!!post && tokens > u128.from(0)) {
		const memento = getMementoById(post.mementoId)
		const originalPost = getPostById(post.originalId)
		let originalMemento: Memento | null = null

		let postOwnerQuota = 100
		let postMementoQuota = 0
		let postOriginalOwnerQuota = 0
		let postOriginalMementoQuota = 0
		if (memento) {
			postOwnerQuota = 90
			postMementoQuota = 10
			if (post.id != post.originalId) {
				if (originalPost) {
					postOwnerQuota = 5
					postMementoQuota = 5
					postOriginalOwnerQuota = 90
					originalMemento = getMementoById(originalPost.id)
					if (originalMemento) {
						postOriginalOwnerQuota = 80
						postOriginalMementoQuota = 10
					}
				}
			}
		}
		const forPostOwner = _percent(tokens, postOwnerQuota)
		if (forPostOwner > u128.from(0)) {
			// log(forPostOwner)
			transfer(post.owner, forPostOwner, '[Piece] For Post Owner')
		}
		const forMementoOwner = _percent(tokens, postMementoQuota)
		if (!!memento && forMementoOwner > u128.from(0)) {
			// log(forMementoOwner)
			transfer(memento.owner, forMementoOwner, '[Piece] For Memento Owner')
		}
		const forOriginalOwner = _percent(tokens, postOriginalOwnerQuota)
		if (!!originalPost && forOriginalOwner > u128.from(0)) {
			// log(forOriginalOwner)
			transfer(originalPost.owner, forOriginalOwner, '[Piece] For Original Post Owner')
		}
		const forOriginalMemento = _percent(tokens, postOriginalMementoQuota)
		if (!!originalPost && !!originalMemento && forOriginalMemento > u128.from(0)) {
			// log(forOriginalMemento)
			transfer(originalMemento.owner, forOriginalMemento, '[Piece] For Original Memento Owner')
		}
	}
	const latestBalance = getBalance(context.sender)
	return latestBalance
}

export function createMemento(
	name: string,
	category: string,
	img: Img,
	desc: string,
	type: string
): Memento {
	assert(
		type == 'public' || type == 'personal',
		'Memento type must be public or personal'
	)
	const memento = new Memento(name, category, img, desc, type)

	// check if memento id already taken
	const exist = getMementoById(memento.id)
	assert(
		!exist,
		'Memento id already taken'
	)

	mementoCollection.set(memento.id, memento)
	memento.user = getUserById(memento.owner)

	const ev = new Event('memento_create', memento.id)
	events.push(ev)

	return memento
}

export function getMementoById(
	id: string
): Memento | null {
	const memento = mementoCollection.get(id)
	if (memento) {
		return memento
	}
	return null
}

export function updateMemento(
	id: string,
	img: Img,
	desc: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be deleted by owner'
		)
		memento.img = img
		memento.desc = desc

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function archiveMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be deleted by owner'
		)
		memento.isArchive = true

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function unarchiveMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be deleted by owner'
		)
		memento.isArchive = false

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function deleteMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be deleted by owner'
		)

		mementoCollection.delete(memento.id)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_delete', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function createPost(
	contentList: Content[],
	mementoId: string
): Post | null {
	const memento = getMementoById(mementoId)
	if (memento) {
		assert(
			!memento.isArchive,
			'Cannot write to archived Memento'
		)
		assert(
			memento.type == 'public' || memento.type == 'personal' && memento.owner == context.sender,
			'Sender does not have access to write to this memento'
		)
		const post = new Post(contentList, mementoId, null)
	
		postCollection.set(post.id, post)
		post.memento = memento
		post.user = getUserById(post.owner)
	
		const ev = new Event('post_create', post.id)
		events.push(ev)
	
		return post
	}
	return null
}

export function transmitPost(
	id: string,
	mementoId: string
): Post | null {
	const post = getPostById(id)
	if (post) {
		const newPost = new Post(post.contentList, mementoId, post.originalId)

		postCollection.set(newPost.id, newPost)
		newPost.memento = getMementoById(newPost.mementoId)
		newPost.user = getUserById(newPost.owner)

		const ev = new Event('post_create', newPost.id)
		events.push(ev)

		return newPost
	}
	return null
}

export function editPost(
	id: string,
	contentList: Content[],
	mementoId: string
): Post | null {
	const post = getPostById(id)
	const memento = getMementoById(mementoId)
	if (!!post && !!memento) {
		assert(
			post.owner == context.sender,
			'Post can only be edited by owner'
		)
		post.contentList = contentList
		post.mementoId = mementoId

		postCollection.set(post.id, post)
		post.memento = memento
		post.user = getUserById(post.owner)

		const ev = new Event('post_update', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function redactPost(
	id: string
): Post | null {
	const post = getPostById(id)
	if (post) {
		const memento = getMementoById(post.mementoId)
		assert(
			!!memento && memento.owner == context.sender,
			'Post can only be redacted by memento owner'
		)

		post.mementoId = ''
		postCollection.set(post.id, post)
		post.user = getUserById(post.owner)

		const ev = new Event('post_update', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function getPostById(
	id: string
): Post | null {
	const post = postCollection.get(id)
	if (post) {
		return post
	}
	return null
}

export function deletePost(
	id: string
): Post | null {
	const post = getPostById(id)
	if (post) {
		assert(
			post.owner == context.sender,
			'Post can only be deleted by post owner or memento owner'
		)

		postCollection.delete(post.id)

		const ev = new Event('post_delete', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function getUserById(id: string): User | null {
	const user = userCollection.get(id)
	if (user) {
		return user
	}
	return null
}

export function createUser(imgAvatar: Img, bio: string): User {
	const userExist = getUserById(context.sender)
	assert(
		!userExist,
		'User already exist'
	)

	const newUser = new User(imgAvatar, bio)

	userCollection.set(newUser.id, newUser)

	const ev = new Event('user_create', newUser.id)
	events.push(ev)

	return newUser
}

export function updateUser(
	imgAvatar: Img,
	bio: string
): User | null {
	const user = getUserById(context.sender)
	if (user) {
		user.imgAvatar = imgAvatar
		user.bio = bio

		userCollection.set(context.sender, user)

		const ev = new Event('user_update', user.id)
		events.push(ev)

		return user
	}
	return null
}

export function createComment(
	postId: string,
	body: string
): Comment {
	const c = new Comment(postId, body)

	commentCollection.set(c.id, c)

	const ev = new Event('comment_create', c.id)
	events.push(ev)

	return c
}

export function getCommentById(id: string): Comment | null {
	const comment = commentCollection.get(id)
	if (comment) {
		return comment
	}
	return null
}

export function deleteComment(
	id: string
): Comment | null {
	const comment = getCommentById(id)
	if (comment) {
		const post = getPostById(comment.postId)
		assert(
			comment.owner == context.sender || !!post && post.owner == context.sender,
			'Comment can only be deleted by comment owner or post owner'
		)

		commentCollection.delete(comment.id)

		const ev = new Event('comment_delete', comment.id)
		events.push(ev)

		return comment
	}
	return null
}

export function getTransactionById(
	id: string
): Transaction | null {
	const tx = transactionCollection.get(id)
	if (tx) {
		return tx
	}
	return null
}

export function getEventLength(): u64 {
	return events.length
}

export function getEvents(start: i32): Event[] {
	const maxLen = events.length
	assert(
		maxLen > start,
		"Start index is more than current length"
	)
	// only get at most 10 new events
	const diff = min(maxLen - start, 10)
	const result: Event[] = []
	for (let i = start; i < (start + diff); i++) {
		const ev = events[i]
		result.push(ev)
	}
	return result
}
'''
'''--- assembly/model.ts ---
import { context, PersistentMap, PersistentVector, u128 } from 'near-sdk-as'
import { generateId } from './utils'

@nearBindgen
export class Img {
  url: string
  type: string
}

@nearBindgen
export class Link {
  img: Img
  title: string
  desc: string
  url: string
}

@nearBindgen
export class Content {
  type: string
  body: string
}

@nearBindgen
export class Memento {
  id: string
  name: string
  category: string
  img: Img
  desc: string
  type: string
  owner: string
  isArchive: bool
  createdAt: u64
  user: User | null

  constructor(name: string, category: string, img: Img, desc: string, type: string) {
    const tail = type == 'personal' ? context.sender.split('.')[0] : category

    this.id = name.concat('.').concat(tail)
    this.name = name
    this.category = category
    this.img = img
    this.desc = desc
    this.type = type
    this.owner = context.sender
    this.isArchive = false
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Post {
  id: string
  originalId: string
  contentList: Content[]
  owner: string
  mementoId: string
  createdAt: u64
  user: User | null
  memento: Memento | null

  constructor(contentList: Content[], mementoId: string, originalId: string | null) {
    const id = generateId()

    this.id = id
    this.originalId = originalId ? originalId : id
    this.contentList = contentList
    this.mementoId = mementoId
    this.owner = context.sender
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Comment {
  id: string
  postId: string
  body: string
  owner: string
  createdAt: u64
  user: User | null

  constructor(postId: string, body: string) {
    this.id = generateId()
    this.postId = postId
    this.body = body
    this.owner = context.sender
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class User {
  id: string
  imgAvatar: Img
  bio: string
  createdAt: u64

  constructor(imgAvatar: Img, bio: string) {
    this.id = context.sender
    this.imgAvatar = imgAvatar
    this.bio = bio
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Transaction {
  id: string
  from: string
  to: string
  value: u128
  msg: string
  createdAt: u64

  constructor(from: string, to: string, value: u128, msg: string) {
    this.id = generateId()
    this.from = from
    this.to = to
    this.value = value
    this.msg = msg
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Event {
  id: string
  msg: string
  params: string
  createdAt: u64

  constructor(msg: string, params: string) {
    this.id = events.length.toString()
    this.msg = msg
    this.params = params
    this.createdAt = context.blockTimestamp
  }
}

export const mementoCollection = new PersistentMap<string, Memento>('memento')
export const postCollection = new PersistentMap<string, Post>('post')
export const userCollection = new PersistentMap<string, User>('user')
export const commentCollection = new PersistentMap<string, Comment>('comment')
export const transactionCollection = new PersistentMap<string, Transaction>('pac:tx')
export const balances = new PersistentMap<string, u128>("pac:b")
export const approves = new PersistentMap<string, u128>("pac:a")
export const events = new PersistentVector<Event>('event')
'''
'''--- assembly/utils.ts ---
import { math, base58 } from 'near-sdk-as'

export function generateId(): string {
	const buff = math.randomBuffer(8)

	var randomId = base58.encode(buff)
	return randomId.replaceAll('/', '')
}
'''
'''--- config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'paras-alpha.testnet';

function getConfig(env) {
  if (process.env && process.env.CONTRACT_ENV) {
    env = process.env.CONTRACT_ENV
  }
  switch (env) {

    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.mainnet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
      };
    case 'development':
    case 'testnet':
      return {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
      };
    case 'devnet':
      return {
        networkId: 'devnet',
        nodeUrl: 'https://rpc.devnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.devnet.near.org',
        helperUrl: 'https://helper.devnet.near.org',
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME,
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;

'''
'''--- controllers/Auth.js ---
const nearSeedPhrase = require('near-seed-phrase')
const Cryptr = require('cryptr')

class Auth {
  constructor(state, storage, mail, near) {
    this.state = state
    this.storage = storage
    this.mail = mail
    this.near = near
    this.cryptr = new Cryptr(process.env.TOKEN_SECRET)
  }

  async register({ email, username }) {
    const accId = `${username}.${this.near.masterAccount.accountId}`
    const accExist = await this.near.checkAccount(accId)
    if (accExist) {
      throw new Error('Username already taken')
    }

    const credExist = await this.storage.db.collection('credential').findOne({
      email: email
    })
    if (credExist) {
      throw new Error('Email already taken')
    }

    const verifyPin = Math.floor(100000 + Math.random() * 900000)
    const MS_15M = 900000

    const doc = {
      token: `${email}_${verifyPin}`,
      userId: accId,
      expiredAt: new Date().getTime() + MS_15M,
      createdAt: new Date().getTime(),
      updatedAt: new Date().getTime()
    }
    await this.storage.db.collection('token').insertOne(doc)

    // send email
    try {
      this.mail.send({
        from: `"Paras Team" <hello@paras.id>`,
        to: email,
        subject: `[Paras] Email Verification`,
        text: `Your verification code is ${verifyPin} and available for 15 minutes`
      })
    } catch (err) {
      console.log(err)
    }

    return true
  }

  async verifyRegister({ email, pin }) {
    const authExist = await this.storage.db.collection('token').findOne({
      token: `${email}_${pin}`
    })
    if (!authExist) {
      throw new Error('Invalid PIN/Email')
    }
    const currentTime = new Date().getTime()
    if (currentTime > authExist.expiredAt) {
      throw new Error('Expired PIN')
    }

    const { seedPhrase, secretKey, publicKey } = nearSeedPhrase.generateSeedPhrase()
    console.log(seedPhrase, secretKey)

    try {
      await this.near.createAccount({
        userId: authExist.userId,
        secretKey: secretKey
      })

      await this.storage.db.collection('credential').insertOne({
        userId: authExist.userId,
        publicKey: publicKey,
        email: email,
        createdAt: new Date().getTime(),
        updatedAt: new Date().getTime()
      })

      this.mail.send({
        from: `"Paras Team" <hello@paras.id>`,
        to: email,
        subject: `[Paras] Seed Password Recovery`,
        text: `Your seed password is ${seedPhrase}`
      })

      const token = await this.login({
        userId: authExist.userId,
        seed: seedPhrase
      })

      return {
        seedPassword: seedPhrase,
        token: token
      }
    } catch (err) {
      console.log(err)
      return err
    }
  }

  async login({ userId, seed }) {
    const { secretKey, publicKey } = nearSeedPhrase.parseSeedPhrase(seed)

    const accExist = await this.storage.db.collection('credential').findOne({
      userId: userId,
      publicKey: publicKey,
    })

    if (!accExist) {
      throw new Error('Invalid username/seed')
    }
    await this.near.loadAccount({
      userId,
      secretKey
    })
    const token = this.cryptr.encrypt(secretKey)

    return token
  }

  async verifyToken({ token }) {
    try {
      this.cryptr.decrypt(token)
      return true
    } catch (err) {
      throw new Error('Invalid token')
    }
  }
}

module.exports = Auth
'''
'''--- controllers/Balance.js ---
class Balance {
  constructor(state, storage) {
    this.state = state
    this.storage = storage
  }

  async get(id) {
    const balance = await this.state.account.viewFunction(this.state.contractName, 'balanceOf', {
      tokenOwner: id
    })
    return balance
  }
}

module.exports = Balance
'''
'''--- controllers/Explore.js ---
const Fuse = require('fuse.js')

class Explore {
  constructor(state, storage) {
    this.state = state
    this.storage = storage
  }

  async getPost() {
    const embed = [{
      col: 'memento',
      key: 'mementoId',
      targetCol: 'memento',
      targetKey: 'id'
    }, {
      col: 'user',
      key: 'owner',
      targetCol: 'user',
      targetKey: 'id'
    }]

    const minSample = 0
    const maxSample = 10
    const rng = Math.floor(Math.random() * (maxSample - minSample) + minSample)
    const data = await this.storage.db.collection('post').aggregate([{ $sample: { size: maxSample } }])

    const arr = await data.toArray()
    const selected = [arr[rng]]
    const iter = selected.map(x => x)
    const result = []
    for await (const d of iter) {
      if (embed && embed.length > 0) {
        for (const e of embed) {
          d[e.col] = await this.storage.db.collection(e.targetCol).findOne({
            [e.targetKey]: d[e.key]
          })
        }
      }
      result.push(d)
    }
    return result
  }

  async search(q) {
    const userList = await this.storage.get('user', q)
    const mementoList = await this.storage.get('memento', q)
    const combineList = userList.concat(mementoList)

    const options = {
      includeScore: true,
      sortFn: (a, b) => b.score - a.score,
      keys: ['id']
    }

    const fuse = new Fuse(combineList, options)
    const result = fuse.search(q.id__re).slice(0, 10)
    const final = []
    for (const data of result) {
      const postQuery = {
        __limit: 3,
        __sort: '-createdAt'
      }
      if (data.item.imgAvatar) {
        postQuery.owner = data.item.id
      }
      else {
        postQuery.mementoId = data.item.id
      }
      const postList = await this.storage.get('post', postQuery, [{
        col: 'memento',
        key: 'mementoId',
        targetCol: 'memento',
        targetKey: 'id'
      }, {
        col: 'user',
        key: 'owner',
        targetCol: 'user',
        targetKey: 'id'
      }])

      final.push({
        id: data.item.id,
        type: data.item.imgAvatar ? 'user' : 'memento',
        img: data.item.img || data.item.imgAvatar,
        postList: postList
      })
    }

    return final
  }
}

module.exports = Explore
'''
'''--- controllers/Feed.js ---
class Feed {
  constructor(state, storage) {
    this.state = state
    this.storage = storage
  }

  async get(id, skip = 0, limit = 5) {
    const followingList = await this.getFollowing(id, 0, 0, true)
    followingList.push({
      targetId: id,
      targetType: 'user'
    })
    const idList = followingList.map(following => following.targetId)
    const embed = [{
      col: 'memento',
      key: 'mementoId',
      targetCol: 'memento',
      targetKey: 'id'
    }, {
      col: 'user',
      key: 'owner',
      targetCol: 'user',
      targetKey: 'id'
    }]
    const data = await this.storage.db.collection('post').find({
      $or: [
        {
          owner: {
            $in: idList
          }
        },
        {
          mementoId: {
            $in: idList
          }
        }
      ]
    }, {
      projection: {
        _id: 0
      }
    })
      .sort({
        createdAt: -1
      })
      .skip(parseInt(skip))
      .limit(parseInt(limit))

    const arr = data.toArray()
    const iter = (await arr).map(x => x)
    const result = []
    for await (const d of iter) {
      if (embed && embed.length > 0) {
        for (const e of embed) {
          d[e.col] = await this.storage.db.collection(e.targetCol).findOne({
            [e.targetKey]: d[e.key]
          })
        }
      }
      result.push(d)
    }
    return result
  }

  async getFollowing(id, skip = 0, limit = 10, all = false) {
    const query = !all ? {
      userId: id,
      __skip: skip,
      __limit: limit
    } : {
        userId: id,
      }
    const followingList = await this.storage.get('feeds', query, [{
      key: 'targetId',
      col: 'memento',
      targetKey: 'id',
      targetCol: 'memento'
    }, {
      key: 'userId',
      col: 'user',
      targetKey: 'id',
      targetCol: 'user',
    }])

    return followingList
  }

  async unfollow(id, targetId, targetType) {
    const doc = {
      userId: id,
      targetId: targetId,
      targetType: targetType
    }
    console.log(`unfollow ${targetId}`)
    await this.storage.feeds.deleteOne(doc)
    return doc
  }

  async follow(id, targetId, targetType) {
    const doc = {
      userId: id,
      targetId: targetId,
      targetType: targetType
    }
    console.log(`follow ${targetId}`)
    const exist = await this.storage.feeds.findOne(doc)
    if (!exist) {
      doc.createdAt = new Date().getTime()
      await this.storage.feeds.insertOne(doc)
    }
    return doc
  }

  async getTimelines(query) {
    const result = await this.storage.get('timelines', query)
    for (const data of result) {
      const post = await this.storage.get('post', {
        id: data.postId
      }, [{
        col: 'memento',
        key: 'mementoId',
        targetCol: 'memento',
        targetKey: 'id'
      }, {
        col: 'user',
        key: 'owner',
        targetCol: 'user',
        targetKey: 'id'
      }])
      data.post = post[0]
    }
    return result
  }

  async addToTimelines(feedId, postId) {
    const doc = {
      feedId: feedId,
      postId: postId
    }
    const exist = await this.storage.db.collection('timelines').findOne(doc)
    if (!exist) {
      doc.createdAt = new Date().getTime()
      await this.storage.db.collection('timelines').insertOne(doc)
    }
    return doc
  }

  async removeFromTimelines(feedId, postId) {
    const doc = {
      feedId: feedId,
      postId: postId
    }
    await this.storage.db.collection('timelines').deleteOne(doc)
    return doc
  }
}

module.exports = Feed
'''
'''--- controllers/Transaction.js ---
class Transaction {
  constructor(state, storage) {
    this.state = state
    this.storage = storage
  }

  async getById(id, skip = 0, limit = 5) {
    const embed = [{
      col: 'fromUser',
      key: 'from',
      targetCol: 'user',
      targetKey: 'id'
    }, {
      col: 'toUser',
      key: 'to',
      targetCol: 'user',
      targetKey: 'id'
    }]
    const data = await this.storage.db.collection('transaction').find({
      $or: [
        {
          from: id
        },
        {
          to: id
        }
      ]
    }, {
      projection: {
        _id: 0
      }
    })
      .sort({
        createdAt: -1
      })
      .skip(parseInt(skip))
      .limit(parseInt(limit))

    const arr = data.toArray()
    const iter = (await arr).map(x => x)
    const result = []
    for await (const d of iter) {
      if (embed &&  embed.length > 0) {
        for (const e of embed) {
          d[e.col] = await this.storage.db.collection(e.targetCol).findOne({
            [e.targetKey]: d[e.key]
          })
        }
      }
      result.push(d)
    }
    return result
  }
}

module.exports = Transaction
'''
'''--- controllers/Verification.js ---
const jwt = require('jsonwebtoken')

class User {
  constructor(state, storage, mail) {
    this.state = state
    this.storage = storage
    this.mail = mail
  }

  async checkRegister(id) {
    const userExist = await this.storage.verifications.findOne({
      userId: id
    })
    // if email already exist
    if (userExist) {
      return userExist
    }
    return null
  }

  register(id, email, fullName, referral) {
    const doc = {
      userId: id,
      email: email,
      fullName: fullName,
      referral: referral,
      status: 'pending'
    }

    return new Promise(async (resolve, reject) => {
      const emailExist = await this.storage.verifications.findOne({
        email: email
      })
      // if email already exist
      if (emailExist) {
        reject('already_registered')
      }
      // else save data
      else {
        doc.createdAt = new Date().getTime()
        doc.updatedAt = new Date().getTime()
        await this.storage.verifications.insertOne(doc)

        // send email
        const token = jwt.sign(doc, process.env.JWT_SECRET)
        const link = `${process.env.FRONTEND_URL}/confirm-email/${token}`
        this.mail.sendVerifyEmail({
          link: link,
          email: email
        })
        resolve(true)
      }
    })
  }

  confirmEmail(token) {
    return new Promise(async (resolve, reject) => {
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET)

        const alreadyConfirmed = await this.storage.verifications.findOne({
          email: decoded.email,
          status: 'confirmed'
        })
        if (alreadyConfirmed) {
          return reject('already_confirmed')
        }
        const newDoc = await this.storage.verifications.findOneAndUpdate({
          userId: decoded.userId,
          email: decoded.email
        }, {
          $set: {
            updatedAt: new Date().getTime(),
            status: 'confirmed'
          }
        }, {
          returnOriginal: false
        })
        if (!newDoc.value) {
          throw "bad_input"
        }
        resolve(newDoc)
      } catch (err) {
        reject(err)
      }
    })
  }
}

module.exports = User
'''
'''--- deploy.js ---
require('dotenv').config()

const Near = require('./Near')

const main = async () => {
  const near = new Near()
  await near.init()

  await near.deployContract()
}

main()
'''
'''--- index.js ---
require('dotenv').config()

const express = require('express')
const cors = require('cors')
const bodyParser = require('body-parser')

const authenticate = require('./middleware/authenticate')
const admin = require('./middleware/admin')

const State = require('./State')
const Storage = require('./Storage')
const Mail = require('./Mail')
const Cron = require('./Cron')
const Near = require('./Near')

const Feed = require('./controllers/Feed')
const Transaction = require('./controllers/Transaction')
const Verification = require('./controllers/Verification')
const Explore = require('./controllers/Explore')
const Balance = require('./controllers/Balance')
const Auth = require('./controllers/Auth')

const PORT = 9090
const server = express()

const main = async () => {
  const storage = new Storage()
  const mail = new Mail()
  const state = new State(storage)
  const cron = new Cron(state, storage, mail)
  const near = new Near()
  try {
    await storage.init()
    await mail.init()
    await state.init()
    await cron.init()
    await near.init()
  } catch (err) {
    console.log(err)
    process.exit(1)
  }

  const feed = new Feed(state, storage)
  const transaction = new Transaction(state, storage)
  const verification = new Verification(state, storage, mail)
  const explore = new Explore(state, storage)
  const balance = new Balance(state, storage)
  const auth = new Auth(state, storage, mail, near)

  server.use(cors())
  server.use(bodyParser.urlencoded({ extended: true }))
  server.use(bodyParser.json())

  server.get('/', (req, res) => {
    return res.json({
      success: 1
    })
  })

  server.post('/register', async (req, res) => {
    const payload = {
      email: req.body.email,
      username: req.body.username,
    }
    try {
      const result = await auth.register(payload)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.status(400).json({
        success: 0,
        message: err.message
      })
    }
  })

  server.post('/register/confirm', async (req, res) => {
    const payload = {
      email: req.body.email,
      pin: req.body.pin
    }
    try {
      const result = await auth.verifyRegister(payload)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.status(400).json({
        success: 0,
        message: err.message
      })
    }
  })

  server.post('/login', async (req, res) => {
    const payload = {
      userId: req.body.userId,
      seed: req.body.seed
    }
    try {
      const result = await auth.login(payload)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.status(400).json({
        success: 0,
        message: err.message
      })
    }
  })

  server.post('/verify', async (req, res) => {
    try {
      const result = await auth.verifyToken({
        token: req.headers.authorization.split(' ')[1]
      })
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.status(400).json({
        success: 0,
        message: err.message
      })
    }
  })

  server.get('/mementos', async (req, res) => {
    const mementoList = await storage.get('memento', req.query, [{
      col: 'user',
      key: 'owner',
      targetCol: 'user',
      targetKey: 'id'
    }])
    return res.json({
      success: 1,
      data: mementoList
    })
  })

  server.get('/posts', async (req, res) => {
    const postList = await storage.get('post', req.query, [{
      col: 'memento',
      key: 'mementoId',
      targetCol: 'memento',
      targetKey: 'id'
    }, {
      col: 'user',
      key: 'owner',
      targetCol: 'user',
      targetKey: 'id'
    }])
    return res.json({
      success: 1,
      data: postList
    })
  })

  server.get('/transactions', async (req, res) => {
    const txList = await transaction.getById(req.query.id, req.query.__skip, req.query.__limit)
    return res.json({
      success: 1,
      data: txList
    })
  })

  server.get('/search', async (req, res) => {
    const itemList = await explore.search(req.query)
    return res.json({
      success: 1,
      data: itemList
    })
  })

  server.get('/users', async (req, res) => {
    const userList = await storage.get('user', req.query)
    return res.json({
      success: 1,
      data: userList
    })
  })

  server.get('/explore', async (req, res) => {
    const postList = await explore.getPost()
    return res.json({
      success: 1,
      data: postList
    })
  })

  server.get('/grants', async (req, res) => {
    const grantList = await storage.get('grant', req.query, [{
      col: 'memento',
      key: 'mementoId',
      targetCol: 'memento',
      targetKey: 'id'
    }])
    return res.json({
      success: 1,
      data: grantList
    })
  })

  server.get('/balances/:id', async (req, res) => {
    const accountBalance = await balance.get(req.params.id)
    return res.json({
      success: 1,
      data: accountBalance
    })
  })

  server.get('/comments', async (req, res) => {
    const commentList = await storage.get('comment', req.query, [{
      col: 'user',
      key: 'owner',
      targetCol: 'user',
      targetKey: 'id'
    }])
    return res.json({
      success: 1,
      data: commentList
    })
  })

  server.get('/feeds', authenticate, async (req, res) => {
    const {
      __skip,
      __limit
    } = req.query

    try {
      const result = await feed.get(req.userId, __skip, __limit)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.json({
        success: 0,
        message: err
      })
    }
  })

  server.get('/timelines', async (req, res) => {
    try {
      const result = await feed.getTimelines(req.query)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      console.log(err)
      return res.json({
        success: 0,
        message: err
      })
    }
  })

  server.post('/timelines', admin, async (req, res) => {
    try {
      const result = await feed.addToTimelines(req.body.feedId, req.body.postId)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      return res.json({
        success: 0,
        message: err
      })
    }
  })

  server.delete('/timelines', admin, async (req, res) => {
    try {
      const result = await feed.removeFromTimelines(req.body.feedId, req.body.postId)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      return res.json({
        success: 0,
        message: err
      })
    }
  })

  server.get('/follow', authenticate, async (req, res) => {
    try {
      const result = await feed.getFollowing(req.userId, req.query.__skip, req.query.__limit)
      return res.json({
        success: 1,
        data: result
      })
    } catch (err) {
      return res.json({
        success: 0,
        message: err
      })
    }
  })

  server.post('/follow', authenticate, async (req, res) => {
    const {
      targetId,
      targetType
    } = req.body

    try {
      await feed.follow(req.userId, targetId, targetType)
      return res.json({
        success: 1,
        data: true
      })
    } catch (err) {
      return res.status(400).json({
        success: 0,
        message: err
      })
    }
  })

  server.post('/unfollow', authenticate, async (req, res) => {
    const {
      targetId,
      targetType
    } = req.body

    try {
      await feed.unfollow(req.userId, targetId, targetType)
      return res.json({
        success: 1,
        data: true
      })
    } catch (err) {
      return res.status(400).json({
        success: 0,
        message: err
      })
    }
  })

  server.get('/register', authenticate, async (req, res) => {
    try {
      const user = await verification.checkRegister(req.userId)
      return res.json({
        success: 1,
        data: user
      })
    } catch (err) {
      console.log(err)
      return res.status(400).json({
        success: 0,
        message: err
      })
    }
  })

  server.post('/register', authenticate, async (req, res) => {
    const {
      email,
      fullName,
      referral,
    } = req.body

    try {
      await verification.register(req.userId, email, fullName, referral)
      return res.json({
        success: 1,
        data: true
      })
    } catch (err) {
      return res.status(400).json({
        success: 0,
        message: err
      })
    }
  })

  server.post('/confirm', async (req, res) => {
    const {
      token
    } = req.body

    try {
      await verification.confirmEmail(token)
      return res.json({
        success: 1,
        data: true
      })
    } catch (err) {
      return res.status(400).json({
        success: 0,
        message: err
      })
    }
  })

  server.listen(PORT, () => {
    console.log(`indexer running on PORT ${PORT}`)
  })
}

main()
'''
'''--- middleware/admin.js ---
module.exports = async (req, res, next) => {
  if (req.headers['x-admin-token'] === process.env.ADMIN_TOKEN) {
    console.log('admin')
    return next()
  }
  return res.status(401).json({
    success: 0,
    message: 'unauthorized'
  })
}
'''
'''--- middleware/authenticate.js ---
const Base64 = require('js-base64').Base64
const nacl = require('tweetnacl')
const bs58 = require('bs58')
const sha256 = require('js-sha256')
const axios = require('axios')

const _hexToArr = (str) => {
  return new Uint8Array(str.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
}

module.exports = async (req, res, next) => {
  const authHeader = req.headers.authorization
  const decodeAuthHeader = Base64.decode(authHeader)
  const [userId, pubKey, signature] = decodeAuthHeader.split('&')
  const pubKeyArr = _hexToArr(pubKey)
  const signatureArr = _hexToArr(signature)
  const hash = new Uint8Array(sha256.sha256.array(userId))
  const verify = nacl.sign.detached.verify(hash, signatureArr, pubKeyArr)
  if (!verify) {
    return res.status(401).json({
      success: 0,
      message: 'unauthorized'
    })
  }
  const b58pubKey = bs58.encode(Buffer.from(pubKey.toUpperCase(), 'hex'))
  const response = await axios.post(`https://rpc.testnet.near.org`, {
    jsonrpc: '2.0',
    id: 'dontcare',
    method: 'query',
    params: {
      request_type: 'view_access_key',
      finality: 'final',
      account_id: userId,
      public_key: `ed25519:${b58pubKey}`
    }
  })

  if (response.data.result && response.data.result.error) {
    console.log(response.data.result.error)
    return res.status(401).json({
      success: 0,
      message: 'unauthorized'
    })
  }
  req.userId = userId
  next()
}
'''
'''--- package.json ---
{
  "name": "paras-alpha-indexer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev:contract": "NODE_ENV=development nodemon --watch assembly -e ts --exec asp",
    "build:contract": "asb",
    "deploy:contract": "NODE_ENV=development npm run build:contract && node deploy.js",
    "dev": "NODE_ENV=development nodemon --watch '*.js' index.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "aws-sdk": "^2.733.0",
    "axios": "^0.19.2",
    "base-64": "^0.1.0",
    "body-parser": "^1.19.0",
    "bs58": "^4.0.1",
    "cors": "^2.8.5",
    "cryptr": "^6.0.2",
    "dotenv": "^8.2.0",
    "express": "^4.17.1",
    "fuse.js": "^6.3.1",
    "heml": "^1.1.3",
    "js-base64": "^2.5.2",
    "js-sha256": "^0.9.0",
    "jsbi": "^3.1.3",
    "jsonwebtoken": "^8.5.1",
    "lokijs": "^1.5.8",
    "mongodb": "^3.5.9",
    "near-api-js": "^0.25.1",
    "near-seed-phrase": "^0.0.2",
    "node-cron": "^2.0.3",
    "nodemailer": "^6.4.8",
    "query-params-mongo": "https://github.com/hdriqi/query-params-mongo",
    "sjcl": "^1.0.8",
    "tweetnacl": "^1.0.3",
    "underscore": "^1.10.2"
  },
  "devDependencies": {
    "near-sdk-as": "^1.0.1",
    "near-shell": "^0.24.9",
    "nodemon": "^2.0.4"
  }
}

'''
'''--- tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- utils/common.js ---
const prettyBalance = (balance, decimals = 18, len = 8) => {
  const diff = balance.toString().length - (10 ** decimals).toString().length
  const fixedPoint = Math.max(1, Math.min(len, len - diff))
  const finalBalance = (balance / (10 ** decimals)).toFixed(fixedPoint).toLocaleString()
  const [head, tail] = finalBalance.split('.')
  const formattedHead = head.replace(/\B(?=(\d{3})+(?!\d))/g, ",")
  return `${formattedHead}.${tail}`
}

module.exports = {
  prettyBalance
} 
'''