*GitHub Repository "ninjadev0706/nft-staking-platform"*

'''--- FT/Cargo.toml ---
[package]
name = "fungible-token-wrapper"
version = "0.0.2"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
near-primitives = "0.5.0"
near-sdk = { path = "../../near-sdk" }
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.1.1"

# remember to include a line for each contract
fungible-token = { path = "./ft" }
defi = { path = "./test-contract-defi" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "ft",
  "test-contract-defi",
]

'''
'''--- FT/README.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests.

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

NOTES:
 - The maximum balance value is limited by U128 (2**128 - 1).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract.

## Building
To build run:
```bash
./build.sh
```

## Testing
To test run:
```bash
cargo test --package fungible-token -- --nocapture
```

## Changelog

### `1.0.0`

- Switched form using [NEP-21](https://github.com/near/NEPs/pull/21) to [NEP-141](https://github.com/near/NEPs/issues/141).

### `0.3.0`

#### Breaking storage change

- Switching `UnorderedMap` to `LookupMap`. It makes it cheaper and faster due to decreased storage access.

'''
'''--- FT/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"

cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/defi.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/fungible_token.wasm ./res/

'''
'''--- FT/ft/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- FT/ft/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{
    env, log, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    FungibleToken,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(StorageKey::FungibleToken),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- FT/test-contract-defi/Cargo.toml ---
[package]
name = "defi"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- FT/test-contract-defi/src/lib.rs ---
/*!
Some hypothetical DeFi contract that will do smart things with the transferred tokens
*/
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_FT_ON_TRANSFER: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DeFi {
    fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl DeFi {
    #[init]
    pub fn new(fungible_token_account_id: AccountId) -> Self {
        require!(!env::state_exists(), "Already initialized");
        Self { fungible_token_account_id: fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for DeFi {
    /// If given `msg: "take-my-money", immediately returns U128::From(0)
    /// Otherwise, makes a cross-contract call to own `value_please` function, passing `msg`
    /// value_please will attempt to parse `msg` as an integer and return a U128 version of it
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Verifying that we were called by fungible token contract that we expect.
        require!(
            env::predecessor_account_id() == self.fungible_token_account_id,
            "Only supports the one fungible token contract"
        );
        log!("in {} tokens from @{} ft_on_transfer, msg = {}", amount.0, sender_id.as_ref(), msg);
        match msg.as_str() {
            "take-my-money" => PromiseOrValue::Value(U128::from(0)),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::value_please(
                    msg,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_FT_ON_TRANSFER,
                )
                .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for DeFi {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128> {
        log!("in value_please, amount_to_return = {}", amount_to_return);
        let amount: Balance = amount_to_return.parse().expect("Not an integer");
        PromiseOrValue::Value(amount.into())
    }
}

'''
'''--- FT/tests/workspaces.rs ---
use near_primitives::views::FinalExecutionStatus;
use near_sdk::json_types::U128;
use near_sdk::ONE_YOCTO;
use near_units::parse_near;
use workspaces::prelude::*;
use workspaces::{Account, AccountId, Contract, DevNetwork, Network, Worker};

async fn register_user(
    worker: &Worker<impl Network>,
    contract: &Contract,
    account_id: &AccountId,
) -> anyhow::Result<()> {
    let res = contract
        .call(&worker, "storage_deposit")
        .args_json((account_id, Option::<bool>::None))?
        .gas(300_000_000_000_000)
        .deposit(near_sdk::env::storage_byte_cost() * 125)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    Ok(())
}

async fn init(
    worker: &Worker<impl DevNetwork>,
    initial_balance: U128,
) -> anyhow::Result<(Contract, Account, Contract)> {
    let ft_contract =
        worker.dev_deploy(include_bytes!("../res/fungible_token.wasm").to_vec()).await?;

    let res = ft_contract
        .call(&worker, "new_default_meta")
        .args_json((ft_contract.id(), initial_balance))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let defi_contract = worker.dev_deploy(include_bytes!("../res/defi.wasm").to_vec()).await?;

    let res = defi_contract
        .call(&worker, "new")
        .args_json((ft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let alice = ft_contract
        .as_account()
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;
    register_user(worker, &ft_contract, alice.id()).await?;

    let res = ft_contract
        .call(&worker, "storage_deposit")
        .args_json((alice.id(), Option::<bool>::None))?
        .gas(300_000_000_000_000)
        .deposit(near_sdk::env::storage_byte_cost() * 125)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    return Ok((ft_contract, alice, defi_contract));
}

#[tokio::test]
async fn test_total_supply() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let worker = workspaces::sandbox();
    let (contract, _, _) = init(&worker, initial_balance).await?;

    let res = contract.call(&worker, "ft_total_supply").view().await?;
    assert_eq!(res.json::<U128>()?, initial_balance);

    Ok(())
}

#[tokio::test]
async fn test_simple_transfer() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, alice, _) = init(&worker, initial_balance).await?;

    let res = contract
        .call(&worker, "ft_transfer")
        .args_json((alice.id(), transfer_amount, Option::<bool>::None))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let root_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    let alice_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((alice.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(initial_balance.0 - transfer_amount.0, root_balance.0);
    assert_eq!(transfer_amount.0, alice_balance.0);

    Ok(())
}

#[tokio::test]
async fn test_close_account_empty_balance() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let worker = workspaces::sandbox();
    let (contract, alice, _) = init(&worker, initial_balance).await?;

    let res = alice
        .call(&worker, contract.id().clone(), "storage_unregister")
        .args_json((Option::<bool>::None,))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(res.json::<bool>()?);

    Ok(())
}

#[tokio::test]
async fn test_close_account_non_empty_balance() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let worker = workspaces::sandbox();
    let (contract, _, _) = init(&worker, initial_balance).await?;

    let res = contract
        .call(&worker, "storage_unregister")
        .args_json((Option::<bool>::None,))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(format!("{:?}", res.status.as_failure())
        .contains("Can't unregister the account with the positive balance without force"));

    let res = contract
        .call(&worker, "storage_unregister")
        .args_json((Some(false),))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(format!("{:?}", res.status.as_failure())
        .contains("Can't unregister the account with the positive balance without force"));

    Ok(())
}

#[tokio::test]
async fn simulate_close_account_force_non_empty_balance() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let worker = workspaces::sandbox();
    let (contract, _, _) = init(&worker, initial_balance).await?;

    let res = contract
        .call(&worker, "storage_unregister")
        .args_json((Some(true),))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let res = contract.call(&worker, "ft_total_supply").view().await?;
    assert_eq!(res.json::<U128>()?.0, 0);

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_with_burned_amount() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, _, defi_contract) = init(&worker, initial_balance).await?;

    // defi contract must be registered as a FT account
    register_user(&worker, &contract, defi_contract.id()).await?;

    // root invests in defi by calling `ft_transfer_call`
    // TODO: Put two actions below into a batched transaction once workspaces supports them
    let res = contract
        .call(&worker, "ft_transfer_call")
        .args_json((defi_contract.id(), transfer_amount, Option::<String>::None, "10"))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    let res = contract
        .call(&worker, "storage_unregister")
        .args_json((Some(true),))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    assert!(res.json::<bool>()?);

    // TODO: Check callbacks once workspaces starts exposing them

    // let callback_outcome = outcome.get_receipt_results().remove(1).unwrap();
    //
    // assert_eq!(callback_outcome.logs()[0], "The account of the sender was deleted");
    // assert_eq!(callback_outcome.logs()[1], format!("Account @{} burned {}", root.account_id(), 10));
    //
    // let used_amount: U128 = callback_outcome.unwrap_json();
    // // Sender deleted the account. Even though the returned amount was 10, it was not refunded back
    // // to the sender, but was taken out of the receiver's balance and was burned.
    // assert_eq!(used_amount.0, transfer_amount);

    let res = contract.call(&worker, "ft_total_supply").view().await?;
    assert_eq!(res.json::<U128>()?.0, transfer_amount.0 - 10);
    let defi_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((defi_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(defi_balance.0, transfer_amount.0 - 10);

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_with_immediate_return_and_no_refund() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, _, defi_contract) = init(&worker, initial_balance).await?;

    // defi contract must be registered as a FT account
    register_user(&worker, &contract, defi_contract.id()).await?;

    // root invests in defi by calling `ft_transfer_call`
    let res = contract
        .call(&worker, "ft_transfer_call")
        .args_json((defi_contract.id(), transfer_amount, Option::<String>::None, "take-my-money"))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let root_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    let defi_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((defi_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(initial_balance.0 - transfer_amount.0, root_balance.0);
    assert_eq!(transfer_amount.0, defi_balance.0);

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_when_called_contract_not_registered_with_ft() -> anyhow::Result<()>
{
    let initial_balance = U128::from(parse_near!("10000 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, _, defi_contract) = init(&worker, initial_balance).await?;

    // call fails because DEFI contract is not registered as FT user
    let res = contract
        .call(&worker, "ft_transfer_call")
        .args_json((defi_contract.id(), transfer_amount, Option::<String>::None, "take-my-money"))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::Failure(_)));

    // balances remain unchanged
    let root_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    let defi_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((defi_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(initial_balance.0, root_balance.0);
    assert_eq!(0, defi_balance.0);

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_with_promise_and_refund() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let refund_amount = U128::from(parse_near!("50 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, _, defi_contract) = init(&worker, initial_balance).await?;

    // defi contract must be registered as a FT account
    register_user(&worker, &contract, defi_contract.id()).await?;

    let res = contract
        .call(&worker, "ft_transfer_call")
        .args_json((
            defi_contract.id(),
            transfer_amount,
            Option::<String>::None,
            refund_amount.0.to_string(),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let root_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    let defi_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((defi_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(initial_balance.0 - transfer_amount.0 + refund_amount.0, root_balance.0);
    assert_eq!(transfer_amount.0 - refund_amount.0, defi_balance.0);

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_promise_panics_for_a_full_refund() -> anyhow::Result<()> {
    let initial_balance = U128::from(parse_near!("10000 N"));
    let transfer_amount = U128::from(parse_near!("100 N"));
    let worker = workspaces::sandbox();
    let (contract, _, defi_contract) = init(&worker, initial_balance).await?;

    // defi contract must be registered as a FT account
    register_user(&worker, &contract, defi_contract.id()).await?;

    // root invests in defi by calling `ft_transfer_call`
    let res = contract
        .call(&worker, "ft_transfer_call")
        .args_json((
            defi_contract.id(),
            transfer_amount,
            Option::<String>::None,
            "no parsey as integer big panic oh no".to_string(),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check promise errors once workspaces starts exposing them

    // assert_eq!(res.promise_errors().len(), 1);
    //
    // if let ExecutionStatus::Failure(execution_error) =
    //     &res.promise_errors().remove(0).unwrap().outcome().status
    // {
    //     assert!(execution_error.to_string().contains("ParseIntError"));
    // } else {
    //     unreachable!();
    // }

    // balances remain unchanged
    let root_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    let defi_balance = contract
        .call(&worker, "ft_balance_of")
        .args_json((defi_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(initial_balance, root_balance);
    assert_eq!(0, defi_balance.0);

    Ok(())
}

'''
'''--- NFT/Cargo.toml ---
[package]
name = "non-fungible-token-wrapper"
version = "0.0.2"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
near-primitives = "0.5.0"
near-contract-standards = { path = "../../near-contract-standards" }
near-sdk = { path = "../../near-sdk" }
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.1.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "test-approval-receiver",
  "test-token-receiver",
]

'''
'''--- NFT/README.md ---
Non-fungible Token (NFT)
===================

Example implementation of a [non-fungible token] contract which uses [near-contract-standards] and [simulation] tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

NOTES:
 - The maximum balance value is limited by U128 (2**128 - 1).
 - JSON calls should pass [U128](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.U128.html) or [U64](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.U64.html) as a base-10 string. E.g. "100".
 - The core NFT standard does not include escrow/approval functionality, as `nft_transfer_call` provides a superior approach. Please see the approval management standard if this is the desired approach.

## Building
To build run:
```bash
./build.sh
```

## Testing
To test run:
```bash
cargo test --workspace --package non-fungible-token -- --nocapture
```

'''
'''--- NFT/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/approval_receiver.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/non_fungible_token.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/token_receiver.wasm ./res/
'''
'''--- NFT/neardev/dev-account.env ---
CONTRACT_NAME=dev-1647956167150-46634819641820
'''
'''--- NFT/nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- NFT/nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `token_owner_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        token_owner_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");
        self.tokens.internal_mint(token_id, token_owner_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id, accounts(0));
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1));
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- NFT/res/neardev/dev-account.env ---
CONTRACT_NAME=dev-1647952710136-71413340344564
'''
'''--- NFT/test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- NFT/test-approval-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_approve for simulation testing nft_approve.
*/
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_NFT_ON_APPROVE: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ApprovalReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

#[near_bindgen]
impl ApprovalReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for ApprovalReceiver {
    /// Could do anything useful to the approval-receiving contract, such as store the given
    /// approval_id for use later when calling the NFT contract. Can also return whatever it wants,
    /// maybe after further promise calls. This one simulates "return anything" behavior only.
    /// Supports the following `msg` patterns:
    /// * "return-now" - immediately return `"cool"`
    /// * anything else - return the given `msg` after one more cross-contract call
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        // Verifying that we were called by non-fungible token contract that we expect.
        require!(
            env::predecessor_account_id() == self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        match msg.as_str() {
            "return-now" => PromiseOrValue::Value("cool".to_string()),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(msg, account_id, NO_DEPOSIT, prepaid_gas - GAS_FOR_NFT_ON_APPROVE)
                    .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for ApprovalReceiver {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String> {
        log!("in ok_go, msg={}", msg);
        PromiseOrValue::Value(msg)
    }
}

'''
'''--- NFT/test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../../../near-sdk" }
near-contract-standards = { path = "../../../near-contract-standards" }

'''
'''--- NFT/test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_transfer for simulation testing nft_transfer_call.
*/
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Verifying that we were called by non-fungible token contract that we expect.
        require!(
            env::predecessor_account_id() == self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_transfer; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &sender_id,
            &previous_owner_id,
            &token_id,
            msg
        );
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(true),
            "return-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(true, account_id, NO_DEPOSIT, prepaid_gas - GAS_FOR_NFT_ON_TRANSFER)
                    .into()
            }
            "keep-it-now" => PromiseOrValue::Value(false),
            "keep-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(
                    false,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_NFT_ON_TRANSFER,
                )
                .into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool> {
        log!("in ok_go, return_it={}", return_it);
        PromiseOrValue::Value(return_it)
    }
}

'''
'''--- NFT/tests/workspaces/main.rs ---
mod test_approval;
mod test_core;
mod test_enumeration;
mod utils;

'''
'''--- NFT/tests/workspaces/test_approval.rs ---
use crate::utils::init;
use near_contract_standards::non_fungible_token::Token;
use near_primitives::views::FinalExecutionStatus;
use near_sdk::{AccountId, ONE_NEAR, ONE_YOCTO};
use std::collections::HashMap;
use std::convert::TryFrom;

pub const TOKEN_ID: &str = "0";

#[tokio::test]
async fn simulate_simple_approve() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // check nft_is_approved, don't provide approval_id
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approved);

    // check nft_is_approved, with approval_id=1
    let alice_approval_id_is_1 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(1u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approval_id_is_1);

    // check nft_is_approved, with approval_id=2
    let alice_approval_id_is_2 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(&(TOKEN_ID, alice.id(), Some(2u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approval_id_is_2);

    // alternatively, one could check the data returned by nft_token
    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    let mut expected_approvals: HashMap<AccountId, u64> = HashMap::new();
    expected_approvals.insert(AccountId::try_from(alice.id().to_string())?, 1);
    assert_eq!(token.approved_account_ids.unwrap(), expected_approvals);

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let alice_approval_id_is_2 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(2u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approval_id_is_2);

    // approving another account gives different approval_id
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        // note that token_receiver's account name is shorter, and so takes less bytes to store and
        // therefore requires a smaller deposit!
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token_receiver_approval_id_is_3 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(token_receiver_approval_id_is_3);

    Ok(())
}

#[tokio::test]
async fn simulate_approval_with_call() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, approval_receiver_contract) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, approval_receiver_contract.id(), Some("return-now".to_string())))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert_eq!(res.json::<String>()?, "cool".to_string());

    // Approve again; will set different approval_id (ignored by approval_receiver).
    // The approval_receiver implementation will return given `msg` after subsequent promise call,
    // if given something other than "return-now".
    let msg = "hahaha".to_string();
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, approval_receiver_contract.id(), Some(msg.clone())))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert_eq!(res.json::<String>()?, msg);

    Ok(())
}

#[tokio::test]
async fn simulate_approved_account_transfers_token() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice sends to self
    let res = alice
        .call(&worker, nft_contract.id().clone(), "nft_transfer")
        .args_json((alice.id(), TOKEN_ID, Some(1u64), Some("gotcha! bahahaha".to_string())))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // token now owned by alice
    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), alice.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_revoke() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root approves token_receiver
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root revokes alice
    let res = nft_contract
        .call(&worker, "nft_revoke")
        .args_json((TOKEN_ID, alice.id()))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // but token_receiver is still approved
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(token_receiver_approved);

    // root revokes token_receiver
    let res = nft_contract
        .call(&worker, "nft_revoke")
        .args_json((TOKEN_ID, token_receiver_contract.id()))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is still revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // ...and now so is token_receiver
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!token_receiver_approved);

    Ok(())
}

#[tokio::test]
async fn simulate_revoke_all() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root approves token_receiver
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root revokes all
    let res = nft_contract
        .call(&worker, "nft_revoke_all")
        .args_json((TOKEN_ID,))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // and so is token_receiver
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!token_receiver_approved);

    Ok(())
}

'''
'''--- NFT/tests/workspaces/test_core.rs ---
use crate::utils::{init, TOKEN_ID};
use near_contract_standards::non_fungible_token::Token;
use near_primitives::views::FinalExecutionStatus;
use near_sdk::ONE_YOCTO;

#[tokio::test]
async fn simulate_simple_transfer() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    let res = nft_contract
        .call(&worker, "nft_transfer")
        .args_json((
            alice.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("simple transfer".to_string()),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), alice.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_fast_return_to_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "return-it-now",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_slow_return_to_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "return-it-later",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_fast_keep_with_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "keep-it-now",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), token_receiver_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_slow_keep_with_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "keep-it-later",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), token_receiver_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_receiver_panics() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "incorrect message",
        ))?
        .gas(35_000_000_000_000 + 1)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints final log
    // assert_eq!(res.logs().len(), 1);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_receiver_panics_and_nft_resolve_transfer_produces_no_log_if_not_enough_gas(
) -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "incorrect message",
        ))?
        .gas(35_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::Failure(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_simple_transfer_no_logs_on_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer")
        // transfer to the current owner should fail and not print log
        .args_json((nft_contract.id(), TOKEN_ID, Option::<u64>::None, Some("simple transfer")))?
        .gas(200_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::Failure(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

'''
'''--- NFT/tests/workspaces/test_enumeration.rs ---
use crate::utils::{helper_mint, init};
use near_contract_standards::non_fungible_token::Token;
use near_sdk::json_types::U128;
use workspaces::{Contract, DevNetwork, Worker};

async fn mint_more(
    nft_contract: &Contract,
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<()> {
    helper_mint(
        nft_contract,
        worker,
        "1".to_string(),
        "Black as the Night".to_string(),
        "In charcoal".to_string(),
    )
    .await?;
    helper_mint(
        nft_contract,
        worker,
        "2".to_string(),
        "Hamakua".to_string(),
        "Vintage recording".to_string(),
    )
    .await?;
    helper_mint(
        nft_contract,
        worker,
        "3".to_string(),
        "Aloha ke akua".to_string(),
        "Original with piano".to_string(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn simulate_enum_total_supply() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    let total_supply: U128 = nft_contract.call(&worker, "nft_total_supply").view().await?.json()?;
    assert_eq!(total_supply, U128::from(4));

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_tokens() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    // No optional args should return all
    let mut tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 4);
    // Start at "1", with no limit arg
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Some(U128::from(1)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 3);
    assert_eq!(tokens.get(0).unwrap().token_id, "1".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "2".to_string());
    assert_eq!(tokens.get(2).unwrap().token_id, "3".to_string());

    // Start at "2", with limit 1
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Some(U128::from(2)), Some(1u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens.get(0).unwrap().token_id, "2".to_string());

    // Don't specify from_index, but limit 2
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Option::<U128>::None, Some(2u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 2);
    assert_eq!(tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "1".to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_supply_for_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    // Get number from account with no NFTs
    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((alice.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(0));

    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((nft_contract.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(1));

    mint_more(&nft_contract, &worker).await?;

    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((nft_contract.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(4));

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_tokens_for_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    // Get tokens from account with no NFTs
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((alice.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 0);

    // Get tokens with no optional args
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 4);

    // With from_index and no limit
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Some(U128::from(2)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 2);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "2".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "3".to_string());

    // With from_index and limit 1
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Some(U128::from(1)), Some(1u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 1);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "1".to_string());

    // No from_index but limit 3
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Option::<U128>::None, Some(3u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 3);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "1".to_string());
    assert_eq!(owner_tokens.get(2).unwrap().token_id, "2".to_string());

    Ok(())
}

'''
'''--- NFT/tests/workspaces/utils.rs ---
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_contract_standards::non_fungible_token::TokenId;
use near_primitives::views::FinalExecutionStatus;
use near_units::parse_near;
use workspaces::prelude::DevAccountDeployer;
use workspaces::{Account, Contract, DevNetwork, Worker};

pub const TOKEN_ID: &str = "0";

pub async fn helper_mint(
    nft_contract: &Contract,
    worker: &Worker<impl DevNetwork>,
    token_id: TokenId,
    title: String,
    desc: String,
) -> anyhow::Result<()> {
    let token_metadata = TokenMetadata {
        title: Some(title),
        description: Some(desc),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let res = nft_contract
        .call(&worker, "nft_mint")
        .args_json((token_id, nft_contract.id(), token_metadata))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    Ok(())
}

/// Deploy and initialize contracts and return:
/// * nft_contract: the NFT contract, callable with `call!` and `view!`
/// * alice: a user account, does not yet own any tokens
/// * token_receiver_contract: a contract implementing `nft_on_transfer` for use with `transfer_and_call`
/// * approval_receiver_contract: a contract implementing `nft_on_approve` for use with `nft_approve`
pub async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Account, Contract, Contract)> {
    let nft_contract =
        worker.dev_deploy(include_bytes!("../../res/non_fungible_token.wasm").to_vec()).await?;

    let res = nft_contract
        .call(&worker, "new_default_meta")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token_metadata = TokenMetadata {
        title: Some("Olympus Mons".into()),
        description: Some("The tallest mountain in the charted solar system".into()),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let res = nft_contract
        .call(&worker, "nft_mint")
        .args_json((TOKEN_ID, nft_contract.id(), token_metadata))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let res = nft_contract
        .as_account()
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?;
    assert!(matches!(res.details.status, FinalExecutionStatus::SuccessValue(_)));
    let alice = res.result;

    let token_receiver_contract =
        worker.dev_deploy(include_bytes!("../../res/token_receiver.wasm").to_vec()).await?;
    let res = token_receiver_contract
        .call(&worker, "new")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let approval_receiver_contract =
        worker.dev_deploy(include_bytes!("../../res/approval_receiver.wasm").to_vec()).await?;
    let res = approval_receiver_contract
        .call(&worker, "new")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    return Ok((nft_contract, alice, token_receiver_contract, approval_receiver_contract));
}

'''
'''--- Staking/Cargo.toml ---
[package]
name = "cross-contract-high-level"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { git = "https://github.com/ahalabs/near-sdk-rs", tag = "v4.0.0-3"}
near-contract-standards = { git = "https://github.com/ahalabs/near-sdk-rs", tag = "v4.0.0-3" }

[dev-dependencies]
alloc-shim = "0.3.5"
anyhow = "1.0"
near-primitives = "0.5.0"
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.1.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []

'''
'''--- Staking/README.md ---
# Cross contract

Example of using cross-contract functions, like promises, or money transfers.

## Several contracts
Let's start the local Near testnet to run the contract on it.

* Make sure you have [Docker](https://www.docker.com/) installed;
* Clone the [nearprotocol/nearcore](https://github.com/near/nearcore);
To start your local node, go to `nearcore` and run the following script:
```bash
rm -rf ~/.near
./scripts/start_localnet.py
```
This will pull the docker image and start a single local node. Enter an `test_near` that you want to be associated with.

Then execute the following to follow the block production logs:
```bash
docker logs --follow nearcore
```

Create a new project:
```bash
npx create-near-app --vanilla myproject
cd myproject
```

Then in `src/config.json` modify `nodeUrl` to point to your local node:
```js
case 'development':
    return {
        networkId: 'default',
        nodeUrl: 'http://localhost:3030',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.nearprotocol.com',
    };
```

Then copy the key that the node generated upon starting in your local project to use for transaction signing.
```bash
mkdir ./neardev/default
cp ~/.near/validator_key.json ./neardev/default/test_near.json
```

Then deploy the `cross-contract` contract:
```bash
near create_account cross_contract --masterAccount=test_near  --initialBalance 10000000
near deploy --accountId=cross_contract --wasmFile=../examples/cross-contract-high-level/res/cross_contract_high_level.wasm
```

### Deploying another contract
Let's deploy another contract using `cross-contract`, factory-style.
```bash
near call cross_contract deploy_status_message "{\"account_id\": \"status_message\", \"amount\":1000000000000000}" --accountId=test_near 
```

### Trying money transfer

First check the balance on both `status_message` and `cross_contract` accounts:

```bash
near state cross_contract
near state status_message
```

See that cross_contract has approximately `9,999,999` and status_message has `0.000000001` tokens.

Then call a function on `cross_contract` that transfers money to `status_message`:

```bash
near call cross_contract transfer_money "{\"account_id\": \"status_message\", \"amount\":1000000000000000}" --accountId=test_near
```

Then check the balances again:

```bash
near state cross_contract
near state status_message
```

Observe that `status_message` has `0.000000002` tokens, even though
`test_near` signed the transaction and paid for all the gas that was used.

### Trying simple cross contract call

Call `simple_call` function on `cross_contract` account:

```bash
near call cross_contract simple_call "{\"account_id\": \"status_message\", \"message\":\"bonjour\"}" --accountId=test_near --gas 10000000000000000000
```

Verify that this actually resulted in correct state change in `status_message` contract:

```bash
near call status_message get_status "{\"account_id\":\"test_near\"}" --accountId=test_near --gas 10000000000000000000
```
Observe:
```bash
bonjour
```

### Trying complex cross contract call

Call `complex_call` function on `cross_contract` account:

```bash
near call cross_contract complex_call "{\"account_id\": \"status_message\", \"message\":\"halo\"}" --accountId=test_near --gas 10000000000000000000
```

observe `'halo'`.

What did just happen?

1. `test_near` account signed a transaction that called a `complex_call` method on `cross_contract` smart contract.
2. `cross_contract` executed `complex_call` with `account_id: "status_message", message: "halo"` arguments;
    1. During the execution the promise #0 was created to call `set_status` method on `status_message` with arguments `"message": "halo"`;
    2. Then another promise #1 was scheduled to be executed right after promise #0. Promise #1 was to call `get_status` on `status_message` with arguments: `"message": "test_near""`;
    3. Then the return value of `get_status` is programmed to be the return value of `complex_call`;
3. `status_message` executed `set_status`, then `status_message` executed `get_status` and got the `"halo"` return value
which is then passed as the return value of `complex_call`.

### Trying callback with return values

Call `merge_sort` function on `cross_contract` account:

```bash
near call cross_contract merge_sort "{\"arr\": [2, 1, 0, 3]}" --accountId=test_near --gas 10000000000000000000
```

observe the logs:
```
[cross_contract]: Received [2] and [1]
[cross_contract]: Merged [1, 2]
[cross_contract]: Received [0] and [3]
[cross_contract]: Merged [0, 3]
[cross_contract]: Received [1, 2] and [0, 3]
[cross_contract]: Merged [0, 1, 2, 3]
```

and the output
```
'\u0004\u0000\u0000\u0000\u0000\u0001\u0002\u0003'
```
The reason why output is a binary is because we used [Borsh](http://borsh.io) binary serialization format to communicate
between the contracts instead of JSON. Borsh is faster and costs less gas. In this simple example you can even read
the format, here `\u0004\u0000\u0000\u0000` stands for `4u32` encoded using little-endian encoding which corresponds to the
length of the array, `\u0000\u0001\u0002\u0003` are the elements of the array. Since the array has type `Vec<u8>` each
element is exactly one byte.

If you don't want to use it you can remove `#[serializer(borsh)]` annotation everywhere from the code and the contract will fallback to JSON.

'''
'''--- Staking/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"
cargo build --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/cross_contract_high_level.wasm ./res/
#wasm-opt -Oz --output ./res/cross_contract_high_level.wasm ./res/cross_contract_high_level.wasm

'''
'''--- Staking/src/lib.rs ---
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::*;
use near_sdk::{
    env, ext_contract, json_types::U128, log, near_bindgen, AccountId, PanicOnDefault, Promise,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct CrossContract {
    nft_account: AccountId,
    ft_account: AccountId,
    staked: UnorderedMap<AccountId, Vector<Stake>>,
    unstaked: UnorderedMap<AccountId, Vector<u128>>,
}

#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub struct Stake {
    timestamp: u64,
    staked_id: TokenId,
    owner_id: AccountId,
}

pub trait From<T> {
    /// Performs the conversion.
    #[must_use]
    fn from_cross_str(_: T) -> Self;
}

impl From<&str> for near_sdk::AccountId {
    /// Converts a `&mut str` into a [`String`].
    ///
    /// The result is allocated on the heap.
    #[inline]
    fn from_cross_str(s: &str) -> near_sdk::AccountId {
        s.parse().unwrap()
    }
}

// impl Default for near_sdk::AccountId {
//     /// Creates an empty `String`.
//     #[inline]
//     fn default() -> near_sdk::AccountId {
//         near_sdk::AccountId::from_cross_str("")
//     }
// }

// One can provide a name, e.g. `ext` to use for generated methods.
#[ext_contract(nftext)]
pub trait NFTCrossContract {
    fn nft_transfer(
        &self,
        sender_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> (AccountId, Option<HashMap<AccountId, u64>>);
}

#[ext_contract(ftext)]
pub trait FTCrossContract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[near_bindgen]
impl CrossContract {
    // Default Constructor
    #[init]
    pub fn new(ft_account: AccountId, nft_account: AccountId) -> Self {
        Self {
            ft_account,
            nft_account,
            staked: UnorderedMap::new(b"staked".to_vec()),
            unstaked: UnorderedMap::new(b"unstaked".to_vec()),
        }
    }

    // pub fn deploy_status_message(&self, account_id: AccountId, amount: U128) {
    //     Promise::new(account_id)
    //         .create_account()
    //         .transfer(amount.0)
    //         .add_full_access_key(env::signer_account_pk())
    //         .deploy_contract(
    //             include_bytes!("../../status-message/res/status_message.wasm").to_vec(),
    //         );
    // }

    #[result_serializer(borsh)]
    pub fn stake(&mut self, token_id: TokenId) /*  -> PromiseOrValue<TokenId>  */
    {
        //nftext::nft_transfer_call(&self, token_id, "Stake NFT");
        let caller = env::predecessor_account_id();
        let current_timestamp = env::block_timestamp();
        //let mut _staked = self.staked.get(&caller).unwrap().clone();
        match self.staked.get(&caller) {
            Some(mut _staked) => {
                _staked.push(&Stake {
                    timestamp: current_timestamp,
                    staked_id: token_id.clone(),
                    owner_id: caller.clone(),
                });
            }
            None => {
                let mut new_vec: Vector<Stake> = Vector::new(b"new_vec".to_vec());
                new_vec.push(&Stake {
                    timestamp: current_timestamp,
                    staked_id: token_id.clone(),
                    owner_id: caller.clone(),
                });
                self.staked.insert(&caller, &new_vec);
            }
        }
        // ------------------------------------------------------

        match self.unstaked.get(&caller) {
            Some(mut _unstaked) => {
                _unstaked.push(&0);
            }
            None => {
                let new_vec: Vector<u128> = Vector::new(b"new_vec".to_vec());
                self.unstaked.insert(&caller, &new_vec);
            }
        }
        nftext::nft_transfer(
            caller.clone(),
            env::current_account_id(),
            token_id,
            Some(1u64),
            Some(String::from("memo")),
            self.nft_account.clone(), // contract account id
            1,                        // yocto NEAR to attach
            near_sdk::Gas(20000),     // gas to attach
        );
        //nftext::nft_transfer_call(&mut self, self.nft_account, "transfer nft");
    }

    #[result_serializer(borsh)]
    pub fn unstake(&mut self) {
        let owner = env::current_account_id();
        let caller = env::predecessor_account_id();
        match self.staked.get(&caller) {
            Some(mut _staked) => {
                _staked.iter().for_each(|ele| {
                    /* nftext::nft_transfer_call(
                        owner,
                        caller,
                        ele.staked_id,
                        String::from("unstake"),
                        String::from("unstake"),
                    ); */
                    if ele.owner_id == caller {
                        nftext::nft_transfer(
                            owner.clone(),
                            caller.clone(),
                            ele.staked_id,
                            Some(1u64),
                            Some(String::from("memo")),
                            self.nft_account.clone(), // contract account id
                            0,                        // yocto NEAR to attach
                            env::prepaid_gas(),       // gas to attach
                        );
                    }
                });
            }
            None => {
                log!("You didn't stake any token at all.");
            }
        }
    }

    #[result_serializer(borsh)]
    pub fn claim(&self, token_id: TokenId) {
        let caller = env::predecessor_account_id();
        match self.staked.get(&caller) {
            Some(mut _staked) => {
                _staked.iter().for_each(|ele| {
                    /* nftext::nft_transfer_call(
                        owner,
                        caller,
                        ele.staked_id,
                        String::from("unstake"),
                        String::from("unstake"),
                    ); */
                    if ele.owner_id == caller {
                        ftext::ft_transfer(
                            env::predecessor_account_id(),
                            1_000_000_000_000_000_000u128.into(),
                            Some("claim".into()),
                            self.nft_account.clone(), // contract account id
                            1,                        // yocto NEAR to attach
                            env::prepaid_gas(),       // gas to attach
                        );
                    }
                });
            }
            None => {
                log!("You are not valid claimer.");
            }
        }
    }

    #[result_serializer(borsh)]
    pub fn get_claimable(&self, token_id: TokenId) -> u128 {
        let caller = env::predecessor_account_id();
        let current_timestamp = env::block_timestamp();
        let mut staked_timestamp = 0;
        match self.staked.get(&caller) {
            Some(mut _staked) => {
                _staked.iter().for_each(|ele| {
                    if ele.staked_id == token_id {
                        staked_timestamp = ele.timestamp;
                    }
                });
                (current_timestamp - staked_timestamp).into()
            }
            None => {
                log!("{}", "Cannot get claimable amount");
                0
            }
        }
    }

    pub fn transfer_money(&mut self, account_id: AccountId, amount: u64) {
        Promise::new(account_id).transfer(amount as u128);
    }
}

'''
'''--- Staking/tests/general.rs ---
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS,
    STORAGE_AMOUNT,
};
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_contract_standards::non_fungible_token::TokenId;
use near_contract_standards::non_fungible_token::Token;
use near_primitives::views::FinalExecutionStatus;
use near_primitives::transaction::{
    Action, AddKeyAction, CreateAccountAction, DeleteAccountAction, DeployContractAction,
    FunctionCallAction, SignedTransaction, TransferAction,
};
use near_units::parse_near;
use near_sdk::json_types::U128;
use near_sdk::ONE_YOCTO;
use workspaces::prelude::DevAccountDeployer;
use workspaces::{Account, Contract, DevNetwork, Worker};
extern crate cross_contract_high_level;
// Note: the struct xxxxxxContract is created by #[near_bindgen] from near-sdk in combination with
// near-sdk-sim
use cross_contract_high_level::CrossContractContract;

pub const TOKEN_ID: &str = "0";

/// # Note
/// 
/// Workspace-rs has a drawback, which a user cannot pass caller account explicitly.
/// This feature is important in NFTxxx.transfer_from() and NFTxxx.approve().
/// 
/// # TODO
/// 
/// Make test code using near_sdk_sim.

pub async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Contract, Contract, UserAccount, Account, Account)> {
    println!("***************************************************** 1");
    let nft_contract =
        worker.dev_deploy(include_bytes!("../../non-fungible-token/res/non_fungible_token.wasm").to_vec()).await?;

    let ft_contract =
        worker.dev_deploy(include_bytes!("../../fungible-token/res/fungible_token.wasm").to_vec()).await?;
    println!("nft, ft contract deployed.");

    println!("***************************************************** 2");
    let staking_contract = worker.dev_deploy(include_bytes!("../res/cross_contract_high_level.wasm").to_vec()).await?;
    println!("staking contract deployed.");

    let res = nft_contract
        .call(&worker, "new_default_meta")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    let res = nft_contract
        .as_account()
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("9 N"))
        .transact()
        .await?;
    println!("***************************************************** 4");
    assert!(matches!(res.details.status, FinalExecutionStatus::SuccessValue(_)));
    let alice = res.result;
    println!("subaccount alice created.");

    let res = nft_contract
        .as_account()
        .create_subaccount(&worker, "bob")
        .initial_balance(parse_near!("9 N"))
        .transact()
        .await?;
    assert!(matches!(res.details.status, FinalExecutionStatus::SuccessValue(_)));
    let bob = res.result;
    println!("subaccount bob created.");

    let mut genesis = near_sdk_sim::runtime::GenesisConfig::default();
    genesis.gas_limit = u64::MAX;
    genesis.gas_price = 0;
    let master_account = init_simulator(Some(genesis));
    println!("***************************************************** 5");
    let res = staking_contract
        .call(&worker, "new")
        .args_json((ft_contract.id(), nft_contract.id()))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    println!("Staking contract initialized.\nres: {:#?}", res);
    return Ok((staking_contract, nft_contract, ft_contract, master_account, alice, bob));
}

#[tokio::test]
async fn test_nft() -> anyhow::Result<()>  {
    let worker = workspaces::sandbox();
    let initial_balance = U128::from(parse_near!("9 N"));
    let (staking_contract, nft_contract, ft_contract, master_account, alice, bob) = init(&worker).await?;
    
    println!("***************************************************** 6");
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((alice.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 0);
    println!("alice has 0 token.");
    
    println!("***************************************************** 7");
    let token_metadata = TokenMetadata {
        title: Some("Olympus Mons".into()),
        description: Some("The tallest mountain in the charted solar system".into()),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };

    let res = nft_contract
        .call(&worker, "nft_mint")
        .args_json((TOKEN_ID, nft_contract.id(), token_metadata))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    println!("nft minted to nft contract.");

    println!("***************************************************** 8");
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 1);
    println!("nft contract has 1 token");
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "0".to_string());

    println!("***************************************************** 9");
    let res = ft_contract
        .call(&worker, "new_default_meta")
        .args_json((alice.id(), initial_balance))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;

    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    

    println!("***************************************************** 10");
    let res = ft_contract.call(&worker, "ft_total_supply").view().await?;
    assert_eq!(res.json::<U128>()?, initial_balance);

    let root_balance = ft_contract
        .call(&worker, "ft_balance_of")
        .args_json((nft_contract.id(),))?
        .view()
        .await?
        .json::<U128>()?;

    assert_eq!(root_balance, U128::from(parse_near!("0 N")));
    
    println!("***************************************************** 11");
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, staking_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    println!("nft contract approved staking contract.");

    let res = nft_contract
        .call(&worker, "nft_transfer")
        .args_json((
            alice.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("simple transfer".to_string()),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));
    println!("nft contract transfered his token to alice.");

    println!("***************************************************** 12");
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((alice.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 1);
    println!("alice has 1 token.");
    println!("res: {:#?}", owner_tokens);

    println!("***************************************************** 13");
    let nft_contract_account_id: workspaces::AccountId = nft_contract
        .as_account()
        .id()
        .to_string()
        .parse()?;

    let res = alice
        .call(&worker, nft_contract_account_id, "nft_approve")
        .args_json((TOKEN_ID, bob.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    println!("alice approved bob. \nres: {:#?}", res);

    
    println!("***************************************************** 14");
    let nft_contract_account_id: workspaces::AccountId = nft_contract
        .as_account()
        .id()
        .to_string()
        .parse()?;

    let res = alice
        .call(&worker, nft_contract_account_id, "nft_transfer")
        .args_json((
            bob.id(), 
            TOKEN_ID, 
            Option::<u64>::None,
            Some("simple transfer".to_string()),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    println!("alice transfered to bob. \nres: {:#?}", res);

    println!("***************************************************** 15");
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((bob.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    println!("bob has one token.");
    assert_eq!(owner_tokens.len(), 1);

    println!("***************************************************** 16");
    let nft_contract_account_id: workspaces::AccountId = nft_contract
        .as_account()
        .id()
        .to_string()
        .parse()?;

    let staking_contract_account_id: workspaces::AccountId = staking_contract
        .as_account()
        .id()
        .to_string()
        .parse()?;

    let res = bob
        .call(&worker, nft_contract_account_id, "nft_approve")
        .args_json((TOKEN_ID, staking_contract_account_id.clone(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    println!("bob approved staking contract.");
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    println!("***************************************************** 17");
    let nft_contract_account_id: workspaces::AccountId = nft_contract
        .as_account()
        .id()
        .to_string()
        .parse()?;
    
    let res = bob
        .call(&worker, staking_contract_account_id.clone(), "stake")
        .args_json((TOKEN_ID,))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;

    // let res = bob
    //     .call(&worker, staking_contract_account_id.clone(), "test_transfer")
    //     .args_json((bob.id(), staking_contract_account_id.clone(), TOKEN_ID, Option::<u64>::None, Option::<String>::None))?
    //     .gas(300_000_000_000_000)
    //     .transact()
    //     .await?;

    println!("staking result: {:#?}", res);

    println!("***************************************************** 18");
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((staking_contract_account_id, Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    println!("staking contract has one token.");
    // println!("{:#?}", owner_tokens);
    assert_eq!(owner_tokens.len(), 1);

    Ok(()) 
}

'''
'''--- Staking/tests/sim.rs ---
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS,
};
use near_units::parse_near;

extern crate fungible_token;
extern crate non_fungible_token;
extern crate cross_contract_high_level;

use fungible_token::ContractContract as FTContract;
use non_fungible_token::ContractContract as NFTContract;
use cross_contract_high_level::CrossContractContract;
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TOKEN_FT => "../fungible-token/res/fungible_token.wasm",
    TOKEN_NFT => "../non-fungible-token/res/non_fungible_token.wasm",
    TOKEN_STAKING => "res/cross_contract_high_level.wasm",
}

/// # Note
/// 
/// Tested mint, transfer, approve, transfer_from, and stake.
/// 
/// # TODO
/// 

fn init() -> (UserAccount, 
    UserAccount,
    UserAccount,
    ContractAccount<FTContract>, 
    ContractAccount<NFTContract>, 
    ContractAccount<CrossContractContract>) 
{
    let mut genesis = near_sdk_sim::runtime::GenesisConfig::default();
    genesis.gas_limit = u64::MAX;
    genesis.gas_price = 0;
    let root = init_simulator(Some(genesis));

    let alice = root.create_user(
        "alice".parse().unwrap(),
        to_yocto("100") // initial balance
    );

    let bob = root.create_user(
        "bob".parse().unwrap(),
        to_yocto("100") // initial balance
    );
    let ft_account = deploy! {
        contract: FTContract,
        contract_id: "ft_contract",
        bytes: &TOKEN_FT,
        signer_account: root
    };
    let nft_account = deploy! {
        contract: NFTContract,
        contract_id: "nft_contract",
        bytes: &TOKEN_NFT,
        signer_account: root,
        init_method: new_default_meta(root.account_id())
    };
    let staking_account = deploy! {
        contract: CrossContractContract,
        contract_id: "staking_contract",
        bytes: &TOKEN_STAKING,
        signer_account: root,
        init_method: new(ft_account.account_id(), nft_account.account_id())
    };
    (root, alice, bob, ft_account, nft_account, staking_account)
}

#[test]
fn test_sim_transfer() {
    let (root, alice, bob, ft_account, nft_account, staking_account ) = init();

    let token_metadata = TokenMetadata {
        title: Some("Olympus Mons".into()),
        description: Some("The tallest mountain in the charted solar system".into()),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };

    let res = call!(
        root,
        nft_account.nft_mint("0".parse().unwrap(), alice.account_id().clone(), token_metadata),
        parse_near!("7 mN"),
        DEFAULT_GAS
    );
    println!("");
    println!(" -- 1 :: {:?}", res);
    println!("*********** mint to alice succeed. ");

    let res = call!(
        alice,
        nft_account.nft_approve("0".parse().unwrap(), staking_account.account_id().clone(), Option::<String>::None),
        parse_near!("7 mN"),
        DEFAULT_GAS
    );
    println!("");
    println!(" -- 2 :: {:?}", res);
    println!("*********** alice approved to staking contract. ");

    let res = call!(
        staking_account.user_account,
        nft_account.nft_transfer(staking_account.account_id(), "0".parse().unwrap(), Option::<u64>::None, Option::<String>::None),
        1,
        DEFAULT_GAS
    );
    println!("");
    println!(" -- 3 :: {:?}", res);

    let res = call!(
        staking_account.user_account,
        nft_account.nft_transfer_from_to(staking_account.account_id(), bob.account_id(), "0".parse().unwrap(), Option::<u64>::None, Option::<String>::None),
        1,
        DEFAULT_GAS
    );
    println!("");
    println!(" -- 4 :: {:?}", res);
    println!("*********** transfer from staking contract to bob succeed. ");

    // let res = call!(
    //     bob,
    //     nft_account.nft_approve("0".parse().unwrap(), staking_account.account_id().clone(), Option::<String>::None),
    //     parse_near!("7 mN"),
    //     DEFAULT_GAS
    // );
    // println!("");
    // println!(" -- 5 :: {:?}", res);
    // println!("*********** bob approved staking contract. ");

    // let res = call!(
    //     staking_account.user_account,
    //     nft_account.nft_transfer_from_to(bob.account_id(), staking_account.account_id(), "0".parse().unwrap(), Option::<u64>::None, Option::<String>::None),
    //     1,
    //     DEFAULT_GAS
    // );
    let res = call!(
        bob,
        staking_account.stake("0".parse().unwrap()),
        0,
        DEFAULT_GAS
    );
    println!("");
    println!(" -- 5 :: {:?}", res);
    println!("*********** staking succeed.");

}

'''