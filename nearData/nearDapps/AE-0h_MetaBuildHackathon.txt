*GitHub Repository "AE-0h/MetaBuildHackathon"*

'''--- requirements.txt ---
# This file may be used to create an environment using:
# $ conda create --name <env> --file <this file>
# platform: linux-64
_libgcc_mutex=0.1=main
_openmp_mutex=4.5=1_gnu
aiohttp=3.8.1=pypi_0
aiosignal=1.2.0=pypi_0
antiorm=1.2.1=pypi_0
argcomplete=2.0.0=pypi_0
asttokens=2.0.5=pypi_0
async-timeout=4.0.1=pypi_0
asynctest=0.13.0=pypi_0
attrs=21.2.0=pypi_0
base58=2.1.1=pypi_0
bitarray=1.2.2=pypi_0
black=21.11b1=pypi_0
ca-certificates=2021.10.26=h06a4308_2
cached-property=1.5.2=pypi_0
certifi=2021.10.8=py39h06a4308_0
charset-normalizer=2.0.9=pypi_0
click=8.0.3=pypi_0
colorama=0.4.4=pypi_0
cytoolz=0.11.2=pypi_0
dataclassy=0.11.1=pypi_0
ed25519=1.5=pypi_0
eip712=0.1.0=pypi_0
eth-abi=2.1.1=pypi_0
eth-account=0.5.6=pypi_0
eth-brownie=1.17.2=pypi_0
eth-event=1.2.3=pypi_0
eth-hash=0.3.2=pypi_0
eth-keyfile=0.5.1=pypi_0
eth-keys=0.3.3=pypi_0
eth-rlp=0.2.1=pypi_0
eth-typing=2.2.2=pypi_0
eth-utils=1.10.0=pypi_0
execnet=1.9.0=pypi_0
executing=0.8.2=pypi_0
frozenlist=1.2.0=pypi_0
hexbytes=0.2.2=pypi_0
hypothesis=6.27.3=pypi_0
icecream=2.1.1=pypi_0
idna=3.3=pypi_0
importlib-metadata=4.8.2=pypi_0
inflection=0.5.0=pypi_0
iniconfig=1.1.1=pypi_0
ipfshttpclient=0.8.0a2=pypi_0
jsonschema=3.2.0=pypi_0
lazy-object-proxy=1.6.0=pypi_0
ld_impl_linux-64=2.35.1=h7274673_9
libffi=3.3=he6710b0_2
libgcc-ng=9.3.0=h5101ec6_17
libgomp=9.3.0=h5101ec6_17
libstdcxx-ng=9.3.0=hd4cf53a_17
lru-dict=1.1.7=pypi_0
multiaddr=0.0.9=pypi_0
multidict=5.2.0=pypi_0
mypy-extensions=0.4.3=pypi_0
mythx-models=1.9.1=pypi_0
ncurses=6.3=h7f8727e_2
near-api-py=0.1.0=pypi_0
netaddr=0.8.0=pypi_0
openssl=1.1.1l=h7f8727e_0
packaging=21.3=pypi_0
parsimonious=0.8.1=pypi_0
pathspec=0.9.0=pypi_0
pip=21.2.4=py39h06a4308_0
pipx=1.0.0=pypi_0
platformdirs=2.4.0=pypi_0
pluggy=1.0.0=pypi_0
prompt-toolkit=3.0.23=pypi_0
protobuf=3.19.1=pypi_0
psutil=5.8.0=pypi_0
py=1.11.0=pypi_0
py-solc-ast=1.2.9=pypi_0
py-solc-x=1.1.1=pypi_0
pycryptodome=3.12.0=pypi_0
pygments=2.10.0=pypi_0
pygments-lexer-solidity=0.7.0=pypi_0
pyjwt=1.7.1=pypi_0
pyparsing=3.0.6=pypi_0
pyrsistent=0.18.0=pypi_0
pytest=6.2.5=pypi_0
pytest-forked=1.3.0=pypi_0
pytest-xdist=1.34.0=pypi_0
python=3.9.7=h12debd9_1
python-dateutil=2.8.1=pypi_0
python-dotenv=0.16.0=pypi_0
pythx=1.6.1=pypi_0
pyyaml=5.4.1=pypi_0
readline=8.1.2=h7f8727e_0
regex=2021.11.10=pypi_0
requests=2.26.0=pypi_0
rlp=2.0.1=pypi_0
semantic-version=2.8.5=pypi_0
setuptools=58.0.4=py39h06a4308_0
six=1.16.0=pypi_0
sortedcontainers=2.4.0=pypi_0
sqlite=3.37.0=hc218d9a_0
tk=8.6.11=h1ccaba5_0
toml=0.10.2=pypi_0
tomli=1.2.2=pypi_0
toolz=0.11.2=pypi_0
tqdm=4.62.3=pypi_0
typed-ast=1.5.1=pypi_0
typing-extensions=3.10.0.2=pypi_0
tzdata=2021e=hda174b7_0
urllib3=1.26.7=pypi_0
userpath=1.7.0=pypi_0
varint=1.0.2=pypi_0
vvm=0.1.0=pypi_0
vyper=0.3.1=pypi_0
wcwidth=0.2.5=pypi_0
web3=5.25.0=pypi_0
websockets=9.1=pypi_0
wheel=0.37.1=pyhd3eb1b0_0
wrapt=1.13.3=pypi_0
xz=5.2.5=h7b6447c_0
yarl=1.7.2=pypi_0
zipp=3.6.0=pypi_0
zlib=1.2.11=h7f8727e_4

'''
'''--- res/aex_icon/aex_token_svg.html ---
<svg xmlns="http://www.w3.org/2000/svg" width="290.667" height="201.333" version="1.0" viewBox="0 0 218 151">
    <path
        d="M57,3.2c-15.4,2-25.4,4.7-35.8,9.4L16,15l5.7,11.5C25.2,33.5,28,38,29,38c.8,0,5.3-1.3,10-2.9C51.4,30.9,56.1,30,65,30c11.1,0,17,2.4,20.6,8.6,1.9,3.3,2.4,5.5,2.4,11.2,0,4.4-.5,7.4-1.2,7.8-.6.4-8.8,1.1-18.2,1.6-37,1.8-54.4,9.1-62.2,26.1-2.7,5.8-2.9,7-2.9,19.2,0,13,0,13,3.7,20.6,5.8,11.9,15.3,19.3,28,22,7,1.5,27.7.6,35.3-1.5,10.5-3,20.9-9.5,28.7-18l4.7-5.1,7,7.1c7.3,7.3,15.9,12.4,27.1,16.1,8,2.6,39.3,2.6,50-.1,13.1-3.2,19.1-5.7,20.1-8.3,1-2.7,1.3-24.6.3-25.6-.3-.3-2.9.3-5.8,1.5-13.4,5.3-28.3,8.1-41.6,7.6-9.6-.3-11.2-.6-17.2-3.6-10.2-5-16.5-14.4-17.5-26.3l-.6-5.9,4.4-.1c2.4-.1,22.9-.2,45.4-.3l41-.1-.1-15.6c0-23.3-4.2-36.3-15.6-48.4C191,9.9,180.1,4.9,163.3,3.1c-17.4-1.9-34,2.4-46.4,12.1-2,1.5-4.2,2.8-4.9,2.8-.7,0-2.8-1.4-4.7-3-4-3.6-11.9-7.7-18.2-9.6C84.2,4,67.8,1.9,64.5,2.2c-1.1.1-4.5.6-7.5,1zm109.5,27.7c8.9,4,15.3,14.8,15.5,25.8V60h-55v-3.9c0-11.8,8-22.8,19-26.2,4.9-1.5,16.3-.9,20.5,1zM87.8,88.8c.4,10.9-1.5,17.5-6.8,23.4-5.8,6.6-11.1,8.8-21.2,8.8-9.2,0-13.2-1.6-16.5-6.7-2.7-4.1-2.5-17.6.4-22.1,5.4-8.6,15.7-12.1,34.8-11.8l9,.1.3,8.3z" />
</svg>
'''
'''--- scripts/meta2ipfs_local.py ---
"""deploy Metadata on IPFS"""

import requests
import argparse

def upload2ipfs(file_path: str) -> str:
    """Upload to ipfs using local port.
    IPFS node must be running locally. Run:
    $ ipfs daemon

    Args:
        nft_path (str): path to metadata file
    """
    with open(file_path, "rb") as f:
        nft_binary = f.read()
    ipfs_endpoint = "http://127.0.0.1:5001/"
    api = "api/v0/add"
    nft_name = file_path.split("/")[-1:][0]
    ipfs_hash = requests.post(ipfs_endpoint + api, files={"from": nft_binary}).json()[
        "Hash"
    ]
    nft_uri = f"https://ipfs.io/ipfs/{ipfs_hash}?filename={nft_name}"
    print("IPFS address: ", nft_uri)
    return nft_uri

if __name__ == "__main__":
    """Main App.
    Runs upload2ipfs function.
    """
    parser = argparse.ArgumentParser(description="Get Metadata path.")
    parser.add_argument(
        "meta-path", metavar="meta", type=str, help="an integer for the accumulator"
    )
    args = parser.parse_args()
    meta_path = args["meta-pass"]
    url = upload2ipfs(meta_path)
    print(url)

'''
'''--- scripts/utils.py ---
"""Helper functions
"""

from code import interact
import string
from brownie import (
    ETH_ADDRESS,
    accounts,
    network,
    interface,
    config,
    Contract,
)
from brownie.network.contract import ProjectContract, ContractTx
from brownie.network.transaction import TransactionReceipt
from eth_account import Account
from eth_typing import Address
import eth_utils
from icecream import ic

DECIMALS = 8
START_PRICE = 20e11
LOCAL_BLOCKCHAINS = ["development", "ganachewin11"]
FORKED_LOCAL_CHAIN = ["mainnet-fork", "dev-fork"]

def get_account(acc_idx: int = 0, brownie_id: int = None) -> str:
    """Checks for network and returns account public key.
    if on Ganache, the native generated first account ist returned.
    On testnet, the account stored in .env.

    Args:
        acc_idx[int]: index of the local account. Default is the first one.
        bronie_id[int]: Id of the account stored in brownie.
    """
    net = network.show_active()
    print("WTF mate?! You're sailing on the {} networq!".format(net))

    if brownie_id:
        return accounts.load(brownie_id)

    if net in LOCAL_BLOCKCHAINS + FORKED_LOCAL_CHAIN:
        ic(accounts[acc_idx])
        return accounts[acc_idx]
    else:
        return accounts.add(config["wallets"]["from_key"])

def get_contract(c_name: string) -> ProjectContract:
    """Returs the contract defined in brownie config.
    If no contract is defined, a moch version is deployed.

    Args:
        c_name (string): contract name

    Returns:
        ProjectContract: most recent deployed contract or mock.
    """
    c_map = {}  # TODO fill in the brownie contracts here

    c_type = c_map[c_name]
    net = network.show_active()

    if net in LOCAL_BLOCKCHAINS:
        if len(c_type) <= 0:
            # MockV3Aggregator.length
            # deploy_mocks()
            pass
        contract = c_type[-1]
    else:
        c_address = config["networks"][net][c_name]
        contract = Contract.from_abi(c_type._name, c_address, c_type.abi)

    return contract

# def deploy_mocks():
#     """Deploy MockV3Aggregator"""
#     acc = get_account()
#     MockV3Aggregator.deploy(DECIMALS, START_PRICE, {"from": acc})
#     print("Deployed MockV3Agg!")
#     link_mock = LinkToken.deploy({"from": acc})
#     print("Deployed LinkMock!")
#     vrf = (VRFCoordinatorMock.deploy(link_mock.address, {"from": acc}),)
#     print("Deployed VRF!")
#     # fund_link(vrf, acc, link_mock)
#     # print("Funded VRF1")

def fund_link(
    c_address: Address,
    acc: Account = None,
    token: Address = None,
    value: int = 10 ** 17,
):
    """Fund the given contract with certain ammount of token.

    Args:
        c_address (Address): contract address
        acc (Account, optional): Emmitting account. Defaults to None.
        link (Address, optional): Toke address. Defaults to None.
        value (int, optional): Value to be transferes. Defaults to 10**17.

    Returns:
        Transaction confirmation
    """
    acc = acc if acc else get_account()
    token = token if token else get_contract("link")
    # tx = token.transfer(c_address, value+111, {"from": acc})
    link_interface = interface.LinkTokenInterface(token.address)
    tx = link_interface.transfer(c_address, value, {"from": acc})
    tx.wait(1)
    print("Funded contract!")

    return tx

def encode_function_data(initializer: ContractTx = None, *args) -> bytes:
    """Encode data to init a contract through a proxy.
    The initializer is the function we want to call when deploying that contract.
    Proxies have no constructor, thus the initializer.
    Args:
        initializer ([ContractTx], optional): The init function we want to call. Defaults to None.

    Returns:
        bytes: the bytes code of the function.
    """
    if len(args) == 0 or not initializer:
        return eth_utils.to_bytes(hexstr="0x")
    return initializer.encode_input(*args)

def upgrade_contract(
    acc: Account,
    proxy: Contract,
    new_address: Address,
    proxy_admin_contract: Contract = None,
    initializer: ContractTx = None,
    *args
) -> TransactionReceipt:
    """Uprage a contract trough its proxy.

    Args:
        acc (Account): Your account
        proxy (Contract): The proxy contract
        new_address (Address): The adress of the new contract
        proxy_admin_contract (Contract, optional): The Admin contract if aplicable. Defaults to None.
        initializer (ContractTx, optional): Init function to call when deploying. Defaults to None.

    Returns:
        TransactionReceipt: The receipt of deployment, including new address.
    """
    tx = None
    args_list = [new_address, {"from": acc}]

    if initializer:
        encoded_init = encode_function_data(initializer, *args)
        args_list.insert(1, encoded_init)

        if proxy_admin_contract:
            args_list.insert(0, proxy.address)
            tx = proxy_admin_contract.upgradeAndCall(*args_list)

        else:
            tx = proxy.upgradeToAndCall(*args_list)

    else:
        if proxy_admin_contract:
            args_list.insert(0, proxy.address)
            tx = proxy_admin_contract.upgrade(*args_list)

        else:
            tx = proxy.upgradeTo(*args_list)

    return tx

'''
'''--- tests/test_env.py ---
from brownie import ETH_ADDRESS, accounts

def test_brownie():
    """Test if the brownie module is working.
    """
    acc = accounts[0]
    assert type(acc.address) == str

'''
'''--- tests/test_ipfs.py ---
import time
from scripts.meta2ipfs import upload2ipfs

import json
import requests
import os

# def test_ipfs():
#     """Test the upload to IPFS."""
#     # Assign
#     meta_path = "res/meta/metadata_template.json"
#     os.system('cmd /k ipfs deamon')
#     url = upload2ipfs(meta_path)
#     # Arrange
#     answer = requests.get(url)

#     # Assert
#     with open(meta_path, "r") as f:
#         meta_json = json.load(f)
#         assert meta_json == answer.json()

'''