*GitHub Repository "near/abomonation_derive"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .travis.yml ---
language: rust
rust:
- nightly
sudo: false
notifications:
  email:
    on_success: never

'''
'''--- Cargo.toml ---
[package]
name = "abomonation_derive"
version = "0.5.0"
authors = ["Nika Layzell <nika@thelayzells.com>"]
description = "A custom derive plugin for abomonation"
license = "MIT"
repository = "https://github.com/mystor/abomonation_derive"
documentation = "https://docs.rs/abomonation_derive"
edition = "2018"

[lib]
name = "abomonation_derive"
proc-macro = true

[dependencies]
proc-macro2 = "1.0"
quote = "1.0"
synstructure = "0.12"

[dev-dependencies]
abomonation = "0.7"

'''
'''--- src/lib.rs ---
#![recursion_limit="128"]

use synstructure::decl_derive;
use quote::quote;

decl_derive!([Abomonation, attributes(unsafe_abomonate_ignore)] => derive_abomonation);

fn derive_abomonation(mut s: synstructure::Structure) -> proc_macro2::TokenStream {
    s.filter(|bi| {
        !bi.ast().attrs.iter()
            .map(|attr| attr.parse_meta())
            .filter_map(Result::ok)
            .any(|attr| attr.path().is_ident("unsafe_abomonate_ignore"))
    });

    let entomb = s.each(|bi| quote! {
        ::abomonation::Abomonation::entomb(#bi, _write)?;
    });

    let extent = s.each(|bi| quote! {
        sum += ::abomonation::Abomonation::extent(#bi);
    });

    s.bind_with(|_| synstructure::BindStyle::RefMut);

    let exhume = s.each(|bi| quote! {
        let temp = bytes;
        bytes = ::abomonation::Abomonation::exhume(#bi, temp)?;
    });

    s.bound_impl(quote!(abomonation::Abomonation), quote! {
        #[inline] unsafe fn entomb<W: ::std::io::Write>(&self, _write: &mut W) -> ::std::io::Result<()> {
            match *self { #entomb }
            Ok(())
        }
        #[allow(unused_mut)]
        #[inline] fn extent(&self) -> usize {
            let mut sum = 0;
            match *self { #extent }
            sum
        }
        #[allow(unused_mut)]
        #[inline] unsafe fn exhume<'a,'b>(
            &'a mut self,
            mut bytes: &'b mut [u8]
        ) -> Option<&'b mut [u8]> {
            match *self { #exhume }
            Some(bytes)
        }
    })
}

'''
'''--- tests/test.rs ---
#![deny(unused_mut)]

#[macro_use]
extern crate abomonation_derive;

#[cfg(test)]
mod tests {
    use abomonation::*;

    #[derive(Eq, PartialEq, Abomonation)]
    pub struct Struct {
        a: String,
        b: u64,
        c: Vec<u8>,
    }

    #[test]
    fn test_struct() {
        // create some test data out of abomonation-approved types
        let record = Struct { a: "test".to_owned(), b: 0, c: vec![0, 1, 2] };

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<Struct>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[derive(Eq, PartialEq, Abomonation)]
    pub struct EmptyStruct;

    #[test]
    fn test_empty_struct() {
        // create some test data out of abomonation-approved types
        let record = EmptyStruct;

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<EmptyStruct>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[derive(Eq, PartialEq, Abomonation)]
    pub struct TupleStruct(String, u64, Vec<u8>);

    #[test]
    fn test_tuple_struct() {
        // create some test data out of abomonation-approved types
        let record = TupleStruct("test".to_owned(), 0, vec![0, 1, 2]);

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<TupleStruct>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[derive(Eq, PartialEq, Abomonation)]
    pub struct GenericStruct<T, U>(T, u64, U);

    #[test]
    fn test_generic_struct() {
        // create some test data out of abomonation-approved types
        let record = GenericStruct("test".to_owned(), 0, vec![0, 1, 2]);

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<GenericStruct<String, Vec<u8>>>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[allow(dead_code)]
    #[derive(Eq, PartialEq, Abomonation)]
    pub enum BasicEnum {
        Apples,
        Pears,
        Chicken
    }

    #[test]
    fn test_basic_enum() {
        // create some test data out of abomonation-approved types
        let record = BasicEnum::Apples;

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<BasicEnum>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[allow(dead_code)]
    #[derive(Eq, PartialEq, Abomonation)]
    pub enum DataEnum {
        A(String, u64, Vec<u8>),
        B,
        C(String, String, String)
    }

    #[test]
    fn test_data_enum() {
        // create some test data out of abomonation-approved types
        let record = DataEnum::A("test".to_owned(), 0, vec![0, 1, 2]);

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<DataEnum>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    #[derive(Eq, PartialEq, Abomonation)]
    pub struct Nested {
        d: DataEnum,
        s: Struct,
    }

    #[test]
    fn test_nested() {
        // create some test data out of abomonation-approved types
        let d = DataEnum::A("test".to_owned(), 0, vec![0, 1, 2]);
        let s = Struct { a: "foo".to_owned(), b: 1, c: vec![3, 4, 5] };
        let record = Nested {d, s};

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<Nested>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }

    pub trait SomeTrait {}

    #[allow(dead_code)]
    #[derive(Abomonation)]
    pub enum GenericEnumWithBounds<T: SomeTrait> {
        A(T),
        B
    }

    #[test]
    fn test_ignore_attribute() {

        #[derive(Abomonation)]
        pub struct StructWithPhantomMarker<T> {
            data: usize,
            // test fails to built without this attribute.
            #[unsafe_abomonate_ignore]
            _phantom: ::std::marker::PhantomData<T>,
        }

        struct NonAbomonable { };

        // create some test data with a phantom non-abomonable type.
        let record = StructWithPhantomMarker {
            data: 0,
            _phantom: ::std::marker::PhantomData::<NonAbomonable>,
        };

        // encode vector into a Vec<u8>
        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));
    }

    #[derive(Abomonation, Eq, PartialEq)]
    pub struct StructUsingCratePath {
        pub header: crate::tests::EmptyStruct,
    }

    #[test]
    fn test_path_beginning_with_crate() {
        let record = StructUsingCratePath { header: EmptyStruct {} };

        let mut bytes = Vec::new();
        unsafe { encode(&record, &mut bytes).unwrap(); }

        assert_eq!(bytes.len(), measure(&record));

        // decode from binary data
        if let Some((result, rest)) = unsafe { decode::<StructUsingCratePath>(&mut bytes) } {
            assert!(result == &record);
            assert!(rest.len() == 0);
        }
    }
}

'''