*GitHub Repository "near-examples/cross-contract-calls"*

'''--- .devcontainer/devcontainer.json ---
{
  "image": "mcr.microsoft.com/devcontainers/universal:2",
  "features": {
    "ghcr.io/devcontainers/features/rust:1": {},
    "ghcr.io/devcontainers/features/node:1": {
      "version":"20"
    }
  }
  
}

'''
'''--- .github/workflows/tests-advanced-rs.yml ---
name: Tests Contract Advanced RS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install and test modules
        run: |
          cd ./contract-advanced-rs
          cargo test

'''
'''--- .github/workflows/tests-advanced-ts.yml ---
name: Tests Contract Advanced TS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "18"
      - name: Install and test modules
        run: |
          cd ./contract-advanced-ts
          yarn
          yarn test

'''
'''--- .github/workflows/tests-simple-rs.yml ---
name: Tests Contract Simple RS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install and test modules
        run: |
          cd ./contract-simple-rs
          cargo test

'''
'''--- .github/workflows/tests-simple-ts.yml ---
name: Tests Contract Simple TS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "18"
      - name: Install and test modules
        run: |
          cd ./contract-simple-ts
          yarn
          yarn test

'''
'''--- README.md ---
# Cross-Contract Call Examples ðŸ‘‹ 
[![](https://img.shields.io/badge/â‹ˆ%20Examples-Basics-green)](https://docs.near.org/tutorials/welcome)
[![](https://img.shields.io/badge/Contract-JS-yellow)](contract-ts)
[![](https://img.shields.io/badge/Contract-Rust-red)](contract-rs)
[![](https://img.shields.io/badge/Frontend-JS-yellow)](frontend)
![example workflow](https://github.com/near-examples/cross-contract-calls/actions/workflows/tests-ts.yml/badge.svg)
![example workflow](https://github.com/near-examples/cross-contract-calls/actions/workflows/tests-rs.yml/badge.svg)

This repository contains examples on how to perform cross-contract calls in both JavaScript and Rust.

- [contract-simple-rs](contract-simple-rs) - Rust example
- [contract-simple-ts](contract-simple-ts) - JavaScript example
- [contract-advanced-rs](contract-advanced-rs) - Rust advanced example
- [contract-advanced-ts](ccontract-advanced-ts) - JavaScript advanced example

<br />

# What These Examples Show

1. How to make cross contract call and handle their responses information in the NEAR network.
2. How to handle their responses.

<br />

# Learn More
1. Learn more about the contract through its [README](./contract-ts/README.md).
2. Check [**our documentation**](https://docs.near.org/tutorials/examples/xcc).

'''
'''--- contract-advanced-rs/Cargo.toml ---
[package]
name = "cross_contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
near-sdk = "5.1.0"
schemars = "0.8.16"

[dev-dependencies]
near-sdk = { version = "5.0.0", features = ["unit-testing"] }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract-advanced-rs/README.md ---
# Complex Cross-Contract Calls Examples

This contract presents 3 examples on how to do complex cross-contract calls. Particularly, it shows:

1. How to batch method calls to a same contract.
2. How to call multiple contracts in parallel, each returning a different type.
3. Different ways of handling the responses in the callback.

## How to Build Locally?

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near build
```

## How to Test Locally?

```bash
cargo test
```

## How to Deploy?

To deploy manually, install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# Create a new account
cargo near create-dev-account

# Deploy the contract on it
cargo near deploy <account-id>
```

## CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Replace <your-account.testnet> with your account ID
# Call batch_actions method
near call <your-account.testnet> batch_actions --gas 300000000000000 --accountId <your-account.testnet>

# Call multiple_contracts method
near call <your-account.testnet> multiple_contracts --gas 300000000000000 --accountId <your-account.testnet>

# Call similar_contracts method
near call <your-account.testnet> similar_contracts --gas 300000000000000 --accountId <your-account.testnet>
```

# Useful Links

- [cargo-near](https://github.com/near/cargo-near) - NEAR smart contract development toolkit for Rust
- [near CLI](https://near.cli.rs) - Interact with NEAR blockchain from command line
- [NEAR Rust SDK Documentation](https://docs.near.org/sdk/rust/introduction)
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub), [Twitter](https://twitter.com/neardevhub)
'''
'''--- contract-advanced-rs/rust-toolchain.toml ---
[toolchain]
channel = "stable"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]
'''
'''--- contract-advanced-rs/src/batch_actions.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::{env, log, near, serde_json::json, Promise, PromiseError};

use crate::{Contract, ContractExt, NO_ARGS, NO_DEPOSIT, XCC_GAS};

#[near]
impl Contract {
    pub fn batch_actions(&mut self) -> Promise {
        let hi = json!({ "greeting": "hi" }).to_string().into_bytes();
        let bye = json!({ "greeting": "bye" }).to_string().into_bytes();

        // You can create one transaction calling multiple methods
        // on a same contract
        Promise::new(self.hello_account.clone())
            .function_call("set_greeting".to_owned(), hi, NO_DEPOSIT, XCC_GAS)
            .function_call("get_greeting".to_owned(), NO_ARGS, NO_DEPOSIT, XCC_GAS)
            .function_call("set_greeting".to_owned(), bye, NO_DEPOSIT, XCC_GAS)
            .function_call("get_greeting".to_owned(), NO_ARGS, NO_DEPOSIT, XCC_GAS)
            .then(Self::ext(env::current_account_id()).batch_actions_callback())
    }

    #[private]
    pub fn batch_actions_callback(
        &self,
        #[callback_result] last_result: Result<String, PromiseError>,
    ) -> String {
        // The callback only has access to the last action's result
        if let Ok(result) = last_result {
            log!(format!("The last result is {result}"));
            result
        } else {
            log!("The batch call failed and all calls got reverted");
            "".to_string()
        }
    }
}

'''
'''--- contract-advanced-rs/src/lib.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::{near, AccountId, Gas, NearToken};

mod batch_actions;
mod multiple_contracts;
mod similar_contracts;

const XCC_GAS: Gas = Gas::from_tgas(10);
const NO_DEPOSIT: NearToken = NearToken::from_near(0);
const NO_ARGS: Vec<u8> = vec![];
const HELLO_CONTRACT: &str = "hello.near-examples.testnet";
const COUNTER_CONTRACT: &str = "counter.near-examples.testnet";
const GUESTBOOK_CONTRACT: &str = "guestbook.near-examples.testnet";

// Define the contract structure
#[near(contract_state)]
pub struct Contract {
    pub hello_account: AccountId,
    pub counter_account: AccountId,
    pub guestbook_account: AccountId,
}

impl Default for Contract {
    fn default() -> Self {
        Self {
            hello_account: HELLO_CONTRACT.parse().unwrap(),
            counter_account: COUNTER_CONTRACT.parse().unwrap(),
            guestbook_account: GUESTBOOK_CONTRACT.parse().unwrap(),
        }
    }
}

#[near]
impl Contract {
    #[init]
    #[private]
    pub fn init(
        hello_account: AccountId,
        counter_account: AccountId,
        guestbook_account: AccountId,
    ) -> Self {
        Self {
            hello_account,
            counter_account,
            guestbook_account,
        }
    }
}

'''
'''--- contract-advanced-rs/src/multiple_contracts.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::{env, log, near, serde_json::json, Promise, PromiseError};

use crate::{Contract, ContractExt, NO_ARGS, NO_DEPOSIT, XCC_GAS};

#[near(serializers=[borsh, json])]
#[derive(Debug)]
pub struct PostedMessage {
    pub premium: bool,
    pub sender: String,
    pub text: String,
}

#[near]
impl Contract {
    /// A method which calls different contracts via cross contract function calls.
    pub fn multiple_contracts(&mut self) -> Promise {
        // We create a promise that calls the `get_greeting` function on the HELLO_CONTRACT
        let hello_promise = Promise::new(self.hello_account.clone()).function_call(
            "get_greeting".to_owned(),
            NO_ARGS,
            NO_DEPOSIT,
            XCC_GAS,
        );

        // We create a promise that calls the `get_num` function on the COUNTER_CONTRACT
        let counter_promise = Promise::new(self.counter_account.clone()).function_call(
            "get_num".to_owned(),
            NO_ARGS,
            NO_DEPOSIT,
            XCC_GAS,
        );

        // We create a promise that calls the `get_messages` function on the GUESTBOOK_CONTRACT
        let args = json!({ "from_index": "0", "limit": 2 })
            .to_string()
            .into_bytes();

        let guestbook_promise = Promise::new(self.guestbook_account.clone()).function_call(
            "get_messages".to_owned(),
            args,
            NO_DEPOSIT,
            XCC_GAS,
        );

        // We join all promises and chain a callback to collect their results.
        hello_promise
            .and(counter_promise)
            .and(guestbook_promise)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(XCC_GAS)
                    .multiple_contracts_callback(),
            )
    }

    #[private]
    pub fn multiple_contracts_callback(
        &self,
        #[callback_result] hello_result: Result<String, PromiseError>,
        #[callback_result] counter_result: Result<i8, PromiseError>,
        #[callback_result] guestbook_result: Result<Vec<PostedMessage>, PromiseError>,
    ) -> (String, i8, Vec<PostedMessage>) {
        // The callback has access to the result of the 3 calls
        let greeting = if let Ok(result) = hello_result {
            log!(format!("HelloNear says {result}"));
            result
        } else {
            log!("The call to HelloNear failed");
            "".to_string()
        };

        let counter = if let Ok(result) = counter_result {
            log!(format!("Counter is {result}"));
            result
        } else {
            log!("The call to Counter failed");
            0
        };

        let messages = if let Ok(result) = guestbook_result {
            log!(format!("The messages are {result:?}"));
            result
        } else {
            log!("The call to GuestBook failed");
            vec![]
        };

        (greeting, counter, messages)
    }
}

'''
'''--- contract-advanced-rs/src/similar_contracts.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::{env, log, near, serde_json::json, Promise, PromiseResult};

use crate::{Contract, ContractExt, NO_ARGS, NO_DEPOSIT, XCC_GAS};

#[near]
impl Contract {
    fn promise_set_get(&self, message: &str) -> Promise {
        // Aux method to create a batch transaction calling
        // set_message and get_message in the HELLO CONTRACT
        let args = json!({ "greeting": message }).to_string().into_bytes();

        Promise::new(self.hello_account.clone())
            .function_call("set_greeting".to_owned(), args, NO_DEPOSIT, XCC_GAS)
            .function_call("get_greeting".to_owned(), NO_ARGS, NO_DEPOSIT, XCC_GAS)
    }

    pub fn similar_contracts(&mut self) -> Promise {
        // Create promises to call 3 contracts that return the same type
        // For simplicity here we call the same contract
        let hello_one = self.promise_set_get("hi");
        let hello_two = self.promise_set_get("howdy");
        let hello_three = self.promise_set_get("bye");

        // Join all promises and chain a callback to collect their results.
        hello_one.and(hello_two).and(hello_three).then(
            Self::ext(env::current_account_id())
                .with_static_gas(XCC_GAS)
                .similar_contracts_callback(3),
        )
    }

    #[private]
    pub fn similar_contracts_callback(&self, number_promises: u64) -> Vec<String> {
        (0..number_promises)
            .filter_map(|index| {
                // env::promise_result(i) has the result of the i-th call
                let result = env::promise_result(index);

                match result {
                    PromiseResult::Failed => {
                        log!(format!("Promise number {index} failed."));
                        None
                    }
                    PromiseResult::Successful(value) => {
                        if let Ok(message) = near_sdk::serde_json::from_slice::<String>(&value) {
                            log!(format!("Call {index} returned: {message}"));
                            Some(message)
                        } else {
                            log!(format!("Error deserializing call {index} result."));
                            None
                        }
                    }
                }
            })
            .collect()
    }
}

'''
'''--- contract-advanced-rs/tests/tests.rs ---
use std::string::String;
use serde_json::json;
use near_workspaces::{types::NearToken, Account, Contract};
use near_sdk::serde::{Deserialize, Serialize};
 
#[tokio::test]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let worker = near_workspaces::sandbox().await?;
    // Deploy hello contract
    let hello_contract_wasm = std::fs::read("./tests/external-contracts/hello-near.wasm")?;
    let hello_contract = worker.dev_deploy(&hello_contract_wasm).await?;
    // Deploy guest-book contract
    let guest_book_contract_wasm = std::fs::read("./tests/external-contracts/guest-book.wasm")?;
    let guest_book_contract = worker.dev_deploy(&guest_book_contract_wasm).await?;
    // Deploy counter contract
    let counter_contract_wasm = std::fs::read("./tests/external-contracts/counter.wasm")?;
    let counter_contract = worker.dev_deploy(&counter_contract_wasm).await?;
    // Deploy contract for testing
    let contract_wasm = near_workspaces::compile_project("./").await?;
    let contract = worker.dev_deploy(&contract_wasm).await?;
 
    // Create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount("alice")
        .initial_balance(NearToken::from_near(30))
        .transact()
        .await?
        .into_result()?;

    // Init contract
    let _ = contract
        .call("init")
        .args_json(json!({
          "hello_account": hello_contract.id(),
          "guestbook_account": guest_book_contract.id(),
          "counter_account": counter_contract.id(),
        }))
        .transact()
        .await?
        .into_result()?;
 
    // Begin tests
    test_multiple_contracts(&alice, &contract, &hello_contract, &guest_book_contract, &counter_contract).await?;
    test_similar_contracts(&alice, &contract).await?;
    test_batch_actions(&alice, &contract).await?;
    Ok(())
}

async fn test_multiple_contracts(
    user: &Account,
    contract: &Contract,
    hello_contract: &Contract,
    guest_book_contract: &Contract,
    counter_contract: &Contract
) -> Result<(), Box<dyn std::error::Error>> {
    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessage {
        pub premium: bool,
        pub sender: String,
        pub text: String,
    }

    let expected_messages = vec![PostedMessage {
        premium: false,
        sender: user.id().to_string(),
        text: "my message".parse().unwrap(),
    }];

    let _ = user
        .call(hello_contract.id(), "set_greeting")
        .args_json(json!({ "greeting": "Howdy" }))
        .max_gas()
        .transact()
        .await?;

    let _ = user
        .call(guest_book_contract.id(), "add_message")
        .args_json(json!({ "text": "my message" }))
        .max_gas()
        .transact()
        .await?;

    let _ = user
        .call(counter_contract.id(), "decrement")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?;

    let result: (String, i8, Vec<PostedMessage>) = user
        .call(contract.id(), "multiple_contracts")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .json()?;
 
    assert_eq!(result.0, "Howdy".to_string());
    assert_eq!(result.1, -1);
    assert_eq!(result.2, expected_messages);
    Ok(())
}

async fn test_similar_contracts(
  user: &Account,
  contract: &Contract
) -> Result<(), Box<dyn std::error::Error>> {
  let expected: Vec<String> = vec![
      "hi".parse().unwrap(),
      "howdy".parse().unwrap(),
      "bye".parse().unwrap()
  ];

  let result: Vec<String> = user
      .call(contract.id(), "similar_contracts")
      .args_json(json!({}))
      .max_gas()
      .transact()
      .await?
      .json()?;

  assert_eq!(result, expected);
  Ok(())
}

async fn test_batch_actions(
  user: &Account,
  contract: &Contract
) -> Result<(), Box<dyn std::error::Error>> {
  let expected: String = "bye".parse().unwrap();
  let result: String = user
      .call(contract.id(), "batch_actions")
      .args_json(json!({}))
      .max_gas()
      .transact()
      .await?
      .json()?;

  assert_eq!(result, expected);
  Ok(())
}
'''
'''--- contract-advanced-ts/README.md ---
# Complex Cross-Contract Calls Examples

This contract presents 3 examples on how to do complex cross-contract calls. Particularly, it shows:

1. How to batch method calls to a same contract.
2. How to call multiple contracts in parallel, each returning a different type.
3. Different ways of handling the responses in the callback.

<br />

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

## 1. Build and Test the Contract
You can automatically compile and test the contract by running:

```bash
# To solely build the contract
npm run build

# To build and execute the contract's tests
npm run test
```

## 2. Create an Account and Deploy the Contract
You can create a new account and deploy the contract by running:

```bash
near create-account <your-account.testnet> --useFaucet

near deploy <your-account.testnet> ./build/cross_contract.wasm init '{"hello_account":"hello.near-example.testnet", "counter_account":"counter.near-example.testnet", "guestbook_account":"guestbook.near-example.testnet"}' 
```

<br />

## 3. CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Replace <your-account.testnet> with your account ID
# Call batch_actions method
near call <your-account.testnet> batch_actions --gas 300000000000000 --accountId <your-account.testnet>

# Call multiple_contracts method
near call <your-account.testnet> multiple_contracts --gas 300000000000000 --accountId <your-account.testnet>

# Call similar_contracts method
near call <your-account.testnet> similar_contracts --gas 300000000000000 --accountId <your-account.testnet>
```

<br />

# Useful Links

- [near CLI](https://near.cli.rs) - Interact with NEAR blockchain from command line
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub), [Twitter](https://twitter.com/neardevhub)
'''
'''--- contract-advanced-ts/package.json ---
{
  "name": "contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/cross_contract.wasm",
    "test": "$npm_execpath build && ava -- ./build/cross_contract.wasm"
  },
  "dependencies": {
    "near-cli": "^4.0.10",
    "near-sdk-js": "1.0.0"
  },
  "devDependencies": {
    "@ava/typescript": "^4.1.0",
    "ava": "^6.1.2",
    "near-workspaces": "^3.5.0",
    "ts-morph": "^22.0.0",
    "ts-node": "^10.9.2",
    "tsimp": "^2.0.11",
    "typescript": "^5.4.2"
  }
}

'''
'''--- contract-advanced-ts/sandbox-ts/main.ava.ts ---
import { Worker, NearAccount } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { setDefaultResultOrder } from 'dns'; setDefaultResultOrder('ipv4first'); // temp fix for node >v17

// Global context
const test = anyTest as TestFn<{ worker: Worker, accounts: Record<string, NearAccount> }>;

type PremiumMessage = { premium: boolean; sender: string; text: string };

test.beforeEach(async (t) => {
  // Create sandbox, accounts, deploy contracts, etc.
  const worker = t.context.worker = await Worker.init();

  // Get root account
  const root = worker.rootAccount;

  // Create test accounts
  const alice = await root.createSubAccount("alice");
  const xcc = await root.createSubAccount("xcc");
  const helloNear = await root.createSubAccount("hello-near");
  const guestBook = await root.createSubAccount("guest-book");
  const counter = await root.createSubAccount("counter");

  // Deploy external contracts
  await helloNear.deploy("./sandbox-ts/external-contracts/hello-near.wasm");
  await guestBook.deploy("./sandbox-ts/external-contracts/guest-book.wasm");
  await counter.deploy("./sandbox-ts/external-contracts/counter.wasm");

  // Deploy the xcc contract
  await xcc.deploy(process.argv[2]);
  await xcc.call(xcc, "init", {
    hello_account: helloNear.accountId,
    counter_account: counter.accountId,
    guestbook_account: guestBook.accountId,
  });

  // Save state for test runs, it is unique for each test
  t.context.accounts = {
    xcc,
    alice,
    helloNear,
    counter,
    guestBook,
  };
});

test.afterEach.always(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed tear down the worker:", error);
  });
});

test("multiple_contract", async (t) => {
  const { xcc, alice, helloNear, counter, guestBook } = t.context.accounts;

  await alice.call(counter, "decrement", {});
  await alice.call(helloNear, "set_greeting", { greeting: "Howdy" });
  await alice.call(
    guestBook,
    "add_message",
    { text: "my message" },
    { gas: "40000000000000" }
  );

  const results: [string, string, [PremiumMessage]] = await alice.call(
    xcc,
    "multiple_contracts",
    {},
    { gas: "300000000000000" }
  );

  const expected = {
    premium: false,
    sender: "alice.test.near",
    text: "my message",
  };

  t.is(results[0], '"Howdy"');
  t.is(results[1], '-1');
  t.deepEqual(results[2], JSON.stringify([expected]));
  t.pass();
});

test("similar_contracts", async (t) => {
  const { xcc, alice } = t.context.accounts;

  const results: [[string]] = await alice.call(
    xcc,
    "similar_contracts",
    {},
    { gas: "300000000000000" }
  );

  const expected = ['"hi"', '"howdy"', '"bye"'];

  t.deepEqual(results, expected);
});

test("batch_actions", async (t) => {
  const { xcc, alice } = t.context.accounts;

  const result: string = await alice.call(
    xcc,
    "batch_actions",
    {},
    { gas: "300000000000000" }
  );

  t.deepEqual(result, '"bye"');
});

'''
'''--- contract-advanced-ts/src/contract.ts ---
// Find all our documentation at https://docs.near.org
import { call, initialize, near, NearBindgen, NearPromise } from "near-sdk-js";
import { AccountId } from "near-sdk-js/lib/types";
import {
  batch_actions as internal_batch_actions,
  batch_actions_callback as internal_batch_actions_callback,
} from "./internal/batch_actions";
import {
  multiple_contracts as internal_multiple_contracts,
  multiple_contracts_callback as internal_multiple_contracts_callback,
} from "./internal/multiple_contracts";
import {
  similar_contracts as internal_similar_contracts,
  similar_contracts_callback as internal_similar_contracts_callback,
} from "./internal/similar_contracts";

@NearBindgen({})
export class CrossContractCall {
  hello_account: AccountId = "hello.near-examples.testnet";
  guestbook_account: AccountId = "guestbook.near-examples.testnet";
  counter_account: AccountId = "counter.near-examples.testnet";

  @initialize({})
  init({
    hello_account,
    guestbook_account,
    counter_account,
  }: {
    hello_account: AccountId;
    guestbook_account: AccountId;
    counter_account: AccountId;
  }) {
    this.hello_account = hello_account;
    this.guestbook_account = guestbook_account;
    this.counter_account = counter_account;
  }

  @call({})
  batch_actions(): NearPromise {
    return internal_batch_actions(this.hello_account);
  }

  @call({ privateFunction: true })
  batch_actions_callback(): string {
    return internal_batch_actions_callback();
  }

  @call({})
  multiple_contracts(): NearPromise {
    return internal_multiple_contracts(this);
  }

  @call({ privateFunction: true })
  multiple_contracts_callback(
    { number_promises }: { number_promises: number },
  ): string[] {
    return internal_multiple_contracts_callback(number_promises);
  }

  @call({})
  similar_contracts(): NearPromise {
    return internal_similar_contracts(this);
  }

  @call({ privateFunction: true })
  similar_contracts_callback(
    { number_promises }: { number_promises: number },
  ): string[] {
    return internal_similar_contracts_callback(number_promises);
  }
}

'''
'''--- contract-advanced-ts/src/internal/batch_actions.ts ---
import { AccountId, near, NearPromise } from "near-sdk-js";
import { NO_ARGS, NO_DEPOSIT, TEN_TGAS } from "./constants";
import { promiseResult } from "./utils";

export function batch_actions(accountId: AccountId) {

  const promise = NearPromise.new(accountId)
    .functionCall("set_greeting", JSON.stringify({ greeting: 'hi' }), NO_DEPOSIT, TEN_TGAS)
    .functionCall("get_greeting", NO_ARGS, NO_DEPOSIT, TEN_TGAS)
    .functionCall("set_greeting", JSON.stringify({ greeting: 'bye' }), NO_DEPOSIT, TEN_TGAS)
    .functionCall("get_greeting", NO_ARGS, NO_DEPOSIT, TEN_TGAS)
    .then(
      NearPromise.new(near.currentAccountId())
      .functionCall("batch_actions_callback", NO_ARGS, NO_DEPOSIT, TEN_TGAS)
    )
    return promise.asReturn();
};

export function batch_actions_callback() {
  let { success, result } = promiseResult(0);

  if (success) {
    near.log(`Success! Result: ${result}`);
    return result;
  } else {
    near.log("Promise failed...");
    return "";
  }
};

'''
'''--- contract-advanced-ts/src/internal/constants.ts ---
export const TEN_TGAS = BigInt("10000000000000");
export const NO_DEPOSIT = BigInt(0);
export const NO_ARGS = JSON.stringify({});
'''
'''--- contract-advanced-ts/src/internal/multiple_contracts.ts ---
import { near, NearPromise } from "near-sdk-js";
import { CrossContractCall } from "../contract";
import { NO_ARGS, NO_DEPOSIT, TEN_TGAS } from "./constants";
import { promiseResult } from "./utils";

export function multiple_contracts(contract: CrossContractCall) {
  const promise1 = NearPromise.new(contract.hello_account)
    .functionCall("get_greeting", NO_ARGS, NO_DEPOSIT, TEN_TGAS)
  const promise2 = NearPromise.new(contract.counter_account)
    .functionCall("get_num", NO_ARGS, NO_DEPOSIT, TEN_TGAS)
  const promise3 = NearPromise.new(contract.guestbook_account)
    .functionCall("get_messages", NO_ARGS, NO_DEPOSIT, TEN_TGAS)

  return promise1
    .and(promise2)
    .and(promise3)
    .then(
      NearPromise.new(near.currentAccountId())
      .functionCall("multiple_contracts_callback", JSON.stringify({ number_promises: 3 }), NO_DEPOSIT, TEN_TGAS)
    )
};

export function multiple_contracts_callback(number_promises: number): string[] {
  const allResults = [];
    
  for (let i = 0; i < number_promises; i++) {
    near.log(`Get index result: ${i}`);
    let { success, result } = promiseResult(i);

    if (success) {
      allResults.push(result);
      near.log(`Success! Index: ${i}, Result: ${result}`);
    } else {
      near.log("Promise failed...");
      return [];
    }
  }

  return allResults;
};

'''
'''--- contract-advanced-ts/src/internal/similar_contracts.ts ---
import { near, NearPromise } from "near-sdk-js";
import { CrossContractCall } from "../contract";
import { NO_ARGS, NO_DEPOSIT, TEN_TGAS } from "./constants";
import { promiseResult } from "./utils";

function promise_set_get(contract: CrossContractCall, message: string) {
  return NearPromise.new(contract.hello_account)
    .functionCall(
      "set_greeting",
      JSON.stringify({ greeting: message }),
      NO_DEPOSIT,
      TEN_TGAS
    )
    .functionCall("get_greeting", NO_ARGS, NO_DEPOSIT, TEN_TGAS);
}

export function similar_contracts(contract: CrossContractCall) {
  const hello_one = promise_set_get(contract,"hi");
  const hello_two = promise_set_get(contract,"howdy");
  const hello_three = promise_set_get(contract,"bye");

  return hello_one
    .and(hello_two)
    .and(hello_three)
    .then(
      NearPromise.new(near.currentAccountId()).functionCall(
        "multiple_contracts_callback",
        JSON.stringify({ number_promises: 3 }),
        NO_DEPOSIT,
        TEN_TGAS
      )
    );
}

export function similar_contracts_callback(number_promises: number): string[] {
  const allResults = [];
    
  for (let i = 0; i < number_promises; i++) {
    near.log(`Get index result: ${i}`);
    let { success, result } = promiseResult(i);

    if (success) {
      allResults.push(result);
      near.log(`Success! Index: ${i}, Result: ${result}`);
    } else {
      near.log("Promise failed...");
      return [];
    }
  }

  return allResults;
};
  
'''
'''--- contract-advanced-ts/src/internal/utils.ts ---
import { near } from "near-sdk-js";

export function promiseResult(index: number): { result: string, success: boolean } {
  let result, success;
  
  try {
    result = near.promiseResult(index);
    success = true;
  } catch (err){
    near.log(err.message);
    throw err;
    result = undefined;
    success = false;
  }
  
  return {
    result,
    success,
  }
}
'''
'''--- contract-advanced-ts/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "ES5",
    "noEmit": true,
    "noImplicitAny": false,
  },
  "files": [
    "sandbox-ts/main.ava.ts",
    "src/contract.ts"
  ],
  "exclude": [
    "node_modules"
  ],
}
'''
'''--- contract-simple-rs/Cargo.toml ---
[package]
name = "cross_contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
near-sdk = "5.1.0"

[dev-dependencies]
near-sdk = { version = "5.0.0", features = ["unit-testing"] }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract-simple-rs/README.md ---
# Cross-Contract Hello Contract

The smart contract implements the simplest form of cross-contract calls: it calls the [Hello NEAR example](https://docs.near.org/tutorials/examples/hello-near) to get and set a greeting.

## How to Build Locally?

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near build
```

## How to Test Locally?

```bash
cargo test
```

## How to Deploy?

To deploy manually, install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# Create a new account
cargo near create-dev-account

# Deploy the contract on it
cargo near deploy <account-id>
```

## CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash

# Get message from the hello-near contract
# Replace <account-id> with your account ID
near call <account-id> query_greeting --accountId <account-id>

# Set a new message for the hello-near contract
# Replace <account-id> with your account ID
near call <account-id> change_greeting '{"new_greeting":"XCC Hi"}' --accountId <account-id>
```

# Useful Links

- [cargo-near](https://github.com/near/cargo-near) - NEAR smart contract development toolkit for Rust
- [near CLI](https://near.cli.rs) - Interact with NEAR blockchain from command line
- [NEAR Rust SDK Documentation](https://docs.near.org/sdk/rust/introduction)
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub), [Twitter](https://twitter.com/neardevhub)
'''
'''--- contract-simple-rs/rust-toolchain.toml ---
[toolchain]
channel = "stable"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]
'''
'''--- contract-simple-rs/src/external.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::ext_contract;

pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

// Validator interface, for cross-contract calls
#[ext_contract(hello_near)]
trait HelloNear {
    fn get_greeting(&self) -> String;
    fn set_greeting(&self, greeting: String);
}

'''
'''--- contract-simple-rs/src/lib.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::{env, log, near, AccountId, Gas, PanicOnDefault, Promise, PromiseError};

pub mod external;
pub use crate::external::*;

#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub hello_account: AccountId,
}

#[near]
impl Contract {
    #[init]
    #[private] // Public - but only callable by env::current_account_id()
    pub fn init(hello_account: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self { hello_account }
    }

    // Public - query external greeting
    pub fn query_greeting(&self) -> Promise {
        // Create a promise to call HelloNEAR.get_greeting()
        let promise = hello_near::ext(self.hello_account.clone())
            .with_static_gas(Gas::from_tgas(5))
            .get_greeting();

        return promise.then(
            // Create a promise to callback query_greeting_callback
            Self::ext(env::current_account_id())
                .with_static_gas(Gas::from_tgas(5))
                .query_greeting_callback(),
        );
    }

    #[private] // Public - but only callable by env::current_account_id()
    pub fn query_greeting_callback(
        &self,
        #[callback_result] call_result: Result<String, PromiseError>,
    ) -> String {
        // Check if the promise succeeded by calling the method outlined in external.rs
        if call_result.is_err() {
            log!("There was an error contacting Hello NEAR");
            return "".to_string();
        }

        // Return the greeting
        let greeting: String = call_result.unwrap();
        greeting
    }

    // Public - change external greeting
    pub fn change_greeting(&mut self, new_greeting: String) -> Promise {
        // Create a promise to call HelloNEAR.set_greeting(message:string)
        hello_near::ext(self.hello_account.clone())
            .with_static_gas(Gas::from_tgas(5))
            .set_greeting(new_greeting)
            .then(
                // Create a callback change_greeting_callback
                Self::ext(env::current_account_id())
                    .with_static_gas(Gas::from_tgas(5))
                    .change_greeting_callback(),
            )
    }

    #[private]
    pub fn change_greeting_callback(
        &mut self,
        #[callback_result] call_result: Result<(), PromiseError>,
    ) -> bool {
        // Return whether or not the promise succeeded using the method outlined in external.rs
        if call_result.is_err() {
            env::log_str("set_greeting failed...");
            return false;
        } else {
            env::log_str("set_greeting was successful!");
            return true;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const HELLO_NEAR: &str = "beneficiary";

    #[test]
    fn initializes() {
        let beneficiary: AccountId = HELLO_NEAR.parse().unwrap();
        let contract = Contract::init(beneficiary);
        assert_eq!(contract.hello_account, HELLO_NEAR)
    }
}

'''
'''--- contract-simple-rs/tests/tests.rs ---
use near_workspaces::{types::NearToken, Account, Contract};
use serde_json::json;
 
#[tokio::test]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let worker = near_workspaces::sandbox().await?;
    // Deploy hello contract
    let hello_contract_wasm = std::fs::read("./tests/hello-near/hello-near.wasm")?;
    let hello_contract = worker.dev_deploy(&hello_contract_wasm).await?;
    // Deploy contract for testing
    let contract_wasm = near_workspaces::compile_project("./").await?;
    let contract = worker.dev_deploy(&contract_wasm).await?;
 
    // Create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount("alice")
        .initial_balance(NearToken::from_near(30))
        .transact()
        .await?
        .into_result()?;

    // Init contract
    let _ = contract
        .call("init")
        .args_json(json!({ "hello_account": hello_contract.id() }))
        .transact()
        .await?
        .into_result()?;
 
    // Begin tests
    test_default_greeting(&alice, &contract).await?;
    test_change_greeting(&alice, &contract).await?;
    Ok(())
}

async fn test_default_greeting(
    user: &Account,
    contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
    let greeting: String = user
        .call(contract.id(), "query_greeting")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .json()?;
 
    assert_eq!(greeting, "Hello".to_string());
    Ok(())
}

async fn test_change_greeting(
  user: &Account,
  contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
  let result: bool = user
      .call(contract.id(), "change_greeting")
      .args_json(json!({ "new_greeting": "Howdy" }))
      .max_gas()
      .transact()
      .await?
      .json()?;

  assert_eq!(result, true);

  let greeting: String = user
      .call(contract.id(), "query_greeting")
      .args_json(json!({}))
      .max_gas()
      .transact()
      .await?
      .json()?;

  assert_eq!(greeting, "Howdy".to_string());
  Ok(())
}
'''
'''--- contract-simple-ts/README.md ---
# Cross-Contract Hello Contract

The smart contract implements the simplest form of cross-contract calls: it calls the [Hello NEAR example](https://docs.near.org/tutorials/examples/hello-near) to get and set a greeting.

<br />

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

## 1. Build and Test the Contract
You can automatically compile and test the contract by running:

```bash
# To solely build the contract
npm run build

# To build and execute the contract's tests
npm run test
```

## 2. Create an Account and Deploy the Contract
You can create a new account and deploy the contract by running:

```bash
near create-account <your-account.testnet> --useFaucet

near deploy <your-account.testnet> ./build/cross_contract.wasm init '{"hello_account":"hello.near-example.testnet"}' 
```

<br />

## 3. CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Get message from the hello-near contract
# Replace <your-account.testnet> with your account ID
near call <your-account.testnet> query_greeting --accountId <your-account.testnet>

# Set a new message for the hello-near contract
# Replace <your-account.testnet> with your account ID
near call <your-account.testnet> change_greeting '{"new_greeting":"XCC Hi"}' --accountId <your-account.testnet>
```

# Useful Links

- [near CLI](https://near.cli.rs) - Interact with NEAR blockchain from command line
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub), [Twitter](https://twitter.com/neardevhub)
'''
'''--- contract-simple-ts/package.json ---
{
  "name": "contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/cross_contract.wasm",
    "test": "$npm_execpath build && ava -- ./build/cross_contract.wasm"
  },
  "dependencies": {
    "near-cli": "^4.0.10",
    "near-sdk-js": "1.0.0"
  },
  "devDependencies": {
    "@ava/typescript": "^4.1.0",
    "ava": "^6.1.2",
    "near-workspaces": "^3.5.0",
    "ts-morph": "^22.0.0",
    "ts-node": "^10.9.2",
    "tsimp": "^2.0.11",
    "typescript": "^5.4.2"
  }
}

'''
'''--- contract-simple-ts/sandbox-ts/main.ava.ts ---
import { Worker, NearAccount } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { setDefaultResultOrder } from 'dns'; setDefaultResultOrder('ipv4first'); // temp fix for node >v17

// Global context
const test = anyTest as TestFn<{ worker: Worker, accounts: Record<string, NearAccount> }>;

test.beforeEach(async (t) => {
  // Create sandbox, accounts, deploy contracts, etc.
  const worker = t.context.worker = await Worker.init();
  
  // Get root account
  const root = worker.rootAccount;

  // Create test accounts
  const alice = await root.createSubAccount("alice");
  const xcc = await root.createSubAccount("xcc");
  const helloNear = await root.createSubAccount("hello-near");

  // Deploy the hello near contract
  await helloNear.deploy("./sandbox-ts/hello-near/hello-near.wasm");

  // Deploy the xcc contract
  await xcc.deploy(process.argv[2]);
  await xcc.call(xcc, "init", { hello_account: helloNear.accountId });

  // Save state for test runs, it is unique for each test
  t.context.accounts = { root, alice, xcc, helloNear };
});

test.afterEach.always(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log('Failed to stop the Sandbox:', error);
  });
});

test("returns the default greeting", async (t) => {
  const { xcc, alice } = t.context.accounts;
  const greeting = await alice.call(xcc, "query_greeting", {}, { gas: "200000000000000" });
  t.is(greeting, 'Hello');
});

test("change the greeting", async (t) => {
  const { xcc, alice } = t.context.accounts;

  const howdyChangingResult = await alice.call(xcc, "change_greeting", { new_greeting: "Howdy" }, { gas: "200000000000000" });
  t.is(howdyChangingResult, true);

  const howdyResult = await alice.call(xcc, "query_greeting", {}, { gas: "200000000000000" });
  t.is(howdyResult, 'Howdy');
});
'''
'''--- contract-simple-ts/src/contract.ts ---
// Find all our documentation at https://docs.near.org
import {
  call,
  initialize,
  near,
  NearBindgen,
  NearPromise,
  PromiseIndex,
} from "near-sdk-js";
import { AccountId } from "near-sdk-js/lib/types";

const FIVE_TGAS = BigInt("50000000000000");
const NO_DEPOSIT = BigInt(0);
const NO_ARGS = JSON.stringify({});

@NearBindgen({})
class CrossContractCall {
  hello_account: AccountId = "hello-nearverse.testnet";

  @initialize({})
  init({ hello_account }: { hello_account: AccountId }) {
    this.hello_account = hello_account;
  }

  @call({})
  query_greeting(): NearPromise {
    const promise = NearPromise.new(this.hello_account)
      .functionCall("get_greeting", NO_ARGS, NO_DEPOSIT, FIVE_TGAS)
      .then(
        NearPromise.new(near.currentAccountId())
          .functionCall(
            "query_greeting_callback",
            NO_ARGS,
            NO_DEPOSIT,
            FIVE_TGAS,
          ),
      );

    return promise.asReturn();
  }

  @call({ privateFunction: true })
  query_greeting_callback(): String {
    let { result, success } = promiseResult();

    if (success) {
      return result.substring(1, result.length - 1);
    } else {
      near.log("Promise failed...");
      return "";
    }
  }

  @call({})
  change_greeting({ new_greeting }: { new_greeting: string }): NearPromise {
    const promise = NearPromise.new(this.hello_account)
      .functionCall(
        "set_greeting",
        JSON.stringify({ greeting: new_greeting }),
        NO_DEPOSIT,
        FIVE_TGAS,
      )
      .then(
        NearPromise.new(near.currentAccountId())
          .functionCall(
            "change_greeting_callback",
            NO_ARGS,
            NO_DEPOSIT,
            FIVE_TGAS,
          ),
      );

    return promise.asReturn();
  }

  @call({ privateFunction: true })
  change_greeting_callback(): boolean {
    let { success } = promiseResult();

    if (success) {
      near.log(`Success!`);
      return true;
    } else {
      near.log("Promise failed...");
      return false;
    }
  }
}

function promiseResult(): { result: string; success: boolean } {
  let result, success;

  try {
    result = near.promiseResult(0 as PromiseIndex);
    success = true;
  } catch {
    result = undefined;
    success = false;
  }

  return { result, success };
}

'''
'''--- contract-simple-ts/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "ES5",
    "noEmit": true,
    "noImplicitAny": false,
  },
  "files": [
    "sandbox-ts/main.ava.ts",
    "src/contract.ts"
  ],
  "exclude": [
    "node_modules"
  ],
}
'''