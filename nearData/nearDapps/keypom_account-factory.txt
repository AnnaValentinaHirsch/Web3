*GitHub Repository "keypom/account-factory"*

'''--- .travis.yml ---
language: rust

rust:
  - stable
  - nightly

jobs:
  include:
    - name: build and test
      script:
        - cargo build --release --all --verbose
        - cargo test --release --all --verbose
    
    - name: fossa
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test

'''
'''--- Cargo.toml ---
[package]
name = "account-factory"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
borsh = "0.9.3"
near-sdk = "4.0.0"

'''
'''--- README.md ---
# Account Factory Contract

Simplified and owner controlled version of `create_account` from Linkdrop Contract.

## Quick How To / Testing

1. Build the contract locally
2. Login to [YOUR_ACCOUNT_FACTORY_ID] using near-cli
```
near login
```
3. Deploy the wasm `./res/account_factory.wasm`
```
near deploy [YOUR_ACCOUNT_FACTORY_ID] ./res/account_factory.wasm

// init the contract
near call [YOUR_ACCOUNT_FACTORY_ID] new --accountId=[YOUR_ACCOUNT_FACTORY_ID]
```
4. This account is the `owner` which can add `approved_creators`
5. Add an approved creator
```
near call [YOUR_ACCOUNT_FACTORY_ID] add_approved_creator '{"account_id":"[SOME_APPROVED_CREATOR_ACCOUNT_ID]"}' --accountId=[YOUR_ACCOUNT_FACTORY_ID]
```
6. Login to [SOME_APPROVED_CREATOR_ACCOUNT_ID] using near-cli
```
near login
```
7. Create an account from the approved creator account
```
near call [YOUR_ACCOUNT_FACTORY_ID] create_account '{"new_account_id":"foo.testnet","new_public_key":"ed25519:BonsbmfRMRNzRwn92827kfGCwkNLjNDritF1LwrbZKn2"}' --deposit=1 --accountId=[SOME_APPROVED_CREATOR_ACCOUNT_ID]
```

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/account_factory.wasm ./res/

'''
'''--- src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupSet};
use near_sdk::json_types::{U128};
use near_sdk::serde::{Serialize, Deserialize};
use near_sdk::{
    env, ext_contract, require, near_bindgen, PanicOnDefault, AccountId, Promise, PromiseResult, Gas, PublicKey,
};

/// Gas attached to the callback from account creation.
pub const ON_CREATE_ACCOUNT_CALLBACK_GAS: Gas = Gas(13_000_000_000_000);

/// Keypom Args struct to be sent to external contracts
#[derive(Serialize, Deserialize, Debug, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct KeypomArgs {
    pub account_id_field: Option<String>,
    pub drop_id_field: Option<String>,
    pub key_id_field: Option<String>,
    pub funder_id_field: Option<String>,
}

#[ext_contract(ext_self)]
pub trait ExtLinkDrop {
    /// Callback after plain account creation.
    fn on_account_created(&mut self, predecessor_account_id: AccountId, amount: U128) -> bool;
}

fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct AccountFactory {
    pub owner_id: AccountId,
    pub approved_creators: LookupSet<AccountId>,
    pub approved_funders: LookupSet<AccountId>,
}

#[near_bindgen]
impl AccountFactory {
    
    #[init]
    pub fn new() -> Self {
        Self {
            owner_id: env::predecessor_account_id(),
            approved_creators: LookupSet::new(b"c"),
            approved_funders: LookupSet::new(b"f")
        }
    }

    #[payable]
    pub fn create_account(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
        funder_id: AccountId,
        keypom_args: KeypomArgs
    ) -> Promise {
        require!(
            self.approved_creators.contains(&env::predecessor_account_id())
        );

        // Ensure the incoming args are correct from Keypom
        require!(keypom_args.funder_id_field.unwrap() == "funder_id".to_string());
        require!(self.approved_funders.contains(&funder_id));

        let amount = env::attached_deposit();
        Promise::new(new_account_id)
            .create_account()
            .add_full_access_key(new_public_key.into())
            .transfer(amount)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(ON_CREATE_ACCOUNT_CALLBACK_GAS)
                    .on_account_created(
                        env::predecessor_account_id(),
                        amount.into()
                    )
            )
    }

    /// Callback after executing `create_account`.
    pub fn on_account_created(&mut self, predecessor_account_id: AccountId, amount: U128) -> bool {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Callback can only be called from the contract"
        );
        let creation_succeeded = is_promise_success();
        if !creation_succeeded {
            // In case of failure, send funds back.
            Promise::new(predecessor_account_id).transfer(amount.into());
        }
        creation_succeeded
    }

    /// approved creators mgmt
    pub fn add_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.insert(&account_id);
    }

    pub fn remove_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.remove(&account_id);
    }

    pub fn is_approved_creator(&self, account_id: AccountId) -> bool {
        self.approved_creators.contains(&account_id)
    }

    pub fn add_approved_funder(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_funders.insert(&account_id);
    }

    pub fn remove_approved_funder(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_funders.remove(&account_id);
    }

    pub fn is_approved_funder(&self, account_id: AccountId) -> bool {
        self.approved_funders.contains(&account_id)
    }

    fn assert_contract_owner(&mut self) {
        assert!(
            self.owner_id == env::predecessor_account_id(),
            "only contract owner"
        )
    }
}

'''