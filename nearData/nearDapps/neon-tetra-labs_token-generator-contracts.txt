*GitHub Repository "neon-tetra-labs/token-generator-contracts"*

'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli --no-optional && nvm use default
    init: yarn
    command: clear && echo Hey! Check out examples of how to build a NEP-21 Fungible Token in Rust.

'''
'''--- Cargo.toml ---
[package]
name = "token-generator-wrapper"
version = "0.0.1"
authors = ["Atilla not a hun <atilla_not_a_hun@protonmail.com>"]
edition = "2018"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.2"
near-sdk = "4.0.0-pre.2"
near-contract-standards = "4.0.0-pre.2"

# remember to include a line for each contract
contract = { path = "./contract" }
nft = { path = "./nft" }
multi-token-standard = { path = "./multi-token-standard-impl/multi_token" }
near-account = "0.1.2"
near-internal-balances-plugin = "0.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[[bin]]
name = "test"
path = "sim/main.rs"

[workspace]
members = ["contract"]
exclude = ["multi-token-standard-impl"]

'''
'''--- README-Windows.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install --global near-cli`

## Building

To build run in CMD:
```bash
build.bat
```

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    set NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    set ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId %ID%

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call %ID% new "{\"owner_id\": \""%ID%"\", \"total_supply\": \"1000000000000000\", \"metadata\": { \"spec\": \"ft-1.0.0\", \"name\": \"Example Token Name\", \"symbol\": \"EXLT\", \"decimals\": 8 }}" --accountId %ID%

Get metadata:

    near view %ID% ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.%ID% --masterAccount %ID% --initialBalance 1

Add storage deposit for Bob's account:

    near call %ID% storage_deposit '' --accountId bob.%ID% --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view %ID% ft_balance_of "{\"account_id\": \""bob.%ID%"\"}"

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% ft_transfer "{\"receiver_id\": \""bob.%ID%"\", \"amount\": \"19\"}" --accountId %ID% --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

'''
'''--- README.md ---
# Token Fractionalizing and Subsequent Sales

The following smart contract found in the `contract` directory. The main
purpose of the smart contract is to allow users to fractionalize a set of NFTs
and subsequently sell them with a simple sales model.

The fractionalize component basically means that a user can deposit some number of NFTs into a contract, the contract then locks up those NFTs and mints some number of Multi-Tokens (see the new [Multi Token proposal](https://github.com/near/NEPs/issues/246)). In order to redeem the NFTs, a caller has to burn all
the supply of a fraction.

These smart contracts make extensive use of the [Near internal balances plugin](https://docs.rs/near-internal-balances-plugin/latest/near_internal_balances_plugin/)
alongside the [Near Accounts library](https://docs.rs/near-account/latest/near_account/).

This contract also makes use of the [Multi Token Standard implementation](https://github.com/shipsgold/multi-token-standard-impl/tree/feat/initial-token).

The public methods additionally exposed are defined by two traits, `NFTFractionalizeFns` and `SalesFns` are
```rust
pub trait NftFractionalizerFns {
    /// Mints the new token
    /// * `mt_id`: The id of the new token. This id must be new and cannot have existed previously on this contract
    fn nft_fractionalize(
        &mut self,
        nfts: Vec<TokenId>,
        mt_id: MTTokenId,
        amount: U128,
        mt_owner: Option<AccountId>,
        token_metadata: MultiTokenMetadata,
        sale_amount: Option<U128>,
        sale_price_per_token: Option<U128>,
    );

    /// Deletes the mt and releases the nfts.
    fn nft_fractionalize_unwrap(&mut self, mt_id: MTTokenId, release_to: Option<AccountId>);

    fn nft_fractionalize_update_mint_fee(&mut self, update: U128);

    fn nft_fractionalize_get_underlying(&self, mt_id: MTTokenId) -> Vec<TokenId>;

    fn nft_fractionalize_get_mint_fee(&self) -> U128;
}

pub trait SalesFns {
    fn sale_buy(&mut self, mt_id: MTTokenId, amount: U128);
    fn sale_info(&self, mt_id: MTTokenId) -> SaleOptionsSerial;
    fn sale_get_all_sales(&self) -> Vec<(MTTokenId, SaleOptionsSerial)>;
}

```
as well as a `new` function
```rust
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: Option<AccountId>,
        treasury: Option<AccountId>,
        nft_mint_fee_numerator: Option<U128>,
        sale_fee_numerator: Option<U128>,
    );
```

Sample usage
=============
For sample usage, please check out `sim/testing/utils.rs` and `sim/testing/test_fractionalize.rs`.

Prerequisites
=============

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install -g near-cli`

## Building

To build run:
```bash
./build.sh
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/docs/concepts/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/contract.wasm --helperUrl https://near-contract-helper.onrender.com
```
Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new '{<ARGS>}' --accountId $CONTRACT_NAME
```

'''
'''--- build.bat ---
@echo off

title FT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "$(dirname $0)"
source ./flags.sh
cargo build --all --target wasm32-unknown-unknown --release
mkdir res || true
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "1.0.0"
authors = ["Atilla Not A Hun - Neon Tetra LLC"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-account = "0.1.2"
near-internal-balances-plugin = "0.1.0"
near-sdk = "4.0.0-pre.2"
near-contract-standards = "4.0.0-pre.2"

multi-token-standard = { path = "../multi-token-standard-impl/multi_token" }
uint = "0.9.2"

'''
'''--- contract/src/lib.rs ---
use multi_token_standard::{
    impl_multi_token_core, impl_multi_token_metadata, impl_multi_token_storage, MultiToken,
};
use near_account::{
    impl_near_accounts_plugin, Account, AccountDeposits, Accounts, NearAccountPlugin,
    NearAccountsPluginNonExternal, NewInfo,
};
use near_internal_balances_plugin::impl_near_balance_plugin;

use near_contract_standards::storage_management::StorageManagement as _StorageManagement;
use near_internal_balances_plugin::token_id::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, PromiseOrValue,
};
use nft_fractionalizer::{NftFractionalizer, NftFractionalizerFns};
use sales::{SaleOptions, SaleOptionsSerial, Sales, SalesFns};

pub mod nft_fractionalizer;
pub mod sales;
pub mod types;
mod utils;

use types::MTTokenId;
pub use utils::FEE_DENOMINATOR;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountInfo {
    pub internal_balance: UnorderedMap<TokenId, Balance>,
}

impl NewInfo for AccountInfo {
    fn default_from_account_id(account_id: AccountId) -> Self {
        Self { internal_balance: UnorderedMap::new(format!("{}-bal", account_id).as_bytes()) }
    }
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
enum StorageKey {
    MultiTokenOwner,
    MultiTokenMetadata,
    MultiTokenSupply,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: Accounts<AccountInfo>,
    pub mt: MultiToken,
    pub owner_id: AccountId,
    pub treasury_id: AccountId,
    pub nft_fractionalizer: NftFractionalizer,
    pub sales: Sales,
}

impl_near_accounts_plugin!(Contract, accounts, AccountInfo);
// Implement functionality for internal balances and multi tokens
impl_near_balance_plugin!(Contract, accounts, AccountInfo, internal_balance);
impl_multi_token_core!(Contract, mt);
impl_multi_token_storage!(Contract, mt);
impl_multi_token_metadata!(Contract, mt);

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: Option<AccountId>,
        treasury: Option<AccountId>,
        nft_mint_fee_numerator: Option<U128>,
        sale_fee_numerator: Option<U128>,
    ) -> Self {
        let owner_id = owner_id.unwrap_or(env::predecessor_account_id());
        let treasury_id = treasury.unwrap_or(env::predecessor_account_id());

        let mut this = Contract {
            accounts: Accounts::new(),
            mt: MultiToken::new(
                StorageKey::MultiTokenOwner,
                owner_id.clone(),
                Some(StorageKey::MultiTokenMetadata),
                StorageKey::MultiTokenSupply,
            ),
            sales: Sales::new(sale_fee_numerator.map(|v| v.into()).unwrap_or(0)),
            owner_id: owner_id.clone(),
            nft_fractionalizer: NftFractionalizer::new(
                nft_mint_fee_numerator.map(|v| v.into()).unwrap_or(0),
            ),
            treasury_id: treasury_id.clone(),
        };

        let default_account = Account::default_from_account_id(owner_id.clone());
        this.accounts.accounts.insert(&owner_id, &default_account);

        if owner_id != treasury_id {
            let default_account_treasury = Account::default_from_account_id(treasury_id.clone());
            this.accounts.accounts.insert(&treasury_id, &default_account_treasury);
        }
        this
    }
}

#[near_bindgen]
impl SalesFns for Contract {
    #[payable]
    fn sale_buy(&mut self, mt_id: types::MTTokenId, amount: U128) {
        self.sale_buy_internal(mt_id, amount.into())
    }

    fn sale_info(&self, mt_id: types::MTTokenId) -> SaleOptionsSerial {
        self.sale_info_internal(mt_id)
    }

    fn sale_get_all_sales(&self) -> Vec<(MTTokenId, SaleOptionsSerial)> {
        self.sale_get_all_sales_internal()
    }
}

#[near_bindgen]
impl NftFractionalizerFns for Contract {
    #[payable]
    fn nft_fractionalize(
        &mut self,
        nfts: Vec<TokenId>,
        mt_id: types::MTTokenId,
        amount: U128,
        mt_owner: Option<AccountId>,
        token_metadata: multi_token_standard::metadata::MultiTokenMetadata,
        sale_amount: Option<U128>,
        sale_price_per_token: Option<U128>,
    ) {
        self.nft_fractionalize_internal(
            nfts,
            mt_id,
            amount.into(),
            mt_owner,
            token_metadata,
            sale_amount.map(|v| v.into()),
            sale_price_per_token.map(|v| v.into()),
        );
    }

    #[payable]
    fn nft_fractionalize_unwrap(&mut self, mt_id: types::MTTokenId, release_to: Option<AccountId>) {
        self.nft_fractionalize_unwrap_internal(mt_id, release_to);
    }

    fn nft_fractionalize_get_mint_fee(&self) -> U128 {
        self.nft_fractionalize_get_mint_fee_internal()
    }

    fn nft_fractionalize_get_underlying(&self, mt_id: types::MTTokenId) -> Vec<TokenId> {
        self.nft_fractionalize_get_underlying_internal(mt_id)
    }

    fn nft_fractionalize_update_mint_fee(&mut self, update: U128) {
        self.nft_fractionalize_update_mint_fee_internal(update);
    }
}

'''
'''--- contract/src/nft_fractionalizer/mod.rs ---
use multi_token_standard::{core::MultiTokenCore, metadata::MultiTokenMetadata, Token};
use near_account::Account;
use near_internal_balances_plugin::{
    InternalBalanceHandlers, SudoInternalBalanceHandlers, TokenId,
};
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env,
    json_types::U128,
    serde::{self, Deserialize, Serialize},
    AccountId, Balance,
};

use crate::{
    sales::SaleOptions,
    types::{MTTokenId, MTTokenType},
    Contract,
};
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NftInfo {
    nfts: Vec<TokenId>,
    /// Set to true after unwrapping an NFT. This is a permanent action and marks the token as
    /// 'deleted'
    unwrapped: bool,
}
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NftFractionalizer {
    mt_to_nfts: UnorderedMap<MTTokenId, NftInfo>,
    mint_fee: u128,
}

pub trait NftFractionalizerFns {
    /// Mints the new token
    /// * `mt_id`: The id of the new token. This id must be new and cannot have existed previously on this contract
    fn nft_fractionalize(
        &mut self,
        nfts: Vec<TokenId>,
        mt_id: MTTokenId,
        amount: U128,
        mt_owner: Option<AccountId>,
        token_metadata: MultiTokenMetadata,
        sale_amount: Option<U128>,
        sale_price_per_token: Option<U128>,
    );

    /// Deletes the mt and releases the nfts.
    fn nft_fractionalize_unwrap(&mut self, mt_id: MTTokenId, release_to: Option<AccountId>);

    fn nft_fractionalize_update_mint_fee(&mut self, update: U128);

    fn nft_fractionalize_get_underlying(&self, mt_id: MTTokenId) -> Vec<TokenId>;

    fn nft_fractionalize_get_mint_fee(&self) -> U128;
}

impl NftFractionalizer {
    pub(crate) fn new(mint_fee: u128) -> Self {
        Self { mt_to_nfts: UnorderedMap::new("nft-f".as_bytes()), mint_fee }
    }
}

impl Contract {
    fn insert_mt(&mut self, mt: &MTTokenId, nfts: Vec<TokenId>) {
        match self.nft_fractionalizer.mt_to_nfts.get(mt) {
            Some(_) => panic!("Should not get here, but only new 'mt's can be added"),
            None => {
                self.nft_fractionalizer.mt_to_nfts.insert(mt, &NftInfo { nfts, unwrapped: false });
            }
        }
    }

    /// Mints the new token
    /// * `mt_id`: The id of the new token. This id must be new and cannot have existed previously on this contract
    pub(crate) fn nft_fractionalize_internal(
        &mut self,
        nfts: Vec<TokenId>,
        mt_id: MTTokenId,
        amount: u128,
        mt_owner: Option<AccountId>,
        token_metadata: MultiTokenMetadata,
        sale_amount: Option<Balance>,
        sale_price_per_token: Option<Balance>,
    ) {
        let minter = env::predecessor_account_id();
        let mt_owner = mt_owner.unwrap_or(minter.clone());
        let initial_storage_usage = env::storage_usage();

        // Subtract from the user's balances
        for token in &nfts {
            Self::assert_nft_type(token);
            self.internal_balance_subtract(&minter, &token, 1);
        }

        // create the mt
        self.mint_mt(
            mt_id.clone(),
            MTTokenType::Ft,
            Some(amount),
            mt_owner.clone(),
            token_metadata,
        );

        // Insert the mt into local data
        self.insert_mt(&mt_id, nfts);

        match (sale_amount, sale_price_per_token) {
            (Some(sale_amount), Some(sale_price_per_token)) => {
                assert!(
                    sale_amount <= amount,
                    "Expected the sale amount to be less than or equal to the total supply"
                );
                // Transfer the sale tokens to the current contract after registering it
                self.mt.internal_register_account(mt_id.clone(), &env::current_account_id());
                self.mt.internal_transfer(
                    &mt_owner,
                    &env::current_account_id(),
                    &mt_id,
                    sale_amount,
                    None,
                );

                self.sales_create(
                    &mt_id,
                    SaleOptions {
                        owner: mt_owner,
                        amount_to_sell: sale_amount,
                        near_price_per_token: sale_price_per_token,
                        sold: 0,
                    },
                );
            }
            _ => {}
        }

        // Return any extra attached deposit not used for storage
        self.check_storage_deposit(
            env::storage_usage() - initial_storage_usage,
            Some(self.nft_fractionalizer.mint_fee),
        );
    }

    /// Deletes the mt and releases the nfts.
    pub(crate) fn nft_fractionalize_unwrap_internal(
        &mut self,
        mt_id: MTTokenId,
        release_to: Option<AccountId>,
    ) {
        assert_one_yocto();
        let caller = env::predecessor_account_id();
        let caller_balance = self.mt.balance_of_batch(caller.clone(), vec![mt_id.clone()])[0].0;
        let total_supply = self.mt.total_supply(mt_id.clone()).0;
        assert_eq!(
            total_supply, caller_balance,
            "Unwrapping can only be done if the unwrapper holds all the tokens"
        );

        // burn the supply of the entire token, but keep around the metadata for future reference
        self.mt.internal_withdraw(&mt_id, &caller, total_supply);

        // redeposit the NFT's into the caller's account
        let nfts = self.nft_fractionalizer.mt_to_nfts.get(&mt_id).unwrap();
        let release_to = release_to.as_ref().unwrap_or(&caller);
        for nft in nfts.nfts {
            self.internal_balance_increase(&release_to, &nft, 1);
        }
    }

    pub(crate) fn nft_fractionalize_get_mint_fee_internal(&self) -> U128 {
        U128::from(self.nft_fractionalizer.mint_fee)
    }

    pub(crate) fn nft_fractionalize_get_underlying_internal(
        &self,
        mt_id: MTTokenId,
    ) -> Vec<TokenId> {
        self.nft_fractionalizer.mt_to_nfts.get(&mt_id).expect("The queried mt does not exist").nfts
    }

    pub(crate) fn nft_fractionalize_update_mint_fee_internal(&mut self, update: U128) {
        assert_eq!(self.owner_id, env::predecessor_account_id(), "Caller must be the owner");
        self.nft_fractionalizer.mint_fee = update.0;
    }

    fn assert_nft_type(token: &TokenId) {
        match token {
            TokenId::FT { .. } => panic!("Expected an NFT token type"),
            _ => (),
        };
    }
}

'''
'''--- contract/src/sales/mod.rs ---
use multi_token_standard::{core::MultiTokenCore, metadata::MultiTokenMetadata, Token};
use near_account::Account;
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env,
    json_types::U128,
    serde::{self, Deserialize, Serialize},
    AccountId, Balance,
};

use crate::{types::MTTokenId, utils::FEE_DENOMINATOR, Contract};

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleOptionsSerial {
    pub amount_to_sell: U128,
    pub near_price_per_token: U128,
    pub sold: U128,
    pub owner: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
pub struct SaleOptions {
    pub amount_to_sell: Balance,
    pub near_price_per_token: Balance,
    pub sold: Balance,
    pub owner: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Sales {
    sales: UnorderedMap<MTTokenId, SaleOptions>,
    /// Platform fee connoted by the numerator of FEE_DENOMINATOR in utils.rs
    platform_fee_numerator: u128,
}

pub trait SalesFns {
    fn sale_buy(&mut self, mt_id: MTTokenId, amount: U128);
    fn sale_info(&self, mt_id: MTTokenId) -> SaleOptionsSerial;
    fn sale_get_all_sales(&self) -> Vec<(MTTokenId, SaleOptionsSerial)>;
}

impl Sales {
    pub fn new(platform_fee: u128) -> Self {
        Self { sales: UnorderedMap::new("sxy".as_bytes()), platform_fee_numerator: platform_fee }
    }
}

impl SaleOptions {
    fn get_near_cost(&self, amount: Balance) -> Balance {
        self.near_price_per_token * amount
    }

    fn to_serial(&self) -> SaleOptionsSerial {
        SaleOptionsSerial {
            amount_to_sell: U128::from(self.amount_to_sell),
            sold: U128::from(self.sold),
            owner: self.owner.clone(),
            near_price_per_token: U128::from(self.near_price_per_token),
        }
    }
}

impl Contract {
    pub(crate) fn sale_info_internal(&self, mt_id: MTTokenId) -> SaleOptionsSerial {
        self.sales
            .sales
            .get(&mt_id)
            .expect("Cannot find the sale with the given token id")
            .to_serial()
    }

    pub(crate) fn sale_get_all_sales_internal(&self) -> Vec<(MTTokenId, SaleOptionsSerial)> {
        self.sales.sales.iter().map(|(tok_id, sale_opts)| (tok_id, sale_opts.to_serial())).collect()
    }

    pub(crate) fn sale_buy_internal(&mut self, mt_id: MTTokenId, amount: Balance) {
        let caller = env::predecessor_account_id();
        // ensure the caller is registered
        let caller_registered = self
            .mt
            .ft_owners_by_id
            .get(&mt_id)
            .expect(&format!("Cannot find token {}", mt_id))
            .get(&caller)
            .is_some();
        assert!(caller_registered == true, "Expected the caller to be registered");

        let mut sale =
            self.sales.sales.get(&mt_id).expect(&format!("Cannot find sale for {}", mt_id));
        let cost = sale.get_near_cost(amount);

        // Make sure that the proper amount is attached and transfer accordingly
        assert_eq!(env::attached_deposit(), cost, "Expected {} attached to pay for the sale", cost);

        // Transfer the fees/ cost
        let amount_to_treasury = Self::calculate_fee(cost, self.sales.platform_fee_numerator);
        let amount_to_owner = cost - amount_to_treasury;
        let treasury = &self.treasury_id.clone();
        self.transfer_fee(amount_to_treasury, treasury);
        self.transfer_fee(amount_to_owner, &sale.owner);

        // Transfer the token's to the buyer's account
        self.mt.internal_transfer(&env::current_account_id(), &caller, &mt_id, amount, None);

        sale.sold += amount;
        self.sales.sales.insert(&mt_id, &sale);
    }
}

impl Contract {
    pub(crate) fn sales_create(&mut self, mt_id: &MTTokenId, sale: SaleOptions) {
        if self.sales.sales.get(mt_id).is_some() {
            panic!("Expected to not find an existing sale for {}", &mt_id);
        }
        self.sales.sales.insert(mt_id, &sale);
    }
}

'''
'''--- contract/src/types.rs ---
pub type MTTokenId = multi_token_standard::TokenId;
pub type MTTokenType = multi_token_standard::TokenType;

'''
'''--- contract/src/utils.rs ---
use multi_token_standard::{metadata::MultiTokenMetadata, TokenType};
use near_account::NearAccountsPluginNonExternal;
use near_sdk::{env, require, AccountId, Balance, Promise};
use uint::construct_uint;

use crate::{
    types::{MTTokenId, MTTokenType},
    Contract,
};

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

pub const FEE_DENOMINATOR: u128 = 1_000_000_000u128;

/// Fee/ near transfer handling
impl Contract {
    pub(crate) fn transfer_fee(&mut self, amount: Balance, to: &AccountId) {
        assert!(
            env::attached_deposit() >= amount,
            "Expected the attached deposit to equal the fee of {}",
            amount
        );
        let mut to_account = self
            .accounts
            .get_account(to)
            .unwrap_or_else(|| panic!("Expected {} to be registered", to.as_str()));
        to_account.near_amount += amount;
        near_account::NearAccountsPluginNonExternal::insert_account_check_storage(&mut self.accounts, &to, &mut to_account);
    }

    pub(crate) fn calculate_fee(amount: Balance, fee_numerator: u128) -> Balance {
        assert!(fee_numerator <= FEE_DENOMINATOR);
        let ret = U256::from(amount) * U256::from(fee_numerator) / U256::from(FEE_DENOMINATOR);
        ret.as_u128()
    }
}

impl Contract {
    /// Taken from [multi-token-standard-impl/examples/multi-token/mt](https://github.com/shipsgold/multi-token-standard-impl/blob/ec874d2e010908160f6c73555bde119943b96736/examples/multi-token/mt/src/lib.rs#L66)
    /// slightly modified to allow for fee collections
    pub(crate) fn mint_mt(
        &mut self,
        token_id: MTTokenId,
        token_type: MTTokenType,
        amount: Option<u128>,
        token_owner_id: AccountId,
        token_metadata: MultiTokenMetadata,
    ) {
        // Every token must have a token type and every NFT type cannot be re-minted
        match self.mt.token_type_index.get(&token_id) {
            Some(MTTokenType::Ft) => {
                require!(
                    token_type == MTTokenType::Ft,
                    "Type must be of FT time tokenId already exists"
                )
            }
            Some(MTTokenType::Nft) => {
                env::panic_str("Attempting to mint already minted NFT");
            }
            None => {
                self.mt.token_type_index.insert(&token_id, &token_type);
            }
        }

        let owner_id: AccountId = token_owner_id;
        // Core behavior: every token must have an owner
        match token_type {
            TokenType::Ft => {
                if amount.is_none() {
                    env::panic_str("Amount must be specified for Ft type tokens");
                }
                // advance the prefix index before insertion
                let amt = u128::from(amount.unwrap());
                //create LookupMap for balances
                match self.mt.ft_owners_by_id.get(&token_id) {
                    Some(mut balances) => {
                        let current_bal = balances.get(&owner_id).unwrap_or(0);
                        // TODO not quite safe
                        if amt == 0 {
                            env::panic_str("error: amount should be greater than 0")
                        }
                        balances.insert(&owner_id, &(current_bal + amt));
                        let supply = self.mt.ft_token_supply_by_id.get(&token_id).unwrap();
                        self.mt.ft_token_supply_by_id.insert(&token_id, &(supply + amt));
                    }
                    None => {
                        let mut balances = self.mt.internal_new_ft_balances();
                        // insert amount into balances
                        balances.insert(&owner_id, &amt);
                        self.mt.ft_owners_by_id.insert(&token_id, &balances);
                        self.mt.ft_token_supply_by_id.insert(&token_id, &amt);
                    }
                }
            }
            TokenType::Nft => {
                self.mt.nft_owner_by_id.insert(&token_id, &owner_id);
            }
        }
        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.mt
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata));
    }

    /// Taken from [multi-token-standard-impl/examples/multi-token/mt](https://github.com/shipsgold/multi-token-standard-impl/blob/ec874d2e010908160f6c73555bde119943b96736/examples/multi-token/mt/src/lib.rs#L51)
    /// with modifications to allow for a "keep" amount
    pub(crate) fn check_storage_deposit(&self, storage_used: u64, fee_amount: Option<Balance>) {
        let required_cost =
            env::storage_byte_cost() * Balance::from(storage_used) + fee_amount.unwrap_or(0);

        let attached_deposit = env::attached_deposit();
        assert!(
            required_cost <= attached_deposit,
            "Must attach {} yoctoNEAR to cover storage and/or fees",
            required_cost,
        );
        let refund = attached_deposit - required_cost;
        if refund > 1 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }
}

'''
'''--- flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- multi-token-standard-impl/Cargo.toml ---
[package]
name = "multi-token-standards"
version = "0.0.0"
authors = ["Ships Gold zane@ships.gold"]
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0-pre.2" 
near-sdk-sim = "4.0.0-pre.2"
 

# remember to include a line for each contract
multi-token-standard = { path = "./multi_token" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "multi_token",
]

exclude = [
  "examples/multi-token",
]

'''
'''--- multi-token-standard-impl/README.md ---
# MultiToken Standard Experimentation 

This approach is to build a standard for erc-1155 for Near. This particular branch is to see the issues that arise from combining
the FT Standard with the NFT Standard , and producing a collection of FT and NFTs.

## Build
cargo build

'''
'''--- multi-token-standard-impl/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- multi-token-standard-impl/examples/multi-token/Cargo.toml ---
[package]
name = "multi-token-wrapper"
version = "0.0.1"
authors = ["zane@ships.gold"]
edition = "2018"

[dev-dependencies]
multi-token-standard = { path = "../../multi_token" }
near-sdk = "4.0.0-pre.2" 
near-sdk-sim = "4.0.0-pre.2"
rand = "0.8.4"

# remember to include a line for each contract
multi-token = { path = "./mt" }
token-receiver = { path = "./test-token-receiver" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "mt",
  "test-token-receiver"
]

'''
'''--- multi-token-standard-impl/examples/multi-token/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cargo build --all --target wasm32-unknown-unknown --release
mkdir res || true
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- multi-token-standard-impl/examples/multi-token/mt/Cargo.toml ---
  
[package]
name = "multi-token"
version = "0.0.1"
authors = ["Ships Gold zane@ships.gold"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.2"
multi-token-standard = { path = "../../../multi_token" }
'''
'''--- multi-token-standard-impl/examples/multi-token/mt/src/lib.rs ---
/*!
Multi Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use multi_token_standard::metadata::MultiTokenMetadata;
use multi_token_standard::MultiToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{
    env, log, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: MultiToken,
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
enum StorageKey {
    MultiTokenOwner,
    MultiTokenMetadata,
    MultiTokenSupply,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            token: MultiToken::new(
                StorageKey::MultiTokenOwner,
                owner_id,
                Some(StorageKey::MultiTokenMetadata),
                StorageKey::MultiTokenSupply,
            ),
        }
    }

    fn refund_deposit(&self, storage_used: u64) {
        let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
        let attached_deposit = env::attached_deposit();
        assert!(
            required_cost <= attached_deposit,
            "Must attach {} yoctoNEAR to cover storage",
            required_cost,
        );
        let refund = attached_deposit - required_cost;
        if refund > 1 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }

    #[payable]
    pub fn mint(
        &mut self,
        token_id: TokenId,
        token_type: TokenType,
        amount: Option<U128>,
        token_owner_id: AccountId,
        token_metadata: Option<MultiTokenMetadata>,
    ) {
        let initial_storage_usage = env::storage_usage();
        require!(env::predecessor_account_id() == self.token.owner_id, "Unauthorized");
        // TODO: shouldn't this be is_none?
        // if self.token.token_metadata_by_id.is_some() && token_metadata.is_none() {
        //     env::panic_str("Must provide metadata");
        // }

        // Every token must have a token type and every NFT type cannot be re-minted
        match self.token.token_type_index.get(&token_id) {
            Some(TokenType::Ft) => {
                require!(
                    token_type == TokenType::Ft,
                    "Type must be of FT time tokenId already exists"
                )
            }
            Some(TokenType::Nft) => {
                env::panic_str("Attempting to mint already minted NFT");
            }
            None => {
                self.token.token_type_index.insert(&token_id, &token_type);
            }
        }

        let owner_id: AccountId = token_owner_id;
        // Core behavior: every token must have an owner
        match token_type {
            TokenType::Ft => {
                if amount.is_none() {
                    env::panic_str("Amount must be specified for Ft type tokens");
                }
                // advance the prefix index before insertion
                let amt = u128::from(amount.unwrap());
                //create LookupMap for balances
                match self.token.ft_owners_by_id.get(&token_id) {
                    Some(mut balances) => {
                        let current_bal = balances.get(&owner_id).unwrap_or(0);
                        // TODO not quite safe
                        if amt == 0 {
                            env::panic_str("error: amount should be greater than 0")
                        }
                        balances.insert(&owner_id, &(current_bal + amt));
                        let supply = self.token.ft_token_supply_by_id.get(&token_id).unwrap();
                        self.token.ft_token_supply_by_id.insert(&token_id, &(supply + amt));
                    }
                    None => {
                        let mut balances = self.token.internal_new_ft_balances();
                        // insert amount into balances
                        balances.insert(&owner_id, &amt);
                        self.token.ft_owners_by_id.insert(&token_id, &balances);
                        self.token.ft_token_supply_by_id.insert(&token_id, &amt);
                    }
                }
            }
            TokenType::Nft => {
                self.token.nft_owner_by_id.insert(&token_id, &owner_id);
            }
        }
        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.token.token_metadata_by_id.as_mut().and_then(|by_id| {
            by_id.insert(
                &token_id,
                &token_metadata.as_ref().unwrap_or(&MultiTokenMetadata {
                    spec: "aa".to_string(),   // required, essentially a version like "mt-1.0.0"
                    name: "aa".to_string(),   // required, ex. "Mosaics"
                    symbol: "aa".to_string(), // required, ex. "MOSIAC"
                    icon: None,               // Data URL
                    base_uri: None, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
                    decimals: Some(12), // precision decimals for tokens that need this information
                    reference: None, // URL to a JSON file with more info
                    reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
                    title: None,          // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
                    description: None,    // free-form description
                    media: None, // URL to associated media, preferably to decentralized, content-addressed storage
                    media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
                    copies: None, // number of copies of this set of metadata in existence when token was minted.
                    issued_at: None, // ISO 8601 datetime when token was issued or minted
                    expires_at: None, // ISO 8601 datetime when token expires
                    starts_at: None, // ISO 8601 datetime when token starts being valid
                    updated_at: None, // ISO 8601 datetime when token was last updated
                    extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
                }),
            )
        });
        // Return any extra attached deposit not used for storage
        self.refund_deposit(env::storage_usage() - initial_storage_usage);
    }
}
multi_token_standard::impl_multi_token_core!(Contract, token);
multi_token_standard::impl_multi_token_storage!(Contract, token);

'''
'''--- multi-token-standard-impl/examples/multi-token/test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Zane <zane@ships.gold>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.2"
multi-token-standard = { path = "../../../multi_token" }
'''
'''--- multi-token-standard-impl/examples/multi-token/test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements mt_on_transfer for simulation testing mt_transfer_call.
*/
use multi_token_standard::core::MultiTokenReceiver;
use multi_token_standard::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, Balance, Gas, PanicOnDefault, PromiseOrValue,
};

const BASE_GAS: Gas = Gas(5_000_000_000_000);
const PROMISE_CALL: Gas = Gas(5_000_000_000_000);
// TODO refactor this gas calculation
const GAS_FOR_MT_ON_TRANSFER:Gas = Gas(10_000_000_000_000);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    multi_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: Vec<U128>) -> PromiseOrValue<Vec<U128>>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn ok_go(&self, return_it: Vec<U128>) -> PromiseOrValue<Vec<U128>>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(multi_token_account_id: AccountId) -> Self {
        Self { multi_token_account_id }
    }
}

#[near_bindgen]
impl MultiTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    ///
    fn mt_on_transfer(
        &mut self,
        sender_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: String,
    ) -> PromiseOrValue<Vec<U128>> {
        log!("in mt_on_transfer; sender_id={}, token_id={:?}, msg={}", &sender_id, &token_ids, msg);
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.multi_token_account_id,
            "Only supports the one semi-fungible token contract"
        );
        log!("in mt_on_transfer; sender_id={}, token_id={:?}, msg={}", &sender_id, &token_ids, msg);
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(amounts),
            "return-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(
                    amounts,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_MT_ON_TRANSFER,
                )
                .into()
            }
            "keep-it-now" => PromiseOrValue::Value(vec![0.into(); amounts.len()]),
            "keep-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(
                    vec![0.into(); amounts.len()],
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_MT_ON_TRANSFER,
                )
                .into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: Vec<U128>) -> PromiseOrValue<Vec<U128>> {
        log!("in ok_go, return_it={}", return_it.len());
        PromiseOrValue::Value(return_it)
    }
}

'''
'''--- multi-token-standard-impl/examples/multi-token/tests/sim/main.rs ---
mod utils;
mod test_core;
'''
'''--- multi-token-standard-impl/examples/multi-token/tests/sim/test_core.rs ---
use crate::utils::{check_balance, init, FT_TOKEN_ID, NFT_TOKEN_ID};
use near_sdk::json_types::U128;
use near_sdk_sim::{call, view, DEFAULT_GAS};

#[test]
fn simulate_simple_transfer_nft() {
    let (root, mt, alice, _) = init();
    let nft_amount: U128 =
        view!(mt.balance_of(root.account_id(), NFT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(nft_amount.0, 1);
    call!(
        root,
        mt.mt_transfer(
            alice.account_id(),
            NFT_TOKEN_ID.into(),
            1.into(),
            Some("simple transfer".to_string())
        ),
        deposit = 1
    )
    .assert_success();

    let remaining_amount: U128 =
        view!(mt.balance_of(root.account_id(), NFT_TOKEN_ID.into())).unwrap_json();
    let transfered_amount: U128 =
        view!(mt.balance_of(alice.account_id(), NFT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(transfered_amount.0, 1);
    assert_eq!(remaining_amount.0, 0);
}

#[test]
fn simulate_simple_transfer_ft() {
    let (root, mt, alice, _) = init();
    let ft_amount: U128 = view!(mt.balance_of(root.account_id(), FT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(ft_amount.0, 100);

    call!(
        root,
        mt.mt_transfer(
            alice.account_id(),
            FT_TOKEN_ID.into(),
            75.into(),
            Some("simple transfer".to_string())
        ),
        deposit = 1
    )
    .assert_success();

    let remaining_amount: U128 =
        view!(mt.balance_of(root.account_id(), FT_TOKEN_ID.into())).unwrap_json();
    let transfered_amount: U128 =
        view!(mt.balance_of(alice.account_id(), FT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(transfered_amount.0, 75);
    assert_eq!(remaining_amount.0, 25);
}

#[test]
fn simulate_simple_transfer_batch() {
    let (root, mt, alice, _) = init();
    call!(
        root,
        mt.mt_batch_transfer(
            alice.account_id(),
            vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
            vec![75.into(), 1.into()],
            Some("simple transfer".to_string())
        ),
        deposit = 1
    )
    .assert_success();

    let mut remaining_amount: U128 =
        view!(mt.balance_of(root.account_id(), FT_TOKEN_ID.into())).unwrap_json();
    let mut transfered_amount: U128 =
        view!(mt.balance_of(alice.account_id(), FT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(transfered_amount.0, 75);
    assert_eq!(remaining_amount.0, 25);

    remaining_amount = view!(mt.balance_of(root.account_id(), NFT_TOKEN_ID.into())).unwrap_json();
    transfered_amount = view!(mt.balance_of(alice.account_id(), NFT_TOKEN_ID.into())).unwrap_json();
    assert_eq!(transfered_amount.0, 1);
    assert_eq!(remaining_amount.0, 0);
}

#[test]
fn simulate_transfer_call_fast_return_to_sender() {
    let (root, mt, _, receiver) = init();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    call!(
        root,
        mt.mt_transfer_call(
            receiver.account_id(),
            FT_TOKEN_ID.into(),
            75.into(),
            Some("transfer & call".into()),
            "return-it-now".into()
        ),
        deposit = 1
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 0);
}

#[test]
fn simulate_batch_transfer_call_fast_return_to_sender() {
    let (root, mt, _, receiver) = init();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    let outcome = call!(
        root,
        1,
        DEFAULT_GAS,
        mt,
        mt_batch_transfer_call,
        receiver.account_id(),
        vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
        vec![75.into(), 1.into()],
        Some("transfer & call".into()),
        "return-it-now".into()
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 0);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    check_balance(&mt, receiver.account_id(), NFT_TOKEN_ID.to_string(), 0);
}

#[test]
fn simulate_batch_transfer_call_slow_return_to_sender() {
    let (root, mt, _, receiver) = init();
    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    call!(
        root,
        mt.mt_batch_transfer_call(
            receiver.account_id(),
            vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
            vec![75.into(), 1.into()],
            Some("transfer & call".into()),
            "return-it-later".into()
        ),
        deposit = 1
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 0);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    check_balance(&mt, receiver.account_id(), NFT_TOKEN_ID.to_string(), 0);
}

#[test]
fn simulate_batch_transfer_call_fast_keep_with_sender() {
    let (root, mt, _, receiver) = init();
    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    call!(
        root,
        mt.mt_batch_transfer_call(
            receiver.account_id(),
            vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
            vec![75.into(), 1.into()],
            Some("transfer & call".into()),
            "keep-it-now".into()
        ),
        deposit = 1
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 25);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 75);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 0);
    check_balance(&mt, receiver.account_id(), NFT_TOKEN_ID.to_string(), 1);
}

#[test]
fn simulate_transfer_batch_call_slow_keep_with_sender() {
    let (root, mt, _, receiver) = init();
    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    call!(
        root,
        mt.mt_batch_transfer_call(
            receiver.account_id(),
            vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
            vec![75.into(), 1.into()],
            Some("transfer & call".into()),
            "keep-it-later".into()
        ),
        deposit = 1
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 25);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 75);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 0);
    check_balance(&mt, receiver.account_id(), NFT_TOKEN_ID.to_string(), 1);
}

#[test]
fn simulate_transfer_call_receiver_panics() {
    let (root, mt, _, receiver) = init();
    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    call!(
        root,
        mt.mt_batch_transfer_call(
            receiver.account_id(),
            vec![FT_TOKEN_ID.into(), NFT_TOKEN_ID.into()],
            vec![75.into(), 1.into()],
            Some("transfer & call".into()),
            "make-it-panic".into()
        ),
        deposit = 1
    )
    .assert_success();

    check_balance(&mt, root.account_id(), FT_TOKEN_ID.to_string(), 100);
    check_balance(&mt, receiver.account_id(), FT_TOKEN_ID.to_string(), 0);
    check_balance(&mt, root.account_id(), NFT_TOKEN_ID.to_string(), 1);
    check_balance(&mt, receiver.account_id(), NFT_TOKEN_ID.to_string(), 0);
}

'''
'''--- multi-token-standard-impl/examples/multi-token/tests/sim/utils.rs ---
use multi_token::ContractContract as MtContract;
use multi_token_standard::metadata::{MultiTokenMetadata, MT_METADATA_SPEC};
use multi_token_standard::{TokenId, TokenType};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::AccountId;
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount, view};
use rand::prelude::*;
use token_receiver::TokenReceiverContract;

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    MT_WASM_BYTES => "res/multi_token.wasm",
    TOKEN_RECEIVER_WASM_BYTES => "res/token_receiver.wasm",
}

pub const MT_ID: &str = "mt";
const TOKEN_RECEIVER_ID: &str = "token-receiver";
pub const NFT_TOKEN_ID: &str = "1";
pub const FT_TOKEN_ID: &str = "2";

pub fn generate_random_token_tuples(
    size: u128,
) -> (Vec<TokenId>, Vec<TokenType>, Vec<U128>, Vec<Option<MultiTokenMetadata>>) {
    let mut token_types: Vec<TokenType> = vec![];
    let mut amounts: Vec<U128> = vec![];
    let mut token_ids: Vec<TokenId> = vec![];
    let mut metadatas: Vec<Option<MultiTokenMetadata>> = vec![];
    let mut counter: u128 = 0;
    for _ in 1..size {
        if rand::random::<bool>() == true {
            token_types.push(TokenType::Ft);
            let amount: u128 = rand::random::<u128>();
            amounts.push(amount.into());
        } else {
            token_types.push(TokenType::Nft);
            amounts.push(1.into());
        }
        let metadata = if rand::random::<bool>() == true {
            Some(MultiTokenMetadata {
                reference: Some("/some/uri/reference/{id}_token.json".into()),
                reference_hash: None,
                title: None,
                description: None,
                media: None,
                media_hash: None,
                copies: None,
                issued_at: None,
                expires_at: None,
                starts_at: None,
                updated_at: None,
                spec: MT_METADATA_SPEC.to_string(),
                name: "".to_string(),
                symbol: "".to_string(),
                icon: None,
                base_uri: None,
                decimals: None,
                extra: None,
            })
        } else {
            None
        };
        metadatas.push(metadata);
        token_ids.push(format!("generated_{}", counter));
    }
    (token_ids, token_types, amounts, metadatas)
}

// Register the given `user` with a set of token_ids
pub fn register_user(user: &near_sdk_sim::UserAccount, acct_id: AccountId, token_ids: &Vec<TokenId>) {
    user.call(
        AccountId::new_unchecked(MT_ID.to_string()),
        "storage_deposit",
        &json!({
            "token_ids": token_ids,
            "account_id": acct_id 
        })
            .to_string()
            .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 700, // attached deposit
    )
        .assert_success();
}

/// Initialize simulator and return:
/// * root: the root user, set as owner_id for NFT contract, owns a token with ID=1
/// * nft: the NFT contract, callable with `call!` and `view!`
/// * alice: a user account, does not yet own any tokens
/// * token_receiver: a contract implementing `nft_on_transfer` for use with `transfer_and_call`
pub fn init() -> (UserAccount, ContractAccount<MtContract>, UserAccount, ContractAccount<TokenReceiverContract>)
{
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let mt = deploy!(
        // Contract Proxy
        contract: MtContract,
        // Contract account id
        contract_id: MT_ID,
        // Bytes of contract
        bytes: &MT_WASM_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new(
            root.account_id()
        )
    );

    let alice = root.create_user(AccountId::new_unchecked("alice".to_string()), to_yocto("100"));
    let dummy_metadata = MultiTokenMetadata {
        reference: Some("/some/uri/reference/{id}_token.json".into()),
        reference_hash: None,
        title: None,
        description: None,
        media: None,
        media_hash: None,
        copies: None,
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        spec: MT_METADATA_SPEC.to_string(),
        name: "".to_string(),
        symbol: "".to_string(),
        icon: None,
        base_uri: None,
        decimals: None,
        extra: None,
    };

    let token_receiver = deploy!(
        contract: TokenReceiverContract,
        contract_id: TOKEN_RECEIVER_ID,
        bytes: &TOKEN_RECEIVER_WASM_BYTES,
        signer_account: root,
        init_method: new(
            mt.account_id()
        )
    );
    call!(
         root,
        mt.mint(
            NFT_TOKEN_ID.to_string(),
            TokenType::Nft,
            None,
            root.account_id(),
            Some(dummy_metadata.clone())
        ),
        deposit = 7000000000000000000000
    );

    call!(
        root,
        mt.mint(
            FT_TOKEN_ID.to_string(),
            TokenType::Ft,
            Some(100.into()),
            root.account_id(),
            Some(dummy_metadata)
        ),
        deposit = 7000000000000000000000
    );
    register_user(&alice, alice.account_id(), &vec![FT_TOKEN_ID.to_string()]);
    register_user(&root, token_receiver.account_id(), &vec![FT_TOKEN_ID.to_string()]);
    (root, mt, alice, token_receiver)
}

pub fn check_balance(
    mt: &ContractAccount<MtContract>,
    account_id: AccountId,
    token_id: TokenId,
    expected_amt: u128,
) {
    let amount: U128 = view!(mt.balance_of(account_id, token_id)).unwrap_json();
    assert_eq!(amount.0, expected_amt);
}

pub fn init_batch() {}

pub fn helper_mint(
    token_id: TokenId,
    root: &UserAccount,
    mt: &ContractAccount<MtContract>,
    title: String,
    desc: String,
) {}

'''
'''--- multi-token-standard-impl/multi_token/Cargo.toml ---
[package]
name = "multi-token-standard"
version = "0.0.1"
authors = ["Ships Gold <zane@ships.gold>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.2" 
near-contract-standards = "4.0.0-pre.2" 
'''
'''--- multi-token-standard-impl/multi_token/src/core/core_impl.rs ---
use crate::core::MultiTokenCore;
use crate::core::resolver::MultiTokenResolver;
use crate::metadata::{MultiTokenMetadata, MT_METADATA_SPEC};
use crate::token::{TokenId, TokenType};
use crate::utils::refund_deposit;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap};
use near_sdk::json_types::{U128};
use near_sdk::{
	assert_one_yocto, env, ext_contract, log, AccountId, Balance, Gas, IntoStorageKey,
	PromiseOrValue, PromiseResult, StorageUsage,
};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_self)]
trait MultiTokenResolver {
	fn mt_resolve_transfer(
		&mut self,
		sender_id: AccountId,
		receiver_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
	) -> Vec<U128>;
}

#[ext_contract(ext_receiver)]
pub trait MultiTokenReceiver {
	/// Returns true if token should be returned to `sender_id`
	fn mt_on_transfer(
		&mut self,
		sender_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
		msg: String,
	) -> PromiseOrValue<Vec<U128>>;
}

/// Implementation of MultiToken-token standard.
/// There are next traits that any contract may implement:
///     - MultiTokenCore -- interface with mt_transfer/balance/supply methods. MultiToken provides methods for it.
///     - MultiTokenApproval -- interface with mt_approve methods. MultiToken provides methods for it.
///     - MultiTokenMetadata -- return metadata for the token in NEP-177, up to contract to implement.
///
/// For example usage, see examples/non-fungible-token/src/lib.rs.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultiToken {
	// owner of contract; this is the only account allowed to call `mint`
	pub owner_id: AccountId,

	// The storage size in bytes for each new token
	pub extra_storage_in_bytes_per_nft_token: StorageUsage,
	pub ft_account_storage_usage: StorageUsage,
	pub ft_token_storage_usage: StorageUsage,

	// index token id and token type to aid in uniqueness guarantees
	pub token_type_index: LookupMap<TokenId, TokenType>,

	// always required TokenId corresponds to nft
	pub nft_owner_by_id: LookupMap<TokenId, AccountId>,

	// always required TokenId corresponds to ft
	pub ft_owners_by_id: LookupMap<TokenId, LookupMap<AccountId, Balance>>,

	pub owner_prefix: Vec<u8>,
	pub ft_prefix_index: u64,

	// always required mapping to token supply
	pub ft_token_supply_by_id: LookupMap<TokenId, u128>,

	// required by metadata extension
	pub token_metadata_by_id: Option<LookupMap<TokenId, MultiTokenMetadata>>,
}

impl MultiToken {
	pub fn new<Q, R, T>(
		owner_by_id_prefix: Q,
		owner_id: AccountId,
		token_metadata_prefix: Option<R>,
		supply_by_id_prefix: T,
	) -> Self
	where
		Q: IntoStorageKey,
		R: IntoStorageKey,
		T: IntoStorageKey,
	{
		let owner_prefix: Vec<u8> = owner_by_id_prefix.into_storage_key();
		let token_type_prefix = [owner_prefix.clone(), "t".into()].concat();
		let mut this = Self {
			owner_id,
			owner_prefix: owner_prefix.clone(),
			ft_token_storage_usage: 0,
			ft_account_storage_usage: 0,
			extra_storage_in_bytes_per_nft_token: 0,
			ft_owners_by_id: LookupMap::new(owner_prefix.clone()),
			nft_owner_by_id: LookupMap::new([owner_prefix, "n".into()].concat()),
			token_type_index: LookupMap::new(token_type_prefix.into_storage_key()),
			ft_prefix_index: 0,
			ft_token_supply_by_id: LookupMap::new(supply_by_id_prefix.into_storage_key()),
			token_metadata_by_id: token_metadata_prefix.map(LookupMap::new),
		};
		this.measure_min_ft_token_storage_cost();
		this.measure_min_nft_token_storage_cost();
		this
	}

	// returns the current storage key prefix for a ft
	fn get_balances_prefix(&self) -> Vec<u8> {
		let mut ft_token_prefix = self.owner_prefix.clone();
		ft_token_prefix.extend(&self.ft_prefix_index.to_be_bytes().to_vec());
		ft_token_prefix
	}

	// increases the internal index for storage keys for balance maps for tokens
	fn inc_balances_prefix(&mut self) {
		self.ft_prefix_index += 1;
	}

	fn measure_min_ft_token_storage_cost(&mut self) {
		let initial_storage_usage = env::storage_usage();

		// 1. add data to calculate space usage
		let mut tmp_balance_lookup: LookupMap<AccountId, Balance> =
			LookupMap::new(self.get_balances_prefix());
		self.ft_token_storage_usage = initial_storage_usage - env::storage_usage();
		let storage_after_token_creation = env::storage_usage();
		let tmp_token_id = "a".repeat(64); // TODO: what's a reasonable max TokenId length?
		let tmp_owner_id = AccountId::new_unchecked("a".repeat(64));
		let tmp_supply: u128 = 9999;
		tmp_balance_lookup.insert(&tmp_owner_id, &tmp_supply);
		self.ft_owners_by_id.insert(&tmp_token_id, &tmp_balance_lookup);

		// 2. measure the space taken up
		self.ft_account_storage_usage = env::storage_usage() - storage_after_token_creation;

		// 3. roll it all back
		self.ft_owners_by_id.remove(&tmp_token_id);
	}

	fn measure_min_nft_token_storage_cost(&mut self) {
		let initial_storage_usage = env::storage_usage();
		// 1. set some dummy data
		let tmp_token_id = "a".repeat(64); // TODO: what's a reasonable max TokenId length?
		let tmp_owner_id = AccountId::new_unchecked("a".repeat(64));

		self.nft_owner_by_id.insert(&tmp_token_id, &tmp_owner_id);
		if let Some(token_metadata_by_id) = &mut self.token_metadata_by_id {
			token_metadata_by_id.insert(
				&tmp_token_id,
				&MultiTokenMetadata {
					name: "a".repeat(64),
					symbol: "a".repeat(64),
					spec: MT_METADATA_SPEC.to_string(),
					icon: None,
					base_uri: None,
					decimals: None,
					reference: None,
					reference_hash: None,
					title: None,
					description: None,
					media: None,
					media_hash: None,
					copies: None,
					issued_at: None,
					expires_at: None,
					starts_at: None,
					updated_at: None,
					extra: None
				},
			);
		}

		// 2. see how much space it took
		self.extra_storage_in_bytes_per_nft_token = env::storage_usage() - initial_storage_usage;

		if let Some(token_metadata_by_id) = &mut self.token_metadata_by_id {
			token_metadata_by_id.remove(&tmp_token_id);
		}

		self.nft_owner_by_id.remove(&tmp_token_id);
	}

	pub fn internal_new_ft_balances(&mut self)-> LookupMap<AccountId, Balance> {
		self.inc_balances_prefix();
		LookupMap::new(self.get_balances_prefix())
	}

	pub fn internal_register_account(&mut self, token_id: TokenId, account_id: &AccountId) {
		let token_type = self
			.token_type_index
			.get(&token_id)
			.unwrap_or_else(|| env::panic_str(format!("token_id {} not found", token_id).as_str()));
		if token_type == TokenType::Ft
			&& self.ft_owners_by_id.get(&token_id).unwrap().insert(&account_id, &0).is_some()
		{
			env::panic_str("The account is already registered");
		}
	}

	pub fn internal_unwrap_balance_of(
		&self,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		account_id: &AccountId,
	) -> Balance {
		let balances = self
			.ft_owners_by_id
			.get(token_id)
			.unwrap_or_else(|| env::panic_str(format!("Token id is not valid {}", token_id).as_str()));
		balances.get(account_id).unwrap_or_else(|| {
			env::panic_str(format!("The account_id {} is not found", account_id).as_str())
		})
	}

	pub fn internal_deposit(
		&mut self,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		account_id: &AccountId,
		amount: Balance,
	) {
		let balance = self.internal_unwrap_balance_of(token_id, account_id);
		if let Some(new_balance) = balance.checked_add(amount) {
			self.ft_owners_by_id.get(token_id).unwrap().insert(&account_id, &new_balance);
			let total_supply = self.ft_token_supply_by_id.get(token_id).unwrap();
			let new_supply = total_supply.checked_add(amount).expect("Total supply overflow");
			self.ft_token_supply_by_id.insert(token_id, &new_supply);
		} else {
			env::panic_str("Balance overflow");
		}
	}

	pub fn internal_withdraw(
		&mut self,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		account_id: &AccountId,
		amount: Balance,
	) {
		let balance = self.internal_unwrap_balance_of(token_id, account_id);
		if let Some(new_balance) = balance.checked_sub(amount) {
			self.ft_owners_by_id.get(token_id).unwrap().insert(&account_id, &new_balance);
			let total_supply = self.ft_token_supply_by_id.get(token_id).unwrap();
			let new_supply = total_supply.checked_sub(amount).expect("Total supply overflow");
			self.ft_token_supply_by_id.insert(token_id, &new_supply);
		} else {
			env::panic_str("The account doesn't have enough balance");
		}
	}

	/// Transfer token_id from `from` to `to`
	///
	///
	pub fn internal_transfer_unguarded(
		&mut self,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		amount: u128,
		from: &AccountId,
		to: &AccountId,
	) {
		// update owner
		match self.token_type_index.get(token_id) {
			Some(TokenType::Nft) => {
				self.nft_owner_by_id.insert(token_id, to);
			}
			Some(TokenType::Ft) => {
				self.internal_withdraw(token_id, from, amount);
				self.internal_deposit(token_id, to, amount);
			}
			_ => (),
		};
	}

	fn verify_ft_transferable(
		&self,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		sender_id: &AccountId,
		receiver_id: &AccountId,
		amount: u128,
	) {
		if sender_id == receiver_id {
			env::panic_str("Sender and receiver cannot be the same")
		}
		let token_holders = self.ft_owners_by_id.get(token_id).expect("Could not find token");
		let balance = token_holders.get(sender_id).expect("Not a token owner");
		if balance < amount {
			env::panic_str("Amount exceeds balance");
		}
	}

	/// Transfer from current owner to receiver_id, checking that sender is allowed to transfer.
	/// Clear approvals, if approval extension being used.
	/// Return previous owner and approvals.
	pub fn internal_transfer(
		&mut self,
		sender_id: &AccountId,
		receiver_id: &AccountId,
		#[allow(clippy::ptr_arg)] token_id: &TokenId,
		amount: u128,
		memo: Option<String>,
	) {
		let token_type = self.token_type_index.get(token_id).expect("Token not found");
		let mut owner_id = sender_id.clone();
		match token_type {
			TokenType::Nft => {
				owner_id = self.nft_owner_by_id.get(token_id).unwrap();
				assert_ne!(&owner_id, receiver_id, "Current and next owner must differ");
				assert_eq!(&owner_id, sender_id, "Unauthorized sender must be owner");
			}
			TokenType::Ft => {
				self.verify_ft_transferable(token_id, sender_id, receiver_id, amount);
			}
		}
		self.internal_transfer_unguarded(&token_id, amount, &owner_id, &receiver_id);
		// TODO this might be problematic if 100 log limit and called from a looping construct
		log!("Transfer {} from {} to {}", token_id, sender_id, receiver_id);
		if let Some(memo) = memo {
			log!("Memo: {}", memo);
		}
	}

	pub fn internal_transfer_batch(
		&mut self,
		sender_id: &AccountId,
		receiver_id: &AccountId,
		#[allow(clippy::ptr_arg)] token_ids: &Vec<TokenId>,
		#[allow(clippy::ptr_arg)] amounts: &Vec<U128>,
		memo: Option<String>,
	) {
		if token_ids.len() != amounts.len() {
			env::panic_str("Number of token ids and amounts must be equal")
		}
		token_ids.iter().enumerate().for_each(|(idx, token_id)| {
			self.internal_transfer(
				sender_id,
				receiver_id,
				&token_id,
				amounts[idx].into(),
				memo.clone(),
			)
		});
	}
}

impl MultiTokenCore for MultiToken {
	fn mt_transfer(
		&mut self,
		receiver_id: AccountId,
		token_id: TokenId,
		amount: U128,
		memo: Option<String>,
	) {
		assert_one_yocto();
		let sender_id = env::predecessor_account_id();
		self.internal_transfer(&sender_id, &receiver_id, &token_id, amount.into(), memo);
	}

	fn mt_transfer_call(
		&mut self,
		receiver_id: AccountId,
		token_id: TokenId,
		amount: U128,
		memo: Option<String>,
		msg: String,
	) -> PromiseOrValue<U128> {
		assert_one_yocto();
		let sender_id = env::predecessor_account_id();
		self.internal_transfer(&sender_id, &receiver_id, &token_id, amount.into(), memo);
		// Initiating receiver's call and the callback
		ext_receiver::mt_on_transfer(
			sender_id.clone(),
			vec![token_id.clone()],
			vec![amount],
			msg,
			receiver_id.clone(),
			NO_DEPOSIT,
			env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
		)
		.then(ext_self::mt_resolve_transfer(
			sender_id,
			receiver_id,
			vec![token_id],
			vec![amount],
			env::current_account_id(),
			NO_DEPOSIT,
			GAS_FOR_RESOLVE_TRANSFER,
		))
		.into()
	}

	fn mt_batch_transfer(
		&mut self,
		receiver_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
		memo: Option<String>,
	) {
		assert_one_yocto();
		let sender_id = env::predecessor_account_id();
		self.internal_transfer_batch(&sender_id, &receiver_id, &token_ids, &amounts, memo);
	}

	fn mt_batch_transfer_call(
		&mut self,
		receiver_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
		memo: Option<String>,
		msg: String,
	) -> PromiseOrValue<Vec<U128>> {
		assert_one_yocto();
		let sender_id = env::predecessor_account_id();
		self.internal_transfer_batch(&sender_id, &receiver_id, &token_ids, &amounts, memo);
		log!(
			"Transferring data to:{} from sender: {}, p_gas: {}",
			receiver_id,
			sender_id,
			env::prepaid_gas().0
		);
		// TODO make this efficient and calculate gas 
		ext_receiver::mt_on_transfer(
			sender_id.clone(),
			token_ids.clone(),
			amounts.clone(),
			msg,
			receiver_id.clone(),
			NO_DEPOSIT,
			Gas(25_000_000_000_000),
		)
		.then(ext_self::mt_resolve_transfer(
			sender_id,
			receiver_id,
			token_ids,
			amounts,
			env::current_account_id(),
			NO_DEPOSIT,
			Gas(5_000_000_000_000),
			//GAS_FOR_RESOLVE_TRANSFER,
		))
		.into()
	}

	fn balance_of(&self, owner_id: AccountId, token_id: TokenId) -> U128 {
		match self.token_type_index.get(&token_id).expect("Token type does not exist") {
			TokenType::Ft => {
				let ft_token = self.ft_owners_by_id.get(&token_id).expect("balance: token id not found");
				ft_token.get(&owner_id).unwrap_or(0).into()
			}
			TokenType::Nft => {
				let owner = self.nft_owner_by_id.get(&token_id).expect("Token does not exist");
				if owner == owner_id {
					return 1.into();
				}
				0.into()
			}
		}
	}

	fn balance_of_batch(&self, owner_id: AccountId, token_ids: Vec<TokenId>) -> Vec<U128> {
		token_ids.iter().map(|token_id| self.balance_of(owner_id.clone(), token_id.clone())).collect()
	}

	fn total_supply(&self, token_id: TokenId) -> U128 {
		self.ft_token_supply_by_id.get(&token_id).expect("supply: token id not found").into()
	}

	fn total_supply_batch(&self, token_ids: Vec<TokenId>) -> Vec<U128> {
		token_ids
			.iter()
			.map(|token_id| {
				self.ft_token_supply_by_id.get(&token_id).expect("supply: token id not found").into()
			})
			.collect()
	}
}

impl MultiToken {
	pub fn mt_internal_resolve_transfer(
		&mut self,
		sender_id: AccountId,
		receiver_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
	) -> Vec<U128> {
		let returned_amounts: Vec<U128> = match env::promise_result(0) {
			PromiseResult::NotReady => unreachable!(),
			PromiseResult::Successful(value) => {
				if let Ok(returned_amount) = near_sdk::serde_json::from_slice::<Vec<U128>>(&value) {
					assert_eq!(returned_amount.len(), amounts.len(), "Amounts returned do not match length");
					returned_amount
				} else {
					amounts.clone()
				}
			}
			PromiseResult::Failed => amounts.clone(),
		};
		returned_amounts
			.iter()
			.enumerate()
			.map(|(idx, returned_amount)| {
				let ret_amt: u128 = returned_amount.clone().into();
				if ret_amt == 0 {
					return U128::from(0);
				}
				match self.token_type_index.get(&token_ids[idx]).expect("Token type does not exist") {
					TokenType::Ft => {
						let unused_amount = std::cmp::min(amounts[idx].into(), returned_amount.clone().into());
						let err_msg = &format!("Token id {} does not exist", &token_ids[idx]);
						let mut balances = self.ft_owners_by_id.get(&token_ids[idx]).expect(err_msg);
						let receiver_balance =
							balances.get(&receiver_id).expect("Token receiver no longer exists");
						if receiver_balance > 0 {
							let refund_amount: u128 = std::cmp::min(receiver_balance, unused_amount);
							balances.insert(&receiver_id, &(receiver_balance - refund_amount));
							return match balances.get(&sender_id) {
								Some(sender_balance) => {
									balances.insert(&sender_id, &(sender_balance + refund_amount));
									log!("Refund {} from {} to {}", refund_amount, receiver_id, sender_id);
									let amount: u128 = amounts[idx].into();
									U128::from(amount - refund_amount)
								}
								None => {
									let supply =
										self.ft_token_supply_by_id.get(&token_ids[idx]).expect("Token has no supply");
									self.ft_token_supply_by_id.insert(&token_ids[idx], &(supply - refund_amount));
									log!("The account of the sender was deleted");
									U128::from(0)
								}
							};
						} else {
							U128::from(0)
						}
					}
					TokenType::Nft => {
						if let Some(current_owner) = self.nft_owner_by_id.get(&token_ids[idx]) {
							return if current_owner != receiver_id {
								U128::from(0)
							} else {
								log!("Return token {} from @{} to @{}", token_ids[idx], &receiver_id, &sender_id);
								self.internal_transfer_unguarded(&token_ids[idx], 1, &receiver_id, &sender_id);
								U128::from(1)
							}
						}
						U128::from(0)
					}
				}
			})
			.collect()
	}
}

impl MultiTokenResolver for MultiToken {
	fn mt_resolve_transfer(
		&mut self,
		sender_id: AccountId,
		receiver_id: AccountId,
		token_ids: Vec<TokenId>,
		amounts: Vec<U128>,
	) -> Vec<U128> {
		self.mt_internal_resolve_transfer(sender_id, receiver_id, token_ids, amounts)
	}
}

'''
'''--- multi-token-standard-impl/multi_token/src/core/mod.rs ---
mod core_impl;
mod receiver;
mod resolver;
mod storage_impl;

pub use self::core_impl::*;
pub use self::storage_impl::*;

pub use self::receiver::*;
pub use self::resolver::*;

use crate::token::TokenId;
use near_sdk::json_types::U128;
use near_sdk::{AccountId, PromiseOrValue};

pub trait MultiTokenCore {
    /// Basic token transfer. Transfer a token or tokens given a token_id. The token id can correspond to  
    /// either a NonFungibleToken or Fungible Token this is differeniated by the implementation.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    /// * If using Approval Management, contract MUST nullify approved accounts on
    ///   successful transfer.
    /// * TODO: needed? Both accounts must be registered with the contract for transfer to
    ///   succeed. See see https://nomicon.io/Standards/StorageManagement.html
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token
    /// * `token_id`: the token or tokens to transfer
    /// * `amount`: the token amount of tokens to transfer for token_id
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer
    fn mt_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: U128,
        memo: Option<String>,
    );

    /// Transfer token/s and call a method on a receiver contract. A successful
    /// workflow will end in a success execution outcome to the callback on the MultiToken
    /// contract at the method `mt_resolve_transfer`.
    ///
    /// You can think of this as being similar to attaching  tokens to a
    /// function call. It allows you to attach any Fungible or Non Fungible Token in a call to a
    /// receiver contract.
    ///
    /// Requirements:
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security
    ///   purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    ///   if using Approval Management, one of the approved accounts
    /// * The receiving contract must implement `mt_on_transfer` according to the
    ///   standard. If it does not, MultiToken contract's `mt_resolve_transfer` MUST deal
    ///   with the resulting failed cross-contract call and roll back the transfer.
    /// * Contract MUST implement the behavior described in `mt_resolve_transfer`
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token.
    /// * `token_id`: the token to send.
    /// * `amount`: amount of tokens to transfer for token_id
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer.
    /// * `msg`: specifies information needed by the receiving contract in
    ///    order to properly handle the transfer. Can indicate both a function to
    ///    call and the parameters to pass to that function.
    fn mt_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Batch token transfer. Transfer a tokens given token_ids and amounts. The token ids can correspond to  
    /// either Non-Fungible Tokens or Fungible Tokens or some combination of the two. The token ids
    /// are used to segment the types on a per contract implementation basis.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    ///   if using Approval Management, one of the approved accounts
    /// * `approval_id` is for use with Approval Management,
    ///   see https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html
    /// * If using Approval Management, contract MUST nullify approved accounts on
    ///   successful transfer.
    /// * TODO: needed? Both accounts must be registered with the contract for transfer to
    ///   succeed. See see https://nomicon.io/Standards/StorageManagement.html
    /// * The token_ids vec and amounts vec must be of equal length and equate to a 1-1 mapping
    ///   between amount and id. In the event that they do not line up the call should fail
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token
    /// * `token_ids`: the tokens to transfer
    /// * `amounts`: the amount of tokens to transfer for corresponding token_id
    /// * `approval_ids`: expected approval ID. A number smaller than
    ///    2^53, and therefore representable as JSON. See Approval Management
    ///    standard for full explanation. Must have same length as token_ids
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer

    fn mt_batch_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: Vec<TokenId>,
        amounts: Vec<U128>,
        memo: Option<String>,
    );
    /// Batch transfer token/s and call a method on a receiver contract. A successful
    /// workflow will end in a success execution outcome to the callback on the MultiToken
    /// contract at the method `mt_resolve_batch_transfer`.
    ///
    /// You can think of this as being similar to attaching  tokens to a
    /// function call. It allows you to attach any Fungible or Non Fungible Token in a call to a
    /// receiver contract.
    ///
    /// Requirements:
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security
    ///   purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    ///   if using Approval Management, one of the approved accounts
    /// * The receiving contract must implement `mt_on_transfer` according to the
    ///   standard. If it does not, MultiToken contract's `mt_resolve_batch_transfer` MUST deal
    ///   with the resulting failed cross-contract call and roll back the transfer.
    /// * Contract MUST implement the behavior described in `mt_resolve_batch_transfer`
    /// * `approval_id` is for use with Approval Management extension, see
    ///   that document for full explanation.
    /// * If using Approval Management, contract MUST nullify approved accounts on
    ///   successful transfer.
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token.
    /// * `token_ids`: the tokens to transfer
    /// * `amounts`: the amount of tokens to transfer for corresponding token_id
    /// * `approval_ids`: expected approval IDs. A number smaller than
    ///    2^53, and therefore representable as JSON. See Approval Management
    ///    standard for full explanation. Must have same length as token_ids
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer.
    /// * `msg`: specifies information needed by the receiving contract in
    ///    order to properly handle the transfer. Can indicate both a function to
    ///    call and the parameters to pass to that function.

    fn mt_batch_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<Vec<U128>>;

    /// Get the balance of an an account given token_id. For fungible token returns back amount, for
    /// non fungible token it returns back constant 1.
    fn balance_of(&self, owner_id: AccountId, token_id: TokenId) -> U128;

    /// Get the balances of an an account given token_ids. For fungible token returns back amount, for
    /// non fungible token it returns back constant 1. returns vector of balances corresponding to token_ids
    /// in a 1-1 mapping
    fn balance_of_batch(&self, owner_id: AccountId, token_ids: Vec<TokenId>) -> Vec<U128>;

    /// Returns the total supply of the token in a decimal string representation given token_id.
    fn total_supply(&self, token_id: TokenId) -> U128;

    // Returns the total supplies of the tokens given by token_ids in a decimal string representation.
    fn total_supply_batch(&self, token_ids: Vec<TokenId>) -> Vec<U128>;
}

'''
'''--- multi-token-standard-impl/multi_token/src/core/receiver.rs ---
use crate::token::TokenId;

use near_sdk::json_types::U128;
use near_sdk::{AccountId, PromiseOrValue};
/// Used when MultiTokens are transferred using `mt_transfer_call`. This trait is implemented on the receiving contract, not on the MultiToken contract.
pub trait MultiTokenReceiver {
    /// Take some action after receiving a MultiToken-tokens token
    ///
    /// Requirements:
    /// * Contract MUST restrict calls to this function to a set of whitelisted MultiToken
    ///   contracts
    ///
    /// Arguments:
    /// * `sender_id`: the sender of `mt_transfer_call`
    /// * `previous_owner_id`: the account that owned the tokens prior to it being
    ///   transferred to this contract, which can differ from `sender_id` if using
    ///   Approval Management extension
    /// * `token_ids`: the `token_ids` argument given to `mt_transfer_call`
    /// * `msg`: information necessary for this contract to know how to process the
    ///   request. This may include method names and/or arguments.
    ///
    /// Returns true if tokens should be returned to `sender_id`
    fn mt_on_transfer(
        &mut self,
        sender_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: String,
    ) -> PromiseOrValue<Vec<U128>>;
}

'''
'''--- multi-token-standard-impl/multi_token/src/core/resolver.rs ---
use crate::token::TokenId;
use near_sdk::json_types::U128;
use near_sdk::AccountId;

/// Used when MultiTokens are transferred using `mt_transfer_call`. This is the method that's called after `mt_on_transfer`. This trait is implemented on the MultiToken contract.
pub trait MultiTokenResolver {
    /// Finalize an `mt_transfer_call` chain of cross-contract calls.
    ///
    /// The `mt_transfer_call` process:
    ///
    /// 1. Sender calls `mt_transfer_call` on MultiToken contract
    /// 2. MultiToken contract transfers token from sender to receiver
    /// 3. MultiToken contract calls `mt_on_transfer` on receiver contract
    /// 4+. [receiver contract may make other cross-contract calls]
    /// N. MultiToken contract resolves promise chain with `mt_resolve_transfer`, and may
    ///    transfer token back to sender
    ///
    /// Requirements:
    /// * Contract MUST forbid calls to this function by any account except self
    /// * If promise chain failed, contract MUST revert token transfer
    /// * If promise chain resolves with `true`, contract MUST return token to
    ///   `sender_id`
    ///
    /// Arguments:
    /// * `previous_owner_id`: the owner prior to the call to `mt_transfer_call`
    /// * `receiver_id`: the `receiver_id` argument given to `mt_transfer_call`
    /// * `token_ids`: the `token_ids` argument given to `mt_transfer_call`
    /// * `approvals`: if using Approval Management, contract MUST provide
    ///   set of original approved accounts in this argument, and restore these
    ///   approved accounts in case of revert. In this case it may be multiple sets of approvals
    ///
    /// Returns true if tokens were successfully transferred to `receiver_id`.
    fn mt_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
    ) -> Vec<U128>;
}

'''
'''--- multi-token-standard-impl/multi_token/src/core/storage_impl.rs ---
use crate::storage_management::{StorageBalance, StorageBalanceBounds, StorageManagement};
use crate::MultiToken;
use crate::{TokenId, TokenType};
use near_sdk::json_types::U128;
use near_sdk::{assert_one_yocto, env, AccountId, Balance, Promise};

impl MultiToken {
  pub fn internal_storage_unregister(
    &mut self,
    token_id: TokenId,
    force: Option<bool>,
  ) -> Option<(AccountId, Balance)> {
    assert_one_yocto();
    let account_id = env::predecessor_account_id();
    let force = force.unwrap_or(false);
    let token_type = self
      .token_type_index
      .get(&token_id)
      .unwrap_or_else(|| env::panic_str(format!("Could not find token {}", token_id).as_str()));
    if token_type == TokenType::Nft {
      return None;
    }
    let balance =
      self.ft_owners_by_id.get(&token_id).unwrap().get(&account_id).unwrap_or_else(|| {
        env::panic_str(format!("Could not find token_id: {} owner for {}", token_id, account_id).as_str())
      });
    if balance == 0 || force {
      self.ft_owners_by_id.get(&token_id).unwrap().remove(&account_id);
      let updated_supply = self.ft_token_supply_by_id.get(&token_id).unwrap() - balance;
      self.ft_token_supply_by_id.insert(&token_id, &updated_supply);
      Promise::new(account_id.clone())
        .transfer(self.internal_storage_balance_bounds(&token_id, None).min.0 + 1);
      Some((account_id, balance))
    } else {
      env::panic_str("Can't unregister the account with the positive balance without force")
    }
  }

  /// Internal method that returns the Account ID and the balance in case the account was
  /// unregistered.
  /// TODO double check logic here and make more efficient
  pub fn internal_storage_unregister_batch(
    &mut self,
    token_ids: Vec<TokenId>,
    force: Option<bool>,
  ) -> Vec<Option<(AccountId, Balance)>> {
    assert_one_yocto();
    token_ids
      .iter()
      .map(|token_id| self.internal_storage_unregister(token_id.clone(), force))
      .collect()
  }

  fn internal_storage_balance_bounds(
    &self,
    token_id: &TokenId,
    account_id: Option<AccountId>,
  ) -> StorageBalanceBounds {
    let token_type = self
      .token_type_index
      .get(&token_id)
      .unwrap_or_else(|| env::panic_str(format!("Token id {} not found", token_id).as_str()));
    let no_storage_bound = StorageBalanceBounds { min: 0.into(), max: Some(0.into()) };

    if token_type == TokenType::Nft {
      return no_storage_bound;
    }

    if let Some(acct) = account_id {
      if self.ft_owners_by_id.get(&token_id).unwrap().get(&acct).is_some() {
        return no_storage_bound;
      }
    }
    let required_storage_balance =
      Balance::from(self.ft_account_storage_usage) * env::storage_byte_cost();
    StorageBalanceBounds {
      min: required_storage_balance.into(),
      max: Some(required_storage_balance.into()),
    }
  }

  pub fn internal_storage_balance_bounds_batch(
    &self,
    token_ids: &[TokenId],
    account_id: Option<AccountId>,
  ) -> StorageBalanceBounds {
    let mut min_storage: u128 = 0;
    let mut max_storage: u128 = 0;

    token_ids.iter().for_each(|token_id| {
      let bound = self.internal_storage_balance_bounds(token_id, account_id.clone());
      min_storage += u128::from(bound.min);
      max_storage += u128::from(bound.max.unwrap_or_else(|| 0.into()));
    });
    StorageBalanceBounds { min: min_storage.into(), max: Some(max_storage.into()) }
  }

  pub fn internal_storage_balance_of(
    &self,
    token_id: TokenId,
    account_id: &AccountId,
  ) -> Option<StorageBalance> {
    let token_type = self
      .token_type_index
      .get(&token_id)
      .unwrap_or_else(|| env::panic_str(format!("Could not find token_id {}", token_id).as_str()));
    if token_type == TokenType::Nft {
      return None;
    }
    let min_storage = self.internal_storage_balance_bounds(&token_id, None).min;
    if self.ft_owners_by_id.get(&token_id).unwrap().contains_key(account_id) {
      Some(StorageBalance { total: min_storage, available: 0.into() })
    } else {
      None
    }
  }

  pub fn internal_storage_balance_of_batch(
    &self,
    token_ids: &[TokenId],
    account_id: &AccountId,
  ) -> Option<StorageBalance> {
    let mut total: u128 = 0;
    token_ids.iter().for_each(|token_id| {
      if let Some(balance) = self.internal_storage_balance_of(token_id.clone(), account_id) {
        total += u128::from(balance.total);
      };
    });
    if total == 0 {
      return None;
    }
    Some(StorageBalance { total: total.into(), available: 0.into() })
  }
}

impl StorageManagement for MultiToken {
  // `registration_only` doesn't affect the implementation for vanilla fungible token.
  // TODO make more efficient
  #[allow(unused_variables)]
  fn storage_deposit(
    &mut self,
    token_ids: Vec<TokenId>,
    account_id: Option<AccountId>,
    registration_only: Option<bool>,
  ) -> StorageBalance {
    let amount: Balance = env::attached_deposit();
    let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
    let min_balance =
      self.internal_storage_balance_bounds_batch(&token_ids, Some(account_id.clone())).min.0;
    if amount < min_balance {
      env::panic_str("The attached deposit is less than the minimum storage balance");
    }
    token_ids.iter().for_each(|token_id| {
      self.internal_register_account(token_id.clone(), &account_id);
    });
    let refund = amount - min_balance;
    if refund > 0 {
      Promise::new(env::predecessor_account_id()).transfer(refund);
    }
    self.internal_storage_balance_of_batch(&token_ids, &account_id).unwrap()
  }

  /// While storage_withdraw normally allows the caller to retrieve `available` balance, the basic
  /// Fungible Token implementation sets storage_balance_bounds.min == storage_balance_bounds.max,
  /// which means available balance will always be 0. So this implementation:
  /// * panics if `amount > 0`
  /// * never transfers Ⓝ to caller
  /// * returns a `storage_balance` struct if `amount` is 0
  fn storage_withdraw(&mut self, token_ids: Vec<TokenId>, amount: Option<U128>) -> StorageBalance {
    assert_one_yocto();
    let predecessor_account_id = env::predecessor_account_id();
    if let Some(storage_balance) =
      self.internal_storage_balance_of_batch(&token_ids, &predecessor_account_id)
    {
      match amount {
        Some(amount) if amount.0 > 0 => {
          env::panic_str("The amount is greater than the available storage balance");
        }
        _ => storage_balance,
      }
    } else {
      env::panic_str(format!("The account {} is not registered", &predecessor_account_id).as_ref());
    }
  }

  fn storage_unregister(&mut self, token_ids: Vec<TokenId>, force: Option<bool>) -> Vec<bool> {
    token_ids
      .iter()
      .map(|token_id| self.internal_storage_unregister(token_id.clone(), force).is_some())
      .collect()
  }
  // Storage requirements for TokenIds associated with NFT times are waved
  // as the cost of storage is handled at minting
  // account_id is to ignore the cost of your account id if it exists
  fn storage_balance_bounds(
    &self,
    token_ids: Vec<TokenId>,
    account_id: Option<AccountId>,
  ) -> StorageBalanceBounds {
    let mut min_storage: u128 = 0;
    let mut max_storage: u128 = 0;

    token_ids.iter().for_each(|token_id| {
      let bound = self.internal_storage_balance_bounds(token_id, account_id.clone());
      min_storage += u128::from(bound.min);
      max_storage += u128::from(bound.max.unwrap_or_else(|| 0.into()));
    });
    StorageBalanceBounds { min: min_storage.into(), max: Some(max_storage.into()) }
  }

  fn storage_balance_of(
    &self,
    token_ids: Vec<TokenId>,
    account_id: AccountId,
  ) -> Option<StorageBalance> {
    self.internal_storage_balance_of_batch(&token_ids, &account_id)
  }
}

'''
'''--- multi-token-standard-impl/multi_token/src/lib.rs ---
/// The [core semifungible token standard](). This can be though of as the base standard, with the others being extension standards.
pub mod core;
/// Metadata traits and implementation according to the [NFT enumeration standard](https://nomicon.io/Standards/NonFungibleToken/Metadata.html).
/// This covers both the contract metadata and the individual token metadata.
pub mod metadata;
/// This covers the storage management for the tokens
pub mod storage_management;
/// The Token struct for the MultiToken token standard.
mod token;
// Utils for the contract
mod macros;
mod utils;

pub use self::core::MultiToken;
pub use self::token::{Token, TokenId, TokenType};
pub use macros::*;

'''
'''--- multi-token-standard-impl/multi_token/src/macros.rs ---
/// The core methods for a basic semi fungible token. Extension standards may be
/// added in addition to this macro.
///

#[macro_export]
macro_rules! impl_multi_token_core {
    ($contract: ident, $token: ident) => {
        use $crate::core::MultiTokenCore;
        use $crate::core::MultiTokenResolver;

        #[near_bindgen]
        impl MultiTokenCore for $contract {
            #[payable]
            fn mt_transfer(
                &mut self,
                receiver_id: AccountId,
                token_id: $crate::TokenId,
                amount: U128,
                memo: Option<String>,
            ) {
                self.$token.mt_transfer(receiver_id, token_id, amount, memo)
            }

            #[payable]
            fn mt_transfer_call(
                &mut self,
                receiver_id: AccountId,
                token_id: $crate::TokenId,
                amount: U128,
                memo: Option<String>,
                msg: String,
            ) -> PromiseOrValue<U128> {
                self.$token.mt_transfer_call(receiver_id, token_id, amount, memo, msg)
            }

            #[payable]
            fn mt_batch_transfer(
                &mut self,
                receiver_id: AccountId,
                token_id: Vec<$crate::TokenId>,
                amounts: Vec<U128>,
                memo: Option<String>,
            ) {
                self.$token.mt_batch_transfer(receiver_id, token_id, amounts, memo)
            }

            #[payable]
            fn mt_batch_transfer_call(
                &mut self,
                receiver_id: AccountId,
                token_ids: Vec<$crate::TokenId>,
                amounts: Vec<U128>,
                memo: Option<String>,
                msg: String,
            ) -> PromiseOrValue<Vec<U128>> {
                self.$token.mt_batch_transfer_call(receiver_id, token_ids, amounts, memo, msg)
            }

            fn balance_of(&self, owner_id: AccountId, token_id: $crate::TokenId) -> U128 {
                self.$token.balance_of(owner_id, token_id)
            }

            fn balance_of_batch(
                &self,
                owner_id: AccountId,
                token_ids: Vec<$crate::TokenId>,
            ) -> Vec<U128> {
                self.$token.balance_of_batch(owner_id, token_ids)
            }

            fn total_supply(&self, token_id: $crate::TokenId) -> U128 {
                self.$token.total_supply(token_id)
            }

            fn total_supply_batch(&self, token_ids: Vec<$crate::TokenId>) -> Vec<U128> {
                self.$token.total_supply_batch(token_ids)
            }
        }

        #[near_bindgen]
        impl MultiTokenResolver for $contract {
            #[private]
            fn mt_resolve_transfer(
                &mut self,
                sender_id: AccountId,
                receiver_id: AccountId,
                token_ids: Vec<$crate::TokenId>,
                amounts: Vec<U128>,
            ) -> Vec<U128> {
                self.$token.mt_resolve_transfer(sender_id, receiver_id, token_ids, amounts)
            }
        }
    };
}

#[macro_export]
macro_rules! impl_multi_token_metadata {
    ($contract: ident, $token: ident) => {
        use $crate::metadata::MultiTokenMetadataProvider;

        #[near_bindgen]
        impl MultiTokenMetadataProvider for $contract {
            fn mt_metadata(&self, token_id: String) -> $crate::metadata::MultiTokenMetadata {
                self.$token
                    .token_metadata_by_id
                    .as_ref()
                    .unwrap()
                    .get(&token_id)
                    .expect("Cannot find the metadata for the given token")
            }
        }
    };
}

/// Ensures that when mt token storage grows by collections adding entries,
/// the storage is be paid by the caller. This ensures that storage cannot grow to a point
/// that the MT contract runs out of Ⓝ.
/// Takes name of the Contract struct, the inner field for the token and optional method name to
/// call when the account was closed.
#[macro_export]
macro_rules! impl_multi_token_storage {
    ($contract: ident, $token: ident $(, $on_account_closed_fn:ident)?) => {
        use $crate::storage_management::{
            StorageManagement, StorageBalance, StorageBalanceBounds
        };

        #[near_bindgen]
        impl StorageManagement for $contract {
            #[payable]
            fn storage_deposit(
                &mut self,
                token_ids: Vec<$crate::TokenId>,
                account_id: Option<AccountId>,
                registration_only: Option<bool>,
            ) -> StorageBalance {
                self.$token.storage_deposit(token_ids, account_id, registration_only)
            }
            #[payable]
            fn storage_withdraw(&mut self, token_ids:Vec<$crate::TokenId>, amount: Option<U128>) -> StorageBalance {
                self.$token.storage_withdraw(token_ids, amount)
            }

            #[payable]
            fn storage_unregister(&mut self, token_ids: Vec<$crate::TokenId>, force: Option<bool>) -> Vec<bool> {
               #[allow(unused_variables)]
               let final_states = self.$token.internal_storage_unregister_batch(token_ids, force);
                final_states.iter().map(|final_state|{
                        if let Some((account_id,balance)) = final_state {
                            $(self.$on_account_closed_fn(account_id, balance);)?
                            true
                        }else {
                            false
                        }
                    }).collect()
            }

            fn storage_balance_bounds(&self, token_ids: Vec<$crate::TokenId>, account_id: Option<AccountId>) -> StorageBalanceBounds {
                self.$token.internal_storage_balance_bounds_batch(&token_ids, account_id)
            }

            fn storage_balance_of(&self, token_ids: Vec<$crate::TokenId>, account_id: AccountId) -> Option<StorageBalance> {
                self.$token.internal_storage_balance_of_batch(&token_ids, &account_id)
            }
        }
    };
}

'''
'''--- multi-token-standard-impl/multi_token/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use crate::token::TokenId;

/// This spec can be treated like a version of the standard.
pub const MT_METADATA_SPEC: &str = "mt-1.0.0";

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiTokenMetadata {
    pub spec: String,              // required, essentially a version like "mt-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub decimals: Option<u8>, // precision decimals for tokens that need this information
    // supports metadata_uri interface that interpolates {id} in the string
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
    pub expires_at: Option<String>, // ISO 8601 datetime when token expires
    pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
    pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
}

/// Offers details on the  metadata.
pub trait MultiTokenMetadataProvider {
    fn mt_metadata(&self, token_id: TokenId) -> MultiTokenMetadata;
}

'''
'''--- multi-token-standard-impl/multi_token/src/storage_management/mod.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;
use near_sdk::AccountId;
use crate::TokenId;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        token_ids: Vec<TokenId>,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, token_ids:Vec<TokenId>, amount: Option<U128>) -> StorageBalance;

    /// Unregisters the predecessor account and returns the storage NEAR deposit back.
    ///
    /// If the predecessor account is not registered, the function MUST return `false` without panic.
    ///
    /// If `force=true` the function SHOULD ignore account balances (burn them) and close the account.
    /// Otherwise, MUST panic if caller has a positive registered balance (eg token holdings) or
    ///     the contract doesn't support force unregistration.
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted function-call access-key call
    /// (UX wallet security)
    /// Returns `true` iff the account was unregistered.
    /// Returns `false` iff account was not registered before.
    fn storage_unregister(&mut self, token_ids:Vec<TokenId>, force: Option<bool>) -> Vec<bool>;

    fn storage_balance_bounds(&self, token_id:Vec<TokenId>, account_id: Option<AccountId>) -> StorageBalanceBounds;
    fn storage_balance_of(&self, token_ids:Vec<TokenId>, account_id: AccountId) -> Option<StorageBalance>;
}
'''
'''--- multi-token-standard-impl/multi_token/src/token.rs ---
use crate::metadata::MultiTokenMetadata;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::collections::HashMap;

/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum TokenType {
	Ft,
	Nft
}

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    pub token_id: TokenId,
    pub token_type: TokenType, 
    pub owner_id: AccountId,
    pub supply: u128,
    pub metadata: Option<MultiTokenMetadata>,
    pub approved_account_ids: Option<HashMap<AccountId, u64>>,
}
'''
'''--- multi-token-standard-impl/multi_token/src/utils.rs ---
use near_sdk::{env, Balance, Promise};
pub fn refund_deposit(storage_used: u64) {
	let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
	let attached_deposit = env::attached_deposit();
	assert!(
		required_cost <= attached_deposit,
		"Must attach {} yoctoNEAR to cover storage",
		required_cost,
	);
	let refund = attached_deposit - required_cost;
	if refund > 1 {
		Promise::new(env::predecessor_account_id()).transfer(refund);
	}
}

'''
'''--- multi-token-standard-impl/rustfmt.toml ---
use_small_heuristics = "Max"
# fn_args_density = "Compressed"
# overflow_delimited_expr = "true"
'''
'''--- multi-token-standard-impl/tests/sim/main.rs ---

'''
'''--- nft/Cargo.toml ---
[package]
name = "nft"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.2"
near-contract-standards = "4.0.0-pre.2"

'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

pub const DEFAULT_META: TokenMetadata = TokenMetadata {
    title: None,          // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    description: None,    // free-form description
    media: None, // URL to associated media, preferably to decentralized, content-addressed storage
    media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    copies: None, // number of copies of this set of metadata in existence when token was minted.
    issued_at: None, // ISO 8601 datetime when token was issued or minted
    expires_at: None, // ISO 8601 datetime when token expires
    starts_at: None, // ISO 8601 datetime when token starts being valid
    updated_at: None, // ISO 8601 datetime when token was last updated
    extra: None,  // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    reference: None, // URL to an off-chain JSON file with more info.
    reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
};

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> Token {
        self.tokens.internal_mint(
            token_id,
            receiver_id,
            Some(token_metadata.unwrap_or(DEFAULT_META)),
        )
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use std::collections::HashMap;

    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), Some(sample_token_metadata()));
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), Some(sample_token_metadata()));

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1));
            assert_eq!(token.metadata.unwrap(), (sample_token_metadata()));
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), Some(sample_token_metadata()));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), Some(sample_token_metadata()));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), Some(sample_token_metadata()));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- scripts/new-core-contract.sh ---
#!/bin/sh
# Meant to be called from the root of the repository

# TODO: add options for ownerId, treasury etc.
near dev-deploy res/contract.wasm --contractName dev-1644267069866-50957569549390 && mv neardev/dev-account neardev/CoreContract
near call $(cat neardev/CoreContract) new "{}" --accountId atilla-test.testnet || echo 'Already initialized'
'''
'''--- scripts/new-nft-conftract.sh ---
#!/bin/sh
# Meant to be called from the root of the repository

near dev-deploy res/nft.wasm --contractName --initArgs "{\"owner_id\": \"atilla-test.testnet\"}" --contractName dev-1644267709016-78788937283506
 && mv neardev/dev-account neardev/NFTContract
near call $(cat neardev/NFTContract) new_default_meta "{\"owner_id\": \"atilla-test.testnet\"}" --accountId atilla-test.testnet || true
'''
'''--- sim/main.rs ---
#[cfg(test)]
mod testing {
    pub mod utils;
    pub mod test_fractionalize;

    pub use crate::testing::utils::*;
}

fn main() {}

'''
'''--- sim/testing/test_fractionalize.rs ---
use std::convert::TryFrom;

use contract::sales::{SaleOptions, SaleOptionsSerial};
use contract::types::MTTokenId;
use contract::FEE_DENOMINATOR;
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::env;
use near_sdk::json_types::U128;
use near_sdk::serde::{self, Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view, DEFAULT_GAS};

use near_internal_balances_plugin::TokenId;

use crate::testing::utils::{init_with_macros as init, register_user};
use crate::testing::InitRet;

use super::{get_default_metadata, INIT_USER_BAL_NEAR};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceTmp {
    pub total: U128,
    pub available: U128,
}

pub const NFT_MINT_FEE: u128 = 1_000_000;
pub const SALE_FEE_NUMERATOR: u128 = 100_000_000u128;
const SUPPLY: u128 = 1_000_000_000_000_000;

fn init_with_fractionalize_nfts(
    sale_amount_whole: Option<U128>,
    sale_price_per_whole: Option<U128>,
    amount_frac_attach: Option<u128>,
) -> (InitRet, Vec<TokenId>, MTTokenId) {
    let nfts = vec!["nft_1".to_string(), "nft_2".to_string()];
    let InitRet { alice, root, nft, contract } =
        init(nfts.clone(), NFT_MINT_FEE, SALE_FEE_NUMERATOR);
    let mt_id = "MyNFTFRACED".to_string();

    // deposit the NFTs
    for nft_id in &nfts {
        call!(
            root,
            nft.nft_transfer_call(
                contract.account_id(),
                nft_id.clone(),
                None,
                None,
                "".to_string()
            ),
            deposit = 1
        )
        .assert_success();
    }

    let nfts_tok_ids: Vec<TokenId> = nfts
        .iter()
        .map(|nft_id| TokenId::NFT { contract_id: nft.account_id(), token_id: nft_id.clone() })
        .collect();

    for nft_tok in &nfts_tok_ids {
        let bal: U128 =
            view!(contract.internal_balance_get_balance(root.account_id(), nft_tok.clone()))
                .unwrap_json();
        assert_eq!(bal.0, 1);
    }

    // Fractionalize them
    call!(
        root,
        contract.nft_fractionalize(
            nfts_tok_ids.clone(),
            mt_id.clone(),
            U128::from(SUPPLY),
            None,
            get_default_metadata(),
            sale_amount_whole,
            sale_price_per_whole
        ),
        deposit =
            amount_frac_attach.unwrap_or(NFT_MINT_FEE + near_sdk::env::storage_byte_cost() * 1_000)
    )
    .assert_success();
    let bal_post_frac: U128 =
        view!(contract.balance_of(root.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_post_frac.0, SUPPLY - sale_amount_whole.map(|a| a.0).unwrap_or(0));

    for nft_tok in &nfts_tok_ids {
        let bal: U128 =
            view!(contract.internal_balance_get_balance(root.account_id(), nft_tok.clone()))
                .unwrap_json();
        assert_eq!(bal.0, 0);
    }
    (InitRet { alice, root, nft, contract }, nfts_tok_ids, mt_id)
}

#[test]
fn simulate_simple_fractionalization() {
    let (InitRet { alice, root, nft, contract }, nfts_tok_ids, mt_id) =
        init_with_fractionalize_nfts(None, None, None);
    call!(root, contract.nft_fractionalize_unwrap(mt_id.clone(), None), deposit = 1)
        .assert_success();
    for nft_tok in &nfts_tok_ids {
        let bal: U128 =
            view!(contract.internal_balance_get_balance(root.account_id(), nft_tok.clone()))
                .unwrap_json();
        assert_eq!(bal.0, 1);
    }
    let bal_post_unwrap: U128 =
        view!(contract.balance_of(root.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_post_unwrap.0, 0);
}

#[test]
fn simulate_nft_frac_sale() {
    let sale_amount_whole = 100;
    let whole_to_buy = 10;
    let sale_price_whole = 100;
    let (InitRet { alice, root, nft, contract }, nfts_tok_ids, mt_id) =
        init_with_fractionalize_nfts(
            Some(sale_amount_whole.into()),
            Some(sale_price_whole.into()),
            None,
        );
    let treasury = alice.account_id();

    let bal_init_sale: U128 =
        view!(contract.balance_of(root.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_init_sale.0, SUPPLY - sale_amount_whole);

    // Check that the initial balances are correct
    let bal_init_contract: U128 =
        view!(contract.balance_of(contract.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_init_sale.0, SUPPLY - sale_amount_whole);
    assert_eq!(bal_init_contract.0, sale_amount_whole);

    // Check the initial sale
    let mut desired_opts = SaleOptions {
        amount_to_sell: sale_amount_whole,
        near_price_per_token: sale_price_whole,
        sold: 0,
        owner: root.account_id(),
    };
    let sale_info_serial: SaleOptionsSerial =
        view!(contract.sale_info(mt_id.clone())).unwrap_json();
    let sale_info = SaleOptions {
        amount_to_sell: sale_info_serial.amount_to_sell.0,
        near_price_per_token: sale_info_serial.near_price_per_token.0,
        sold: sale_info_serial.sold.0,
        owner: sale_info_serial.owner.clone(),
    };

    assert_eq!(&desired_opts, &sale_info);

    let seller_bal_pre_sale: StorageBalance =
        view!(contract.accounts_near_balance_of(root.account_id())).unwrap_json();

    // Make a sale
    call!(
        alice,
        contract.storage_deposit(vec![mt_id.clone()], None, None),
        deposit = near_sdk::env::storage_byte_cost() * 2_000
    )
    .assert_success();

    let treasury_bal_pre_sale: StorageBalance =
        view!(contract.accounts_near_balance_of(treasury.clone())).unwrap_json();

    call!(
        alice,
        contract.sale_buy(mt_id.clone(), U128::from(whole_to_buy)),
        deposit = sale_price_whole * whole_to_buy
    )
    .assert_success();

    let sale_info_serial: SaleOptionsSerial =
        view!(contract.sale_info(mt_id.clone())).unwrap_json();

    let sale_info = SaleOptions {
        amount_to_sell: sale_info_serial.amount_to_sell.0,
        near_price_per_token: sale_info_serial.near_price_per_token.0,
        sold: sale_info_serial.sold.0,
        owner: sale_info_serial.owner.clone(),
    };

    desired_opts.sold += whole_to_buy;
    assert_eq!(desired_opts, sale_info);

    let bal_post_sale_contract: U128 =
        view!(contract.balance_of(contract.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_post_sale_contract.0, (sale_amount_whole - whole_to_buy));

    let bal_post_sale_alice: U128 =
        view!(contract.balance_of(alice.account_id(), mt_id.clone())).unwrap_json();
    assert_eq!(bal_post_sale_alice.0, whole_to_buy);

    // Check the near account balances
    // contract.

    let expected_treasury_increase =
        sale_price_whole * whole_to_buy * SALE_FEE_NUMERATOR / FEE_DENOMINATOR;
    let expected_seller_increase = sale_price_whole * whole_to_buy - expected_treasury_increase;

    let treasury_bal: StorageBalance =
        view!(contract.accounts_near_balance_of(treasury)).unwrap_json();

    let seller_bal: StorageBalance =
        view!(contract.accounts_near_balance_of(root.account_id())).unwrap_json();

    assert_eq!(
        treasury_bal.available.0 - treasury_bal_pre_sale.available.0,
        expected_treasury_increase
    );
    assert_eq!(seller_bal.available.0 - seller_bal_pre_sale.available.0, expected_seller_increase);
}

#[test]
#[should_panic(
    expected = "Must attach 9090000000000001000000 yoctoNEAR to cover storage and/or fees"
)]
fn simulate_fractionalize_not_enough_attached() {
    let sale_amount_whole = 100;
    let whole_to_buy = 10;
    let sale_price_whole = 100;
    let (InitRet { alice, root, nft, contract }, nfts_tok_ids, mt_id) =
        init_with_fractionalize_nfts(
            Some(sale_amount_whole.into()),
            Some(sale_price_whole.into()),
            Some(0),
        );
    let treasury = alice.account_id();
}

#[test]
fn simulate_fractionalize_too_much_attached_and_returns() {
    let sale_amount_whole = 100;
    let whole_to_buy = 10;
    let sale_price_whole = 100;
    let amount_attached = to_yocto("2");
    let (InitRet { alice, root, nft, contract }, nfts_tok_ids, mt_id) =
        init_with_fractionalize_nfts(
            Some(sale_amount_whole.into()),
            Some(sale_price_whole.into()),
            Some(amount_attached),
        );
    let alice_init_bal = to_yocto(INIT_USER_BAL_NEAR);
    let near_bal = alice.account().unwrap().amount;
    assert!(alice_init_bal - near_bal < to_yocto("2"))
}

'''
'''--- sim/testing/utils.rs ---
use std::str::FromStr;

use contract::ContractContract;
use multi_token_standard::metadata::MultiTokenMetadata;
use near_sdk::serde_json::json;
use near_sdk::{json_types::U128, AccountId};
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS,
    STORAGE_AMOUNT,
};
use nft::{ContractContract as NFTContract, DEFAULT_META};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_BYTES => "res/contract.wasm",
    NFT_BYTES => "res/nft.wasm",
}

pub struct InitRet {
    pub alice: UserAccount,
    pub root: UserAccount,
    pub contract: ContractAccount<ContractContract>,
    pub nft: ContractAccount<NFTContract>,
}

pub const CONTRACT_ID: &str = "dummy";
pub const NFT_ID: &str = "nft";

pub const INIT_USER_BAL_NEAR: &str = "100";

pub fn get_default_metadata() -> MultiTokenMetadata {
    multi_token_standard::metadata::MultiTokenMetadata {
        spec: "aa".to_string(),   // required, essentially a version like "mt-1.0.0"
        name: "aa".to_string(),   // required, ex. "Mosaics"
        symbol: "aa".to_string(), // required, ex. "MOSIAC"
        icon: None,               // Data URL
        base_uri: None, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
        decimals: Some(12), // precision decimals for tokens that need this information
        reference: None, // URL to a JSON file with more info
        reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        title: None,          // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
        description: None,    // free-form description
        media: None, // URL to associated media, preferably to decentralized, content-addressed storage
        media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
        copies: None, // number of copies of this set of metadata in existence when token was minted.
        issued_at: None, // ISO 8601 datetime when token was issued or minted
        expires_at: None, // ISO 8601 datetime when token expires
        starts_at: None, // ISO 8601 datetime when token starts being valid
        updated_at: None, // ISO 8601 datetime when token was last updated
        extra: None,  // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    }
}

// Register the given `user` with NFT contract and the contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        AccountId::from_str(CONTRACT_ID).unwrap(),
        "accounts_storage_deposit",
        &json!({
            "registration_only": false,
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 2_000,
    );
}

pub fn init_with_macros(nfts_to_mint: Vec<String>, nft_mint_fee: u128, sale_fee: u128) -> InitRet {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let contract = deploy!(
        // Contract Proxy
        contract: ContractContract,
        // Contract account id
        contract_id: CONTRACT_ID,
        // Bytes of contract
        bytes: &CONTRACT_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new(Some(root.account_id()), Some(AccountId::from_str("alice").unwrap()), Some(U128::from(nft_mint_fee)), Some(U128::from(sale_fee)))
    );

    let nft = deploy!(
        // Contract Proxy
        contract: NFTContract,
        // Contract account id
        contract_id: NFT_ID,
        // Bytes of contract
        bytes: &NFT_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(root.account_id())
    );

    let alice = root.create_user(AccountId::from_str("alice").unwrap(), to_yocto("100"));

    for nft_id in nfts_to_mint {
        call!(
            root,
            nft.nft_mint(nft_id, root.account_id(), Some(DEFAULT_META)),
            deposit = near_sdk::env::storage_byte_cost() * 1_000
        )
        .assert_success();
    }

    register_user(&root);
    register_user(&alice);

    InitRet { root, alice, contract, nft }
}

'''
'''--- specs/tech.md ---
<!-- TODO: move this to just be part of the rust code w/ doc generation -->

## A quick tech spec

### The main data to store and contract

```rust
type MtTokenId = String;

struct AccountInfo {
	internal_balances: Map<TokenId, Balance>
}

struct NftFractionalizer {
	// Expects token id to be an NFT of type NFT or MT
	mt_token: Map<TokenId, MtTokenId>
	// hmmmmm.... we have to think about this/ explore the current offerings...
	fee: u64
}

struct Contract {
	accounts: NearAccounts<AccountInfo>,
}
```

### Public Write Functions

#### NFT fractionalization

```rust
fn nft_fractionalize(nfts: Vec<TokenId>, mt_id: TokenId, amount: U128, mt_owner: Option<AccountId>, token_metadata: MultiTokenMetadata);

fn nft_defractionalize(mt_id: TokenId, release_nft_to: Option<AccountId>);
```

<!-- ALLOW FEE TO BE UPDATED -->

### Public View Functions

### File Structure

'''
'''--- workflows/test.yml ---
name: CI
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable-2020-10-08
          target: wasm32-unknown-unknown

      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown

      - name: Check that build works
        run: ./build.sh
        # TODO: check that files in `res` are unchanged

      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test

'''