*GitHub Repository "0xhipo/0xhipo-cell-sdk-release"*

'''--- example/Bot/near/CellConfig/load.example.ts ---
import { NearCellConfig } from '../../../../src';
import { nearContractId } from '../../../constant.example';

async function loadExample() {
    const cellConfig = await NearCellConfig.load(nearContractId);
    console.log(cellConfig);
}
loadExample();

'''
'''--- example/Bot/near/CellConfig/set.example.ts ---
import { NearCellConfig, nearSendTransactionPayload, NearSetCellConfigParams } from '../../../../src';
import Decimal from 'decimal.js';
import { nearAccountId, nearAccountPrivateKey, nearContractId } from '../../../constant.example';

async function setExample() {
    const params: NearSetCellConfigParams = {
        delegateAccountId: 'cellfi-dev-delegate.near',
        createBotLine: new Decimal(5000),
        stopBotLine: new Decimal(3000),
        perpFeeRatio: new Decimal(10),
        botOwnerMostPerpFeeRatio: new Decimal(30),
        contractId: nearContractId,
    };
    const payload = NearCellConfig.set(params);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
setExample();

'''
'''--- example/Bot/near/Whitelist/add.example.ts ---
import { nearSendTransactionPayload, NearWhitelist } from '../../../../src';
import { nearAccountId, nearAccountPrivateKey, nearContractId } from '../../../constant.example';

async function addExample() {
    const whitelist = ['cellfi01.near'];
    const payload = NearWhitelist.add(whitelist, nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
addExample();

'''
'''--- example/Bot/near/Whitelist/load.example.ts ---
import { NearWhitelist } from '../../../../src';
import { nearContractId } from '../../../constant.example';

async function loadExample() {
    const whitelist = await NearWhitelist.load(nearContractId);
    console.log(whitelist);
}
loadExample();

'''
'''--- example/Bot/near/Whitelist/remove.example.ts ---
import { nearSendTransactionPayload, NearWhitelist } from '../../../../src';
import { nearAccountId, nearAccountPrivateKey, nearContractId } from '../../../constant.example';

async function removeExample() {
    const whitelist = ['cellfi01.near'];
    const payload = NearWhitelist.remove(whitelist, nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
removeExample();

'''
'''--- example/Bot/near/addReferer.example.ts ---
import { NearBot, nearSendTransactionPayload } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearContractId } from '../../constant.example';
import Decimal from 'decimal.js';

async function setDelegateExample() {
    const payload = await NearBot.addReferer('hipodev.near', new Decimal(0.1), nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
setDelegateExample();

'''
'''--- example/Bot/near/cancelAllOrders.example.ts ---
import { NearBot, nearSendTransactionPayload, CancelAllNearOrdersParams } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';

async function cancelOrderExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId);
    const params: CancelAllNearOrdersParams = {
        protocol: bot.protocol,
        market: bot.market,
        botIndex: nearBotIndex,
        contractId: nearContractId,
    };
    const payload = await NearBot.cancelAllOrders(params);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
cancelOrderExample();

'''
'''--- example/Bot/near/cancelOrder.example.ts ---
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';
import { CancelNearOrderParams, NearBot, NearNetworkId, nearSendTransactionPayload, OrderSide } from '../../../src';
import Decimal from 'decimal.js';

async function cancelOrderExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId, NearNetworkId.mainnet);
    const params: CancelNearOrderParams = {
        protocol: bot.protocol,
        market: bot.market,
        orderId: '378564',
        botIndex: nearBotIndex,
        contractId: nearContractId,
        // Ref Only params
        // amount: new Decimal(1),
        // side: OrderSide.Bid,
    };
    const payload = await NearBot.cancelOrder(params);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey, NearNetworkId.mainnet);
}
cancelOrderExample();

'''
'''--- example/Bot/near/close.example.ts ---
import { CloseNearBotParms, NearBot, NearNetworkId, nearSendTransactionPayload } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';

async function closeExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId);
    const params: CloseNearBotParms = {
        protocol: bot.protocol,
        market: bot.market,
        botIndex: nearBotIndex,
        userAccountId: nearAccountId,
        contractId: nearContractId,
        networkId: NearNetworkId.mainnet,
    };
    const payloads = await NearBot.close(params);
    for (const payload of payloads) {
        await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
    }
}
closeExample();

'''
'''--- example/Bot/near/closeMarket.example.ts ---
import { CloseNearMarketParams, NearBot, NearNetworkId, nearSendTransactionPayload } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';

async function closeMarketExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId);
    const params: CloseNearMarketParams = {
        protocol: bot.protocol,
        market: bot.market,
        botIndex: nearBotIndex,
        contractId: nearContractId,
        networkId: NearNetworkId.mainnet,
    };
    const payload = await NearBot.closeMarket(params);
    if (payload) {
        await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
    }
}
closeMarketExample();

'''
'''--- example/Bot/near/create.example.ts ---
import {
    BotType,
    CreateNearBotParams,
    NearBot,
    NearNetworkId,
    nearSendTransactionPayload,
    Protocol,
} from '../../../src';
import Decimal from 'decimal.js';
import { nearAccountId, nearAccountPrivateKey, nearContractId } from '../../constant.example';

async function createExample() {
    const params: CreateNearBotParams = {
        protocol: Protocol.Tonic,
        baseTokenBalance: new Decimal(0),
        quoteTokenBalance: new Decimal(1),
        lowerPrice: new Decimal(2),
        upperPrice: new Decimal(3.5),
        gridNumber: new Decimal(10),
        leverage: new Decimal(1),
        market: '7Ub1tFH9hUTcS3F4PbU7PPVmXx4u11nQnBPCF3tqJgkV',
        botType: BotType.Long,
        startPrice: new Decimal(2.3),
        referer: nearAccountId,
        contractId: nearContractId,
        networkId: NearNetworkId.mainnet,
    };
    const [botIndex, payloads] = await NearBot.create(params);

    for (const payload of payloads) {
        await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey, NearNetworkId.mainnet);
    }
}
createExample();

'''
'''--- example/Bot/near/getBotInfo.example.ts ---
import { GetNearBotInfoParams, NearBot, NearNetworkId } from '../../../src';
import { nearBotIndex, nearContractId } from '../../constant.example';

async function getBotInfoExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId, NearNetworkId.testnet);

    const params: GetNearBotInfoParams = {
        protocol: bot.protocol,
        market: bot.market,
        botIndex: nearBotIndex,
        contractId: nearContractId,
        networkId: NearNetworkId.testnet,
    };
    const botInfo = await NearBot.getBotInfo(params);
    console.log(botInfo);
}
getBotInfoExample();

'''
'''--- example/Bot/near/getOpenOrders.example.ts ---
import { GetNearOpenOrdersParams, NearBot, NearNetworkId } from '../../../src';
import { nearBotIndex, nearContractId } from '../../constant.example';

async function getOpenOrdersExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId, NearNetworkId.testnet);
    const params: GetNearOpenOrdersParams = {
        protocol: bot.protocol,
        market: bot.market,
        botIndex: nearBotIndex,
        contractId: nearContractId,
        networkId: NearNetworkId.testnet,
    };
    const openOrders = await NearBot.getOpenOrders(params);
    console.log(openOrders);
}
getOpenOrdersExample();

'''
'''--- example/Bot/near/getRefererDiscount.example.ts ---
import { NearBot } from '../../../src';
import { nearContractId } from '../../constant.example';

async function setDelegateExample() {
    const discount = await NearBot.getRefererDiscount('hipodev.near', nearContractId);
    console.log(discount);
}
setDelegateExample();

'''
'''--- example/Bot/near/load.example.ts ---
import { NearBot, NearNetworkId } from '../../../src';
import { nearBotIndex, nearContractId } from '../../constant.example';

async function loadExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId, NearNetworkId.testnet);
    console.log(bot);
}
loadExample();

'''
'''--- example/Bot/near/loadAll.example.ts ---
import { NearBot, NearNetworkId } from '../../../src';
import { nearContractId } from '../../constant.example';

async function loadAllExample() {
    const bots = await NearBot.loadAll(nearContractId, NearNetworkId.testnet);
    console.log(bots);
}
loadAllExample();

'''
'''--- example/Bot/near/placeOrder.example.ts ---
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';
import {
    NearBot,
    NearNetworkId,
    nearSendTransactionPayload,
    OrderSide,
    OrderType,
    PlaceNearOrderParams,
} from '../../../src';
import Decimal from 'decimal.js';

async function placeOrderExample() {
    const bot = await NearBot.load(nearBotIndex, nearContractId, NearNetworkId.testnet);
    const params: PlaceNearOrderParams = {
        protocol: bot.protocol,
        market: bot.market,
        price: new Decimal(0.01),
        size: new Decimal(100),
        side: OrderSide.Bid,
        orderType: OrderType.Limit,
        clientId: '1',
        botIndex: nearBotIndex,
        contractId: nearContractId,
    };
    const payload = await NearBot.placeOrder(params);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey, NearNetworkId.testnet);
}
placeOrderExample();

'''
'''--- example/Bot/near/setDelegate.example.ts ---
import { NearBot, nearSendTransactionPayload, NearSetDelegateParams } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';

async function setDelegateExample() {
    const params: NearSetDelegateParams = {
        delegateAccountId: 'hipodev.near',
        botIndex: nearBotIndex,
        contractId: nearContractId,
    };
    const payload = await NearBot.setDelegate(params);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
setDelegateExample();

'''
'''--- example/Bot/near/setReferer.example.ts ---
import { NearBot, nearSendTransactionPayload } from '../../../src';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';

async function setDelegateExample() {
    const payload = await NearBot.setReferer('hipodev.near', nearBotIndex, nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
setDelegateExample();

'''
'''--- example/Bot/near/start.example.ts ---
import { NearBot } from '../../../src/Bot/near';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';
import { nearSendTransactionPayload } from '../../../src/util';

async function startExample() {
    const payload = await NearBot.start(nearBotIndex, nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
startExample();

'''
'''--- example/Bot/near/stop.example.ts ---
import { NearBot } from '../../../src/Bot/near';
import { nearAccountId, nearAccountPrivateKey, nearBotIndex, nearContractId } from '../../constant.example';
import { nearSendTransactionPayload } from '../../../src/util';

async function stopExample() {
    const payload = await NearBot.stop(nearBotIndex, nearContractId);
    await nearSendTransactionPayload(payload, nearAccountId, nearAccountPrivateKey);
}
stopExample();

'''
'''--- example/Bot/solana/CellConfig/create.example.ts ---
import { sendSolanaPayload, SolanaCellConfig } from '../../../../src';
import { solanaConnection, solanaEnv, solanaWallet } from '../../../constant.example';

async function createExample() {
    const payload = await SolanaCellConfig.create(solanaWallet.publicKey, solanaWallet.publicKey, solanaEnv.programId);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
createExample();

'''
'''--- example/Bot/solana/CellConfig/load.example.ts ---
import { SolanaCellConfig } from '../../../../src';
import { solanaConnection, solanaEnv } from '../../../constant.example';

async function loadExample() {
    const cellConfig = await SolanaCellConfig.load(solanaConnection, solanaEnv.programId);
    console.log(cellConfig);
    console.log(`admin: ${cellConfig.admin.toString()}`);
    console.log(`delegate: ${cellConfig.delegate.toString()}`);
}
loadExample();

'''
'''--- example/Bot/solana/CellConfig/setConfig.example.ts ---
import { sendSolanaPayload, SolanaCellConfig } from '../../../../src';
import { PublicKey } from '@solana/web3.js';
import { solanaConnection, solanaEnv, solanaWallet } from '../../../constant.example';

async function setConfigExample() {
    const delegate = new PublicKey('BefBuFi7LCjEzFDAxWd3DqxtDYmaeJZDV6cqtoGx5EZB');
    const payload = await SolanaCellConfig.setConfig(
        solanaWallet.publicKey,
        delegate,
        1,
        1,
        600,
        0.2,
        0.1,
        0.3,
        0.1,
        0.1,
        solanaEnv.programId,
    );
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
setConfigExample();

'''
'''--- example/Bot/solana/cancelOrder.example.ts ---
import { SolanaBot, CancelOrderParams, OrderSide } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';
import { sendSolanaPayload } from '../../../src';

async function cancelOrderExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: CancelOrderParams = {
        protocol: bot.protocol,
        botSeed: solanaBotSeed,
        side: OrderSide.Ask,
        orderId: '368934881474191032579582',
        marketKey: bot.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaBot.cancelOrder(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
cancelOrderExample();

'''
'''--- example/Bot/solana/close.example.ts ---
import { SolanaBot, CloseBotParams, sendSolanaPayload } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function closeExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: CloseBotParams = {
        protocol: bot.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        owner: bot.owner,
        referrer: bot.referrer,
        cellAdmin: solanaEnv.adminAccount,
        programId: solanaEnv.programId,
    };
    const payloads = await SolanaBot.close(params);

    for (const payload of payloads) {
        if (payload) {
            await sendSolanaPayload(solanaConnection, solanaWallet, payload, true);
        }
    }
}
closeExample();

'''
'''--- example/Bot/solana/closeMarket.example.ts ---
import { CloseSolanaBotMarketParams, sendSolanaPayload, SolanaBot } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function closeMarketExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: CloseSolanaBotMarketParams = {
        protocol: bot.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        payer: bot.owner,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaBot.closeMarket(params);
    if (payload) {
        await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
    }
}
closeMarketExample();

'''
'''--- example/Bot/solana/create.example.ts ---
import { SolanaBot, BotType, CreateBotParams, Protocol, sendSolanaPayload } from '../../../src';
import base58 from 'bs58';
import { PublicKey } from '@solana/web3.js';
import Decimal from 'decimal.js';
import { solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function createExample() {
    const createBotParams: CreateBotParams = {
        botOwner: solanaWallet.publicKey,
        depositBaseBalance: new Decimal(0),
        depositQuoteBalance: new Decimal(10),
        lowerPrice: new Decimal(1.5),
        upperPrice: new Decimal(2.5),
        gridNum: new Decimal(10),
        leverage: new Decimal(1.5),
        marketKey: new PublicKey('8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6'),
        protocol: Protocol.Serum,
        botType: BotType.Neutral,
        startPrice: new Decimal(2.4),
        programId: solanaEnv.programId,
        stopTopRatio: new Decimal(0),
        stopBottomRatio: new Decimal(0),
        trigger: false,
    };

    const [botSeed, dexAccountKey, orderOwnerKey, payload] = await SolanaBot.create(createBotParams);

    console.log(`Bot seed: ${base58.encode(botSeed)}`);
    console.log(`Dex account key: ${dexAccountKey.toString()}`);
    console.log(`Order owner key: ${orderOwnerKey.toString()}`);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}

createExample();

'''
'''--- example/Bot/solana/getBotInfo.example.ts ---
import { SolanaBot, GetBotInfoParams } from '../../../src';
import {solanaBotSeed, solanaConnection, solanaEnv} from '../../constant.example';

async function getBotInfoExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: GetBotInfoParams = {
        protocol: bot.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        programId: solanaEnv.programId,
    };
    const botInfo = await SolanaBot.getBotInfo(params);
    console.log(botInfo);
}
getBotInfoExample();

'''
'''--- example/Bot/solana/getOpenOrders.example.ts ---
import { SolanaBot, GetOpenOrdersParams } from '../../../src';
import {solanaBotSeed, solanaConnection, solanaEnv} from '../../constant.example';

async function getOpenOrdersExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: GetOpenOrdersParams = {
        protocol: bot.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        programId: solanaEnv.programId,
    };
    const openOrders = await SolanaBot.getOpenOrders(params);
    console.log(openOrders);
}
getOpenOrdersExample();

'''
'''--- example/Bot/solana/load.example.ts ---
import { SolanaBot } from '../../../src';
import {solanaBotSeed, solanaConnection, solanaEnv} from '../../constant.example';

async function loadExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    console.log(bot);
    console.log(`Market: ${bot.market.toString()}`);
}
loadExample();

'''
'''--- example/Bot/solana/loadAll.example.ts ---
import { SolanaBot } from '../../../src';
import { solanaConnection, solanaEnv } from '../../constant.example';

async function loadAllExample() {
    const bots = await SolanaBot.loadAll(solanaConnection, solanaEnv.programId);
    console.log(bots);
    console.log(`Bot number: ${bots.length}`);
}
loadAllExample();

'''
'''--- example/Bot/solana/placeOrder.example.ts ---
import { SolanaBot, OrderSide, OrderType, PlaceOrderParams, sendSolanaPayload } from '../../../src';
import Decimal from 'decimal.js';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function placeOrderExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: PlaceOrderParams = {
        price: new Decimal(20),
        quantity: new Decimal(0.01),
        side: OrderSide.Bid,
        orderType: OrderType.Limit,
        protocol: bot.protocol,
        clientId: '1',
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaBot.placeOrder(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
placeOrderExample();

'''
'''--- example/Bot/solana/start.example.ts ---
import { sendSolanaPayload, SolanaBot, StartBotParams } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function startExample() {
    const params: StartBotParams = {
        botSeed: solanaBotSeed,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaBot.start(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
startExample();

'''
'''--- example/Pool/solana/adjustReserve.example.ts ---
import { SolanaPool, AdjustPoolReserveParams, sendSolanaPayload } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function adjustReserveExample() {
    const pool = await SolanaPool.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: AdjustPoolReserveParams = {
        protocol: pool.protocol,
        botSeed: solanaBotSeed,
        marketKey: pool.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.adjustReserve(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
adjustReserveExample();

'''
'''--- example/Pool/solana/cancelOrder.example.ts ---
import { SolanaBot, CancelOrderParams, OrderSide, SolanaPool } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';
import { sendSolanaPayload } from '../../../src';

async function cancelOrderExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: CancelOrderParams = {
        protocol: bot.protocol,
        botSeed: solanaBotSeed,
        side: OrderSide.Bid,
        orderId: '186754837002235499595995',
        marketKey: bot.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.cancelOrder(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
cancelOrderExample();

'''
'''--- example/Pool/solana/create.example.ts ---
import { BotType, CreateBotParams, Protocol, sendSolanaPayload, SolanaPool } from '../../../src';
import base58 from 'bs58';
import { PublicKey } from '@solana/web3.js';
import Decimal from 'decimal.js';
import { solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function createExample() {
    const createBotParams: CreateBotParams = {
        botOwner: solanaWallet.publicKey,
        depositBaseBalance: new Decimal(0),
        depositQuoteBalance: new Decimal(1),
        lowerPrice: new Decimal(1.5),
        upperPrice: new Decimal(2.5),
        gridNum: new Decimal(10),
        leverage: new Decimal(1.5),
        marketKey: new PublicKey('FZxi3yWkE5mMjyaZj6utmYL54QQYfMCKMcLaQZq4UwnA'),
        protocol: Protocol.Serum,
        botType: BotType.Neutral,
        startPrice: new Decimal(2.4),
        programId: solanaEnv.programId,
        stopTopRatio: new Decimal(0),
        stopBottomRatio: new Decimal(0),
        trigger: false,
    };

    const [botSeed, dexAccountKey, orderOwnerKey, payload] = await SolanaPool.create(createBotParams);

    console.log(`Bot seed: ${base58.encode(botSeed)}`);
    console.log(`Dex account key: ${dexAccountKey.toString()}`);
    console.log(`Order owner key: ${orderOwnerKey.toString()}`);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}

createExample();

'''
'''--- example/Pool/solana/deposit.example.ts ---
import { SolanaPool, DepositPoolParams, sendSolanaPayload } from '../../../src';
import Decimal from 'decimal.js';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function depositExample() {
    const pool = await SolanaPool.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: DepositPoolParams = {
        protocol: pool.protocol,
        connection: solanaConnection,
        amount: new Decimal(0.1),
        botSeed: solanaBotSeed,
        marketKey: pool.market,
        investor: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.deposit(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
depositExample();

'''
'''--- example/Pool/solana/getOpenOrders.example.ts ---
import {SolanaBot, GetOpenOrdersParams, SolanaPool} from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv } from '../../constant.example';

async function getOpenOrdersExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: GetOpenOrdersParams = {
        protocol: bot.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        programId: solanaEnv.programId,
    };
    const openOrders = await SolanaPool.getOpenOrders(params);
    console.log(openOrders);
}
getOpenOrdersExample();

'''
'''--- example/Pool/solana/getPoolInfo.example.ts ---
import { SolanaPool, GetPoolInfoParams } from '../../../src';
import {solanaBotSeed, solanaConnection, solanaEnv} from '../../constant.example';

async function getPoolInfoExample() {
    const pool = await SolanaPool.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: GetPoolInfoParams = {
        protocol: pool.protocol,
        connection: solanaConnection,
        botSeed: solanaBotSeed,
        marketKey: pool.market,
        programId: solanaEnv.programId,
    };
    const poolInfo = await SolanaPool.getPoolInfo(params);
    console.log(poolInfo);
}
getPoolInfoExample();

'''
'''--- example/Pool/solana/modifyOrder.example.ts ---
import { SolanaPool, ModifyPoolOrderParams, OrderSide, OrderType, sendSolanaPayload } from '../../../src';
import Decimal from 'decimal.js';
import {solanaBotSeed, solanaConnection, solanaEnv, solanaWallet} from '../../constant.example';

async function modifyOrderExample() {
    const pool = await SolanaPool.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: ModifyPoolOrderParams = {
        protocol: pool.protocol,
        existedOrderId: '18446762520453625319632387',
        existedOrderSide: OrderSide.Bid,
        newOrderPrice: new Decimal(1.2),
        newOrderSize: new Decimal(0.02),
        newOrderSide: OrderSide.Bid,
        newOrderType: OrderType.Limit,
        newOrderClientId: '1',
        botSeed: solanaBotSeed,
        marketKey: pool.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.modifyOrder(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
modifyOrderExample();

'''
'''--- example/Pool/solana/placeOrder.example.ts ---
import { SolanaBot, OrderSide, OrderType, PlaceOrderParams, sendSolanaPayload, SolanaPool } from '../../../src';
import Decimal from 'decimal.js';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function placeOrderExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: PlaceOrderParams = {
        price: new Decimal(10.123),
        quantity: new Decimal(0.01),
        side: OrderSide.Bid,
        orderType: OrderType.Limit,
        protocol: bot.protocol,
        clientId: '1',
        botSeed: solanaBotSeed,
        marketKey: bot.market,
        payer: solanaWallet.publicKey,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.placeOrder(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
placeOrderExample();

'''
'''--- example/Pool/solana/redeem.example.ts ---
import { SolanaPool, RedeemPoolParams, sendSolanaPayload } from '../../../src';
import Decimal from 'decimal.js';
import { solanaBotSeed, solanaConnection, solanaEnv, solanaWallet } from '../../constant.example';

async function redeemExample() {
    const pool = await SolanaPool.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const params: RedeemPoolParams = {
        protocol: pool.protocol,
        amount: new Decimal(0.1),
        botSeed: solanaBotSeed,
        marketKey: pool.market,
        investor: solanaWallet.publicKey,
        botOwner: pool.owner,
        cellAdmin: solanaEnv.adminAccount,
        programId: solanaEnv.programId,
    };
    const payload = await SolanaPool.redeem(params);
    await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
}
redeemExample();

'''
'''--- example/Strategy/GridStrategy/getDualInvestment.example.ts ---
import { GetDualInvestmentParams, GridStrategy } from '../../../src';
import Decimal from 'decimal.js';

async function getDualInvestmentExample() {
    const params: GetDualInvestmentParams = {
        quoteBalance: new Decimal(1000),
        lowerPrice: new Decimal(10),
        upperPrice: new Decimal(20),
        gridNumber: new Decimal(100),
        marketPrice: new Decimal(19),
    };
    const dualInvestment = GridStrategy.getDualInvestment(params);
    console.log(dualInvestment);
}
getDualInvestmentExample();

'''
'''--- example/Strategy/GridStrategy/rebalance.example.ts ---
import { getMarketPrice, GridRebalanceParams, GridStrategy, SolanaBot } from '../../../src';
import { solanaBotSeed, solanaConnection, solanaEnv } from '../../constant.example';

async function rebalanceExample() {
    const bot = await SolanaBot.load(solanaConnection, solanaBotSeed, solanaEnv.programId);
    const marketPrice = await getMarketPrice('SOL');
    console.log(`Market price: ${marketPrice}`);

    const params: GridRebalanceParams = {
        botType: bot.type,
        amount: bot.amount,
        leverage: bot.leverage,
        lowerPrice: bot.lowerPrice,
        upperPrice: bot.upperPrice,
        gridNumber: bot.gridNumber,
        marketPrice: marketPrice,
        startPrice: bot.startPrice,
    };
    const rebalance = await GridStrategy.rebalance(params);
    console.log(rebalance);
}
rebalanceExample();

'''
'''--- example/constant.example.ts ---
import { Keypair, Connection } from '@solana/web3.js';
import { NEAR_CONTRACT_ID, SOLANA_ENV } from '../src';
import base58 from 'bs58';

// Solana constant
export const solanaWallet = Keypair.fromSecretKey(base58.decode('WALLET-SEC-KEY'));

export const solanaDelegate = Keypair.fromSecretKey(base58.decode('DELEGATE-SEC-KEY'));

export const solanaConnection = new Connection('https://api.mainnet-beta.solana.com');

export const solanaBotSeed = base58.decode('BMmmKskvwdoySKrkBZoMoPPeATBzw5Y3EDoLS9HaJ1tg');

export const solanaEnv = SOLANA_ENV.PROD_V2;

// Near constant
export const nearAccountId = 'delegate.near';

export const nearAccountPrivateKey = 'delegate-secret-key';

export const nearBotIndex = 23;

export const nearContractId = NEAR_CONTRACT_ID.PROD;

'''
'''--- example/util/getMangoReimbursementRow.example.ts ---
import { getMangoReimbursementRow } from '../../src';
import { solanaConnection } from '../constant.example';
import { PublicKey } from '@solana/web3.js';

async function getMangoReimbursementRowExample() {
    const botKey = new PublicKey('H32Tg76vg8Kjrze6vBFtiaUSsut9rmDdLXvrwxAHQfyn');
    const row = await getMangoReimbursementRow(solanaConnection, botKey);
    console.log(row);
}
getMangoReimbursementRowExample();

'''
'''--- example/util/getMarketPrice.example.ts ---
import { getMarketPrice } from '../../src';

async function getMarketPriceExample() {
    const price = await getMarketPrice('ETH');
    console.log(price);
}
getMarketPriceExample();

'''
'''--- example/util/getRefPoolPrice.example.ts ---
import { getRefPoolPrice } from '../../src';

async function getRefPoolPriceExample() {
    const poolId = 'ref.fakes.testnet|usdt.fakes.testnet|2000';
    const price = await getRefPoolPrice(poolId);
    console.log(price);
}
getRefPoolPriceExample();

'''
'''--- example/util/getZetaExpirySeries.example.ts ---
import { getZetaExpirySeries } from '../../src';
import { solanaConnection } from '../constant.example';

async function getZetaExpirySeriesExample() {
    const expirySeries = await getZetaExpirySeries(solanaConnection, 'SOL');
    console.log(expirySeries);

    console.log(
        `series 0 active: ${new Date(expirySeries[0].activeTs)}, expiry: ${new Date(expirySeries[0].expiryTs)}`,
    );
    console.log(
        `series 1 active: ${new Date(expirySeries[1].activeTs)}, expiry: ${new Date(expirySeries[1].expiryTs)}`,
    );
}
getZetaExpirySeriesExample();

'''
'''--- package-lock.json ---
{
    "name": "0xhipo-cell-sdk-release",
    "version": "2.4.2",
    "lockfileVersion": 3,
    "requires": true,
    "packages": {
        "": {
            "name": "0xhipo-cell-sdk-release",
            "version": "2.4.2",
            "license": "ISC",
            "dependencies": {
                "@blockworks-foundation/mango-client": "^3.6.11",
                "@project-serum/serum": "^0.13.65",
                "@solana/spl-token": "^0.3.5",
                "@solana/web3.js": "^1.47.3",
                "borsh": "^0.7.0",
                "buffer-layout": "^1.2.2",
                "decimal.js": "^10.4.2",
                "near-api-js": "^1.1.0"
            },
            "devDependencies": {
                "@types/bn.js": "^5.1.0",
                "@types/bs58": "^4.0.1",
                "@types/jest": "^28.1.6",
                "@typescript-eslint/eslint-plugin": "^5.27.1",
                "@typescript-eslint/parser": "^5.27.1",
                "eslint": "^8.17.0",
                "jest": "^28.1.3",
                "prettier": "^2.6.2",
                "ts-jest": "^28.0.7",
                "typescript": "^4.7.3"
            }
        },
        "node_modules/@ampproject/remapping": {
            "version": "2.2.0",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "@jridgewell/gen-mapping": "^0.1.0",
                "@jridgewell/trace-mapping": "^0.3.9"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@babel/code-frame": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/highlight": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/compat-data": {
            "version": "7.17.10",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/core": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@ampproject/remapping": "^2.1.0",
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.18.0",
                "@babel/helper-compilation-targets": "^7.17.10",
                "@babel/helper-module-transforms": "^7.18.0",
                "@babel/helpers": "^7.18.0",
                "@babel/parser": "^7.18.0",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.18.0",
                "@babel/types": "^7.18.0",
                "convert-source-map": "^1.7.0",
                "debug": "^4.1.0",
                "gensync": "^1.0.0-beta.2",
                "json5": "^2.2.1",
                "semver": "^6.3.0"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/babel"
            }
        },
        "node_modules/@babel/core/node_modules/semver": {
            "version": "6.3.0",
            "dev": true,
            "license": "ISC",
            "bin": {
                "semver": "bin/semver.js"
            }
        },
        "node_modules/@babel/generator": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.18.0",
                "@jridgewell/gen-mapping": "^0.3.0",
                "jsesc": "^2.5.1"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/generator/node_modules/@jridgewell/gen-mapping": {
            "version": "0.3.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jridgewell/set-array": "^1.0.0",
                "@jridgewell/sourcemap-codec": "^1.4.10",
                "@jridgewell/trace-mapping": "^0.3.9"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@babel/helper-compilation-targets": {
            "version": "7.17.10",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/compat-data": "^7.17.10",
                "@babel/helper-validator-option": "^7.16.7",
                "browserslist": "^4.20.2",
                "semver": "^6.3.0"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0"
            }
        },
        "node_modules/@babel/helper-compilation-targets/node_modules/semver": {
            "version": "6.3.0",
            "dev": true,
            "license": "ISC",
            "bin": {
                "semver": "bin/semver.js"
            }
        },
        "node_modules/@babel/helper-environment-visitor": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-function-name": {
            "version": "7.17.9",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/template": "^7.16.7",
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-hoist-variables": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-module-imports": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-module-transforms": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-module-imports": "^7.16.7",
                "@babel/helper-simple-access": "^7.17.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/helper-validator-identifier": "^7.16.7",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.18.0",
                "@babel/types": "^7.18.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-plugin-utils": {
            "version": "7.18.9",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-simple-access": {
            "version": "7.17.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-split-export-declaration": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-validator-identifier": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-validator-option": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helpers": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.18.0",
                "@babel/types": "^7.18.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/highlight": {
            "version": "7.17.12",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "chalk": "^2.0.0",
                "js-tokens": "^4.0.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/highlight/node_modules/ansi-styles": {
            "version": "3.2.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-convert": "^1.9.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/chalk": {
            "version": "2.4.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^3.2.1",
                "escape-string-regexp": "^1.0.5",
                "supports-color": "^5.3.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/color-convert": {
            "version": "1.9.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-name": "1.1.3"
            }
        },
        "node_modules/@babel/highlight/node_modules/color-name": {
            "version": "1.1.3",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@babel/highlight/node_modules/escape-string-regexp": {
            "version": "1.0.5",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.8.0"
            }
        },
        "node_modules/@babel/highlight/node_modules/has-flag": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/supports-color": {
            "version": "5.5.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^3.0.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/parser": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "bin": {
                "parser": "bin/babel-parser.js"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@babel/plugin-syntax-async-generators": {
            "version": "7.8.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-bigint": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-class-properties": {
            "version": "7.12.13",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.12.13"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-import-meta": {
            "version": "7.10.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-json-strings": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
            "version": "7.10.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-numeric-separator": {
            "version": "7.10.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-object-rest-spread": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-optional-catch-binding": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-optional-chaining": {
            "version": "7.8.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-top-level-await": {
            "version": "7.14.5",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.14.5"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-syntax-typescript": {
            "version": "7.18.6",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.18.6"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/runtime": {
            "version": "7.17.2",
            "license": "MIT",
            "dependencies": {
                "regenerator-runtime": "^0.13.4"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/template": {
            "version": "7.16.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.16.7",
                "@babel/parser": "^7.16.7",
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/traverse": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.18.0",
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-function-name": "^7.17.9",
                "@babel/helper-hoist-variables": "^7.16.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/parser": "^7.18.0",
                "@babel/types": "^7.18.0",
                "debug": "^4.1.0",
                "globals": "^11.1.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/traverse/node_modules/globals": {
            "version": "11.12.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/types": {
            "version": "7.18.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "to-fast-properties": "^2.0.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@bcoe/v8-coverage": {
            "version": "0.2.3",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@blockworks-foundation/mango-client": {
            "version": "3.6.14",
            "license": "MIT",
            "dependencies": {
                "@project-serum/anchor": "^0.21.0",
                "@project-serum/serum": "^0.13.65",
                "@project-serum/sol-wallet-adapter": "^0.2.0",
                "@solana/spl-token": "^0.1.6",
                "@solana/web3.js": "^1.43.5",
                "big.js": "^6.1.1",
                "bn.js": "^5.1.0",
                "buffer-layout": "^1.2.1",
                "cross-fetch": "^3.1.5",
                "dotenv": "^10.0.0",
                "toformat": "^2.0.0",
                "yargs": "^17.0.1"
            }
        },
        "node_modules/@blockworks-foundation/mango-client/node_modules/@solana/spl-token": {
            "version": "0.1.8",
            "license": "MIT",
            "dependencies": {
                "@babel/runtime": "^7.10.5",
                "@solana/web3.js": "^1.21.0",
                "bn.js": "^5.1.0",
                "buffer": "6.0.3",
                "buffer-layout": "^1.2.0",
                "dotenv": "10.0.0"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/@blockworks-foundation/mango-client/node_modules/buffer": {
            "version": "6.0.3",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/@cspotcode/source-map-support": {
            "version": "0.8.1",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true,
            "dependencies": {
                "@jridgewell/trace-mapping": "0.3.9"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
            "version": "0.3.9",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true,
            "dependencies": {
                "@jridgewell/resolve-uri": "^3.0.3",
                "@jridgewell/sourcemap-codec": "^1.4.10"
            }
        },
        "node_modules/@eslint/eslintrc": {
            "version": "1.3.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ajv": "^6.12.4",
                "debug": "^4.3.2",
                "espree": "^9.3.2",
                "globals": "^13.15.0",
                "ignore": "^5.2.0",
                "import-fresh": "^3.2.1",
                "js-yaml": "^4.1.0",
                "minimatch": "^3.1.2",
                "strip-json-comments": "^3.1.1"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            }
        },
        "node_modules/@humanwhocodes/config-array": {
            "version": "0.9.5",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "@humanwhocodes/object-schema": "^1.2.1",
                "debug": "^4.1.1",
                "minimatch": "^3.0.4"
            },
            "engines": {
                "node": ">=10.10.0"
            }
        },
        "node_modules/@humanwhocodes/object-schema": {
            "version": "1.2.1",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@istanbuljs/load-nyc-config": {
            "version": "1.1.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "camelcase": "^5.3.1",
                "find-up": "^4.1.0",
                "get-package-type": "^0.1.0",
                "js-yaml": "^3.13.1",
                "resolve-from": "^5.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/@istanbuljs/load-nyc-config/node_modules/argparse": {
            "version": "1.0.10",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "sprintf-js": "~1.0.2"
            }
        },
        "node_modules/@istanbuljs/load-nyc-config/node_modules/js-yaml": {
            "version": "3.14.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "argparse": "^1.0.7",
                "esprima": "^4.0.0"
            },
            "bin": {
                "js-yaml": "bin/js-yaml.js"
            }
        },
        "node_modules/@istanbuljs/load-nyc-config/node_modules/resolve-from": {
            "version": "5.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/@istanbuljs/schema": {
            "version": "0.1.3",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/@jest/console": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "chalk": "^4.0.0",
                "jest-message-util": "^28.1.3",
                "jest-util": "^28.1.3",
                "slash": "^3.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/core": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/console": "^28.1.3",
                "@jest/reporters": "^28.1.3",
                "@jest/test-result": "^28.1.3",
                "@jest/transform": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "ansi-escapes": "^4.2.1",
                "chalk": "^4.0.0",
                "ci-info": "^3.2.0",
                "exit": "^0.1.2",
                "graceful-fs": "^4.2.9",
                "jest-changed-files": "^28.1.3",
                "jest-config": "^28.1.3",
                "jest-haste-map": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-regex-util": "^28.0.2",
                "jest-resolve": "^28.1.3",
                "jest-resolve-dependencies": "^28.1.3",
                "jest-runner": "^28.1.3",
                "jest-runtime": "^28.1.3",
                "jest-snapshot": "^28.1.3",
                "jest-util": "^28.1.3",
                "jest-validate": "^28.1.3",
                "jest-watcher": "^28.1.3",
                "micromatch": "^4.0.4",
                "pretty-format": "^28.1.3",
                "rimraf": "^3.0.0",
                "slash": "^3.0.0",
                "strip-ansi": "^6.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
                "node-notifier": {
                    "optional": true
                }
            }
        },
        "node_modules/@jest/environment": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/fake-timers": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "jest-mock": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/expect": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "expect": "^28.1.3",
                "jest-snapshot": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/expect-utils": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "jest-get-type": "^28.0.2"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/fake-timers": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "@sinonjs/fake-timers": "^9.1.2",
                "@types/node": "*",
                "jest-message-util": "^28.1.3",
                "jest-mock": "^28.1.3",
                "jest-util": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/globals": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/environment": "^28.1.3",
                "@jest/expect": "^28.1.3",
                "@jest/types": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/reporters": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@bcoe/v8-coverage": "^0.2.3",
                "@jest/console": "^28.1.3",
                "@jest/test-result": "^28.1.3",
                "@jest/transform": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@jridgewell/trace-mapping": "^0.3.13",
                "@types/node": "*",
                "chalk": "^4.0.0",
                "collect-v8-coverage": "^1.0.0",
                "exit": "^0.1.2",
                "glob": "^7.1.3",
                "graceful-fs": "^4.2.9",
                "istanbul-lib-coverage": "^3.0.0",
                "istanbul-lib-instrument": "^5.1.0",
                "istanbul-lib-report": "^3.0.0",
                "istanbul-lib-source-maps": "^4.0.0",
                "istanbul-reports": "^3.1.3",
                "jest-message-util": "^28.1.3",
                "jest-util": "^28.1.3",
                "jest-worker": "^28.1.3",
                "slash": "^3.0.0",
                "string-length": "^4.0.1",
                "strip-ansi": "^6.0.0",
                "terminal-link": "^2.0.0",
                "v8-to-istanbul": "^9.0.1"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
                "node-notifier": {
                    "optional": true
                }
            }
        },
        "node_modules/@jest/schemas": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@sinclair/typebox": "^0.24.1"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/source-map": {
            "version": "28.1.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jridgewell/trace-mapping": "^0.3.13",
                "callsites": "^3.0.0",
                "graceful-fs": "^4.2.9"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/test-result": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/console": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/istanbul-lib-coverage": "^2.0.0",
                "collect-v8-coverage": "^1.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/test-sequencer": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/test-result": "^28.1.3",
                "graceful-fs": "^4.2.9",
                "jest-haste-map": "^28.1.3",
                "slash": "^3.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/transform": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/core": "^7.11.6",
                "@jest/types": "^28.1.3",
                "@jridgewell/trace-mapping": "^0.3.13",
                "babel-plugin-istanbul": "^6.1.1",
                "chalk": "^4.0.0",
                "convert-source-map": "^1.4.0",
                "fast-json-stable-stringify": "^2.0.0",
                "graceful-fs": "^4.2.9",
                "jest-haste-map": "^28.1.3",
                "jest-regex-util": "^28.0.2",
                "jest-util": "^28.1.3",
                "micromatch": "^4.0.4",
                "pirates": "^4.0.4",
                "slash": "^3.0.0",
                "write-file-atomic": "^4.0.1"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jest/types": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/schemas": "^28.1.3",
                "@types/istanbul-lib-coverage": "^2.0.0",
                "@types/istanbul-reports": "^3.0.0",
                "@types/node": "*",
                "@types/yargs": "^17.0.8",
                "chalk": "^4.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/@jridgewell/gen-mapping": {
            "version": "0.1.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jridgewell/set-array": "^1.0.0",
                "@jridgewell/sourcemap-codec": "^1.4.10"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@jridgewell/resolve-uri": {
            "version": "3.0.7",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@jridgewell/set-array": {
            "version": "1.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@jridgewell/sourcemap-codec": {
            "version": "1.4.13",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@jridgewell/trace-mapping": {
            "version": "0.3.13",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jridgewell/resolve-uri": "^3.0.3",
                "@jridgewell/sourcemap-codec": "^1.4.10"
            }
        },
        "node_modules/@noble/ed25519": {
            "version": "1.7.1",
            "funding": [
                {
                    "type": "individual",
                    "url": "https://paulmillr.com/funding/"
                }
            ],
            "license": "MIT"
        },
        "node_modules/@noble/hashes": {
            "version": "1.1.2",
            "funding": [
                {
                    "type": "individual",
                    "url": "https://paulmillr.com/funding/"
                }
            ],
            "license": "MIT"
        },
        "node_modules/@noble/secp256k1": {
            "version": "1.7.0",
            "funding": [
                {
                    "type": "individual",
                    "url": "https://paulmillr.com/funding/"
                }
            ],
            "license": "MIT"
        },
        "node_modules/@nodelib/fs.scandir": {
            "version": "2.1.5",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@nodelib/fs.stat": "2.0.5",
                "run-parallel": "^1.1.9"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/@nodelib/fs.stat": {
            "version": "2.0.5",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/@nodelib/fs.walk": {
            "version": "1.2.8",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@nodelib/fs.scandir": "2.1.5",
                "fastq": "^1.6.0"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/@project-serum/anchor": {
            "version": "0.21.0",
            "license": "(MIT OR Apache-2.0)",
            "dependencies": {
                "@project-serum/borsh": "^0.2.4",
                "@solana/web3.js": "^1.17.0",
                "base64-js": "^1.5.1",
                "bn.js": "^5.1.2",
                "bs58": "^4.0.1",
                "buffer-layout": "^1.2.2",
                "camelcase": "^5.3.1",
                "cross-fetch": "^3.1.5",
                "crypto-hash": "^1.3.0",
                "eventemitter3": "^4.0.7",
                "find": "^0.3.0",
                "js-sha256": "^0.9.0",
                "pako": "^2.0.3",
                "snake-case": "^3.0.4",
                "toml": "^3.0.0"
            },
            "engines": {
                "node": ">=11"
            }
        },
        "node_modules/@project-serum/borsh": {
            "version": "0.2.5",
            "license": "Apache-2.0",
            "dependencies": {
                "bn.js": "^5.1.2",
                "buffer-layout": "^1.2.0"
            },
            "engines": {
                "node": ">=10"
            },
            "peerDependencies": {
                "@solana/web3.js": "^1.2.0"
            }
        },
        "node_modules/@project-serum/serum": {
            "version": "0.13.65",
            "license": "MIT",
            "dependencies": {
                "@project-serum/anchor": "^0.11.1",
                "@solana/spl-token": "^0.1.6",
                "@solana/web3.js": "^1.21.0",
                "bn.js": "^5.1.2",
                "buffer-layout": "^1.2.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/@project-serum/serum/node_modules/@project-serum/anchor": {
            "version": "0.11.1",
            "license": "(MIT OR Apache-2.0)",
            "dependencies": {
                "@project-serum/borsh": "^0.2.2",
                "@solana/web3.js": "^1.17.0",
                "base64-js": "^1.5.1",
                "bn.js": "^5.1.2",
                "bs58": "^4.0.1",
                "buffer-layout": "^1.2.0",
                "camelcase": "^5.3.1",
                "crypto-hash": "^1.3.0",
                "eventemitter3": "^4.0.7",
                "find": "^0.3.0",
                "js-sha256": "^0.9.0",
                "pako": "^2.0.3",
                "snake-case": "^3.0.4",
                "toml": "^3.0.0"
            },
            "engines": {
                "node": ">=11"
            }
        },
        "node_modules/@project-serum/serum/node_modules/@solana/spl-token": {
            "version": "0.1.8",
            "license": "MIT",
            "dependencies": {
                "@babel/runtime": "^7.10.5",
                "@solana/web3.js": "^1.21.0",
                "bn.js": "^5.1.0",
                "buffer": "6.0.3",
                "buffer-layout": "^1.2.0",
                "dotenv": "10.0.0"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/@project-serum/serum/node_modules/buffer": {
            "version": "6.0.3",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/@project-serum/sol-wallet-adapter": {
            "version": "0.2.6",
            "license": "Apache-2.0",
            "dependencies": {
                "bs58": "^4.0.1",
                "eventemitter3": "^4.0.7"
            },
            "engines": {
                "node": ">=10"
            },
            "peerDependencies": {
                "@solana/web3.js": "^1.5.0"
            }
        },
        "node_modules/@sinclair/typebox": {
            "version": "0.24.22",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@sinonjs/commons": {
            "version": "1.8.3",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "type-detect": "4.0.8"
            }
        },
        "node_modules/@sinonjs/fake-timers": {
            "version": "9.1.2",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "@sinonjs/commons": "^1.7.0"
            }
        },
        "node_modules/@solana/buffer-layout": {
            "version": "4.0.0",
            "license": "MIT",
            "dependencies": {
                "buffer": "~6.0.3"
            },
            "engines": {
                "node": ">=5.10"
            }
        },
        "node_modules/@solana/buffer-layout-utils": {
            "version": "0.2.0",
            "license": "Apache-2.0",
            "dependencies": {
                "@solana/buffer-layout": "^4.0.0",
                "@solana/web3.js": "^1.32.0",
                "bigint-buffer": "^1.1.5",
                "bignumber.js": "^9.0.1"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/@solana/buffer-layout/node_modules/buffer": {
            "version": "6.0.3",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/@solana/spl-token": {
            "version": "0.3.5",
            "license": "Apache-2.0",
            "dependencies": {
                "@solana/buffer-layout": "^4.0.0",
                "@solana/buffer-layout-utils": "^0.2.0",
                "buffer": "^6.0.3"
            },
            "engines": {
                "node": ">=16"
            },
            "peerDependencies": {
                "@solana/web3.js": "^1.47.4"
            }
        },
        "node_modules/@solana/spl-token/node_modules/buffer": {
            "version": "6.0.3",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/@solana/web3.js": {
            "version": "1.62.0",
            "license": "MIT",
            "dependencies": {
                "@babel/runtime": "^7.12.5",
                "@noble/ed25519": "^1.7.0",
                "@noble/hashes": "^1.1.2",
                "@noble/secp256k1": "^1.6.3",
                "@solana/buffer-layout": "^4.0.0",
                "bigint-buffer": "^1.1.5",
                "bn.js": "^5.0.0",
                "borsh": "^0.7.0",
                "bs58": "^4.0.1",
                "buffer": "6.0.1",
                "fast-stable-stringify": "^1.0.0",
                "jayson": "^3.4.4",
                "node-fetch": "2",
                "rpc-websockets": "^7.5.0",
                "superstruct": "^0.14.2"
            },
            "engines": {
                "node": ">=12.20.0"
            }
        },
        "node_modules/@tsconfig/node10": {
            "version": "1.0.8",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/@tsconfig/node12": {
            "version": "1.0.9",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/@tsconfig/node14": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/@tsconfig/node16": {
            "version": "1.0.2",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/@types/babel__core": {
            "version": "7.1.19",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/parser": "^7.1.0",
                "@babel/types": "^7.0.0",
                "@types/babel__generator": "*",
                "@types/babel__template": "*",
                "@types/babel__traverse": "*"
            }
        },
        "node_modules/@types/babel__generator": {
            "version": "7.6.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.0.0"
            }
        },
        "node_modules/@types/babel__template": {
            "version": "7.4.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/parser": "^7.1.0",
                "@babel/types": "^7.0.0"
            }
        },
        "node_modules/@types/babel__traverse": {
            "version": "7.17.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.3.0"
            }
        },
        "node_modules/@types/bn.js": {
            "version": "5.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/node": "*"
            }
        },
        "node_modules/@types/bs58": {
            "version": "4.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "base-x": "^3.0.6"
            }
        },
        "node_modules/@types/connect": {
            "version": "3.4.35",
            "license": "MIT",
            "dependencies": {
                "@types/node": "*"
            }
        },
        "node_modules/@types/express-serve-static-core": {
            "version": "4.17.28",
            "license": "MIT",
            "dependencies": {
                "@types/node": "*",
                "@types/qs": "*",
                "@types/range-parser": "*"
            }
        },
        "node_modules/@types/graceful-fs": {
            "version": "4.1.5",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/node": "*"
            }
        },
        "node_modules/@types/istanbul-lib-coverage": {
            "version": "2.0.4",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/istanbul-lib-report": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/istanbul-lib-coverage": "*"
            }
        },
        "node_modules/@types/istanbul-reports": {
            "version": "3.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/istanbul-lib-report": "*"
            }
        },
        "node_modules/@types/jest": {
            "version": "28.1.6",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "jest-matcher-utils": "^28.0.0",
                "pretty-format": "^28.0.0"
            }
        },
        "node_modules/@types/json-schema": {
            "version": "7.0.11",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/lodash": {
            "version": "4.14.178",
            "license": "MIT"
        },
        "node_modules/@types/node": {
            "version": "17.0.17",
            "license": "MIT"
        },
        "node_modules/@types/prettier": {
            "version": "2.6.4",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/qs": {
            "version": "6.9.7",
            "license": "MIT"
        },
        "node_modules/@types/range-parser": {
            "version": "1.2.4",
            "license": "MIT"
        },
        "node_modules/@types/stack-utils": {
            "version": "2.0.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/ws": {
            "version": "7.4.7",
            "license": "MIT",
            "dependencies": {
                "@types/node": "*"
            }
        },
        "node_modules/@types/yargs": {
            "version": "17.0.10",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/yargs-parser": "*"
            }
        },
        "node_modules/@types/yargs-parser": {
            "version": "21.0.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@typescript-eslint/eslint-plugin": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@typescript-eslint/scope-manager": "5.27.1",
                "@typescript-eslint/type-utils": "5.27.1",
                "@typescript-eslint/utils": "5.27.1",
                "debug": "^4.3.4",
                "functional-red-black-tree": "^1.0.1",
                "ignore": "^5.2.0",
                "regexpp": "^3.2.0",
                "semver": "^7.3.7",
                "tsutils": "^3.21.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
                "@typescript-eslint/parser": "^5.0.0",
                "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
            },
            "peerDependenciesMeta": {
                "typescript": {
                    "optional": true
                }
            }
        },
        "node_modules/@typescript-eslint/parser": {
            "version": "5.27.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "@typescript-eslint/scope-manager": "5.27.1",
                "@typescript-eslint/types": "5.27.1",
                "@typescript-eslint/typescript-estree": "5.27.1",
                "debug": "^4.3.4"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
                "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
            },
            "peerDependenciesMeta": {
                "typescript": {
                    "optional": true
                }
            }
        },
        "node_modules/@typescript-eslint/scope-manager": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@typescript-eslint/types": "5.27.1",
                "@typescript-eslint/visitor-keys": "5.27.1"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            }
        },
        "node_modules/@typescript-eslint/type-utils": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@typescript-eslint/utils": "5.27.1",
                "debug": "^4.3.4",
                "tsutils": "^3.21.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
                "eslint": "*"
            },
            "peerDependenciesMeta": {
                "typescript": {
                    "optional": true
                }
            }
        },
        "node_modules/@typescript-eslint/types": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            }
        },
        "node_modules/@typescript-eslint/typescript-estree": {
            "version": "5.27.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "@typescript-eslint/types": "5.27.1",
                "@typescript-eslint/visitor-keys": "5.27.1",
                "debug": "^4.3.4",
                "globby": "^11.1.0",
                "is-glob": "^4.0.3",
                "semver": "^7.3.7",
                "tsutils": "^3.21.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependenciesMeta": {
                "typescript": {
                    "optional": true
                }
            }
        },
        "node_modules/@typescript-eslint/utils": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/json-schema": "^7.0.9",
                "@typescript-eslint/scope-manager": "5.27.1",
                "@typescript-eslint/types": "5.27.1",
                "@typescript-eslint/typescript-estree": "5.27.1",
                "eslint-scope": "^5.1.1",
                "eslint-utils": "^3.0.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
                "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
            }
        },
        "node_modules/@typescript-eslint/visitor-keys": {
            "version": "5.27.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@typescript-eslint/types": "5.27.1",
                "eslint-visitor-keys": "^3.3.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/typescript-eslint"
            }
        },
        "node_modules/acorn": {
            "version": "8.7.1",
            "dev": true,
            "license": "MIT",
            "bin": {
                "acorn": "bin/acorn"
            },
            "engines": {
                "node": ">=0.4.0"
            }
        },
        "node_modules/acorn-jsx": {
            "version": "5.3.2",
            "dev": true,
            "license": "MIT",
            "peerDependencies": {
                "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
            }
        },
        "node_modules/acorn-walk": {
            "version": "8.2.0",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true,
            "engines": {
                "node": ">=0.4.0"
            }
        },
        "node_modules/ajv": {
            "version": "6.12.6",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fast-deep-equal": "^3.1.1",
                "fast-json-stable-stringify": "^2.0.0",
                "json-schema-traverse": "^0.4.1",
                "uri-js": "^4.2.2"
            },
            "funding": {
                "type": "github",
                "url": "https://github.com/sponsors/epoberezkin"
            }
        },
        "node_modules/ansi-escapes": {
            "version": "4.3.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "type-fest": "^0.21.3"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/ansi-escapes/node_modules/type-fest": {
            "version": "0.21.3",
            "dev": true,
            "license": "(MIT OR CC0-1.0)",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/ansi-regex": {
            "version": "5.0.1",
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/ansi-styles": {
            "version": "4.3.0",
            "license": "MIT",
            "dependencies": {
                "color-convert": "^2.0.1"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/chalk/ansi-styles?sponsor=1"
            }
        },
        "node_modules/anymatch": {
            "version": "3.1.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "normalize-path": "^3.0.0",
                "picomatch": "^2.0.4"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/arg": {
            "version": "4.1.3",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/argparse": {
            "version": "2.0.1",
            "dev": true,
            "license": "Python-2.0"
        },
        "node_modules/array-union": {
            "version": "2.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/babel-jest": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/transform": "^28.1.3",
                "@types/babel__core": "^7.1.14",
                "babel-plugin-istanbul": "^6.1.1",
                "babel-preset-jest": "^28.1.3",
                "chalk": "^4.0.0",
                "graceful-fs": "^4.2.9",
                "slash": "^3.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.8.0"
            }
        },
        "node_modules/babel-plugin-istanbul": {
            "version": "6.1.1",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.0.0",
                "@istanbuljs/load-nyc-config": "^1.0.0",
                "@istanbuljs/schema": "^0.1.2",
                "istanbul-lib-instrument": "^5.0.4",
                "test-exclude": "^6.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/babel-plugin-jest-hoist": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/template": "^7.3.3",
                "@babel/types": "^7.3.3",
                "@types/babel__core": "^7.1.14",
                "@types/babel__traverse": "^7.0.6"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/babel-preset-current-node-syntax": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/plugin-syntax-async-generators": "^7.8.4",
                "@babel/plugin-syntax-bigint": "^7.8.3",
                "@babel/plugin-syntax-class-properties": "^7.8.3",
                "@babel/plugin-syntax-import-meta": "^7.8.3",
                "@babel/plugin-syntax-json-strings": "^7.8.3",
                "@babel/plugin-syntax-logical-assignment-operators": "^7.8.3",
                "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
                "@babel/plugin-syntax-numeric-separator": "^7.8.3",
                "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
                "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
                "@babel/plugin-syntax-optional-chaining": "^7.8.3",
                "@babel/plugin-syntax-top-level-await": "^7.8.3"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0"
            }
        },
        "node_modules/babel-preset-jest": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "babel-plugin-jest-hoist": "^28.1.3",
                "babel-preset-current-node-syntax": "^1.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0"
            }
        },
        "node_modules/balanced-match": {
            "version": "1.0.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/base-x": {
            "version": "3.0.9",
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "^5.0.1"
            }
        },
        "node_modules/base64-js": {
            "version": "1.5.1",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/big.js": {
            "version": "6.1.1",
            "license": "MIT",
            "engines": {
                "node": "*"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/bigjs"
            }
        },
        "node_modules/bigint-buffer": {
            "version": "1.1.5",
            "hasInstallScript": true,
            "license": "Apache-2.0",
            "dependencies": {
                "bindings": "^1.3.0"
            },
            "engines": {
                "node": ">= 10.0.0"
            }
        },
        "node_modules/bignumber.js": {
            "version": "9.1.0",
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/bindings": {
            "version": "1.5.0",
            "license": "MIT",
            "dependencies": {
                "file-uri-to-path": "1.0.0"
            }
        },
        "node_modules/bindings/node_modules/file-uri-to-path": {
            "version": "1.0.0",
            "license": "MIT"
        },
        "node_modules/bn.js": {
            "version": "5.2.1",
            "license": "MIT"
        },
        "node_modules/borsh": {
            "version": "0.7.0",
            "license": "Apache-2.0",
            "dependencies": {
                "bn.js": "^5.2.0",
                "bs58": "^4.0.0",
                "text-encoding-utf-8": "^1.0.2"
            }
        },
        "node_modules/brace-expansion": {
            "version": "1.1.11",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "balanced-match": "^1.0.0",
                "concat-map": "0.0.1"
            }
        },
        "node_modules/braces": {
            "version": "3.0.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fill-range": "^7.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/browserslist": {
            "version": "4.20.3",
            "dev": true,
            "funding": [
                {
                    "type": "opencollective",
                    "url": "https://opencollective.com/browserslist"
                },
                {
                    "type": "tidelift",
                    "url": "https://tidelift.com/funding/github/npm/browserslist"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "caniuse-lite": "^1.0.30001332",
                "electron-to-chromium": "^1.4.118",
                "escalade": "^3.1.1",
                "node-releases": "^2.0.3",
                "picocolors": "^1.0.0"
            },
            "bin": {
                "browserslist": "cli.js"
            },
            "engines": {
                "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
            }
        },
        "node_modules/bs-logger": {
            "version": "0.2.6",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fast-json-stable-stringify": "2.x"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/bs58": {
            "version": "4.0.1",
            "license": "MIT",
            "dependencies": {
                "base-x": "^3.0.2"
            }
        },
        "node_modules/bser": {
            "version": "2.1.1",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "node-int64": "^0.4.0"
            }
        },
        "node_modules/buffer": {
            "version": "6.0.1",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/buffer-from": {
            "version": "1.1.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/buffer-layout": {
            "version": "1.2.2",
            "license": "MIT",
            "engines": {
                "node": ">=4.5"
            }
        },
        "node_modules/bufferutil": {
            "version": "4.0.6",
            "hasInstallScript": true,
            "license": "MIT",
            "optional": true,
            "dependencies": {
                "node-gyp-build": "^4.3.0"
            },
            "engines": {
                "node": ">=6.14.2"
            }
        },
        "node_modules/callsites": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/camelcase": {
            "version": "5.3.1",
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/caniuse-lite": {
            "version": "1.0.30001341",
            "dev": true,
            "funding": [
                {
                    "type": "opencollective",
                    "url": "https://opencollective.com/browserslist"
                },
                {
                    "type": "tidelift",
                    "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
                }
            ],
            "license": "CC-BY-4.0"
        },
        "node_modules/capability": {
            "version": "0.2.5",
            "license": "MIT"
        },
        "node_modules/chalk": {
            "version": "4.1.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^4.1.0",
                "supports-color": "^7.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/chalk?sponsor=1"
            }
        },
        "node_modules/char-regex": {
            "version": "1.0.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/ci-info": {
            "version": "3.3.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/cjs-module-lexer": {
            "version": "1.2.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/cliui": {
            "version": "7.0.4",
            "license": "ISC",
            "dependencies": {
                "string-width": "^4.2.0",
                "strip-ansi": "^6.0.0",
                "wrap-ansi": "^7.0.0"
            }
        },
        "node_modules/co": {
            "version": "4.6.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "iojs": ">= 1.0.0",
                "node": ">= 0.12.0"
            }
        },
        "node_modules/collect-v8-coverage": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/color-convert": {
            "version": "2.0.1",
            "license": "MIT",
            "dependencies": {
                "color-name": "~1.1.4"
            },
            "engines": {
                "node": ">=7.0.0"
            }
        },
        "node_modules/color-name": {
            "version": "1.1.4",
            "license": "MIT"
        },
        "node_modules/commander": {
            "version": "2.20.3",
            "license": "MIT"
        },
        "node_modules/concat-map": {
            "version": "0.0.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/convert-source-map": {
            "version": "1.8.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "~5.1.1"
            }
        },
        "node_modules/convert-source-map/node_modules/safe-buffer": {
            "version": "5.1.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/create-require": {
            "version": "1.1.1",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/cross-fetch": {
            "version": "3.1.5",
            "license": "MIT",
            "dependencies": {
                "node-fetch": "2.6.7"
            }
        },
        "node_modules/cross-spawn": {
            "version": "7.0.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "path-key": "^3.1.0",
                "shebang-command": "^2.0.0",
                "which": "^2.0.1"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/crypto-hash": {
            "version": "1.3.0",
            "license": "MIT",
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/debug": {
            "version": "4.3.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.1.2"
            },
            "engines": {
                "node": ">=6.0"
            },
            "peerDependenciesMeta": {
                "supports-color": {
                    "optional": true
                }
            }
        },
        "node_modules/decimal.js": {
            "version": "10.4.2",
            "license": "MIT"
        },
        "node_modules/dedent": {
            "version": "0.7.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/deep-is": {
            "version": "0.1.4",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/deepmerge": {
            "version": "4.2.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/delay": {
            "version": "5.0.0",
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/depd": {
            "version": "2.0.0",
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/detect-newline": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/diff": {
            "version": "4.0.2",
            "dev": true,
            "license": "BSD-3-Clause",
            "optional": true,
            "peer": true,
            "engines": {
                "node": ">=0.3.1"
            }
        },
        "node_modules/diff-sequences": {
            "version": "28.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/dir-glob": {
            "version": "3.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "path-type": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/doctrine": {
            "version": "3.0.0",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "esutils": "^2.0.2"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/dot-case": {
            "version": "3.0.4",
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/dotenv": {
            "version": "10.0.0",
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/electron-to-chromium": {
            "version": "1.4.137",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/emittery": {
            "version": "0.10.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=12"
            },
            "funding": {
                "url": "https://github.com/sindresorhus/emittery?sponsor=1"
            }
        },
        "node_modules/emoji-regex": {
            "version": "8.0.0",
            "license": "MIT"
        },
        "node_modules/error-ex": {
            "version": "1.3.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-arrayish": "^0.2.1"
            }
        },
        "node_modules/error-polyfill": {
            "version": "0.1.3",
            "license": "MIT",
            "dependencies": {
                "capability": "^0.2.5",
                "o3": "^1.0.3",
                "u3": "^0.1.1"
            }
        },
        "node_modules/es6-promise": {
            "version": "4.2.8",
            "license": "MIT"
        },
        "node_modules/es6-promisify": {
            "version": "5.0.0",
            "license": "MIT",
            "dependencies": {
                "es6-promise": "^4.0.3"
            }
        },
        "node_modules/escalade": {
            "version": "3.1.1",
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/escape-string-regexp": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/eslint": {
            "version": "8.17.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@eslint/eslintrc": "^1.3.0",
                "@humanwhocodes/config-array": "^0.9.2",
                "ajv": "^6.10.0",
                "chalk": "^4.0.0",
                "cross-spawn": "^7.0.2",
                "debug": "^4.3.2",
                "doctrine": "^3.0.0",
                "escape-string-regexp": "^4.0.0",
                "eslint-scope": "^7.1.1",
                "eslint-utils": "^3.0.0",
                "eslint-visitor-keys": "^3.3.0",
                "espree": "^9.3.2",
                "esquery": "^1.4.0",
                "esutils": "^2.0.2",
                "fast-deep-equal": "^3.1.3",
                "file-entry-cache": "^6.0.1",
                "functional-red-black-tree": "^1.0.1",
                "glob-parent": "^6.0.1",
                "globals": "^13.15.0",
                "ignore": "^5.2.0",
                "import-fresh": "^3.0.0",
                "imurmurhash": "^0.1.4",
                "is-glob": "^4.0.0",
                "js-yaml": "^4.1.0",
                "json-stable-stringify-without-jsonify": "^1.0.1",
                "levn": "^0.4.1",
                "lodash.merge": "^4.6.2",
                "minimatch": "^3.1.2",
                "natural-compare": "^1.4.0",
                "optionator": "^0.9.1",
                "regexpp": "^3.2.0",
                "strip-ansi": "^6.0.1",
                "strip-json-comments": "^3.1.0",
                "text-table": "^0.2.0",
                "v8-compile-cache": "^2.0.3"
            },
            "bin": {
                "eslint": "bin/eslint.js"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            },
            "funding": {
                "url": "https://opencollective.com/eslint"
            }
        },
        "node_modules/eslint-scope": {
            "version": "5.1.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "esrecurse": "^4.3.0",
                "estraverse": "^4.1.1"
            },
            "engines": {
                "node": ">=8.0.0"
            }
        },
        "node_modules/eslint-utils": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "eslint-visitor-keys": "^2.0.0"
            },
            "engines": {
                "node": "^10.0.0 || ^12.0.0 || >= 14.0.0"
            },
            "funding": {
                "url": "https://github.com/sponsors/mysticatea"
            },
            "peerDependencies": {
                "eslint": ">=5"
            }
        },
        "node_modules/eslint-utils/node_modules/eslint-visitor-keys": {
            "version": "2.1.0",
            "dev": true,
            "license": "Apache-2.0",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/eslint-visitor-keys": {
            "version": "3.3.0",
            "dev": true,
            "license": "Apache-2.0",
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            }
        },
        "node_modules/eslint/node_modules/eslint-scope": {
            "version": "7.1.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "esrecurse": "^4.3.0",
                "estraverse": "^5.2.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            }
        },
        "node_modules/eslint/node_modules/estraverse": {
            "version": "5.3.0",
            "dev": true,
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/eslint/node_modules/levn": {
            "version": "0.4.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "prelude-ls": "^1.2.1",
                "type-check": "~0.4.0"
            },
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/eslint/node_modules/optionator": {
            "version": "0.9.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "deep-is": "^0.1.3",
                "fast-levenshtein": "^2.0.6",
                "levn": "^0.4.1",
                "prelude-ls": "^1.2.1",
                "type-check": "^0.4.0",
                "word-wrap": "^1.2.3"
            },
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/eslint/node_modules/prelude-ls": {
            "version": "1.2.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/eslint/node_modules/type-check": {
            "version": "0.4.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "prelude-ls": "^1.2.1"
            },
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/espree": {
            "version": "9.3.2",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "acorn": "^8.7.1",
                "acorn-jsx": "^5.3.2",
                "eslint-visitor-keys": "^3.3.0"
            },
            "engines": {
                "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
            }
        },
        "node_modules/esprima": {
            "version": "4.0.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "bin": {
                "esparse": "bin/esparse.js",
                "esvalidate": "bin/esvalidate.js"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/esquery": {
            "version": "1.4.0",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "estraverse": "^5.1.0"
            },
            "engines": {
                "node": ">=0.10"
            }
        },
        "node_modules/esquery/node_modules/estraverse": {
            "version": "5.3.0",
            "dev": true,
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/esrecurse": {
            "version": "4.3.0",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "estraverse": "^5.2.0"
            },
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/esrecurse/node_modules/estraverse": {
            "version": "5.3.0",
            "dev": true,
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/estraverse": {
            "version": "4.3.0",
            "dev": true,
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/esutils": {
            "version": "2.0.3",
            "dev": true,
            "license": "BSD-2-Clause",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/eventemitter3": {
            "version": "4.0.7",
            "license": "MIT"
        },
        "node_modules/execa": {
            "version": "5.1.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "cross-spawn": "^7.0.3",
                "get-stream": "^6.0.0",
                "human-signals": "^2.1.0",
                "is-stream": "^2.0.0",
                "merge-stream": "^2.0.0",
                "npm-run-path": "^4.0.1",
                "onetime": "^5.1.2",
                "signal-exit": "^3.0.3",
                "strip-final-newline": "^2.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sindresorhus/execa?sponsor=1"
            }
        },
        "node_modules/exit": {
            "version": "0.1.2",
            "dev": true,
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/expect": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/expect-utils": "^28.1.3",
                "jest-get-type": "^28.0.2",
                "jest-matcher-utils": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-util": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/eyes": {
            "version": "0.1.8",
            "engines": {
                "node": "> 0.1.90"
            }
        },
        "node_modules/fast-deep-equal": {
            "version": "3.1.3",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/fast-glob": {
            "version": "3.2.11",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@nodelib/fs.stat": "^2.0.2",
                "@nodelib/fs.walk": "^1.2.3",
                "glob-parent": "^5.1.2",
                "merge2": "^1.3.0",
                "micromatch": "^4.0.4"
            },
            "engines": {
                "node": ">=8.6.0"
            }
        },
        "node_modules/fast-glob/node_modules/glob-parent": {
            "version": "5.1.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "is-glob": "^4.0.1"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/fast-json-stable-stringify": {
            "version": "2.1.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/fast-levenshtein": {
            "version": "2.0.6",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/fast-stable-stringify": {
            "version": "1.0.0",
            "license": "MIT"
        },
        "node_modules/fastq": {
            "version": "1.13.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "reusify": "^1.0.4"
            }
        },
        "node_modules/fb-watchman": {
            "version": "2.0.1",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "bser": "2.1.1"
            }
        },
        "node_modules/file-entry-cache": {
            "version": "6.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "flat-cache": "^3.0.4"
            },
            "engines": {
                "node": "^10.12.0 || >=12.0.0"
            }
        },
        "node_modules/fill-range": {
            "version": "7.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "to-regex-range": "^5.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/find": {
            "version": "0.3.0",
            "license": "MIT",
            "dependencies": {
                "traverse-chain": "~0.1.0"
            }
        },
        "node_modules/find-up": {
            "version": "4.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "locate-path": "^5.0.0",
                "path-exists": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/flat-cache": {
            "version": "3.0.4",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "flatted": "^3.1.0",
                "rimraf": "^3.0.2"
            },
            "engines": {
                "node": "^10.12.0 || >=12.0.0"
            }
        },
        "node_modules/flatted": {
            "version": "3.2.5",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/fs.realpath": {
            "version": "1.0.0",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/fsevents": {
            "version": "2.3.2",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
                "darwin"
            ],
            "engines": {
                "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
            }
        },
        "node_modules/function-bind": {
            "version": "1.1.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/functional-red-black-tree": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/gensync": {
            "version": "1.0.0-beta.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/get-caller-file": {
            "version": "2.0.5",
            "license": "ISC",
            "engines": {
                "node": "6.* || 8.* || >= 10.*"
            }
        },
        "node_modules/get-package-type": {
            "version": "0.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8.0.0"
            }
        },
        "node_modules/get-stream": {
            "version": "6.0.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/glob": {
            "version": "7.2.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "fs.realpath": "^1.0.0",
                "inflight": "^1.0.4",
                "inherits": "2",
                "minimatch": "^3.0.4",
                "once": "^1.3.0",
                "path-is-absolute": "^1.0.0"
            },
            "engines": {
                "node": "*"
            },
            "funding": {
                "url": "https://github.com/sponsors/isaacs"
            }
        },
        "node_modules/glob-parent": {
            "version": "6.0.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "is-glob": "^4.0.3"
            },
            "engines": {
                "node": ">=10.13.0"
            }
        },
        "node_modules/globals": {
            "version": "13.15.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "type-fest": "^0.20.2"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/globby": {
            "version": "11.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "array-union": "^2.1.0",
                "dir-glob": "^3.0.1",
                "fast-glob": "^3.2.9",
                "ignore": "^5.2.0",
                "merge2": "^1.4.1",
                "slash": "^3.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/graceful-fs": {
            "version": "4.2.9",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/has": {
            "version": "1.0.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "function-bind": "^1.1.1"
            },
            "engines": {
                "node": ">= 0.4.0"
            }
        },
        "node_modules/has-flag": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/html-escaper": {
            "version": "2.0.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/human-signals": {
            "version": "2.1.0",
            "dev": true,
            "license": "Apache-2.0",
            "engines": {
                "node": ">=10.17.0"
            }
        },
        "node_modules/ieee754": {
            "version": "1.2.1",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "BSD-3-Clause"
        },
        "node_modules/ignore": {
            "version": "5.2.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 4"
            }
        },
        "node_modules/import-fresh": {
            "version": "3.3.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "parent-module": "^1.0.0",
                "resolve-from": "^4.0.0"
            },
            "engines": {
                "node": ">=6"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/import-local": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "pkg-dir": "^4.2.0",
                "resolve-cwd": "^3.0.0"
            },
            "bin": {
                "import-local-fixture": "fixtures/cli.js"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/imurmurhash": {
            "version": "0.1.4",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.8.19"
            }
        },
        "node_modules/inflight": {
            "version": "1.0.6",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "once": "^1.3.0",
                "wrappy": "1"
            }
        },
        "node_modules/inherits": {
            "version": "2.0.4",
            "license": "ISC"
        },
        "node_modules/is-arrayish": {
            "version": "0.2.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/is-core-module": {
            "version": "2.9.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has": "^1.0.3"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/is-extglob": {
            "version": "2.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/is-fullwidth-code-point": {
            "version": "3.0.0",
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/is-generator-fn": {
            "version": "2.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/is-glob": {
            "version": "4.0.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-extglob": "^2.1.1"
            },
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/is-number": {
            "version": "7.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.12.0"
            }
        },
        "node_modules/is-stream": {
            "version": "2.0.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/isexe": {
            "version": "2.0.0",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/isomorphic-ws": {
            "version": "4.0.1",
            "license": "MIT",
            "peerDependencies": {
                "ws": "*"
            }
        },
        "node_modules/istanbul-lib-coverage": {
            "version": "3.2.0",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/istanbul-lib-instrument": {
            "version": "5.2.0",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "@babel/core": "^7.12.3",
                "@babel/parser": "^7.14.7",
                "@istanbuljs/schema": "^0.1.2",
                "istanbul-lib-coverage": "^3.2.0",
                "semver": "^6.3.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/istanbul-lib-instrument/node_modules/semver": {
            "version": "6.3.0",
            "dev": true,
            "license": "ISC",
            "bin": {
                "semver": "bin/semver.js"
            }
        },
        "node_modules/istanbul-lib-report": {
            "version": "3.0.0",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "istanbul-lib-coverage": "^3.0.0",
                "make-dir": "^3.0.0",
                "supports-color": "^7.1.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/istanbul-lib-source-maps": {
            "version": "4.0.1",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "debug": "^4.1.1",
                "istanbul-lib-coverage": "^3.0.0",
                "source-map": "^0.6.1"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/istanbul-reports": {
            "version": "3.1.5",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "html-escaper": "^2.0.0",
                "istanbul-lib-report": "^3.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/jayson": {
            "version": "3.6.6",
            "license": "MIT",
            "dependencies": {
                "@types/connect": "^3.4.33",
                "@types/express-serve-static-core": "^4.17.9",
                "@types/lodash": "^4.14.159",
                "@types/node": "^12.12.54",
                "@types/ws": "^7.4.4",
                "commander": "^2.20.3",
                "delay": "^5.0.0",
                "es6-promisify": "^5.0.0",
                "eyes": "^0.1.8",
                "isomorphic-ws": "^4.0.1",
                "json-stringify-safe": "^5.0.1",
                "JSONStream": "^1.3.5",
                "lodash": "^4.17.20",
                "uuid": "^8.3.2",
                "ws": "^7.4.5"
            },
            "bin": {
                "jayson": "bin/jayson.js"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/jayson/node_modules/@types/node": {
            "version": "12.20.45",
            "license": "MIT"
        },
        "node_modules/jest": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/core": "^28.1.3",
                "@jest/types": "^28.1.3",
                "import-local": "^3.0.2",
                "jest-cli": "^28.1.3"
            },
            "bin": {
                "jest": "bin/jest.js"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
                "node-notifier": {
                    "optional": true
                }
            }
        },
        "node_modules/jest-changed-files": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "execa": "^5.0.0",
                "p-limit": "^3.1.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-changed-files/node_modules/p-limit": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "yocto-queue": "^0.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/jest-circus": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/environment": "^28.1.3",
                "@jest/expect": "^28.1.3",
                "@jest/test-result": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "chalk": "^4.0.0",
                "co": "^4.6.0",
                "dedent": "^0.7.0",
                "is-generator-fn": "^2.0.0",
                "jest-each": "^28.1.3",
                "jest-matcher-utils": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-runtime": "^28.1.3",
                "jest-snapshot": "^28.1.3",
                "jest-util": "^28.1.3",
                "p-limit": "^3.1.0",
                "pretty-format": "^28.1.3",
                "slash": "^3.0.0",
                "stack-utils": "^2.0.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-circus/node_modules/p-limit": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "yocto-queue": "^0.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/jest-cli": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/core": "^28.1.3",
                "@jest/test-result": "^28.1.3",
                "@jest/types": "^28.1.3",
                "chalk": "^4.0.0",
                "exit": "^0.1.2",
                "graceful-fs": "^4.2.9",
                "import-local": "^3.0.2",
                "jest-config": "^28.1.3",
                "jest-util": "^28.1.3",
                "jest-validate": "^28.1.3",
                "prompts": "^2.0.1",
                "yargs": "^17.3.1"
            },
            "bin": {
                "jest": "bin/jest.js"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
                "node-notifier": {
                    "optional": true
                }
            }
        },
        "node_modules/jest-config": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/core": "^7.11.6",
                "@jest/test-sequencer": "^28.1.3",
                "@jest/types": "^28.1.3",
                "babel-jest": "^28.1.3",
                "chalk": "^4.0.0",
                "ci-info": "^3.2.0",
                "deepmerge": "^4.2.2",
                "glob": "^7.1.3",
                "graceful-fs": "^4.2.9",
                "jest-circus": "^28.1.3",
                "jest-environment-node": "^28.1.3",
                "jest-get-type": "^28.0.2",
                "jest-regex-util": "^28.0.2",
                "jest-resolve": "^28.1.3",
                "jest-runner": "^28.1.3",
                "jest-util": "^28.1.3",
                "jest-validate": "^28.1.3",
                "micromatch": "^4.0.4",
                "parse-json": "^5.2.0",
                "pretty-format": "^28.1.3",
                "slash": "^3.0.0",
                "strip-json-comments": "^3.1.1"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "@types/node": "*",
                "ts-node": ">=9.0.0"
            },
            "peerDependenciesMeta": {
                "@types/node": {
                    "optional": true
                },
                "ts-node": {
                    "optional": true
                }
            }
        },
        "node_modules/jest-diff": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "chalk": "^4.0.0",
                "diff-sequences": "^28.1.1",
                "jest-get-type": "^28.0.2",
                "pretty-format": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-docblock": {
            "version": "28.1.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "detect-newline": "^3.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-each": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "chalk": "^4.0.0",
                "jest-get-type": "^28.0.2",
                "jest-util": "^28.1.3",
                "pretty-format": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-environment-node": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/environment": "^28.1.3",
                "@jest/fake-timers": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "jest-mock": "^28.1.3",
                "jest-util": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-get-type": {
            "version": "28.0.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-haste-map": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "@types/graceful-fs": "^4.1.3",
                "@types/node": "*",
                "anymatch": "^3.0.3",
                "fb-watchman": "^2.0.0",
                "graceful-fs": "^4.2.9",
                "jest-regex-util": "^28.0.2",
                "jest-util": "^28.1.3",
                "jest-worker": "^28.1.3",
                "micromatch": "^4.0.4",
                "walker": "^1.0.8"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "optionalDependencies": {
                "fsevents": "^2.3.2"
            }
        },
        "node_modules/jest-leak-detector": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "jest-get-type": "^28.0.2",
                "pretty-format": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-matcher-utils": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "chalk": "^4.0.0",
                "jest-diff": "^28.1.3",
                "jest-get-type": "^28.0.2",
                "pretty-format": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-message-util": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.12.13",
                "@jest/types": "^28.1.3",
                "@types/stack-utils": "^2.0.0",
                "chalk": "^4.0.0",
                "graceful-fs": "^4.2.9",
                "micromatch": "^4.0.4",
                "pretty-format": "^28.1.3",
                "slash": "^3.0.0",
                "stack-utils": "^2.0.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-mock": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "@types/node": "*"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-pnp-resolver": {
            "version": "1.2.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            },
            "peerDependencies": {
                "jest-resolve": "*"
            },
            "peerDependenciesMeta": {
                "jest-resolve": {
                    "optional": true
                }
            }
        },
        "node_modules/jest-regex-util": {
            "version": "28.0.2",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-resolve": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "chalk": "^4.0.0",
                "graceful-fs": "^4.2.9",
                "jest-haste-map": "^28.1.3",
                "jest-pnp-resolver": "^1.2.2",
                "jest-util": "^28.1.3",
                "jest-validate": "^28.1.3",
                "resolve": "^1.20.0",
                "resolve.exports": "^1.1.0",
                "slash": "^3.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-resolve-dependencies": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "jest-regex-util": "^28.0.2",
                "jest-snapshot": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-runner": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/console": "^28.1.3",
                "@jest/environment": "^28.1.3",
                "@jest/test-result": "^28.1.3",
                "@jest/transform": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "chalk": "^4.0.0",
                "emittery": "^0.10.2",
                "graceful-fs": "^4.2.9",
                "jest-docblock": "^28.1.1",
                "jest-environment-node": "^28.1.3",
                "jest-haste-map": "^28.1.3",
                "jest-leak-detector": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-resolve": "^28.1.3",
                "jest-runtime": "^28.1.3",
                "jest-util": "^28.1.3",
                "jest-watcher": "^28.1.3",
                "jest-worker": "^28.1.3",
                "p-limit": "^3.1.0",
                "source-map-support": "0.5.13"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-runner/node_modules/p-limit": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "yocto-queue": "^0.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/jest-runtime": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/environment": "^28.1.3",
                "@jest/fake-timers": "^28.1.3",
                "@jest/globals": "^28.1.3",
                "@jest/source-map": "^28.1.2",
                "@jest/test-result": "^28.1.3",
                "@jest/transform": "^28.1.3",
                "@jest/types": "^28.1.3",
                "chalk": "^4.0.0",
                "cjs-module-lexer": "^1.0.0",
                "collect-v8-coverage": "^1.0.0",
                "execa": "^5.0.0",
                "glob": "^7.1.3",
                "graceful-fs": "^4.2.9",
                "jest-haste-map": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-mock": "^28.1.3",
                "jest-regex-util": "^28.0.2",
                "jest-resolve": "^28.1.3",
                "jest-snapshot": "^28.1.3",
                "jest-util": "^28.1.3",
                "slash": "^3.0.0",
                "strip-bom": "^4.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-snapshot": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/core": "^7.11.6",
                "@babel/generator": "^7.7.2",
                "@babel/plugin-syntax-typescript": "^7.7.2",
                "@babel/traverse": "^7.7.2",
                "@babel/types": "^7.3.3",
                "@jest/expect-utils": "^28.1.3",
                "@jest/transform": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/babel__traverse": "^7.0.6",
                "@types/prettier": "^2.1.5",
                "babel-preset-current-node-syntax": "^1.0.0",
                "chalk": "^4.0.0",
                "expect": "^28.1.3",
                "graceful-fs": "^4.2.9",
                "jest-diff": "^28.1.3",
                "jest-get-type": "^28.0.2",
                "jest-haste-map": "^28.1.3",
                "jest-matcher-utils": "^28.1.3",
                "jest-message-util": "^28.1.3",
                "jest-util": "^28.1.3",
                "natural-compare": "^1.4.0",
                "pretty-format": "^28.1.3",
                "semver": "^7.3.5"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-util": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "chalk": "^4.0.0",
                "ci-info": "^3.2.0",
                "graceful-fs": "^4.2.9",
                "picomatch": "^2.2.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-validate": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/types": "^28.1.3",
                "camelcase": "^6.2.0",
                "chalk": "^4.0.0",
                "jest-get-type": "^28.0.2",
                "leven": "^3.1.0",
                "pretty-format": "^28.1.3"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-validate/node_modules/camelcase": {
            "version": "6.3.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/jest-watcher": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/test-result": "^28.1.3",
                "@jest/types": "^28.1.3",
                "@types/node": "*",
                "ansi-escapes": "^4.2.1",
                "chalk": "^4.0.0",
                "emittery": "^0.10.2",
                "jest-util": "^28.1.3",
                "string-length": "^4.0.1"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-worker": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/node": "*",
                "merge-stream": "^2.0.0",
                "supports-color": "^8.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/jest-worker/node_modules/supports-color": {
            "version": "8.1.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^4.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/supports-color?sponsor=1"
            }
        },
        "node_modules/js-sha256": {
            "version": "0.9.0",
            "license": "MIT"
        },
        "node_modules/js-tokens": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/js-yaml": {
            "version": "4.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "argparse": "^2.0.1"
            },
            "bin": {
                "js-yaml": "bin/js-yaml.js"
            }
        },
        "node_modules/jsesc": {
            "version": "2.5.2",
            "dev": true,
            "license": "MIT",
            "bin": {
                "jsesc": "bin/jsesc"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/json-parse-even-better-errors": {
            "version": "2.3.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/json-schema-traverse": {
            "version": "0.4.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/json-stable-stringify-without-jsonify": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/json-stringify-safe": {
            "version": "5.0.1",
            "license": "ISC"
        },
        "node_modules/json5": {
            "version": "2.2.1",
            "dev": true,
            "license": "MIT",
            "bin": {
                "json5": "lib/cli.js"
            },
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/jsonparse": {
            "version": "1.3.1",
            "engines": [
                "node >= 0.2.0"
            ],
            "license": "MIT"
        },
        "node_modules/JSONStream": {
            "version": "1.3.5",
            "license": "(MIT OR Apache-2.0)",
            "dependencies": {
                "jsonparse": "^1.2.0",
                "through": ">=2.2.7 <3"
            },
            "bin": {
                "JSONStream": "bin.js"
            },
            "engines": {
                "node": "*"
            }
        },
        "node_modules/kleur": {
            "version": "3.0.3",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/leven": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/lines-and-columns": {
            "version": "1.2.4",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/locate-path": {
            "version": "5.0.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-locate": "^4.1.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/lodash": {
            "version": "4.17.21",
            "license": "MIT"
        },
        "node_modules/lodash.memoize": {
            "version": "4.1.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/lodash.merge": {
            "version": "4.6.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/lower-case": {
            "version": "2.0.2",
            "license": "MIT",
            "dependencies": {
                "tslib": "^2.0.3"
            }
        },
        "node_modules/make-dir": {
            "version": "3.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "semver": "^6.0.0"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/make-dir/node_modules/semver": {
            "version": "6.3.0",
            "dev": true,
            "license": "ISC",
            "bin": {
                "semver": "bin/semver.js"
            }
        },
        "node_modules/make-error": {
            "version": "1.3.6",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/makeerror": {
            "version": "1.0.12",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "tmpl": "1.0.5"
            }
        },
        "node_modules/merge-stream": {
            "version": "2.0.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/merge2": {
            "version": "1.4.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/micromatch": {
            "version": "4.0.5",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "braces": "^3.0.2",
                "picomatch": "^2.3.1"
            },
            "engines": {
                "node": ">=8.6"
            }
        },
        "node_modules/mimic-fn": {
            "version": "2.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/minimatch": {
            "version": "3.1.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "brace-expansion": "^1.1.7"
            },
            "engines": {
                "node": "*"
            }
        },
        "node_modules/ms": {
            "version": "2.1.2",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/mustache": {
            "version": "4.2.0",
            "license": "MIT",
            "bin": {
                "mustache": "bin/mustache"
            }
        },
        "node_modules/natural-compare": {
            "version": "1.4.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/near-api-js": {
            "version": "1.1.0",
            "license": "(MIT AND Apache-2.0)",
            "dependencies": {
                "bn.js": "5.2.1",
                "borsh": "^0.7.0",
                "bs58": "^4.0.0",
                "depd": "^2.0.0",
                "error-polyfill": "^0.1.3",
                "http-errors": "^1.7.2",
                "js-sha256": "^0.9.0",
                "mustache": "^4.0.0",
                "node-fetch": "^2.6.1",
                "text-encoding-utf-8": "^1.0.2",
                "tweetnacl": "^1.0.1"
            }
        },
        "node_modules/near-api-js/node_modules/http-errors": {
            "version": "1.8.1",
            "license": "MIT",
            "dependencies": {
                "depd": "~1.1.2",
                "inherits": "2.0.4",
                "setprototypeof": "1.2.0",
                "statuses": ">= 1.5.0 < 2",
                "toidentifier": "1.0.1"
            },
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/near-api-js/node_modules/http-errors/node_modules/depd": {
            "version": "1.1.2",
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/near-api-js/node_modules/statuses": {
            "version": "1.5.0",
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/no-case": {
            "version": "3.0.4",
            "license": "MIT",
            "dependencies": {
                "lower-case": "^2.0.2",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/node-fetch": {
            "version": "2.6.7",
            "license": "MIT",
            "dependencies": {
                "whatwg-url": "^5.0.0"
            },
            "engines": {
                "node": "4.x || >=6.0.0"
            },
            "peerDependencies": {
                "encoding": "^0.1.0"
            },
            "peerDependenciesMeta": {
                "encoding": {
                    "optional": true
                }
            }
        },
        "node_modules/node-gyp-build": {
            "version": "4.3.0",
            "license": "MIT",
            "optional": true,
            "bin": {
                "node-gyp-build": "bin.js",
                "node-gyp-build-optional": "optional.js",
                "node-gyp-build-test": "build-test.js"
            }
        },
        "node_modules/node-int64": {
            "version": "0.4.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/node-releases": {
            "version": "2.0.4",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/normalize-path": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/npm-run-path": {
            "version": "4.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "path-key": "^3.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/o3": {
            "version": "1.0.3",
            "license": "MIT",
            "dependencies": {
                "capability": "^0.2.5"
            }
        },
        "node_modules/once": {
            "version": "1.4.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "wrappy": "1"
            }
        },
        "node_modules/onetime": {
            "version": "5.1.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "mimic-fn": "^2.1.0"
            },
            "engines": {
                "node": ">=6"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/p-limit": {
            "version": "2.3.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-try": "^2.0.0"
            },
            "engines": {
                "node": ">=6"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/p-locate": {
            "version": "4.1.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-limit": "^2.2.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/p-try": {
            "version": "2.2.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/pako": {
            "version": "2.0.4",
            "license": "(MIT AND Zlib)"
        },
        "node_modules/parent-module": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "callsites": "^3.0.0"
            },
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/parse-json": {
            "version": "5.2.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.0.0",
                "error-ex": "^1.3.1",
                "json-parse-even-better-errors": "^2.3.0",
                "lines-and-columns": "^1.1.6"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/path-exists": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/path-is-absolute": {
            "version": "1.0.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/path-key": {
            "version": "3.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/path-parse": {
            "version": "1.0.7",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/path-type": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/picocolors": {
            "version": "1.0.0",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/picomatch": {
            "version": "2.3.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8.6"
            },
            "funding": {
                "url": "https://github.com/sponsors/jonschlinkert"
            }
        },
        "node_modules/pirates": {
            "version": "4.0.5",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/pkg-dir": {
            "version": "4.2.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "find-up": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/prettier": {
            "version": "2.6.2",
            "dev": true,
            "license": "MIT",
            "bin": {
                "prettier": "bin-prettier.js"
            },
            "engines": {
                "node": ">=10.13.0"
            },
            "funding": {
                "url": "https://github.com/prettier/prettier?sponsor=1"
            }
        },
        "node_modules/pretty-format": {
            "version": "28.1.3",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jest/schemas": "^28.1.3",
                "ansi-regex": "^5.0.1",
                "ansi-styles": "^5.0.0",
                "react-is": "^18.0.0"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            }
        },
        "node_modules/pretty-format/node_modules/ansi-styles": {
            "version": "5.2.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/ansi-styles?sponsor=1"
            }
        },
        "node_modules/prompts": {
            "version": "2.4.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "kleur": "^3.0.3",
                "sisteransi": "^1.0.5"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/punycode": {
            "version": "2.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/queue-microtask": {
            "version": "1.2.3",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/react-is": {
            "version": "18.2.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/regenerator-runtime": {
            "version": "0.13.9",
            "license": "MIT"
        },
        "node_modules/regexpp": {
            "version": "3.2.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/mysticatea"
            }
        },
        "node_modules/require-directory": {
            "version": "2.1.1",
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/resolve": {
            "version": "1.22.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-core-module": "^2.9.0",
                "path-parse": "^1.0.7",
                "supports-preserve-symlinks-flag": "^1.0.0"
            },
            "bin": {
                "resolve": "bin/resolve"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/resolve-cwd": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "resolve-from": "^5.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/resolve-cwd/node_modules/resolve-from": {
            "version": "5.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/resolve-from": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/resolve.exports": {
            "version": "1.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/reusify": {
            "version": "1.0.4",
            "dev": true,
            "license": "MIT",
            "engines": {
                "iojs": ">=1.0.0",
                "node": ">=0.10.0"
            }
        },
        "node_modules/rimraf": {
            "version": "3.0.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "glob": "^7.1.3"
            },
            "bin": {
                "rimraf": "bin.js"
            },
            "funding": {
                "url": "https://github.com/sponsors/isaacs"
            }
        },
        "node_modules/rpc-websockets": {
            "version": "7.5.0",
            "license": "LGPL-3.0-only",
            "dependencies": {
                "@babel/runtime": "^7.17.2",
                "eventemitter3": "^4.0.7",
                "uuid": "^8.3.2",
                "ws": "^8.5.0"
            },
            "funding": {
                "type": "paypal",
                "url": "https://paypal.me/kozjak"
            },
            "optionalDependencies": {
                "bufferutil": "^4.0.1",
                "utf-8-validate": "^5.0.2"
            }
        },
        "node_modules/rpc-websockets/node_modules/ws": {
            "version": "8.8.0",
            "license": "MIT",
            "engines": {
                "node": ">=10.0.0"
            },
            "peerDependencies": {
                "bufferutil": "^4.0.1",
                "utf-8-validate": "^5.0.2"
            },
            "peerDependenciesMeta": {
                "bufferutil": {
                    "optional": true
                },
                "utf-8-validate": {
                    "optional": true
                }
            }
        },
        "node_modules/run-parallel": {
            "version": "1.2.0",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "queue-microtask": "^1.2.2"
            }
        },
        "node_modules/safe-buffer": {
            "version": "5.2.1",
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/semver": {
            "version": "7.3.7",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "lru-cache": "^6.0.0"
            },
            "bin": {
                "semver": "bin/semver.js"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/semver/node_modules/lru-cache": {
            "version": "6.0.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "yallist": "^4.0.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/semver/node_modules/yallist": {
            "version": "4.0.0",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/setprototypeof": {
            "version": "1.2.0",
            "license": "ISC"
        },
        "node_modules/shebang-command": {
            "version": "2.0.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "shebang-regex": "^3.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/shebang-regex": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/signal-exit": {
            "version": "3.0.7",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/sisteransi": {
            "version": "1.0.5",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/slash": {
            "version": "3.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/snake-case": {
            "version": "3.0.4",
            "license": "MIT",
            "dependencies": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/source-map": {
            "version": "0.6.1",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/source-map-support": {
            "version": "0.5.13",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "buffer-from": "^1.0.0",
                "source-map": "^0.6.0"
            }
        },
        "node_modules/sprintf-js": {
            "version": "1.0.3",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/stack-utils": {
            "version": "2.0.5",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "escape-string-regexp": "^2.0.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/stack-utils/node_modules/escape-string-regexp": {
            "version": "2.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/string-length": {
            "version": "4.0.2",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "char-regex": "^1.0.2",
                "strip-ansi": "^6.0.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/string-width": {
            "version": "4.2.3",
            "license": "MIT",
            "dependencies": {
                "emoji-regex": "^8.0.0",
                "is-fullwidth-code-point": "^3.0.0",
                "strip-ansi": "^6.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/strip-ansi": {
            "version": "6.0.1",
            "license": "MIT",
            "dependencies": {
                "ansi-regex": "^5.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/strip-bom": {
            "version": "4.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/strip-final-newline": {
            "version": "2.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/strip-json-comments": {
            "version": "3.1.1",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/superstruct": {
            "version": "0.14.2",
            "license": "MIT"
        },
        "node_modules/supports-color": {
            "version": "7.2.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/supports-hyperlinks": {
            "version": "2.2.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^4.0.0",
                "supports-color": "^7.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/supports-preserve-symlinks-flag": {
            "version": "1.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.4"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/terminal-link": {
            "version": "2.1.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-escapes": "^4.2.1",
                "supports-hyperlinks": "^2.0.0"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/test-exclude": {
            "version": "6.0.0",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "@istanbuljs/schema": "^0.1.2",
                "glob": "^7.1.4",
                "minimatch": "^3.0.4"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/text-encoding-utf-8": {
            "version": "1.0.2"
        },
        "node_modules/text-table": {
            "version": "0.2.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/through": {
            "version": "2.3.8",
            "license": "MIT"
        },
        "node_modules/tmpl": {
            "version": "1.0.5",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/to-fast-properties": {
            "version": "2.0.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/to-regex-range": {
            "version": "5.0.1",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-number": "^7.0.0"
            },
            "engines": {
                "node": ">=8.0"
            }
        },
        "node_modules/toformat": {
            "version": "2.0.0",
            "license": "MIT"
        },
        "node_modules/toidentifier": {
            "version": "1.0.1",
            "license": "MIT",
            "engines": {
                "node": ">=0.6"
            }
        },
        "node_modules/toml": {
            "version": "3.0.0",
            "license": "MIT"
        },
        "node_modules/tr46": {
            "version": "0.0.3",
            "license": "MIT"
        },
        "node_modules/traverse-chain": {
            "version": "0.1.0",
            "license": "MIT"
        },
        "node_modules/ts-jest": {
            "version": "28.0.7",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "bs-logger": "0.x",
                "fast-json-stable-stringify": "2.x",
                "jest-util": "^28.0.0",
                "json5": "^2.2.1",
                "lodash.memoize": "4.x",
                "make-error": "1.x",
                "semver": "7.x",
                "yargs-parser": "^21.0.1"
            },
            "bin": {
                "ts-jest": "cli.js"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"
            },
            "peerDependencies": {
                "@babel/core": ">=7.0.0-beta.0 <8",
                "@jest/types": "^28.0.0",
                "babel-jest": "^28.0.0",
                "jest": "^28.0.0",
                "typescript": ">=4.3"
            },
            "peerDependenciesMeta": {
                "@babel/core": {
                    "optional": true
                },
                "@jest/types": {
                    "optional": true
                },
                "babel-jest": {
                    "optional": true
                },
                "esbuild": {
                    "optional": true
                }
            }
        },
        "node_modules/ts-node": {
            "version": "10.8.0",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true,
            "dependencies": {
                "@cspotcode/source-map-support": "^0.8.0",
                "@tsconfig/node10": "^1.0.7",
                "@tsconfig/node12": "^1.0.7",
                "@tsconfig/node14": "^1.0.0",
                "@tsconfig/node16": "^1.0.2",
                "acorn": "^8.4.1",
                "acorn-walk": "^8.1.1",
                "arg": "^4.1.0",
                "create-require": "^1.1.0",
                "diff": "^4.0.1",
                "make-error": "^1.1.1",
                "v8-compile-cache-lib": "^3.0.1",
                "yn": "3.1.1"
            },
            "bin": {
                "ts-node": "dist/bin.js",
                "ts-node-cwd": "dist/bin-cwd.js",
                "ts-node-esm": "dist/bin-esm.js",
                "ts-node-script": "dist/bin-script.js",
                "ts-node-transpile-only": "dist/bin-transpile.js",
                "ts-script": "dist/bin-script-deprecated.js"
            },
            "peerDependencies": {
                "@swc/core": ">=1.2.50",
                "@swc/wasm": ">=1.2.50",
                "@types/node": "*",
                "typescript": ">=2.7"
            },
            "peerDependenciesMeta": {
                "@swc/core": {
                    "optional": true
                },
                "@swc/wasm": {
                    "optional": true
                }
            }
        },
        "node_modules/tslib": {
            "version": "2.3.1",
            "license": "0BSD"
        },
        "node_modules/tsutils": {
            "version": "3.21.0",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "tslib": "^1.8.1"
            },
            "engines": {
                "node": ">= 6"
            },
            "peerDependencies": {
                "typescript": ">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta"
            }
        },
        "node_modules/tsutils/node_modules/tslib": {
            "version": "1.14.1",
            "dev": true,
            "license": "0BSD"
        },
        "node_modules/tweetnacl": {
            "version": "1.0.3",
            "license": "Unlicense"
        },
        "node_modules/type-detect": {
            "version": "4.0.8",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/type-fest": {
            "version": "0.20.2",
            "dev": true,
            "license": "(MIT OR CC0-1.0)",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/typescript": {
            "version": "4.7.3",
            "dev": true,
            "license": "Apache-2.0",
            "bin": {
                "tsc": "bin/tsc",
                "tsserver": "bin/tsserver"
            },
            "engines": {
                "node": ">=4.2.0"
            }
        },
        "node_modules/u3": {
            "version": "0.1.1",
            "license": "MIT"
        },
        "node_modules/uri-js": {
            "version": "4.4.1",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "punycode": "^2.1.0"
            }
        },
        "node_modules/utf-8-validate": {
            "version": "5.0.8",
            "hasInstallScript": true,
            "license": "MIT",
            "optional": true,
            "dependencies": {
                "node-gyp-build": "^4.3.0"
            },
            "engines": {
                "node": ">=6.14.2"
            }
        },
        "node_modules/uuid": {
            "version": "8.3.2",
            "license": "MIT",
            "bin": {
                "uuid": "dist/bin/uuid"
            }
        },
        "node_modules/v8-compile-cache": {
            "version": "2.3.0",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/v8-compile-cache-lib": {
            "version": "3.0.1",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true
        },
        "node_modules/v8-to-istanbul": {
            "version": "9.0.1",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "@jridgewell/trace-mapping": "^0.3.12",
                "@types/istanbul-lib-coverage": "^2.0.1",
                "convert-source-map": "^1.6.0"
            },
            "engines": {
                "node": ">=10.12.0"
            }
        },
        "node_modules/walker": {
            "version": "1.0.8",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "makeerror": "1.0.12"
            }
        },
        "node_modules/webidl-conversions": {
            "version": "3.0.1",
            "license": "BSD-2-Clause"
        },
        "node_modules/whatwg-url": {
            "version": "5.0.0",
            "license": "MIT",
            "dependencies": {
                "tr46": "~0.0.3",
                "webidl-conversions": "^3.0.0"
            }
        },
        "node_modules/which": {
            "version": "2.0.2",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "isexe": "^2.0.0"
            },
            "bin": {
                "node-which": "bin/node-which"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/word-wrap": {
            "version": "1.2.3",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/wrap-ansi": {
            "version": "7.0.0",
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^4.0.0",
                "string-width": "^4.1.0",
                "strip-ansi": "^6.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
            }
        },
        "node_modules/wrappy": {
            "version": "1.0.2",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/write-file-atomic": {
            "version": "4.0.1",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "imurmurhash": "^0.1.4",
                "signal-exit": "^3.0.7"
            },
            "engines": {
                "node": "^12.13.0 || ^14.15.0 || >=16"
            }
        },
        "node_modules/ws": {
            "version": "7.5.7",
            "license": "MIT",
            "engines": {
                "node": ">=8.3.0"
            },
            "peerDependencies": {
                "bufferutil": "^4.0.1",
                "utf-8-validate": "^5.0.2"
            },
            "peerDependenciesMeta": {
                "bufferutil": {
                    "optional": true
                },
                "utf-8-validate": {
                    "optional": true
                }
            }
        },
        "node_modules/y18n": {
            "version": "5.0.8",
            "license": "ISC",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yargs": {
            "version": "17.3.1",
            "license": "MIT",
            "dependencies": {
                "cliui": "^7.0.2",
                "escalade": "^3.1.1",
                "get-caller-file": "^2.0.5",
                "require-directory": "^2.1.1",
                "string-width": "^4.2.3",
                "y18n": "^5.0.5",
                "yargs-parser": "^21.0.0"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/yargs-parser": {
            "version": "21.0.1",
            "license": "ISC",
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/yn": {
            "version": "3.1.1",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "peer": true,
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/yocto-queue": {
            "version": "0.1.0",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        }
    }
}

'''
'''--- package.json ---
{
    "name": "0xhipo-cell-sdk-release",
    "version": "2.4.2",
    "description": "",
    "main": "dist/index.js",
    "scripts": {
        "build": "tsc",
        "format": "prettier --write \"src/**/*.ts\" \"src/**/*.js\"",
        "lint": "eslint . --ext .ts",
        "test": "jest --config jestconfig.json",
        "prepare": "npm run build",
        "prepublishOnly": "npm test && npm run lint",
        "preversion": "npm run lint",
        "version": "npm run format && git add -A src",
        "postversion": "git push && git push --tags"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "homepage": "https://github.com/0xhipo/0xhipo-cell-sdk-release",
    "bugs": {
        "url": "https://github.com/0xhipo/0xhipo-cell-sdk-release/issues"
    },
    "dependencies": {
        "@blockworks-foundation/mango-client": "^3.6.11",
        "@project-serum/serum": "^0.13.65",
        "@solana/spl-token": "^0.3.5",
        "@solana/web3.js": "^1.47.3",
        "borsh": "^0.7.0",
        "buffer-layout": "^1.2.2",
        "decimal.js": "^10.4.2",
        "near-api-js": "^1.1.0"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.0",
        "@types/bs58": "^4.0.1",
        "@types/jest": "^28.1.6",
        "@typescript-eslint/eslint-plugin": "^5.27.1",
        "@typescript-eslint/parser": "^5.27.1",
        "eslint": "^8.17.0",
        "jest": "^28.1.3",
        "prettier": "^2.6.2",
        "ts-jest": "^28.0.7",
        "typescript": "^4.7.3"
    },
    "files": [
        "dist/**/*"
    ]
}

'''
'''--- script/getSerumMarketConfig.ts ---
import { PublicKey } from '@solana/web3.js';
import { solanaConnection } from '../example/constant.example';
import { MARKET_STATE_LAYOUT_V3 } from '@project-serum/serum';
import { SERUM_PROGRAM_ID } from '../src';

async function getSerumMarketConfig() {
    const marketKey = new PublicKey('8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6');
    const accountInfo = await solanaConnection.getAccountInfo(marketKey);
    if (!accountInfo) {
        throw `Serum market account not found`;
    }

    const market = MARKET_STATE_LAYOUT_V3.decode(accountInfo.data);
    const vaultSigner = await PublicKey.createProgramAddress(
        [marketKey.toBuffer(), market['vaultSignerNonce'].toArrayLike(Buffer, 'le', 8)],
        SERUM_PROGRAM_ID,
    );
    console.log(market);
    console.log(`=`.repeat(100));
    console.log(`base lot size: ${market['baseLotSize'].toString()}`);
    console.log(`quote lot size: ${market['quoteLotSize'].toString()}`);
    console.log(`bids: ${market['bids'].toString()}`);
    console.log(`asks: ${market['asks'].toString()}`);
    console.log(`base mint: ${market['baseMint'].toString()}`);
    console.log(`quote mint: ${market['quoteMint'].toString()}`);
    console.log(`base vault: ${market['baseVault'].toString()}`);
    console.log(`quote vault: ${market['quoteVault'].toString()}`);
    console.log(`event queue: ${market['eventQueue'].toString()}`);
    console.log(`request queue: ${market['requestQueue'].toString()}`);
    console.log(`authority: ${market['authority'].toString()}`);
    console.log(`vault signer nonce: ${market['vaultSignerNonce'].toString()}`);
    console.log(`vault signer: ${vaultSigner.toString()}`);
}

getSerumMarketConfig();

'''
'''--- script/upgradeBotInfo.ts ---
import { getBotKeyBySeed, sendSolanaPayload, TransactionPayload, upgradeBotInfoIx } from '../src';
import base58 from 'bs58';
import { solanaConnection, solanaEnv, solanaWallet } from '../example/constant.example';

async function upgradeBotInfo() {
    const botSeeds = ['9SzK6BoPVpCfkKWpbYiaZGoPtB38guT9qXGVhdPUbNyC'];
    for (const botSeedStr of botSeeds) {
        const botSeed = base58.decode(botSeedStr);
        const botKey = await getBotKeyBySeed(botSeed, solanaEnv.programId);
        const payload: TransactionPayload = {
            instructions: [
                upgradeBotInfoIx({
                    botSeed,
                    botKey,
                    payerKey: solanaWallet.publicKey,
                    programId: solanaEnv.programId,
                }),
            ],
            signers: [],
        };
        await sendSolanaPayload(solanaConnection, solanaWallet, payload, false);
    }
}
upgradeBotInfo();

'''
'''--- src/Bot/index.ts ---
export * from './solana';
export * from './near';

'''
'''--- src/Bot/near/RefBot.ts ---
import {
    BotInfo,
    CancelNearOrderParams,
    GetNearBotInfoParams,
    GetNearOpenOrdersParams,
    NearTokenConfig,
    NearTransactionPayload,
    OpenOrder,
    OrderSide,
    PlaceNearOrderParams,
    RefPoolConfig,
} from '../../type';
import {
    getMarketPrice,
    getNearTokenBalance,
    getNearTokenConfigBySymbol,
    getRefPoolConfig,
    nativeToUi,
    nearViewFunction,
    refPointToPrice,
    refPriceToPoint,
    uiToNative,
} from '../../util';
import { Action, functionCall } from 'near-api-js/lib/transaction';
import { DEFAULT_GAS, REF_CONTRACT_ID, ZERO_BN } from '../../constant';
import Decimal from 'decimal.js';

export class RefBot {
    /*
     * 1. create bot (need deposit NEAR to deploy bot contract, see BOT_CONTRACT_STORAGE_NEAR)
     * 2. token Y storage deposit & deposit to bot (if NEAR register wNEAR and deposit NEAR)
     * 3. token X storage deposit (if NEAR register wNEAR)
     * 4. ref storage deposit
     * returns [botIndex, transactionPayloads]
     */
    // static async create(params: CreateNearBotParams): Promise<[number, NearTransactionPayload[]]> {
    //     const payloads: NearTransactionPayload[] = [];
    //     const botIndex = await NearBot.loadAll(params.contractId, params.networkId).then((res) => res.length);
    //     const botContractId = `${botIndex}.${params.contractId}`;
    //     console.log(`Create bot ${botContractId}`);
    //
    //     const poolConfig = getRefPoolConfig(params.market) as RefPoolConfig;
    //     const tokenXConfig = getNearTokenConfigBySymbol(poolConfig.tokenXSymbol) as NearTokenConfig;
    //     const tokenYConfig = getNearTokenConfigBySymbol(poolConfig.tokenYSymbol) as NearTokenConfig;
    //     const wNEARTokenConfig = getNearTokenConfigBySymbol('wNEAR') as NearTokenConfig;
    //
    //     // 1. create bot
    //     payloads.push({
    //         receiverId: params.contractId,
    //         actions: [
    //             functionCall(
    //                 'create_bot',
    //                 {
    //                     deposit_asset_quantity: uiToNative(params.amount, tokenYConfig.decimals).toFixed(),
    //                     lower_price: uiToNative(params.lowerPrice, tokenYConfig.decimals).toFixed(),
    //                     upper_price: uiToNative(params.upperPrice, tokenYConfig.decimals).toFixed(),
    //                     grid_num: params.gridNumber.toNumber(),
    //                     leverage: uiToNative(params.leverage, 2).toNumber(),
    //                     market_id: params.market,
    //                     protocol: botProtocolEnumToStr(params.protocol),
    //                     bot_type: botTypeEnumToStr(params.botType),
    //                     start_price: uiToNative(params.startPrice, tokenYConfig.decimals).toFixed(),
    //                 },
    //                 DEFAULT_GAS,
    //                 ONE_NEAR_YOCTO.muln(BOT_CONTRACT_STORAGE_NEAR),
    //             ),
    //         ],
    //     });
    //
    //     //2. token Y storage deposit & deposit to bot (if NEAR register wNEAR and deposit NEAR)
    //     if (tokenYConfig.symbol == 'NEAR') {
    //         console.log(`Register in wNEAR & deposit ${params.amount} NEAR to bot`);
    //         payloads.push({
    //             receiverId: wNEARTokenConfig.symbol,
    //             actions: [
    //                 functionCall(
    //                     'storage_deposit',
    //                     {
    //                         account_id: botContractId,
    //                         registration_only: true,
    //                     },
    //                     DEFAULT_GAS.divn(2),
    //                     // 0.0125 NEAR
    //                     new BN('12500000000000000000000'),
    //                 ),
    //             ],
    //         });
    //         payloads.push({
    //             receiverId: botContractId,
    //             actions: [
    //                 functionCall('deposit_near', {}, DEFAULT_GAS, ONE_NEAR_YOCTO.mul(decimalToBN(params.amount))),
    //             ],
    //         });
    //     } else {
    //         console.log(`Register in ${tokenYConfig.symbol} & deposit ${params.amount} ${tokenYConfig.symbol} to bot`);
    //         payloads.push({
    //             receiverId: tokenYConfig.accountId,
    //             actions: [
    //                 functionCall(
    //                     'storage_deposit',
    //                     {
    //                         account_id: botContractId,
    //                         registration_only: true,
    //                     },
    //                     DEFAULT_GAS.divn(2),
    //                     // 0.0125 NEAR
    //                     new BN('12500000000000000000000'),
    //                 ),
    //                 functionCall(
    //                     'ft_transfer_call',
    //                     {
    //                         receiver_id: botContractId,
    //                         amount: uiToNative(params.amount, tokenYConfig.decimals).toFixed(),
    //                         msg: botIndex.toString(),
    //                     },
    //                     DEFAULT_GAS.divn(2),
    //                     new BN(1),
    //                 ),
    //             ],
    //         });
    //     }
    //
    //     //3. token X storage deposit (if NEAR register wNEAR)
    //     const tokenXRegisterAccountId =
    //         tokenXConfig.symbol == 'NEAR' ? wNEARTokenConfig.accountId : tokenXConfig.accountId;
    //     console.log(`Register in ${tokenXRegisterAccountId}`);
    //     payloads.push({
    //         receiverId: tokenXRegisterAccountId,
    //         actions: [
    //             functionCall(
    //                 'storage_deposit',
    //                 {
    //                     account_id: botContractId,
    //                     registration_only: true,
    //                 },
    //                 DEFAULT_GAS.divn(2),
    //                 // 0.0125 NEAR
    //                 new BN('12500000000000000000000'),
    //             ),
    //         ],
    //     });
    //
    //     //4. ref storage deposit
    //     console.log(`register in ref`);
    //     payloads.push({
    //         receiverId: REF_CONTRACT_ID,
    //         actions: [
    //             functionCall(
    //                 'storage_deposit',
    //                 {
    //                     account_id: botContractId,
    //                     registration_only: false,
    //                 },
    //                 DEFAULT_GAS,
    //                 // deposit 0.5 NEAR
    //                 ONE_NEAR_YOCTO.divn(2),
    //             ),
    //         ],
    //     });
    //     return [botIndex, payloads];
    // }

    static async getBotInfo(params: GetNearBotInfoParams): Promise<BotInfo> {
        const poolConfig = getRefPoolConfig(params.market) as RefPoolConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenXSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenYSymbol) as NearTokenConfig;
        const botContractId = `${params.botIndex}.${params.contractId}`;

        const [baseBalance, quoteBalance, baseMarketPrice, quoteMarketPrice] = await Promise.all([
            getNearTokenBalance(baseTokenConfig.symbol, botContractId, params.networkId),
            getNearTokenBalance(quoteTokenConfig.symbol, botContractId, params.networkId),
            getMarketPrice(baseTokenConfig.symbol),
            getMarketPrice(quoteTokenConfig.symbol),
        ]);
        return {
            value: baseBalance.mul(baseMarketPrice).add(quoteBalance.mul(quoteMarketPrice)),
            position: baseBalance,
        };
    }

    static async getOpenOrders(params: GetNearOpenOrdersParams): Promise<OpenOrder[]> {
        const poolConfig = getRefPoolConfig(params.market) as RefPoolConfig;
        const tokenXSymbol = poolConfig.tokenXSymbol == 'NEAR' ? 'wNEAR.Testnet' : poolConfig.tokenXSymbol;
        const tokenYSymbol = poolConfig.tokenYSymbol == 'NEAR' ? 'wNEAR.Testnet' : poolConfig.tokenYSymbol;
        const baseTokenConfig = getNearTokenConfigBySymbol(tokenXSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(tokenYSymbol) as NearTokenConfig;

        const botContractId = `${params.botIndex}.${params.contractId}`;

        const res = await nearViewFunction(
            'list_active_orders',
            { account_id: botContractId },
            REF_CONTRACT_ID,
            params.networkId,
        );
        console.log(res);

        const openOrders: OpenOrder[] = [];
        for (const i of res) {
            const price = refPointToPrice(new Decimal(i['point']), quoteTokenConfig.decimals, baseTokenConfig.decimals);
            const side: OrderSide = i['sell_token'] == quoteTokenConfig.accountId ? OrderSide.Bid : OrderSide.Ask;
            const size = nativeToUi(
                new Decimal(i['remain_amount']),
                side == OrderSide.Bid ? quoteTokenConfig.decimals : baseTokenConfig.decimals,
            );
            openOrders.push({
                price,
                size: side == OrderSide.Bid ? size.div(price) : size,
                side,
                orderId: i['order_id'],
                clientId: null,
            });
        }
        return openOrders;
    }

    /*
     * If order source token is NEAR, exchange to wNEAR first
     */
    static placeOrder(params: PlaceNearOrderParams): NearTransactionPayload {
        const poolConfig = getRefPoolConfig(params.market) as RefPoolConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenXSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenYSymbol) as NearTokenConfig;
        const botContractId = `${params.botIndex}.${params.contractId}`;

        const actions: Action[] = [];

        let buyTokenConfig: NearTokenConfig;
        let sellAmount: Decimal;
        let nativeSellAmount: string;
        if (params.side == OrderSide.Bid) {
            buyTokenConfig = baseTokenConfig;
            sellAmount = params.price.mul(params.size);
            nativeSellAmount = uiToNative(sellAmount, quoteTokenConfig.decimals).toFixed();
        } else {
            buyTokenConfig = quoteTokenConfig;
            sellAmount = params.size;
            nativeSellAmount = uiToNative(sellAmount, baseTokenConfig.decimals).toFixed();
        }

        if (
            (params.side == OrderSide.Bid && quoteTokenConfig.symbol == 'NEAR') ||
            (params.side == OrderSide.Ask && baseTokenConfig.symbol == 'NEAR')
        ) {
            actions.push(
                functionCall(
                    'exchange_for_wrapped_near',
                    {
                        amount: nativeSellAmount,
                    },
                    DEFAULT_GAS.divn(2),
                    ZERO_BN,
                ),
            );
        }

        const point = refPriceToPoint(
            params.price,
            quoteTokenConfig.decimals,
            baseTokenConfig.decimals,
            poolConfig.pointDelta,
        );
        console.log(`side: ${params.side}, price: ${params.price}, size: ${params.size}`);
        console.log(
            `buy token: ${buyTokenConfig.symbol}, sell amount: ${nativeSellAmount}, point: ${point.toString()} `,
        );

        actions.push(
            functionCall(
                'place_ref_limit_order',
                {
                    pool_id: params.market,
                    buy_token_id: buyTokenConfig.accountId,
                    sell_amount: nativeSellAmount,
                    point: point.toNumber(),
                },
                DEFAULT_GAS.divn(2),
                ZERO_BN,
            ),
        );

        return {
            receiverId: botContractId,
            actions,
        };
    }

    static cancelOrder(params: CancelNearOrderParams): NearTransactionPayload {
        if (params.amount === undefined) {
            throw `Cancel ref order error: missing parameter amount`;
        } else if (params.side === undefined) {
            throw `Cancel ref order error: missing parameter side`;
        }

        const poolConfig = getRefPoolConfig(params.market) as RefPoolConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenXSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(poolConfig.tokenYSymbol) as NearTokenConfig;
        const botContractId = `${params.botIndex}.${params.contractId}`;

        const nativeAmount = uiToNative(
            params.amount,
            params.side == OrderSide.Bid ? quoteTokenConfig.decimals : baseTokenConfig.decimals,
        );
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'cancel_ref_limit_order',
                    {
                        order_id: params.orderId,
                        amount: nativeAmount.toFixed(),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }
}

'''
'''--- src/Bot/near/SpinPerpBot.ts ---
import {
    BotInfo,
    CancelAllNearOrdersParams,
    CancelNearOrderParams,
    CloseNearBotParms,
    CloseNearMarketParams,
    CreateNearBotParams,
    GetNearBotInfoParams,
    GetNearOpenOrdersParams,
    NearTokenConfig,
    NearTransactionPayload,
    OpenOrder,
    OrderSide,
    OrderType,
    PlaceNearOrderParams,
    SpinPerpMarketConfig,
} from '../../type';
import { NearBot } from './index';
import {
    botProtocolEnumToStr,
    botTypeEnumToStr,
    getMarketPrice,
    getNearTokenConfigBySymbol,
    getSpinPerpMarketConfig,
    nativeToUi,
    nearViewFunction,
    uiToNative,
} from '../../util';
import { functionCall } from 'near-api-js/lib/transaction';
import {
    BOT_CONTRACT_STORAGE_NEAR,
    DEFAULT_GAS,
    ONE_NEAR_YOCTO,
    SPIN_PERP_CONTRACT_ID,
    ZERO_BN,
    ZERO_DECIMAL,
} from '../../constant';
import BN from 'bn.js';
import Decimal from 'decimal.js';

export class SpinPerpBot {
    /*
     * 1. Create bot (need deposit NEAR to deploy bot contract, see BOT_CONTRACT_STORAGE_NEAR)
     * 2. Register bot in quote ft & deposit quote ft to bot
     * 3. Deposit quote to Spin
     * returns [botIndex, transactionPayloads]
     */
    static async create(params: CreateNearBotParams): Promise<[number, NearTransactionPayload[]]> {
        const payloads: NearTransactionPayload[] = [];
        const botIndex = await NearBot.loadAll(params.contractId).then((res) => res.length);
        const botContractId = `${botIndex}.${params.contractId}`;

        const marketConfig = getSpinPerpMarketConfig(params.market) as SpinPerpMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;
        const [basePrice, quotePrice] = await Promise.all([
            getMarketPrice(baseTokenConfig.symbol),
            getMarketPrice(quoteTokenConfig.symbol),
        ]);
        const botValue = basePrice.mul(params.baseTokenBalance).add(quotePrice.mul(params.quoteTokenBalance));

        // 1. create bot
        console.log(`Create bot ${botContractId}`);
        payloads.push({
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'create_bot',
                    {
                        deposit_asset_quantity: uiToNative(botValue, quoteTokenConfig.decimals).floor().toFixed(),
                        lower_price: uiToNative(params.lowerPrice, quoteTokenConfig.decimals).toFixed(),
                        upper_price: uiToNative(params.upperPrice, quoteTokenConfig.decimals).toFixed(),
                        grid_num: params.gridNumber.toNumber(),
                        leverage: uiToNative(params.leverage, 2).toNumber(),
                        market_id: params.market,
                        protocol: botProtocolEnumToStr(params.protocol),
                        bot_type: botTypeEnumToStr(params.botType),
                        start_price: uiToNative(params.startPrice, quoteTokenConfig.decimals).toFixed(),
                        referer: params.referer,
                    },
                    DEFAULT_GAS,
                    ONE_NEAR_YOCTO.muln(BOT_CONTRACT_STORAGE_NEAR),
                ),
            ],
        });

        // 2. Register bot in quote ft & deposit quote ft to bot
        console.log(`Register ${botContractId} in ${quoteTokenConfig.symbol}`);
        const depositQuoteToBotPayload: NearTransactionPayload = {
            receiverId: quoteTokenConfig.accountId,
            actions: [
                functionCall(
                    'storage_deposit',
                    {
                        account_id: botContractId,
                        registration_only: true,
                    },
                    DEFAULT_GAS.divn(2),
                    // 0.0125 NEAR
                    new BN('12500000000000000000000'),
                ),
            ],
        };
        if (params.quoteTokenBalance.gt(ZERO_DECIMAL)) {
            console.log(`Deposit ${params.quoteTokenBalance} ${quoteTokenConfig.symbol} to bot`);
            depositQuoteToBotPayload.actions.push(
                functionCall(
                    'ft_transfer_call',
                    {
                        receiver_id: botContractId,
                        amount: uiToNative(params.quoteTokenBalance, quoteTokenConfig.decimals).toFixed(),
                        msg: botIndex.toString(),
                    },
                    DEFAULT_GAS.divn(2),
                    new BN(1),
                ),
            );
        }
        payloads.push(depositQuoteToBotPayload);

        // 3. Deposit quote to Spin
        console.log(`Deposit ${params.quoteTokenBalance} ${quoteTokenConfig.symbol} to Spin`);
        payloads.push({
            receiverId: botContractId,
            actions: [
                functionCall(
                    'deposit_to_spin_perp',
                    {
                        deposit_amount: uiToNative(params.quoteTokenBalance, quoteTokenConfig.decimals).toFixed(),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        });

        return [botIndex, payloads];
    }

    static async getBotInfo(params: GetNearBotInfoParams): Promise<BotInfo> {
        const botContractId = `${params.botIndex}.${params.contractId}`;

        const balance = await nearViewFunction('get_balance', { account_id: botContractId }, SPIN_PERP_CONTRACT_ID);
        const equity = nativeToUi(new Decimal(balance), 6);

        const positions = await nearViewFunction('get_positions', { account_id: botContractId }, SPIN_PERP_CONTRACT_ID);
        let position: Decimal;
        if (positions['positions'].length == 0) {
            position = ZERO_DECIMAL;
        } else {
            position =
                positions['positions'][0]['position_type'] == 'Long'
                    ? new Decimal(positions['positions'][0]['size_formatted'])
                    : new Decimal(positions['positions'][0]['size_formatted']).neg();
        }
        return {
            value: equity,
            position: position,
        };
    }

    static async getOpenOrders(params: GetNearOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getSpinPerpMarketConfig(params.market) as SpinPerpMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;

        const botContractId = `${params.botIndex}.${params.contractId}`;
        return nearViewFunction(
            'get_orders',
            {
                market_id: Number(params.market),
                account_id: botContractId,
            },
            SPIN_PERP_CONTRACT_ID,
        ).then((openOrders) =>
            openOrders.map((openOrder) => {
                return {
                    price: nativeToUi(new Decimal(openOrder['price']), baseTokenConfig.decimals),
                    size: nativeToUi(new Decimal(openOrder['remaining']), baseTokenConfig.decimals),
                    side: openOrder['o_type'] == 'Bid' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: openOrder['id'],
                    clientId: openOrder['client_order_id'].toString(),
                };
            }),
        );
    }

    static async placeOrder(params: PlaceNearOrderParams) {
        const orderValue = params.price.mul(params.size);
        if (orderValue.lte(new Decimal(0.1))) {
            throw `Place SpinPerp order error: order value must greater than 0.1 USDC`;
        }

        const marketConfig = getSpinPerpMarketConfig(params.market) as SpinPerpMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const botContractId = `${params.botIndex}.${params.contractId}`;
        // deadline add 3 hrs from current timestamp
        const deadline = new Date().getTime() + 3600000;

        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'place_spin_perp_order',
                    {
                        market_id: Number(params.market),
                        price: uiToNative(params.price, baseTokenConfig.decimals).toFixed(),
                        quantity: uiToNative(params.size, baseTokenConfig.decimals).toFixed(),
                        market_order: params.orderType == OrderType.Market,
                        client_order_id: Number(params.clientId),
                        time_in_force: 'GTC',
                        post_only: params.orderType == OrderType.PostOnly,
                        deadline: (deadline * Math.pow(10, 6)).toString(),
                        is_bid: params.side == OrderSide.Bid,
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static cancelOrder(params: CancelNearOrderParams): NearTransactionPayload {
        const botContractId = `${params.botIndex}.${params.contractId}`;
        // deadline add 3 hrs from current timestamp
        const deadline = new Date().getTime() + 3600000;
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'cancel_spin_perp_order',
                    {
                        market_id: Number(params.market),
                        order_id: params.orderId,
                        deadline: (deadline * Math.pow(10, 6)).toString(),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static cancelAllOrders(params: CancelAllNearOrdersParams): NearTransactionPayload {
        const botContractId = `${params.botIndex}.${params.contractId}`;
        // deadline add 3 hrs from current timestamp
        const deadline = new Date().getTime() + 3600000;
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'cancel_all_spin_perp_orders',
                    {
                        market_id: Number(params.market),
                        limit: 100,
                        deadline: (deadline * Math.pow(10, 6)).toString(),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static async closeMarket(params: CloseNearMarketParams): Promise<NearTransactionPayload | undefined> {
        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });

        if (botInfo.position.eq(ZERO_DECIMAL)) {
            return;
        }
        const side = botInfo.position.gt(ZERO_DECIMAL) ? OrderSide.Ask : OrderSide.Bid;

        const marketConfig = getSpinPerpMarketConfig(params.market) as SpinPerpMarketConfig;
        const marketPrice = await getMarketPrice(marketConfig.baseSymbol);
        const price = side == OrderSide.Bid ? marketPrice.mul(new Decimal(1.05)) : marketPrice.mul(new Decimal(0.95));
        const formattedPrice = price.toDecimalPlaces(marketConfig.orderPriceDecimals);

        console.log(
            `side: ${side}, price: ${price}, formattedPrice: ${formattedPrice}, size: ${botInfo.position.abs()}`,
        );

        return this.placeOrder({
            protocol: params.protocol,
            market: params.market,
            price: formattedPrice,
            size: botInfo.position.abs(),
            side,
            orderType: OrderType.Market,
            clientId: Math.floor(new Date().getTime() / 1000).toString(),
            botIndex: params.botIndex,
            contractId: params.contractId,
        });
    }

    /*
     * Requirement: No open orders & Zero position
     * 1. Redeem quote ft from Spin
     * 2. Redeem quote ft from bot
     * 3. Close bot
     */
    static async close(params: CloseNearBotParms) {
        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });
        if (openOrders.length > 0) {
            throw `Close SpinPerp bot error: open orders existed`;
        }

        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });
        if (botInfo.position.gt(ZERO_DECIMAL)) {
            throw `Close SpinPerp bot error: non-zero position`;
        }

        const usdcConfig = getNearTokenConfigBySymbol('USDC') as NearTokenConfig;
        const bot = await NearBot.load(params.botIndex, params.contractId, params.networkId);
        const botContractId = `${params.botIndex}.${params.contractId}`;
        const payloads: NearTransactionPayload[] = [];

        // 1. Redeem quote ft from Spin
        if (botInfo.value.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${botInfo.value} USDC from Spin Perp account`);
            payloads.push({
                receiverId: botContractId,
                actions: [
                    functionCall(
                        'withdraw_from_spin_perp',
                        { withdraw_amount: uiToNative(botInfo.value, usdcConfig.decimals) },
                        DEFAULT_GAS,
                        ZERO_BN,
                    ),
                ],
            });
        }

        // 2. Redeem quote ft from bot
        const botUSDCBalance = botInfo.value.add(nativeToUi(bot.balances[usdcConfig.accountId], usdcConfig.decimals));
        if (botUSDCBalance.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${botUSDCBalance} USDC from bot`);
            payloads.push({
                receiverId: params.contractId,
                actions: [
                    functionCall(
                        'withdraw',
                        {
                            bot_index: params.botIndex,
                            token_id: usdcConfig.accountId,
                            withdraw_amount: uiToNative(botUSDCBalance, usdcConfig.decimals).toFixed(),
                        },
                        DEFAULT_GAS,
                        ZERO_BN,
                    ),
                ],
            });
        }

        // 3. Close bot
        console.log(`Close bot ${botContractId} & redeem ${BOT_CONTRACT_STORAGE_NEAR} NEAR from bot contract`);
        payloads.push({
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'close_bot',
                    {
                        bot_index: params.botIndex,
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        });
        return payloads;
    }
}

'''
'''--- src/Bot/near/SpinSpotBot.ts ---
import { CreateNearBotParams, NearTokenConfig, NearTransactionPayload, SpinSpotMarketConfig } from '../../type';
import { NearBot } from './index';
import {
    botProtocolEnumToStr,
    botTypeEnumToStr,
    decimalToBN,
    getMarketPrice,
    getNearTokenConfigBySymbol,
    getSpinSpotMarketConfig,
    uiToNative,
} from '../../util';
import { functionCall } from 'near-api-js/lib/transaction';
import { BOT_CONTRACT_STORAGE_NEAR, DEFAULT_GAS, ONE_NEAR_YOCTO, ZERO_DECIMAL } from '../../constant';
import BN from 'bn.js';

export class SpinSpotBot {
    /*
     * 1. Create bot (need deposit NEAR to deploy bot contract, see BOT_CONTRACT_STORAGE_NEAR)
     * 2. Register bot in quote ft & deposit quote ft to bot
     * 3. Register bot in base ft & deposit base ft to bot (if NEAR deposit directly)
     * 4. Deposit quote & base to Spin
     * returns [botIndex, transactionPayloads]
     */
    static async create(params: CreateNearBotParams): Promise<[number, NearTransactionPayload[]]> {
        const payloads: NearTransactionPayload[] = [];
        const botIndex = await NearBot.loadAll(params.contractId).then((res) => res.length);
        const botContractId = `${botIndex}.${params.contractId}`;

        const marketConfig = getSpinSpotMarketConfig(params.market) as SpinSpotMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;
        const [basePrice, quotePrice] = await Promise.all([
            getMarketPrice(baseTokenConfig.symbol),
            getMarketPrice(quoteTokenConfig.symbol),
        ]);
        const botValue = basePrice.mul(params.baseTokenBalance).add(quotePrice.mul(params.quoteTokenBalance));

        // 1. create bot
        console.log(`Create bot ${botContractId}`);
        payloads.push({
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'create_bot',
                    {
                        deposit_asset_quantity: uiToNative(botValue, quoteTokenConfig.decimals).floor().toFixed(),
                        lower_price: uiToNative(params.lowerPrice, quoteTokenConfig.decimals).toFixed(),
                        upper_price: uiToNative(params.upperPrice, quoteTokenConfig.decimals).toFixed(),
                        grid_num: params.gridNumber.toNumber(),
                        leverage: uiToNative(params.leverage, 2).toNumber(),
                        market_id: params.market,
                        protocol: botProtocolEnumToStr(params.protocol),
                        bot_type: botTypeEnumToStr(params.botType),
                        start_price: uiToNative(params.startPrice, quoteTokenConfig.decimals).toFixed(),
                        referer: params.referer,
                    },
                    DEFAULT_GAS,
                    ONE_NEAR_YOCTO.muln(BOT_CONTRACT_STORAGE_NEAR),
                ),
            ],
        });

        // 2. Register bot in quote ft & deposit quote ft to bot
        console.log(`Register ${botContractId} in ${quoteTokenConfig.symbol}`);
        const depositQuoteToBotPayload: NearTransactionPayload = {
            receiverId: quoteTokenConfig.accountId,
            actions: [
                functionCall(
                    'storage_deposit',
                    {
                        account_id: botContractId,
                        registration_only: true,
                    },
                    DEFAULT_GAS.divn(2),
                    // 0.0125 NEAR
                    new BN('12500000000000000000000'),
                ),
            ],
        };
        if (params.quoteTokenBalance.gt(ZERO_DECIMAL)) {
            console.log(`Deposit ${params.quoteTokenBalance} ${quoteTokenConfig.symbol} to bot`);
            depositQuoteToBotPayload.actions.push(
                functionCall(
                    'ft_transfer_call',
                    {
                        receiver_id: botContractId,
                        amount: uiToNative(params.quoteTokenBalance, quoteTokenConfig.decimals).toFixed(),
                        msg: botIndex.toString(),
                    },
                    DEFAULT_GAS.divn(2),
                    new BN(1),
                ),
            );
        }
        payloads.push(depositQuoteToBotPayload);

        // 3. Register bot in base ft & deposit base ft to bot
        if (baseTokenConfig.symbol != 'NEAR') {
            console.log(`Register ${botContractId} in ${baseTokenConfig.symbol}`);
            const depositBaseToBotPayload: NearTransactionPayload = {
                receiverId: baseTokenConfig.accountId,
                actions: [
                    functionCall(
                        'storage_deposit',
                        {
                            account_id: botContractId,
                            registration_only: true,
                        },
                        DEFAULT_GAS.divn(2),
                        // 0.0125 NEAR
                        new BN('12500000000000000000000'),
                    ),
                ],
            };
            if (params.baseTokenBalance.gt(ZERO_DECIMAL)) {
                console.log(`Deposit ${params.baseTokenBalance} ${baseTokenConfig.symbol} to bot`);
                depositBaseToBotPayload.actions.push(
                    functionCall(
                        'ft_transfer_call',
                        {
                            receiver_id: botContractId,
                            amount: uiToNative(params.baseTokenBalance, baseTokenConfig.decimals).toFixed(),
                            msg: botIndex.toString(),
                        },
                        DEFAULT_GAS.divn(2),
                        new BN(1),
                    ),
                );
            }
            payloads.push(depositBaseToBotPayload);
        } else {
            console.log(`Deposit ${params.baseTokenBalance} NEAR to bot`);
            payloads.push({
                receiverId: botContractId,
                actions: [
                    functionCall('deposit_near', {}, DEFAULT_GAS, decimalToBN(uiToNative(params.baseTokenBalance, 24))),
                ],
            });
        }
        // TODO 4. Deposit quote & base to Spin

        return [botIndex, payloads];
    }
}

'''
'''--- src/Bot/near/TonicBot.ts ---
import {
    BotInfo,
    CancelAllNearOrdersParams,
    CancelNearOrderParams,
    CloseNearBotParms,
    CloseNearMarketParams,
    CreateNearBotParams,
    GetNearBotInfoParams,
    GetNearOpenOrdersParams,
    NearTokenConfig,
    NearTransactionPayload,
    OpenOrder,
    OrderSide,
    OrderType,
    PlaceNearOrderParams,
    TonicMarketConfig,
} from '../../type';
import { NearBot } from './index';
import { functionCall } from 'near-api-js/lib/transaction';
import {
    botProtocolEnumToStr,
    botTypeEnumToStr,
    decimalToBN,
    getMarketPrice,
    getNearTokenConfigBySymbol,
    getTonicMarketConfig,
    nativeToUi,
    nearViewFunction,
    redeemFromTonicAction,
    tonicOrderSideTransform,
    tonicOrderTypeTransform,
    uiToNative,
} from '../../util';
import {
    BOT_CONTRACT_STORAGE_NEAR,
    DEFAULT_GAS,
    ONE_NEAR_YOCTO,
    TONIC_CONTRACT_ID,
    ZERO_BN,
    ZERO_DECIMAL,
} from '../../constant';
import BN from 'bn.js';
import Decimal from 'decimal.js';

export class TonicBot {
    /*
     * 1. Create bot (need deposit NEAR to deploy bot contract, see BOT_CONTRACT_STORAGE_NEAR)
     * 2. Register bot in quote ft & deposit quote ft to bot
     * 3. Register bot in base ft & deposit base ft to bot (if NEAR deposit directly)
     * 4. Register bot in tonic
     * 5. Deposit quote & base to tonic
     * returns [botIndex, transactionPayloads]
     */
    static async create(params: CreateNearBotParams): Promise<[number, NearTransactionPayload[]]> {
        const payloads: NearTransactionPayload[] = [];
        const botIndex = await NearBot.loadAll(params.contractId).then((res) => res.length);
        const botContractId = `${botIndex}.${params.contractId}`;

        const marketConfig = getTonicMarketConfig(params.market) as TonicMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;
        const [basePrice, quotePrice] = await Promise.all([
            getMarketPrice(baseTokenConfig.symbol),
            getMarketPrice(quoteTokenConfig.symbol),
        ]);
        const botValue = basePrice.mul(params.baseTokenBalance).add(quotePrice.mul(params.quoteTokenBalance));

        // 1. create bot
        console.log(`Create bot ${botContractId}`);
        payloads.push({
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'create_bot',
                    {
                        deposit_asset_quantity: uiToNative(botValue, quoteTokenConfig.decimals).floor().toFixed(),
                        lower_price: uiToNative(params.lowerPrice, quoteTokenConfig.decimals).toFixed(),
                        upper_price: uiToNative(params.upperPrice, quoteTokenConfig.decimals).toFixed(),
                        grid_num: params.gridNumber.toNumber(),
                        leverage: uiToNative(params.leverage, 2).toNumber(),
                        market_id: params.market,
                        protocol: botProtocolEnumToStr(params.protocol),
                        bot_type: botTypeEnumToStr(params.botType),
                        start_price: uiToNative(params.startPrice, quoteTokenConfig.decimals).toFixed(),
                        referer: params.referer,
                    },
                    DEFAULT_GAS,
                    ONE_NEAR_YOCTO.muln(BOT_CONTRACT_STORAGE_NEAR),
                ),
            ],
        });

        // 2. Register bot in quote ft & deposit quote ft to bot
        console.log(`Register ${botContractId} in ${quoteTokenConfig.symbol}`);
        const depositQuoteToBotPayload: NearTransactionPayload = {
            receiverId: quoteTokenConfig.accountId,
            actions: [
                functionCall(
                    'storage_deposit',
                    {
                        account_id: botContractId,
                        registration_only: true,
                    },
                    DEFAULT_GAS.divn(2),
                    // 0.0125 NEAR
                    new BN('12500000000000000000000'),
                ),
            ],
        };
        if (params.quoteTokenBalance.gt(ZERO_DECIMAL)) {
            console.log(`Deposit ${params.quoteTokenBalance} ${quoteTokenConfig.symbol} to bot`);
            depositQuoteToBotPayload.actions.push(
                functionCall(
                    'ft_transfer_call',
                    {
                        receiver_id: botContractId,
                        amount: uiToNative(params.quoteTokenBalance, quoteTokenConfig.decimals).toFixed(),
                        msg: botIndex.toString(),
                    },
                    DEFAULT_GAS.divn(2),
                    new BN(1),
                ),
            );
        }
        payloads.push(depositQuoteToBotPayload);

        // 3. Register bot in base ft & deposit base ft to bot
        if (baseTokenConfig.symbol != 'NEAR') {
            console.log(`Register ${botContractId} in ${baseTokenConfig.symbol}`);
            const depositBaseToBotPayload: NearTransactionPayload = {
                receiverId: baseTokenConfig.accountId,
                actions: [
                    functionCall(
                        'storage_deposit',
                        {
                            account_id: botContractId,
                            registration_only: true,
                        },
                        DEFAULT_GAS.divn(2),
                        // 0.0125 NEAR
                        new BN('12500000000000000000000'),
                    ),
                ],
            };
            if (params.baseTokenBalance.gt(ZERO_DECIMAL)) {
                console.log(`Deposit ${params.baseTokenBalance} ${baseTokenConfig.symbol} to bot`);
                depositBaseToBotPayload.actions.push(
                    functionCall(
                        'ft_transfer_call',
                        {
                            receiver_id: botContractId,
                            amount: uiToNative(params.baseTokenBalance, baseTokenConfig.decimals).toFixed(),
                            msg: botIndex.toString(),
                        },
                        DEFAULT_GAS.divn(2),
                        new BN(1),
                    ),
                );
            }
            payloads.push(depositBaseToBotPayload);
        } else {
            console.log(`Deposit ${params.baseTokenBalance} NEAR to bot`);
            payloads.push({
                receiverId: botContractId,
                actions: [
                    functionCall('deposit_near', {}, DEFAULT_GAS, decimalToBN(uiToNative(params.baseTokenBalance, 24))),
                ],
            });
        }

        // 4. Register bot in tonic
        console.log(`Register ${botContractId} in tonic`);
        payloads.push({
            receiverId: TONIC_CONTRACT_ID,
            actions: [
                functionCall(
                    'storage_deposit',
                    {
                        account_id: botContractId,
                        registration_only: false,
                    },
                    DEFAULT_GAS,
                    // deposit 0.1 NEAR
                    ONE_NEAR_YOCTO.divn(10),
                ),
            ],
        });

        // 5. Deposit quote & base to tonic
        const depositToTonicPayload: NearTransactionPayload = {
            receiverId: botContractId,
            actions: [],
        };
        if (params.quoteTokenBalance.gt(ZERO_DECIMAL)) {
            console.log(`Deposit ${params.quoteTokenBalance} ${quoteTokenConfig.symbol} to tonic`);
            depositToTonicPayload.actions.push(
                functionCall(
                    'deposit_ft_to_tonic',
                    {
                        token_id: quoteTokenConfig.accountId,
                        deposit_amount: uiToNative(params.quoteTokenBalance, 6).toFixed(),
                    },
                    DEFAULT_GAS.divn(2),
                    ZERO_BN,
                ),
            );
        }
        if (params.baseTokenBalance.gt(ZERO_DECIMAL)) {
            if (baseTokenConfig.symbol != 'NEAR') {
                console.log(`Deposit ${params.baseTokenBalance} ${baseTokenConfig.symbol} to tonic`);
                depositToTonicPayload.actions.push(
                    functionCall(
                        'deposit_ft_to_tonic',
                        {
                            token_id: baseTokenConfig.accountId,
                            deposit_amount: uiToNative(params.baseTokenBalance, baseTokenConfig.decimals).toFixed(),
                        },
                        DEFAULT_GAS.divn(2),
                        ZERO_BN,
                    ),
                );
            } else {
                console.log(`Deposit ${params.baseTokenBalance} NEAR to tonic`);
                depositToTonicPayload.actions.push(
                    functionCall(
                        'deposit_near_to_tonic',
                        {
                            deposit_amount: uiToNative(params.baseTokenBalance, baseTokenConfig.decimals).toFixed(),
                        },
                        DEFAULT_GAS.divn(2),
                        ZERO_BN,
                    ),
                );
            }
        }
        payloads.push(depositToTonicPayload);
        return [botIndex, payloads];
    }

    static async getBotInfo(params: GetNearBotInfoParams): Promise<BotInfo> {
        const marketConfig = getTonicMarketConfig(params.market) as TonicMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;

        const botContractId = `${params.botIndex}.${params.contractId}`;
        const tonicBalances = await nearViewFunction('get_balances', { account_id: botContractId }, TONIC_CONTRACT_ID);

        // [ft:a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near, 1000000]
        const tonicBaseBalance = tonicBalances.find((i) => i[0].replace('ft:', '') == baseTokenConfig.accountId);
        const tonicQuoteBalance = tonicBalances.find((i) => i[0].replace('ft:', '') == quoteTokenConfig.accountId);
        let baseBalance = tonicBaseBalance
            ? nativeToUi(new Decimal(tonicBaseBalance[1]), baseTokenConfig.decimals)
            : ZERO_DECIMAL;
        let quoteBalance = tonicQuoteBalance
            ? nativeToUi(new Decimal(tonicQuoteBalance[1]), quoteTokenConfig.decimals)
            : ZERO_DECIMAL;

        // add in orders base / quote balance
        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });
        for (const openOrder of openOrders) {
            if (openOrder.side == OrderSide.Bid) {
                quoteBalance = quoteBalance.add(openOrder.price.mul(openOrder.size));
            } else {
                baseBalance = baseBalance.add(openOrder.size);
            }
        }

        const basePrice = await getMarketPrice(baseTokenConfig.symbol);

        return {
            value: basePrice.mul(baseBalance).add(quoteBalance),
            position: baseBalance,
        };
    }

    static async getOpenOrders(params: GetNearOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getTonicMarketConfig(params.market) as TonicMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;

        const botContractId = `${params.botIndex}.${params.contractId}`;
        return nearViewFunction(
            'get_open_orders',
            {
                market_id: params.market,
                account_id: botContractId,
            },
            TONIC_CONTRACT_ID,
        ).then((openOrders) =>
            openOrders.map((openOrder) => {
                return {
                    price: nativeToUi(new Decimal(openOrder['limit_price']), quoteTokenConfig.decimals),
                    size: nativeToUi(new Decimal(openOrder['open_qty']), baseTokenConfig.decimals),
                    side: openOrder['side'] == 'Buy' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: openOrder['id'],
                    clientId: openOrder['client_id'].toString(),
                };
            }),
        );
    }

    static placeOrder(params: PlaceNearOrderParams): NearTransactionPayload {
        const marketConfig = getTonicMarketConfig(params.market) as TonicMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;

        const botContractId = `${params.botIndex}.${params.contractId}`;
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'place_tonic_limit_order',
                    {
                        market_id: params.market,
                        limit_price: uiToNative(params.price, quoteTokenConfig.decimals).toFixed(),
                        quantity: uiToNative(params.size, baseTokenConfig.decimals).toFixed(),
                        side: tonicOrderSideTransform(params.side),
                        order_type: tonicOrderTypeTransform(params.orderType),
                        client_id: Number(params.clientId),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static cancelOrder(params: CancelNearOrderParams): NearTransactionPayload {
        const botContractId = `${params.botIndex}.${params.contractId}`;
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'cancel_tonic_limit_order',
                    {
                        order_id: params.orderId,
                        market_id: params.market,
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static cancelAllOrders(params: CancelAllNearOrdersParams): NearTransactionPayload {
        const botContractId = `${params.botIndex}.${params.contractId}`;
        return {
            receiverId: botContractId,
            actions: [
                functionCall(
                    'cancel_all_tonic_limit_orders',
                    {
                        market_id: params.market,
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    static async closeMarket(params: CloseNearMarketParams): Promise<NearTransactionPayload | undefined> {
        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });

        if (botInfo.position.eq(ZERO_DECIMAL)) {
            return;
        }
        const side = botInfo.position.gt(ZERO_DECIMAL) ? OrderSide.Ask : OrderSide.Bid;

        return this.placeOrder({
            protocol: params.protocol,
            market: params.market,
            price: new Decimal(1),
            size: botInfo.position.abs(),
            side,
            orderType: OrderType.Market,
            clientId: Math.floor(new Date().getTime() / 1000).toString(),
            botIndex: params.botIndex,
            contractId: params.contractId,
        });
    }

    /*
     * Requirement: No open orders
     * 1. Redeem base & quote ft from tonic
     * 2. Redeem base ft from bot
     * 3. Redeem quote ft from bot
     * 4. Close bot
     */
    static async close(params: CloseNearBotParms) {
        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            market: params.market,
            botIndex: params.botIndex,
            contractId: params.contractId,
            networkId: params.networkId,
        });
        if (openOrders.length > 0) {
            throw `Close tonic bot error: open orders existed`;
        }

        const payloads: NearTransactionPayload[] = [];

        const marketConfig = getTonicMarketConfig(params.market) as TonicMarketConfig;
        const baseTokenConfig = getNearTokenConfigBySymbol(marketConfig.baseSymbol) as NearTokenConfig;
        const quoteTokenConfig = getNearTokenConfigBySymbol(marketConfig.quoteSymbol) as NearTokenConfig;
        const botContractId = `${params.botIndex}.${params.contractId}`;

        const tonicBalances = await nearViewFunction('get_balances', { account_id: botContractId }, TONIC_CONTRACT_ID);
        const tonicNativeBaseBalance = tonicBalances.find((i) => i[0].replace('ft:', '') == baseTokenConfig.accountId);
        const tonicNativeQuoteBalance = tonicBalances.find(
            (i) => i[0].replace('ft:', '') == quoteTokenConfig.accountId,
        );

        const tonicBaseBalance = tonicNativeBaseBalance
            ? nativeToUi(new Decimal(tonicNativeBaseBalance[1]), baseTokenConfig.decimals)
            : ZERO_DECIMAL;
        const tonicQuoteBalance = tonicNativeQuoteBalance
            ? nativeToUi(new Decimal(tonicNativeQuoteBalance[1]), quoteTokenConfig.decimals)
            : ZERO_DECIMAL;

        // 1. Redeem base & quote ft from tonic
        const redeemFromDexPayload: NearTransactionPayload = { receiverId: botContractId, actions: [] };
        if (tonicBaseBalance.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${tonicBaseBalance} ${baseTokenConfig.symbol} from dex`);
            redeemFromDexPayload.actions.push(redeemFromTonicAction(baseTokenConfig.symbol, tonicBaseBalance));
        }
        if (tonicQuoteBalance.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${tonicQuoteBalance} ${quoteTokenConfig.symbol} from dex`);
            redeemFromDexPayload.actions.push(redeemFromTonicAction(quoteTokenConfig.symbol, tonicQuoteBalance));
        }
        if (redeemFromDexPayload.actions.length > 0) {
            payloads.push(redeemFromDexPayload);
        }

        const botInfo = await NearBot.load(params.botIndex, params.contractId, params.networkId);

        const botInfoBaseTokenAccountId = baseTokenConfig.symbol == 'NEAR' ? 'near.near' : baseTokenConfig.accountId;
        const botInfoQuoteTokenAccountId = quoteTokenConfig.symbol == 'NEAR' ? 'near.near' : quoteTokenConfig.accountId;
        const botBaseBalance = botInfo.balances[botInfoBaseTokenAccountId]
            ? nativeToUi(botInfo.balances[botInfoBaseTokenAccountId], baseTokenConfig.decimals)
            : ZERO_DECIMAL;
        const botQuoteBalance = botInfo.balances[botInfoQuoteTokenAccountId]
            ? nativeToUi(botInfo.balances[botInfoQuoteTokenAccountId], quoteTokenConfig.decimals)
            : ZERO_DECIMAL;

        const baseBalance = botBaseBalance.add(tonicBaseBalance);
        const quoteBalance = botQuoteBalance.add(tonicQuoteBalance);

        // 2. Redeem base ft from bot
        if (baseBalance.gt(ZERO_DECIMAL)) {
            if (baseTokenConfig.symbol != 'NEAR') {
                const storageBalance = await nearViewFunction(
                    'storage_balance_of',
                    {
                        account_id: params.userAccountId,
                    },
                    baseTokenConfig.accountId,
                );
                if (!storageBalance) {
                    console.log(`Register ${params.userAccountId} in ${baseTokenConfig.symbol}`);
                    payloads.push({
                        receiverId: baseTokenConfig.accountId,
                        actions: [
                            functionCall(
                                'storage_deposit',
                                {
                                    account_id: params.userAccountId,
                                    registration_only: true,
                                },
                                DEFAULT_GAS,
                                // 0.0125 NEAR
                                new BN('12500000000000000000000'),
                            ),
                        ],
                    });
                }
            }

            console.log(`Redeem ${baseBalance} ${baseTokenConfig.symbol} from bot`);
            payloads.push({
                receiverId: params.contractId,
                actions: [
                    functionCall(
                        'withdraw',
                        {
                            bot_index: params.botIndex,
                            token_id: botInfoBaseTokenAccountId,
                            withdraw_amount: uiToNative(baseBalance, baseTokenConfig.decimals).toFixed(),
                        },
                        DEFAULT_GAS,
                        ZERO_BN,
                    ),
                ],
            });
        }

        // 3. Redeem quote ft from bot
        if (quoteBalance.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${quoteBalance} ${quoteTokenConfig.symbol} from bot`);
            payloads.push({
                receiverId: params.contractId,
                actions: [
                    functionCall(
                        'withdraw',
                        {
                            bot_index: params.botIndex,
                            token_id: botInfoQuoteTokenAccountId,
                            withdraw_amount: uiToNative(quoteBalance, quoteTokenConfig.decimals).toFixed(),
                        },
                        DEFAULT_GAS,
                        ZERO_BN,
                    ),
                ],
            });
        }

        // 4. Close bot
        console.log(`Close bot ${botContractId} & redeem ${BOT_CONTRACT_STORAGE_NEAR} NEAR from bot contract`);
        payloads.push({
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'close_bot',
                    {
                        bot_index: params.botIndex,
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        });
        return payloads;
    }
}

'''
'''--- src/Bot/near/index.ts ---
import {
    CancelAllNearOrdersParams,
    CancelNearOrderParams,
    CloseNearBotParms,
    CloseNearMarketParams,
    CreateNearBotParams,
    GetNearBotInfoParams,
    GetNearOpenOrdersParams,
    NearBotAccount,
    NearBotInfo,
    NearNetworkId,
    NearSetCellConfigParams,
    NearSetDelegateParams,
    NearTransactionPayload,
    OpenOrder,
    PlaceNearOrderParams,
    Protocol,
} from '../../type';
import {
    botProtocolEnumToStr,
    botProtocolStrToEnum,
    botStatusStrToEnum,
    botTypeStrToEnum,
    nativeToUi,
    nearViewFunction,
    uiToNative,
} from '../../util';
import Decimal from 'decimal.js';
import { TonicBot } from './TonicBot';
import { functionCall } from 'near-api-js/lib/transaction';
import { DEFAULT_GAS, ZERO_BN } from '../../constant';
import { RefBot } from './RefBot';
import { SpinSpotBot } from './SpinSpotBot';
import { SpinPerpBot } from './SpinPerpBot';

export class NearBot {
    static async load(
        botIndex: number,
        contractId: string,
        networkId = NearNetworkId.mainnet,
    ): Promise<NearBotAccount> {
        const botContractId = `${botIndex}.${contractId}`;
        const bot = await nearViewFunction('get_bot_info', {}, botContractId, networkId);

        const balances = {};
        for (const i of Object.entries(bot['balances'])) {
            balances[i[0]] = new Decimal(i[1] as Decimal.Value);
        }

        return {
            contractId: botContractId,
            owner: bot['bot_owner'],
            amount: nativeToUi(new Decimal(bot['deposit_asset_quantity']), 6),
            market: bot['market_id'],
            protocol: botProtocolStrToEnum(bot['protocol']),
            type: botTypeStrToEnum(bot['bot_type']),
            status: botStatusStrToEnum(bot['bot_status']),
            startPrice: nativeToUi(new Decimal(bot['start_price']), 6),
            lowerPrice: nativeToUi(new Decimal(bot['lower_price']), 6),
            upperPrice: nativeToUi(new Decimal(bot['upper_price']), 6),
            gridNumber: new Decimal(bot['grid_num']),
            leverage: nativeToUi(new Decimal(bot['leverage']), 2),
            referer: bot['referer'],
            perpFeeDiscount: new Decimal(bot['perf_fee_discount']),
            balances,
        };
    }

    static async loadAll(contractId: string, networkId = NearNetworkId.mainnet): Promise<NearBotInfo[]> {
        return nearViewFunction('get_all_bots', {}, contractId, networkId).then((bots) =>
            bots.map((bot) => {
                return {
                    contractId: bot['bot_account'],
                    owner: bot['bot_owner'],
                    isClosed: bot['is_closed'],
                };
            }),
        );
    }

    static create(params: CreateNearBotParams): Promise<[number, NearTransactionPayload[]]> {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.create(params);
            // case Protocol.Ref:
            //     return RefBot.create(params);
            case Protocol.SpinSpot:
                return SpinSpotBot.create(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.create(params);
            default:
                throw `Create near bot error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static start(botIndex: number, contractId: string): NearTransactionPayload {
        return {
            receiverId: `${botIndex}.${contractId}`,
            actions: [functionCall('start_bot', {}, DEFAULT_GAS, ZERO_BN)],
        };
    }

    static getBotInfo(params: GetNearBotInfoParams) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.getBotInfo(params);
            case Protocol.Ref:
                return RefBot.getBotInfo(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.getBotInfo(params);
            default:
                throw `Get near bot info error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static getOpenOrders(params: GetNearOpenOrdersParams): Promise<OpenOrder[]> {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.getOpenOrders(params);
            case Protocol.Ref:
                return RefBot.getOpenOrders(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.getOpenOrders(params);
            default:
                throw `Cancel near bot open orders error: unsupported protocol ${botProtocolEnumToStr(
                    params.protocol,
                )}`;
        }
    }

    static stop(botIndex: number, contractId: string): NearTransactionPayload {
        return {
            receiverId: `${botIndex}.${contractId}`,
            actions: [functionCall('stop_bot', {}, DEFAULT_GAS, ZERO_BN)],
        };
    }

    static placeOrder(params: PlaceNearOrderParams) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.placeOrder(params);
            case Protocol.Ref:
                return RefBot.placeOrder(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.placeOrder(params);
            default:
                throw `Place near bot order info error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static cancelOrder(params: CancelNearOrderParams) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.cancelOrder(params);
            case Protocol.Ref:
                return RefBot.cancelOrder(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.cancelOrder(params);
            default:
                throw `Cancel near bot order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static cancelAllOrders(params: CancelAllNearOrdersParams) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.cancelAllOrders(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.cancelAllOrders(params);
            default:
                throw `Cancel near bot all orders error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static closeMarket(params: CloseNearMarketParams) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.closeMarket(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.closeMarket(params);
            default:
                throw `Close near bot market error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static close(params: CloseNearBotParms) {
        switch (params.protocol) {
            case Protocol.Tonic:
                return TonicBot.close(params);
            case Protocol.SpinPerp:
                return SpinPerpBot.close(params);
            default:
                throw `Cancel near bot error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static setDelegate(params: NearSetDelegateParams): NearTransactionPayload {
        return {
            receiverId: `${params.botIndex}.${params.contractId}`,
            actions: [functionCall('set_delegate', { delegate: params.delegateAccountId }, DEFAULT_GAS, ZERO_BN)],
        };
    }

    /*
     * Add referer & discount in cell config, discount 0.1 as 10%
     */
    static addReferer(refererAccount: string, discount: Decimal, contractId: string): NearTransactionPayload {
        return {
            receiverId: contractId,
            actions: [
                functionCall(
                    'add_referer',
                    { referer_account: refererAccount, discount: uiToNative(discount, 2).toNumber() },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }

    /*
     * Set referer to bot
     */
    static setReferer(refererAccount: string, botIndex: number, contractId: string): NearTransactionPayload {
        return {
            receiverId: contractId,
            actions: [
                functionCall('set_bot_referer', { bot_index: botIndex, referer: refererAccount }, DEFAULT_GAS, ZERO_BN),
            ],
        };
    }

    static getRefererDiscount(refererAccount: string, contractId: string): Promise<Decimal> {
        return nearViewFunction('get_referer_discount', { referer_account: refererAccount }, contractId).then((res) =>
            nativeToUi(new Decimal(res), 2),
        );
    }
}

export class NearCellConfig {
    static load(contractId: string) {
        return nearViewFunction('get_cell_info', {}, contractId);
    }

    static set(params: NearSetCellConfigParams) {
        return {
            receiverId: params.contractId,
            actions: [
                functionCall(
                    'set_cell_config',
                    {
                        delegate: params.delegateAccountId,
                        create_bot_line: params.createBotLine.toFixed(),
                        stop_bot_line: params.stopBotLine.toFixed(),
                        perf_fee_ratio: params.perpFeeRatio.toNumber(),
                        bot_owner_most_perf_fee_ratio: params.botOwnerMostPerpFeeRatio.toNumber(),
                    },
                    DEFAULT_GAS,
                    ZERO_BN,
                ),
            ],
        };
    }
}

'''
'''--- src/Bot/solana/MangoPerpBot.ts ---
import { CloseBotParams, SolanaTokenConfig, TransactionPayload } from '../../type';
import {
    createATA,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getMangoReimbursementAccount,
    getMangoReimbursementAccountKey,
    getMangoReimbursementGroup,
    getMangoReimbursementRow,
    getTokenConfig,
    getTokenConfigBySymbol,
    nativeToUi,
    redeemAllFromBot,
} from '../../util';
import { createMangoReimbursementAccountIx, mangoReimbursementIx } from '../../instruction';
import { MangoClient } from '@blockworks-foundation/mango-client';
import { MANGO_GROUP_KEY, MANGO_PROGRAM_ID, ZERO_DECIMAL } from '../../constant';

export class MangoPerpBot {
    /*
     * 1. Mango reimbursement
     * 2. Redeem all asset from bot
     */
    static async close(params: CloseBotParams) {
        const payloads: (TransactionPayload | undefined)[] = [];
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const redeemTokens: string[] = [];

        // 1. Mango reimbursement
        // Skip reimbursement if no reimbursement row or already created reimbursement account
        const reimbursementRow = await getMangoReimbursementRow(params.connection, botKey);
        if (!reimbursementRow) {
            payloads.push(undefined);
        } else {
            const reimbursementAccountKey = await getMangoReimbursementAccountKey(botKey);
            const reimbursementAccount = await getMangoReimbursementAccount(params.connection, reimbursementAccountKey);
            if (reimbursementAccount) {
                payloads.push(undefined);
            } else {
                const reimbursementPayload: TransactionPayload = { instructions: [], signers: [] };
                console.log(`Create reimbursement account ${reimbursementAccountKey.toString()}`);
                reimbursementPayload.instructions.push(
                    createMangoReimbursementAccountIx({
                        botSeed: params.botSeed,
                        reimbursementAccount: reimbursementAccountKey,
                        mangoAccountOwnerAccount: botKey,
                        payer: params.owner,
                        programId: params.programId,
                    }),
                );

                const mangoClient = new MangoClient(params.connection, MANGO_PROGRAM_ID);
                const mangoGroup = await mangoClient.getMangoGroup(MANGO_GROUP_KEY);
                const mangoReimbursementGroup = await getMangoReimbursementGroup(params.connection);
                for (const [tokenIndex, balance] of reimbursementRow.balances.entries()) {
                    if (balance.eq(ZERO_DECIMAL)) {
                        continue;
                    }
                    const tokenConfig = getTokenConfig(mangoGroup.tokens[tokenIndex].mint) as SolanaTokenConfig;
                    const uiBalance = nativeToUi(balance, tokenConfig.decimals);
                    redeemTokens.push(tokenConfig.name);
                    console.log(`Mango reimbursement ${uiBalance} ${tokenConfig.name}`);
                    const [botTokenATA, createBotTokenATAIx] = await createATA(
                        params.connection,
                        botKey,
                        tokenConfig.mintKey,
                        params.owner,
                    );
                    if (createBotTokenATAIx) {
                        reimbursementPayload.instructions.push(createBotTokenATAIx);
                    }
                    const claimMintTokenAccount = await getATAKey(
                        mangoReimbursementGroup.claimTransferDestination,
                        mangoReimbursementGroup.claimMints[tokenIndex],
                    );
                    reimbursementPayload.instructions.push(
                        mangoReimbursementIx({
                            botSeed: params.botSeed,
                            tokenIndex: tokenIndex,
                            indexIntoTable: reimbursementRow.index,
                            vaultAccount: mangoReimbursementGroup.vaults[tokenIndex],
                            tokenAccount: botTokenATA,
                            reimbursementAccount: reimbursementAccountKey,
                            mangoAccountOwnerAccount: botKey,
                            botAccount: botKey,
                            claimMintTokenAccount: claimMintTokenAccount,
                            claimMintAccount: mangoReimbursementGroup.claimMints[tokenIndex],
                            reimbursementTableAccount: mangoReimbursementGroup.table,
                            programId: params.programId,
                        }),
                    );
                }
                payloads.push(reimbursementPayload);
            }
        }

        // 2. Redeem all asset from bot
        const quoteTokenConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const botQuoteBalance = await getATABalance(params.connection, botQuoteATA);
        console.log(`bot quote balance: ${botQuoteBalance}`);

        if (botQuoteBalance.gt(ZERO_DECIMAL) && redeemTokens.indexOf(quoteTokenConfig.name) == -1) {
            redeemTokens.push(quoteTokenConfig.name);
        }

        if (redeemTokens.length > 0) {
            console.log(`Redeem from bot tokens: ${redeemTokens}`);
            const redeemAllFromBotPayload = await redeemAllFromBot(
                params.connection,
                params.botSeed,
                params.owner,
                params.referrer,
                params.cellAdmin,
                redeemTokens,
                params.programId,
            );
            payloads.push(redeemAllFromBotPayload);
        } else {
            payloads.push(undefined);
        }

        return payloads;
    }
}

'''
'''--- src/Bot/solana/MangoSpotBot.ts ---
import { CloseBotParams, MangoSpotMarketConfig, SolanaTokenConfig, TransactionPayload } from '../../type';
import {
    createATA,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getMangoReimbursementAccount,
    getMangoReimbursementAccountKey,
    getMangoReimbursementGroup,
    getMangoReimbursementRow,
    getMangoSpotMarketConfig,
    getTokenConfig,
    getTokenConfigBySymbol,
    nativeToUi,
    redeemAllFromBot,
} from '../../util';
import { createMangoReimbursementAccountIx, mangoReimbursementIx } from '../../instruction';
import { MANGO_GROUP_KEY, MANGO_PROGRAM_ID, ZERO_DECIMAL } from '../../constant';
import { MangoClient } from '@blockworks-foundation/mango-client';

export class MangoSpotBot {
    /*
     * 1. Mango reimbursement
     * 2. Redeem all asset from bot
     */
    static async close(params: CloseBotParams): Promise<(TransactionPayload | undefined)[]> {
        const payloads: (TransactionPayload | undefined)[] = [];
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const redeemTokens: string[] = [];

        // 1. Mango reimbursement
        // Skip reimbursement if no reimbursement row or already created reimbursement account
        const reimbursementRow = await getMangoReimbursementRow(params.connection, botKey);
        if (!reimbursementRow) {
            payloads.push(undefined);
        } else {
            const reimbursementAccountKey = await getMangoReimbursementAccountKey(botKey);
            const reimbursementAccount = await getMangoReimbursementAccount(params.connection, reimbursementAccountKey);
            if (reimbursementAccount) {
                payloads.push(undefined);
            } else {
                const reimbursementPayload: TransactionPayload = { instructions: [], signers: [] };
                console.log(`Create reimbursement account ${reimbursementAccountKey.toString()}`);
                reimbursementPayload.instructions.push(
                    createMangoReimbursementAccountIx({
                        botSeed: params.botSeed,
                        reimbursementAccount: reimbursementAccountKey,
                        mangoAccountOwnerAccount: botKey,
                        payer: params.owner,
                        programId: params.programId,
                    }),
                );

                const mangoClient = new MangoClient(params.connection, MANGO_PROGRAM_ID);
                const mangoGroup = await mangoClient.getMangoGroup(MANGO_GROUP_KEY);
                const mangoReimbursementGroup = await getMangoReimbursementGroup(params.connection);
                for (const [tokenIndex, balance] of reimbursementRow.balances.entries()) {
                    if (balance.eq(ZERO_DECIMAL)) {
                        continue;
                    }
                    const tokenConfig = getTokenConfig(mangoGroup.tokens[tokenIndex].mint) as SolanaTokenConfig;
                    const uiBalance = nativeToUi(balance, tokenConfig.decimals);
                    redeemTokens.push(tokenConfig.name);
                    console.log(`Mango reimbursement ${uiBalance} ${tokenConfig.name}`);
                    const [botTokenATA, createBotTokenATAIx] = await createATA(
                        params.connection,
                        botKey,
                        tokenConfig.mintKey,
                        params.owner,
                    );
                    if (createBotTokenATAIx) {
                        reimbursementPayload.instructions.push(createBotTokenATAIx);
                    }
                    const claimMintTokenAccount = await getATAKey(
                        mangoReimbursementGroup.claimTransferDestination,
                        mangoReimbursementGroup.claimMints[tokenIndex],
                    );
                    reimbursementPayload.instructions.push(
                        mangoReimbursementIx({
                            botSeed: params.botSeed,
                            tokenIndex: tokenIndex,
                            indexIntoTable: reimbursementRow.index,
                            vaultAccount: mangoReimbursementGroup.vaults[tokenIndex],
                            tokenAccount: botTokenATA,
                            reimbursementAccount: reimbursementAccountKey,
                            mangoAccountOwnerAccount: botKey,
                            botAccount: botKey,
                            claimMintTokenAccount: claimMintTokenAccount,
                            claimMintAccount: mangoReimbursementGroup.claimMints[tokenIndex],
                            reimbursementTableAccount: mangoReimbursementGroup.table,
                            programId: params.programId,
                        }),
                    );
                }
                payloads.push(reimbursementPayload);
            }
        }

        // 2. Redeem all asset from bot
        const marketConfig = getMangoSpotMarketConfig(params.marketKey) as MangoSpotMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botBaseATA = await getATAKey(botKey, baseTokenConfig.mintKey);
        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const botBaseBalance = await getATABalance(params.connection, botBaseATA);
        const botQuoteBalance = await getATABalance(params.connection, botQuoteATA);
        console.log(`bot base balance: ${botBaseBalance}`);
        console.log(`bot quote balance: ${botQuoteBalance}`);

        if (botBaseBalance.gt(ZERO_DECIMAL) && redeemTokens.indexOf(baseTokenConfig.name) == -1) {
            redeemTokens.push(baseTokenConfig.name);
        }
        if (botQuoteBalance.gt(ZERO_DECIMAL) && redeemTokens.indexOf(quoteTokenConfig.name) == -1) {
            redeemTokens.push(quoteTokenConfig.name);
        }

        if (redeemTokens.length > 0) {
            console.log(`Redeem from bot tokens: ${redeemTokens}`);
            const redeemAllFromBotPayload = await redeemAllFromBot(
                params.connection,
                params.botSeed,
                params.owner,
                params.referrer,
                params.cellAdmin,
                redeemTokens,
                params.programId,
            );
            payloads.push(redeemAllFromBotPayload);
        } else {
            payloads.push(undefined);
        }

        return payloads;
    }
}

'''
'''--- src/Bot/solana/SerumBot.ts ---
import {
    BotInfo,
    CancelOrderParams,
    CloseBotParams,
    CloseSolanaBotMarketParams,
    CreateBotParams,
    GetBotInfoParams,
    GetOpenOrdersParams,
    OpenOrder,
    OrderSide,
    OrderType,
    PlaceOrderParams,
    SerumMarketConfig,
    SolanaTokenConfig,
    StopBotParams,
    TransactionPayload,
} from '../../type';
import {
    genValidBotAccount,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getCellCacheKey,
    getCellConfigAccountKey,
    getMarketPrice,
    getSerumMarketConfig,
    getSerumOpenOrdersAccountInfo,
    getSerumOpenOrdersAccountKey,
    getTokenConfigBySymbol,
    nativeToUi,
    redeemAllFromBot,
    serumOrderTypeTransform,
    uiToNative,
} from '../../util';
import {
    createATAIx,
    createBotIx,
    serumCancelOrderIx,
    serumCloseOpenOrdersIx,
    serumInitOpenOrdersIx,
    serumPlaceOrderIx,
    serumSettleFundsIx,
    stopBotIx,
} from '../../instruction';
import { PublicKey } from '@solana/web3.js';
import { Market, Orderbook } from '@project-serum/serum';
import { SERUM_PROGRAM_ID, ZERO_DECIMAL } from '../../constant';
import Decimal from 'decimal.js';

export class SerumBot {
    /*
     * txPayload: [createBotQuoteTokenATA, createBotBaseTokenATA, createBotIx, createSerumOpenOrdersIx]
     * returns [botSeed, dexAccountKey, orderOwnerKey, txPayload]
     */
    static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
        const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
        const serumOpenOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);

        const isDualDeposit =
            !params.depositBaseBalance.eq(ZERO_DECIMAL) && !params.depositQuoteBalance.eq(ZERO_DECIMAL);

        const botBaseTokenATA = await getATAKey(botKey, baseTokenConfig.mintKey);
        const botQuoteTokenATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const userBaseTokenATA = await getATAKey(params.botOwner, baseTokenConfig.mintKey);
        const userQuoteTokenATA = await getATAKey(params.botOwner, quoteTokenConfig.mintKey);

        const botAssetKeys: PublicKey[] = [botQuoteTokenATA];
        const userAssetKeys: PublicKey[] = [userQuoteTokenATA];
        const assetPriceKeys: PublicKey[] = [quoteTokenConfig.pythPriceKey];
        if (!params.depositBaseBalance.eq(ZERO_DECIMAL)) {
            botAssetKeys.push(botBaseTokenATA);
            userAssetKeys.push(userBaseTokenATA);
            assetPriceKeys.push(baseTokenConfig.pythPriceKey);
        }

        const payload: TransactionPayload = {
            instructions: [
                createATAIx({
                    ataKey: botBaseTokenATA,
                    ownerKey: botKey,
                    mintKey: baseTokenConfig.mintKey,
                    payerKey: params.botOwner,
                }),
                createATAIx({
                    ataKey: botQuoteTokenATA,
                    ownerKey: botKey,
                    mintKey: quoteTokenConfig.mintKey,
                    payerKey: params.botOwner,
                }),
                createBotIx({
                    botSeed,
                    depositBaseBalance: uiToNative(params.depositBaseBalance, baseTokenConfig.decimals),
                    depositQuoteBalance: uiToNative(params.depositQuoteBalance, quoteTokenConfig.decimals),
                    lowerPrice: uiToNative(params.lowerPrice, 6),
                    upperPrice: uiToNative(params.upperPrice, 6),
                    gridNum: params.gridNum,
                    marketKey: params.marketKey,
                    leverage: uiToNative(params.leverage, 2),
                    isDualDeposit,
                    botKey,
                    botMintKey,
                    userBotTokenKey: ownerBotMintATA,
                    userKey: params.botOwner,
                    protocol: params.protocol,
                    botType: params.botType,
                    stopTopRatio: params.stopTopRatio,
                    stopBottomRatio: params.stopBottomRatio,
                    trigger: params.trigger,
                    isPool: false,
                    startPrice: uiToNative(params.startPrice, 6),
                    cellCacheAccount: cellCacheKey,
                    botAssetKeys,
                    userAssetKeys,
                    assetPriceKeys,
                    programId: params.programId,
                }),
                serumInitOpenOrdersIx({
                    botSeed,
                    userOrBotDelegateAccount: params.botOwner,
                    marketAccount: params.marketKey,
                    openOrdersAccount: serumOpenOrdersAccountKey,
                    botAccount: botKey,
                    botOrWorkingCapAccount: botKey,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
        return [botSeed, serumOpenOrdersAccountKey, serumOpenOrdersAccountKey, payload];
    }

    static async stop(params: StopBotParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        return {
            instructions: [
                stopBotIx({
                    botSeed: params.botSeed,
                    botKey,
                    userKey: params.payer,
                    pythPriceAccount: baseTokenConfig.pythPriceKey,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    /*
     * returns BotInfo {
     *      value: (botBaseToken + ooaBaseTokenTotal) * basePrice + (botQuoteToken + ooaQuoteTokenTotal) * quotePrice
     *      position: botBaseToken + ooaBaseTokenTotal
     * }
     */
    static async getBotInfo(params: GetBotInfoParams): Promise<BotInfo> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botBaseATA = await getATAKey(botKey, baseTokenConfig.mintKey);
        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);

        const serumOpenOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);

        const [openOrdersAccountInfo, basePrice, quotePrice, botBaseTokenBalance, botQuoteTokenBalance] =
            await Promise.all([
                getSerumOpenOrdersAccountInfo(params.connection, serumOpenOrdersAccountKey),
                getMarketPrice(baseTokenConfig.name),
                getMarketPrice(quoteTokenConfig.name),
                getATABalance(params.connection, botBaseATA),
                getATABalance(params.connection, botQuoteATA),
            ]);

        const baseTokenBalance = openOrdersAccountInfo
            ? botBaseTokenBalance.add(nativeToUi(openOrdersAccountInfo.baseTokenTotal, baseTokenConfig.decimals))
            : botBaseTokenBalance;
        const quoteTokenBalance = openOrdersAccountInfo
            ? botQuoteTokenBalance.add(nativeToUi(openOrdersAccountInfo.quoteTokenTotal, quoteTokenConfig.decimals))
            : botQuoteTokenBalance;
        return {
            position: baseTokenBalance,
            value: baseTokenBalance.mul(basePrice).add(quoteTokenBalance.mul(quotePrice)),
        };
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);

        const [market, bidsInfo, asksInfo] = await Promise.all([
            Market.load(params.connection, params.marketKey, {}, SERUM_PROGRAM_ID),
            params.connection.getAccountInfo(marketConfig.bids),
            params.connection.getAccountInfo(marketConfig.asks),
        ]);

        if (!bidsInfo || !asksInfo) {
            throw `Get open orders error: bids / asks not available`;
        }

        const bids = Orderbook.decode(market, bidsInfo.data);
        const asks = Orderbook.decode(market, asksInfo.data);

        return [...bids, ...asks]
            .filter((o) => o.openOrdersAddress.equals(openOrdersAccountKey))
            .map((i) => {
                return {
                    price: new Decimal(i['price']),
                    // TODO 1. open order size decimals convert?
                    // TODO 2. buy / sell order size transfer(source token amount)?
                    size: new Decimal(i['size']),
                    side: i['side'] == 'buy' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: i['orderId'].toString(),
                    clientId: i['clientId'] ? i['clientId'].toString() : null,
                };
            });
    }

    /*
     * Serum order size using source token amount
     * e.g. SOL/USDC market, Buy order amount is USDC amount, Sell order amount is SOL amount
     */
    static async placeOrder(params: PlaceOrderParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);
        const botAssetATA =
            params.side == OrderSide.Bid
                ? await getATAKey(botKey, quoteTokenConfig.mintKey)
                : await getATAKey(botKey, baseTokenConfig.mintKey);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);

        const nativePrice = uiToNative(params.price, marketConfig.orderPriceDecimals);
        const size = params.side == OrderSide.Bid ? params.price.mul(params.quantity) : params.quantity;
        const nativeSize =
            params.side == OrderSide.Bid
                ? uiToNative(size, quoteTokenConfig.decimals)
                : uiToNative(size, baseTokenConfig.decimals);
        return {
            instructions: [
                serumPlaceOrderIx({
                    botSeed: params.botSeed,
                    side: params.side,
                    orderType: serumOrderTypeTransform(params.orderType),
                    limitPrice: nativePrice,
                    amountToTrade: nativeSize,
                    coinLotSize: marketConfig.baseLotSize,
                    pcLotSize: marketConfig.quoteLotSize,
                    clientOrderId: params.clientId,
                    userOrBotDelegateAccount: params.payer,
                    marketAccount: params.marketKey,
                    openOrdersAccount: openOrdersAccountKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    // TODO if pool using working cap account
                    botOrWorkingCapAssetAccount: botAssetATA,
                    botOrWorkingCapAccount: botKey,
                    botAccount: botKey,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async cancelOrder(params: CancelOrderParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        return {
            instructions: [
                serumCancelOrderIx({
                    botSeed: params.botSeed,
                    side: params.side,
                    orderId: params.orderId,
                    userOrBotDelegateAccount: params.payer,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    openOrdersAccount: openOrdersAccountKey,
                    botOrWorkingCapAccount: botKey,
                    botAccount: botKey,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    // TODO market order price size adjustment
    static async closeMarket(params: CloseSolanaBotMarketParams): Promise<TransactionPayload | undefined> {
        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });

        if (botInfo.position.eq(ZERO_DECIMAL)) {
            return;
        }

        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const side = botInfo.position.gt(ZERO_DECIMAL) ? OrderSide.Ask : OrderSide.Bid;
        // buy order with maximum price, e.g. quote token decimal = 6, buy with price 1e7-1 = 999999
        // sell order with minimum price, e.g. order price decimal is 3, sell with 1e-3 = 0.001
        const price =
            side == OrderSide.Bid
                ? uiToNative(new Decimal(1), quoteTokenConfig.decimals + 1).sub(new Decimal(1))
                : nativeToUi(new Decimal(1), marketConfig.orderPriceDecimals);

        return this.placeOrder({
            protocol: params.protocol,
            price,
            quantity: botInfo.position.abs(),
            side,
            orderType: OrderType.IOC,
            clientId: new Date().getTime().toString(),
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            payer: params.payer,
            programId: params.programId,
        });
    }

    /*
     * Requirement: No open orders
     * 1. Close open orders account
     * 2. Redeem all base & quote token from bot
     */
    static async close(params: CloseBotParams): Promise<(TransactionPayload | undefined)[]> {
        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });
        if (openOrders.length > 0) {
            throw `Close bot error: open orders existed`;
        }

        const payloads: (TransactionPayload | undefined)[] = [];

        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botBaseATA = await getATAKey(botKey, baseTokenConfig.mintKey);
        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(botKey, params.programId);
        const [openOrdersAccountInfo, botBaseTokenBalance, botQuoteTokenBalance] = await Promise.all([
            getSerumOpenOrdersAccountInfo(params.connection, openOrdersAccountKey),
            getATABalance(params.connection, botBaseATA),
            getATABalance(params.connection, botQuoteATA),
        ]);

        const ooaBase = openOrdersAccountInfo
            ? nativeToUi(openOrdersAccountInfo.baseTokenTotal, baseTokenConfig.decimals)
            : ZERO_DECIMAL;
        const ooaQuote = openOrdersAccountInfo
            ? nativeToUi(openOrdersAccountInfo.quoteTokenTotal, quoteTokenConfig.decimals)
            : ZERO_DECIMAL;
        const baseTotal = botBaseTokenBalance.add(ooaBase);
        const quoteTotal = botQuoteTokenBalance.add(ooaQuote);

        // 1. Close open orders account
        if (openOrdersAccountInfo) {
            console.log(`Close open orders account ${openOrdersAccountKey.toString()}`);
            console.log(`Open orders base ${ooaBase}, quote ${ooaQuote}`);
            const closeOpenOrdersAccountPayload: TransactionPayload = {
                instructions: [
                    serumSettleFundsIx({
                        botSeed: params.botSeed,
                        userOrBotDelegateAccount: params.owner,
                        marketAccount: params.marketKey,
                        openOrdersAccount: openOrdersAccountKey,
                        botOrWorkingCapAccount: botKey,
                        botAccount: botKey,
                        coinVault: marketConfig.baseVault,
                        coinWalletAccount: botBaseATA,
                        pcVault: marketConfig.quoteVault,
                        pcWalletAccount: botQuoteATA,
                        vaultSigner: marketConfig.vaultSigner,
                        cellConfigAccount: cellConfigKey,
                        programId: params.programId,
                    }),
                    serumCloseOpenOrdersIx({
                        botSeed: params.botSeed,
                        userOrBotDelegateAccount: params.owner,
                        openOrdersAccount: openOrdersAccountKey,
                        botOrWorkingCapAccount: botKey,
                        botAccount: botKey,
                        userAccount: params.owner,
                        marketAccount: params.marketKey,
                        cellConfigAccount: cellConfigKey,
                        programId: params.programId,
                    }),
                ],
                signers: [],
            };
            payloads.push(closeOpenOrdersAccountPayload);
        } else {
            payloads.push(undefined);
        }

        // 2. Redeem all base & quote token from bot
        const redeemTokens: string[] = [];
        if (baseTotal.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${baseTotal} ${baseTokenConfig.name} from bot`);
            redeemTokens.push(baseTokenConfig.name);
        }
        if (quoteTotal.gt(ZERO_DECIMAL)) {
            console.log(`Redeem ${quoteTotal} ${quoteTokenConfig.name} from bot`);
            redeemTokens.push(quoteTokenConfig.name);
        }
        if (redeemTokens.length > 0) {
            const redeemAllFromBotPayload = await redeemAllFromBot(
                params.connection,
                params.botSeed,
                params.owner,
                params.referrer,
                params.cellAdmin,
                redeemTokens,
                params.programId,
            );
            payloads.push(redeemAllFromBotPayload);
        } else {
            payloads.push(undefined);
        }
        return payloads;
    }
}

'''
'''--- src/Bot/solana/ZetaFutureBot.ts ---
import {
    BotInfo,
    CancelOrderParams,
    CloseBotParams,
    GetBotInfoParams,
    GetOpenOrdersParams,
    OpenOrder,
    OrderSide,
    PlaceOrderParams,
    StopBotParams,
    SolanaTokenConfig,
    TransactionPayload,
    ZetaAssetConfig,
    ZetaFutureMarketConfig,
    ZetaOrderSide,
} from '../../type';
import {
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getBotZetaMarginAccountKeyBySeed,
    getBotZetaOpenOrdersAccountKey,
    getCellConfigAccountKey,
    getMarketPrice,
    getSerumOpenOrdersAccountInfo,
    getTokenConfigBySymbol,
    getZetaAssetConfigBySymbol,
    getZetaFutureMarketConfig,
    getZetaMarginAccount,
    getZetaOpenOrdersMapKey,
    nativeToUi,
    Numberu128,
    redeemAllFromBot,
    uiToNative,
    uiZetaPriceToNative,
    zetaOrderSideTransform,
    zetaOrderTypeTransform,
} from '../../util';
import { ZERO_DECIMAL, ZETA_DEX_PROGRAM_ID } from '../../constant';
import {
    cancelZetaOrderIx,
    closeZetaOpenOrdersIx,
    placeZetaOrderIx,
    settleZetaMarketIx,
    stopBotIx,
    withdrawFromZetaIx,
} from '../../instruction';
import { Market, Orderbook } from '@project-serum/serum';
import Decimal from 'decimal.js';

export class ZetaFutureBot {
    /*
     * returns [botSeed, dexAccountKey, orderOwnerKey, txPayload]
     */
    // static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
    //     const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
    //     const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
    //     const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
    //     const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;
    //
    //     const cellConfigKey = await getCellConfigAccountKey(params.programId);
    //     const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);
    //
    //     const ownerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
    //     const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
    //     const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
    //
    //     const dexAccountKey = await getBotZetaMarginAccountKeyBySeed(
    //         botSeed,
    //         assetConfig.groupAccount,
    //         params.programId,
    //     );
    //     const orderOwnerKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
    //     const zetaOpenOrdersMapKey = await getZetaOpenOrdersMapKey(orderOwnerKey).then((res) => res[0]);
    //
    //     const payload: TransactionPayload = {
    //         instructions: [
    //             createATAIx({
    //                 ataKey: botUSDCATA,
    //                 ownerKey: botKey,
    //                 mintKey: usdcConfig.mintKey,
    //                 payerKey: params.botOwner,
    //             }),
    //             createBotIx({
    //                 botSeed,
    //                 depositAssetQuantity: uiToNative(params.depositAssetQuantity, 6),
    //                 lowerPrice: uiToNative(params.lowerPrice, 6),
    //                 upperPrice: uiToNative(params.upperPrice, 6),
    //                 gridNum: params.gridNum,
    //                 marketKey: params.marketKey,
    //                 leverage: uiToNative(params.leverage, 2),
    //                 botKey,
    //                 botMintKey,
    //                 botAssetKey: botUSDCATA,
    //                 userAssetKey: ownerUSDCATA,
    //                 userBotTokenKey: ownerBotMintATA,
    //                 assetPriceKey: usdcConfig.pythPriceKey,
    //                 userKey: params.botOwner,
    //                 protocol: params.protocol,
    //                 botType: params.botType,
    //                 stopTopRatio: params.stopTopRatio,
    //                 stopBottomRatio: params.stopBottomRatio,
    //                 trigger: params.trigger,
    //                 isPool: false,
    //                 startPrice: uiToNative(params.startPrice, 6),
    //                 cellCacheAccount: cellCacheKey,
    //                 programId: params.programId,
    //             }),
    //             initZetaMarginAccountIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 zetaAccountOwnerAccount: botKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             initZetaOpenOrdersIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 openOrdersAccount: orderOwnerKey,
    //                 zetaMarginAccount: dexAccountKey,
    //                 marketAccount: params.marketKey,
    //                 openOrdersMapAccount: zetaOpenOrdersMapKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             depositToZetaIx({
    //                 botSeed,
    //                 amount: uiToNative(params.depositAssetQuantity, 6),
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 botTokenAccount: botUSDCATA,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 zetaVaultKey: assetConfig.vaultAccount,
    //                 zetaGreeksKey: assetConfig.greeksAccount,
    //                 zetaSocializedLossKey: assetConfig.socializedLossAccount,
    //                 programId: params.programId,
    //             }),
    //         ],
    //         signers: [],
    //     };
    //
    //     return [botSeed, dexAccountKey, orderOwnerKey, payload];
    // }

    static async stop(params: StopBotParams): Promise<TransactionPayload> {
        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const tokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const cellConfigAccount = await getCellConfigAccountKey(params.programId);

        return {
            instructions: [
                stopBotIx({
                    botSeed: params.botSeed,
                    botKey,
                    userKey: params.payer,
                    pythPriceAccount: tokenConfig.pythPriceKey,
                    cellConfigAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);

        const [market, bidsInfo, asksInfo] = await Promise.all([
            Market.load(params.connection, params.marketKey, {}, ZETA_DEX_PROGRAM_ID),
            params.connection.getAccountInfo(marketConfig.bids),
            params.connection.getAccountInfo(marketConfig.asks),
        ]);

        if (!bidsInfo || !asksInfo) {
            throw `Get open orders error: bids / asks not available`;
        }

        const bids = Orderbook.decode(market, bidsInfo.data);
        const asks = Orderbook.decode(market, asksInfo.data);

        return [...bids, ...asks]
            .filter((o) => o.openOrdersAddress.equals(zetaOpenOrdersAccountKey))
            .map((i) => {
                return {
                    price: new Decimal(i.price),
                    size: nativeToUi(new Decimal(i.size), marketConfig.orderQuantityDecimals),
                    side: i.side == 'buy' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: i.orderId.toString(),
                    clientId: i.clientId ? i.clientId.toString() : null,
                };
            });
    }

    static async getBotInfo(params: GetBotInfoParams): Promise<BotInfo> {
        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const tokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaMarginAccount = await getZetaMarginAccount(params.connection, zetaMarginAccountKey);

        const position = nativeToUi(
            new Decimal(zetaMarginAccount.productLedgers[marketConfig.marketIndex].position.size.toString()),
            3,
        );
        const costOfTrades = nativeToUi(
            new Decimal(zetaMarginAccount.productLedgers[marketConfig.marketIndex].position.costOfTrades.toString()),
            6,
        );
        const balance = nativeToUi(new Decimal(zetaMarginAccount.balance.toString()), 6);

        const marketPrice = await getMarketPrice(tokenConfig.name);

        let unrealizedPnl = ZERO_DECIMAL;
        if (position.gt(ZERO_DECIMAL)) {
            unrealizedPnl = position.mul(marketPrice).sub(costOfTrades);
        } else if (position.lt(ZERO_DECIMAL)) {
            unrealizedPnl = position.mul(marketPrice).add(costOfTrades);
        }

        return {
            value: balance.add(unrealizedPnl),
            position,
        };
    }

    static async placeOrder(params: PlaceOrderParams): Promise<TransactionPayload> {
        const side = zetaOrderSideTransform(params.side);
        const orderType = zetaOrderTypeTransform(params.orderType);

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);

        return {
            instructions: [
                placeZetaOrderIx({
                    botSeed: params.botSeed,
                    // TODO order book price with 4 decimal, tx price data need 6 decimal?
                    price: uiZetaPriceToNative(params.price),
                    size: uiToNative(params.quantity, marketConfig.orderQuantityDecimals),
                    side,
                    orderType,
                    clientOrderId: params.clientId,
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    orderPayerTokenAccount:
                        side == ZetaOrderSide.Bid ? marketConfig.zetaQuoteVault : marketConfig.zetaBaseVault,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    pcWallet: marketConfig.zetaQuoteVault,
                    coinWallet: marketConfig.zetaBaseVault,
                    zetaMarketNode: marketConfig.greekNodeKey,
                    zetaMarketMint: side == ZetaOrderSide.Bid ? marketConfig.quoteMint : marketConfig.baseMint,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    zetaGroupOracleKey: assetConfig.oracleAccount,
                    zetaGreeksKey: assetConfig.greeksAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async cancelOrder(params: CancelOrderParams): Promise<TransactionPayload> {
        const side = zetaOrderSideTransform(params.side);

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        return {
            instructions: [
                cancelZetaOrderIx({
                    botSeed: params.botSeed,
                    side,
                    orderId: new Numberu128(params.orderId),
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    /*
     * Requirement: 1. Zero position; 2. No open orders
     * 1. Close open orders account
     * 2. Redeem all USDC from Zeta
     * 3. Redeem all USDC from bot
     */
    static async close(params: CloseBotParams): Promise<(TransactionPayload | undefined)[]> {
        const payloads: (TransactionPayload | undefined)[] = [];

        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });
        if (openOrders.length > 0) {
            throw `Close bot error: open orders existed`;
        }

        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });

        if (!botInfo.position.eq(ZERO_DECIMAL)) {
            throw `Close bot error: position not zero`;
        }

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        const [zetaOpenOrdersMapKey, zetaOpenOrdersMapNonce] = await getZetaOpenOrdersMapKey(zetaOpenOrdersAccountKey);
        const openOrdersAccountInfo = await getSerumOpenOrdersAccountInfo(params.connection, zetaOpenOrdersAccountKey);

        // 1. Close open orders account
        if (openOrdersAccountInfo) {
            console.log(`Close open orders account ${zetaOpenOrdersAccountKey.toString()}`);
            const closeOOAPayload: TransactionPayload = {
                instructions: [
                    settleZetaMarketIx({
                        marketKey: params.marketKey,
                        baseVault: marketConfig.zetaBaseVault,
                        quoteVault: marketConfig.zetaQuoteVault,
                        dexBaseVault: marketConfig.baseVault,
                        dexQuoteVault: marketConfig.quoteVault,
                        vaultOwner: marketConfig.vaultOwner,
                        openOrdersAccount: zetaOpenOrdersAccountKey,
                    }),
                    closeZetaOpenOrdersIx({
                        botSeed: params.botSeed,
                        botAccount: botKey,
                        userOrBotDelegateAccount: params.owner,
                        zetaMarginAccount: zetaMarginAccountKey,
                        openOrdersAccount: zetaOpenOrdersAccountKey,
                        openOrdersMapAccount: zetaOpenOrdersMapKey,
                        openOrdersMapNonce: zetaOpenOrdersMapNonce,
                        marketAccount: params.marketKey,
                        cellConfigAccount,
                        zetaGroupKey: assetConfig.groupAccount,
                        userKey: params.owner,
                        programId: params.programId,
                    }),
                ],
                signers: [],
            };
            payloads.push(closeOOAPayload);
        } else {
            payloads.push(undefined);
        }

        // 2. Redeem all USDC from Zeta
        if (!botInfo.value.eq(ZERO_DECIMAL)) {
            console.log(`Redeem ${botInfo.value} USDC from Zeta`);
            const redeemAllFromDexPayload: TransactionPayload = {
                instructions: [
                    withdrawFromZetaIx({
                        botSeed: params.botSeed,
                        amount: uiToNative(botInfo.value, 6),
                        botAccount: botKey,
                        userOrBotDelegateAccount: params.owner,
                        zetaMarginAccount: zetaMarginAccountKey,
                        botTokenAccount: botUSDCATA,
                        cellConfigAccount,
                        zetaGroupKey: assetConfig.groupAccount,
                        zetaGroupOracleKey: assetConfig.oracleAccount,
                        zetaVaultKey: assetConfig.vaultAccount,
                        zetaGreeksKey: assetConfig.greeksAccount,
                        zetaSocializedLossKey: assetConfig.socializedLossAccount,
                        programId: params.programId,
                    }),
                ],
                signers: [],
            };
            payloads.push(redeemAllFromDexPayload);
        } else {
            payloads.push(undefined);
        }

        // 3. Redeem all USDC from bot
        const botUSDCBalance = await getATABalance(params.connection, botUSDCATA).then((res) => res.add(botInfo.value));
        if (!botUSDCBalance.eq(ZERO_DECIMAL)) {
            console.log(`Redeem ${botUSDCBalance} USDC from bot`);
            const redeemAllFromBotPayload = await redeemAllFromBot(
                params.connection,
                params.botSeed,
                params.owner,
                params.referrer,
                params.cellAdmin,
                ['USDC'],
                params.programId,
            );
            payloads.push(redeemAllFromBotPayload);
        } else {
            payloads.push(undefined);
        }
        return payloads;
    }
}

'''
'''--- src/Bot/solana/ZetaPerpBot.ts ---
import {
    BotInfo,
    CancelOrderParams,
    CloseBotParams,
    GetBotInfoParams,
    GetOpenOrdersParams,
    OpenOrder,
    OrderSide,
    PlaceOrderParams,
    StopBotParams,
    SolanaTokenConfig,
    TransactionPayload,
    ZetaAssetConfig,
    ZetaOrderSide,
    ZetaPerpMarketConfig,
} from '../../type';
import {
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getBotZetaMarginAccountKeyBySeed,
    getBotZetaOpenOrdersAccountKey,
    getCellConfigAccountKey,
    getMarketPrice,
    getSerumOpenOrdersAccountInfo,
    getTokenConfigBySymbol,
    getZetaAssetConfigBySymbol,
    getZetaMarginAccount,
    getZetaOpenOrdersMapKey,
    getZetaPerpMarketConfig,
    nativeToUi,
    Numberu128,
    redeemAllFromBot,
    uiToNative,
    uiZetaPriceToNative,
    zetaOrderSideTransform,
    zetaOrderTypeTransform,
} from '../../util';
import { ZERO_DECIMAL, ZETA_DEX_PROGRAM_ID } from '../../constant';
import {
    cancelZetaOrderIx,
    closeZetaOpenOrdersIx,
    placeZetaPerpOrderIx,
    settleZetaMarketIx,
    stopBotIx,
    withdrawFromZetaIx,
} from '../../instruction';
import { Market, Orderbook } from '@project-serum/serum';
import Decimal from 'decimal.js';

export class ZetaPerpBot {
    /*
     * returns [botSeed, dexAccountKey, orderOwnerKey, txPayload]
     */
    // static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
    //     const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
    //     const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
    //     const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
    //     const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;
    //
    //     const cellConfigKey = await getCellConfigAccountKey(params.programId);
    //     const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);
    //
    //     const ownerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
    //     const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
    //     const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
    //
    //     const dexAccountKey = await getBotZetaMarginAccountKeyBySeed(
    //         botSeed,
    //         assetConfig.groupAccount,
    //         params.programId,
    //     );
    //     const orderOwnerKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
    //     const zetaOpenOrdersMapKey = await getZetaOpenOrdersMapKey(orderOwnerKey).then((res) => res[0]);
    //
    //     const payload: TransactionPayload = {
    //         instructions: [
    //             createATAIx({
    //                 ataKey: botUSDCATA,
    //                 ownerKey: botKey,
    //                 mintKey: usdcConfig.mintKey,
    //                 payerKey: params.botOwner,
    //             }),
    //             createBotIx({
    //                 botSeed,
    //                 depositAssetQuantity: uiToNative(params.depositAssetQuantity, 6),
    //                 lowerPrice: uiToNative(params.lowerPrice, 6),
    //                 upperPrice: uiToNative(params.upperPrice, 6),
    //                 gridNum: params.gridNum,
    //                 marketKey: params.marketKey,
    //                 leverage: uiToNative(params.leverage, 2),
    //                 botKey,
    //                 botMintKey,
    //                 botAssetKey: botUSDCATA,
    //                 userAssetKey: ownerUSDCATA,
    //                 userBotTokenKey: ownerBotMintATA,
    //                 assetPriceKey: usdcConfig.pythPriceKey,
    //                 userKey: params.botOwner,
    //                 protocol: params.protocol,
    //                 botType: params.botType,
    //                 stopTopRatio: params.stopTopRatio,
    //                 stopBottomRatio: params.stopBottomRatio,
    //                 trigger: params.trigger,
    //                 isPool: false,
    //                 startPrice: uiToNative(params.startPrice, 6),
    //                 cellCacheAccount: cellCacheKey,
    //                 programId: params.programId,
    //             }),
    //             initZetaMarginAccountIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 zetaAccountOwnerAccount: botKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             initZetaOpenOrdersIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 openOrdersAccount: orderOwnerKey,
    //                 zetaMarginAccount: dexAccountKey,
    //                 marketAccount: params.marketKey,
    //                 openOrdersMapAccount: zetaOpenOrdersMapKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             depositToZetaIx({
    //                 botSeed,
    //                 amount: uiToNative(params.depositAssetQuantity, 6),
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 botTokenAccount: botUSDCATA,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 zetaVaultKey: assetConfig.vaultAccount,
    //                 zetaGreeksKey: assetConfig.greeksAccount,
    //                 zetaSocializedLossKey: assetConfig.socializedLossAccount,
    //                 programId: params.programId,
    //             }),
    //         ],
    //         signers: [],
    //     };
    //
    //     return [botSeed, dexAccountKey, orderOwnerKey, payload];
    // }

    static async stop(params: StopBotParams): Promise<TransactionPayload> {
        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const tokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const cellConfigAccount = await getCellConfigAccountKey(params.programId);

        return {
            instructions: [
                stopBotIx({
                    botSeed: params.botSeed,
                    botKey,
                    userKey: params.payer,
                    pythPriceAccount: tokenConfig.pythPriceKey,
                    cellConfigAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);

        const [market, bidsInfo, asksInfo] = await Promise.all([
            Market.load(params.connection, params.marketKey, {}, ZETA_DEX_PROGRAM_ID),
            params.connection.getAccountInfo(marketConfig.bids),
            params.connection.getAccountInfo(marketConfig.asks),
        ]);

        if (!bidsInfo || !asksInfo) {
            throw `Get open orders error: bids / asks not available`;
        }

        const bids = Orderbook.decode(market, bidsInfo.data);
        const asks = Orderbook.decode(market, asksInfo.data);

        return [...bids, ...asks]
            .filter((o) => o.openOrdersAddress.equals(zetaOpenOrdersAccountKey))
            .map((i) => {
                return {
                    price: new Decimal(i.price),
                    size: nativeToUi(new Decimal(i.size), marketConfig.orderQuantityDecimals),
                    side: i.side == 'buy' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: i.orderId.toString(),
                    clientId: i.clientId ? i.clientId.toString() : null,
                };
            });
    }

    static async getBotInfo(params: GetBotInfoParams): Promise<BotInfo> {
        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const tokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaMarginAccount = await getZetaMarginAccount(params.connection, zetaMarginAccountKey);

        const position = nativeToUi(new Decimal(zetaMarginAccount.perpProductLedger.position.size.toString()), 3);
        const costOfTrades = nativeToUi(
            new Decimal(zetaMarginAccount.perpProductLedger.position.costOfTrades.toString()),
            6,
        );
        const balance = nativeToUi(new Decimal(zetaMarginAccount.balance.toString()), 6);

        const marketPrice = await getMarketPrice(tokenConfig.name);

        let unrealizedPnl = ZERO_DECIMAL;
        if (position.gt(ZERO_DECIMAL)) {
            unrealizedPnl = position.mul(marketPrice).sub(costOfTrades);
        } else if (position.lt(ZERO_DECIMAL)) {
            unrealizedPnl = position.mul(marketPrice).add(costOfTrades);
        }

        return {
            value: balance.add(unrealizedPnl),
            position,
        };
    }

    static async placeOrder(params: PlaceOrderParams): Promise<TransactionPayload> {
        const side = zetaOrderSideTransform(params.side);
        const orderType = zetaOrderTypeTransform(params.orderType);

        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);

        return {
            instructions: [
                placeZetaPerpOrderIx({
                    botSeed: params.botSeed,
                    price: uiZetaPriceToNative(params.price),
                    size: uiToNative(params.quantity, marketConfig.orderQuantityDecimals),
                    side,
                    orderType,
                    clientOrderId: params.clientId,
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaGroupKey: assetConfig.groupAccount,
                    zetaMarginAccount: zetaMarginAccountKey,
                    zetaGreeksKey: assetConfig.greeksAccount,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    orderPayerTokenAccount:
                        side == ZetaOrderSide.Bid ? marketConfig.zetaQuoteVault : marketConfig.zetaBaseVault,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    coinWallet: marketConfig.zetaBaseVault,
                    pcWallet: marketConfig.zetaQuoteVault,
                    zetaGroupOracleKey: assetConfig.oracleAccount,
                    zetaMarketMint: side == ZetaOrderSide.Bid ? marketConfig.quoteMint : marketConfig.baseMint,
                    perpSyncQueue: assetConfig.perpSyncQueue,
                    cellConfigAccount: cellConfigAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async cancelOrder(params: CancelOrderParams): Promise<TransactionPayload> {
        const side = zetaOrderSideTransform(params.side);

        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        return {
            instructions: [
                cancelZetaOrderIx({
                    botSeed: params.botSeed,
                    side,
                    orderId: new Numberu128(params.orderId),
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    /*
     * Requirement: 1. Zero position; 2. No open orders
     * 1. Close open orders account
     * 2. Redeem all USDC from Zeta
     * 3. Redeem all USDC from bot
     */
    static async close(params: CloseBotParams): Promise<(TransactionPayload | undefined)[]> {
        const payloads: (TransactionPayload | undefined)[] = [];

        const openOrders = await this.getOpenOrders({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });
        if (openOrders.length > 0) {
            throw `Close bot error: open orders existed`;
        }

        const botInfo = await this.getBotInfo({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });

        if (!botInfo.position.eq(ZERO_DECIMAL)) {
            throw `Close bot error: position not zero`;
        }

        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        const [zetaOpenOrdersMapKey, zetaOpenOrdersMapNonce] = await getZetaOpenOrdersMapKey(zetaOpenOrdersAccountKey);
        const openOrdersAccountInfo = await getSerumOpenOrdersAccountInfo(params.connection, zetaOpenOrdersAccountKey);

        // 1. Close open orders account
        if (openOrdersAccountInfo) {
            console.log(`Close open orders account ${zetaOpenOrdersAccountKey.toString()}`);
            const closeOOAPayload: TransactionPayload = {
                instructions: [
                    settleZetaMarketIx({
                        marketKey: params.marketKey,
                        baseVault: marketConfig.zetaBaseVault,
                        quoteVault: marketConfig.zetaQuoteVault,
                        dexBaseVault: marketConfig.baseVault,
                        dexQuoteVault: marketConfig.quoteVault,
                        vaultOwner: marketConfig.vaultOwner,
                        openOrdersAccount: zetaOpenOrdersAccountKey,
                    }),
                    closeZetaOpenOrdersIx({
                        botSeed: params.botSeed,
                        botAccount: botKey,
                        userOrBotDelegateAccount: params.owner,
                        zetaMarginAccount: zetaMarginAccountKey,
                        openOrdersAccount: zetaOpenOrdersAccountKey,
                        openOrdersMapAccount: zetaOpenOrdersMapKey,
                        openOrdersMapNonce: zetaOpenOrdersMapNonce,
                        marketAccount: params.marketKey,
                        cellConfigAccount,
                        zetaGroupKey: assetConfig.groupAccount,
                        userKey: params.owner,
                        programId: params.programId,
                    }),
                ],
                signers: [],
            };
            payloads.push(closeOOAPayload);
        } else {
            payloads.push(undefined);
        }

        // 2. Redeem all USDC from Zeta
        if (!botInfo.value.eq(ZERO_DECIMAL)) {
            console.log(`Redeem ${botInfo.value} USDC from Zeta`);
            const redeemAllFromDexPayload: TransactionPayload = {
                instructions: [
                    withdrawFromZetaIx({
                        botSeed: params.botSeed,
                        amount: uiToNative(botInfo.value, 6),
                        botAccount: botKey,
                        userOrBotDelegateAccount: params.owner,
                        zetaMarginAccount: zetaMarginAccountKey,
                        botTokenAccount: botUSDCATA,
                        cellConfigAccount,
                        zetaGroupKey: assetConfig.groupAccount,
                        zetaGroupOracleKey: assetConfig.oracleAccount,
                        zetaVaultKey: assetConfig.vaultAccount,
                        zetaGreeksKey: assetConfig.greeksAccount,
                        zetaSocializedLossKey: assetConfig.socializedLossAccount,
                        programId: params.programId,
                    }),
                ],
                signers: [],
            };
            payloads.push(redeemAllFromDexPayload);
        } else {
            payloads.push(undefined);
        }

        // 3. Redeem all USDC from bot
        const botUSDCBalance = await getATABalance(params.connection, botUSDCATA).then((res) => res.add(botInfo.value));
        if (!botUSDCBalance.eq(ZERO_DECIMAL)) {
            console.log(`Redeem ${botUSDCBalance} USDC from bot`);
            const redeemAllFromBotPayload = await redeemAllFromBot(
                params.connection,
                params.botSeed,
                params.owner,
                params.referrer,
                params.cellAdmin,
                ['USDC'],
                params.programId,
            );
            payloads.push(redeemAllFromBotPayload);
        } else {
            payloads.push(undefined);
        }
        return payloads;
    }
}

'''
'''--- src/Bot/solana/index.ts ---
import {
    BotInfo,
    CancelOrderParams,
    CloseBotParams,
    CloseSolanaBotMarketParams,
    CreateBotParams,
    GetBotInfoParams,
    GetOpenOrdersParams,
    OpenOrder,
    PlaceOrderParams,
    Protocol,
    SetReferrerParams,
    StartBotParams,
    StopBotParams,
    TransactionPayload,
} from '../../type';
import { Connection, PublicKey } from '@solana/web3.js';
import { ZetaFutureBot } from './ZetaFutureBot';
import { ZetaPerpBot } from './ZetaPerpBot';
import { botProtocolEnumToStr, getBotKeyBySeed, getCellConfigAccountKey, nativeToUi } from '../../util';
import {
    cellConfigReallocIx,
    createCellConfigAccountIx,
    setBotReferrerkeyIx,
    setCellConfigIx,
    startBotIx,
} from '../../instruction';
import { BotAccount, botAccountLayout, CellConfigAccount, CellConfigAccountLayout } from '../../layout';
import { CellConfigAccountNotFoundError } from '../../error';
import { SerumBot } from './SerumBot';
import { MangoSpotBot } from './MangoSpotBot';
import { MangoPerpBot } from './MangoPerpBot';

export class SolanaBot {
    static async load(connection: Connection, botSeed: Uint8Array, programId: PublicKey): Promise<BotAccount> {
        const botKey = await getBotKeyBySeed(botSeed, programId);
        const accountInfo = await connection.getAccountInfo(botKey);
        if (!accountInfo) {
            throw `Load bot error: ${botKey.toString()} account not found`;
        }
        const bot = botAccountLayout('').decode(accountInfo.data, 0);
        return {
            ...bot,
            amount: nativeToUi(bot.amount, 6),
            lowerPrice: nativeToUi(bot.lowerPrice, 6),
            upperPrice: nativeToUi(bot.upperPrice, 6),
            leverage: nativeToUi(bot.leverage, 2),
            startPrice: nativeToUi(bot.startPrice, 6),
        };
    }

    static async loadAll(connection: Connection, programId: PublicKey): Promise<BotAccount[]> {
        const bots: BotAccount[] = [];

        const accounts = await connection.getProgramAccounts(programId);
        for (const account of accounts) {
            if (account.account.data.length == botAccountLayout()['span']) {
                const bot = botAccountLayout('').decode(account.account.data, 0);
                bots.push({
                    ...bot,
                    amount: nativeToUi(bot.amount, 6),
                    lowerPrice: nativeToUi(bot.lowerPrice, 6),
                    upperPrice: nativeToUi(bot.upperPrice, 6),
                    leverage: nativeToUi(bot.leverage, 2),
                    startPrice: nativeToUi(bot.startPrice, 6),
                });
            }
        }

        return bots;
    }

    static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
        switch (params.protocol) {
            // case Protocol.ZetaFuture:
            //     return ZetaFutureBot.create(params);
            // case Protocol.ZetaPerp:
            //     return ZetaPerpBot.create(params);
            case Protocol.Serum:
                return SerumBot.create(params);
            default:
                throw `Create bot error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async start(params: StartBotParams): Promise<TransactionPayload> {
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        return {
            instructions: [
                startBotIx({
                    botSeed: params.botSeed,
                    botKey,
                    userKey: params.payer,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async stop(params: StopBotParams): Promise<TransactionPayload> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.stop(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.stop(params);
            case Protocol.Serum:
                return SerumBot.stop(params);
            default:
                throw `Stop bot error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async setReferrer(params: SetReferrerParams): Promise<TransactionPayload> {
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        return {
            instructions: [
                setBotReferrerkeyIx({
                    botSeed: params.botSeed,
                    referrerKey: params.referrer,
                    botKey: botKey,
                    userKey: params.userKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async getBotInfo(params: GetBotInfoParams): Promise<BotInfo> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.getBotInfo(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.getBotInfo(params);
            case Protocol.Serum:
                return SerumBot.getBotInfo(params);
            default:
                throw `Get bot info error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.getOpenOrders(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.getOpenOrders(params);
            case Protocol.Serum:
                return SerumBot.getOpenOrders(params);
            default:
                throw `Get open orders error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async placeOrder(params: PlaceOrderParams): Promise<TransactionPayload> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.placeOrder(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.placeOrder(params);
            case Protocol.Serum:
                return SerumBot.placeOrder(params);
            default:
                throw `Place order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async cancelOrder(params: CancelOrderParams): Promise<TransactionPayload> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.cancelOrder(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.cancelOrder(params);
            case Protocol.Serum:
                return SerumBot.cancelOrder(params);
            default:
                throw `Cancel order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async closeMarket(params: CloseSolanaBotMarketParams): Promise<TransactionPayload | undefined> {
        switch (params.protocol) {
            case Protocol.Serum:
                return SerumBot.closeMarket(params);
            default:
                throw `Close market error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async close(params: CloseBotParams): Promise<(TransactionPayload | undefined)[]> {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFutureBot.close(params);
            case Protocol.ZetaPerp:
                return ZetaPerpBot.close(params);
            case Protocol.Serum:
                return SerumBot.close(params);
            case Protocol.MangoSpot:
                return MangoSpotBot.close(params);
            case Protocol.MangoPerp:
                return MangoPerpBot.close(params);
            default:
                throw `Close bot error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }
}

export class SolanaCellConfig {
    static async load(connection: Connection, programId: PublicKey): Promise<CellConfigAccount> {
        const cellConfigKey = await getCellConfigAccountKey(programId);
        const accountInfo = await connection.getAccountInfo(cellConfigKey);
        if (!accountInfo) {
            throw new CellConfigAccountNotFoundError(cellConfigKey.toString());
        }
        const cellConfigAccount = CellConfigAccountLayout.decode(accountInfo.data);
        return {
            ...cellConfigAccount,
            createBotLine: cellConfigAccount.createBotLine.toNumber(),
            stopBotLine: cellConfigAccount.stopBotLine.toNumber(),
            reserveFreq: cellConfigAccount.reserveFreq.toNumber(),
            reserveRatio: cellConfigAccount.reserveRatio / Math.pow(10, 2),
            performanceFeeRatio: cellConfigAccount.performanceFeeRatio / Math.pow(10, 2),
            botOwnerMostPerformanceFeeRatio: cellConfigAccount.botOwnerMostPerformanceFeeRatio / Math.pow(10, 2),
            performanceFeeDiscount: cellConfigAccount.performanceFeeDiscount / Math.pow(10, 2),
            referrerPerformanceFeeRatio: cellConfigAccount.referrerPerformanceFeeRatio / Math.pow(10, 2),
        };
    }

    static async create(adminAccount: PublicKey, payer: PublicKey, programId: PublicKey): Promise<TransactionPayload> {
        const cellConfigKey = await getCellConfigAccountKey(programId);
        return {
            instructions: [
                createCellConfigAccountIx({
                    adminAccount,
                    payerAccount: payer,
                    cellConfigKey,
                    programId,
                }),
            ],
            signers: [],
        };
    }

    static async setConfig(
        adminAccount: PublicKey,
        delegate: PublicKey,
        createBotLine: number,
        stopBotLine: number,
        reserveFreq: number,
        reserveRatio: number,
        performanceFeeRatio: number,
        botOwnerMostPerformanceFeeRatio: number,
        performanceFeeDiscount: number,
        referrerPerformanceFeeRatio: number,
        programId: PublicKey,
    ): Promise<TransactionPayload> {
        const cellConfigAccount = await getCellConfigAccountKey(programId);
        return {
            instructions: [
                setCellConfigIx({
                    delegate,
                    createBotLine,
                    stopBotLine,
                    reserveFreq,
                    reserveRatio: reserveRatio * Math.pow(10, 2),
                    performanceFeeRatio: performanceFeeRatio * Math.pow(10, 2),
                    botOwnerMostPerformanceFeeRatio: botOwnerMostPerformanceFeeRatio * Math.pow(10, 2),
                    performanceFeeDiscount: performanceFeeDiscount * Math.pow(10, 2),
                    referrerPerformanceFeeRatio: referrerPerformanceFeeRatio * Math.pow(10, 2),
                    cellConfigAccount,
                    adminAccount,
                    programId,
                }),
            ],
            signers: [],
        };
    }

    static async reallocate(
        addSize: number,
        adminAccount: PublicKey,
        programId: PublicKey,
    ): Promise<TransactionPayload> {
        const cellConfigAccount = await getCellConfigAccountKey(programId);
        return {
            instructions: [
                cellConfigReallocIx({
                    addSize,
                    cellConfigAccount,
                    adminAccount,
                    programId,
                }),
            ],
            signers: [],
        };
    }
}

'''
'''--- src/Pool/index.ts ---
export * from './solana';

'''
'''--- src/Pool/solana/SerumPool.ts ---
import {
    AdjustPoolReserveParams,
    CancelOrderParams,
    CreateBotParams,
    DepositPoolParams,
    GetOpenOrdersParams,
    GetPoolInfoParams,
    OpenOrder,
    OrderSide,
    PlaceOrderParams,
    PoolInfo,
    RedeemPoolParams,
    SerumMarketConfig,
    SolanaTokenConfig,
    TransactionPayload,
} from '../../type';
import {
    createATA,
    genValidBotAccount,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getBotMintKeyBySeed2,
    getCellCacheKey,
    getCellConfigAccountKey,
    getMarketPrice,
    getSerumMarketConfig,
    getSerumOpenOrdersAccountInfo,
    getSerumOpenOrdersAccountKey,
    getSerumPoolWorkingCapKey,
    getTokenConfigBySymbol,
    nativeToUi,
    serumOrderTypeTransform,
    uiToNative,
} from '../../util';
import {
    createATAIx,
    createBotIx,
    serumCancelOrderIx,
    serumInitOpenOrdersIx,
    serumPlaceOrderIx,
    serumPoolAdjustReserveIx,
    serumPoolDepositIx,
    serumPoolWithdrawIx,
    serumSettleFundsIx,
} from '../../instruction';
import { PublicKey } from '@solana/web3.js';
import { SERUM_PROGRAM_ID, ZERO_DECIMAL } from '../../constant';
import { Market, Orderbook } from '@project-serum/serum';
import Decimal from 'decimal.js';

export class SerumPool {
    /*
     * txPayload: [createBotQuoteTokenATA, createBotBaseTokenATA, createBotIx, createSerumOpenOrdersIx]
     * returns [botSeed, workingCapKey, orderOwnerKey, txPayload]
     */
    static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
        const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);

        const ownerUSDCATA = await getATAKey(params.botOwner, quoteTokenConfig.mintKey);
        const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
        const botQuoteTokenATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const botBaseTokenATA = await getATAKey(botKey, baseTokenConfig.mintKey);

        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const serumOpenOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);

        const payload: TransactionPayload = {
            instructions: [
                createATAIx({
                    ataKey: botBaseTokenATA,
                    ownerKey: botKey,
                    mintKey: baseTokenConfig.mintKey,
                    payerKey: params.botOwner,
                }),
                createATAIx({
                    ataKey: botQuoteTokenATA,
                    ownerKey: botKey,
                    mintKey: quoteTokenConfig.mintKey,
                    payerKey: params.botOwner,
                }),
                createBotIx({
                    botSeed,
                    depositBaseBalance: ZERO_DECIMAL,
                    depositQuoteBalance: uiToNative(params.depositQuoteBalance, 6),
                    lowerPrice: uiToNative(params.lowerPrice, 6),
                    upperPrice: uiToNative(params.upperPrice, 6),
                    gridNum: params.gridNum,
                    marketKey: params.marketKey,
                    leverage: uiToNative(params.leverage, 2),
                    isDualDeposit: false,
                    botKey,
                    botMintKey,
                    botAssetKeys: [botQuoteTokenATA],
                    userAssetKeys: [ownerUSDCATA],
                    userBotTokenKey: ownerBotMintATA,
                    assetPriceKeys: [quoteTokenConfig.pythPriceKey],
                    userKey: params.botOwner,
                    protocol: params.protocol,
                    botType: params.botType,
                    stopTopRatio: params.stopTopRatio,
                    stopBottomRatio: params.stopBottomRatio,
                    trigger: params.trigger,
                    isPool: true,
                    startPrice: uiToNative(params.startPrice, 6),
                    cellCacheAccount: cellCacheKey,
                    programId: params.programId,
                }),
                serumInitOpenOrdersIx({
                    botSeed,
                    userOrBotDelegateAccount: params.botOwner,
                    marketAccount: params.marketKey,
                    openOrdersAccount: serumOpenOrdersAccountKey,
                    botAccount: botKey,
                    botOrWorkingCapAccount: workingCapKey,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
        return [botSeed, workingCapKey, serumOpenOrdersAccountKey, payload];
    }

    static async deposit(params: DepositPoolParams): Promise<TransactionPayload> {
        const payload: TransactionPayload = { instructions: [], signers: [] };

        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);

        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const investorUSDCATA = await getATAKey(params.investor, quoteTokenConfig.mintKey);
        const [investorBotMintATA, createInvestorBotMintATAIx] = await createATA(
            params.connection,
            params.investor,
            botMintKey,
            params.investor,
        );
        if (createInvestorBotMintATAIx) {
            payload.instructions.push(createInvestorBotMintATAIx);
        }
        const [workingCapBaseATA, createWorkingCapBaseATAIx] = await createATA(
            params.connection,
            workingCapKey,
            baseTokenConfig.mintKey,
            params.investor,
        );
        if (createWorkingCapBaseATAIx) {
            payload.instructions.push(createWorkingCapBaseATAIx);
        }

        const [workingCapQuoteATA, createWorkingCapQuoteATAIx] = await createATA(
            params.connection,
            workingCapKey,
            quoteTokenConfig.mintKey,
            params.investor,
        );
        if (createWorkingCapQuoteATAIx) {
            payload.instructions.push(createWorkingCapQuoteATAIx);
        }

        payload.instructions.push(
            serumPoolDepositIx({
                botSeed: params.botSeed,
                amount: uiToNative(params.amount, 6),
                botAccount: botKey,
                botMintAccount: botMintKey,
                investorAccount: params.investor,
                investorAssetAccount: investorUSDCATA,
                investorBotTokenAccount: investorBotMintATA,
                botAssetAccount: botQuoteATA,
                workingCapAccount: workingCapKey,
                workingCapBaseTokenAccount: workingCapBaseATA,
                workingCapQuoteTokenAccount: workingCapQuoteATA,
                openOrdersAccount: openOrdersAccountKey,
                marketAccount: params.marketKey,
                cellCacheAccount: cellCacheKey,
                baseTokenPythPriceAccount: baseTokenConfig.pythPriceKey,
                quoteTokenPythPriceAccount: quoteTokenConfig.pythPriceKey,
                programId: params.programId,
            }),
        );
        return payload;
    }

    static async redeem(params: RedeemPoolParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);

        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const workingCapBaseATA = await getATAKey(workingCapKey, baseTokenConfig.mintKey);
        const workingCapQuoteATA = await getATAKey(workingCapKey, quoteTokenConfig.mintKey);
        const investorQuoteATA = await getATAKey(params.investor, quoteTokenConfig.mintKey);
        const investorBotMintATA = await getATAKey(params.investor, botMintKey);
        const botOwnerQuoteATA = await getATAKey(params.botOwner, quoteTokenConfig.mintKey);
        const cellAdminQuoteATA = await getATAKey(params.cellAdmin, quoteTokenConfig.mintKey);

        return {
            instructions: [
                serumPoolWithdrawIx({
                    botSeed: params.botSeed,
                    amount: uiToNative(params.amount, 6),
                    botAccount: botKey,
                    botMintAccount: botMintKey,
                    investorAccount: params.investor,
                    investorAssetAccount: investorQuoteATA,
                    investorBotTokenAccount: investorBotMintATA,
                    botAssetAccount: botQuoteATA,
                    cellCacheAccount: cellCacheKey,
                    cellConfigAccount: cellConfigKey,
                    cellAssetAccount: cellAdminQuoteATA,
                    botOwnerAssetAccount: botOwnerQuoteATA,
                    workingCapAccount: workingCapKey,
                    workingCapBaseTokenAccount: workingCapBaseATA,
                    workingCapQuoteTokenAccount: workingCapQuoteATA,
                    openOrdersAccount: openOrdersAccountKey,
                    marketAccount: params.marketKey,
                    baseTokenPythPriceAccount: baseTokenConfig.pythPriceKey,
                    quoteTokenPythPriceAccount: quoteTokenConfig.pythPriceKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async adjustReserve(params: AdjustPoolReserveParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);

        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const workingCapBaseATA = await getATAKey(workingCapKey, baseTokenConfig.mintKey);
        const workingCapQuoteATA = await getATAKey(workingCapKey, quoteTokenConfig.mintKey);
        return {
            instructions: [
                serumSettleFundsIx({
                    botSeed: params.botSeed,
                    userOrBotDelegateAccount: params.payer,
                    marketAccount: params.marketKey,
                    openOrdersAccount: openOrdersAccountKey,
                    botOrWorkingCapAccount: workingCapKey,
                    botAccount: botKey,
                    coinVault: marketConfig.baseVault,
                    coinWalletAccount: workingCapBaseATA,
                    pcVault: marketConfig.quoteVault,
                    pcWalletAccount: workingCapQuoteATA,
                    vaultSigner: marketConfig.vaultSigner,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
                serumPoolAdjustReserveIx({
                    botSeed: params.botSeed,
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    botAssetAccount: botQuoteATA,
                    workingCapAccount: workingCapKey,
                    workingCapBaseTokenAccount: workingCapBaseATA,
                    workingCapQuoteTokenAccount: workingCapQuoteATA,
                    openOrdersAccount: openOrdersAccountKey,
                    marketAccount: params.marketKey,
                    cellConfigAccount: cellConfigKey,
                    baseTokenPythPriceAccount: baseTokenConfig.pythPriceKey,
                    quoteTokenPythPriceAccount: quoteTokenConfig.pythPriceKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    /*
     * botValue = (basePrice * botBase) + (quotePrice * botQuote)
     * dexValue = (basePrice * (workingCapBase + ooaBase)) + (quotePrice * (workingCapQuote + ooaQuote))
     * position = workingCapBase + ooaBase
     */
    static async getPoolInfo(params: GetPoolInfoParams): Promise<PoolInfo> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);

        const botBaseATA = await getATAKey(botKey, baseTokenConfig.mintKey);
        const botQuoteATA = await getATAKey(botKey, quoteTokenConfig.mintKey);
        const workingCapBaseATA = await getATAKey(workingCapKey, baseTokenConfig.mintKey);
        const workingCapQuoteATA = await getATAKey(workingCapKey, quoteTokenConfig.mintKey);

        // TODO get multiple account by single connection
        const [
            basePrice,
            quotePrice,
            botBaseBalance,
            botQuoteBalance,
            workingCapBaseBalance,
            workingCapQuoteBalance,
            openOrdersAccountInfo,
        ] = await Promise.all([
            getMarketPrice(baseTokenConfig.name),
            getMarketPrice(quoteTokenConfig.name),
            getATABalance(params.connection, botBaseATA),
            getATABalance(params.connection, botQuoteATA),
            getATABalance(params.connection, workingCapBaseATA),
            getATABalance(params.connection, workingCapQuoteATA),
            getSerumOpenOrdersAccountInfo(params.connection, openOrdersAccountKey),
        ]);
        const ooaUiBaseTotal = openOrdersAccountInfo
            ? nativeToUi(openOrdersAccountInfo.baseTokenTotal, baseTokenConfig.decimals)
            : ZERO_DECIMAL;
        const ooaUiQuoteTotal = openOrdersAccountInfo
            ? nativeToUi(openOrdersAccountInfo.quoteTokenTotal, quoteTokenConfig.decimals)
            : ZERO_DECIMAL;

        const botValue = basePrice.mul(botBaseBalance).add(quotePrice.mul(botQuoteBalance));
        const dexValue = basePrice
            .mul(workingCapBaseBalance.add(ooaUiBaseTotal))
            .add(quotePrice.mul(workingCapQuoteBalance.add(ooaUiQuoteTotal)));
        const position = workingCapBaseBalance.add(ooaUiBaseTotal);
        return {
            botValue,
            dexValue,
            position,
        };
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);

        const [market, bidsInfo, asksInfo] = await Promise.all([
            Market.load(params.connection, params.marketKey, {}, SERUM_PROGRAM_ID),
            params.connection.getAccountInfo(marketConfig.bids),
            params.connection.getAccountInfo(marketConfig.asks),
        ]);

        if (!bidsInfo || !asksInfo) {
            throw `Get open orders error: bids / asks not available`;
        }

        const bids = Orderbook.decode(market, bidsInfo.data);
        const asks = Orderbook.decode(market, asksInfo.data);

        return [...bids, ...asks]
            .filter((o) => o.openOrdersAddress.equals(openOrdersAccountKey))
            .map((i) => {
                return {
                    price: new Decimal(i['price']),
                    size: new Decimal(i['size']),
                    side: i['side'] == 'buy' ? OrderSide.Bid : OrderSide.Ask,
                    orderId: i['orderId'].toString(),
                    clientId: i['clientId'] ? i['clientId'].toString() : null,
                };
            });
    }

    static async placeOrder(params: PlaceOrderParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;
        const baseTokenConfig = getTokenConfigBySymbol(marketConfig.baseSymbol) as SolanaTokenConfig;
        const quoteTokenConfig = getTokenConfigBySymbol(marketConfig.quoteSymbol) as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);
        const workingCapAssetATA =
            params.side == OrderSide.Bid
                ? await getATAKey(workingCapKey, quoteTokenConfig.mintKey)
                : await getATAKey(workingCapKey, baseTokenConfig.mintKey);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);

        const nativePrice = uiToNative(params.price, marketConfig.orderPriceDecimals);
        const size = params.side == OrderSide.Bid ? params.price.mul(params.quantity) : params.quantity;
        const nativeSize =
            params.side == OrderSide.Bid
                ? uiToNative(size, quoteTokenConfig.decimals)
                : uiToNative(size, baseTokenConfig.decimals);
        return {
            instructions: [
                serumPlaceOrderIx({
                    botSeed: params.botSeed,
                    side: params.side,
                    orderType: serumOrderTypeTransform(params.orderType),
                    limitPrice: nativePrice,
                    amountToTrade: nativeSize,
                    coinLotSize: marketConfig.baseLotSize,
                    pcLotSize: marketConfig.quoteLotSize,
                    clientOrderId: params.clientId,
                    userOrBotDelegateAccount: params.payer,
                    marketAccount: params.marketKey,
                    openOrdersAccount: openOrdersAccountKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    botOrWorkingCapAssetAccount: workingCapAssetATA,
                    botOrWorkingCapAccount: workingCapKey,
                    botAccount: botKey,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async cancelOrder(params: CancelOrderParams): Promise<TransactionPayload> {
        const marketConfig = getSerumMarketConfig(params.marketKey) as SerumMarketConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const workingCapKey = await getSerumPoolWorkingCapKey(botKey, params.programId);
        const openOrdersAccountKey = await getSerumOpenOrdersAccountKey(workingCapKey, params.programId);
        const cellConfigKey = await getCellConfigAccountKey(params.programId);
        return {
            instructions: [
                serumCancelOrderIx({
                    botSeed: params.botSeed,
                    side: params.side,
                    orderId: params.orderId,
                    userOrBotDelegateAccount: params.payer,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    openOrdersAccount: openOrdersAccountKey,
                    botOrWorkingCapAccount: workingCapKey,
                    botAccount: botKey,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount: cellConfigKey,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }
}

'''
'''--- src/Pool/solana/ZetaFuturePool.ts ---
import {
    AdjustPoolReserveParams,
    DepositPoolParams,
    GetPoolInfoParams,
    ModifyPoolOrderParams,
    PoolInfo,
    RedeemPoolParams,
    SolanaTokenConfig,
    TransactionPayload,
    ZetaAssetConfig,
    ZetaFutureMarketConfig,
    ZetaOrderSide,
} from '../../type';
import {
    createATA,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getBotMintKeyBySeed2,
    getBotZetaMarginAccountKeyBySeed,
    getBotZetaOpenOrdersAccountKey,
    getCellCacheKey,
    getCellConfigAccountKey,
    getTokenConfigBySymbol,
    getZetaAssetConfigBySymbol,
    getZetaFutureMarketConfig,
    Numberu128,
    uiToNative,
    uiZetaPriceToNative,
    zetaOrderSideTransform,
    zetaOrderTypeTransform,
} from '../../util';
import {
    cancelZetaOrderIx,
    placeZetaOrderIx,
    zetaPoolAdjustReserveIx,
    zetaPoolDepositIx,
    zetaPoolWithdrawIx,
} from '../../instruction';
import { ZetaFutureBot } from '../../Bot/solana/ZetaFutureBot';

export class ZetaFuturePool {
    /*
     * returns [botSeed, dexAccountKey, orderOwnerKey, txPayload]
     */
    // static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
    //     const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
    //     const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
    //     const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
    //     const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;
    //
    //     const cellConfigKey = await getCellConfigAccountKey(params.programId);
    //     const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);
    //
    //     const ownerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
    //     const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
    //     const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
    //
    //     const dexAccountKey = await getBotZetaMarginAccountKeyBySeed(
    //         botSeed,
    //         assetConfig.groupAccount,
    //         params.programId,
    //     );
    //     const orderOwnerKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
    //     const zetaOpenOrdersMapKey = await getZetaOpenOrdersMapKey(orderOwnerKey).then((res) => res[0]);
    //
    //     const payload: TransactionPayload = {
    //         instructions: [
    //             createATAIx({
    //                 ataKey: botUSDCATA,
    //                 ownerKey: botKey,
    //                 mintKey: usdcConfig.mintKey,
    //                 payerKey: params.botOwner,
    //             }),
    //             createBotIx({
    //                 botSeed,
    //                 depositAssetQuantity: uiToNative(params.depositAssetQuantity, 6),
    //                 lowerPrice: uiToNative(params.lowerPrice, 6),
    //                 upperPrice: uiToNative(params.upperPrice, 6),
    //                 gridNum: params.gridNum,
    //                 marketKey: params.marketKey,
    //                 leverage: uiToNative(params.leverage, 2),
    //                 botKey,
    //                 botMintKey,
    //                 botAssetKey: botUSDCATA,
    //                 userAssetKey: ownerUSDCATA,
    //                 userBotTokenKey: ownerBotMintATA,
    //                 assetPriceKey: usdcConfig.pythPriceKey,
    //                 userKey: params.botOwner,
    //                 protocol: params.protocol,
    //                 botType: params.botType,
    //                 stopTopRatio: params.stopTopRatio,
    //                 stopBottomRatio: params.stopBottomRatio,
    //                 trigger: params.trigger,
    //                 isPool: true,
    //                 startPrice: uiToNative(params.startPrice, 6),
    //                 cellCacheAccount: cellCacheKey,
    //                 programId: params.programId,
    //             }),
    //             initZetaMarginAccountIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 zetaAccountOwnerAccount: botKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             initZetaOpenOrdersIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 openOrdersAccount: orderOwnerKey,
    //                 zetaMarginAccount: dexAccountKey,
    //                 marketAccount: params.marketKey,
    //                 openOrdersMapAccount: zetaOpenOrdersMapKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             depositToZetaIx({
    //                 botSeed,
    //                 amount: uiToNative(params.depositAssetQuantity, 6),
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 botTokenAccount: botUSDCATA,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 zetaVaultKey: assetConfig.vaultAccount,
    //                 zetaGreeksKey: assetConfig.greeksAccount,
    //                 zetaSocializedLossKey: assetConfig.socializedLossAccount,
    //                 programId: params.programId,
    //             }),
    //         ],
    //         signers: [],
    //     };
    //
    //     return [botSeed, dexAccountKey, orderOwnerKey, payload];
    // }

    static async deposit(params: DepositPoolParams): Promise<TransactionPayload> {
        const payload: TransactionPayload = { instructions: [], signers: [] };

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const investorUSDCATA = await getATAKey(params.investor, usdcConfig.mintKey);
        const [investorBotMintATA, createInvestorBotMintATAIx] = await createATA(
            params.connection,
            params.investor,
            botMintKey,
            params.investor,
        );
        if (createInvestorBotMintATAIx) {
            payload.instructions.push(createInvestorBotMintATAIx);
        }

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );

        payload.instructions.push(
            zetaPoolDepositIx({
                botSeed: params.botSeed,
                amount: uiToNative(params.amount, 6),
                botAccount: botKey,
                botMintAccount: botMintKey,
                investorAccount: params.investor,
                investorAssetAccount: investorUSDCATA,
                investorBotTokenAccount: investorBotMintATA,
                botAssetAccount: botUSDCATA,
                cellCacheAccount: cellCacheKey,
                zetaMarginAccount: zetaMarginAccountKey,
                zetaGreeksAccount: assetConfig.greeksAccount,
                zetaGroupAccount: assetConfig.groupAccount,
                pythPriceAccount: usdcConfig.pythPriceKey,
                programId: params.programId,
            }),
        );

        return payload;
    }

    static async redeem(params: RedeemPoolParams): Promise<TransactionPayload> {
        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const investorBotMintATA = await getATAKey(params.investor, botMintKey);

        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);
        const cellConfigAccount = await getCellConfigAccountKey(params.programId);

        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const investorUSDCATA = await getATAKey(params.investor, usdcConfig.mintKey);
        const botOwnerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
        const cellUSDCATA = await getATAKey(params.cellAdmin, usdcConfig.mintKey);

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );

        return {
            signers: [],
            instructions: [
                zetaPoolWithdrawIx({
                    botSeed: params.botSeed,
                    amount: uiToNative(params.amount, 6),
                    botAccount: botKey,
                    botMintAccount: botMintKey,
                    investorAccount: params.investor,
                    investorAssetAccount: investorUSDCATA,
                    investorBotTokenAccount: investorBotMintATA,
                    botAssetAccount: botUSDCATA,
                    cellCacheAccount: cellCacheKey,
                    cellConfigAccount: cellConfigAccount,
                    cellAssetAccount: cellUSDCATA,
                    zetaMarginAccount: zetaMarginAccountKey,
                    zetaGreeksAccount: assetConfig.greeksAccount,
                    zetaGroupAccount: assetConfig.groupAccount,
                    pythPriceAccount: usdcConfig.pythPriceKey,
                    botOwnerAssetAccount: botOwnerUSDCATA,
                    programId: params.programId,
                }),
            ],
        };
    }

    static async adjustReserve(params: AdjustPoolReserveParams): Promise<TransactionPayload> {
        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        return {
            signers: [],
            instructions: [
                zetaPoolAdjustReserveIx({
                    botSeed: params.botSeed,
                    botAccount: botKey,
                    zetaGroupAccount: assetConfig.groupAccount,
                    zetaVaultAccount: assetConfig.vaultAccount,
                    zetaMarginAccount: zetaMarginAccountKey,
                    botAssetTokenAccount: botUSDCATA,
                    zetaGreeksAccount: assetConfig.greeksAccount,
                    zetaOracleAccount: assetConfig.oracleAccount,
                    zetaSocializedLossAccount: assetConfig.socializedLossAccount,
                    userOrBotDelegateAccount: params.payer,
                    cellConfigAccount,
                    pythPriceAccount: usdcConfig.pythPriceKey,
                    programId: params.programId,
                }),
            ],
        };
    }

    static async getPoolInfo(params: GetPoolInfoParams): Promise<PoolInfo> {
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const botUSDCBalance = await getATABalance(params.connection, botUSDCATA);

        const botInfo = await ZetaFutureBot.getBotInfo({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });
        return {
            botValue: botUSDCBalance,
            dexValue: botInfo.value,
            position: botInfo.position,
        };
    }

    static async modifyOrder(params: ModifyPoolOrderParams): Promise<TransactionPayload> {
        const zetaExistedOrderSide = zetaOrderSideTransform(params.existedOrderSide);
        const zetaNewOrderSide = zetaOrderSideTransform(params.newOrderSide);
        const zetaNewOrderType = zetaOrderTypeTransform(params.newOrderType);

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        return {
            instructions: [
                cancelZetaOrderIx({
                    botSeed: params.botSeed,
                    side: zetaExistedOrderSide,
                    orderId: new Numberu128(params.existedOrderId),
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    programId: params.programId,
                }),
                placeZetaOrderIx({
                    botSeed: params.botSeed,
                    price: uiZetaPriceToNative(params.newOrderPrice),
                    size: uiToNative(params.newOrderSize, marketConfig.orderQuantityDecimals),
                    side: zetaNewOrderSide,
                    orderType: zetaNewOrderType,
                    clientOrderId: params.newOrderClientId,
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    orderPayerTokenAccount:
                        zetaNewOrderSide == ZetaOrderSide.Bid
                            ? marketConfig.zetaQuoteVault
                            : marketConfig.zetaBaseVault,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    pcWallet: marketConfig.zetaQuoteVault,
                    coinWallet: marketConfig.zetaBaseVault,
                    zetaMarketNode: marketConfig.greekNodeKey,
                    zetaMarketMint:
                        zetaNewOrderSide == ZetaOrderSide.Bid ? marketConfig.quoteMint : marketConfig.baseMint,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    zetaGroupOracleKey: assetConfig.oracleAccount,
                    zetaGreeksKey: assetConfig.greeksAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }
}

'''
'''--- src/Pool/solana/ZetaPerpPool.ts ---
import {
    AdjustPoolReserveParams,
    DepositPoolParams,
    GetPoolInfoParams,
    ModifyPoolOrderParams,
    PoolInfo,
    RedeemPoolParams,
    SolanaTokenConfig,
    TransactionPayload,
    ZetaAssetConfig,
    ZetaFutureMarketConfig,
    ZetaOrderSide,
    ZetaPerpMarketConfig,
} from '../../type';
import {
    createATA,
    getATABalance,
    getATAKey,
    getBotKeyBySeed,
    getBotMintKeyBySeed2,
    getBotZetaMarginAccountKeyBySeed,
    getBotZetaOpenOrdersAccountKey,
    getCellCacheKey,
    getCellConfigAccountKey,
    getTokenConfigBySymbol,
    getZetaAssetConfigBySymbol,
    getZetaFutureMarketConfig,
    getZetaPerpMarketConfig,
    Numberu128,
    uiToNative,
    uiZetaPriceToNative,
    zetaOrderSideTransform,
    zetaOrderTypeTransform,
} from '../../util';
import {
    cancelZetaOrderIx,
    placeZetaPerpOrderIx,
    zetaPoolAdjustReserveIx,
    zetaPoolDepositIx,
    zetaPoolWithdrawIx,
} from '../../instruction';
import { ZetaPerpBot } from '../../Bot/solana/ZetaPerpBot';

export class ZetaPerpPool {
    /*
     * returns [botSeed, dexAccountKey, orderOwnerKey, txPayload]
     */
    // static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
    //     const [botSeed, botKey, botMintKey] = await genValidBotAccount(params.programId);
    //     const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
    //     const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
    //     const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;
    //
    //     const cellConfigKey = await getCellConfigAccountKey(params.programId);
    //     const cellCacheKey = await getCellCacheKey(botKey, params.botOwner, params.programId);
    //
    //     const ownerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
    //     const ownerBotMintATA = await getATAKey(params.botOwner, botMintKey);
    //     const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
    //
    //     const dexAccountKey = await getBotZetaMarginAccountKeyBySeed(
    //         botSeed,
    //         assetConfig.groupAccount,
    //         params.programId,
    //     );
    //     const orderOwnerKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
    //     const zetaOpenOrdersMapKey = await getZetaOpenOrdersMapKey(orderOwnerKey).then((res) => res[0]);
    //
    //     const payload: TransactionPayload = {
    //         instructions: [
    //             createATAIx({
    //                 ataKey: botUSDCATA,
    //                 ownerKey: botKey,
    //                 mintKey: usdcConfig.mintKey,
    //                 payerKey: params.botOwner,
    //             }),
    //             createBotIx({
    //                 botSeed,
    //                 depositAssetQuantity: uiToNative(params.depositAssetQuantity, 6),
    //                 lowerPrice: uiToNative(params.lowerPrice, 6),
    //                 upperPrice: uiToNative(params.upperPrice, 6),
    //                 gridNum: params.gridNum,
    //                 marketKey: params.marketKey,
    //                 leverage: uiToNative(params.leverage, 2),
    //                 botKey,
    //                 botMintKey,
    //                 botAssetKey: botUSDCATA,
    //                 userAssetKey: ownerUSDCATA,
    //                 userBotTokenKey: ownerBotMintATA,
    //                 assetPriceKey: usdcConfig.pythPriceKey,
    //                 userKey: params.botOwner,
    //                 protocol: params.protocol,
    //                 botType: params.botType,
    //                 stopTopRatio: params.stopTopRatio,
    //                 stopBottomRatio: params.stopBottomRatio,
    //                 trigger: params.trigger,
    //                 isPool: true,
    //                 startPrice: uiToNative(params.startPrice, 6),
    //                 cellCacheAccount: cellCacheKey,
    //                 programId: params.programId,
    //             }),
    //             initZetaMarginAccountIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 zetaAccountOwnerAccount: botKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             initZetaOpenOrdersIx({
    //                 botSeed,
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 openOrdersAccount: orderOwnerKey,
    //                 zetaMarginAccount: dexAccountKey,
    //                 marketAccount: params.marketKey,
    //                 openOrdersMapAccount: zetaOpenOrdersMapKey,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 programId: params.programId,
    //             }),
    //             depositToZetaIx({
    //                 botSeed,
    //                 amount: uiToNative(params.depositAssetQuantity, 6),
    //                 botAccount: botKey,
    //                 userOrBotDelegateAccount: params.botOwner,
    //                 zetaMarginAccount: dexAccountKey,
    //                 botTokenAccount: botUSDCATA,
    //                 cellConfigAccount: cellConfigKey,
    //                 zetaGroupKey: assetConfig.groupAccount,
    //                 zetaVaultKey: assetConfig.vaultAccount,
    //                 zetaGreeksKey: assetConfig.greeksAccount,
    //                 zetaSocializedLossKey: assetConfig.socializedLossAccount,
    //                 programId: params.programId,
    //             }),
    //         ],
    //         signers: [],
    //     };
    //
    //     return [botSeed, dexAccountKey, orderOwnerKey, payload];
    // }

    static async deposit(params: DepositPoolParams): Promise<TransactionPayload> {
        const payload: TransactionPayload = { instructions: [], signers: [] };

        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const investorUSDCATA = await getATAKey(params.investor, usdcConfig.mintKey);
        const [investorBotMintATA, createInvestorBotMintATAIx] = await createATA(
            params.connection,
            params.investor,
            botMintKey,
            params.investor,
        );
        if (createInvestorBotMintATAIx) {
            payload.instructions.push(createInvestorBotMintATAIx);
        }

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );

        payload.instructions.push(
            zetaPoolDepositIx({
                botSeed: params.botSeed,
                amount: uiToNative(params.amount, 6),
                botAccount: botKey,
                botMintAccount: botMintKey,
                investorAccount: params.investor,
                investorAssetAccount: investorUSDCATA,
                investorBotTokenAccount: investorBotMintATA,
                botAssetAccount: botUSDCATA,
                cellCacheAccount: cellCacheKey,
                zetaMarginAccount: zetaMarginAccountKey,
                zetaGreeksAccount: assetConfig.greeksAccount,
                zetaGroupAccount: assetConfig.groupAccount,
                pythPriceAccount: usdcConfig.pythPriceKey,
                programId: params.programId,
            }),
        );

        return payload;
    }

    static async redeem(params: RedeemPoolParams): Promise<TransactionPayload> {
        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botMintKey = await getBotMintKeyBySeed2(params.botSeed, params.programId);
        const investorBotMintATA = await getATAKey(params.investor, botMintKey);

        const cellCacheKey = await getCellCacheKey(botKey, params.investor, params.programId);
        const cellConfigAccount = await getCellConfigAccountKey(params.programId);

        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const investorUSDCATA = await getATAKey(params.investor, usdcConfig.mintKey);
        const botOwnerUSDCATA = await getATAKey(params.botOwner, usdcConfig.mintKey);
        const cellUSDCATA = await getATAKey(params.cellAdmin, usdcConfig.mintKey);

        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );

        return {
            signers: [],
            instructions: [
                zetaPoolWithdrawIx({
                    botSeed: params.botSeed,
                    amount: uiToNative(params.amount, 6),
                    botAccount: botKey,
                    botMintAccount: botMintKey,
                    investorAccount: params.investor,
                    investorAssetAccount: investorUSDCATA,
                    investorBotTokenAccount: investorBotMintATA,
                    botAssetAccount: botUSDCATA,
                    cellCacheAccount: cellCacheKey,
                    cellConfigAccount: cellConfigAccount,
                    cellAssetAccount: cellUSDCATA,
                    zetaMarginAccount: zetaMarginAccountKey,
                    zetaGreeksAccount: assetConfig.greeksAccount,
                    zetaGroupAccount: assetConfig.groupAccount,
                    pythPriceAccount: usdcConfig.pythPriceKey,
                    botOwnerAssetAccount: botOwnerUSDCATA,
                    programId: params.programId,
                }),
            ],
        };
    }

    static async adjustReserve(params: AdjustPoolReserveParams): Promise<TransactionPayload> {
        const marketConfig = getZetaPerpMarketConfig(params.marketKey) as ZetaPerpMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        return {
            signers: [],
            instructions: [
                zetaPoolAdjustReserveIx({
                    botSeed: params.botSeed,
                    botAccount: botKey,
                    zetaGroupAccount: assetConfig.groupAccount,
                    zetaVaultAccount: assetConfig.vaultAccount,
                    zetaMarginAccount: zetaMarginAccountKey,
                    botAssetTokenAccount: botUSDCATA,
                    zetaGreeksAccount: assetConfig.greeksAccount,
                    zetaOracleAccount: assetConfig.oracleAccount,
                    zetaSocializedLossAccount: assetConfig.socializedLossAccount,
                    userOrBotDelegateAccount: params.payer,
                    cellConfigAccount,
                    pythPriceAccount: usdcConfig.pythPriceKey,
                    programId: params.programId,
                }),
            ],
        };
    }

    static async getPoolInfo(params: GetPoolInfoParams): Promise<PoolInfo> {
        const usdcConfig = getTokenConfigBySymbol('USDC') as SolanaTokenConfig;

        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const botUSDCATA = await getATAKey(botKey, usdcConfig.mintKey);
        const botUSDCBalance = await getATABalance(params.connection, botUSDCATA);

        const botInfo = await ZetaPerpBot.getBotInfo({
            protocol: params.protocol,
            connection: params.connection,
            botSeed: params.botSeed,
            marketKey: params.marketKey,
            programId: params.programId,
        });
        return {
            botValue: botUSDCBalance,
            dexValue: botInfo.value,
            position: botInfo.position,
        };
    }

    static async modifyOrder(params: ModifyPoolOrderParams): Promise<TransactionPayload> {
        const zetaExistedOrderSide = zetaOrderSideTransform(params.existedOrderSide);
        const zetaNewOrderSide = zetaOrderSideTransform(params.newOrderSide);
        const zetaNewOrderType = zetaOrderTypeTransform(params.newOrderType);

        const marketConfig = getZetaFutureMarketConfig(params.marketKey) as ZetaFutureMarketConfig;
        const assetConfig = getZetaAssetConfigBySymbol(marketConfig.baseSymbol) as ZetaAssetConfig;

        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        const zetaMarginAccountKey = await getBotZetaMarginAccountKeyBySeed(
            params.botSeed,
            assetConfig.groupAccount,
            params.programId,
        );
        const zetaOpenOrdersAccountKey = await getBotZetaOpenOrdersAccountKey(botKey, params.marketKey);
        return {
            instructions: [
                cancelZetaOrderIx({
                    botSeed: params.botSeed,
                    side: zetaExistedOrderSide,
                    orderId: new Numberu128(params.existedOrderId),
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaMarginAccount: zetaMarginAccountKey,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    eventQueueAccount: marketConfig.eventQueue,
                    cellConfigAccount,
                    zetaGroupKey: assetConfig.groupAccount,
                    programId: params.programId,
                }),
                placeZetaPerpOrderIx({
                    botSeed: params.botSeed,
                    price: uiZetaPriceToNative(params.newOrderPrice),
                    size: uiToNative(params.newOrderSize, marketConfig.orderQuantityDecimals),
                    side: zetaNewOrderSide,
                    orderType: zetaNewOrderType,
                    clientOrderId: params.newOrderClientId,
                    botAccount: botKey,
                    userOrBotDelegateAccount: params.payer,
                    zetaGroupKey: assetConfig.groupAccount,
                    zetaMarginAccount: zetaMarginAccountKey,
                    zetaGreeksKey: assetConfig.greeksAccount,
                    openOrdersAccount: zetaOpenOrdersAccountKey,
                    marketAccount: params.marketKey,
                    requestQueueAccount: marketConfig.requestQueue,
                    eventQueueAccount: marketConfig.eventQueue,
                    bidsAccount: marketConfig.bids,
                    asksAccount: marketConfig.asks,
                    orderPayerTokenAccount:
                        zetaNewOrderSide == ZetaOrderSide.Bid
                            ? marketConfig.zetaQuoteVault
                            : marketConfig.zetaBaseVault,
                    coinVault: marketConfig.baseVault,
                    pcVault: marketConfig.quoteVault,
                    coinWallet: marketConfig.zetaBaseVault,
                    pcWallet: marketConfig.zetaQuoteVault,
                    zetaGroupOracleKey: assetConfig.oracleAccount,
                    zetaMarketMint:
                        zetaNewOrderSide == ZetaOrderSide.Bid ? marketConfig.quoteMint : marketConfig.baseMint,
                    perpSyncQueue: assetConfig.perpSyncQueue,
                    cellConfigAccount: cellConfigAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }
}

'''
'''--- src/Pool/solana/index.ts ---
import {
    AdjustPoolReserveParams,
    CancelOrderParams,
    CreateBotParams,
    DepositPoolParams,
    GetOpenOrdersParams,
    GetPoolInfoParams,
    ModifyPoolOrderParams,
    OpenOrder,
    PlaceOrderParams,
    Protocol,
    RedeemPoolParams,
    SetPoolWithdrawOnlyParams,
    TransactionPayload,
} from '../../type';
import { Connection, PublicKey } from '@solana/web3.js';
import { ZetaFuturePool } from './ZetaFuturePool';
import { ZetaPerpPool } from './ZetaPerpPool';
import { BotAccount } from '../../layout';
import { SolanaBot } from '../../Bot';
import { setPoolWithdrawOnlyIx } from '../../instruction';
import { botProtocolEnumToStr, getBotKeyBySeed, getCellConfigAccountKey } from '../../util';
import { SerumPool } from './SerumPool';

export class SolanaPool {
    static async load(connection: Connection, botSeed: Uint8Array, programId: PublicKey): Promise<BotAccount> {
        return SolanaBot.load(connection, botSeed, programId);
    }

    static async create(params: CreateBotParams): Promise<[Uint8Array, PublicKey, PublicKey, TransactionPayload]> {
        switch (params.protocol) {
            // case Protocol.ZetaFuture:
            //     return ZetaFuturePool.create(params);
            // case Protocol.ZetaPerp:
            //     return ZetaPerpPool.create(params);
            case Protocol.Serum:
                return SerumPool.create(params);
            default:
                throw `Create pool error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async deposit(params: DepositPoolParams) {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFuturePool.deposit(params);
            case Protocol.ZetaPerp:
                return ZetaPerpPool.deposit(params);
            case Protocol.Serum:
                return SerumPool.deposit(params);
            default:
                throw `Deposit pool error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async redeem(params: RedeemPoolParams) {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFuturePool.redeem(params);
            case Protocol.ZetaPerp:
                return ZetaPerpPool.redeem(params);
            case Protocol.Serum:
                return SerumPool.redeem(params);
            default:
                throw `Redeem pool error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async adjustReserve(params: AdjustPoolReserveParams) {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFuturePool.adjustReserve(params);
            case Protocol.ZetaPerp:
                return ZetaPerpPool.adjustReserve(params);
            case Protocol.Serum:
                return SerumPool.adjustReserve(params);
            default:
                throw `Adjust pool reserve error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async setWithdrawOnly(params: SetPoolWithdrawOnlyParams): Promise<TransactionPayload> {
        const cellConfigAccount = await getCellConfigAccountKey(params.programId);
        const botKey = await getBotKeyBySeed(params.botSeed, params.programId);
        return {
            instructions: [
                setPoolWithdrawOnlyIx({
                    botSeed: params.botSeed,
                    botAccount: botKey,
                    delegateAccount: params.payer,
                    cellConfigAccount,
                    programId: params.programId,
                }),
            ],
            signers: [],
        };
    }

    static async getPoolInfo(params: GetPoolInfoParams) {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFuturePool.getPoolInfo(params);
            case Protocol.ZetaPerp:
                return ZetaPerpPool.getPoolInfo(params);
            case Protocol.Serum:
                return SerumPool.getPoolInfo(params);
            default:
                throw `Get pool info error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async getOpenOrders(params: GetOpenOrdersParams): Promise<OpenOrder[]> {
        switch (params.protocol) {
            case Protocol.Serum:
                return SerumPool.getOpenOrders(params);
            default:
                throw `Get pool open orders error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async placeOrder(params: PlaceOrderParams) {
        switch (params.protocol) {
            case Protocol.Serum:
                return SerumPool.placeOrder(params);
            default:
                throw `Place pool order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async cancelOrder(params: CancelOrderParams) {
        switch (params.protocol) {
            case Protocol.Serum:
                return SerumPool.cancelOrder(params);
            default:
                throw `Cancel pool order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }

    static async modifyOrder(params: ModifyPoolOrderParams) {
        switch (params.protocol) {
            case Protocol.ZetaFuture:
                return ZetaFuturePool.modifyOrder(params);
            case Protocol.ZetaPerp:
                return ZetaPerpPool.modifyOrder(params);
            default:
                throw `Modify pool order error: unsupported protocol ${botProtocolEnumToStr(params.protocol)}`;
        }
    }
}

'''
'''--- src/Stragety/GridStrategy.ts ---
import { DualInvestment, BotType, GetDualInvestmentParams, GetGridsParams, Grid, GridRebalanceParams } from '../type';
import Decimal from 'decimal.js';
import { ZERO_DECIMAL } from '../constant';

export class GridStrategy {
    /*
     * gridSize = (amount * leverage) / (((lowerPrice + upperPrice) * gridNumber) / 2)
     * priceInterval = (upperPrice - lowerPrice) / (gridNumber - 1)
     */
    static getGrids(params: GetGridsParams): Grid[] {
        const gridSize = params.amount
            .mul(params.leverage)
            .div(params.lowerPrice.add(params.upperPrice).mul(params.gridNumber).div(new Decimal(2)));
        const priceInterval = params.upperPrice.sub(params.lowerPrice).div(params.gridNumber.sub(new Decimal(1)));

        const grids: Grid[] = [];
        for (let gridIndex = 0; gridIndex < params.gridNumber.toNumber(); gridIndex++) {
            const gridPrice = params.lowerPrice.add(priceInterval.mul(new Decimal(gridIndex)));
            grids.push({
                index: gridIndex,
                price: gridPrice,
                size: gridSize,
            });
        }
        return grids;
    }

    /*
     *  assumed zero position / balance when market price >= upper price
     *  return SUM(quantity) of grid between market price and upper price
     */
    static rebalanceLongBot(grids: Grid[], upperPrice: Decimal, marketPrice: Decimal): Decimal {
        if (marketPrice.gte(upperPrice) || grids.length == 0) {
            return ZERO_DECIMAL;
        }

        let orderNumber = 0;
        for (const grid of grids) {
            if (grid.price.gte(marketPrice) && grid.price.lte(upperPrice)) {
                orderNumber += 1;
            }
        }
        return new Decimal(orderNumber).mul(grids[0].size);
    }

    /*
     * assumed zero position / balance when market price equal or less than lower price
     * return -SUM(quantity) of grids between lower price and market price
     */
    static rebalanceShortBot(grids: Grid[], lowerPrice: Decimal, marketPrice: Decimal): Decimal {
        if (marketPrice.lte(lowerPrice) || grids.length == 0) {
            return ZERO_DECIMAL;
        }

        let orderNumber = 0;
        for (const grid of grids) {
            if (grid.price.gte(lowerPrice) && grid.price.lte(marketPrice)) {
                orderNumber += 1;
            }
        }
        return new Decimal(orderNumber).mul(grids[0].size).neg();
    }

    /*
     * return SUM(quantity) of grid's' between startPrice and marketPrice
     * negative position / balance if marketPrice > startPrice
     * positive position / balance if startPrice > marketPrice
     */
    static rebalanceNeutralBot(grids: Grid[], startPrice: Decimal, marketPrice: Decimal): Decimal {
        if (startPrice.eq(marketPrice) || grids.length == 0) {
            return ZERO_DECIMAL;
        }
        const lowerPrice = Decimal.min(startPrice, marketPrice);
        const upperPrice = Decimal.max(startPrice, marketPrice);
        const direction = startPrice.gt(marketPrice) ? new Decimal(1) : new Decimal(-1);

        let orderNumber = 0;
        for (const grid of grids) {
            if (grid.price.gt(lowerPrice) && grid.price.lt(upperPrice)) {
                orderNumber += 1;
            }
        }
        return new Decimal(orderNumber).mul(grids[0].size).mul(direction);
    }

    /*
     * return bot position as it should be by bot params & market price
     */
    static rebalance(params: GridRebalanceParams): Decimal {
        const grids = this.getGrids(params);
        switch (params.botType) {
            case BotType.Long:
                return this.rebalanceLongBot(grids, params.upperPrice, params.marketPrice);
            case BotType.Short:
                return this.rebalanceShortBot(grids, params.lowerPrice, params.marketPrice);
            case BotType.Neutral:
                return this.rebalanceNeutralBot(grids, params.startPrice, params.marketPrice);
            case BotType.EnhancedNeutral:
                return ZERO_DECIMAL;
        }
    }

    /*
     * Estimate the amount of investment required when creating a bot using dual tokens
     * ONLY support SPOT LONG bot
     */
    static getDualInvestment(params: GetDualInvestmentParams): DualInvestment {
        const grids = this.getGrids({
            amount: new Decimal(1),
            leverage: new Decimal(1),
            lowerPrice: params.lowerPrice,
            upperPrice: params.upperPrice,
            gridNumber: params.gridNumber,
        });
        // number of grids which price lower than market price
        const lowerGridsNumber = grids.filter((grid) => grid.price.lt(params.marketPrice)).length;

        const quoteTokenRatio = new Decimal(lowerGridsNumber).div(params.gridNumber);
        const baseTokenRatio = new Decimal(1).sub(quoteTokenRatio);
        if (quoteTokenRatio.eq(ZERO_DECIMAL)) {
            throw `Get dual investment error: zero quote token ratio`;
        }

        const baseValue = params.quoteBalance.div(quoteTokenRatio).mul(baseTokenRatio);
        const baseBalance = baseValue.div(params.marketPrice);

        return {
            baseBalance,
            quoteBalance: params.quoteBalance,
        };
    }
}

'''
'''--- src/Stragety/index.ts ---
export * from './GridStrategy';

'''
'''--- src/constant/coingecko.constant.ts ---
export const COIN_GECKO_TOKEN_MAP = {
    AURORA: 'aurora-near',
    REF: 'ref-finance',
    USDT: 'tether',
    SOL: 'solana',
    ETH: 'ethereum',
    wETH: 'ethereum',
    BTC: 'bitcoin',
    FTT: 'ftx-token',
    MNGO: 'mango-markets',
    AVAX: 'avalanche-2',
    RAY: 'raydium',
    BNB: 'binancecoin',
    GMT: 'stepn',
    SRM: 'serum',
    MSOL: 'msol',
    ADA: 'cardano',
    NEAR: 'near',
    USDC: 'usd-coin',
    stSOL: 'lido-staked-sol',
    ARB: 'arb-protocol'
};

'''
'''--- src/constant/index.ts ---
export * from './solana';
export * from './near';

'''
'''--- src/constant/near/common.constant.ts ---
import BN from 'bn.js';
import { NearEnvConfig, NearNetworkId } from '../../type';

export const ONE_NEAR_YOCTO = new BN(10).pow(new BN(24));
export const ONE_TGAS = new BN(Math.pow(10, 12));
export const DEFAULT_GAS = ONE_TGAS.muln(300);
export const ZERO_BN = new BN(0);

export const BOT_CONTRACT_STORAGE_NEAR = 5;

export const NEAR_ENV: NearEnvConfig[] = [
    {
        networkId: NearNetworkId.mainnet,
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
    },
    {
        networkId: NearNetworkId.testnet,
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
    },
];

'''
'''--- src/constant/near/index.ts ---
export * from './common.constant';
export * from './token.constant';
export * from './tonic.constant';
export * from './ref.constant';
export * from './spin.constant';

export const NEAR_CONTRACT_ID = {
    DEV: 'app10.hipodev.near',
    PROD: 'v1.cellfi-prod.near',
    REF: 'app10.cellfi.testnet',
};

'''
'''--- src/constant/near/ref.constant.ts ---
import { RefPoolConfig } from '../../type';

// testnet contract ID
export const REF_CONTRACT_ID = 'dcl.ref-dev.testnet';

export const REF_POOLS: RefPoolConfig[] = [
    // testnet pool
    {
        name: 'REF/wNEAR',
        poolId: 'ref.fakes.testnet|wrap.testnet|400',
        tokenXSymbol: 'REF',
        tokenYSymbol: 'wNEAR',
        pointDelta: 8,
        fee: 400,
    },
    // testnet pool
    {
        name: 'REF/USDT',
        poolId: 'ref.fakes.testnet|usdt.fakes.testnet|2000',
        tokenXSymbol: 'REF',
        tokenYSymbol: 'USDT',
        pointDelta: 40,
        fee: 2000,
    },
];

'''
'''--- src/constant/near/spin.constant.ts ---
import { SpinPerpMarketConfig, SpinSpotMarketConfig } from '../../type';

export const SPIN_SPOT_CONTRACT_ID = 'spot.spin-fi.near';
export const SPIN_PERP_CONTRACT_ID = 'v2_0_2.perp.spin-fi.near';

export const SPIN_SPOT_MARKETS: SpinSpotMarketConfig[] = [
    {
        name: 'NEAR/USDC',
        marketId: '1',
        baseSymbol: 'NEAR',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
    },
];

export const SPIN_PERP_MARKETS: SpinPerpMarketConfig[] = [
    {
        name: 'NEAR-PERP',
        marketId: '1',
        leverage: 10,
        baseSymbol: 'NEAR',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
    },
];

'''
'''--- src/constant/near/token.constant.ts ---
import { NearTokenConfig } from '../../type';

export const NEAR_TOKENS: NearTokenConfig[] = [
    { symbol: 'NEAR', accountId: 'NEAR', decimals: 24 },
    {
        symbol: 'USDC',
        accountId: 'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near',
        decimals: 6,
    },
    {
        symbol: 'USN',
        accountId: 'usn',
        decimals: 18,
    },
    {
        symbol: 'STNEAR',
        accountId: 'meta-pool',
        decimals: 24,
    },
    {
        symbol: 'PEM',
        accountId: 'token.pembrock.near',
        decimals: 18,
    },
    {
        symbol: 'PARAS',
        accountId: 'token.paras.near',
        decimals: 18,
    },
    {
        symbol: 'NEARX',
        accountId: 'v2-nearx.stader-labs.near',
        decimals: 24,
    },
    {
        symbol: 'AURORA',
        accountId: 'aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near',
        decimals: 18,
    },
    {
        symbol: 'AURORA',
        accountId: 'aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near',
        decimals: 18,
    },
    // testnet token
    {
        symbol: 'REF',
        accountId: 'ref.fakes.testnet',
        decimals: 18,
    },
    // testnet token
    {
        symbol: 'wNEAR',
        accountId: 'wrap.testnet',
        decimals: 24,
    },
    // testnet token
    {
        symbol: 'USDT',
        accountId: 'usdt.fakes.testnet',
        decimals: 6,
    },
];

'''
'''--- src/constant/near/tonic.constant.ts ---
import { TonicMarketConfig } from '../../type';

export const TONIC_CONTRACT_ID = 'v1.orderbook.near';

export const TONIC_MARKETS: TonicMarketConfig[] = [
    {
        name: 'NEAR-100/USDC',
        marketId: '2UmzUXYpaZg4vXfFVmD7r8mYUYkKEF19xpjLw7ygDUwp',
        baseSymbol: 'NEAR',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 2,
        orderQuantityDecimals: 2,
    },
    {
        name: 'NEAR/USDC',
        marketId: '9CeAnXRUg48e6VwSEwB1v52qSVkgiDEfw98FjDMCkSto',
        baseSymbol: 'NEAR',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
    },
    {
        name: 'USN/USDC',
        marketId: 'J5mggeEGCyXVUibvYTe9ydVBrELECRUu23VRk2TwC2is',
        baseSymbol: 'USN',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 2,
    },
    {
        name: 'NEAR/USN',
        marketId: 'Cefz3vA3yjf8QrjAJgbke4aRbMQU6hbf1M6jRpcBUrdz',
        baseSymbol: 'NEAR',
        quoteSymbol: 'USN',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
    },
    {
        name: 'STNEAR/NEAR',
        marketId: '6x4XNC51pBigBPVEjpp1dmGfRbkxQMrTSudsbAhKwh7h',
        baseSymbol: 'STNEAR',
        quoteSymbol: 'NEAR',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 2,
    },
    {
        name: 'PEM/USDC',
        marketId: 'EQNFsoETbeJshWW4h2sh7bsqJ4Cz2XSHsSDETj1Q2uUb',
        baseSymbol: 'PEM',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
    },
    {
        name: 'PARAS/USDC',
        marketId: '3Eh8EqMdhAQN2pP3c5pd1zD84PxLMic4XuB75mpv66he',
        baseSymbol: 'PARAS',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 0,
    },
    {
        name: 'NEARX/NEAR',
        marketId: '2hSL1vwCn2NET49WT3YQuokUzh9bTNQfjNrqW4ewbPV2',
        baseSymbol: 'NEARX',
        quoteSymbol: 'NEAR',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 2,
    },
    {
        name: 'AURORA-1000/USDC',
        marketId: '7Ub1tFH9hUTcS3F4PbU7PPVmXx4u11nQnBPCF3tqJgkV',
        baseSymbol: 'AURORA',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
    },
    {
        name: 'AURORA/USDC',
        marketId: 'Fef7VNamGSiujh9AL88FyF9MgN1M7vJvX9CtEdSmYGoP',
        baseSymbol: 'AURORA',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 2,
    },
];

'''
'''--- src/constant/solana/common.constant.ts ---
import { PublicKey } from '@solana/web3.js';
import Decimal from 'decimal.js';
import { SolanaEnvConfig, SolanaEnvName } from '../../type';

export const SOLANA_ENV: { [index in SolanaEnvName]: SolanaEnvConfig } = {
    DEV: {
        programId: new PublicKey('CeLLnpHYVjZSmjfw4syfJwGyAdGtXccZiacJKybFEfHJ'),
        adminAccount: new PublicKey('Aw2CnBU7xrw3UXGqCkjZc1cRfVuR5ZW9dkdFz4VAoA8d'),
    },
    ZETA: {
        programId: new PublicKey('EXQespVxq6d6BTXAU1fE5HyqKG5vxgRoYnq8pHNPVdyA'),
        adminAccount: new PublicKey('CeLLkwAYkVtFmej6PvNWXY9c1BzTCgs854nPHXqgECTd'),
    },
    POOL: {
        programId: new PublicKey('8QfW1kNu5o25AJU6Htcno6KgnzrT6obiq2mZeR8qaMXp'),
        adminAccount: new PublicKey('CeLLkwAYkVtFmej6PvNWXY9c1BzTCgs854nPHXqgECTd'),
    },
    PROD: {
        programId: new PublicKey('E88JZpoDm5M7xSpgxdQ3aSbiiZgWuLBPgNQSehWcLJM4'),
        adminAccount: new PublicKey('Aw2CnBU7xrw3UXGqCkjZc1cRfVuR5ZW9dkdFz4VAoA8d'),
    },
    PROD_V2: {
        programId: new PublicKey('8EndYA8H6DBKdrGJNQ6JqckzZAVPMfoYAmaAPwhC9kar'),
        adminAccount: new PublicKey('Aw2CnBU7xrw3UXGqCkjZc1cRfVuR5ZW9dkdFz4VAoA8d'),
    },
};

export const ZERO_DECIMAL = new Decimal(0);

'''
'''--- src/constant/solana/index.ts ---
export * from './common.constant';
export * from './token.constant';
export * from './serum.constant';
export * from './zeta.constant';
export * from './mango.constant';

'''
'''--- src/constant/solana/mango.constant.ts ---
import { PublicKey } from '@solana/web3.js';
import {MangoPerpMarketConfig, MangoSpotMarketConfig} from "../../type";

export const MANGO_PROGRAM_ID = new PublicKey('mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68');
export const MANGO_REIMBURSEMENT_PROGRAM_ID = new PublicKey('m3roABq4Ta3sGyFRLdY4LH1KN16zBtg586gJ3UxoBzb');
export const MANGO_REIMBURSEMENT_GROUP_KEY = new PublicKey('Hy4ZsZkVa1ZTVa2ghkKY3TsThYEK9MgaL8VPF569jsHP');
export const MANGO_GROUP_KEY = new PublicKey('98pjRuQjK3qA6gXts96PqZT4Ze5QmnCmt3QYjhbUSPue');

export const MANGO_PERP_MARKETS: MangoPerpMarketConfig[] = [
    {
        name: 'MNGO-PERP',
        publicKey: new PublicKey('4nfmQP3KmUqEJ6qJLsS3offKgE96YUB4Rp7UQvm2Fbi9'),
        orderPriceDecimals: 4,
        orderQuantityDecimals: 0,
        leverage: 4,
        marketIndex: 0,
        baseSymbol: 'MNGO',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('4XU8wH9ivp7x7ohhTbWUZabg5WVkF7sBtqQCmFEV6qiN'),
        asksKey: new PublicKey('4ZkS7ZZkxfsC3GtvvsHP3DFcUeByU9zzZELS4r8HCELo'),
        eventQueueKey: new PublicKey('7orixrhZpjvofZGWZyyLFxSEt2tfFiost5kHEzd7jdet'),
        mngoVault: new PublicKey('ChtvWUf5qPQaNi8kcwFXLWb6BTrLsADPVMHmqtgQVNvh'),
    },
    {
        name: 'BTC-PERP',
        publicKey: new PublicKey('DtEcjPLyD4YtTBB4q8xwFZ9q49W89xZCZtJyrGebi5t8'),
        orderPriceDecimals: 1,
        orderQuantityDecimals: 4,
        leverage: 20,
        marketIndex: 1,
        baseSymbol: 'BTC',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('Bc8XaK5UTuDSCBtiESSUxBSb9t6xczhbAJnesPamMRir'),
        asksKey: new PublicKey('BkWRiarqxP5Gwx7115LQPbjRmr3NjuSRXWBnduXXLGWR'),
        eventQueueKey: new PublicKey('7t5Me8RieYKsFpfLEV8jnpqcqswNpyWD95ZqgUXuLV8Z'),
        mngoVault: new PublicKey('CF8sDcPztLDkvnEbYnCaXiDxhUpZ2uKLStpmFfRDNxSd'),
    },
    {
        name: 'ETH-PERP',
        publicKey: new PublicKey('DVXWg6mfwFvHQbGyaHke4h3LE9pSkgbooDSDgA4JBC8d'),
        orderPriceDecimals: 1,
        orderQuantityDecimals: 3,
        leverage: 20,
        marketIndex: 2,
        baseSymbol: 'ETH',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('DQv2sWhaHYbKrobHH6jAdkAXw13mnDdM9hVfRQtrUcMe'),
        asksKey: new PublicKey('8NhLMV6huneGAqijuUgUFSshbAfXxdNj6ZMHSLb9aW8K'),
        eventQueueKey: new PublicKey('9vDfKNPJkCvQv9bzR4JNTGciQC2RVHPVNMMHiVDgT1mw'),
        mngoVault: new PublicKey('DMNtyjf5jUWzK3qCGrMBeRSmYQ43agD1eXScSqxZ67gT'),
    },
    {
        name: 'SOL-PERP',
        publicKey: new PublicKey('2TgaaVoHgnSeEtXvWTx13zQeTf4hYWAMEiMQdcG6EwHi'),
        orderPriceDecimals: 2,
        orderQuantityDecimals: 2,
        leverage: 20,
        marketIndex: 3,
        baseSymbol: 'SOL',
        baseDecimals: 9,
        quoteDecimals: 6,
        bidsKey: new PublicKey('Fu8q5EiFunGwSRrjFKjRUoMABj5yCoMEPccMbUiAT6PD'),
        asksKey: new PublicKey('9qUxMSWBGAeNmXusQHuLfgSuYJqADyYoNLwZ63JJSi6V'),
        eventQueueKey: new PublicKey('31cKs646dt1YkA3zPyxZ7rUAkxTBz279w4XEobFXcAKP'),
        mngoVault: new PublicKey('HzHhbkEvjU4X65CK2xBBxmmJ79tLRDk2X5WfkaH1FbMq'),
    },
    {
        name: 'SRM-PERP',
        publicKey: new PublicKey('4GkJj2znAr2pE2PBbak66E12zjCs2jkmeafiJwDVM9Au'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 8,
        marketIndex: 5,
        baseSymbol: 'SRM',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('E8Dv9giJQgPqNaBxF9WKDUhJD7GZ5fwXfF1NQfeCCaQp'),
        asksKey: new PublicKey('GMv773oHiNd4jaj8uQvr1kbzroY5BDK7QTNHD14ATjGJ'),
        eventQueueKey: new PublicKey('BXSPmdHWP6fMqsCsT6kG8UN9uugAJxdDkQWy87njUQnL'),
        mngoVault: new PublicKey('9dTZh76cAbp287bbG91uHU3mmWNoDdSthSuWkYmtVGNJ'),
    },
    {
        name: 'RAY-PERP',
        publicKey: new PublicKey('6WGoQr5mJAEpYCdX6qjju2vEnJuD7e8ZeYes7X7Shi7E'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 8,
        marketIndex: 6,
        baseSymbol: 'RAY',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('9AHm1nsxG1e3zkHnFLzYUXd17qnCgM7aFJDDApXXrhVU'),
        asksKey: new PublicKey('43dVtcFTgDHHr32V6vhvxU2gg11wK7oyK8DdfTQ2pQsy'),
        eventQueueKey: new PublicKey('Css2MQhEvXMTKjp9REVZR9ZyUAYAZAPrnDvRoPxrQkeN'),
        mngoVault: new PublicKey('3jbET1DX1AM8E3FVU9kijmdfPENeEVBMHn7bhsxkugNs'),
    },
    {
        name: 'FTT-PERP',
        publicKey: new PublicKey('AhgEayEGNw46ALHuC5ASsKyfsJzAm5JY8DWqpGMQhcGC'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 10,
        marketIndex: 8,
        baseSymbol: 'FTT',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('5xihpD8yz9vt95WSHVpW8pVykffW7h5VHb2LkhGBMUck'),
        asksKey: new PublicKey('G9HtAEwHRYBrz9ZpdDJH8Qs1hEZqNJ1BPm3veBsmEXbX'),
        eventQueueKey: new PublicKey('5pHAhyEphQRVvLqvYF7dziofR52yZWuq8DThQFJvJ7r5'),
        mngoVault: new PublicKey('HtKPzDC2TcMwCkHNMs2M4ZRWoooufshBfE4HGPJwbrZ6'),
    },
    {
        name: 'ADA-PERP',
        publicKey: new PublicKey('Bh9UENAncoTEwE7NDim8CdeM1GPvw6xAT4Sih2rKVmWB'),
        orderPriceDecimals: 4,
        orderQuantityDecimals: 0,
        leverage: 10,
        marketIndex: 9,
        baseSymbol: 'ADA',
        baseDecimals: 6,
        quoteDecimals: 6,
        bidsKey: new PublicKey('ivYhvYgribqdCzDg4m8fUF9ejgJHE4mnRUseR4d9khN'),
        asksKey: new PublicKey('F4UTmEXxEUgGSL7P3HePAuz3PsXvx6hWr256vqVnzxKE'),
        eventQueueKey: new PublicKey('G6Dsw9KnP4G38hePtedTH6gDfDQmPJGJw8zipBJvKc12'),
        mngoVault: new PublicKey('EX5YRv7BpEcQL5SxNx37iugzj7V5nHqSZWccKRhSFa9N'),
    },
    {
        name: 'BNB-PERP',
        publicKey: new PublicKey('CqxX2QupYiYafBSbA519j4vRVxxecidbh2zwX66Lmqem'),
        orderPriceDecimals: 1,
        orderQuantityDecimals: 3,
        leverage: 10,
        marketIndex: 11,
        baseSymbol: 'BNB',
        baseDecimals: 8,
        quoteDecimals: 6,
        bidsKey: new PublicKey('6Pg82x4SSejLny5v1wSWs7QhnheLDq7EX1pMVY8LTsB3'),
        asksKey: new PublicKey('6n2ooaNFP6X54ZiwDskhhVeW81F4hHNEibsJ8vfjVNDU'),
        eventQueueKey: new PublicKey('GmX4qXMpXvs1DuUXNB4eqL1rfF8LeYEjkKgpFeYsm55n'),
        mngoVault: new PublicKey('6DuaYV1uAWSh6CcpyY1cYihyXRn13pL7xR4HFwXxrHER'),
    },
    {
        name: 'AVAX-PERP',
        publicKey: new PublicKey('EAC7jtzsoQwCbXj1M3DapWrNLnc3MBwXAarvWDPr2ZV9'),
        orderPriceDecimals: 2,
        orderQuantityDecimals: 2,
        leverage: 10,
        marketIndex: 12,
        baseSymbol: 'AVAX',
        baseDecimals: 8,
        quoteDecimals: 6,
        bidsKey: new PublicKey('BD1vpQjLXx7Rmd5n1SFNTLcwujPYTnFpoaArvPd9ixB9'),
        asksKey: new PublicKey('8Q11iGHXFTr267J4bgbeEeWPYPSANVcs6NQWHQK4UrNs'),
        eventQueueKey: new PublicKey('5Grgo9kLu692SUcJ6S7jtbi1WkdwiyRWgThAfN1PcvbL'),
        mngoVault: new PublicKey('HaGVpy6RbgkoofTdMxkSN5o2imraPvwk9rH7WhoahHft'),
    },
    {
        name: 'GMT-PERP',
        publicKey: new PublicKey('3hBYgfMHogR8X2JkpxvT8HMtUSbrE2PE61q64gZkWArr'),
        orderPriceDecimals: 4,
        orderQuantityDecimals: 0,
        leverage: 8,
        marketIndex: 14,
        baseSymbol: 'GMT',
        baseDecimals: 9,
        quoteDecimals: 6,
        bidsKey: new PublicKey('67jnTtxDdDqz6R18Do3AUUjBbZT3yysprGLhaucyKd93'),
        asksKey: new PublicKey('DstVrGA3CBcq1r7op4yU7dX3sirzSgz1uicn63aYBMGz'),
        eventQueueKey: new PublicKey('J2WYiw67VeGkPvmM3fi65H9KxDgCf79fNwspcD3ycubK'),
        mngoVault: new PublicKey('4qh34T1MZV8aTd9DGKteojRJBRotqvhLytuE6xZDXf8N'),
    },
];

export const MANGO_SPOT_MARKETS: MangoSpotMarketConfig[] = [
    {
        name: 'MNGO/USDC',
        publicKey: new PublicKey('3d4rzwpy9iGdCZvgxcu7B1YocYffVLsQXPXkBZKt2zLc'),
        orderPriceDecimals: 4,
        orderQuantityDecimals: 0,
        leverage: 1.25,
        marketIndex: 0,
        baseSymbol: 'MNGO',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 1000000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('3nAdH9wTEhPoW4e2s8K2cXfn4jZH8FBCkUqtzWpsZaGb'),
        asksKey: new PublicKey('HxbWm3iabHEFeHG9LVGYycTwn7aJVYYHbpQyhZhAYnfn'),
        eventQueueKey: new PublicKey('H1VVmwbM96BiBJq46zubSBm6VBhfM2FUhLVUqKGh1ee9'),
        requestQueueKey: new PublicKey('EgafUKwVAmEj2czrt7HkWnZJLZSAK9BDN5aGQpLypAys'),
        baseVaultKey: new PublicKey('7Ex7id4G37HynuiCAv5hTYM4BnPB9y4NU85QcaNWZy3G'),
        quoteVaultKey: new PublicKey('9UB1NhGeDuV1apHdtK5LeAEjP7kZFH8vVYGdh2yGFRi8'),
        vaultSignerKey: new PublicKey('BFkxdUwW17eANhfs1xNmBqEcegb4EStQxVb5VaMS2dq6'),
    },
    {
        name: 'BTC/USDC',
        publicKey: new PublicKey('A8YFbxQYFVqKZaoYJLLUVcQiWP7G2MeEgW5wsAQgMvFw'),
        orderPriceDecimals: 1,
        orderQuantityDecimals: 4,
        leverage: 5,
        marketIndex: 1,
        baseSymbol: 'BTC',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 100,
        quoteLotSize: 10,
        bidsKey: new PublicKey('6wLt7CX1zZdFpa6uGJJpZfzWvG6W9rxXjquJDYiFwf9K'),
        asksKey: new PublicKey('6EyVXMMA58Nf6MScqeLpw1jS12RCpry23u9VMfy8b65Y'),
        eventQueueKey: new PublicKey('6NQqaa48SnBBJZt9HyVPngcZFW81JfDv9EjRX2M4WkbP'),
        requestQueueKey: new PublicKey('H6UaUrNVELJgTqao1CNL4252kShLKSfwoboT8tF7HNtB'),
        baseVaultKey: new PublicKey('GZ1YSupuUq9kB28kX9t1j9qCpN67AMMwn4Q72BzeSpfR'),
        quoteVaultKey: new PublicKey('7sP9fug8rqZFLbXoEj8DETF81KasaRA1fr6jQb6ScKc5'),
        vaultSignerKey: new PublicKey('GBWgHXLf1fX4J1p5fAkQoEbnjpgjxUtr4mrVgtj9wW8a'),
    },
    {
        name: 'ETH/USDC',
        publicKey: new PublicKey('4tSvZvnbyzHXLMTiFonMyxZoHmFqau1XArcRCVHLZ5gX'),
        orderPriceDecimals: 2,
        orderQuantityDecimals: 3,
        leverage: 5,
        marketIndex: 2,
        baseSymbol: 'ETH',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 1000,
        quoteLotSize: 10,
        bidsKey: new PublicKey('8tFaNpFPWJ8i7inhKSfAcSestudiFqJ2wHyvtTfsBZZU'),
        asksKey: new PublicKey('2po4TC8qiTgPsqcnbf6uMZRMVnPBzVwqqYfHP15QqREU'),
        eventQueueKey: new PublicKey('Eac7hqpaZxiBtG4MdyKpsgzcoVN6eMe9tAbsdZRYH4us'),
        requestQueueKey: new PublicKey('6yJsfduT4Av6xaECAoXf4cXHaQQYjf78D1FG3WDyuxdr'),
        baseVaultKey: new PublicKey('7Nw66LmJB6YzHsgEGQ8oDSSsJ4YzUkEVAvysQuQw7tC4'),
        quoteVaultKey: new PublicKey('EsDTx47jjFACkBhy48Go2W7AQPk4UxtT4765f3tpK21a'),
        vaultSignerKey: new PublicKey('C5v68qSzDdGeRcs556YoEMJNsp8JiYEiEhw2hVUR8Z8y'),
    },
    {
        name: 'SOL/USDC',
        publicKey: new PublicKey('9wFFyRfZBsuAha4YcuxcXLKwMxJR43S7fPfQLusDBzvT'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 5,
        marketIndex: 3,
        baseSymbol: 'SOL',
        baseDecimals: 9,
        quoteDecimals: 6,
        baseLotSize: 100000000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('14ivtgssEBoBjuZJtSAPKYgpUK7DmnSwuPMqJoVTSgKJ'),
        asksKey: new PublicKey('CEQdAFKdycHugujQg9k2wbmxjcpdYZyVLfV9WerTnafJ'),
        eventQueueKey: new PublicKey('5KKsLVU6TcbVDK4BS6K1DGDxnh4Q9xjYJ8XaDCG5t8ht'),
        requestQueueKey: new PublicKey('AZG3tFCFtiCqEwyardENBQNpHqxgzbMw8uKeZEw2nRG5'),
        baseVaultKey: new PublicKey('36c6YqAwyGKQG66XEp2dJc5JqjaBNv7sVghEtJv4c7u6'),
        quoteVaultKey: new PublicKey('8CFo8bL8mZQK8abbFyypFMwEDd8tVJjHTTojMLgQTUSZ'),
        vaultSignerKey: new PublicKey('F8Vyqk3unwxkXukZFQeYyGmFfTG3CAX4v24iyrjEYBJV'),
    },
    {
        name: 'SRM/USDC',
        publicKey: new PublicKey('ByRys5tuUWDgL73G8JBAEfkdFf8JWBzPBDHsBVQ5vbQA'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 5,
        marketIndex: 5,
        baseSymbol: 'SRM',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 100000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('AuL9JzRJ55MdqzubK4EutJgAumtkuFcRVuPUvTX39pN8'),
        asksKey: new PublicKey('8Lx9U9wdE3afdqih1mCAXy3unJDfzSaXFqAvoLMjhwoD'),
        eventQueueKey: new PublicKey('6o44a9xdzKKDNY7Ff2Qb129mktWbsCT4vKJcg2uk41uy'),
        requestQueueKey: new PublicKey('Hr8Z93aWe4hhJbC5i7YTsPaSToziVh3vyMfv9GRqKFCh'),
        baseVaultKey: new PublicKey('Ecfy8et9Mft9Dkavnuh4mzHMa2KWYUbBTA5oDZNoWu84'),
        quoteVaultKey: new PublicKey('hUgoKy5wjeFbZrXDW4ecr42T4F5Z1Tos31g68s5EHbP'),
        vaultSignerKey: new PublicKey('GVV4ZT9pccwy9d17STafFDuiSqFbXuRTdvKQ1zJX6ttX'),
    },
    {
        name: 'RAY/USDC',
        publicKey: new PublicKey('2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep'),
        orderPriceDecimals: 4,
        orderQuantityDecimals: 1,
        leverage: 5,
        marketIndex: 6,
        baseSymbol: 'RAY',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 100000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('Hf84mYadE1VqSvVWAvCWc9wqLXak4RwXiPb4A91EAUn5'),
        asksKey: new PublicKey('DC1HsWWRCXVg3wk2NndS5LTbce3axwUwUZH1RgnV4oDN'),
        eventQueueKey: new PublicKey('H9dZt8kvz1Fe5FyRisb77KcYTaN8LEbuVAfJSnAaEABz'),
        requestQueueKey: new PublicKey('39mE6bYktM1XAKKmB6WN971X3Sa1yGkHxtCTWMkVrwN2'),
        baseVaultKey: new PublicKey('GGcdamvNDYFhAXr93DWyJ8QmwawUHLCyRqWL3KngtLRa'),
        quoteVaultKey: new PublicKey('22jHt5WmosAykp3LPGSAKgY45p7VGh4DFWSwp21SWBVe'),
        vaultSignerKey: new PublicKey('FmhXe9uG6zun49p222xt3nG1rBAkWvzVz7dxERQ6ouGw'),
    },
    {
        name: 'FTT/USDC',
        publicKey: new PublicKey('2Pbh1CvRVku1TgewMfycemghf6sU9EyuFDcNXqvRmSxc'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 5,
        marketIndex: 8,
        baseSymbol: 'FTT',
        baseDecimals: 6,
        quoteDecimals: 6,
        baseLotSize: 100000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('9HTDV2r7cQBUKL3fgcJZCUfmJsKA9qCP7nZAXyoyaQou'),
        asksKey: new PublicKey('EpnUJCMCQNZi45nCBoNs6Bugy67Kj3bCSTLYPfz6jkYH'),
        eventQueueKey: new PublicKey('2XHxua6ZaPKpCGUNvSvTwc9teJBmexp8iMWCLu4mtzGb'),
        requestQueueKey: new PublicKey('2ncWnY9QuCdNAX4gLutkNoKr9R1owDY1bhLLV1yH8Ukf'),
        baseVaultKey: new PublicKey('4LXjM6rptNvhBZTcWk4AL49oF4oA8AH7D4CV6z7tmpX3'),
        quoteVaultKey: new PublicKey('2ycZAqQ3YNPfBZnKTbz2FqPiV7fmTQpzF95vjMUekP5z'),
        vaultSignerKey: new PublicKey('B5b9ddFHrjndUieLAKkyzB1xmq8sNqGGZPmbyYWPzCyu'),
    },
    {
        name: 'MSOL/USDC',
        publicKey: new PublicKey('6oGsL2puUgySccKzn9XA9afqF217LfxP5ocq4B3LWsjy'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 3,
        leverage: 5,
        marketIndex: 10,
        baseSymbol: 'MSOL',
        baseDecimals: 9,
        quoteDecimals: 6,
        baseLotSize: 1000000,
        quoteLotSize: 1,
        bidsKey: new PublicKey('8qyWhEcpuvEsdCmY1kvEnkTfgGeWHmi73Mta5jgWDTuT'),
        asksKey: new PublicKey('PPnJy6No31U45SVSjWTr45R8Q73X6bNHfxdFqr2vMq3'),
        eventQueueKey: new PublicKey('BC8Tdzz7rwvuYkJWKnPnyguva27PQP5DTxosHVQrEzg9'),
        requestQueueKey: new PublicKey('EHUoDPVVKR5Udp4EZPb4bsHZte5EEHc1PPTPXBgJEPEK'),
        baseVaultKey: new PublicKey('2y3BtF5oRBpLwdoaGjLkfmT3FY3YbZCKPbA9zvvx8Pz7'),
        quoteVaultKey: new PublicKey('6w5hF2hceQRZbaxjPJutiWSPAFWDkp3YbY2Aq3RpCSKe'),
        vaultSignerKey: new PublicKey('9dEVMESKXcMQNndoPc5ji9iTeDJ9GfToboy8prkZeT96'),
    },
    {
        name: 'BNB/USDC',
        publicKey: new PublicKey('4UPUurKveNEJgBqJzqHPyi8DhedvpYsMXi7d43CjAg2f'),
        orderPriceDecimals: 1,
        orderQuantityDecimals: 3,
        leverage: 5,
        marketIndex: 11,
        baseSymbol: 'BNB',
        baseDecimals: 8,
        quoteDecimals: 6,
        baseLotSize: 100000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('XHJx6VrtEjpHhTQVt7KSapsTf63BqrStuFd3X3LSovP'),
        asksKey: new PublicKey('4wZkXYKNcnkkf2ALX3ktRDCuj8Sj1dd2L4APxcKDpgwG'),
        eventQueueKey: new PublicKey('DK7Jw2fZCbTVDF191eXywDFymmbXqGUp4VuERiX6RAR4'),
        requestQueueKey: new PublicKey('DzYpcbvi32Me2KTRnpa18VxDU1VP57nHHS7Ks2wEs9KL'),
        baseVaultKey: new PublicKey('7SjACG2xPdt9ur1Shdav6SwBnr58wRZPxLegJX3e2vhT'),
        quoteVaultKey: new PublicKey('HrxG4K4xSpRfPxSGtMQnnbKRo3r6F2Qj1eyDZXFvP7pe'),
        vaultSignerKey: new PublicKey('xns66Y3kLdMA7aVZciP5pdc46oBD9QHjUrnfTVF3PWp'),
    },
    {
        name: 'AVAX/USDC',
        publicKey: new PublicKey('E8JQstcwjuqN5kdMyUJLNuaectymnhffkvfg1j286UCr'),
        orderPriceDecimals: 2,
        orderQuantityDecimals: 2,
        leverage: 5,
        marketIndex: 12,
        baseSymbol: 'AVAX',
        baseDecimals: 8,
        quoteDecimals: 6,
        baseLotSize: 1000000,
        quoteLotSize: 100,
        bidsKey: new PublicKey('925NuYb44V63wNRooM5tBFNCXM5daD72m6KDxoCmYpYX'),
        asksKey: new PublicKey('q2eUYuqJeBD6DndxDQ2tEuFqAe6j9j9jMtMnkkKU5P9'),
        eventQueueKey: new PublicKey('HY7ZpmQ6VXLHKxN4cruFKMTNu42EbjPEDthyGPnsYYHq'),
        requestQueueKey: new PublicKey('HvxcJ8Nbd6HcoN1ud7eA4JXvASxLERSob1HSNM5frYhW'),
        baseVaultKey: new PublicKey('GCy2YwPXnK8XSaTzekBXqk7QM39obxA4uASsC316KpZ5'),
        quoteVaultKey: new PublicKey('8PDzWsq8J4AWBk1YSnS5NHSpZWhXxaM5dvGQLxgWxAX6'),
        vaultSignerKey: new PublicKey('CUG8UvhW1q6ojQC2gyga8x67nde37vvsJUUbinTaPU9N'),
    },
    {
        name: 'GMT/USDC',
        publicKey: new PublicKey('9KLmeRBpT4chsxkJatfDdzrtTBvBastYp9wMe712ASCg'),
        orderPriceDecimals: 3,
        orderQuantityDecimals: 2,
        leverage: 2,
        marketIndex: 14,
        baseSymbol: 'GMT',
        baseDecimals: 9,
        quoteDecimals: 6,
        baseLotSize: 10000000,
        quoteLotSize: 10,
        bidsKey: new PublicKey('EzVutiMEE8gyeyaiQ4jUrSn4LXwrDmRkuNK4wcRctJxW'),
        asksKey: new PublicKey('Eg2PKQ3BHWsRCMLZQaJrAXMCEWoEsNXPY8BLLk5AHsrM'),
        eventQueueKey: new PublicKey('92AfWEUqA2RQjD46otvaXEA3CQ4qBFi2K8AmCBwwghHG'),
        requestQueueKey: new PublicKey('DtQRDbouSPoqgqKTKrEdSvnYMxp1nxheFS445r3qrkYn'),
        baseVaultKey: new PublicKey('2oxTZXWtZQiZ4amFfhFHJSPoXGhi4gtBV8SF9BZTF4kg'),
        quoteVaultKey: new PublicKey('m6jKUb5KmKtEDMAP8FpENv3k2ecRWDxvM1azgcQbVcw'),
        vaultSignerKey: new PublicKey('26hKhwGrpPabhMS4F2s7LixnycMZhJEcegBvxr7n4LbY'),
    },
];

'''
'''--- src/constant/solana/serum.constant.ts ---
import { PublicKey } from '@solana/web3.js';
import { SerumMarketConfig } from '../../type';

export const SERUM_PROGRAM_ID = new PublicKey('srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX');

export const SERUM_MARKETS: SerumMarketConfig[] = [
    {
        name: 'SOL/USDC',
        address: new PublicKey('8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6'),
        baseSymbol: 'SOL',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 3,
        leverage: 1,
        baseLotSize: 1000000,
        quoteLotSize: 1,
        bids: new PublicKey('5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh'),
        asks: new PublicKey('EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5'),
        requestQueue: new PublicKey('CPjXDcggXckEq9e4QeXUieVJBpUNpLEmpihLpg5vWjGF'),
        eventQueue: new PublicKey('8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa'),
        baseVault: new PublicKey('CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX'),
        quoteVault: new PublicKey('6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu'),
        vaultSigner: new PublicKey('CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7'),
    },
    {
        name: 'wETH/USDC',
        address: new PublicKey('FZxi3yWkE5mMjyaZj6utmYL54QQYfMCKMcLaQZq4UwnA'),
        baseSymbol: 'wETH',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 0,
        orderQuantityDecimals: 4,
        leverage: 1,
        baseLotSize: 10000,
        quoteLotSize: 100,
        bids: new PublicKey('aknvfZ4mKykoGSNy6ZGUjKGz8xKWVKAkqsfHQEvaFJJ'),
        asks: new PublicKey('51QtGepdiruSb1n6pmKHLNaRNT6jpAqquF71G7Ux493Y'),
        requestQueue: new PublicKey('XQrNty6sE3Bx8yo1pbFqjK8Pingfat5viCuF55tE7CN'),
        eventQueue: new PublicKey('4v7Tg2bEEV1WHDgXja7KHfJh5zCcWQmafNbt14pUC3PJ'),
        baseVault: new PublicKey('AW9cs18vGQnNitjHpBRFAJCFomncMGkB3qpzVqcSPZzz'),
        quoteVault: new PublicKey('6N4p6Uo4QsFTXCra8Y8suVqCaNSNhTyvEMVJE9ARd1JK'),
        vaultSigner: new PublicKey('G6bwK22tQZwv6zfQXNehuA4rFJRVNxqZW2dr7MGGSfSN'),
    },
    {
        name: 'MNGO/USDC',
        address: new PublicKey('3NnxQvDcZXputNMxaxsGvqiKpqgPfSYXpNigZNFcknmD'),
        baseSymbol: 'MNGO',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 6,
        orderQuantityDecimals: -1,
        leverage: 1,
        baseLotSize: 10000000,
        quoteLotSize: 10,
        bids: new PublicKey('5xcsJ8wAc37HMMWuboeon8EFQFd5xaeeFF7gYWQecJRh'),
        asks: new PublicKey('FS3RJV17qKEtDjsffnbLujxR1qieBFR1Rvvk3jHxb3Ua'),
        requestQueue: new PublicKey('bHULB9gq5RVErH8Z9gKj6N8ZNLpNdiSGCUGb21QiyE2'),
        eventQueue: new PublicKey('L5qRy8coUoZpKTLN3xRXRNThGhQneg7k1fAMqjcE4cN'),
        baseVault: new PublicKey('6pr2nSMUg7Bet39jztkKJ1WtX1AV27vpzzLbWa4Tdrrc'),
        quoteVault: new PublicKey('4pQHik1oQgYJwNRjyzNgTJcxR7Z3BgHPcmj9Gp3gVZyA'),
        vaultSigner: new PublicKey('2g6tJJE8Dk8aVUWuj5ZYaJeSLCMn4qwGFg2WK8vLA4i1'),
    },
    {
        name: 'MSOL/USDC',
        address: new PublicKey('9Lyhks5bQQxb9EyyX55NtgKQzpM4WK7JCmeaWuQ5MoXD'),
        baseSymbol: 'MSOL',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 3,
        leverage: 1,
        baseLotSize: 1000000,
        quoteLotSize: 1,
        bids: new PublicKey('kB3BTG6Pz3W7JzKQLHyrAZaFk1LVmeeXRP4ZiCKUaA3'),
        asks: new PublicKey('Gi8KdURhXWvsRvDFHpqy1gNfnnYuTsWexQvDpP9711id'),
        requestQueue: new PublicKey('FNoj9fYY9qvt2Wfo2FQwwLEtxMEjLPvbC41qe7PiKcpn'),
        eventQueue: new PublicKey('CsB4XjwH4uZRjRXEXRBFJ3hi3mb9jujzRCW7NXg7TRtX'),
        baseVault: new PublicKey('9LBLMC54awCpsufBA9jm5mbwQbprNqLkSJxnpU7phXsm'),
        quoteVault: new PublicKey('FxBmYB5gdcDGag6992QkB1beMQajWiEhoRsaDYo3oGjm'),
        vaultSigner: new PublicKey('7BP26tWJq4omUnMyYTJZyDAkStuAShV9ZmGEAnv9yKMB'),
    },
    {
        name: 'RAY/USDC',
        address: new PublicKey('DZjbn4XC8qoHKikZqzmhemykVzmossoayV9ffbsUqxVj'),
        baseSymbol: 'RAY',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 1,
        baseLotSize: 100000,
        quoteLotSize: 100,
        bids: new PublicKey('CXMRrGEseppLPmzYJsx5vYwTkaDEag4A9LJvgrAeNpF'),
        asks: new PublicKey('27BrDDYtv9NDQCALCNnDqe3BqjYkgiaQwKBbyqCA8p8B'),
        requestQueue: new PublicKey('Beni6ohbhLxyyRR2jmAQyvQszYmmMW7atQ8vP4p1kxA3'),
        eventQueue: new PublicKey('EkKZwBeKWPvhraYERfUNr2fdh1eazrbTrQXYkRZs24XB'),
        baseVault: new PublicKey('7ssdQJxVAEBSigoJovgHcchwcEQFPPtYbyzLHDHEewKM'),
        quoteVault: new PublicKey('EBGFfeQ5dVwW4HxtShVbh8aCh2fKJ1r2qXBoa6teUve6'),
        vaultSigner: new PublicKey('HYfri5vWyYiDziQeprFErUTbrWdUnkfAFnAAGApZjdGv'),
    },
    {
        name: 'stSOL/USDC',
        address: new PublicKey('JCKa72xFYGWBEVJZ7AKZ2ofugWPBfrrouQviaGaohi3R'),
        baseSymbol: 'stSOL',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 3,
        orderQuantityDecimals: 1,
        leverage: 1,
        baseLotSize: 100000000,
        quoteLotSize: 100,
        bids: new PublicKey('GUQP2dWc6e2saQJL1Ep3QSZdTboNfpF8uzCj9th4CRUM'),
        asks: new PublicKey('7JynbAyCjg8Rvia8hizfRSaLhEWnHQxxBKUh5FqjRncY'),
        requestQueue: new PublicKey('E8jc4BZmZivHhPDoYUNvfzrD3fB7W8xNv4R7tgdRNByh'),
        eventQueue: new PublicKey('9ttPB4KHXuwxDD8668WiY1L8jdvYMFvZtwKn5PGNMCHX'),
        baseVault: new PublicKey('6q3zjhjZrC2f8Xd8CLqxQJaeSATQDhKMcDvF8KL3yHB4'),
        quoteVault: new PublicKey('BExFcur6aLQBLhtbngfs37yxvNad3N5u1Kg3pWzSeuNn'),
        vaultSigner: new PublicKey('DYVAKTk5icrGV5ouuMyQT2kCAN8ECP5qx9q7Bwk2Uxbi'),
    },
    {
        name: 'ARB/USDC',
        address: new PublicKey('5xCudgPvVetTL3M4ExtPuAFTnCr2hdQ3cte9LhGAuBee'),
        baseSymbol: 'ARB',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 5,
        orderQuantityDecimals: 1,
        leverage: 1,
        baseLotSize: 100000,
        quoteLotSize: 1,
        bids: new PublicKey('2RHQ12v6C2iLLm9v8cE5DEbt3oDdskptgt5pJNuGV366'),
        asks: new PublicKey('HmSzLV4mzkmpsiq2NFs4vsXAgaYsjgfHrNEYGv9UitPt'),
        requestQueue: new PublicKey('8uzBgEjQBNUN43eja38aqNuK7fnHiWQgNV5ZjjnUktxh'),
        eventQueue: new PublicKey('2YBZgUYLB5wb2J6SxMURDtudCLYfm6kczxRKnkKCivDM'),
        baseVault: new PublicKey('3pQcy3s6SM83SnZjVRHpMSEjMgRrzxATpoR3TERwhKCA'),
        quoteVault: new PublicKey('3xCAcLtpACxCFu95vezhZcz2Jq7afzbM4m22tKD6JVMZ'),
        vaultSigner: new PublicKey('AYeuHndwMA24QAgcRZpHUXsHz3vJVU5sYPFXVZ8ue87N'),
    },
];

'''
'''--- src/constant/solana/token.constant.ts ---
import { PublicKey } from '@solana/web3.js';
import { SolanaTokenConfig } from '../../type';

export const PYTH_PRICE_KEY = {
    USDC: new PublicKey('Gnt27xtC473ZT2Mw5u8wZ68Z3gULkSTb5DuxJy7eJotD'),
    BTC: new PublicKey('GVXRSBjFk6e6J3NbVPXohDJetcTjaeeuykUpbQF8UoMU'),
    COPE: new PublicKey('9xYBiDWYsh2fHzpsz3aaCnNHCKWBNtfEDLtU6kS4aFD9'),
    ETH: new PublicKey('JBu1AL4obBcCMqKBBxhpWCNUt136ijcuMZLFvTP7iWdB'),
    MNGO: new PublicKey('79wm3jjcPr6RaNQ4DGvP5KxG1mNd3gEBsg6FsNVFezK4'),
    RAY: new PublicKey('AnLf8tVYCM816gmBjiy8n53eXKKEDydT5piYjjQDPgTB'),
    SOL: new PublicKey('H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG'),
    SRM: new PublicKey('3NBReDRTLKMQEKiLD5tGcx4kXbTf88b7f2xLS9UuGjym'),
    FTT: new PublicKey('8JPJJkmDScpcNmBRKGZuPuG2GYAveQgP3t5gFuMymwvF'),
    LUNA: new PublicKey('5bmWuR1dgP4avtGYMNKLuxumZTVKGgoN2BCMXWDNL9nY'),
    BNB: new PublicKey('4CkQJBxhU8EZ2UjhigbtdaPbpTe6mqf811fipYBFbSYN'),
    AVAX: new PublicKey('Ax9ujW5B9oqcv59N8m6f1BpTBq2rGeGaBcpKjC5UYsXU'),
    USDT: new PublicKey('3vxLXJqLqF3JG5TCbYycbKWRBbCJQLxQmBGCkyqEEefL'),
    MSOL: new PublicKey('E4v1BBgoso9s64TQvmyownAVJbhbEPGyzA3qn4n46qj9'),
    GMT: new PublicKey('DZYZkJcFJThN9nZy4nK3hrHra1LaWeiyoZ9SMdLFEFpY'),
    ADA: new PublicKey('3pyn4svBbxJ9Wnn3RVeafyLWfzie6yC5eTig2S62v9SC'),
    stSOL: new PublicKey('Bt1hEbY62aMriY1SyQqbeZbm8VmSbQVGBFzSzMuVNWzN'),
    ARB: PublicKey.default,
};

export const SOLANA_TOKENS: SolanaTokenConfig[] = [
    {
        name: 'USDC',
        mintKey: new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'),
        decimals: 6,
        tokenIndex: 0,
        pythPriceKey: PYTH_PRICE_KEY.USDC,
    },
    {
        name: 'MNGO',
        mintKey: new PublicKey('MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac'),
        decimals: 6,
        tokenIndex: 1,
        pythPriceKey: PYTH_PRICE_KEY.MNGO,
    },
    {
        name: 'BTC',
        mintKey: new PublicKey('9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E'),
        decimals: 6,
        tokenIndex: 2,
        pythPriceKey: PYTH_PRICE_KEY.BTC,
    },
    {
        name: 'ETH',
        mintKey: new PublicKey('2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk'),
        decimals: 6,
        tokenIndex: 3,
        pythPriceKey: PYTH_PRICE_KEY.ETH,
    },
    {
        name: 'SOL',
        mintKey: new PublicKey('So11111111111111111111111111111111111111112'),
        decimals: 9,
        tokenIndex: 4,
        pythPriceKey: PYTH_PRICE_KEY.SOL,
    },
    {
        name: 'USDT',
        mintKey: new PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'),
        decimals: 6,
        tokenIndex: 5,
        pythPriceKey: PYTH_PRICE_KEY.USDT,
    },
    {
        name: 'SRM',
        mintKey: new PublicKey('SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt'),
        decimals: 6,
        tokenIndex: 6,
        pythPriceKey: PYTH_PRICE_KEY.SRM,
    },
    {
        name: 'RAY',
        mintKey: new PublicKey('4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R'),
        decimals: 6,
        tokenIndex: 7,
        pythPriceKey: PYTH_PRICE_KEY.RAY,
    },
    {
        name: 'COPE',
        mintKey: new PublicKey('8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh'),
        decimals: 6,
        tokenIndex: 8,
        pythPriceKey: PYTH_PRICE_KEY.COPE,
    },
    {
        name: 'FTT',
        mintKey: new PublicKey('AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3'),
        decimals: 6,
        tokenIndex: 9,
        pythPriceKey: PYTH_PRICE_KEY.FTT,
    },
    {
        name: 'MSOL',
        mintKey: new PublicKey('mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So'),
        decimals: 9,
        tokenIndex: 10,
        pythPriceKey: PYTH_PRICE_KEY.MSOL,
    },
    {
        name: 'BNB',
        mintKey: new PublicKey('9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa'),
        decimals: 8,
        tokenIndex: 11,
        pythPriceKey: PYTH_PRICE_KEY.BNB,
    },
    {
        name: 'AVAX',
        mintKey: new PublicKey('KgV1GvrHQmRBY8sHQQeUKwTm2r2h8t4C8qt12Cw1HVE'),
        decimals: 8,
        tokenIndex: 12,
        pythPriceKey: PYTH_PRICE_KEY.AVAX,
    },
    {
        name: 'LUNA',
        mintKey: new PublicKey('F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W'),
        decimals: 6,
        tokenIndex: 13,
        pythPriceKey: PYTH_PRICE_KEY.LUNA,
    },
    {
        name: 'GMT',
        mintKey: new PublicKey('7i5KKsX2weiTkry7jA4ZwSuXGhs5eJBEjY8vVxR4pfRx'),
        decimals: 9,
        tokenIndex: 14,
        pythPriceKey: PYTH_PRICE_KEY.GMT,
    },
    {
        name: 'wETH',
        mintKey: new PublicKey('7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs'),
        decimals: 8,
        tokenIndex: 15,
        pythPriceKey: PYTH_PRICE_KEY.ETH,
    },
    {
        name: 'stSOL',
        mintKey: new PublicKey('7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj'),
        decimals: 9,
        tokenIndex: 16,
        pythPriceKey: PYTH_PRICE_KEY.stSOL,
    },
    {
        name: 'ARB',
        mintKey: new PublicKey('9tzZzEHsKnwFL1A3DyFJwj36KnZj3gZ7g4srWp9YTEoh'),
        decimals: 6,
        tokenIndex: 17,
        pythPriceKey: PYTH_PRICE_KEY.ARB,
    },
];

'''
'''--- src/constant/solana/zeta.constant.ts ---
import { PublicKey } from '@solana/web3.js';
import { ZetaAssetConfig, ZetaFutureMarketConfig, ZetaPerpMarketConfig } from '../../type';

export const ZETA_PROGRAM_ID = new PublicKey('ZETAxsqBRek56DhiGXrn75yj2NHU3aYUnxvHXpkf3aD');
export const ZETA_DEX_PROGRAM_ID = new PublicKey('zDEXqXEG7gAyxb1Kg9mK5fPnUdENCGKzWrM21RMdWRq');
export const ZETA_STATE_ACCOUNT = new PublicKey('8eExPiLp47xbSDYkbuem4qnLUpbLTfZBeFuEJoh6EUr2');
export const ZETA_SERUM_AUTHORITY_KEY = new PublicKey('AVNMK6wiGfppdQNg9WKfMRBXefDPGZFh2f3o1fRbgN8n');
export const ZETA_MINT_AUTHORITY_KEY = new PublicKey('AV1UvTbycnqMe4JqHKGCqhACRd2m79YmtEUJrnCUQ3GT');

export const ZETA_ASSETS_CONFIG: ZetaAssetConfig[] = [
    {
        symbol: 'SOL',
        groupAccount: new PublicKey('CoGhjFdyqzMFr5xVgznuBjULvoFbFtNN4bCdQzRArNK2'),
        oracleAccount: new PublicKey('H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG'),
        vaultAccount: new PublicKey('6esygvEPnAV3JKzMKP4ainLvENM2tFYzZ1bpA1NhfDyK'),
        socializedLossAccount: new PublicKey('GMHLjhEosbS7kFzAL557ss9gMP7QfkTT1kBeeicyYvJV'),
        greeksAccount: new PublicKey('FRTCRjf8T5hFHZ9PKGPhYYVRWMFHKje4KwMAEttnDNBe'),
        perpSyncQueue: new PublicKey('5TcAGTDp5iaSLQwRK8m9r3uDQJKeat3vfwe3XA2vw12J'),
    },
    {
        symbol: 'BTC',
        groupAccount: new PublicKey('5XC7JWvLGGds4tjaawgY8FwMdotUb5rrEUmxcmyp5ZiW'),
        oracleAccount: new PublicKey('GVXRSBjFk6e6J3NbVPXohDJetcTjaeeuykUpbQF8UoMU'),
        vaultAccount: new PublicKey('B8y9zLxFGw588CEyoEPkZgGtye6DRhaxppCG4zmfues2'),
        socializedLossAccount: new PublicKey('EwGA8GAotukgr6dLXjhMPPc5zA9nSngynUHqYMnSpmz4'),
        greeksAccount: new PublicKey('6A7KX1pRLYzhP2WRtvfUNBmZit2qFt43yxjGN8N192Th'),
        perpSyncQueue: new PublicKey('zcJWvVdpW3QXYBWyEpjv4ejVXCEUiD41ugocaig44s4'),
    },
    {
        symbol: 'ETH',
        groupAccount: new PublicKey('HPnqfiRSVvuBjfHN9ah4Kecb6J9et2UTnNgUwtAJdV26'),
        oracleAccount: new PublicKey('JBu1AL4obBcCMqKBBxhpWCNUt136ijcuMZLFvTP7iWdB'),
        vaultAccount: new PublicKey('EWGc1UC22P6EWuquZD8vbo7FgnmNFccLDeiita9nubME'),
        socializedLossAccount: new PublicKey('6gucuqexxEuY1BBmpJjYWnTt3QaUqkkmsGE7ydRtCkJY'),
        greeksAccount: new PublicKey('A4ZbGoDjbUhmvgSSZD5J9yjpVsYGXXjoTYZrkRdecGAS'),
        perpSyncQueue: new PublicKey('Gbe7yJ78AK6rmsjVf7CxEYwK71pVEsSzJ97JxuxMbCQ8'),
    },
];

export const ZETA_FUTURE_MARKETS: ZetaFutureMarketConfig[] = [
    {
        name: 'SOL/USDC',
        address: new PublicKey('37Chq2NiKcTekr3WwnDdrV6edC2hVfxVkpEPhXJx2KWV'),
        leverage: 5,
        baseSymbol: 'SOL',
        quoteSymbol: 'USDC',
        marketIndex: 22,
        expiryIndex: 0,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('7uWp3Rxd1HGdNWNyFjvBW61StEx5A1u11R91cuq1n9RB'),
        zetaBaseVault: new PublicKey('6igTexTX1SQZWLWocqBZxnyo1PWHmkfT1P5DXfsqWtNo'),
        zetaQuoteVault: new PublicKey('Dkkr4RBdUiNywNk7iMo22ZJn2N64gTXew9LSnon6NrJn'),
        bids: new PublicKey('Hd7J5JqypdqHsx5sL8MzSeZawYMetfcw39BggMKvbLBP'),
        asks: new PublicKey('2Ft6YmhBZJpuZL3fHitHHZFKL7m7AyC9XHDMWUZNrEdU'),
        requestQueue: new PublicKey('4huJFYstGNwUFn6f9coGEz44ie2odRoypawVBeidAKka'),
        eventQueue: new PublicKey('2NKGhYsBmC7yWhcWcFqoVKwWr7eKaNaGbjwyHE7SaRjk'),
        baseVault: new PublicKey('3rRQEJufhTkqj3GEtmhHuFS4deZtPAMQjn8esiwXoKfU'),
        quoteVault: new PublicKey('HthbhY6EqH6PGfNYxn6fUujcHzjBiEcYwHobJ1R7aJ2E'),
        baseMint: new PublicKey('5eKdcMwLmsnmZ3CSNLpsumxoFS6WZKNzW1oQNdxipAAM'),
        quoteMint: new PublicKey('2XRjQTsnHLszFwusQoYmbrKASgYbNG4Z8FsZaUo28HBJ'),
        vaultOwner: new PublicKey('6mDNCysDqXyPBKAqVgsZcMkfYdRUwQZrn8tRZcTewcpX'),
    },
    {
        name: 'SOL/USDC',
        address: new PublicKey('652F3eya36Lk9qLa5gMNGQYT1mEKdcLGkiUbxUztSJAh'),
        leverage: 5,
        baseSymbol: 'SOL',
        quoteSymbol: 'USDC',
        marketIndex: 45,
        expiryIndex: 1,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('73ccTKqh7wEYGDC6mhmB5UfUvZ25FWgj4rtZBwKC4whV'),
        zetaBaseVault: new PublicKey('9NYyGaNC9MaCVM9FtqvtYWp9F8pRvMFpANAqEXHUvFXu'),
        zetaQuoteVault: new PublicKey('77oY1nj4iEw5YHMdLV2Zx1ce3sjM4wdqadEXSkN739jg'),
        bids: new PublicKey('HiMkjfUv11mqaLVt4PYz8Pb1uvtc3yJmi9DBtEjzuHfo'),
        asks: new PublicKey('CVM9TibcKTMgoLLXvL1o7y3A9LbnKhhQkoQ6Hr25SbL1'),
        requestQueue: new PublicKey('9YnB3ySSoj1c2doCttsbVbGmgS84ebWVoVAHDcDGuUrH'),
        eventQueue: new PublicKey('57XHPRzqNQSsCfoQCXNt9ooU1WDsPrMT4ufqQdPZects'),
        baseVault: new PublicKey('5ukPjGw2zMz2YGw9nFeBu3JeyVfcZK7YEq9NRudUtWhP'),
        quoteVault: new PublicKey('D3r1VND8weCNoFybkc5YHeHWaBTdZasysV12J3G6zrPL'),
        baseMint: new PublicKey('Dgwak255GzjK8L4E3b9zD42ZY7sRKLzMsCfRsKSD4kFv'),
        quoteMint: new PublicKey('3Nabu6eAkuq3i2MRTx88B3qtf3ULUoumCKx45hN7CgQL'),
        vaultOwner: new PublicKey('GbFwmBwKqAqAfywz3syXYTJWgj7qFC4hXbYzKfRS6Exg'),
    },
    {
        name: 'BTC/USDC',
        address: new PublicKey('3ubhzPcuqMRKoCrBSxBL4Nnh492sipqaJXmK8TugWXdJ'),
        leverage: 5,
        baseSymbol: 'BTC',
        quoteSymbol: 'USDC',
        marketIndex: 22,
        expiryIndex: 0,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('6Zia9aEEBnyfxhVqpWHPnZoSkrTpHgcC9PUrwwLizokX'),
        zetaBaseVault: new PublicKey('JCfQiCrKD8puLpmzxqxdQRULjGNr9uYpS4KqPtrj8Knc'),
        zetaQuoteVault: new PublicKey('6W6WM1hFCoA3SBTCd2FiF4zLC7DVDpfoFCscQjVwYK1X'),
        bids: new PublicKey('WXzAVceEYY4ugygSzWtKzLzEMXy4kQcbnq75VhaAVSf'),
        asks: new PublicKey('EMgwBXyECv7nKjrifjwt5NdoJKZPS7TCvULPNB7XN9HY'),
        requestQueue: new PublicKey('QxVP3LFd1EEY212LBxL1fQpypGt7YPQh7X4vYk1XAKU'),
        eventQueue: new PublicKey('FGk1xV2qDpGgtuBSokUjCpb37e5fv8wDVaCvK2rQBmtp'),
        baseVault: new PublicKey('6kJkXA9ss3dJnRiz7nPk8UgpZgXETzzJFXHsHaN2JK8E'),
        quoteVault: new PublicKey('8EyEyZqDAhhh3BJTTApm6jkrTyWgvFf1r14yyB8XeLa3'),
        baseMint: new PublicKey('DHALxCahVckZxqt7SzjG3tSTnpydpJE2qsFk7axVDhMm'),
        quoteMint: new PublicKey('4B1DVNsjJbVRJyeFFfudQ8phHaXW2CdfG8RYdBiNdC3A'),
        vaultOwner: new PublicKey('CEUd6j3ZKH7feKtYJNj8JxN8T9rnLcryFpAmq81vJFQ'),
    },
    {
        name: 'BTC/USDC',
        address: new PublicKey('7ayQdHG4h9BQyUWGNmeU58UBPjQaVbkpVXPTFfx4pVdH'),
        leverage: 5,
        baseSymbol: 'BTC',
        quoteSymbol: 'USDC',
        marketIndex: 45,
        expiryIndex: 1,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('BTLpzbf3xbA9usJNBZ8ZpT4dJzgyG2TGnnXMZVH1ka4b'),
        zetaBaseVault: new PublicKey('3vQGr5ZuMeB6xXZkTDWggbCy94bdPtwSZVcYAM9i8noP'),
        zetaQuoteVault: new PublicKey('DFUswUXwZesLdvk2YaU7Z8YzinBUSyXiuoqJmfbQkCbi'),
        bids: new PublicKey('5HeLL4po1P55fmxKCAf67qyYuZPne2eKmwhib9QDSYzc'),
        asks: new PublicKey('4J1UEiwYNxL5fnbAGRcVERYesYV2a6XUKvQMVSxRBWZz'),
        requestQueue: new PublicKey('AyAZf5TynHrfBwYPbMkU9hX3bEHTQPokTox6WK1KmjWw'),
        eventQueue: new PublicKey('5nEDKv1NkNMPLqVpNKxYoudtuGXaQcsEXV9FxUXE9iyu'),
        baseVault: new PublicKey('ARTR2VWZcfSrH8GMF3JDBDm4TP3p2dBAvqVt7PKc1FFn'),
        quoteVault: new PublicKey('JC3Xn6TqkhRAQFKCW4grziLWKKZWmhit6om5zpS9x7Tj'),
        baseMint: new PublicKey('AhM1M85JmL77DeCcPVh7gCF9NP7bHuNphT9ez5g6aHyt'),
        quoteMint: new PublicKey('6fBnX78rRMNS7ZMsCTPfjvguiBNE5zLdioGzLvW4zkcK'),
        vaultOwner: new PublicKey('GUwD99aaZUCkMPk44M1eTKDjRcrBnco6jb9s7Y9x3ZsW'),
    },
    {
        name: 'ETH/USDC',
        address: new PublicKey('4A9WSdRr4ANz1izgiZx7yn17BqqJKz3R6NHNnqbCEUBK'),
        leverage: 5,
        baseSymbol: 'ETH',
        quoteSymbol: 'USDC',
        marketIndex: 22,
        expiryIndex: 0,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('798H5KUGcNXYsiZnE11iAtgYRQPPCqKWbhKZr3MP2NX2'),
        zetaBaseVault: new PublicKey('BWhCv8j63woXeJWSQZeTgfpNFvDGGZXPEzee2sf24XN4'),
        zetaQuoteVault: new PublicKey('44arqhvySh2FeWioHGYwk9xmG2HKcUfgsn5iCTVddFox'),
        bids: new PublicKey('5PjjLrxpL9A4msEq8wxCLafChTGDtGuB6guu7DdahMHx'),
        asks: new PublicKey('8JrvMgV17qAUKc92sx8F1dBr9uxPsuSFYVrTVAyFNcrX'),
        requestQueue: new PublicKey('2XE9UogQr5AWsFezrACgmtB4rGwvp2JXz6LVwiaxtWWJ'),
        eventQueue: new PublicKey('5iyZ77EtSuENywUaXECnyX2gvBNwSD8oXgFxrh36v3Bh'),
        baseVault: new PublicKey('QeuweZYLVXraveMNxYrs1AcKW2uPWmbRf2BPswRuZTZ'),
        quoteVault: new PublicKey('uEEx9N59XtZaMimxJtwb7VZUKLz3vPSD61QDKgnGwK6'),
        baseMint: new PublicKey('EhetHAcNHW3KaGdiQMouPn1zp5Y4kbNCnnYGeqJ9JiAR'),
        quoteMint: new PublicKey('4pdHFUcdBhw8pr4ygw52nhuKhJkbohj9Hxxuhq5qXpVZ'),
        vaultOwner: new PublicKey('J3XpoJiunwaP8p9KmkiU2UJyhaojFax9HLnPDhFduP2M'),
    },
    {
        name: 'ETH/USDC',
        address: new PublicKey('7kFe7bYSfGTVeBowWcVE2VRHtgTA5YTyMXLhddbrawza'),
        leverage: 5,
        baseSymbol: 'ETH',
        quoteSymbol: 'USDC',
        marketIndex: 45,
        expiryIndex: 1,
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        greekNodeKey: new PublicKey('ATvAsdK1PVDJXeRsUD3MvjfhqwUVAN1YjUxCWzScGpQC'),
        zetaBaseVault: new PublicKey('FN1VHiqcx3KUHFZtnq328y3gsw3FvYxtoqMS3MM1FXGW'),
        zetaQuoteVault: new PublicKey('4cUdYxuPANkVuh7EXsKLniRisNomn3BHFi6KXew1Mrxa'),
        bids: new PublicKey('J6gGFm11pSbnMNpUEgDnwAUit1uL8LN6MmhS8u4BDpM9'),
        asks: new PublicKey('QMissYZb3HWXU1tS3vqQQQH6LM7WBUUiHrX36FoFYdy'),
        requestQueue: new PublicKey('G1cRBNHTRH4gaYVirZMk4EtfRQU3t4iirhGNyXMBZpVb'),
        eventQueue: new PublicKey('H6a8Rt1ACXpP14FrBRJNmg8k9aTDmjfxb3e1edCYuSE1'),
        baseVault: new PublicKey('DXZEeBZdH8wkiivNABpwskGkazqYRPAbNPzmboVvDnhV'),
        quoteVault: new PublicKey('7SeRNGUw2ziFKgnUot5dCyJwQPgzfJLpyZ8BM8osLkVu'),
        baseMint: new PublicKey('8tgEAtnHFFcWKd5VhgE5nt3pbEAC4D1drEGcSA1ZGfBP'),
        quoteMint: new PublicKey('H9tywwzSFbqEuFPvYyvFfrQr7jaqAoRYx963Q2qGbFNA'),
        vaultOwner: new PublicKey('Hz15AZHpye8a3PE7u8K5Dqv9radzH9acWqbkYnX4Kh9H'),
    },
];

export const ZETA_PERP_MARKETS: ZetaPerpMarketConfig[] = [
    {
        name: 'SOL-PERP',
        address: new PublicKey('JE6d41JRokZAMUEAznV8JP4h7i6Ain6CyJrQuweRipFU'),
        leverage: 5,
        baseSymbol: 'SOL',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        zetaBaseVault: new PublicKey('GYm6qTFwkGJx2ywetEuYrjHjhzVFCM2TwayyqS1HUPLG'),
        zetaQuoteVault: new PublicKey('7aXkF7AZE2D3h128eNJ7VVp72HCV1izjKFsJ8uNWtCFN'),
        bids: new PublicKey('HcjrQKnbqKJuxHDLNM9LJPyxcQs237waNZXW7RwgvAps'),
        asks: new PublicKey('Ec4xsLLgLc4wM5c19ZSvazE7M9Rtk2T6RzddNcSQKYGu'),
        requestQueue: new PublicKey('EaNR74nCjrYyNDsuoWmq19pH76QSd1nuTzvJSr3RDQ6x'),
        eventQueue: new PublicKey('3rjBffJkFa9zdGr9xmTVxF3y6nL6iL1pASVzym7s5FGr'),
        baseVault: new PublicKey('BEjGhNFnKT5weGtpBoFs5Y1mDN47Ntvag5aMV59nZRpk'),
        quoteVault: new PublicKey('CHBUBfU3zscTNsihdK3x44TbpTza1hwcsTUaZfk751b5'),
        baseMint: new PublicKey('2ZLdhFsrkAtdn9Kud4SZvqchQFvn5jVCHUdJ83vumKyR'),
        quoteMint: new PublicKey('BKt2FdgBahn77joeawhNidswFxfgasPYCHWghRL4AKBR'),
        vaultOwner: new PublicKey('3zqD2BwyXqKKjj5USunJTnFAij9g6ZaZVfVoRpr8XH2B'),
    },
    {
        name: 'BTC-PERP',
        address: new PublicKey('J5DTCqRAjX1FyzoP2A2HVmmaXuG971HJ8X1Z8Rvvd8uT'),
        leverage: 5,
        baseSymbol: 'BTC',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        zetaBaseVault: new PublicKey('5mvaZWcZa4gB3JZptZuFAJnmDFfo1JovhqTkkfEcsryD'),
        zetaQuoteVault: new PublicKey('DboTtkWW3KPvT14fag8N6iDUyDXaT8FeBszGV9xdfBx2'),
        bids: new PublicKey('8JSbFw4YT3bzpbbHs1wKmRCSAmKucAba7XSUWj1p8xK5'),
        asks: new PublicKey('483SmqGQVxw3WDwcewMYHqC3Mu7ENxfTQJQtTR3ttpi7'),
        requestQueue: new PublicKey('6JSdqUr24mBt4MCQrZHRoSfeZbjgALx4MQunZwD8Uarg'),
        eventQueue: new PublicKey('4K1zxqAZn7bGAPN26W5mUaHrLMSpCk45gT4qVXwmfh39'),
        baseVault: new PublicKey('DbzL5mT4nBaxuAs8ti4UeT2qougRBdujxa7GhLndM5Jz'),
        quoteVault: new PublicKey('7M9xhY2ARnrkCaBK5SNM3Lyd3FdbTu2EWBwG4TQcqpsv'),
        baseMint: new PublicKey('63DZkAzoDXmzGzn9esoWSYpMLo4YB9oPHXreHKwuu4HA'),
        quoteMint: new PublicKey('DhMH8oRQoAAb6poHVsvCqq3NCMj6aKUH2tGQG5Lo4bCg'),
        vaultOwner: new PublicKey('ExV76Y8vas6rNibjnnKzC6xXxduyWvRHbF5gDrPUWXe8'),
    },
    {
        name: 'ETH-PERP',
        address: new PublicKey('J8x6y5G7GmTkuKTbbCAnfhn72vaUU2qsB6je9oKFigHM'),
        leverage: 5,
        baseSymbol: 'ETH',
        quoteSymbol: 'USDC',
        orderPriceDecimals: 4,
        orderQuantityDecimals: 3,
        zetaBaseVault: new PublicKey('8SH6uJe5rV13APZFQvkGdXPwTyeiLv67XTnv3EeYff3B'),
        zetaQuoteVault: new PublicKey('DhWWXYK2DSnCdK5rkAxJBkGb1SBR49RHpfHj2u1vobCJ'),
        bids: new PublicKey('CaqN8gomPEB1My2czRhetrj5ESKP3VRR3kwKhXtGxohG'),
        asks: new PublicKey('4oAjuVLt5N9au2X3bhYLSi9LRqtk4caBvSPQRwhXuEKP'),
        requestQueue: new PublicKey('A7D8zuxAmtui3XKz2VcxthAZ5HuwLbN74rrDapMJ3Z5d'),
        eventQueue: new PublicKey('CzK26LWpoU9UjSrZkVu97oZj63abJrNv1zp9Hy2zZdy5'),
        baseVault: new PublicKey('9YVE9r9cHFZNwm91p3Js8NBWVznesLSM8FZyswG2MG1B'),
        quoteVault: new PublicKey('DecjLCYjb7jdDp2UqA2MS4xjgDjZfvdgMjvkRW7oWs9L'),
        baseMint: new PublicKey('2Stzi7XE3btUQXaauTVB9brPAtPmGnrEDSJmp3w5VY2j'),
        quoteMint: new PublicKey('5Ehp2LtTRmjug39GphXhFEeguz7hGeg41N1U49wU8Kov'),
        vaultOwner: new PublicKey('53uJuK3KmRsVHhTVsrnJHGBxRQGZb5hEyW8NxwzyPaJC'),
    },
];

'''
'''--- src/error.ts ---
import { BotType, Protocol } from './type';

export class BotAccountNotFoundError extends Error {
    constructor(botSeed: string) {
        super(`Bot account not found, seed: ${botSeed}`);
        this.name = 'BotAccountNotFoundError';
    }
}

export class MangoSpotMarketNotFoundError extends Error {
    constructor(marketAddress: string) {
        super(`Mango spot market not found for address ${marketAddress}!`);
        this.name = 'MangoSpotMarketNotFoundError';
    }
}

export class MangoPerpMarketNotFoundError extends Error {
    constructor(marketAddress: string) {
        super(`Mango perp market not found for address ${marketAddress}!`);
        this.name = 'MangoPerpMarketNotFoundError';
    }
}

export class MangoSpotMarketNotFoundByNameError extends Error {
    constructor(marketName: string) {
        super(`Mango spot market not found for name ${marketName}!`);
        this.name = 'MangoSpotMarketNotFoundByNameError';
    }
}

export class MangoGroupConfigNotFoundError extends Error {
    constructor(mangoGroupName: string) {
        super(`Mango group config not found for name ${mangoGroupName}!`);
        this.name = 'MangoGroupConfigNotFoundError';
    }
}

export class BotMangoAccountNotFoundError extends Error {
    constructor(botSeed: string) {
        super(`No available mango account for bot ${botSeed}!`);
        this.name = 'BotMangoAccountNotFoundError';
    }
}

export class SerumMarketNotFoundError extends Error {
    constructor(marketAddress: string) {
        super(`Serum market not found for address ${marketAddress}!`);
        this.name = 'NoAvailableSwapMarketForTokenError';
    }
}

export class BotProtocolTypeNotSupportedError extends Error {
    constructor(botSeed: string, protocolType: Protocol) {
        super(`Bot ${botSeed} protocol type ${protocolType} not supported!`);
        this.name = 'BotProtocolTypeNotSupportedError';
    }
}

export class BotMarketNotSupportedError extends Error {
    constructor(botSeed: string, marketAddress: string) {
        super(`Bot ${botSeed} market ${marketAddress} not supported!`);
        this.name = 'BotMarketNotSupportedError';
    }
}

export class BotTypeNotSupportedError extends Error {
    constructor(botType: BotType) {
        super(`Bot type ${botType} not supported!`);
        this.name = 'BotTypeNotSupportedError';
    }
}

export class BotLeverageExceedMarketMaxLimitError extends Error {
    constructor(botSeed: string, marketAddress: string, marketLeverageLimit: number) {
        super(`Bot ${botSeed} leverage exceed market ${marketAddress} max leverage limit ${marketLeverageLimit}!`);
        this.name = 'BotLeverageExceedMarketMaxLimitError';
    }
}

export class BotZetaMarginAccountNotFoundError extends Error {
    constructor(botSeed: string) {
        super(`No available zeta margin account for bot ${botSeed}!`);
        this.name = 'BotZetaMarginAccountNotFoundError';
    }
}

export class ZetaGroupAccountNotFoundError extends Error {
    constructor(zetaGroupAccountAddress: string) {
        super(`Zeta group account not available: ${zetaGroupAccountAddress}!`);
        this.name = 'ZetaGroupAccountNotFoundError';
    }
}

export class CellConfigAccountNotFoundError extends Error {
    constructor(cellConfigKey: string) {
        super(`Cell config account not found for address ${cellConfigKey}!`);
        this.name = 'CellConfigAccountNotFoundError';
    }
}

export class PythPriceNotFoundError extends Error {
    constructor(priceKey: string) {
        super(`Pyth price not found for address ${priceKey}!`);
        this.name = 'PythPriceNotFoundError';
    }
}

export class CellCacheNotFoundError extends Error {
    constructor(botSeed: string, userAddress: string) {
        super(`Cell cache not found, seed: ${botSeed}, user ${userAddress}!`);
        this.name = 'CellCacheNotFoundError';
    }
}

'''
'''--- src/index.ts ---
export * from './Bot';
export * from './error';
export * from './instruction';
export * from './layout';
export * from './type';
export * from './Pool';
export * from './constant';
export * from './util';
export * from './Stragety';

'''
'''--- src/instruction/bot.instruction.ts ---
import {
    CellConfigReallocIxParams,
    CreateBotIxParams,
    CreateCellConfigAccountIxParams,
    InstructionIndex,
    RedeemAllAssetsFromBotIxParams,
    SetBotGridInfoIxParams,
    SetBotReferrerkeyIxParams,
    SetCellConfigDelegateIxParams,
    SetCellConfigIxParams,
    SetCellConfigReserveInfoIxParams,
    SetCellFeeIxParams,
    SetPoolWithdrawOnlyIxParams,
    StartBotIxParams,
    StopBotIxParams,
    UpdateBotInfoIxParams,
    UpgradeBotInfo2IxParams,
    UpgradeBotInfoIxParams,
} from '../type';
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { Numberu16, Numberu32, Numberu64, Numberu8 } from '../util';
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';

export function createBotIx(params: CreateBotIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.CreateBot])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.depositQuoteBalance.toString()).toBuffer(),
            new Numberu64(params.depositBaseBalance.toString()).toBuffer(),
            new Numberu64(params.lowerPrice.toString()).toBuffer(),
            new Numberu64(params.upperPrice.toString()).toBuffer(),
            new Numberu16(params.gridNum.toString()).toBuffer(),
            new Numberu16(params.leverage.toString()).toBuffer(),
            Buffer.from(Int8Array.from([params.protocol])),
            Buffer.from(Int8Array.from([params.botType])),
            new Numberu8(params.stopTopRatio.toString()).toBuffer(),
            new Numberu8(params.stopBottomRatio.toString()).toBuffer(),
            new Numberu8(params.trigger ? 1 : 0).toBuffer(),
            new Numberu8(params.isPool ? 1 : 0).toBuffer(),
            new Numberu64(params.startPrice.toString()).toBuffer(),
            new Numberu8(params.isDualDeposit ? 1 : 0).toBuffer(),
        ]),
        keys: [
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.botMintKey, isSigner: false, isWritable: true },
            { pubkey: params.userBotTokenKey, isSigner: false, isWritable: true },
            { pubkey: params.userKey, isSigner: true, isWritable: false },
            { pubkey: params.cellCacheAccount, isSigner: false, isWritable: true },
            { pubkey: params.marketKey, isSigner: false, isWritable: false },
            ...params.botAssetKeys.map((botAssetKey) => {
                return { pubkey: botAssetKey, isSigner: false, isWritable: true };
            }),
            ...params.userAssetKeys.map((userAssetKey) => {
                return { pubkey: userAssetKey, isSigner: false, isWritable: true };
            }),
            ...params.assetPriceKeys.map((assetPriceKey) => {
                return { pubkey: assetPriceKey, isSigner: false, isWritable: false };
            }),
        ],
        programId: params.programId,
    });
}

export function redeemAllAssetsFromBotIx(params: RedeemAllAssetsFromBotIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.RedeemAllAssetsFromBot])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigKey, isSigner: false, isWritable: false },
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.botMintKey, isSigner: false, isWritable: true },
            { pubkey: params.userBotTokenKey, isSigner: false, isWritable: true },
            { pubkey: params.userKey, isSigner: true, isWritable: false },
            { pubkey: params.referrerKey, isSigner: false, isWritable: false },
            ...params.botAssetKeys.map((botAssetKey) => {
                return { pubkey: botAssetKey, isSigner: false, isWritable: true };
            }),
            ...params.userAssetKeys.map((userAssetKey) => {
                return { pubkey: userAssetKey, isSigner: false, isWritable: true };
            }),
            ...params.cellAssetKeys.map((cellAssetKey) => {
                return { pubkey: cellAssetKey, isSigner: false, isWritable: true };
            }),
            ...params.assetPriceKeys.map((assetPriceKey) => {
                return { pubkey: assetPriceKey, isSigner: false, isWritable: false };
            }),
            ...params.referrerAssetKeys.map((i) => {
                return { pubkey: i, isSigner: false, isWritable: true };
            }),
        ],
        programId: params.programId,
    });
}

export function startBotIx(params: StartBotIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.StartBot])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.userKey, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function stopBotIx(params: StopBotIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([Buffer.from(Int8Array.from([InstructionIndex.StopBot])), Buffer.concat([params.botSeed])]),
        keys: [
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.userKey, isSigner: true, isWritable: false },
            { pubkey: params.pythPriceAccount, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function createCellConfigAccountIx(params: CreateCellConfigAccountIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([Buffer.from(Int8Array.from([InstructionIndex.CreateCellConfigAccount]))]),
        keys: [
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigKey, isSigner: false, isWritable: true },
            { pubkey: params.adminAccount, isSigner: false, isWritable: false },
            { pubkey: params.payerAccount, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setCellFeeIx(params: SetCellFeeIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetCellFee])),
            new Numberu32(params.feePercent).toBuffer(),
        ]),
        keys: [
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.adminOrDelegateAccount, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setCellConfigDelegateIx(params: SetCellConfigDelegateIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([Buffer.from(Int8Array.from([InstructionIndex.SetCellConfigDelegate]))]),
        keys: [
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.delegateAccount, isSigner: false, isWritable: false },
            { pubkey: params.adminAccount, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function updateBotInfoIx(params: UpdateBotInfoIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.UpdateBotInfo])),
            Buffer.concat([params.botSeed]),
            Buffer.from(Int8Array.from([params.botType])),
            new Numberu8(params.stopTopRatio).toBuffer(),
            new Numberu8(params.stopBottomRatio).toBuffer(),
            new Numberu8(params.trigger).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.delegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setCellConfigReserveInfoIx(params: SetCellConfigReserveInfoIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetCellConfigReserveInfo])),
            new Numberu8(params.reserveRatio).toBuffer(),
            new Numberu64(params.reserveFreq).toBuffer(),
        ]),
        keys: [
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.adminOrDelegateAccount, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setBotGridInfoIx(params: SetBotGridInfoIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetBotGridInfo])),
            new Numberu64(params.amountToTrade).toBuffer(),
            new Numberu64(params.upperPrice).toBuffer(),
            new Numberu64(params.lowerPrice).toBuffer(),
            new Numberu16(params.gridNum).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setPoolWithdrawOnlyIx(params: SetPoolWithdrawOnlyIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetPoolWithdrawOnly])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.delegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function setCellConfigIx(params: SetCellConfigIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetCellConfig])),
            params.delegate.toBuffer(),
            new Numberu64(params.createBotLine).toBuffer(),
            new Numberu64(params.stopBotLine).toBuffer(),
            new Numberu64(params.reserveFreq).toBuffer(),
            Buffer.from(Int8Array.from([params.reserveRatio])),
            Buffer.from(Int8Array.from([params.performanceFeeRatio])),
            Buffer.from(Int8Array.from([params.botOwnerMostPerformanceFeeRatio])),
            Buffer.from(Int8Array.from([params.performanceFeeDiscount])),
            Buffer.from(Int8Array.from([params.referrerPerformanceFeeRatio])),
        ]),
        keys: [
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.adminAccount, isSigner: true, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function cellConfigReallocIx(params: CellConfigReallocIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.CellConfigRealloc])),
            new Numberu16(params.addSize).toBuffer(),
        ]),
        keys: [
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.adminAccount, isSigner: true, isWritable: true },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function upgradeBotInfoIx(params: UpgradeBotInfoIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.UpgradeBotInfo])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.payerKey, isSigner: true, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function upgradeBotInfo2Ix(params: UpgradeBotInfo2IxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.UpgradeBotInfo2])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.upperPrice).toBuffer(),
            new Numberu64(params.lowerPrice).toBuffer(),
            new Numberu64(params.startPrice).toBuffer(),
        ]),
        keys: [{ pubkey: params.botKey, isSigner: false, isWritable: true }],
        programId: params.programId,
    });
}

export function setBotReferrerkeyIx(params: SetBotReferrerkeyIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SetBotReferrerKey])),
            Buffer.concat([params.botSeed]),
            params.referrerKey.toBuffer(),
        ]),
        keys: [
            { pubkey: params.botKey, isSigner: false, isWritable: true },
            { pubkey: params.userKey, isSigner: true, isWritable: true },
        ],
        programId: params.programId,
    });
}

'''
'''--- src/instruction/common.instruction.ts ---
import { createATAIxParams } from '../type';
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';

export function createATAIx(params: createATAIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.from([]),
        keys: [
            { pubkey: params.payerKey, isSigner: true, isWritable: true },
            { pubkey: params.ataKey, isSigner: false, isWritable: true },
            { pubkey: params.ownerKey, isSigner: false, isWritable: false },
            { pubkey: params.mintKey, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ],
        programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    });
}

'''
'''--- src/instruction/index.ts ---
export * from './common.instruction';
export * from './bot.instruction';
export * from './zeta.instruction';
export * from './serum.instruction';
export * from './mango.instruction';

'''
'''--- src/instruction/mango.instruction.ts ---
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import {InstructionIndex, MangoCreateReimbursementAccountIxParams, MangoReimbursementIxParams} from '../type';
import { MANGO_REIMBURSEMENT_GROUP_KEY, MANGO_REIMBURSEMENT_PROGRAM_ID } from '../constant';
import { Numberu64 } from '../util';
import {TOKEN_PROGRAM_ID} from "@solana/spl-token";

export function createMangoReimbursementAccountIx(
    params: MangoCreateReimbursementAccountIxParams,
): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.CreateReimbursementAccount])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: MANGO_REIMBURSEMENT_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: MANGO_REIMBURSEMENT_GROUP_KEY, isSigner: false, isWritable: false },
            { pubkey: params.reimbursementAccount, isSigner: false, isWritable: true },
            { pubkey: params.mangoAccountOwnerAccount, isSigner: false, isWritable: true },
            { pubkey: params.payer, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function mangoReimbursementIx(params: MangoReimbursementIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.MangoReimbursement])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.tokenIndex).toBuffer(),
            new Numberu64(params.indexIntoTable).toBuffer(),
        ]),
        keys: [
            { pubkey: MANGO_REIMBURSEMENT_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: MANGO_REIMBURSEMENT_GROUP_KEY, isSigner: false, isWritable: false },
            { pubkey: params.vaultAccount, isSigner: false, isWritable: true },
            { pubkey: params.tokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.reimbursementAccount, isSigner: false, isWritable: true },
            { pubkey: params.mangoAccountOwnerAccount, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.claimMintTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.claimMintAccount, isSigner: false, isWritable: true },
            { pubkey: params.reimbursementTableAccount, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

'''
'''--- src/instruction/serum.instruction.ts ---
import {
    InstructionIndex,
    SerumCancelOrderIxParams,
    SerumCloseOpenOrdersIxParams,
    SerumInitOpenOrdersIxParams,
    SerumPlaceOrderIxParams,
    SerumPoolAdjustReserveIxParams,
    SerumPoolDepositIxParams,
    SerumPoolWithdrawIxParams,
    SerumSettleFundsIxParams,
} from '../type';
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { Numberu128, Numberu64 } from '../util';
import { SERUM_PROGRAM_ID } from '../constant';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';

export function serumPlaceOrderIx(params: SerumPlaceOrderIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumPlaceOrder])),
            Buffer.concat([params.botSeed]),
            Buffer.from(Int8Array.from([params.side])),
            Buffer.from(Int8Array.from([params.orderType])),
            new Numberu64(params.limitPrice.toString()).toBuffer(),
            new Numberu64(params.amountToTrade.toString()).toBuffer(),
            new Numberu64(params.coinLotSize.toString()).toBuffer(),
            new Numberu64(params.pcLotSize.toString()).toBuffer(),
            new Numberu64(params.clientOrderId.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.requestQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.eventQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.bidsAccount, isSigner: false, isWritable: true },
            { pubkey: params.asksAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAccount, isSigner: false, isWritable: true },
            { pubkey: params.coinVault, isSigner: false, isWritable: true },
            { pubkey: params.pcVault, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumSettleFundsIx(params: SerumSettleFundsIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumSettleFunds])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.coinVault, isSigner: false, isWritable: true },
            { pubkey: params.coinWalletAccount, isSigner: false, isWritable: true },
            { pubkey: params.pcVault, isSigner: false, isWritable: true },
            { pubkey: params.pcWalletAccount, isSigner: false, isWritable: true },
            { pubkey: params.vaultSigner, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumCancelOrderIx(params: SerumCancelOrderIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumCancelOrder])),
            Buffer.concat([params.botSeed]),
            Buffer.from(Int8Array.from([params.side])),
            new Numberu128(params.orderId).toBuffer(),
        ]),
        keys: [
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: params.bidsAccount, isSigner: false, isWritable: true },
            { pubkey: params.asksAccount, isSigner: false, isWritable: true },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAccount, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.eventQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumInitOpenOrdersIx(params: SerumInitOpenOrdersIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumInitOpenOrders])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: true },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAccount, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumCloseOpenOrdersIx(params: SerumCloseOpenOrdersIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumCloseOpenOrders])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOrWorkingCapAccount, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.userAccount, isSigner: false, isWritable: true },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumPoolDepositIx(params: SerumPoolDepositIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumPoolDeposit])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.botMintAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorAccount, isSigner: true, isWritable: false },
            { pubkey: params.investorAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorBotTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapBaseTokenAccount, isSigner: false, isWritable: false },
            { pubkey: params.workingCapQuoteTokenAccount, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellCacheAccount, isSigner: false, isWritable: true },
            { pubkey: params.baseTokenPythPriceAccount, isSigner: false, isWritable: false },
            { pubkey: params.quoteTokenPythPriceAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumPoolWithdrawIx(params: SerumPoolWithdrawIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumPoolWithdraw])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.botMintAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorAccount, isSigner: true, isWritable: false },
            { pubkey: params.investorAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorBotTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellCacheAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.botOwnerAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapBaseTokenAccount, isSigner: false, isWritable: false },
            { pubkey: params.workingCapQuoteTokenAccount, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.baseTokenPythPriceAccount, isSigner: false, isWritable: false },
            { pubkey: params.quoteTokenPythPriceAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function serumPoolAdjustReserveIx(params: SerumPoolAdjustReserveIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.SerumPoolAdjustReserve])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: false, isWritable: false },
            { pubkey: params.botAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapAccount, isSigner: false, isWritable: true },
            { pubkey: params.workingCapBaseTokenAccount, isSigner: false, isWritable: false },
            { pubkey: params.workingCapQuoteTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: SERUM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.baseTokenPythPriceAccount, isSigner: false, isWritable: false },
            { pubkey: params.quoteTokenPythPriceAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

'''
'''--- src/instruction/zeta.instruction.ts ---
import {
    CancelZetaOrderIxParams,
    CloseZetaOpenOrdersIxParams,
    DepositToZetaIxParams,
    InitZetaMarginAccountIxParams,
    InitZetaOpenOrdersIxParams,
    InstructionIndex,
    PlaceZetaOrderIxParams,
    PlaceZetaPerpOrderIxParams,
    SettleZetaMarketIxParams,
    WithdrawFromZetaIxParams,
    ZetaPoolAdjustReserveIxParams,
    ZetaPoolDepositIxParams,
    ZetaPoolWithdrawIxParams,
} from '../type';
import { SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import {
    ZETA_DEX_PROGRAM_ID,
    ZETA_MINT_AUTHORITY_KEY,
    ZETA_PROGRAM_ID,
    ZETA_SERUM_AUTHORITY_KEY,
    ZETA_STATE_ACCOUNT,
} from '../constant';
import { Numberu128, Numberu64, Numberu8 } from '../util';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';

export function initZetaMarginAccountIx(params: InitZetaMarginAccountIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.InitZetaMarginAccount])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function depositToZetaIx(params: DepositToZetaIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.DepositToZeta])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaVaultKey, isSigner: false, isWritable: true },
            { pubkey: params.botTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaSocializedLossKey, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksKey, isSigner: false, isWritable: false },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function withdrawFromZetaIx(params: WithdrawFromZetaIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.WithdrawFromZeta])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaVaultKey, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: params.botTokenAccount, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupOracleKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaSocializedLossKey, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function initZetaOpenOrdersIx(params: InitZetaOpenOrdersIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.InitZetaOpenOrders])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersMapAccount, isSigner: false, isWritable: true },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function placeZetaOrderIx(params: PlaceZetaOrderIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.PlaceZetaOrder])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.price.toString()).toBuffer(),
            new Numberu64(params.size.toString()).toBuffer(),
            Buffer.from(Int8Array.from([params.side])),
            Buffer.from(Int8Array.from([params.orderType])),
            new Numberu64(params.clientOrderId).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksKey, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: params.requestQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.eventQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.bidsAccount, isSigner: false, isWritable: true },
            { pubkey: params.asksAccount, isSigner: false, isWritable: true },
            { pubkey: params.orderPayerTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.coinVault, isSigner: false, isWritable: true },
            { pubkey: params.pcVault, isSigner: false, isWritable: true },
            { pubkey: params.coinWallet, isSigner: false, isWritable: true },
            { pubkey: params.pcWallet, isSigner: false, isWritable: true },
            { pubkey: params.zetaGroupOracleKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarketNode, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarketMint, isSigner: false, isWritable: true },
            { pubkey: ZETA_MINT_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function cancelZetaOrderIx(params: CancelZetaOrderIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.CancelZetaOrder])),
            Buffer.concat([params.botSeed]),
            Buffer.from(Int8Array.from([params.side])),
            new Numberu128(params.orderId).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: params.bidsAccount, isSigner: false, isWritable: true },
            { pubkey: params.asksAccount, isSigner: false, isWritable: true },
            { pubkey: params.eventQueueAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function closeZetaOpenOrdersIx(params: CloseZetaOpenOrdersIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.CloseZetaOpenOrders])),
            Buffer.concat([params.botSeed]),
            new Numberu8(params.openOrdersMapNonce).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: true },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: params.marketAccount, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersMapAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.userKey, isSigner: false, isWritable: true },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function settleZetaMarketIx(params: SettleZetaMarketIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([new Numberu64('16289140328060839845').toBuffer()]),
        keys: [
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.marketKey, isSigner: false, isWritable: true },
            { pubkey: params.baseVault, isSigner: false, isWritable: true },
            { pubkey: params.quoteVault, isSigner: false, isWritable: true },
            { pubkey: params.dexBaseVault, isSigner: false, isWritable: true },
            { pubkey: params.dexQuoteVault, isSigner: false, isWritable: true },
            { pubkey: params.vaultOwner, isSigner: false, isWritable: false },
            { pubkey: ZETA_MINT_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
        ],
        programId: ZETA_PROGRAM_ID,
    });
}

export function zetaPoolDepositIx(params: ZetaPoolDepositIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.ZetaPoolDeposit])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.botMintAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorAccount, isSigner: true, isWritable: false },
            { pubkey: params.investorAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorBotTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellCacheAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupAccount, isSigner: false, isWritable: false },
            { pubkey: params.pythPriceAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function zetaPoolWithdrawIx(params: ZetaPoolWithdrawIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.ZetaPoolWithdraw])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.amount.toString()).toBuffer(),
        ]),
        keys: [
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.botAccount, isSigner: false, isWritable: false },
            { pubkey: params.botMintAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorAccount, isSigner: true, isWritable: false },
            { pubkey: params.investorAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.investorBotTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellCacheAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: true },
            { pubkey: params.cellAssetAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupAccount, isSigner: false, isWritable: false },
            { pubkey: params.pythPriceAccount, isSigner: false, isWritable: false },
            { pubkey: params.botOwnerAssetAccount, isSigner: false, isWritable: true },
        ],
        programId: params.programId,
    });
}

export function zetaPoolAdjustReserveIx(params: ZetaPoolAdjustReserveIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.ZetaPoolAdjustReserve])),
            Buffer.concat([params.botSeed]),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaVaultAccount, isSigner: false, isWritable: true },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: params.botAssetTokenAccount, isSigner: false, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaOracleAccount, isSigner: false, isWritable: false },
            { pubkey: params.zetaSocializedLossAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
            { pubkey: params.pythPriceAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

export function placeZetaPerpOrderIx(params: PlaceZetaPerpOrderIxParams): TransactionInstruction {
    return new TransactionInstruction({
        data: Buffer.concat([
            Buffer.from(Int8Array.from([InstructionIndex.PlaceZetaPerpOrder])),
            Buffer.concat([params.botSeed]),
            new Numberu64(params.price.toString()).toBuffer(),
            new Numberu64(params.size.toString()).toBuffer(),
            Buffer.from(Int8Array.from([params.side])),
            Buffer.from(Int8Array.from([params.orderType])),
            // Buffer.from(Int8Array.from([1])),
            new Numberu64(params.clientOrderId).toBuffer(),
        ]),
        keys: [
            { pubkey: params.botAccount, isSigner: false, isWritable: true },
            { pubkey: params.userOrBotDelegateAccount, isSigner: true, isWritable: false },
            { pubkey: ZETA_STATE_ACCOUNT, isSigner: false, isWritable: false },
            { pubkey: params.zetaGroupKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarginAccount, isSigner: false, isWritable: true },
            { pubkey: ZETA_DEX_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: ZETA_SERUM_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.zetaGreeksKey, isSigner: false, isWritable: false },
            { pubkey: params.openOrdersAccount, isSigner: false, isWritable: true },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: params.marketAccount, isSigner: false, isWritable: true },
            { pubkey: params.requestQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.eventQueueAccount, isSigner: false, isWritable: true },
            { pubkey: params.bidsAccount, isSigner: false, isWritable: true },
            { pubkey: params.asksAccount, isSigner: false, isWritable: true },
            { pubkey: params.orderPayerTokenAccount, isSigner: false, isWritable: true },
            { pubkey: params.coinVault, isSigner: false, isWritable: true },
            { pubkey: params.pcVault, isSigner: false, isWritable: true },
            { pubkey: params.coinWallet, isSigner: false, isWritable: true },
            { pubkey: params.pcWallet, isSigner: false, isWritable: true },
            { pubkey: params.zetaGroupOracleKey, isSigner: false, isWritable: false },
            { pubkey: params.zetaMarketMint, isSigner: false, isWritable: true },
            { pubkey: ZETA_MINT_AUTHORITY_KEY, isSigner: false, isWritable: false },
            { pubkey: params.perpSyncQueue, isSigner: false, isWritable: true },
            { pubkey: ZETA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: params.cellConfigAccount, isSigner: false, isWritable: false },
        ],
        programId: params.programId,
    });
}

'''
'''--- src/layout/bot.layout.ts ---
import BN from 'bn.js';
import { seq, struct, Structure, u16, u8 } from 'buffer-layout';
import { bool, publicKeyLayout, u128, u64 } from '@blockworks-foundation/mango-client';
import { PublicKey } from '@solana/web3.js';
import { BotStatus, BotType, Protocol } from '../type';
import Decimal from 'decimal.js';
import { bnToDecimal } from '../util';

export class BotAccount {
    seed: Uint8Array;
    owner: PublicKey;
    status: BotStatus;
    amount: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
    market: PublicKey;
    leverage: Decimal;
    depositedAssetsQuantity: BN[];
    protocol: Protocol;
    type: BotType;
    stopTopRatio: Decimal;
    stopBottomRatio: Decimal;
    trigger: boolean;
    lastAdjustReserveTs: Decimal;
    isPool: boolean;
    startPrice: Decimal;
    referrer: PublicKey;
    createTime: Decimal;
    version: Decimal;

    constructor(decoded: any) {
        Object.assign(this, decoded);
        this.amount = bnToDecimal(decoded['amount']);
        this.lowerPrice = bnToDecimal(decoded['lowerPrice']);
        this.upperPrice = bnToDecimal(decoded['upperPrice']);
        this.gridNumber = bnToDecimal(decoded['gridNumber']);
        this.leverage = bnToDecimal(decoded['leverage']);
        this.stopTopRatio = bnToDecimal(decoded['stopTopRatio']);
        this.stopBottomRatio = bnToDecimal(decoded['stopBottomRatio']);
        this.lastAdjustReserveTs = bnToDecimal(decoded['lastAdjustReserveTs']);
        this.startPrice = bnToDecimal(decoded['startPrice']);
        this.version = bnToDecimal(decoded['version']);
        this.createTime = bnToDecimal(decoded['createTime']);
        this.depositedAssetsQuantity = decoded['depositedAssetsQuantity'].map((i) => bnToDecimal(i));
        delete this['padding'];
        delete this['padding2'];
    }
}

export class BotAccountLayout extends Structure {
    constructor(property) {
        super(
            [
                seq(u8(), 32, 'seed'),
                publicKeyLayout('owner'),
                u8('status'),
                u128('amount'),
                u64('lowerPrice'),
                u64('upperPrice'),
                u16('gridNumber'),
                publicKeyLayout('market'),
                u16('leverage'),
                seq(u64(), 17, 'depositedAssetsQuantity'),
                seq(u8(), 72, 'padding'),
                u8('protocol'),
                u8('type'),
                u8('stopTopRatio'),
                u8('stopBottomRatio'),
                bool('trigger'),
                u64('lastAdjustReserveTs'),
                bool('isPool'),
                u64('startPrice'),
                publicKeyLayout('referrer'),
                u64('createTime'),
                u8('version'),
                seq(u8(), 100, 'padding2'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new BotAccount(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

export function botAccountLayout(property = '') {
    return new BotAccountLayout(property);
}

export const CellConfigAccountLayout = struct([
    publicKeyLayout('admin'),
    publicKeyLayout('delegate'),
    u64('createBotLine'),
    u64('stopBotLine'),
    u64('reserveFreq'),
    u8('reserveRatio'),
    u8('performanceFeeRatio'),
    u8('botOwnerMostPerformanceFeeRatio'),
    u8('performanceFeeDiscount'),
    u8('referrerPerformanceFeeRatio'),
]);

export const CellCacheAccountLayout = struct([
    seq(u8(), 32, 'botSeed'),
    publicKeyLayout('investorKey'),
    u64('investCost'),
    seq(u8(), 100, 'padding'),
]);

export interface CellConfigAccount {
    admin: PublicKey;
    delegate: PublicKey;
    createBotLine: number;
    stopBotLine: number;
    reserveFreq: number;
    reserveRatio: number;
    performanceFeeRatio: number;
    botOwnerMostPerformanceFeeRatio: number;
    performanceFeeDiscount: number;
    referrerPerformanceFeeRatio: number;
}

export interface CellCacheAccount {
    botSeed: Uint8Array;
    investorKey: PublicKey;
    investCost: Decimal;
}

'''
'''--- src/layout/index.ts ---
export * from './bot.layout';
export * from './mango.layout';
export * from './zeta.layout';

'''
'''--- src/layout/mango.layout.ts ---
import { greedy, seq, Structure, u16, u32, u8, struct } from 'buffer-layout';
import { publicKeyLayout, u64 } from '@blockworks-foundation/mango-client';
import BN from 'bn.js';
import { PublicKey } from '@solana/web3.js';

export class MangoReimbursementGroup {
    anchorIndex: BN;
    groupNum: BN;
    table: PublicKey;
    claimTransferDestination: PublicKey;
    authority: PublicKey;
    vaults: PublicKey[];
    claimMints: PublicKey[];
    mints: PublicKey[];
    reimbursementStarted: BN;
    bump: BN;
    testing: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class MangoReimbursementGroupLayout extends Structure {
    constructor(property) {
        super(
            [
                u64('anchorIndex'),
                u32('groupNum'),
                publicKeyLayout('table'),
                publicKeyLayout('claimTransferDestination'),
                publicKeyLayout('authority'),
                seq(publicKeyLayout(), 16, 'vaults'),
                seq(publicKeyLayout(), 16, 'claimMints'),
                seq(publicKeyLayout(), 16, 'mints'),
                u8('reimbursementStarted'),
                u8('bump'),
                u8('testing'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new MangoReimbursementGroup(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

export function mangoReimbursementGroupLayout(property = '') {
    return new MangoReimbursementGroupLayout(property);
}

export class MangoReimbursementAccount {
    anchorIndex: BN;
    reimbursed: BN;
    claimTransferred: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class MangoReimbursementAccountLayout extends Structure {
    constructor(property) {
        super([u64('anchorIndex'), u16('reimbursed'), u16('claimTransferred')], property);
    }

    decode(b, offset) {
        return new MangoReimbursementAccount(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

export function mangoReimbursementAccountLayout(property = '') {
    return new MangoReimbursementAccountLayout(property);
}

export const MangoReimbursementTableRowLayout = struct([publicKeyLayout('owner'), seq(u64(), 16, 'balances')]);

export const MangoReimbursementTableLayout = struct([
    seq(MangoReimbursementTableRowLayout, greedy(MangoReimbursementTableRowLayout.span), 'rows'),
]);

'''
'''--- src/layout/zeta.layout.ts ---
import BN from 'bn.js';
import { seq, Structure, u32, u8 } from 'buffer-layout';
import { bool, i64, publicKeyLayout, u64 } from '@blockworks-foundation/mango-client';
import { PublicKey } from '@solana/web3.js';

class ZetaAnchorDecimal {
    flags: BN;
    hi: BN;
    lo: BN;
    mid: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaAnchorDecimalLayout extends Structure {
    constructor(property) {
        super([u32('flags'), u32('hi'), u32('lo'), u32('mid')], property);
    }

    decode(b, offset) {
        return new ZetaAnchorDecimal(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaAnchorDecimalLayout(property = '') {
    return new ZetaAnchorDecimalLayout(property);
}

class ZetaStrike {
    isSet: boolean;
    value: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaStrikeLayout extends Structure {
    constructor(property) {
        super([bool('isSet'), u64('value')], property);
    }

    decode(b, offset) {
        return new ZetaStrike(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaStrikeLayout(property = '') {
    return new ZetaStrikeLayout(property);
}

class ZetaProduct {
    market: PublicKey;
    strike: ZetaStrike;
    dirty: boolean;
    // uninitialized, call, put, future, perp
    kind: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaProductLayout extends Structure {
    constructor(property) {
        super([publicKeyLayout('market'), zetaStrikeLayout('strike'), bool('dirty'), u8('kind')], property);
    }

    decode(b, offset) {
        return new ZetaProduct(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaProductLayout(property = '') {
    return new ZetaProductLayout(property);
}

class ZetaHaltState {
    halted: boolean;
    spotPrice: BN;
    timestamp: BN;
    markPricesSet: boolean[];
    markPricesSetPadding: boolean[];
    marketNodesCleaned: boolean[];
    marketNodesCleanedPadding: boolean[];
    marketCleaned: boolean[];
    marketCleanedPadding: boolean[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaHaltStateLayout extends Structure {
    constructor(property) {
        super(
            [
                bool('halted'),
                u64('spotPrice'),
                u64('timestamp'),
                seq(bool(), 2, 'markPricesSet'),
                seq(bool(), 4, 'markPricesSetPadding'),
                seq(bool(), 2, 'marketNodesCleaned'),
                seq(bool(), 4, 'marketNodesCleanedPadding'),
                seq(bool(), 46, 'marketCleaned'),
                seq(bool(), 92, 'marketCleanedPadding'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new ZetaHaltState(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaHaltStateLayout(property = '') {
    return new ZetaHaltStateLayout(property);
}

class ZetaPricingParameters {
    optionTradeNormalizer: BN;
    futureTradeNormalizer: BN;
    maxVolatilityRetreat: BN;
    maxInterestRetreat: BN;
    maxDelta: BN;
    minDelta: BN;
    minVolatility: BN;
    maxVolatility: BN;
    minInterestRate: BN;
    maxInterestRate: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaPricingParametersLayout extends Structure {
    constructor(property) {
        super(
            [
                zetaAnchorDecimalLayout('optionTradeNormalizer'),
                zetaAnchorDecimalLayout('futureTradeNormalizer'),
                zetaAnchorDecimalLayout('maxVolatilityRetreat'),
                zetaAnchorDecimalLayout('maxInterestRetreat'),
                u64('maxDelta'),
                u64('minDelta'),
                u64('minVolatility'),
                u64('maxVolatility'),
                i64('minInterestRate'),
                i64('maxInterestRate'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new ZetaPricingParameters(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaPricingParametersLayout(property = '') {
    return new ZetaPricingParametersLayout(property);
}

class ZetaMarginParameters {
    futureMarginInitial: BN;
    futureMarginMaintenance: BN;
    optionMarkPercentageLongInitial: BN;
    optionSpotPercentageLongInitial: BN;
    optionSpotPercentageShortInitial: BN;
    optionDynamicPercentageShortInitial: BN;
    optionMarkPercentageLongMaintenance: BN;
    optionSpotPercentageLongMaintenance: BN;
    optionSpotPercentageShortMaintenance: BN;
    optionDynamicPercentageShortMaintenance: BN;
    optionShortPutCapPercentage: BN;
    padding: BN[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaMarginParametersLayout extends Structure {
    constructor(property) {
        super(
            [
                u64('futureMarginInitial'),
                u64('futureMarginMaintenance'),
                u64('optionMarkPercentageLongInitial'),
                u64('optionSpotPercentageLongInitial'),
                u64('optionSpotPercentageShortInitial'),
                u64('optionDynamicPercentageShortInitial'),
                u64('optionMarkPercentageLongMaintenance'),
                u64('optionSpotPercentageLongMaintenance'),
                u64('optionSpotPercentageShortMaintenance'),
                u64('optionDynamicPercentageShortMaintenance'),
                u64('optionShortPutCapPercentage'),
                seq(u8(), 32, 'padding'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new ZetaMarginParameters(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaMarginParametersLayout(property = '') {
    return new ZetaMarginParametersLayout(property);
}

class ZetaExpirySeries {
    activeTs: BN;
    expiryTs: BN;
    dirty: boolean;
    padding: BN[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaExpirySeriesLayout extends Structure {
    constructor(property) {
        super([u64('activeTs'), u64('expiryTs'), bool('dirty'), seq(u8(), 15, 'padding')], property);
    }

    decode(b, offset) {
        return new ZetaExpirySeries(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaExpirySeriesLayout(property = '') {
    return new ZetaExpirySeriesLayout(property);
}

class ZetaPerpParameters {
    minFundingRatePercent: BN;
    maxFundingRatePercent: BN;
    impactCashDelta: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaPerpParametersLayout extends Structure {
    constructor(property) {
        super([i64('minFundingRatePercent'), i64('maxFundingRatePercent'), u64('impactCashDelta')], property);
    }

    decode(b, offset) {
        return new ZetaPerpParameters(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaPerpParametersLayout(property = '') {
    return new ZetaPerpParametersLayout(property);
}

class ZetaPosition {
    size: BN;
    costOfTrades: BN;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaPositionLayout extends Structure {
    constructor(property) {
        super([i64('size'), u64('costOfTrades')], property);
    }

    decode(b, offset) {
        return new ZetaPosition(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaPositionLayout(property = '') {
    return new ZetaPositionLayout(property);
}

class ZetaOrderState {
    closingOrders: BN;
    openingOrders: BN[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaOrderStateLayout extends Structure {
    constructor(property) {
        super([u64('closingOrders'), seq(u64(), 2, 'openingOrders')], property);
    }

    decode(b, offset) {
        return new ZetaOrderState(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaOrderStateLayout(property = '') {
    return new ZetaOrderStateLayout(property);
}

class ZetaProductLedger {
    position: ZetaPosition;
    orderState: ZetaOrderState;

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaProductLedgerLayout extends Structure {
    constructor(property) {
        super([zetaPositionLayout('position'), zetaOrderStateLayout('orderState')], property);
    }

    decode(b, offset) {
        return new ZetaProductLedger(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

function zetaProductLedgerLayout(property = '') {
    return new ZetaProductLedgerLayout(property);
}

export class ZetaGroupAccount {
    anchorIndex: BN;
    nonce: BN;
    vaultNonce: BN;
    insuranceVaultNonce: BN;
    frontExpiryIndex: BN;
    haltState: ZetaHaltState;
    underlyingMint: PublicKey;
    oracle: PublicKey;
    greeks: PublicKey;
    pricingParameters: ZetaPricingParameters;
    marginParameters: ZetaMarginParameters;
    products: ZetaProduct[];
    productsPadding: ZetaProduct[];
    perp: ZetaProduct;
    expirySeries: ZetaExpirySeries[];
    expirySeriesPadding: ZetaExpirySeries[];
    totalInsuranceVaultDeposits: BN;
    asset: BN;
    expiryIntervalSeconds: BN;
    newExpiryThresholdSeconds: BN;
    perpParameters: ZetaPerpParameters;
    perpSyncQueue: PublicKey;
    padding: BN[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaGroupAccountLayout extends Structure {
    constructor(property) {
        super(
            [
                u64('anchorIndex'),
                u8('nonce'),
                u8('vaultNonce'),
                u8('insuranceVaultNonce'),
                u8('frontExpiryIndex'),
                zetaHaltStateLayout('haltState'),
                publicKeyLayout('underlyingMint'),
                publicKeyLayout('oracle'),
                publicKeyLayout('greeks'),
                zetaPricingParametersLayout('pricingParameters'),
                zetaMarginParametersLayout('marginParameters'),
                seq(zetaProductLayout(), 46, 'products'),
                seq(zetaProductLayout(), 91, 'productsPadding'),
                zetaProductLayout('perp'),
                seq(zetaExpirySeriesLayout(), 2, 'expirySeries'),
                seq(zetaExpirySeriesLayout(), 4, 'expirySeriesPadding'),
                u64('totalInsuranceVaultDeposits'),
                // SOL, BTC, ETH, undefined
                u8('asset'),
                u32('expiryIntervalSeconds'),
                u32('newExpiryThresholdSeconds'),
                zetaPerpParametersLayout('perpParameters'),
                publicKeyLayout('perpSyncQueue'),
                seq(u8(), 998, 'padding'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new ZetaGroupAccount(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

export function zetaGroupAccountLayout(property = '') {
    return new ZetaGroupAccountLayout(property);
}

export class ZetaMarginAccount {
    anchorIndex: BN;
    authority: PublicKey;
    nonce: BN;
    balance: BN;
    forceCancelFlag: boolean;
    openOrdersNonce: BN[];
    seriesExpiry: BN[];
    seriesExpiryPadding: BN[];
    productLedgers: ZetaProductLedger[];
    productLedgersPadding: ZetaProductLedger[];
    perpProductLedger: ZetaProductLedger;
    rebalanceAmount: BN;
    asset: BN;
    accountType: BN;
    lastFundingDelta: ZetaAnchorDecimal;
    padding: BN[];

    constructor(decoded: any) {
        Object.assign(this, decoded);
    }
}

class ZetaMarginAccountLayout extends Structure {
    constructor(property) {
        super(
            [
                u64('anchorIndex'),
                publicKeyLayout('authority'),
                u8('nonce'),
                u64('balance'),
                bool('forceCancelFlag'),
                seq(u8(), 138, 'openOrdersNonce'),
                seq(u64(), 5, 'seriesExpiry'),
                u64('seriesExpiryPadding'),
                seq(zetaProductLedgerLayout(), 46, 'productLedgers'),
                seq(zetaProductLedgerLayout(), 91, 'productLedgersPadding'),
                zetaProductLedgerLayout('perpProductLedger'),
                i64('rebalanceAmount'),
                // SOL, BTC, ETH, undefined
                u8('asset'),
                // normal, marketMaker
                u8('accountType'),
                zetaAnchorDecimalLayout('lastFundingDelta'),
                seq(u8(), 370, 'padding'),
            ],
            property,
        );
    }

    decode(b, offset) {
        return new ZetaMarginAccount(super.decode(b, offset));
    }

    encode(src, b, offset) {
        return super.encode(src.toBuffer(), b, offset);
    }
}

export function zetaMarginAccountLayout(property = '') {
    return new ZetaMarginAccountLayout(property);
}

'''
'''--- src/type/bot.type.ts ---
import { Connection, PublicKey } from '@solana/web3.js';
import Decimal from 'decimal.js';
import { NearNetworkId } from './constant.type';

export enum BotStatus {
    Uninitialized = 0,
    Ready = 1,
    Running = 2,
    Stopped = 3,
    Abandoned = 4,
    StoppedByDelegate = 5,
    WithdrawOnly = 6,
}

export enum BotType {
    Neutral = 0,
    Long = 1,
    Short = 2,
    EnhancedNeutral = 3,
}

export enum Protocol {
    MangoPerp = 0,
    MangoSpot = 1,
    ZetaFuture = 2,
    Tonic = 3,
    SpinSpot = 4,
    SpinPerp = 5,
    Ref = 6,
    ZetaPerp = 7,
    Serum = 8,
}

export enum OrderSide {
    Bid = 0,
    Ask = 1,
}

export enum ZetaOrderSide {
    Bid = 1,
    Ask = 2,
}

export enum OrderType {
    Limit = 0,
    PostOnly = 1,
    Market = 2,
    IOC = 3,
}

export enum ZetaOrderType {
    Limit = 0,
    PostOnly = 1,
    FillOrKill = 2,
}

export enum SerumOrderType {
    Limit = 0,
    IOC = 1,
    PostOnly = 2,
}

export interface OpenOrder {
    price: Decimal;
    size: Decimal;
    side: OrderSide;
    orderId: string;
    clientId: string | null;
}

export interface BotInfo {
    value: Decimal;
    position: Decimal;
}

export interface SerumOpenOrdersAccountInfo {
    baseTokenFree: Decimal;
    baseTokenTotal: Decimal;
    quoteTokenFree: Decimal;
    quoteTokenTotal: Decimal;
}

export interface CreateBotParams {
    botOwner: PublicKey;
    depositBaseBalance: Decimal;
    depositQuoteBalance: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNum: Decimal;
    leverage: Decimal;
    marketKey: PublicKey;
    protocol: Protocol;
    botType: BotType;
    startPrice: Decimal;
    programId: PublicKey;
    stopTopRatio: Decimal;
    stopBottomRatio: Decimal;
    trigger: boolean;
}

export interface StartBotParams {
    botSeed: Uint8Array;
    payer: PublicKey;
    programId: PublicKey;
}

export interface StopBotParams {
    protocol: Protocol;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface SetReferrerParams {
    referrer: PublicKey;
    botSeed: Uint8Array;
    userKey: PublicKey;
    programId: PublicKey;
}

export interface GetOpenOrdersParams {
    protocol: Protocol;
    connection: Connection;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    programId: PublicKey;
}

export interface PlaceOrderParams {
    protocol: Protocol;
    price: Decimal;
    quantity: Decimal;
    side: OrderSide;
    orderType: OrderType;
    clientId: string;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface CancelOrderParams {
    protocol: Protocol;
    botSeed: Uint8Array;
    side: OrderSide;
    orderId: string;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface GetBotInfoParams {
    protocol: Protocol;
    connection: Connection;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    programId: PublicKey;
}

export interface CloseBotParams {
    protocol: Protocol;
    connection: Connection;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    owner: PublicKey;
    referrer: PublicKey;
    cellAdmin: PublicKey;
    programId: PublicKey;
}

export interface LoadNearBotParams {
    botIndex: number;
    contractId: string;
}

export interface NearBotAccount {
    contractId: string;
    owner: string;
    amount: Decimal;
    market: string;
    protocol: Protocol;
    type: BotType;
    status: BotStatus;
    startPrice: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
    leverage: Decimal;
    referer: string;
    perpFeeDiscount: Decimal;
    balances: { [key: string]: Decimal };
}

export interface NearBotInfo {
    contractId: string;
    owner: string;
    isClosed: boolean;
}

export interface CreateNearBotParams {
    protocol: Protocol;
    baseTokenBalance: Decimal;
    quoteTokenBalance: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
    leverage: Decimal;
    market: string;
    botType: BotType;
    startPrice: Decimal;
    referer: string;
    contractId: string;
    networkId: NearNetworkId;
}

export interface PlaceNearOrderParams {
    protocol: Protocol;
    market: string;
    price: Decimal;
    size: Decimal;
    side: OrderSide;
    orderType: OrderType;
    clientId: string;
    botIndex: number;
    contractId: string;
}

export interface GetNearBotInfoParams {
    protocol: Protocol;
    market: string;
    botIndex: number;
    contractId: string;
    networkId: NearNetworkId;
}

export interface CancelNearOrderParams {
    protocol: Protocol;
    orderId: string;
    market: string;
    botIndex: number;
    contractId: string;
    // REF
    amount?: Decimal;
    // REF
    side?: OrderSide;
}

export interface GetNearOpenOrdersParams {
    protocol: Protocol;
    market: string;
    botIndex: number;
    contractId: string;
    networkId: NearNetworkId;
}

export interface CancelAllNearOrdersParams {
    protocol: Protocol;
    market: string;
    botIndex: number;
    contractId: string;
}

export interface CloseNearBotParms {
    protocol: Protocol;
    market: string;
    botIndex: number;
    userAccountId: string;
    contractId: string;
    networkId: NearNetworkId;
}

export interface NearAccountState {
    amount: string;
    block_hash: string;
    block_height: number;
    code_hash: string;
    locked: string;
    storage_paid_at: number;
    storage_usage: number;
}

export interface NearSetDelegateParams {
    delegateAccountId: string;
    botIndex: number;
    contractId: string;
}

export interface NearSetCellConfigParams {
    delegateAccountId: string;
    createBotLine: Decimal;
    stopBotLine: Decimal;
    perpFeeRatio: Decimal;
    botOwnerMostPerpFeeRatio: Decimal;
    contractId: string;
}

export interface CloseSolanaBotMarketParams {
    protocol: Protocol;
    connection: Connection;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface CloseNearMarketParams {
    protocol: Protocol;
    market: string;
    botIndex: number;
    contractId: string;
    networkId: NearNetworkId;
}

export interface MangoReimbursementRow {
    index: number;
    owner: PublicKey;
    balances: Decimal[];
}

'''
'''--- src/type/common.type.ts ---
export interface ZetaExpirySeries {
    activeTs: number;
    expiryTs: number;
}

'''
'''--- src/type/constant.type.ts ---
import { PublicKey } from '@solana/web3.js';

export interface SolanaTokenConfig {
    name: string;
    mintKey: PublicKey;
    decimals: number;
    tokenIndex: number;
    pythPriceKey: PublicKey;
}

export interface ZetaAssetConfig {
    symbol: string;
    groupAccount: PublicKey;
    oracleAccount: PublicKey;
    vaultAccount: PublicKey;
    socializedLossAccount: PublicKey;
    greeksAccount: PublicKey;
    perpSyncQueue: PublicKey;
}

export interface ZetaFutureMarketConfig {
    name: string;
    address: PublicKey;
    leverage: number;
    baseSymbol: string;
    quoteSymbol: string;
    marketIndex: number;
    expiryIndex: number;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
    greekNodeKey: PublicKey;
    zetaBaseVault: PublicKey;
    zetaQuoteVault: PublicKey;
    // DEX address
    bids: PublicKey;
    asks: PublicKey;
    requestQueue: PublicKey;
    eventQueue: PublicKey;
    baseVault: PublicKey;
    quoteVault: PublicKey;
    baseMint: PublicKey;
    quoteMint: PublicKey;
    vaultOwner: PublicKey;
}

export interface ZetaPerpMarketConfig {
    name: string;
    address: PublicKey;
    leverage: number;
    baseSymbol: string;
    quoteSymbol: string;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
    zetaBaseVault: PublicKey;
    zetaQuoteVault: PublicKey;
    // DEX address
    bids: PublicKey;
    asks: PublicKey;
    requestQueue: PublicKey;
    eventQueue: PublicKey;
    baseVault: PublicKey;
    quoteVault: PublicKey;
    baseMint: PublicKey;
    quoteMint: PublicKey;
    vaultOwner: PublicKey;
}

export interface TonicMarketConfig {
    name: string;
    marketId: string;
    baseSymbol: string;
    quoteSymbol: string;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
}

export interface NearTokenConfig {
    symbol: string;
    accountId: string;
    decimals: number;
}

export enum NearNetworkId {
    mainnet = 'mainnet',
    testnet = 'testnet',
}

export interface NearEnvConfig {
    networkId: NearNetworkId;
    nodeUrl: string;
    walletUrl: string;
    helperUrl: string;
}

export interface RefPoolConfig {
    name: string;
    poolId: string;
    tokenXSymbol: string;
    tokenYSymbol: string;
    pointDelta: number;
    fee: number;
}

export interface SerumMarketConfig {
    name: string;
    address: PublicKey;
    baseSymbol: string;
    quoteSymbol: string;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
    leverage: number;
    baseLotSize: number;
    quoteLotSize: number;
    bids: PublicKey;
    asks: PublicKey;
    requestQueue: PublicKey;
    eventQueue: PublicKey;
    baseVault: PublicKey;
    quoteVault: PublicKey;
    vaultSigner: PublicKey;
}

export interface MangoSpotMarketConfig {
    name: string;
    publicKey: PublicKey;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
    leverage: number;
    marketIndex: number;
    baseSymbol: string;
    baseDecimals: number;
    quoteDecimals: number;
    baseLotSize: number;
    quoteLotSize: number;
    bidsKey: PublicKey;
    asksKey: PublicKey;
    eventQueueKey: PublicKey;
    requestQueueKey: PublicKey;
    baseVaultKey: PublicKey;
    quoteVaultKey: PublicKey;
    vaultSignerKey: PublicKey;
}

export interface MangoPerpMarketConfig {
    name: string;
    publicKey: PublicKey;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
    leverage: number;
    marketIndex: number;
    baseSymbol: string;
    baseDecimals: number;
    quoteDecimals: number;
    bidsKey: PublicKey;
    asksKey: PublicKey;
    eventQueueKey: PublicKey;
    mngoVault: PublicKey;
}

export interface SolanaEnvConfig {
    programId: PublicKey;
    adminAccount: PublicKey;
}

export enum SolanaEnvName {
    DEV = 'DEV',
    ZETA = 'ZETA',
    POOL = 'POOL',
    PROD = 'PROD',
    PROD_V2 = 'PROD_V2',
}

export interface SpinSpotMarketConfig {
    name: string;
    marketId: string;
    baseSymbol: string;
    quoteSymbol: string;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
}

export interface SpinPerpMarketConfig {
    name: string;
    marketId: string;
    leverage: 10;
    baseSymbol: string;
    quoteSymbol: string;
    orderPriceDecimals: number;
    orderQuantityDecimals: number;
}

'''
'''--- src/type/index.ts ---
export * from './bot.type';
export * from './pool.type';
export * from './instruction.type';
export * from './transaction.type';
export * from './constant.type';
export * from './common.type';
export * from './strategy.type';

'''
'''--- src/type/instruction.type.ts ---
import { PublicKey } from '@solana/web3.js';
import { Numberu128 } from '../util';
import { SerumOrderType, ZetaOrderSide, ZetaOrderType } from '../type';
import { BotType, OrderSide, Protocol } from './bot.type';
import Decimal from 'decimal.js';

export enum InstructionIndex {
    CreateBot = 0,
    RedeemAllAssetsFromBot = 1,
    StartBot = 2,
    StopBot = 3,
    DepositToMango = 5,
    WithdrawFromMango = 6,
    PlaceMangoPerpOrder = 7,
    CancelMangoPerpOrder = 8,
    CancelAllMangoPerpOrders = 9,
    CloseMangoPerpMarket = 10,
    RedeemMNGOReward = 11,
    CreateCellConfigAccount = 12,
    SetCellFee = 13,
    SetCellConfigDelegate = 14,
    UpdateBotInfo = 15,
    InitZetaMarginAccount = 16,
    DepositToZeta = 17,
    WithdrawFromZeta = 18,
    InitZetaOpenOrders = 19,
    PlaceZetaOrder = 20,
    CancelZetaOrder = 21,
    CreateMangoAccount = 22,
    Deposit = 26,
    Withdraw = 27,
    SetCellConfigReserveInfo = 28,
    SetBotGridInfo = 29,
    CreateMangoSpotOpenOrders = 30,
    PlaceMangoSpotOrder = 31,
    MangoSettleFunds = 32,
    CancelMangoSpotOrder = 33,
    CancelAllMangoSpotOrders = 34,
    RemoveMangoSpotAsset = 35,
    CloseMangoSpotOpenOrders = 36,
    ModifyMangoPerpOrder = 37,
    ModifyMangoSpotOrder = 38,
    CloseZetaOpenOrders = 39,
    SetPoolWithdrawOnly = 40,
    ResolveMangoDust = 41,
    CloseMangoAccount = 42,
    CellConfigRealloc = 46,
    AdjustReserveRatio = 47,
    SetCellConfig = 48,
    UpgradeBotInfo = 49,
    UpgradeBotInfo2 = 50,
    SetBotReferrerKey = 51,
    MangoReimbursement = 52,
    CreateReimbursementAccount = 53,
    ZetaPoolDeposit = 54,
    ZetaPoolWithdraw = 55,
    ZetaPoolAdjustReserve = 56,
    PlaceZetaPerpOrder = 57,
    SerumPlaceOrder = 100,
    SerumSettleFunds = 101,
    SerumCancelOrder = 102,
    SerumInitOpenOrders = 103,
    SerumCloseOpenOrders = 104,
    SerumPoolDeposit = 105,
    SerumPoolWithdraw = 106,
    SerumPoolAdjustReserve = 107,
}

export interface CreateBotIxParams {
    botSeed: Uint8Array;
    depositBaseBalance: Decimal;
    depositQuoteBalance: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNum: Decimal;
    marketKey: PublicKey;
    leverage: Decimal;
    botKey: PublicKey;
    botMintKey: PublicKey;
    userBotTokenKey: PublicKey;
    userKey: PublicKey;
    botType: BotType;
    protocol: Protocol;
    stopTopRatio: Decimal;
    stopBottomRatio: Decimal;
    trigger: boolean;
    isPool: boolean;
    startPrice: Decimal;
    isDualDeposit: boolean;
    cellCacheAccount: PublicKey;
    botAssetKeys: PublicKey[];
    userAssetKeys: PublicKey[];
    assetPriceKeys: PublicKey[];
    programId: PublicKey;
}

export interface RedeemAllAssetsFromBotIxParams {
    botSeed: Uint8Array;
    botKey: PublicKey;
    botMintKey: PublicKey;
    userBotTokenKey: PublicKey;
    userKey: PublicKey;
    referrerKey: PublicKey;
    programId: PublicKey;
    cellConfigKey: PublicKey;
    botAssetKeys: PublicKey[];
    userAssetKeys: PublicKey[];
    cellAssetKeys: PublicKey[];
    assetPriceKeys: PublicKey[];
    referrerAssetKeys: PublicKey[];
}

export interface StartBotIxParams {
    botSeed: Uint8Array;
    botKey: PublicKey;
    userKey: PublicKey;
    programId: PublicKey;
}

export interface StopBotIxParams {
    botSeed: Uint8Array;
    botKey: PublicKey;
    userKey: PublicKey;
    pythPriceAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface DepositToMangoIxParams {
    botSeed: Uint8Array;
    depositQuantity: number;
    botKey: PublicKey;
    mangoAccountKey: PublicKey;
    rootBankKey: PublicKey;
    nodeBankKey: PublicKey;
    vaultAccount: PublicKey;
    botAssetKey: PublicKey;
    userKey: PublicKey;
    cellConfigKey: PublicKey;
    userOrDelegateKey: PublicKey;
    openOrdersAccounts: PublicKey[];
    usdcPythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface WithdrawFromMangoIxParams {
    botSeed: Uint8Array;
    withdrawQuantity: number | string;
    allowBorrow: number;
    botKey: PublicKey;
    botAssetKey: PublicKey;
    userOrDelegateKey: PublicKey;
    mangoAccountKey: PublicKey;
    rootBankKey: PublicKey;
    nodeBankKey: PublicKey;
    vaultAccount: PublicKey;
    cellConfigKey: PublicKey;
    mangoGroupSignerKey: PublicKey;
    openOrdersKeys: PublicKey[];
    usdcPythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface CancelMangoPerpOrderIxParams {
    botSeed: Uint8Array;
    orderId: Numberu128;
    invalidIdOk: number;
    botKey: PublicKey;
    userOrDelegateKey: PublicKey;
    mangoAccountKey: PublicKey;
    perpMarketKey: PublicKey;
    bidsKey: PublicKey;
    asksKey: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface CancelAllMangoPerpOrdersIxParams {
    botSeed: Uint8Array;
    limit: number;
    botKey: PublicKey;
    userOrDelegateKey: PublicKey;
    mangoAccountKey: PublicKey;
    perpMarketKey: PublicKey;
    bidsKey: PublicKey;
    asksKey: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface RedeemMNGORewardIxParams {
    botSeed: Uint8Array;
    botKey: PublicKey;
    userOrDelegateKey: PublicKey;
    mangoAccountKey: PublicKey;
    perpMarketKey: PublicKey;
    mangoPerpVaultKey: PublicKey;
    rootBankKey: PublicKey;
    nodeBankKey: PublicKey;
    mangoBankVaultKey: PublicKey;
    mangoGroupSignerKey: PublicKey;
    programId: PublicKey;
}

export interface CreateCellConfigAccountIxParams {
    adminAccount: PublicKey;
    payerAccount: PublicKey;
    cellConfigKey: PublicKey;
    programId: PublicKey;
}

export interface SetCellFeeIxParams {
    feePercent: number;
    cellConfigAccount: PublicKey;
    adminOrDelegateAccount: PublicKey;
    programId: PublicKey;
}

export interface SetCellConfigDelegateIxParams {
    cellConfigAccount: PublicKey;
    delegateAccount: PublicKey;
    adminAccount: PublicKey;
    programId: PublicKey;
}

export interface CreateMangoAccountIxParams {
    botSeed: Uint8Array;
    accountNumber: number;
    botKey: PublicKey;
    mangoAccountKey: PublicKey;
    userKey: PublicKey;
    programId: PublicKey;
}

export interface InitZetaMarginAccountIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    zetaAccountOwnerAccount: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    programId: PublicKey;
}

export interface createATAIxParams {
    ataKey: PublicKey;
    ownerKey: PublicKey;
    mintKey: PublicKey;
    payerKey: PublicKey;
}

export interface DepositToZetaIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    botTokenAccount: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    zetaVaultKey: PublicKey;
    zetaGreeksKey: PublicKey;
    zetaSocializedLossKey: PublicKey;
    programId: PublicKey;
}

export interface WithdrawFromZetaIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    botTokenAccount: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    zetaGroupOracleKey: PublicKey;
    zetaVaultKey: PublicKey;
    zetaGreeksKey: PublicKey;
    zetaSocializedLossKey: PublicKey;
    programId: PublicKey;
}

export interface InitZetaOpenOrdersIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    openOrdersAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    marketAccount: PublicKey;
    openOrdersMapAccount: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    programId: PublicKey;
}

export interface PlaceZetaOrderIxParams {
    botSeed: Uint8Array;
    price: Decimal;
    size: Decimal;
    side: ZetaOrderSide;
    orderType: ZetaOrderType;
    clientOrderId: string;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    requestQueueAccount: PublicKey;
    eventQueueAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    orderPayerTokenAccount: PublicKey;
    coinVault: PublicKey;
    pcVault: PublicKey;
    pcWallet: PublicKey;
    coinWallet: PublicKey;
    zetaMarketNode: PublicKey;
    zetaMarketMint: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    zetaGroupOracleKey: PublicKey;
    zetaGreeksKey: PublicKey;
    programId: PublicKey;
}

export interface CancelZetaOrderIxParams {
    botSeed: Uint8Array;
    side: ZetaOrderSide;
    orderId: Numberu128;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    eventQueueAccount: PublicKey;
    cellConfigAccount: PublicKey;
    zetaGroupKey: PublicKey;
    programId: PublicKey;
}

export interface CloseZetaOpenOrdersIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    openOrdersAccount: PublicKey;
    openOrdersMapNonce: number;
    marketAccount: PublicKey;
    openOrdersMapAccount: PublicKey;
    cellConfigAccount: PublicKey;
    userKey: PublicKey;
    zetaGroupKey: PublicKey;
    programId: PublicKey;
}

export interface CreateMangoSpotOpenOrdersIxParams {
    botSeed: Uint8Array;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    openOrdersAccount: PublicKey;
    spotMarketAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface MangoSettleFundsIxParams {
    botSeed: Uint8Array;
    userOrBotDelegateAccount: PublicKey;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    openOrdersAccount: PublicKey;
    spotMarketAccount: PublicKey;
    baseAccount: PublicKey;
    quoteAccount: PublicKey;
    baseRootBankAccount: PublicKey;
    baseNodeBankAccount: PublicKey;
    baseVaultAccount: PublicKey;
    quoteRootBankAccount: PublicKey;
    quoteNodeBankAccount: PublicKey;
    quoteVaultAccount: PublicKey;
    serumSignerAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface CancelMangoSpotOrderIxParams {
    botSeed: Uint8Array;
    side: OrderSide;
    orderId: Numberu128;
    userOrBotDelegateAccount: PublicKey;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    spotMarketAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    eventQueueAccount: PublicKey;
    mangoSignerAccount: PublicKey;
    openOrdersAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface CancelAllMangoSpotOrdersIxParams {
    botSeed: Uint8Array;
    limit: number;
    userOrBotDelegateAccount: PublicKey;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    spotMarketAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    openOrdersAccount: PublicKey;
    eventQueueAccount: PublicKey;
    baseAccount: PublicKey;
    quoteAccount: PublicKey;
    baseRootBankAccount: PublicKey;
    baseNodeBankAccount: PublicKey;
    baseVaultAccount: PublicKey;
    quoteRootBankAccount: PublicKey;
    quoteNodeBankAccount: PublicKey;
    quoteVaultAccount: PublicKey;
    mangoSignerAccount: PublicKey;
    serumSignerAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface RemoveMangoSpotAssetIxParams {
    botSeed: Uint8Array;
    marketIndex: number;
    coinLotSize: number;
    pcLotSize: number;
    userOrDelegateKey: PublicKey;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    spotMarketAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    requestQueueAccount: PublicKey;
    eventQueueAccount: PublicKey;
    baseAccount: PublicKey;
    quoteAccount: PublicKey;
    baseRootBankAccount: PublicKey;
    baseNodeBankAccount: PublicKey;
    baseVaultAccount: PublicKey;
    quoteRootBankAccount: PublicKey;
    quoteNodeBankAccount: PublicKey;
    quoteVaultAccount: PublicKey;
    serumSignerAccount: PublicKey;
    msrmOrSrmVaultAccount: PublicKey;
    openOrdersAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface CloseMangoSpotOpenOrdersIxParams {
    botSeed: Uint8Array;
    mangoAccount: PublicKey;
    botAccount: PublicKey;
    openOrdersAccount: PublicKey;
    spotMarketAccount: PublicKey;
    userKey: PublicKey;
    programId: PublicKey;
}

export interface SettleZetaMarketIxParams {
    marketKey: PublicKey;
    baseVault: PublicKey;
    quoteVault: PublicKey;
    dexBaseVault: PublicKey;
    dexQuoteVault: PublicKey;
    vaultOwner: PublicKey;
    openOrdersAccount: PublicKey;
}

export interface UpdateBotInfoIxParams {
    botSeed: Uint8Array;
    botType: BotType;
    stopTopRatio: number;
    stopBottomRatio: number;
    trigger: number;
    botAccount: PublicKey;
    delegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface DepositIxParams {
    botSeed: Uint8Array;
    depositAmount: number;
    botKey: PublicKey;
    botMintKey: PublicKey;
    investorKey: PublicKey;
    investorAssetKey: PublicKey;
    investorBotTokenKey: PublicKey;
    botAssetKey: PublicKey;
    cellCacheKey: PublicKey;
    mangoAccountKey: PublicKey;
    usdcPythPriceAccount: PublicKey;
    openOrdersAccounts: PublicKey[];
    programId: PublicKey;
}

export interface WithdrawIxParams {
    botSeed: Uint8Array;
    withdrawBotTokenAmount: number;
    botKey: PublicKey;
    botMintKey: PublicKey;
    investorKey: PublicKey;
    investorAssetKey: PublicKey;
    investorBotTokenKey: PublicKey;
    botAssetKey: PublicKey;
    cellCacheKey: PublicKey;
    cellAssetKey: PublicKey;
    mangoAccountKey: PublicKey;
    cellConfigKey: PublicKey;
    usdcPythPriceAccount: PublicKey;
    botOwnerAssetAccount: PublicKey;
    openOrdersAccounts: PublicKey[];
    programId: PublicKey;
}

export interface SetCellConfigReserveInfoIxParams {
    reserveRatio: number;
    reserveFreq: number;
    cellConfigAccount: PublicKey;
    adminOrDelegateAccount: PublicKey;
    programId: PublicKey;
}

export interface SetBotGridInfoIxParams {
    amountToTrade: number;
    upperPrice: number;
    lowerPrice: number;
    gridNum: number;
    botAccount: PublicKey;
    userOrDelegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SetPoolWithdrawOnlyIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    delegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface ResolveMangoDustIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    mangoAccount: PublicKey;
    mangoRootBankAccount: PublicKey;
    mangoNodeBankAccount: PublicKey;
    mangoDustAccount: PublicKey;
    userAccount: PublicKey;
    programId: PublicKey;
}

export interface CloseMangoAccountIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    mangoAccount: PublicKey;
    userAccount: PublicKey;
    programId: PublicKey;
}

export interface AdjustPoolReserveIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    botAssetAccount: PublicKey;
    mangoAccount: PublicKey;
    rootBankAccount: PublicKey;
    nodeBankAccount: PublicKey;
    vaultAccount: PublicKey;
    userOrDelegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    usdcPythPriceAccount: PublicKey;
    openOrdersAccounts: PublicKey[];
    programId: PublicKey;
}

export interface SetCellConfigIxParams {
    delegate: PublicKey;
    createBotLine: number;
    stopBotLine: number;
    reserveFreq: number;
    reserveRatio: number;
    performanceFeeRatio: number;
    botOwnerMostPerformanceFeeRatio: number;
    cellConfigAccount: PublicKey;
    adminAccount: PublicKey;
    performanceFeeDiscount: number;
    referrerPerformanceFeeRatio: number;
    programId: PublicKey;
}

export interface CellConfigReallocIxParams {
    addSize: number;
    cellConfigAccount: PublicKey;
    adminAccount: PublicKey;
    programId: PublicKey;
}

export interface UpgradeBotInfoIxParams {
    botSeed: Uint8Array;
    botKey: PublicKey;
    payerKey: PublicKey;
    programId: PublicKey;
}

export interface UpgradeBotInfo2IxParams {
    botSeed: Uint8Array;
    upperPrice: number;
    lowerPrice: number;
    startPrice: number;
    botKey: PublicKey;
    programId: PublicKey;
}

export interface SetBotReferrerkeyIxParams {
    botSeed: Uint8Array;
    referrerKey: PublicKey;
    botKey: PublicKey;
    userKey: PublicKey;
    programId: PublicKey;
}

export interface MangoReimbursementIxParams {
    botSeed: Uint8Array;
    tokenIndex: number;
    indexIntoTable: number;
    vaultAccount: PublicKey;
    tokenAccount: PublicKey;
    reimbursementAccount: PublicKey;
    mangoAccountOwnerAccount: PublicKey;
    botAccount: PublicKey;
    claimMintTokenAccount: PublicKey;
    claimMintAccount: PublicKey;
    reimbursementTableAccount: PublicKey;
    programId: PublicKey;
}

export interface MangoCreateReimbursementAccountIxParams {
    botSeed: Uint8Array;
    reimbursementAccount: PublicKey;
    mangoAccountOwnerAccount: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface PlaceZetaPerpOrderIxParams {
    botSeed: Uint8Array;
    price: Decimal;
    size: Decimal;
    side: ZetaOrderSide;
    orderType: ZetaOrderType;
    clientOrderId: string;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    zetaGroupKey: PublicKey;
    zetaMarginAccount: PublicKey;
    zetaGreeksKey: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    requestQueueAccount: PublicKey;
    eventQueueAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    orderPayerTokenAccount: PublicKey;
    coinVault: PublicKey;
    pcVault: PublicKey;
    coinWallet: PublicKey;
    pcWallet: PublicKey;
    zetaGroupOracleKey: PublicKey;
    zetaMarketMint: PublicKey;
    perpSyncQueue: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface ZetaPoolDepositIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    botMintAccount: PublicKey;
    investorAccount: PublicKey;
    investorAssetAccount: PublicKey;
    investorBotTokenAccount: PublicKey;
    botAssetAccount: PublicKey;
    cellCacheAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    zetaGreeksAccount: PublicKey;
    zetaGroupAccount: PublicKey;
    pythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface ZetaPoolWithdrawIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    botMintAccount: PublicKey;
    investorAccount: PublicKey;
    investorAssetAccount: PublicKey;
    investorBotTokenAccount: PublicKey;
    botAssetAccount: PublicKey;
    cellCacheAccount: PublicKey;
    cellConfigAccount: PublicKey;
    cellAssetAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    zetaGreeksAccount: PublicKey;
    zetaGroupAccount: PublicKey;
    pythPriceAccount: PublicKey;
    botOwnerAssetAccount: PublicKey;
    programId: PublicKey;
}

export interface ZetaPoolAdjustReserveIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    zetaGroupAccount: PublicKey;
    zetaVaultAccount: PublicKey;
    zetaMarginAccount: PublicKey;
    botAssetTokenAccount: PublicKey;
    zetaGreeksAccount: PublicKey;
    zetaOracleAccount: PublicKey;
    zetaSocializedLossAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    cellConfigAccount: PublicKey;
    pythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumPlaceOrderIxParams {
    botSeed: Uint8Array;
    side: OrderSide;
    orderType: SerumOrderType;
    limitPrice: Decimal;
    amountToTrade: Decimal;
    coinLotSize: number;
    pcLotSize: number;
    clientOrderId: string;
    userOrBotDelegateAccount: PublicKey;
    marketAccount: PublicKey;
    openOrdersAccount: PublicKey;
    requestQueueAccount: PublicKey;
    eventQueueAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    botOrWorkingCapAssetAccount: PublicKey;
    botOrWorkingCapAccount: PublicKey;
    botAccount: PublicKey;
    coinVault: PublicKey;
    pcVault: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumSettleFundsIxParams {
    botSeed: Uint8Array;
    userOrBotDelegateAccount: PublicKey;
    marketAccount: PublicKey;
    openOrdersAccount: PublicKey;
    botOrWorkingCapAccount: PublicKey;
    botAccount: PublicKey;
    coinVault: PublicKey;
    coinWalletAccount: PublicKey;
    pcVault: PublicKey;
    pcWalletAccount: PublicKey;
    vaultSigner: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumCancelOrderIxParams {
    botSeed: Uint8Array;
    side: OrderSide;
    orderId: string;
    userOrBotDelegateAccount: PublicKey;
    marketAccount: PublicKey;
    bidsAccount: PublicKey;
    asksAccount: PublicKey;
    openOrdersAccount: PublicKey;
    botOrWorkingCapAccount: PublicKey;
    botAccount: PublicKey;
    eventQueueAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumInitOpenOrdersIxParams {
    botSeed: Uint8Array;
    userOrBotDelegateAccount: PublicKey;
    marketAccount: PublicKey;
    openOrdersAccount: PublicKey;
    botOrWorkingCapAccount: PublicKey;
    botAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumCloseOpenOrdersIxParams {
    botSeed: Uint8Array;
    userOrBotDelegateAccount: PublicKey;
    openOrdersAccount: PublicKey;
    botOrWorkingCapAccount: PublicKey;
    botAccount: PublicKey;
    userAccount: PublicKey;
    marketAccount: PublicKey;
    cellConfigAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumPoolDepositIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    botMintAccount: PublicKey;
    investorAccount: PublicKey;
    investorAssetAccount: PublicKey;
    investorBotTokenAccount: PublicKey;
    botAssetAccount: PublicKey;
    workingCapAccount: PublicKey;
    workingCapBaseTokenAccount: PublicKey;
    workingCapQuoteTokenAccount: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    cellCacheAccount: PublicKey;
    baseTokenPythPriceAccount: PublicKey;
    quoteTokenPythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumPoolWithdrawIxParams {
    botSeed: Uint8Array;
    amount: Decimal;
    botAccount: PublicKey;
    botMintAccount: PublicKey;
    investorAccount: PublicKey;
    investorAssetAccount: PublicKey;
    investorBotTokenAccount: PublicKey;
    botAssetAccount: PublicKey;
    cellCacheAccount: PublicKey;
    cellConfigAccount: PublicKey;
    cellAssetAccount: PublicKey;
    botOwnerAssetAccount: PublicKey;
    workingCapAccount: PublicKey;
    workingCapBaseTokenAccount: PublicKey;
    workingCapQuoteTokenAccount: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    baseTokenPythPriceAccount: PublicKey;
    quoteTokenPythPriceAccount: PublicKey;
    programId: PublicKey;
}

export interface SerumPoolAdjustReserveIxParams {
    botSeed: Uint8Array;
    botAccount: PublicKey;
    userOrBotDelegateAccount: PublicKey;
    botAssetAccount: PublicKey;
    workingCapAccount: PublicKey;
    workingCapBaseTokenAccount: PublicKey;
    workingCapQuoteTokenAccount: PublicKey;
    openOrdersAccount: PublicKey;
    marketAccount: PublicKey;
    cellConfigAccount: PublicKey;
    baseTokenPythPriceAccount: PublicKey;
    quoteTokenPythPriceAccount: PublicKey;
    programId: PublicKey;
}

'''
'''--- src/type/pool.type.ts ---
import { Connection, PublicKey } from '@solana/web3.js';
import { OrderSide, OrderType, Protocol } from './bot.type';
import Decimal from 'decimal.js';

export interface PoolInfo {
    botValue: Decimal;
    dexValue: Decimal;
    position: Decimal;
}

export interface DepositPoolParams {
    protocol: Protocol;
    connection: Connection;
    amount: Decimal;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    investor: PublicKey;
    programId: PublicKey;
}

export interface RedeemPoolParams {
    protocol: Protocol;
    amount: Decimal;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    investor: PublicKey;
    botOwner: PublicKey;
    cellAdmin: PublicKey;
    programId: PublicKey;
}

export interface AdjustPoolReserveParams {
    protocol: Protocol;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface GetPoolInfoParams {
    protocol: Protocol;
    connection: Connection;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    programId: PublicKey;
}

export interface ModifyPoolOrderParams {
    protocol: Protocol;
    existedOrderId: string;
    existedOrderSide: OrderSide;
    newOrderPrice: Decimal;
    newOrderSize: Decimal;
    newOrderSide: OrderSide;
    newOrderType: OrderType;
    newOrderClientId: string;
    botSeed: Uint8Array;
    marketKey: PublicKey;
    payer: PublicKey;
    programId: PublicKey;
}

export interface SetPoolWithdrawOnlyParams {
    botSeed: Uint8Array;
    payer: PublicKey;
    programId: PublicKey;
}

'''
'''--- src/type/strategy.type.ts ---
import { BotType } from './bot.type';
import Decimal from 'decimal.js';

export interface GridRebalanceParams {
    botType: BotType;
    amount: Decimal;
    leverage: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
    marketPrice: Decimal;
    startPrice: Decimal;
}

export interface GetGridsParams {
    amount: Decimal;
    leverage: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
}

export interface Grid {
    index: number;
    price: Decimal;
    size: Decimal;
}

export interface DualInvestment {
    baseBalance: Decimal;
    quoteBalance: Decimal;
}

export interface GetDualInvestmentParams {
    quoteBalance: Decimal;
    lowerPrice: Decimal;
    upperPrice: Decimal;
    gridNumber: Decimal;
    marketPrice: Decimal;
}

'''
'''--- src/type/transaction.type.ts ---
import { Signer, TransactionInstruction } from '@solana/web3.js';
import { Action } from 'near-api-js/lib/transaction';

export interface TransactionPayload {
    instructions: TransactionInstruction[];
    signers: Signer[];
}

export interface NearTransactionPayload {
    receiverId: string;
    actions: Action[];
}

'''
'''--- src/util/common.util.ts ---
import {
    BotStatus,
    BotType,
    OrderSide,
    OrderType,
    Protocol,
    SerumOrderType,
    ZetaOrderSide,
    ZetaOrderType,
} from '../type';
import Decimal from 'decimal.js';
import { COIN_GECKO_TOKEN_MAP } from '../constant/coingecko.constant';
import { uiToNative } from './number.util';

export function zetaOrderSideTransform(side: OrderSide): ZetaOrderSide {
    return side == OrderSide.Bid ? ZetaOrderSide.Bid : ZetaOrderSide.Ask;
}

export function zetaOrderTypeTransform(orderType: OrderType): ZetaOrderType {
    switch (orderType) {
        case OrderType.Limit:
            return ZetaOrderType.Limit;
        case OrderType.PostOnly:
            return ZetaOrderType.PostOnly;
        default:
            throw `Unsupported zeta order type ${orderType}`;
    }
}

export function serumOrderTypeTransform(orderType: OrderType): SerumOrderType {
    switch (orderType) {
        case OrderType.Limit:
            return SerumOrderType.Limit;
        case OrderType.PostOnly:
            return SerumOrderType.PostOnly;
        case OrderType.IOC:
            return SerumOrderType.IOC;
        default:
            throw `Unsupported zeta order type ${orderType}`;
    }
}

// 6 decimals with last 2 decimals zero, e.g. 35.625413 -> 35625400
export function uiZetaPriceToNative(price: Decimal): Decimal {
    return uiToNative(price, 4).floor().mul(new Decimal(100));
}

export function botProtocolEnumToStr(protocol: Protocol): string {
    switch (protocol) {
        case Protocol.MangoPerp:
            return 'MangoPerp';
        case Protocol.MangoSpot:
            return 'MangoSpot';
        case Protocol.ZetaFuture:
            return 'ZetaFuture';
        case Protocol.ZetaPerp:
            return 'ZetaPerp';
        case Protocol.Tonic:
            return 'Tonic';
        case Protocol.Ref:
            return 'Ref';
        case Protocol.Serum:
            return 'Serum';
        case Protocol.SpinSpot:
            return 'SpinSpot';
        case Protocol.SpinPerp:
            return 'SpinPerp';
        default:
            throw `Invalid bot protocol type enum ${protocol}`;
    }
}

export function botProtocolStrToEnum(protocolType: string): Protocol {
    switch (protocolType) {
        case 'MangoPerp':
            return Protocol.MangoPerp;
        case 'MangoSpot':
            return Protocol.MangoSpot;
        case 'ZetaFuture':
            return Protocol.ZetaFuture;
        case 'Tonic':
            return Protocol.Tonic;
        case 'Ref':
            return Protocol.Ref;
        case 'Serum':
            return Protocol.Serum;
        case 'SpinSpot':
            return Protocol.SpinSpot;
        case 'SpinPerp':
            return Protocol.SpinPerp;
        default:
            throw `Invalid bot protocol type ${protocolType}`;
    }
}

export function botTypeStrToEnum(botType: string): BotType {
    switch (botType) {
        case 'Long':
            return BotType.Long;
        case 'Short':
            return BotType.Short;
        case 'Neutral':
            return BotType.Neutral;
        case 'EnhancedNeutral':
            return BotType.EnhancedNeutral;
        default:
            throw `Invalid bot type ${botType}`;
    }
}

export function botTypeEnumToStr(botType: BotType): string {
    switch (botType) {
        case BotType.Long:
            return 'Long';
        case BotType.Short:
            return 'Short';
        case BotType.Neutral:
            return 'Neutral';
        case BotType.EnhancedNeutral:
            return 'EnhancedNeutral';
        default:
            throw `Invalid bot type ${botType}`;
    }
}

export function botStatusStrToEnum(botStatus: string): BotStatus {
    switch (botStatus) {
        case 'Uninitialized':
            return BotStatus.Uninitialized;
        case 'Ready':
            return BotStatus.Ready;
        case 'Running':
            return BotStatus.Running;
        case 'Stopped':
            return BotStatus.Stopped;
        case 'Abandoned':
            return BotStatus.Abandoned;
        case 'StoppedByDelegate':
            return BotStatus.StoppedByDelegate;
        case 'WithdrawOnly':
            return BotStatus.WithdrawOnly;
        default:
            throw `Invalid bot status ${botStatus}`;
    }
}

export async function getMarketPrice(symbol: string): Promise<Decimal> {
    const coingeckoTokenId = COIN_GECKO_TOKEN_MAP[symbol] ? COIN_GECKO_TOKEN_MAP[symbol] : symbol.toLowerCase();
    const url = `https://api.coingecko.com/api/v3/coins/${coingeckoTokenId}`;
    const usdPrice = await fetch(url)
        .then((res) => res.json())
        .then((resJson) => resJson['market_data']['current_price']['usd'] as number);
    return new Decimal(usdPrice);
}

export function tonicOrderSideTransform(side: OrderSide): string {
    return side == OrderSide.Bid ? 'Buy' : 'Sell';
}

export function tonicOrderTypeTransform(orderType: OrderType): string {
    switch (orderType) {
        case OrderType.Limit:
            return 'Limit';
        case OrderType.PostOnly:
            return 'PostOnly';
        case OrderType.Market:
            return 'Market';
        default:
            throw `Unsupported tonic order type ${orderType}`;
    }
}

'''
'''--- src/util/constant.util.ts ---
import {
    MangoPerpMarketConfig,
    MangoSpotMarketConfig,
    NearEnvConfig,
    NearNetworkId,
    NearTokenConfig,
    RefPoolConfig,
    SerumMarketConfig,
    SolanaTokenConfig,
    SpinPerpMarketConfig,
    SpinSpotMarketConfig,
    TonicMarketConfig,
    ZetaAssetConfig,
    ZetaFutureMarketConfig,
    ZetaPerpMarketConfig,
} from '../type';
import {
    NEAR_ENV,
    NEAR_TOKENS,
    TONIC_MARKETS,
    REF_POOLS,
    SERUM_MARKETS,
    MANGO_SPOT_MARKETS,
    MANGO_PERP_MARKETS,
    SPIN_SPOT_MARKETS,
    SPIN_PERP_MARKETS,
} from '../constant';
import { SOLANA_TOKENS, ZETA_ASSETS_CONFIG, ZETA_FUTURE_MARKETS, ZETA_PERP_MARKETS } from '../constant';
import { PublicKey } from '@solana/web3.js';

export function getNearEnvConfig(networkId: NearNetworkId): NearEnvConfig | undefined {
    return NEAR_ENV.find((i) => i.networkId == networkId);
}

export function getTonicMarketConfig(marketId: string): TonicMarketConfig | undefined {
    return TONIC_MARKETS.find((i) => i.marketId == marketId);
}

export function getNearTokenConfigBySymbol(symbol: string): NearTokenConfig | undefined {
    return NEAR_TOKENS.find((i) => i.symbol == symbol);
}

export function getNearTokenConfigByAccountId(accountId: string): NearTokenConfig | undefined {
    return NEAR_TOKENS.find((i) => i.accountId == accountId);
}

export function getTokenConfigBySymbol(tokenSymbol: string): SolanaTokenConfig | undefined {
    return SOLANA_TOKENS.find((i) => i.name == tokenSymbol);
}

export function getTokenConfig(tokenMint: PublicKey): SolanaTokenConfig | undefined {
    return SOLANA_TOKENS.find((i) => i.mintKey.equals(tokenMint));
}

export function getZetaAssetConfigBySymbol(symbol: string): ZetaAssetConfig | undefined {
    return ZETA_ASSETS_CONFIG.find((i) => i.symbol == symbol);
}

export function getZetaFutureMarketConfig(publicKey: PublicKey): ZetaFutureMarketConfig | undefined {
    return ZETA_FUTURE_MARKETS.find((i) => i.address.equals(publicKey));
}

export function getZetaPerpMarketConfig(marketKey: PublicKey): ZetaPerpMarketConfig | undefined {
    return ZETA_PERP_MARKETS.find((i) => i.address.equals(marketKey));
}

export function getRefPoolConfig(poolId: string): RefPoolConfig | undefined {
    return REF_POOLS.find((i) => i.poolId == poolId);
}

export function getSerumMarketConfig(marketKey: PublicKey): SerumMarketConfig | undefined {
    return SERUM_MARKETS.find((i) => i.address.equals(marketKey));
}

export function getMangoSpotMarketConfig(marketKey: PublicKey): MangoSpotMarketConfig | undefined {
    return MANGO_SPOT_MARKETS.find((i) => i.publicKey.equals(marketKey));
}

export function getMangoPerpMarketConfig(marketKey: PublicKey): MangoPerpMarketConfig | undefined {
    return MANGO_PERP_MARKETS.find((i) => i.publicKey.equals(marketKey));
}

export function getSpinSpotMarketConfig(marketId: string): SpinSpotMarketConfig | undefined {
    return SPIN_SPOT_MARKETS.find((i) => i.marketId == marketId);
}

export function getSpinPerpMarketConfig(marketId: string): SpinPerpMarketConfig | undefined {
    return SPIN_PERP_MARKETS.find((i) => i.marketId == marketId);
}

'''
'''--- src/util/index.ts ---
export * from './common.util';
export * from './constant.util';
export * from './near.util';
export * from './number.util';
export * from './solana.util';

'''
'''--- src/util/near.util.ts ---
import Decimal from 'decimal.js';
import { Action, functionCall, signTransaction } from 'near-api-js/lib/transaction';
import {
    NearAccountState,
    NearEnvConfig,
    NearNetworkId,
    NearTokenConfig,
    NearTransactionPayload,
    RefPoolConfig,
} from '../type';
import { DEFAULT_GAS, REF_CONTRACT_ID, ZERO_BN } from '../constant';
import { nativeToUi, refPointToPrice, uiToNative } from './number.util';
import { getNearEnvConfig, getNearTokenConfigBySymbol, getRefPoolConfig } from './constant.util';
import { FinalExecutionOutcome, JsonRpcProvider } from 'near-api-js/lib/providers';
import { KeyPair, keyStores, Near } from 'near-api-js';
import BN from 'bn.js';
import { baseDecode } from 'borsh';

export function redeemFromTonicAction(tokenSymbol: string, amount: Decimal): Action {
    const tokenConfig = getNearTokenConfigBySymbol(tokenSymbol) as NearTokenConfig;
    if (tokenConfig.symbol == 'NEAR') {
        return functionCall(
            'withdraw_near_from_tonic',
            {
                withdraw_amount: uiToNative(new Decimal(amount), tokenConfig.decimals).toFixed(),
            },
            DEFAULT_GAS.divn(2),
            ZERO_BN,
        );
    } else {
        return functionCall(
            'withdraw_ft_from_tonic',
            {
                token_id: tokenConfig.accountId,
                withdraw_amount: uiToNative(new Decimal(amount), tokenConfig.decimals).toFixed(),
            },
            DEFAULT_GAS.divn(2),
            ZERO_BN,
        );
    }
}

export async function getNearTokenBalance(
    tokenSymbol: string,
    accountId: string,
    networkId = NearNetworkId.mainnet,
): Promise<Decimal> {
    const tokenConfig = getNearTokenConfigBySymbol(tokenSymbol) as NearTokenConfig;
    if (tokenConfig.symbol == 'NEAR') {
        const accountState = await nearViewAccount(accountId, networkId);
        return nativeToUi(new Decimal(accountState.amount), tokenConfig.decimals);
    } else {
        return nearViewFunction('ft_balance_of', { account_id: accountId }, tokenConfig.accountId, networkId).then(
            (res) => nativeToUi(new Decimal(res), tokenConfig.decimals),
        );
    }
}

export async function nearSendTransactionPayload(
    payload: NearTransactionPayload,
    accountId: string,
    privateKeyStr: string,
    networkId: NearNetworkId = NearNetworkId.mainnet,
    addedNonce = new BN(1),
): Promise<FinalExecutionOutcome> {
    const nearEnv = getNearEnvConfig(networkId) as NearEnvConfig;
    const keyPair = KeyPair.fromString(privateKeyStr);
    const keyStore = new keyStores.InMemoryKeyStore();
    await keyStore.setKey(networkId, accountId, keyPair);
    const near = new Near({ ...nearEnv, keyStore });
    const account = await near.account(accountId);

    const accessKeyInfo = await account.findAccessKey(account.accountId, payload.actions);
    const { accessKey } = accessKeyInfo;

    const block = await account.connection.provider.block({ finality: 'final' });
    const blockHash = block.header.hash;
    const nonce = accessKey.nonce.add(addedNonce);

    const [_, signedTx] = await signTransaction(
        payload.receiverId,
        nonce,
        payload.actions,
        baseDecode(blockHash),
        account.connection.signer,
        account.accountId,
        account.connection.networkId,
    );
    const outcome = await account.connection.provider.sendTransaction(signedTx);
    console.log(`Signature: ${outcome.transaction['hash']}`);
    return outcome;
}

export async function nearViewFunction(
    methodName: string,
    args: any,
    accountId: string,
    networkId: NearNetworkId = NearNetworkId.mainnet,
) {
    const nearEnv = getNearEnvConfig(networkId) as NearEnvConfig;
    const provider = new JsonRpcProvider({ url: nearEnv.nodeUrl });
    return provider
        .query({
            request_type: 'call_function',
            finality: 'optimistic',
            account_id: accountId,
            method_name: methodName,
            args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
        })
        .then((res) => JSON.parse(Buffer.from(res['result']).toString()));
}

export async function nearViewAccount(
    accountId: string,
    networkId: NearNetworkId = NearNetworkId.mainnet,
): Promise<NearAccountState> {
    const nearEnv = getNearEnvConfig(networkId) as NearEnvConfig;
    const provider = new JsonRpcProvider({ url: nearEnv.nodeUrl });
    return provider
        .query({
            account_id: accountId,
            finality: 'optimistic',
            request_type: 'view_account',
        })
        .then((res) => res as NearAccountState);
}

/*
 * Token X / Token Y
 * e.g. REF | USDT pool, get REF price quoted by USDT
 */
export async function getRefPoolPrice(poolId: string, networkId = NearNetworkId.testnet) {
    const poolConfig = getRefPoolConfig(poolId) as RefPoolConfig;
    const tokenXConfig = getNearTokenConfigBySymbol(poolConfig.tokenXSymbol) as NearTokenConfig;
    const tokenYConfig = getNearTokenConfigBySymbol(poolConfig.tokenYSymbol) as NearTokenConfig;
    const poolInfo = await nearViewFunction('get_pool', { pool_id: poolId }, REF_CONTRACT_ID, networkId);
    return refPointToPrice(new Decimal(poolInfo['current_point']), tokenYConfig.decimals, tokenXConfig.decimals);
}

'''
'''--- src/util/number.util.ts ---
import BN from 'bn.js';
import assert from 'assert';
import Decimal from 'decimal.js';

export class Numberu8 extends BN {
    toBuffer(): Buffer {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 1) {
            return b;
        }
        if (b.length >= 1) {
            throw new Error('Numberu16 too large');
        }
        const zeroPad = Buffer.alloc(1);
        b.copy(zeroPad);
        return zeroPad;
    }

    static fromBuffer(buffer) {
        if (buffer.length !== 1) {
            throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new BN(
            [...buffer]
                .reverse()
                .map((i) => `00${i.toString(4)}`.slice(-2))
                .join(''),
            16,
        );
    }
}

export class Numberu16 extends BN {
    toBuffer() {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 2) {
            return b;
        }
        if (b.length >= 2) {
            throw new Error('Numberu16 too large');
        }
        const zeroPad = Buffer.alloc(2);
        b.copy(zeroPad);
        return zeroPad;
    }

    /**
     * Construct a Numberu64 from Buffer representation
     */
    static fromBuffer(buffer) {
        if (buffer.length !== 2) {
            throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new BN(
            [...buffer]
                .reverse()
                .map((i) => `00${i.toString(16)}`.slice(-2))
                .join(''),
            16,
        );
    }
}

export class Numberu32 extends BN {
    toBuffer() {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 4) {
            return b;
        }
        if (b.length >= 4) {
            throw new Error('Numberu32 too large');
        }
        const zeroPad = Buffer.alloc(4);
        b.copy(zeroPad);
        return zeroPad;
    }

    /**
     * Construct a Numberu32 from Buffer representation
     */
    static fromBuffer(buffer) {
        if (buffer.length !== 4) {
            throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new BN(
            [...buffer]
                .reverse()
                .map((i) => `00${i.toString(16)}`.slice(-2))
                .join(''),
            16,
        );
    }
}

export class Numberu64 extends BN {
    toBuffer() {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 8) {
            return b;
        }
        if (b.length >= 8) {
            throw new Error('Numberu64 too large');
        }
        const zeroPad = Buffer.alloc(8);
        b.copy(zeroPad);
        return zeroPad;
    }

    /**
     * Construct a Numberu64 from Buffer representation
     */
    static fromBuffer(buffer) {
        if (buffer.length !== 8) {
            throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new BN(
            [...buffer]
                .reverse()
                .map((i) => `00${i.toString(16)}`.slice(-2))
                .join(''),
            16,
        );
    }
}

export class Numberu128 extends BN {
    toBuffer(): Buffer {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 16) {
            return b;
        }
        assert(b.length < 16, 'Numberu128 too large');

        const zeroPad = Buffer.alloc(16, 0);
        b.copy(zeroPad);
        return zeroPad;
    }

    static fromBuffer(buffer: Buffer): Numberu128 {
        assert(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);
        return new Numberu128(
            [...buffer]
                .reverse()
                .map((i) => `00${i.toString(16)}`.slice(-2))
                .join(''),
            16,
        );
    }
}

export function decimalToBN(n: Decimal): BN {
    return new BN(n.toFixed());
}

export function bnToDecimal(n: BN) {
    return new Decimal(n.toString());
}

export function uiToNative(ui: Decimal, decimals: number): Decimal {
    return ui.mul(new Decimal(10).pow(new Decimal(decimals)));
}

export function nativeToUi(native: Decimal, decimals: number): Decimal {
    return native.div(new Decimal(10).pow(new Decimal(decimals)));
}

export function booleanToBN(b: boolean): BN {
    return b ? new BN(1) : new BN(0);
}

// 10 NEAR/REF, tokenA: NEAR, tokenB: REF
export function refPriceToPoint(
    price: Decimal,
    tokenADecimals: number,
    tokenBDecimals: number,
    pointDelta: number,
): Decimal {
    const n = price
        .mul(new Decimal(10).pow(new Decimal(tokenADecimals)))
        .div(new Decimal(10).pow(new Decimal(tokenBDecimals)));
    const base = new Decimal(1.0001);
    const point = Decimal.log(n, base);
    return point.divToInt(new Decimal(pointDelta)).mul(new Decimal(pointDelta));
}

/*
 * eg: X=REF, Y=wNEAR: point: 115120
 * decimalPrice = 1.0001**115120 * 10**18 / 10**24 = = 0.09985000993759437 wNEAR/REF
 */
export function refPointToPrice(point: Decimal, tokenADecimals: number, tokenBDecimals: number): Decimal {
    const base = new Decimal(1.0001);
    return base
        .pow(point)
        .mul(new Decimal(10).pow(new Decimal(tokenBDecimals)))
        .div(new Decimal(10).pow(new Decimal(tokenADecimals)));
}

'''
'''--- src/util/solana.util.ts ---
import {
    Connection,
    Keypair,
    PublicKey,
    sendAndConfirmTransaction,
    Transaction,
    TransactionInstruction,
} from '@solana/web3.js';
import {
    CellCacheAccount,
    CellCacheAccountLayout,
    MangoReimbursementAccount,
    mangoReimbursementAccountLayout,
    MangoReimbursementGroup,
    mangoReimbursementGroupLayout,
    MangoReimbursementTableLayout,
    ZetaGroupAccount,
    zetaGroupAccountLayout,
    ZetaMarginAccount,
    zetaMarginAccountLayout,
} from '../layout';
import Decimal from 'decimal.js';
import {
    MANGO_REIMBURSEMENT_GROUP_KEY,
    MANGO_REIMBURSEMENT_PROGRAM_ID,
    ZERO_DECIMAL,
    ZETA_DEX_PROGRAM_ID,
    ZETA_PROGRAM_ID,
} from '../constant';
import {
    MangoReimbursementRow,
    SerumOpenOrdersAccountInfo,
    SolanaTokenConfig,
    TransactionPayload,
    ZetaAssetConfig,
    ZetaExpirySeries,
} from '../type';
import { _OPEN_ORDERS_LAYOUT_V2 } from '@project-serum/serum/lib/market';
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import crypto from 'crypto';
import { createATAIx, redeemAllAssetsFromBotIx } from '../instruction';
import { bnToDecimal, nativeToUi } from './number.util';
import { getTokenConfigBySymbol, getZetaAssetConfigBySymbol } from './constant.util';

export async function getZetaMarginAccount(
    connection: Connection,
    marginAccountKey: PublicKey,
): Promise<ZetaMarginAccount> {
    const accountInfo = await connection.getAccountInfo(marginAccountKey);
    if (!accountInfo) {
        throw `Get zeta margin account error: ${marginAccountKey.toString()} account not available`;
    }
    return zetaMarginAccountLayout('').decode(accountInfo.data, 0);
}

export async function getATABalance(connection: Connection, ataKey: PublicKey): Promise<Decimal> {
    return connection.getTokenAccountBalance(ataKey).then((tokenAmount) => {
        if (!tokenAmount) {
            return ZERO_DECIMAL;
        }
        return nativeToUi(new Decimal(tokenAmount.value.amount), tokenAmount.value.decimals);
    });
}

export async function getSerumOpenOrdersAccountInfo(
    connection: Connection,
    openOrdersAccountKey: PublicKey,
): Promise<SerumOpenOrdersAccountInfo | null> {
    const accountInfo = await connection.getAccountInfo(openOrdersAccountKey);
    if (!accountInfo) {
        console.log(`Serum open orders account ${openOrdersAccountKey.toString()} not found`);
        return null;
    }
    const openOrdersAccount = _OPEN_ORDERS_LAYOUT_V2.decode(accountInfo.data);
    return {
        baseTokenFree: bnToDecimal(openOrdersAccount['baseTokenFree']),
        baseTokenTotal: bnToDecimal(openOrdersAccount['baseTokenTotal']),
        quoteTokenFree: bnToDecimal(openOrdersAccount['quoteTokenFree']),
        quoteTokenTotal: bnToDecimal(openOrdersAccount['quoteTokenTotal']),
    };
}

export async function getATAKey(ownerKey: PublicKey, mintKey: PublicKey): Promise<PublicKey> {
    return await PublicKey.findProgramAddress(
        [ownerKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintKey.toBuffer()],
        ASSOCIATED_TOKEN_PROGRAM_ID,
    ).then((res) => res[0]);
}

export function getBotKeyBySeed(botSeed: Uint8Array, programId: PublicKey): Promise<PublicKey> {
    return PublicKey.createProgramAddress([botSeed], programId);
}

export function getBotMintKeyBySeed2(botSeed: Uint8Array, programId: PublicKey): Promise<PublicKey> {
    return PublicKey.createProgramAddress([botSeed, new Uint8Array([1])], programId);
}

export async function genValidBotAccount(programId: PublicKey): Promise<[Uint8Array, PublicKey, PublicKey]> {
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const botSeed = crypto.randomBytes(32);
        const botKey = await getBotKeyBySeed(botSeed, programId).catch(() => null);
        const botMintKey = await getBotMintKeyBySeed2(botSeed, programId).catch(() => null);

        if (botKey && botMintKey) {
            return [botSeed, botKey, botMintKey];
        }
    }
}

// check ATA, return payload if ATA not existed
export async function createATA(
    connection: Connection,
    ownerKey: PublicKey,
    tokenMint: PublicKey,
    payerAccount: PublicKey,
): Promise<[PublicKey, TransactionInstruction | null]> {
    const ataKey = await getATAKey(ownerKey, tokenMint);
    return connection.getAccountInfo(ataKey).then((accountInfo) => {
        if (accountInfo) {
            return [ataKey, null];
        }
        return [
            ataKey,
            createATAIx({
                ataKey,
                ownerKey,
                mintKey: tokenMint,
                payerKey: payerAccount,
            }),
        ];
    });
}

export async function getBotZetaMarginAccountKeyBySeed(
    botSeed: Uint8Array,
    zetaGroupKey: PublicKey,
    programId: PublicKey,
): Promise<PublicKey> {
    const botKey = await getBotKeyBySeed(botSeed, programId);
    return PublicKey.findProgramAddress(
        [Buffer.from('margin'), zetaGroupKey.toBuffer(), botKey.toBuffer()],
        ZETA_PROGRAM_ID,
    ).then((res) => res[0]);
}

export async function getBotZetaOpenOrdersAccountKey(botKey: PublicKey, marketKey: PublicKey): Promise<PublicKey> {
    return PublicKey.findProgramAddress(
        [Buffer.from('open-orders', 'utf-8'), ZETA_DEX_PROGRAM_ID.toBuffer(), marketKey.toBuffer(), botKey.toBuffer()],
        ZETA_PROGRAM_ID,
    ).then((res) => res[0]);
}

export async function getZetaOpenOrdersMapKey(openOrdersAccountKey: PublicKey): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress([openOrdersAccountKey.toBuffer()], ZETA_PROGRAM_ID);
}

export async function getCellConfigAccountKey(programId: PublicKey): Promise<PublicKey> {
    return PublicKey.findProgramAddress([Buffer.from('config', 'utf-8')], programId).then((res) => res[0]);
}

export async function getCellCacheKey(botKey: PublicKey, userKey: PublicKey, programId: PublicKey): Promise<PublicKey> {
    return PublicKey.findProgramAddress(
        [botKey.toBuffer(), userKey.toBuffer(), Buffer.from('cell-cache', 'utf-8')],
        programId,
    ).then((res) => res[0]);
}

/*
 * @param mint dex base / quote vault
 * returns zeta base / quote vault
 */
export async function getZetaVault(mint: PublicKey): Promise<PublicKey> {
    return PublicKey.findProgramAddress([Buffer.from('zeta-vault'), mint.toBuffer()], ZETA_PROGRAM_ID).then(
        (res) => res[0],
    );
}

export async function getCellCacheAccount(
    connection: Connection,
    botSeed: Uint8Array,
    userKey: PublicKey,
    programId: PublicKey,
): Promise<CellCacheAccount> {
    const botKey = await getBotKeyBySeed(botSeed, programId);
    const cellCacheKey = await getCellCacheKey(botKey, userKey, programId);

    const accountInfo = await connection.getAccountInfo(cellCacheKey);
    if (!accountInfo) {
        throw `Get cell cache account error: account ${cellCacheKey.toString()} not available`;
    }
    const cellCache = CellCacheAccountLayout.decode(accountInfo.data);
    return {
        ...cellCache,
        investCost: nativeToUi(new Decimal(cellCache.investCost.toString()), 6),
    };
}

export async function sendSolanaPayload(
    connection: Connection,
    payer: Keypair,
    payload: TransactionPayload,
    confirm = true,
    skipPreflight = false,
) {
    const tx = new Transaction({ feePayer: payer.publicKey });
    tx.add(...payload.instructions);
    const signers = payload.signers.length == 0 ? [payer] : [payer, ...payload.signers];

    let signature: string | void;
    if (confirm) {
        signature = await sendAndConfirmTransaction(connection, tx, signers, { skipPreflight }).catch((e) => {
            console.error(e);
            throw e;
        });
    } else {
        signature = await connection.sendTransaction(tx, signers, { skipPreflight }).catch((e) => {
            console.error(e);
            throw e;
        });
    }

    console.log(`Signature: ${signature}`);
    return signature;
}

export async function getZetaGroup(connection: Connection, baseSymbol: string): Promise<ZetaGroupAccount> {
    const assetConfig = getZetaAssetConfigBySymbol(baseSymbol) as ZetaAssetConfig;
    const zetaGroupAccount = await connection.getAccountInfo(assetConfig.groupAccount);
    if (!zetaGroupAccount) {
        throw `Get Zeta group error: account not existed ${assetConfig.groupAccount}`;
    }
    return zetaGroupAccountLayout('').decode(zetaGroupAccount.data, 0);
}

// return timestamp in ms
export async function getZetaExpirySeries(connection: Connection, baseSymbol: string): Promise<ZetaExpirySeries[]> {
    const zetaGroup = await getZetaGroup(connection, baseSymbol);
    return zetaGroup.expirySeries.map((i) => {
        return {
            activeTs: i['activeTs'].muln(1000).toNumber(),
            expiryTs: i['expiryTs'].muln(1000).toNumber(),
        };
    });
}

export function getSerumOpenOrdersAccountKey(botKey: PublicKey, programId: PublicKey) {
    return PublicKey.findProgramAddress([botKey.toBuffer(), Buffer.from('open-orders', 'utf-8')], programId).then(
        (res) => res[0],
    );
}

export function getMangoReimbursementAccountKey(ownerKey: PublicKey) {
    return PublicKey.findProgramAddress(
        [Buffer.from('ReimbursementAccount'), MANGO_REIMBURSEMENT_GROUP_KEY.toBuffer(), ownerKey.toBuffer()],
        MANGO_REIMBURSEMENT_PROGRAM_ID,
    ).then((res) => res[0]);
}

export async function getMangoReimbursementGroup(connection: Connection): Promise<MangoReimbursementGroup> {
    const accountInfo = await connection.getAccountInfo(MANGO_REIMBURSEMENT_GROUP_KEY);
    if (!accountInfo) {
        throw `Get mango reimbursement group error: account not found ${MANGO_REIMBURSEMENT_GROUP_KEY.toString()}`;
    }
    return mangoReimbursementGroupLayout('').decode(accountInfo.data, 0);
}

export async function getMangoReimbursementTable(connection: Connection, reimbursementTableKey: PublicKey) {
    const accountInfo = await connection.getAccountInfo(reimbursementTableKey);
    if (!accountInfo) {
        throw `Get mango reimbursement table error: account not found ${reimbursementTableKey.toString()}`;
    }
    return MangoReimbursementTableLayout.decode(accountInfo.data.slice(40));
}

export async function getMangoReimbursementRow(
    connection,
    botKey: PublicKey,
): Promise<MangoReimbursementRow | undefined> {
    const reimbursementGroup = await getMangoReimbursementGroup(connection);
    const rows = await getMangoReimbursementTable(connection, reimbursementGroup.table).then((res) => res['rows']);
    for (const [index, row] of rows.entries()) {
        if (row['owner'].equals(botKey)) {
            return { index, owner: row['owner'], balances: row['balances'].map((i) => new Decimal(i.toString())) };
        }
    }
}

export async function getMangoReimbursementAccount(
    connection: Connection,
    reimbursementAccountKey: PublicKey,
): Promise<MangoReimbursementAccount | undefined> {
    const accountInfo = await connection.getAccountInfo(reimbursementAccountKey);
    if (!accountInfo) {
        return;
    }
    return mangoReimbursementAccountLayout('').decode(accountInfo.data, 0);
}

export async function redeemAllFromBot(
    connection: Connection,
    botSeed: Uint8Array,
    owner: PublicKey,
    referrer: PublicKey,
    cellAdmin: PublicKey,
    tokenSymbols: string[],
    programId: PublicKey,
): Promise<TransactionPayload> {
    if (tokenSymbols.length == 0) {
        throw `Redeem all from bot error: no asset in redeem token list`;
    }
    const botKey = await getBotKeyBySeed(botSeed, programId);
    const botMintKey = await getBotMintKeyBySeed2(botSeed, programId);
    const ownerBotMintATA = await getATAKey(owner, botMintKey);
    const cellConfigKey = await getCellConfigAccountKey(programId);

    const payload: TransactionPayload = { instructions: [], signers: [] };
    const botAssetKeys: PublicKey[] = [];
    const ownerAssetKeys: PublicKey[] = [];
    const cellAssetKeys: PublicKey[] = [];
    const assetPriceKeys: PublicKey[] = [];
    const referrerAssetKeys: PublicKey[] = [];
    for (const tokenSymbol of tokenSymbols) {
        const tokenConfig = getTokenConfigBySymbol(tokenSymbol) as SolanaTokenConfig;

        const botTokenATA = await getATAKey(botKey, tokenConfig.mintKey);
        botAssetKeys.push(botTokenATA);

        const [ownerTokenATA, createOwnerTokenATAIx] = await createATA(connection, owner, tokenConfig.mintKey, owner);
        if (createOwnerTokenATAIx) {
            payload.instructions.push(createOwnerTokenATAIx);
        }
        ownerAssetKeys.push(ownerTokenATA);

        const [cellTokenATA, createCellTokenATAIx] = await createATA(connection, cellAdmin, tokenConfig.mintKey, owner);
        if (createCellTokenATAIx) {
            payload.instructions.push(createCellTokenATAIx);
        }
        cellAssetKeys.push(cellTokenATA);

        assetPriceKeys.push(tokenConfig.pythPriceKey);

        if (!referrer.equals(PublicKey.default)) {
            const [referrerTokenATA, createReferrerTokenATAIx] = await createATA(
                connection,
                referrer,
                tokenConfig.mintKey,
                owner,
            );
            if (createReferrerTokenATAIx) {
                payload.instructions.push(createReferrerTokenATAIx);
            }
            referrerAssetKeys.push(referrerTokenATA);
        }
    }
    payload.instructions.push(
        redeemAllAssetsFromBotIx({
            botSeed,
            botKey,
            botMintKey,
            userBotTokenKey: ownerBotMintATA,
            userKey: owner,
            referrerKey: referrer,
            botAssetKeys,
            userAssetKeys: ownerAssetKeys,
            cellAssetKeys,
            assetPriceKeys,
            cellConfigKey: cellConfigKey,
            referrerAssetKeys,
            programId: programId,
        }),
    );
    return payload;
}

export function getSerumPoolWorkingCapKey(botKey: PublicKey, programId: PublicKey) {
    return PublicKey.findProgramAddress([botKey.toBuffer(), Buffer.from('working-cap', 'utf-8')], programId).then(
        (res) => res[0],
    );
}

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true,
        "resolveJsonModule": true,
        "module": "commonjs",
        "esModuleInterop": true,
        "target": "ES2020",
        "noImplicitAny": false,
        "moduleResolution": "node",
        "sourceMap": true,
        "outDir": "./dist",
        "skipLibCheck": true,
        "declaration": true
        // "strict": true
    },
    "include": ["src"],
    "exclude": ["node_modules"]
}

'''