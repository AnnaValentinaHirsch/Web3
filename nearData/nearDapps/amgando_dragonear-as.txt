*GitHub Repository "amgando/dragonear-as"*

'''--- README.md ---
# DragoNEAR in AssemblyScript

Transcribed from the original [DragoNEAR in Rust](https://github.com/ilblackdragon/dragonear)

Based on work by [theophoric](https://github.com/theophoric/near-core-contracts-as) in adapting NEAR core contracts

## Setup

1. run `./scripts/1.dev-deploy.sh`  \
   _(note that you will see some messages about `Missing ... environment variable` the first time you run this)_
   > sample: https://explorer.testnet.near.org/transactions/5Zup3iJsYPPPojcZ4YTn4ezLhHr1MQK9nZWAh7PjnEdG

2. setup environment variable for contract account  \
   `export CONTRACT=<dev-123-456>`

3. initialize the contract  \
   `near call $CONTRACT init '{"owner_id":"'$CONTRACT'"}' --accountId $CONTRACT`
   > sample: https://explorer.testnet.near.org/transactions/GFjc3f2J7df8h2gKgAPKm8eXpEZorPctSuFhSBcd6SWN

4. setup environment variables for game play  \
   `export PLAYER1=<some account>`
   `export PLAYER2=<another account>`

5. run `./scripts/2.use-contract.sh`

# ðŸ’¥

```sh
	Failure [dev-1631945920580-30795013478292]: Error: {"index":0,"kind":{"ExecutionError":"WebAssembly trap: An `unreachable` opcode was executed."}}
```

---

## Testing

run `yarn test`

```sh
[Describe]: Contract

 [Success]: âœ” runs a basic battle

    [File]: src/dragonear/__tests__/index.unit.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: âœ” PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 1 pass,  0 fail, 1 total
    [Time]: 28.753ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: âœ” PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 1 pass, 0 fail, 1 total
    [Time]: 14385.03ms
âœ¨  Done in 15.00s.
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/dragonear"
  ]
}

'''
'''--- package.json ---
{
  "name": "dragonear-as",
  "version": "0.0.1",
  "description": "Transcribed from the original in Rust",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"
[ -z "$OWNER" ] || echo "Found it! \$OWNER is set to [ $OWNER ]"

near delete $CONTRACT $OWNER
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

near dev-deploy ./build/release/dragonear.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo "export CONTRACT=<dev-123-456>"
echo "near call \$CONTRACT init '{\"owner_id\":\"'\$CONTRACT'\"}' --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

[ -z "$PLAYER1" ] && echo "Missing \$PLAYER1 environment variable" && exit 1
[ -z "$PLAYER1" ] || echo "Found it! \$PLAYER1 is set to [ $PLAYER1 ]"

[ -z "$PLAYER2" ] && echo "Missing \$PLAYER2 environment variable" && exit 1
[ -z "$PLAYER2" ] || echo "Found it! \$PLAYER2 is set to [ $PLAYER2 ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Creating player accounts and two dragons each"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near call $CONTRACT create_account --accountId $PLAYER1
near call $CONTRACT create_account --accountId $PLAYER2

echo
echo

near call $CONTRACT dragon_create '{"account_id":"'$PLAYER1'"}' --accountId $CONTRACT
near call $CONTRACT dragon_create '{"account_id":"'$PLAYER1'"}' --accountId $CONTRACT

near call $CONTRACT dragon_create '{"account_id":"'$PLAYER2'"}' --accountId $CONTRACT
near call $CONTRACT dragon_create '{"account_id":"'$PLAYER2'"}' --accountId $CONTRACT

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Players select their dragons"
echo ---------------------------------------------------------
echo

near call $CONTRACT dragon_select '{"dragon_id":"1"}' --accountId $PLAYER1
near call $CONTRACT dragon_select '{"dragon_id":"2"}' --accountId $PLAYER2

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Battle!"
echo ---------------------------------------------------------
echo

near call $CONTRACT battle_start --accountId $CONTRACT

exit 0

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/dragonear/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/dragonear/__tests__/index.unit.spec.ts ---
import { VMContext } from "near-sdk-as";
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  const owner = "owen"
  contract = new Contract(owner)
})

describe("Contract", () => {
  // VIEW method tests

  it("runs a basic battle", () => {
    const owner = "owen"
    const accounts = ["alice", "bob", "carol"]
    for (let i = 0; i < 3; i++) {
      const account = accounts[i]
      VMContext.setPredecessor_account_id(account)
      contract.create_account()
      VMContext.setPredecessor_account_id(owner)
      contract.dragon_create(account)
    }

    VMContext.setPredecessor_account_id(accounts[1])
    contract.dragon_select(1)
    expect(contract.battle_start()).toBeFalsy()

    VMContext.setPredecessor_account_id(accounts[2])
    contract.dragon_select(2)
    expect(contract.battle_start()).toBeTruthy()

  })
})

'''
'''--- src/dragonear/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/dragonear/assembly/account.ts ---
import { Context } from "near-sdk-as"
import { Timestamp, Option } from "../../utils"

@nearBindgen
export class Account {
  public cluster_id: u64 = 0
  public current_dragon: Option<u64>
  dragon_change_timestamp: Timestamp = 0

  set_dragon(dragon_id: u64): void {
    assert(this.dragon_change_timestamp < Context.blockTimestamp + DAY_DURATION, "ERR_CHANGE_DRAGON_DELAY");
    if (dragon_id == u64.MAX_VALUE) {
      this.current_dragon = new Option(0);
    } else {
      this.current_dragon = new Option(dragon_id);
    }
    this.dragon_change_timestamp = Context.blockTimestamp;
  }
}

/**
 * VERSIONED MODEL

pub enum VAccount {
    V1(Account)
}

impl From<VAccount> for Account {
    fn from(c: VAccount) -> Self {
        match c {
            VAccount::V1(c) => c
        }
    }
}
*/

const DAY_DURATION: Timestamp = 24 * 60 * 60 * 1_000_000;

'''
'''--- src/dragonear/assembly/battle.ts ---
import { Context } from "near-sdk-as"
import { Timestamp, CryptoHash, Option } from "../../utils";
import { Dragon } from "./dragon"

const BATTLE_MAX_DURATION: Timestamp = 10 * 60 * 1_000_000;

export class Battle {
  start_timestamp: Timestamp
  hash_actions_a: Option<CryptoHash>
  hash_actions_b: Option<CryptoHash>
  actions_a: Option<Array<u8>>
  actions_b: Option<Array<u8>>

  constructor(
    public dragon_a: u64,
    public dragon_b: u64
  ) {
    this.start_timestamp = Context.blockTimestamp
    this.hash_actions_a = new Option([])
    this.hash_actions_b = new Option([])
    this.actions_a = new Option([])
    this.actions_b = new Option([])
  }

  set_hash_actions(dragon_id: u64, hash_actions: CryptoHash): void {
    assert(this.dragon_a == dragon_id || this.dragon_b == dragon_id, "ERR_NOT_YOUR_BATTLE");
    if (this.dragon_a == dragon_id) {
      this.hash_actions_a = new Option(hash_actions)
    } else {
      this.hash_actions_b = new Option(hash_actions)
    }
  }

  set_actions(dragon_id: u64, actions: Array<u8>): void {
    assert(this.dragon_a == dragon_id || this.dragon_b == dragon_id, "ERR_NOT_YOUR_BATTLE");
    // TODO: check hashes.
    if (this.dragon_a == dragon_id) {
      this.actions_a = new Option(actions);
    } else {
      this.actions_b = new Option(actions);
    }
  }

  complete(): bool {
    // TODO: add expiry
    return this.actions_a.is_some() && this.actions_b.is_some() || Context.blockTimestamp >= this.start_timestamp + BATTLE_MAX_DURATION
  }

  run(dragon_a: Dragon, dragon_b: Dragon): void {
    // TODO: run the battle.
    let i = 0;
    let j = 0;
    let actions_a = this.actions_a.unwrap() || [0];
    let actions_b = this.actions_b.unwrap() || [0];
    let constitution_a = dragon_a.constitution;
    let constitution_b = dragon_b.constitution;
    while (true) {
      dragon_a.apply_skill(constitution_a, constitution_b, actions_a[i]);
      dragon_b.apply_skill(constitution_b, constitution_a, actions_b[i]);
      i = (i + 1) % actions_a.length;
      j = (j + 1) % actions_b.length;
    }
  }
}

/**
 * VERSIONED MODEL

pub enum VBattle {
    V1(Battle)
}

impl From<VBattle> for Battle {
    fn from(c: VBattle) -> this {
        match c {
            VBattle::V1(c) => c
        }
    }
}
*/

'''
'''--- src/dragonear/assembly/cluster.ts ---
import { Option } from "../../utils"

@nearBindgen
export class Cluster {
    constructor(
        public max_lvl: u8,
        /// Last dragon that is waiting for battle in this cluster.
        public waiting_for_battle: Option<u64>
    ) { }
}

/**
 * VERSIONED MODEL

pub enum VCluster {
    V1(Cluster)
}

impl From<VCluster> for Cluster {
    fn from(c: VCluster) -> Self {
        match c {
            VCluster::V1(c) => c
        }
    }
}
*/

'''
'''--- src/dragonear/assembly/dragon.ts ---
import { RNG } from "near-sdk-as";
import { AccountId } from "../../utils"

enum Element {
  Physical,
  Fire,
  Water,
  Air,
  Earth,
}

function randomElement(): Element {
  return Element.Physical
}

@nearBindgen
class Ratio {
  constructor(public num: u32, public denom: u32) { }
}

enum SkillKind {
  Attack,
  Buff,
}

@nearBindgen
class Skill {
  constructor(
    public element: Element,
    public kind: SkillKind,
    public powerup_ratio: Ratio,
    public cooldown: u32) { }

  static physical(): Skill {
    return new Skill(
      Element.Physical,
      SkillKind.Attack,
      new Ratio(1, 1),
      0)
  }

  static random(): Skill {
    return new Skill(
      randomElement(),
      random_number() % 2 == 0 ? SkillKind.Attack : SkillKind.Buff,
      random_powerup(),
      random_cooldown(),
    )
  }
}

function random_number(): u8 {
  const rng = new RNG<u8>(1);
  return rng.next();
}

function random_powerup(): Ratio {
  const rn = random_number()

  if (rn >= 0 && rn <= 99) {
    return new Ratio(1, 1)
  } else if (rn >= 100 && rn <= 174) {
    return new Ratio(5, 4)
  } else if (rn >= 175 && rn <= 224) {
    return new Ratio(3, 2)
  } else if (rn >= 225 && rn <= 250) {
    return new Ratio(2, 1)
  } else {
    return new Ratio(5, 1)
  }
}

function random_cooldown(): u32 {
  const rn = random_number()

  if (rn >= 0 && rn <= 99) {
    return 3
  } else if (rn >= 100 && rn <= 200) {
    return 2
  } else {
    return 1
  }
}

@nearBindgen
class Constitution {
  constructor(
    public max_hp: u32,
    public attack: Array<u32>,
    public defense: Array<u32>) { }
}

@nearBindgen
export class Dragon {
  constructor(
    public owner_id: AccountId,
    public generation: u8,
    public level: u8,
    public exp: u32,
    public element: Element,
    public skills: Array<Skill>,
    public constitution: Constitution,
  ) { }

  /// Create a random dragon of 0th generation.
  static random(account_id: AccountId): Dragon {
    const skills = [Skill.physical()];

    const constitution = new Constitution(
      (random_number() % 10) + 10,
      [1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1],
    );

    return new Dragon(
      account_id,
      0,
      0,
      0,
      randomElement(),
      skills,
      constitution
    );
  }

  /// Mate two dragons and create a new dragon of next generation and of the given properties.
  // pub fn mate(dragon_a: &Dragon, dragon_b: &Dragon) -> Self {
  //     Self::random(dragon_a)
  // }

  uplevel(): void {
    assert(this.exp >= (this.level) * 1000, "NOT_ENOUGH_EXP");
    this.exp -= (this.level) * 1000;
    this.level += 1;
    this.skills.push(Skill.random());
  }

  apply_skill(constitution: Constitution, other_constitution: Constitution, skill_id: u8): void {
    let skill = this.skills[skill_id];
    let element_id = skill.element
    switch (skill.kind) {
      case SkillKind.Attack:
        let attack = constitution.attack[element_id] * skill.powerup_ratio.num / skill.powerup_ratio.denom;
        let defense = other_constitution.defense[element_id];
        attack -= attack < defense ? 1 : attack - defense;
        other_constitution.max_hp -= min(attack, other_constitution.max_hp);
        break;
      case SkillKind.Buff:
        constitution.defense[element_id] = constitution.defense[element_id] * skill.powerup_ratio.num / skill.powerup_ratio.denom;
        break;
    }
  }
}

/**
 * VERSIONED MODEL

  pub enum VDragon {
      V1(Dragon)
  }

  impl From<VDragon> for Dragon {
      fn from(c: VDragon) -> Self {
          match c {
              VDragon::V1(c) => c
          }
      }
  }
*/

'''
'''--- src/dragonear/assembly/index.ts ---
import { logging, Context, PersistentUnorderedMap } from "near-sdk-as"

import { AccountId, Base58CryptoHash, Option } from "../../utils"

import { Account } from "./account"
import { Cluster } from "./cluster"
import { Battle } from "./battle"
import { Dragon } from "./dragon"

enum StorageKey {
  Accounts,
  Dragons,
  Clusters,
  Battles,
}

@nearBindgen
export class Contract {
  owner_id: AccountId
  accounts: PersistentUnorderedMap<AccountId, Account>;
  dragons: PersistentUnorderedMap<u64, Dragon>;
  clusters: PersistentUnorderedMap<u64, Cluster>;
  battles: PersistentUnorderedMap<String, Battle>;
  last_dragon_id: u64;

  constructor(
    owner_id: AccountId,
  ) {
    this.owner_id = owner_id
    this.accounts = new PersistentUnorderedMap(StorageKey.Accounts.toString())
    this.dragons = new PersistentUnorderedMap(StorageKey.Dragons.toString())
    this.clusters = new PersistentUnorderedMap(StorageKey.Clusters.toString())
    this.battles = new PersistentUnorderedMap(StorageKey.Battles.toString())
    this.last_dragon_id = 0
    this.set_cluster(0, new Cluster(255, new Option(0)))
  }

  get_account(account_id: AccountId): Account | null {
    const account = this.accounts.get(account_id)
    assert(account, "NO_ACCOUNT")
    return account
  }

  set_account(account_id: AccountId, account: Account): void {
    this.accounts.set(account_id, account);
  }

  get_dragon(dragon_id: u64): Dragon | null {
    const dragon = this.dragons.get(dragon_id)
    assert(dragon, "NO_DRAGON")
    return dragon
  }

  set_dragon(dragon_id: u64, dragon: Dragon): void {
    this.dragons.set(dragon_id, dragon);
  }

  get_cluster(cluster_id: u64): Cluster | null {
    const cluster = this.clusters.get(cluster_id)
    assert(cluster, "NO_CLUSTER")
    return cluster
  }

  set_cluster(cluster_id: u64, cluster: Cluster): void {
    this.clusters.set(cluster_id, cluster);
  }

  get_battle(battle_id: string): Battle | null {
    const battle = this.battles.get(battle_id)
    assert(battle, "NO_BATTLE")
    return battle
  }

  set_battle(battle_id: string, battle: Battle): void {
    this.battles.set(battle_id, battle);
  }

  create_account(): void {
    let account_id = Context.predecessor
    assert(!this.accounts.contains(account_id), "ERR_ACCOUNT_EXISTS");
    this.set_account(account_id, new Account());
  }

  dragon_create(account_id: AccountId): u64 {
    assert(Context.predecessor == this.owner_id, "ONLY_OWNER");
    let dragon = Dragon.random(account_id);
    this.set_dragon(this.last_dragon_id, dragon);
    this.last_dragon_id += 1;
    return this.last_dragon_id - 1
  }

  dragon_select(dragon_id: u64): void {
    let account_id = Context.predecessor
    let account = this.get_account(account_id)!;
    if (dragon_id != u64.MAX_VALUE) {
      let dragon = this.get_dragon(dragon_id)!;
      assert(dragon.owner_id == account_id, "ERR_NOT_OWNER");
    }
    account.set_dragon(dragon_id);
    this.set_account(account_id, account);
  }

  private internal_get_info(): Info {
    let account = this.get_account(Context.predecessor)!;
    let cluster = this.get_cluster(account.cluster_id)!;
    let dragon_id = account.current_dragon.expect("ERR_NO_DRAGON_SELECTED")
    let dragon = this.get_dragon(dragon_id)!;
    return new Info(account, cluster, dragon_id, dragon)
  }

  private internal_create_battle(dragon_a: u64, dragon_b: u64): void {
    let battle = new Battle(dragon_a, dragon_b);
    this.set_battle(`${dragon_a}:${dragon_b}`, battle);
  }

  battle_start(): bool {
    let info = this.internal_get_info();
    assert(info.dragon.level <= info.cluster.max_lvl, "ERR_HIGH_LEVEL");
    let started_battle: bool
    let waiting_dragon_id = info.cluster.waiting_for_battle.unwrap()
    if (waiting_dragon_id) {
      this.internal_create_battle(info.dragon_id, waiting_dragon_id);
      info.cluster.waiting_for_battle = new Option(0);
      started_battle = true
    } else {
      info.cluster.waiting_for_battle = new Option(info.dragon_id);
      started_battle = false
    };
    this.set_cluster(info.account.cluster_id, info.cluster);
    return started_battle
  }

  battle_commit_actions(battle_id: string, hash_actions: Base58CryptoHash): void {
    let info = this.internal_get_info();
    let battle = this.get_battle(battle_id)!;
    battle.set_hash_actions(info.dragon_id, hash_actions);
    this.set_battle(battle_id, battle);
  }

  battle_reveal_actions(battle_id: string, actions: Array<u8>): void {
    let info = this.internal_get_info();

    let battle = this.get_battle(battle_id)!;
    battle.set_actions(info.dragon_id, actions);
    if (battle.complete()) {
      let other_dragon_id = info.dragon_id == battle.dragon_a ? battle.dragon_b : battle.dragon_a;
      let other_dragon = this.get_dragon(other_dragon_id)!;
      if (info.dragon_id == battle.dragon_a) {
        battle.run(info.dragon, other_dragon);
      } else {
        battle.run(other_dragon, info.dragon);
      }
      this.set_dragon(info.dragon_id, info.dragon);
      this.set_dragon(other_dragon_id, other_dragon);
    }
    this.set_battle(battle_id, battle);
  }

  cluster_select(cluster_id: u64): void {
    let account_id = Context.predecessor
    let account = this.get_account(account_id)!;
    // TODO: add more properties of the cluster.
    account.cluster_id = cluster_id;
    this.set_account(account_id, account);
  }
}

class Info {
  constructor(
    public account: Account,
    public cluster: Cluster,
    public dragon_id: u64,
    public dragon: Dragon,
  ) { }
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

export type CryptoHash = Array<u8>;
export type Base58CryptoHash = CryptoHash;

@nearBindgen
export class Option<T> {
  constructor(public value: T) { }

  is_some(): bool {
    return (!this.is_none());
  }
  is_none(): bool {
    if (isNullable<T>() || isReference<T>()) {
      return changetype<usize>(this.value) == 0;
    } else {
      return false
    }
  }
  expect(message: string = "Missing expected value"): T {
    assert(this.is_some(), message);
    return this.value;
  }
  unwrap(): T {
    return this.expect();
  }
}

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''