*GitHub Repository "near/near-api-helper"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

- The use of sexualized language or imagery and unwelcome sexual attention or
  advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic
  address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at ag_dubs@cloudflare.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- README.md ---

# NEAR API Helper

Batch near-api-js RPC calls.

Optionally flatten and sort arrays of objects.

## ðŸš¨ Warning this is WIP ðŸš¨
- Not officially supported (yet)
- Potential syntax changes
- For now route does nothing (v1/testnet/view only example)

## Notes
I am aware snake_case and JSON in REST is ugly. However, not willing to convert all method names and args from what you would normally use with near-api-js. e.g. maintain consistency between these API calls and RPC calls as best I can.

## Syntax
```bash
# GET (note with http you need to escape the JSON with single quotes first)
http https://helper.nearapi.org/v1/contract/dev-1618440176640-7650905/nft_token/'{"token_id":"token-1619265007329"}'
```

# Example calls from client side:
```js
// consts
const domain = 'http://127.0.0.1:8787'; // wrangler dev local testing
// const domain = 'https://helper.nearapi.org/v1/contract/' // testnet helper domain
const domainAndPath = domain + '/v1/contract/';
const testNFTPath = domainAndPath + 'dev-1618440176640-7650905/nft_token/';
const batchPath = domain + '/v1/batch/';
```

## It should have the whole rpc response

Returns a raw response for a given view near-api-js call (viewFunction)

```javascript
const args = JSON.stringify({
	token_id: 'token-1619265007329'
});
const url = testNFTPath + args;
console.log('\n URL:\n', url, '\n');
const response = await fetch(url).then((res) => res.json());

assert.strictEqual(Object.keys(response).length > 1, true);
```

## It should return just a field with the last field name as key

Use this to drill into JSON responses (e.g. get metadata for a token)

```javascript
const args = JSON.stringify({
	token_id: 'token-1619265007329'
});
const actions = JSON.stringify({
	field: 'metadata.media'
});
const url = testNFTPath + args + '/' + actions;
console.log('\n URL:\n', url, '\n');
const response = await fetch(url).then((res) => res.json());

assert.strictEqual(Object.keys(response).length, 1);
```

## It should have a bot response with customized fields

Creates a bot response for when you share your links (link previews with images etc...)

```javascript
const args = JSON.stringify({
	token_id: 'token-1619265007329'
});
const actions = JSON.stringify({
	botMap: {
		'og:title': 'MEOW',
		'og:image': { field: 'metadata.media' }
	}
});
const url = testNFTPath + args + '/' + actions;
console.log('\n URL:\n', url, '\n');
const response = await fetch(url, {
	headers: {
		'user-agent': 'facebookexternalhit'
	}
}).then((res) => res.text());

console.log(response);

assert.strictEqual(response.indexOf('MEOW') > -1, true);
```

## It should return an encoded url

Turn your call into an encoded URL that you can use for sharing (prettier than JSON in REST)

botMap for bots -> link preview
redirect for users -> NFT item

```javascript
const args = JSON.stringify({
	token_id: 'token-1619265007329'
});
const actions = JSON.stringify({
	botMap: {
		'og:title': 'MEOW',
		'og:image': { field: 'metadata.media' }
	},
	redirect: 'https%3A%2F%2Fnear-apps.github.io%2Fnft-market%2F',
	encodeUrl: true,
});
const url = testNFTPath + args + '/' + actions;
console.log('\n URL:\n', url, '\n');
const response = await fetch(url).then((res) => res.json());
assert.strictEqual(Object.keys(response)[0], 'encodedUrl');

// redirect will return html from market which should not contain the string MEOW
const encodedUrl = Object.values(response)[0];
console.log('\n URL:\n', encodedUrl, '\n');
const response2 = await fetch(encodedUrl).then((res) => res.text());
assert.strictEqual(response2.indexOf('MEOW') === -1, true);
```

## It should return a batched response

Use this to get a lot of data at once.

Call different view methods.

Within each call, the first and second arguments of batch must have names matching the contract arguments used for offset and limit.

e.g. if the contract has args like "offset" and "num", you need to use: batch: { offset: '0', num: '100', step: '10' }

This means "start at '0' and keep making RPC calls until '100' increasing by '10' each time." creating a total of 10 RPC calls in the helper, but only 1 call and reponse for the user.

flatten: [] combines results into an array vs. separate RPC results

WIP
sort.field: what field on the objects to use for sorting
sort.parse: how to treat the field "int": parseInt or "bn": parseFloat(parseNearAmount(val, 8)) // 8 decimal approximation of NEAR

```javascript
const batch = [{
	contract: 'dev-1618440176640-7650905',
	method: 'nft_tokens',
	args: {},
	batch: {
		from_index: '0', // must be name of contract arg (above)
		limit: '200', // must be name of contract arg (above)
		step: '10', // divides contract arg 'limit'
		flatten: [], // how to combine results
	},
	sort: {
		path: 'metadata.issued_at',
	}
},
{
	contract: 'market.dev-1618440176640-7650905',
	method: 'get_sales_by_nft_contract_id',
	args: {
		nft_contract_id: 'dev-1618440176640-7650905'
	},
	batch: {
		from_index: '0', // must be name of contract arg (above)
		limit: '100', // must be name of contract arg (above)
		step: '10', // divides contract arg 'limit'
		flatten: [], // how to combine results
	},
	sort: {
		path: 'conditions.near',
		parse: 'bn'
	}
}];

const url = batchPath + JSON.stringify(batch);
console.log('\n URL:\n', url, '\n');

const response = await fetch(batchPath + JSON.stringify(batch)).then((res) => res.json());

assert.strictEqual(response.length, 2);
assert.strictEqual(response[0].length > 20, true);
assert.strictEqual(response[1].length > 0, true);
```

## It should return a batched response

Mainnet Test

```javascript
const batch = [{
	contract: 'nft_679bada6b8.near-hackathon.collab-land.near',
	method: 'nft_tokens',
	args: {},
	batch: {
		from_index: '0', // must be name of contract arg (above)
		limit: '1000', // must be name of contract arg (above)
		step: '50', // divides contract arg 'limit'
		flatten: [], // how to combine results
	},
}];

const url = batchPath + JSON.stringify(batch);
console.log('\n URL:\n', url, '\n');

const response = await fetch(batchPath + JSON.stringify(batch), {
	headers: {
		'near-network': 'mainnet'
	}
}).then((res) => res.json());

assert.strictEqual(response[0].length > 300, true);
```

'''
'''--- TEST.md ---

# /view

# near-api-helper

Batch near-api-js RPC calls.

Optionally flatten and sort arrays of objects.

# ðŸš¨ WIP ðŸš¨

- Not officially supported (yet)
- Potential syntax changes
- For now route does nothing (v1/testnet/view only example)

### Example call from client side

## It should have the whole rpc response

```javascript
const response = await fetch(domainAndPath + 'dev-1618440176640-7650905/nft_token/{"token_id":"token-1619265007329"}').then((res) => res.json())

assert.strictEqual(Object.keys(response).length > 1, true)
```

## It should have the whole rpc response

```javascript
const response = await fetch(domainAndPath + 'dev-1618440176640-7650905/nft_token/{"token_id":"token-1619265007329"}/{"field":"metadata.media"}').then((res) => res.json())

assert.strictEqual(Object.keys(response).length, 1)
```

## It should return an encoded url

```javascript
const response = await fetch(domainAndPath + 'dev-1618440176640-7650905/nft_token/{"token_id":"token-1619265007329"}/{"botMap":{"og:image":{"field":"metadata.media"}},"redirect":"https%3A%2F%2Fnear-apps.github.io%2Fnft-market%2F","encodeUrl":true}').then((res) => res.json())
        
assert.strictEqual(Object.keys(response)[0], 'encodedUrl')
```

## It should have a bot response with customized fields

```javascript
const response = await fetch(domainAndPath + 'dev-1618440176640-7650905/nft_token/{"token_id":"token-1619265007329"}/{"botMap":{"og:title":"MEOW","og:image":{"field":"metadata.media"}}}', { 
    headers: {
        'user-agent': 'facebookexternalhit'
    }
}).then((res) => res.text())

assert.strictEqual(response.indexOf('MEOW') > -1, true)
```

## It should return a batched response

```javascript
this.timeout(5000);

const batch = [{
    contract: 'dev-1618440176640-7650905',
    method: 'nft_tokens',
    args: {},
    batch: {
        from_index: '0', // must be name of contract arg (above)
        limit: '500', // must be name of contract arg (above)
        step: '100', // divides contract arg 'limit'
        flatten: [], // how to combine results
    },
    sort: {
        path: 'metadata.issued_at',
    }
},
{
    contract: 'market.dev-1618440176640-7650905',
    method: 'get_sales_by_nft_contract_id',
    args: {
        nft_contract_id: 'dev-1618440176640-7650905'
    },
    batch: {
        from_index: '0', // must be name of contract arg (above)
        limit: '500', // must be name of contract arg (above)
        step: '100', // divides contract arg 'limit'
        flatten: [], // how to combine results
    },
    sort: {
        path: 'conditions.near',
        parse: 'bn'
    }
}]
const response = await fetch(batchPath + JSON.stringify(batch)).then((res) => res.json())
        
assert.strictEqual(response.length, 2)
assert.strictEqual(response[0].length > 0, true)
assert.strictEqual(response[1].length > 0, true)
```

'''
'''--- index.js ---
import { handleOptions, corsHeaders, jsonHeaders } from './src/cors';
import { checkCache } from './src/cache';
import { handleView } from './src/view';
import { handleBatch } from './src/batch'
import { handleUpload, handleShare } from './src/upload'
import { handleRedirect } from './src/redirect'
import { getParamsObj } from './src/utils';
import { pathToArgs } from './src/path';

addEventListener('fetch', (event) => {
	const { request } = event
	if (request.method === "OPTIONS") {
		event.respondWith(handleOptions(request))
		return
	}
	event.respondWith(wrapRequest(event))
})

async function wrapRequest(event) {
	try {
		return await handleRequest(event)
	} catch(e) {
		console.warn(e)
		return new Response(JSON.stringify({ error: e.toString() }), {
			headers: jsonHeaders,
			status: 500,
		})
	}
}

async function handleRequest(event) {
	const { request } = event
	const { headers } = request
    const userAgent = headers.get('user-agent') || ''
    const networkId = headers.get('near-network') || 'testnet'
    const signature = JSON.parse(headers.get('near-signature') || '{}')
	const url = new URL(request.url)
	const { searchParams, pathname } = url
	if (pathname === '/favicon.ico') return new Response('')
	let params = getParamsObj(searchParams)
    let cacheMaxAge = headers.get('max-age') || '60'

	// qualify path and args
	const pathArgs = pathToArgs(pathname)
	Object.assign(params, pathArgs)

	// '0' max-age means : "skip cache"
	// if there's a cached response, serve it
	const { cache, cachedResponse, cacheKey } = await checkCache({ request, params, url, corsHeaders, cacheMaxAge })
	if (cachedResponse) {
		return cachedResponse
	}
	if (cacheMaxAge === '0') {
		cacheMaxAge = '60'
	}

	const methodArgs = {
		event, request, url, params, userAgent, signature,
		jsonHeaders, corsHeaders,
		cache, cacheKey, cacheMaxAge, networkId,
	}

	switch (request.method) {
		case 'GET': 
			switch (params.type) {
				case 'share': return await handleShare(methodArgs)
				case 'view': return await handleView(methodArgs)
				case 'batch': return await handleBatch(methodArgs)
			}
		case 'POST': 
			switch (params.type) {
				case 'batch': 
					params.views = await request.json()
					return await handleBatch(methodArgs)
				case 'upload': return await handleUpload(methodArgs)
				case 'redirect': return await handleRedirect(methodArgs)
			}
	}

}

'''
'''--- package.json ---
{
	"private": true,
	"name": "api-helper",
	"version": "1.0.0",
	"description": "A template for kick starting a Cloudflare Workers project",
	"main": "index.js",
	"scripts": {
		"fix": "eslint src/ test/ --fix",
		"doc": "acquit-markdown -p ./test/api.test.js > README.md",
		"test": "mocha",
		"format": "prettier --write '**/*.{js,css,json,md}'"
	},
	"author": "mattlockyer <mattdlockyer@gmail.com>",
	"license": "MIT",
	"devDependencies": {
		"acquit": "^1.2.1",
		"acquit-markdown": "^0.1.0",
		"eslint": "^7.14.0",
		"mocha": "^8.3.2",
		"node-fetch": "^2.6.1",
		"prettier": "^1.18.2"
	},
	"dependencies": {
		"@msgpack/msgpack": "^2.6.0",
		"base64-js": "^1.5.1",
		"bs58": "^4.0.1",
		"near-api-js": "^0.41.0",
		"tweetnacl": "^1.0.3"
	}
}

'''
'''--- src/b2.js ---
const B2 = JSON.parse(ENV_B2)

export const authB2 = () => {
    return fetch('https://api.backblazeb2.com' + B2.apiPath + 'b2_authorize_account', {
        headers: {
            authorization: 'Basic ' + btoa(B2.keyID + ':' + B2.applicationKey)
        }
    }).then((res) => res.json())
}

export const uploadB2 = async ({ fn, body, bytes, type = 'image/png' }) => {
    const auth = await authB2()

    const upload = await fetch(auth.apiUrl + B2.apiPath + 'b2_get_upload_url', {
        method: 'POST',
        headers: {
            authorization: auth.authorizationToken,
        },
        body: JSON.stringify({ bucketId: B2.bucketId })
    }).then((res) => res.json())

    const res = await fetch(upload.uploadUrl, {
        method: 'POST',
        headers: {
            authorization: upload.authorizationToken,
            'X-Bz-File-Name': fn,
            // 'X-Bz-Content-Sha1': sha1,
            'X-Bz-Content-Sha1': 'do_not_verify',
            'Content-Type': type,
            'Content-Length': bytes,
        },
        body
    }).then((res) => res.json())

    return res
}

export const downloadB2 = async (fn, auth) => {
    if (!auth) auth = await authB2()
    const fileUrl = auth.downloadUrl + B2.filePath + fn
    const res = await fetch(fileUrl, {
        headers: {
            authorization: auth.authorizationToken,
        },
    })
    return res
}

export const deleteB2 = async (fileName) => {
    const auth = await authB2()
    const file = await downloadB2(fileName, auth)
    const fileId = file.headers.get('x-bz-file-id')

    if (fileId === null) return {} // already deleted

    const delUrl = auth.apiUrl + B2.apiPath + 'b2_delete_file_version'
    const del = await fetch(delUrl, {
        method: 'POST',
        headers: {
            authorization: auth.authorizationToken,
        },
        body: JSON.stringify({ fileName, fileId })
    }).then((res) => res.json())
    return del
}
'''
'''--- src/batch.js ---
import { 
	accounts,
	getNestedField
} from './utils';

export const handleBatch = async ({
	event, jsonHeaders,
	cache, cacheKey, cacheMaxAge, networkId,
	params,
}) => {

	let { views } = params;

	const allPromises = [];
	views = views.map(({ contract, method, args, batch, sort }) => {
		const promises = [];
		if (batch) {
			const ids = Object.values(args)[0]
			if (Array.isArray(ids)) {
				// assume ids is an arr of the ids you want to query the method with
				const argKey = Object.keys(args)[0]
				// assume batch obj is { from_index, limit, step, flatten }
				const valInts = Object.values(batch).map((v) => parseInt(v));
				valInts[1] = Math.min(valInts[1], ids.length)
				for (let i = valInts[0]; i < valInts[1]; i += valInts[2]) {
					const promise = accounts[networkId].viewFunction(contract, method, {
						[argKey]: ids.slice(i, i + valInts[2]),
					});
					promises.push(promise);
					allPromises.push(promise);
				}
			} else {
				const keys = Object.keys(batch);
				const vals = Object.values(batch);
				// TODO loop big numbers in case offset was huge (use BN.js)
				const valInts = vals.map((v) => parseInt(v));
				for (let i = valInts[0]; i < valInts[1]; i += valInts[2]) {
					const offset = i.toString();
					const promise = accounts[networkId].viewFunction(contract, method, {
						...args,
						...{
							[keys[0]]: offset,
							[keys[1]]: Math.min(valInts[1] - i, valInts[2]),
						}
					});
					promises.push(promise);
					allPromises.push(promise);
				}
			}
		}
		return {
			promises,
			batch,
			sort,
		};
	});

	await Promise.all(allPromises);

	// await all responses
	for (let i = 0; i < views.length; i++) {
		const { promises } = views[i];
		const responses = [];
		for (let j = 0; j < promises.length; j++) {
			responses.push(await promises[j]);
		}
		delete views[i].promises;
		views[i].responses = responses;
	}
    
	// flatten and sort
	views = views.map(({ responses, batch, sort }) => {
		const { flatten } = batch;
    
		let result = responses;
		if (Array.isArray(flatten)) {
			result = responses.reduce((a, c) => a.concat(c), flatten);
    
			if (sort) {
				const { path, how = 'desc', parse = 'int' } = sort;
				result.forEach((r) => r.__sortIndex = getNestedField(r, path, parse));
				if (how === 'desc') {
					result.sort((b, a) => a.__sortIndex - b.__sortIndex);
				} else {
					result.sort((a, b) => a.__sortIndex - b.__sortIndex);
				}
			}
    
		} else {
			// TODO flatten {}
			// result = result.reduce((a, c) => Object.assign(a, c), flatten)
		}
    
		return result;
	});
    
	const response = new Response(JSON.stringify(views), {
		headers: Object.assign(jsonHeaders, {
			'cache-control': 's-maxage=' + cacheMaxAge
		}),
	});
	event.waitUntil(cache.put(cacheKey, response.clone()));
	response.headers.append("cached", "false");
	return response;
};

'''
'''--- src/cache.js ---
const sha256 = async (message) => {
	const msgBuffer = new TextEncoder().encode(message);
	const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
	const hashArray = Array.from(new Uint8Array(hashBuffer));
	const hashHex = hashArray.map(b => ("00" + b.toString(16)).slice(-2)).join("");
	return hashHex;
};

export const checkCache = async ({ request, params, url, corsHeaders, cacheMaxAge }) => {
	let { method } = request;

	const cache = caches.default;
	const body = method === 'POST' && params.type !== 'upload' && await request.clone().text();
	const hash = await sha256(url.toString() + body);
	const cacheUrl = new URL(url.origin);
	cacheUrl.pathname = '/c/' + hash;
	const cacheKey = cacheUrl.toString();

	if (cacheMaxAge === '0') {
		return {cache, cacheKey, cachedResponse: false };
	}

	let cachedResponse = await cache.match(cacheKey);

	if (!params.skipcache && cachedResponse) {
		cachedResponse = new Response(cachedResponse.body, {
			headers: Object.assign(corsHeaders, cachedResponse.headers)
		});
		cachedResponse.headers.append('cached', 'true');
		return { cache, cachedResponse, cacheKey };
	}
    
	return {cache, cacheKey, cachedResponse: false };
};
'''
'''--- src/cors.js ---
// We support the GET, POST, HEAD, and OPTIONS methods from any origin,
// and allow any header on requests. These headers must be present
// on all responses to all CORS preflight requests. In practice, this means
// all responses to OPTIONS requests.
export const corsHeaders = {
	"Access-Control-Allow-Origin": "*",
	"Access-Control-Allow-Methods": "GET,HEAD,POST,OPTIONS",
	"Access-Control-Max-Age": "86400",
};

export const jsonHeaders = Object.assign({
	'content-type': 'application/json',
}, corsHeaders);

export function handleOptions(request) {
	// Make sure the necessary headers are present
	// for this to be a valid pre-flight request
	let headers = request.headers;
	if (
		headers.get("Origin") !== null &&
        headers.get("Access-Control-Request-Method") !== null &&
        headers.get("Access-Control-Request-Headers") !== null
	) {
		// Handle CORS pre-flight request.
		// If you want to check or reject the requested method + headers
		// you can do that here.
		let respHeaders = {
			...corsHeaders,
			// Allow all future content Request headers to go back to browser
			// such as Authorization (Bearer) or X-Client-Name-Version
			"Access-Control-Allow-Headers": request.headers.get("Access-Control-Request-Headers"),
		};

		return new Response(null, {
			headers: respHeaders,
		});
	}
	else {
		// Handle standard OPTIONS request.
		// If you want to allow other HTTP Methods, you can do that here.
		return new Response(null, {
			headers: {
				Allow: "GET, HEAD, POST, OPTIONS",
			},
		});
	}
}

'''
'''--- src/image.js ---
import { 
	account,
	getNestedField
} from './utils';

export const handleImage = async ({
	event, params, corsHeaders
}) => {

	const paramsObj = {};
	for (let [k, v] of params.entries()) {
		paramsObj[k] = v;
	}

	console.log('paramsObj', paramsObj);
	const { contract, method, args, path } = paramsObj;

	// rpc to get data
	const rpcResponse = await account.viewFunction(contract, method, JSON.parse(args));
	// get image url nested in token data
	const url = getNestedField(rpcResponse, path);
	console.log('url', url);

	// not GA yet

	// const imageRequest = new Request(url, {
	//     headers: corsHeaders,
	// })
	// const imageOptions = {
	//     cf: {
	//         image: {
	//             width, height,
	//             fit: 'cover', gravity: 'auto',
	//             format: 'webp', anim: false,
	//         }
	//     },
	// }
	// console.log('imageOptions', imageOptions)

	// // ref https://developers.cloudflare.com/images/resizing-with-workers
	// const response = await fetch(imageRequest, imageOptions)

	const response = await fetch(url, {
		headers: corsHeaders,
	});

	console.log('response', response);

	if (response.ok) {
		return response;
	} else {
		console.log('wut');
		return response;
	}
};

'''
'''--- src/path.js ---

import { decode } from '@msgpack/msgpack';
import { toByteArray } from 'base64-js';

export const pathToArgs = (pathname) => {
	const path = pathname.split('/');

	// console.log('\n\n\npath\n\n\n', path, '\n\n\n')

	// upload or share url path
	if (path[1] === 'v1' && (path[2] === 'upload' || path[2] === 'share')) {
		let args = path[3];
		try {
			args = JSON.parse(decodeURIComponent(args));
		} catch (e) {
			throw 'unable to parse args /v1/' + path[2] + '/[args]';
		}
		return { type: path[2], ...args };
	}

	// redirect path (url args encoded)
	if (path[1] === 'v1' && path[2] === 'r') {
		let decoded = path[3];
		try {
			decoded = decode(toByteArray(decoded));
		} catch (e) {
			throw 'unable to parse args /v1/upload/[args]';
		}
		return { type: 'redirect', ...decoded };
	}

	// encoded path
	if (path[1] === 'v1' && path[2] === 'e') {
		let decoded = path[3];
		try {
			decoded = decode(toByteArray(decoded));
		} catch (e) {
			throw 'unable to decode url';
		}
		return { type: 'view', ...decoded };
	}

	// batch path
	if (path[1] === 'v1' && path[2] === 'batch') {
		let views = path[3];
		try {
			views = JSON.parse(decodeURIComponent(views));
		} catch (e) {
			throw 'unable to parse batch args /v1/batch/[args]';
		}
		return { type: 'batch', views };
	}

	// contract path
	if (path[1] !== 'v1' || path[2] !== 'contract') {
		throw 'supports /v1/contract/[contractName]/[methodName]/[args]/[actions]';
	}
	const contract = path[3];
	if (!contract) throw 'missing /v1/contract/[contractName]';
	const method = path[4];
	if (!method) throw 'missing /v1/contract/[contractName]/[methodName]';

	let args = path[5] || {};
	if (!!args.length) {
		try {
			args = JSON.parse(decodeURIComponent(args));
		} catch (e) {
			throw 'unable to parse args /v1/contract/[contractName]/[methodName]/[args]: ' + args;
		}
	}

	let actions = path[6] || {};
	if (!!actions.length) {
		try {
			actions = JSON.parse(decodeURIComponent(actions));
		} catch (e) {
			throw 'unable to parse actions /v1/contract/[contractName]/[methodName]/[args]/[actions]';
		}
	}

	return {
		type: 'view', contract, method, args, actions
	};
};
'''
'''--- src/redirect.js ---
const FILE_HOST = 'https://files.nearapi.org/file/nearapi/'

export const handleRedirect = async ({
    params, userAgent, corsHeaders, cacheMaxAge,
	event, cache, cacheKey
}) => {
    const { redirect, fn, title, description } = params
    
	// not bot, redirect to url in params of link or direct to image
	if (!/facebookexternalhit|Slackbot|WhatsApp|Snapchat|Applebot|Discordbot|Twitterbot|LinkedInBot|TelegramBot/gi.test(userAgent)) {
        return Response.redirect(decodeURIComponent(redirect), 301);
	}

    // bot response
    const map = {
        'image': FILE_HOST + fn,
    }
    if (title.length) map.title = title
    if (description.length) map.description = description
    const response = new Response(botTemplate(map), {
        headers: Object.assign(corsHeaders, {
            'content-type': 'text/html',
            'cache-control': 's-maxage=' + cacheMaxAge,
        }),
    });

	event.waitUntil(cache.put(cacheKey, response.clone()));
	response.headers.append('cached', 'false');

	return response;
};

const botTemplate = (map) => {
	const src = map['image'];
    return `
<!doctype html>
<html lang="en">
<head>
${
    Object.entries(map)
        .map(([k, v]) => `<meta property="og:${k}" content="${v}" />`)
        .join('\n\t')
}
${
    Object.entries(map)
        .map(([k, v]) => `<meta property="twitter:${k}" content="${v}" />`)
        .join('\n\t')
}
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@nearprotocol"></meta>
<meta name="twitter:image:alt" content="Image Link from NEAR Protocol App"></meta>
</head>
<body>
${ src ? `<img src="${src}" />` : '' }
</body>
</html>
`;
};
'''
'''--- src/upload.js ---

import { uploadB2 } from './b2'
import { encode } from '@msgpack/msgpack';
import { fromByteArray } from 'base64-js';
import {
    nftOwner,
} from './utils';

const DELIMETER = '@'

export const handleUpload = async ({
   url, event, request, networkId, signature, params, jsonHeaders
}) => {
    const {
        nft,
        nft: { contractId, tokenId },
        redirect = FILE_HOST + fn,
        title = '',
        description = '',
    } = params

    nftOwner(networkId, signature, nft)

    const fn = encodeURIComponent(contractId + DELIMETER + tokenId + '.png')
    const body = await request.arrayBuffer()
    const b2upload = uploadB2({
        event,
        fn,
        body,
        bytes: body.byteLength
    })
	event.waitUntil(b2upload);
	const base64 = fromByteArray(encode({ redirect, fn, title, description }));
    // const encodedUrl = 'http://127.0.0.1:8787/v1/r/' + base64;
    const encodedUrl = url.origin + '/v1/r/' + base64;
    return new Response(JSON.stringify({ encodedUrl, fn }), { headers: jsonHeaders });
};

export const handleShare = async ({
    url, params, jsonHeaders
 }) => {
    const {
        nft: { contractId, tokenId },
        redirect,
        title = '',
        description = ''
    } = params
    const fn = encodeURIComponent(contractId + DELIMETER + tokenId + '.png')
	const base64 = fromByteArray(encode({ redirect, fn, title, description }));
    // const encodedUrl = 'http://127.0.0.1:8787/v1/r/' + base64;
    const encodedUrl = url.origin + '/v1/r/' + base64;
    return new Response(JSON.stringify({ encodedUrl, fn }), { headers: jsonHeaders });
};
'''
'''--- src/utils.js ---
import {
	Near, Account, keyStores, utils
} from 'near-api-js';
const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');

const { format: { parseNearAmount } } = utils;
const n2f = (amount) => parseFloat(parseNearAmount(amount, 8));

export const accounts = {};
export const networks = {};
const nearTestnet = new Near({
	networkId: 'testnet',
	nodeUrl: 'https://rpc.testnet.near.org',
	deps: {
		keyStore: new keyStores.InMemoryKeyStore()
	},
});
networks.testnet = nearTestnet
accounts.testnet = new Account(nearTestnet.connection, 'testnet');

const nearMainnet = new Near({
	networkId: 'mainnet',
	nodeUrl: 'https://rpc.mainnet.near.org',
	deps: {
		keyStore: new keyStores.InMemoryKeyStore()
	},
});
networks.mainnet = nearMainnet
accounts.mainnet = new Account(nearMainnet.connection, 'near');

/// signature verification

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

export const verifySignature = async (networkId, data) => {
	const near = networks[networkId];

	const { accountId, blockNumber, blockNumberSignature } = data
	if (!validBlock(blockNumber)) {
		console.error('Invalid block')
		return false
	}
	const account = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(blockNumber).digest();
		let accessKeys = await account.getAccessKeys();
		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(blockNumberSignature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

export const isOwner = async (networkId, signature) => {
    if (!signature.accountId) {
        throw 'method requires signature from account';
    }
    if (!await verifySignature(networkId, signature)) {
        throw 'invalid signature';
    }
}

export const nftOwner = async (networkId, signature, nft) => {
    isOwner(networkId, signature)
    
    const { contractId, tokenId } = nft
    if (!contractId || !tokenId) {
        throw 'method requires near-nft header with { contractId, tokenId }';
    }
    const account = accounts[networkId];
    const token = await account.viewFunction(contractId, 'nft_token', {
        token_id: tokenId
    })
    if (token.owner_id !== signature.accountId) {
        throw 'method requires signature.accountId === token.owner_id';
    }
}

/// JS
export const getNestedField = (obj, field, parse) => {
	const path = field.split('.');
	try {
		for (let i = 0; i < path.length; i++) {
			obj = obj[path[i]];
		}
		if (parse === 'int') {
			return !!obj ? parseInt(obj) : 0;
		}
		if (parse === 'bn') {
			return !!obj ? n2f(obj) : n2f('0');
		}
		return obj;
	} catch (e) { }
	// error finding field
	if (parse === 'int') {
		return 0;
	}
	if (parse === 'bn') {
		return n2f('0');
	}
	return obj;
};

// CFW

export const getParamsObj = (params) => {
	const paramsObj = {};
	for (let [k, v] of params.entries()) {
		paramsObj[k] = v;
	}
	return paramsObj;
};
'''
'''--- src/view.js ---
import { 
	accounts,
	getNestedField,
} from './utils';

import { encode } from '@msgpack/msgpack';
import { fromByteArray } from 'base64-js';

export const handleView = async ({
	event, url, params, corsHeaders, jsonHeaders, userAgent,
	cache, cacheKey, cacheMaxAge, networkId
}) => {
	const { contract, method, args, actions } = params;
	const { field, botMap, redirect, encodeUrl } = actions;

	// return encoded url (or redirect to it)
	if (encodeUrl) {
		const base64 = fromByteArray(encode({ contract, method, args, actions:{
			field, botMap, redirect
		}}));
		const encodedUrl = url.origin + '/v1/e/' + base64;
		return new Response(JSON.stringify({ encodedUrl }), { headers: jsonHeaders });
	}

	// not a bot
	if (redirect && !/facebookexternalhit|Slackbot|WhatsApp|Snapchat|Applebot|Discordbot|Twitterbot|LinkedInBot|TelegramBot/gi.test(userAgent)) {
		return Response.redirect(decodeURIComponent(redirect), 301);
	}

	// get raw rpc response
	let rpcResponse = await accounts[networkId].viewFunction(contract, method, args);

	// get specified field
	if (field) {
		rpcResponse = getNestedField(rpcResponse, field);
		const path = field.split('.');
		rpcResponse = {
			[path[path.length-1]]: rpcResponse
		};
	}
    
	let response;
	if (botMap) {
		// TODO how to handle the botResponse, further details in nested action
		response = new Response(botTemplate(botMap, rpcResponse), {
			headers: Object.assign(corsHeaders, {
				'content-type': 'text/html',
				'cache-control': 's-maxage=' + cacheMaxAge,
			}),
		});
	} else {
		response = new Response(JSON.stringify(rpcResponse), { headers: jsonHeaders });
	}
    
	event.waitUntil(cache.put(cacheKey, response.clone()));
	response.headers.append('cached', 'false');

	return response;
};

const botTemplate = (botMap, rpcResponse) => {
	const botMapImage = botMap['og:image'];
	const src = typeof botMapImage === 'string' ? botMapImage : getNestedField(rpcResponse, botMapImage.field);

	return `
<!doctype html>
<html lang="en">
<head>
${
	Object.entries(botMap)
		.map(([k, v]) => `<meta property="${k}" content="${
			typeof v === 'string' ? v : getNestedField(rpcResponse, v.field)
		}" />`)
		.join('\n\t')
}
<meta property="og:description" content="Your friend sent you a NEAR Link" />
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://near.org"></meta>
<meta property="twitter:image:alt" content="NEAR Link"></meta>
</head>
<body>
${ src ? `<img src="${src}" />` : '' }
</body>
</html>
`;
};
'''
'''--- test/api.test.js ---
const assert = require('assert');
const fetch = require("node-fetch");
const { account, getSignature } = require("./near-utils");

const contractId = 'dev-1623990723679-78605620599599'
const tokenId = 'HipHopHead.10.143.11151512:1'
// consts
const domain = 'http://127.0.0.1:8787';
// const domain = 'https://helper.nearapi.org/v1/contract/'
const domainAndPath = domain + '/v1/contract/';
const testNFTPath = domainAndPath + contractId + '/nft_token/';
const batchPath = domain + '/v1/batch/';
const uploadPath = domain + '/v1/upload/';
const sharePath = domain + '/v1/share/';

/** 
 * Batch near-api-js RPC calls.
 * 
 * Optionally flatten and sort arrays of objects.
 * 
 * ## ðŸš¨ Warning this is WIP ðŸš¨ 
 * - Not officially supported (yet)
 * - Potential syntax changes
 * - For now route does nothing (v1/testnet/view only example)
 * 
 * ## Notes
 * I am aware snake_case and JSON in REST is ugly. However, not willing to convert all method names and args from what you would normally use with near-api-js. e.g. maintain consistency between these API calls and RPC calls as best I can.
 * 
 * ## Syntax
 * ```bash
 * # GET (note with http you need to escape the JSON with single quotes first)
 * http https://helper.nearapi.org/v1/contract/dev-1618440176640-7650905/nft_token/'{"token_id":"token-1619265007329"}'
 * ```
 * 
 * # Example calls from client side:
 * ```js
 * // consts
 * const domain = 'http://127.0.0.1:8787'; // wrangler dev local testing
 * // const domain = 'https://helper.nearapi.org/v1/contract/' // testnet helper domain
 * const domainAndPath = domain + '/v1/contract/';
 * const testNFTPath = domainAndPath + 'dev-1618440176640-7650905/nft_token/';
 * const batchPath = domain + '/v1/batch/';
```
 */
describe('NEAR API Helper', function () {
	this.timeout(10000);

	/** 
     * Using backblaze as image store (S3 style service) and then caching that image for link previews
     */
	it('should upload an image if account owns NFT', async function() {
		// account is NFT owner in contractId and owns the nft in tokenId
		const signature = await getSignature(account)
		const { contractId, tokenId } = account
		const nft = { contractId, tokenId }
		
		const url = uploadPath + JSON.stringify({
			nft,
			redirect: "https%3A%2F%2Fmobile.twitter.com%2Fhome"
		});
		console.log('\n URL:\n', url, '\n');

		const response = await fetch(url, {
			headers: {
				'near-signature': JSON.stringify(signature),
			},
			method: 'POST',
			body: 'test'
		}).then((res) => res.json());

		// console.log(response)

		assert.strictEqual(!!response.encodedUrl, true);
		
		const response2 = await fetch(response.encodedUrl, {
			headers: {
				'user-agent': 'facebookexternalhit'
			}
		}).then((res) => res.text());

		// console.log(response2)

		assert.strictEqual(response2.indexOf(response.fn) > -1, true);
	});

	/** 
     * Get the share link only using fn -> uploaded image url and bot response
     */
	 it('should get a share link and check the bot response', async function() {
		// account is NFT owner in contractId and owns the nft in tokenId
		const { contractId, tokenId } = account
		const nft = { contractId, tokenId }
		
		const title = 'hello world!'
		const url = sharePath + JSON.stringify({
			title,
			description: 'this is a test',
			nft,
			redirect: "https%3A%2F%2Fmobile.twitter.com%2Fhome"
		});
		console.log('\n URL:\n', url, '\n');

		const response = await fetch(url).then((res) => res.json());

		// console.log(response)

		assert.strictEqual(!!response.encodedUrl, true);
		
		const response2 = await fetch(response.encodedUrl, {
			headers: {
				'user-agent': 'facebookexternalhit'
			}
		}).then((res) => res.text());

		// console.log(response2)

		assert.strictEqual(response2.indexOf(response.fn) > -1, true);
		assert.strictEqual(response2.indexOf(title) > -1, true);
	});

	/** 
     * Returns a raw response for a given view near-api-js call (viewFunction)
     */
	it('should have the whole rpc response', async function() {  
		const args = JSON.stringify({
			token_id: tokenId
		});
		const url = testNFTPath + args;
		console.log('\n URL:\n', url, '\n');
		const response = await fetch(url).then((res) => res.json());

		assert.strictEqual(Object.keys(response).length > 1, true);
	});

	/** 
     * Use this to drill into JSON responses (e.g. get metadata for a token)
     */
	it('should return just a field with the last field name as key', async function() {  
		const args = JSON.stringify({
			token_id: tokenId
		});
		const actions = JSON.stringify({
			field: 'metadata.media'
		});
		const url = testNFTPath + args + '/' + actions;
		console.log('\n URL:\n', url, '\n');
		const response = await fetch(url).then((res) => res.json());

		assert.strictEqual(Object.keys(response).length, 1);
	});

	/** 
     * Creates a bot response for when you share your links (link previews with images etc...)
     */
	it('should have a bot response with customized fields', async function() {  
		const args = JSON.stringify({
			token_id: tokenId
		});
		const actions = JSON.stringify({
			botMap: {
				'og:title': 'MEOW',
				'og:image': { field: 'metadata.media' }
			}
		});
		const url = testNFTPath + args + '/' + actions;
		console.log('\n URL:\n', url, '\n');
		const response = await fetch(url, {
			headers: {
				'user-agent': 'facebookexternalhit'
			}
		}).then((res) => res.text());

		console.log(response);

		assert.strictEqual(response.indexOf('MEOW') > -1, true);
	});

	/** 
     * Turn your call into an encoded URL that you can use for sharing (prettier than JSON in REST)
     * 
     * botMap for bots -> link preview
     * redirect for users -> NFT item
     */
	it('should return an encoded url', async function() {
		const args = JSON.stringify({
			token_id: tokenId
		});
		const actions = JSON.stringify({
			botMap: {
				'og:title': 'MEOW',
				'og:image': { field: 'metadata.media' }
			},
			redirect: 'https%3A%2F%2Fnear-apps.github.io%2Fnft-market%2F',
			encodeUrl: true,
		});
		const url = testNFTPath + args + '/' + actions;
		console.log('\n URL:\n', url, '\n');
		const response = await fetch(url).then((res) => res.json());
		assert.strictEqual(Object.keys(response)[0], 'encodedUrl');

		// redirect will return html from market which should not contain the string MEOW
		const encodedUrl = Object.values(response)[0];
		console.log('\n URL:\n', encodedUrl, '\n');
		const response2 = await fetch(encodedUrl).then((res) => res.text());
		assert.strictEqual(response2.indexOf('MEOW') === -1, true);
	});

	/** 
     * Use this to get a lot of data at once.
     * 
     * Call different view methods.
     * 
     * Within each call, the first and second arguments of batch must have names matching the contract arguments used for offset and limit.
     * 
     * e.g. if the contract has args like "offset" and "num", you need to use: batch: { offset: '0', num: '100', step: '10' }
     * 
     * This means "start at '0' and keep making RPC calls until '100' increasing by '10' each time." creating a total of 10 RPC calls in the helper, but only 1 call and reponse for the user.
     * 
     * flatten: [] combines results into an array vs. separate RPC results
     * 
     * WIP
     * sort.field: what field on the objects to use for sorting
     * sort.parse: how to treat the field "int": parseInt or "bn": parseFloat(parseNearAmount(val, 8)) // 8 decimal approximation of NEAR
     */
	it('should return a batched response', async function() {

		const batch = [{
			contract: contractId,
			method: 'nft_tokens',
			args: {},
			batch: {
				from_index: '0', // must be name of contract arg (above)
				limit: '200', // must be name of contract arg (above)
				step: '10', // divides contract arg 'limit'
				flatten: [], // how to combine results
			},
			sort: {
				path: 'metadata.issued_at',
			}
		},
		{
			contract: 'market.' + contractId,
			method: 'get_sales_by_nft_contract_id',
			args: {
				nft_contract_id: contractId
			},
			batch: {
				from_index: '0', // must be name of contract arg (above)
				limit: '100', // must be name of contract arg (above)
				step: '10', // divides contract arg 'limit'
				flatten: [], // how to combine results
			},
			sort: {
				path: 'conditions.near',
				parse: 'bn'
			}
		}];

		const url = batchPath + JSON.stringify(batch);
		console.log('\n URL:\n', url, '\n');

		const response = await fetch(url).then((res) => res.json());

		assert.strictEqual(response.length, 2);
		assert.strictEqual(response[0].length > 20, true);
		assert.strictEqual(response[1].length > 0, true);
	});

	/** 
     * Use this to split a call that requires sending an array of ids to a view method.
     * 
     * The array of ids will be automatically split up into separate RPC calls and the results will be flattened back together.
     * 
     * WIP
     * sort.field: what field on the objects to use for sorting
     * sort.parse: how to treat the field "int": parseInt or "bn": parseFloat(parseNearAmount(val, 8)) // 8 decimal approximation of NEAR
     */
	it('should process a batch of input (token_ids) sent via POST', async function() {

		const batch = [{
			contract: contractId,
			method: 'nft_tokens',
			args: {},
			batch: {
				from_index: '0', // must be name of contract arg (above)
				limit: '200', // must be name of contract arg (above)
				step: '10', // divides contract arg 'limit'
				flatten: [], // how to combine results
			},
			sort: {
				path: 'metadata.issued_at',
			}
		}];

		const url = batchPath + JSON.stringify(batch);
		console.log('\n URL:\n', url, '\n');
		const response = await fetch(url).then((res) => res.json());

		const token_ids = response[0].map(({ token_id }) => token_id)

		const batch2 = [{
			contract: contractId,
			method: 'nft_tokens_batch',
			args: {
				token_ids
			},
			batch: {
				from_index: '0',
				limit: '2000',
				step: '50', // divides batch above
				flatten: [],
			},
			sort: {
				path: 'metadata.issued_at',
			}
		}];

		// use POST - token_ids array too large for GET url
		const url2 = batchPath + JSON.stringify({});
		console.log('\n URL:\n', url2, '\n');
		const response2 = await fetch(url2, {
			method: 'POST',
			body: JSON.stringify(batch2)
		}).then((res) => res.json());

		assert.strictEqual(response2.length, 1);
		assert.strictEqual(response2[0].length > 20, true);
	});

	/** 
     * Mainnet Test
     */
	// it('should return a batched response', async function() {
		
	// 	const batch = [{
	// 		contract: 'nft_679bada6b8.near-hackathon.collab-land.near',
	// 		method: 'nft_tokens',
	// 		args: {},
	// 		batch: {
	// 			from_index: '0', // must be name of contract arg (above)
	// 			limit: '1000', // must be name of contract arg (above)
	// 			step: '50', // divides contract arg 'limit'
	// 			flatten: [], // how to combine results
	// 		},
	// 	}];

	// 	const url = batchPath + JSON.stringify(batch);
	// 	console.log('\n URL:\n', url, '\n');

	// 	const response = await fetch(url, {
	// 		headers: {
	// 			'near-network': 'mainnet'
	// 		}
	// 	}).then((res) => res.json());

	// 	assert.strictEqual(response[0].length > 300, true);
	// });
	
});
'''
'''--- test/config.js ---
module.exports = function getConfig() {
	let config = {
		networkId: 'testnet',
		nodeUrl: 'https://rpc.testnet.near.org',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org',
	};
    
	if (process.env.REACT_APP_ENV !== undefined) {
		config = {
			...config,
			GAS: '200000000000000',
			DEFAULT_NEW_ACCOUNT_AMOUNT: '5',
			contractMethods: {
				changeMethods: ['new', 'create', 'purchase'],
				viewMethods: ['get_message'],
			},
		};
	}
    
	if (process.env.REACT_APP_ENV === 'prod') {
		config = {
			...config,
			networkId: 'mainnet',
			nodeUrl: 'https://rpc.mainnet.near.org',
			walletUrl: 'https://wallet.near.org',
			helperUrl: 'https://helper.mainnet.near.org',
		};
	}

	return config;
};

'''
'''--- test/near-utils.js ---

const nearAPI = require('near-api-js');
const getConfig = require('./config');
const { nodeUrl, networkId } = getConfig();
const {
    keyStores: { InMemoryKeyStore },
	Near, Account, KeyPair,
} = nearAPI;

const accountId = 'dev-1622483586098-7037602'
const credentials = {
	"account_id": accountId,
	"public_key":"ed25519:E3tFXaYxHMmPK1uk5EtZSnNGCKkV14d5Ee28UyjWgBZi",
	"private_key":"ed25519:5q4cW6QLqU1t257yzipYjMT5UvECdFrpzG1sgPHEiRqNY6rnsG1dPGMPzvdeQyccjTzJ4dvJWUk8hn7NSY2qkHag"
}
const keyStore = new InMemoryKeyStore()
keyStore.setKey(networkId, accountId, KeyPair.fromString(credentials.private_key));
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const account = new Account(connection, accountId);
account.contractId = accountId
account.tokenId = 'regl-1-1622483600037:0'

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { accountId, blockNumber, blockNumberSignature };
};

module.exports = {
	near,
	keyStore,
	connection,
	account,
    getSignature,
};
'''
'''--- webpack.config.js ---
module.exports = {
  target: "webworker",
  entry: "./index.js",
  mode: "development",
  devtool: "cheap-module-source-map", // avoid "eval": Workers environment doesnâ€™t allow it
}
'''
'''--- wrangler.toml ---
name = "api-helper"
type = "webpack"

account_id = "e933298eadc1cb3ced383f0d701f8ff8"
workers_dev = true
route = ""
zone_id = "near.workers.dev"
webpack_config = "webpack.config.js"

'''