*GitHub Repository "farhantariq12b/nft-marketplace"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# NFT Market Reference Implementation

## 🚨🚨🚨 Unaudited Contracts 🚨🚨🚨

A PoC backbone for NFT Marketplaces on NEAR Protocol.

## TODO / DONE:
- [x] basic purchase of NFT with FT
- [x] demo pay out royalties (FTs and NEAR)
- [x] test and determine standards for markets (best practice?) to buy/sell NFTs (finish standard) with FTs (already standard)
- [x] demo some basic auction types, secondary markets and 
- [x] frontend example
- [ ] connect with bridged tokens e.g. buy and sell with wETH/nDAI (or whatever we call these)

## Notes:

High level diagram of NFT sale on Market using Fungible Token:
![image](https://user-images.githubusercontent.com/321340/113903355-bea71e80-9785-11eb-8ab3-9c2f0d23466f.png)

Differences from `nft-simple` NFT standard reference implementation:
- anyone can mint an NFT
- Optional token_type
- capped supply by token_type
- lock transfers by token_token
- enumerable.rs

## Working

**Frontend App Demo: `/test/app.test.js/`**
- install, deploy, test `yarn && yarn test:deploy`
- run app - `yarn start`

**App Tests: `/test/app.test.js/`**
- install, deploy, test `yarn && yarn test:deploy`
- if you update contracts - `yarn test:deploy`
- if you update tests only - `yarn test`

## 🚨🚨🚨 End of Warning 🚨🚨🚨

# NFT Specific Notes

Associated Video Demos (most recent at top)

[![NEAR Protocol - Demo NFT Marketplace Walkthough](https://img.youtube.com/vi/AevmMAtkIr4/0.jpg)](https://www.youtube.com/watch?v=AevmMAtkIr4)

[![Live App Review 19 - NFT Marketplace with Fungible Token Transfers and Royalty Distribution](https://img.youtube.com/vi/sGTC3rs8OJQ/0.jpg)](https://youtu.be/sGTC3rs8OJQ)

Some additional ideas around user onboarding:

[![NEAR Protocol - NFT Launcher & Easy User Onboarding Demo - Hackathon Starter Kit!](https://img.youtube.com/vi/59Lzt1PFF6I/0.jpg)](https://www.youtube.com/watch?v=59Lzt1PFF6I)

# Detailed Installation / Quickstart

#### If you don't have Rust
Install Rust https://rustup.rs/
#### If you have never used near-cli
1. Install near-cli: `npm i -g near-cli`
2. Create testnet account: [Wallet](https://wallet.testnet.near.org)
3. Login: `near login`
#### Installing and Running Tests for this Example
1. Install everything: `yarn && (cd server && yarn)`
2. Deploy the contract and run the app tests: `yarn test:deploy`
3. (WIP) Start server and run server tests: `cd server && yarn start` then in another terminal from the root `yarn test:server`

#### Notes
- If you ONLY change the JS tests use `yarn test`.
- If you change the contract run `yarn test:deploy` again.
- If you run out of funds in the dev account run `yarn test:deploy` again.
- If you change the dev account (yarn test:deploy) the server should restart automatically, but you may need to restart the app and sign out/in again with NEAR Wallet.
### Moar Context

There's 3 main areas to explore:
- frontend app - shows how to create guest accounts that are added to the app contract via the nodejs server. Guests can mind NFTs, put them up for sale and earn NEAR tokens. When the guest has NEAR they can upgrade their account to a full account.
- app.test.js (demos frontend only tests)

### Owner Account, Token Account, etc...

The tests are set up to auto generate the dev account each time you run `test:deploy` **e.g. you will get a new NFT contract address each time you run a test**.

This is just for testing. You can obviously deploy a token to a fixed address on testnet / mainnet, it's an easy config update.

#### Guests Account (key and tx gas sponsorship)
When you run app / server tests. There's a contract deployed and a special account created `guests.OWNER_ACCOUNT_ID` to manage the sponsored users (the ones you will pay for gas fees while onboarding). This special "guests" account is different from the test guest account `bob.TOKEN_ID.OWNER_ACCOUNT_ID`. It is an account, different from the owner or token accounts, that manages the guests keys.

#### Guest Accounts
The guest users can `claim_drop, ft_transfer_guest` and receive tokens from other users, e.g. in the server tests the owner transfers tokens to the guest account via API call and using client side code.

Then, following the server tests, the guest transfers tokens to alice (who is a real NEAR account e.g. she pays her own gas).

Finally, the guest upgrades themselves to a real NEAR account, something demoed in the video.

It's a lot to digest but if you focus on the `/test/app.test.js` you will start to see the patterns.
# Background

One of the issues with onboarding new users to crypto is that they need to have crypto to do anything e.g. mint an NFT. A creator, artist or community might want to drop a bunch of free minting options to their fans for them to mint user generated content, but the audience has (1) no crypto to pay for fees (2) no wallet (3) no concept of crypto or blockchain; prior to the drop. 

So let's solve these issues by allowing users to generate content the traditional Web2 way!

We do a demo of creating a "guest" named account for an app where the gas fees are sponsored by a special app account called "guests.APP_NAME.near". The guest account doesn't exist (sometimes called a virtual or contract account) until the user creates and sells and NFT that generates some NEAR tokens and then they can upgrade to a real account. Until then their name is reserved because only the app is able to create "USERNAME.APP_NAME.near".

This has many advantages for user onboarding, where users can use the app immediately and later can be upgraded to a full account. The users also don't have to move any assets - namely the fungible tokens they earned as a guest user. 

## Installation

Beyond having npm and node (latest versions), you should have Rust installed. I recommend nightly because living on the edge is fun.

https://rustup.rs/

Also recommend installing near-cli globally

`npm i -g near-cli`

Everything else can be installed via:
`yarn`
`cd server && yarn`

## NEAR Config

There is only one config.js file found in `src/config.js`, this is also used for running tests.

Using `src/config.js` you can set up your different environments. Use `REACT_APP_ENV` to switch environments e.g. in `package.json` script `deploy`.

## Running Tests

You can run unit tests in the Rust contracts themselves, but it may be more useful to JS tests against testnet itself.

Note: to run the app and server tests make sure you install and start the server.
- cd server
- yarn && yarn start

Commands:
- `test` will simply run app tests against the contract already deployed. You can mess around with `app.test.js` and try different frontend stuff
- `test:deploy` - will deploy a new dev account (`/neardev`) and deploy a new contract to this account, then run `test`
- `test:server` - will test the server, make sure you start it (see "Note" above)
- `test:unit` - runs the rust unit tests

If you've changed your contract or your dev account has run out of funds use `test:deploy`, if you're updating your JS tests only then use `test`.

## Test Utils

There are helpers in `test/test-utils.js` that take care of:
1. creating a near connection and establishing a keystore for the dev account
2. creating test accounts each time a test is run
3. establishing a contract instance so you can call methods

You can change the default funding amount for test accounts in `src/config.js`

## Using the NEAR Config in your app

In `src/state/near.js` you will see that `src/config.js` is loaded as a function. This is to satisfy the jest/node test runner.

You can destructure any properies of the config easily in any module you import it in like this:

```
// example file app.js

import getConfig from '../config';
export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();
```
Note the export const in the destructuring?

Now you can import these like so:
```
//example file Component.js
import { GAS } from '../app.js'
...
await contract.withdraw({ amount: parseNearAmount('1') }, GAS)
...
```

# React 17, Parcel with useContext and useReducer
- Bundled with Parcel 2.0 (@next) && eslint
- *Minimal all-in-one state management with async/await support*

## Getting Started: State Store & useContext

>The following steps describe how to use `src/utils/state` to create and use your own `store` and `StateProvider`.

1. Create a file e.g. `/state/app.js` and add the following code
```js
import { State } from '../utils/state';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { store, Provider } = State(initialState);
```
2. Now in your `index.js` wrap your `App` component with the `StateProvider`
```js
import { Provider } from './state/app';

ReactDOM.render(
    <Provider>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
3. Finally in `App.js` you can `useContext(store)`
```js
const { state, dispatch, update } = useContext(store);
```

## Usage in Components
### Print out state values
```js
<p>Hello {state.foo && state.foo.bar.hello}</p>
```
### Update state directly in component functions
```js
const handleClick = () => {
    update('clicked', !state.clicked);
};
```
### Dispatch a state update function (action listener)
```js
const onMount = () => {
    dispatch(onAppMount('world'));
};
useEffect(onMount, []);
```
## Dispatched Functions with context (update, getState, dispatch)

When a function is called using dispatch, it expects arguments passed in to the outer function and the inner function returned to be async with the following json args: `{ update, getState, dispatch }`

Example of a call:
```js
dispatch(onAppMount('world'));
```

All dispatched methods **and** update calls are async and can be awaited. It also doesn't matter what file/module the functions are in, since the json args provide all the context needed for updates to state.

For example:
```js
import { helloWorld } from './hello';

export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};
```
## Prefixing store and Provider

The default names the `State` factory method returns are `store` and `Provider`. However, if you want multiple stores and provider contexts you can pass an additional `prefix` argument to disambiguate.

```js
export const { appStore, AppProvider } = State(initialState, 'app');
```

## Performance and memo

The updating of a single store, even several levels down, is quite quick. If you're worried about components re-rendering, use `memo`:
```js
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered message');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
```
Higher up the component hierarchy you might have:
```js
const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    ...
	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button onClick={handleClick}>Click Me</button>
		</div>
	);
};
```
When the button is clicked, the component HelloMessage will not re-render, it's value has been memoized (cached). Using this method you can easily prevent performance intensive state updates in further down components until they are neccessary.

Reference:
- https://reactjs.org/docs/context.html
- https://dmitripavlutin.com/use-react-memo-wisely/

'''
'''--- contracts/ft/Cargo.toml ---
[package]
name = "ft_for_launcher"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>", "Vincent <vincent@decentralisedengineeringltd.co.uk>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

[profile.release]
codegen-units=24
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contracts/ft/README.md ---
Minimal NEP141 + Metadata Token Launcher

TBD

Fork of: https://github.com/mikedotexe/nep-141-examples (basic)
'''
'''--- contracts/ft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/ft.wasm

'''
'''--- contracts/ft/src/fungible_token_core.rs ---
use crate::*;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = 5_000_000_000_000;
const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

const NO_DEPOSIT: Balance = 0;

pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128;
}

#[ext_contract(ext_fungible_token_receiver)]
trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> Promise;
}

#[ext_contract(ext_self)]
trait FungibleTokenResolverExt {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        let sender_id = env::predecessor_account_id();
        assert_one_yocto();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
        // Initiating receiver's call and the callback
        ext_fungible_token_receiver::ft_on_transfer(
            sender_id.clone(),
            amount.into(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::ft_resolve_transfer(
            sender_id,
            receiver_id.into(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
    }

    fn ft_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.accounts.get(account_id.as_ref()).unwrap_or(0).into()
    }
}

#[near_bindgen]
impl FungibleTokenResolver for Contract {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        assert_self();
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount, // TODO why
        };

        if unused_amount > 0 {
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                self.accounts
                    .insert(&receiver_id, &(receiver_balance - refund_amount));

                if let Some(sender_balance) = self.accounts.get(&sender_id) {
                    self.accounts
                        .insert(&sender_id, &(sender_balance + refund_amount));
                    env::log(
                        format!(
                            "Refund {} from {} to {}",
                            refund_amount, receiver_id, sender_id
                        )
                        .as_bytes(),
                    );
                    return (amount - refund_amount).into();
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.total_supply -= refund_amount;
                    env::log(b"The account of the sender was deleted");
                    env::log(format!("Burn {}", refund_amount).as_bytes());
                }
            }
        }
        amount.into() // TODO: i think this should be something else, how many were returned
    }
}

'''
'''--- contracts/ft/src/fungible_token_metadata.rs ---
use super::*;
use near_sdk::serde::Serialize;

#[derive(Serialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub version: String,
    pub name: String,
    pub symbol: String,
    pub reference: String,
    pub reference_hash: [u8; 32],
    pub decimals: u8,
}

pub trait FungibleTokenMetadataProvider {
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.ft_metadata.clone()
    }
}

'''
'''--- contracts/ft/src/internal.rs ---
use crate::*;

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

pub(crate) fn assert_self() {
    assert_eq!(
        env::predecessor_account_id(),
        env::current_account_id(),
        "Method is private"
    );
}

impl Contract {
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self
            .accounts
            .get(&account_id)
            .expect("The account is not registered");
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(&account_id, &new_balance);
        } else {
            env::panic(b"Balance overflow");
        }
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self
            .accounts
            .get(&account_id)
            .expect("The account is not registered");
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(&account_id, &new_balance);
        } else {
            env::panic(b"The account doesn't have enough balance");
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        assert_ne!(
            sender_id, receiver_id,
            "Sender and receiver should be different"
        );
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        env::log(format!("Transfer {} from {} to {}", amount, sender_id, receiver_id).as_bytes());
        if let Some(memo) = memo {
            env::log(format!("Memo: {}", memo).as_bytes());
        }
    }
}

'''
'''--- contracts/ft/src/lib.rs ---

/**
* Fungible Token NEP-141 Token contract
*
* The aim of the contract is to provide a basic implementation of the improved function token standard.
*
* lib.rs is the main entry point.
* fungible_token_core.rs implements NEP-146 standard
* storage_manager.rs implements NEP-145 standard for allocating storage per account
* fungible_token_metadata.rs implements NEP-148 standard for providing token-specific metadata.
* internal.rs contains internal methods for fungible token.
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise, StorageUsage};

pub use crate::fungible_token_core::*;
pub use crate::fungible_token_metadata::*;
use crate::internal::*;
pub use crate::storage_manager::*;
use std::num::ParseIntError;
use std::convert::TryInto;

mod fungible_token_core;
mod fungible_token_metadata;
mod internal;
mod storage_manager;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub owner_id: AccountId,

    /// AccountID -> Account balance.
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of the all token.
    pub total_supply: Balance,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,

    pub ft_metadata: FungibleTokenMetadata
}

impl Default for Contract {
    fn default() -> Self {
        env::panic(b"Contract is not initialized");
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId, total_supply: U128, version: String, name: String, symbol: String, reference: String, reference_hash: String, decimals: u8) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let ref_hash_result: Result<Vec<u8>, ParseIntError> = (0..reference_hash.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&reference_hash[i..i + 2], 16))
            .collect();
        let ref_hash_fixed_bytes: [u8; 32] = ref_hash_result.unwrap().as_slice().try_into().unwrap();

        let mut this = Self {
            owner_id: owner_id.clone().into(),
            accounts: LookupMap::new(b"a".to_vec()),
            total_supply: total_supply.into(),
            account_storage_usage: 0,
            ft_metadata: FungibleTokenMetadata {
                version,
                name,
                symbol,
                reference,
                reference_hash: ref_hash_fixed_bytes,
                decimals
            }
        };
        // Determine cost of insertion into LookupMap
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = unsafe { String::from_utf8_unchecked(vec![b'a'; 64]) };
        this.accounts.insert(&tmp_account_id, &0u128);
        this.account_storage_usage = env::storage_usage() - initial_storage_usage;
        this.accounts.remove(&tmp_account_id);
        // Make owner have total supply
        let total_supply_u128: u128 = total_supply.into();
        this.accounts.insert(&owner_id.as_ref(), &total_supply_u128);
        this
    }

    /// Custom Methods

    /// only owner can mint
    pub fn mint(&mut self, amount: U128) {
        assert!(env::predecessor_account_id() == self.owner_id, "must be owner_id");
        self.total_supply += u128::from(amount);
        let mut balance = self.accounts.get(&self.owner_id).expect("owner should have balance");
        balance += u128::from(amount);
        self.accounts.insert(&self.owner_id, &balance);
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod fungible_token_tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use std::convert::TryFrom;

    const ZERO_U128: Balance = 0u128;

    fn alice() -> ValidAccountId {
        ValidAccountId::try_from("alice.near").unwrap()
    }
    fn bob() -> ValidAccountId {
        ValidAccountId::try_from("bob.near").unwrap()
    }
    fn carol() -> ValidAccountId {
        ValidAccountId::try_from("carol.near").unwrap()
    }
    fn dex() -> ValidAccountId {
        ValidAccountId::try_from("dex.near").unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: "mike.near".to_string(),
            signer_account_id: "bob.near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn contract_creation_with_new() {
        testing_env!(get_context(dex().as_ref().to_string()));

        let contract = Contract::new(
            dex(),
            U128::from(1_000_000_000_000_000),
            String::from("0.1.0"),
            String::from("NEAR Test Token"),
            String::from("TEST"),
            String::from(
                "https://github.com/near/core-contracts/tree/master/w-near-141",
            ),
            "7c879fa7b49901d0ecc6ff5d64d7f673da5e4a5eb52a8d50a214175760d8919a".to_string(),
            24
        );
        assert_eq!(contract.ft_total_supply().0, 1_000_000_000_000_000);
        assert_eq!(contract.ft_balance_of(alice()).0, ZERO_U128);
        assert_eq!(contract.ft_balance_of(bob().into()).0, ZERO_U128);
        assert_eq!(contract.ft_balance_of(carol().into()).0, ZERO_U128);
    }

    #[test]
    #[should_panic(expected = "Contract is not initialized")]
    fn default_fails() {
        testing_env!(get_context(carol().into()));
        let _contract = Contract::default();
    }
}

'''
'''--- contracts/ft/src/storage_manager.rs ---
use super::*;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
pub const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStorageBalance {
    total: U128,
    available: U128,
}

pub trait StorageManager {
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> AccountStorageBalance;

    fn storage_withdraw(&mut self, amount: U128) -> AccountStorageBalance;

    fn storage_minimum_balance(&self) -> U128;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> AccountStorageBalance;
}

#[near_bindgen]
impl StorageManager for Contract {
    #[payable]
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> AccountStorageBalance {
        let amount = env::attached_deposit();
        assert_eq!(
            amount,
            self.storage_minimum_balance().0,
            "Requires attached deposit of the exact storage minimum balance"
        );
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        if self.accounts.insert(&account_id, &0).is_some() {
            env::panic(b"The account is already registered");
        }
        AccountStorageBalance {
            total: amount.into(),
            available: amount.into(),
        }
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: U128) -> AccountStorageBalance {
        assert_one_yocto();
        let amount: Balance = amount.into();
        assert_eq!(
            amount,
            self.storage_minimum_balance().0,
            "The withdrawal amount should be the exact storage minimum balance"
        );
        let account_id = env::predecessor_account_id();
        if let Some(balance) = self.accounts.remove(&account_id) {
            if balance > 0 {
                env::panic(b"The account has positive token balance");
            } else {
                Promise::new(account_id).transfer(amount + 1);
                AccountStorageBalance {
                    total: 0.into(),
                    available: 0.into(),
                }
            }
        } else {
            env::panic(b"The account is not registered");
        }
    }

    fn storage_minimum_balance(&self) -> U128 {
        (Balance::from(self.account_storage_usage) * STORAGE_PRICE_PER_BYTE).into()
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> AccountStorageBalance {
        if let Some(balance) = self.accounts.get(account_id.as_ref()) {
            AccountStorageBalance {
                total: self.storage_minimum_balance(),
                available: if balance > 0 {
                    0.into()
                } else {
                    self.storage_minimum_balance()
                },
            }
        } else {
            AccountStorageBalance {
                total: 0.into(),
                available: 0.into(),
            }
        }
    }
}

'''
'''--- contracts/market-simple/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=3.1.0"

[profile.release]
codegen-units=24
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contracts/market-simple/README.md ---
# TBD

'''
'''--- contracts/market-simple/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/market.wasm

'''
'''--- contracts/market-simple/src/external.rs ---
use crate::*;

/// external contract calls

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        enforce_owner_id: AccountId,
        memo: Option<String>,
        balance: U128,
    );
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>
    );
}
'''
'''--- contracts/market-simple/src/ft_callbacks.rs ---
use crate::*;

/// callbacks from FT Contracts

trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> Promise;
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> Promise {
        let PurchaseArgs {
            nft_contract_id,
            token_id,
        } = near_sdk::serde_json::from_str(&msg).expect("Invalid SaleArgs");
        
        let contract_and_token_id = format!("{}:{}", nft_contract_id, token_id);
        let sale = self.sales.get(&contract_and_token_id).expect("No sale in ft_on_transfer");
        assert_ne!(sale.owner_id, sender_id, "Cannot bid on your own sale.");
        let ft_token_id = env::predecessor_account_id();
        let price = *sale.conditions.get(&ft_token_id).expect("Not for sale in that token type");

        assert_eq!(u128::from(amount), u128::from(price), "Must pay exactly the sale price");

        self.process_purchase(nft_contract_id, token_id, ft_token_id, price, sender_id)
    }
}
'''
'''--- contracts/market-simple/src/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

pub(crate) fn hash_account_id(account_id: &AccountId, modifier: Option<String>) -> CryptoHash {
    let mut hash = CryptoHash::default();
    let mut str = account_id.clone();
    if let Some(modifier) = modifier {
        str.push_str(&modifier);
    }
    hash.copy_from_slice(&env::sha256(str.as_bytes()));
    hash
}

impl Contract {
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Owner's method"
        );
    }

    pub(crate) fn internal_remove_sale(&mut self, nft_contract_id: AccountId, token_id: TokenId) -> Sale {
        let contract_and_token_id = format!("{}:{}", &nft_contract_id, token_id);
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

        let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("No sale");
        by_owner_id.remove(&contract_and_token_id);
        self.by_owner_id.insert(&sale.owner_id, &by_owner_id);

        let mut by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id).expect("No sale");
        by_nft_contract_id.remove(&token_id);
        self.by_nft_contract_id.insert(&nft_contract_id, &by_nft_contract_id);

        sale
    }
}

'''
'''--- contracts/market-simple/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, LookupSet, UnorderedSet, UnorderedMap};
use near_sdk::json_types::{ValidAccountId, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault, Promise,
    PromiseResult,
};
use std::cmp::min;
use std::collections::HashMap;

use crate::internal::*;
use crate::external::*;
use crate::sale::*;

mod internal;
mod external;
mod sale;
mod sale_views;
mod ft_callbacks;
mod nft_callbacks;

near_sdk::setup_alloc!();

// TODO check seller supports storage_deposit at ft_token_id they want to post sale in

const NO_DEPOSIT: Balance = 0;
const STORAGE_AMOUNT: u128 = 100_000_000_000_000_000_000_000;
const MAX_SALES_PER_ACCOUNT: u8 = 20;

pub type TokenId = String;
pub type FungibleTokenId = AccountId;
pub type ContractAndTokenId = String;
pub type Payout = HashMap<AccountId, u128>;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub ft_token_ids: LookupSet<AccountId>,
    pub storage_deposits: LookupSet<AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut this = Self {
            owner_id: owner_id.into(),
            sales: UnorderedMap::new(b"s".to_vec()),
            by_owner_id: LookupMap::new(b"b".to_vec()),
            by_nft_contract_id: LookupMap::new(b"n".to_vec()),
            ft_token_ids: LookupSet::new(b"t".to_vec()),
            storage_deposits: LookupSet::new(b"d".to_vec()),
        };
        // support NEAR by default
        this.ft_token_ids.insert(&"near".to_string());

        this
    }

    /// only owner
    pub fn add_token(&mut self, ft_token_id: ValidAccountId) -> bool {
        self.assert_owner();
        self.ft_token_ids.insert(ft_token_id.as_ref())
    }

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) -> bool {
        let storage_account_id = if let Some(account_id) = account_id {
            account_id
        } else {
            env::predecessor_account_id()
        };
        assert_eq!(self.storage_deposits.contains(&storage_account_id), false, "Already paid for storage");
        assert_eq!(env::attached_deposit(), STORAGE_AMOUNT, "Required attached deposit of {}", STORAGE_AMOUNT);
        self.storage_deposits.insert(&storage_account_id)
    }

    #[payable]
    pub fn storage_withdraw(&mut self) -> bool {
        assert_one_yocto();
        let predecessor = env::predecessor_account_id();
        if self.storage_deposits.remove(&predecessor) {
            Promise::new(predecessor).transfer(STORAGE_AMOUNT);
            true
        } else {
            false
        }
    }

    /// views

    pub fn supports_token(&self, ft_token_id: ValidAccountId) -> bool {
        self.ft_token_ids.contains(ft_token_id.as_ref())
    }

    pub fn storage_amount(&self) -> U128 {
        U128(STORAGE_AMOUNT)
    }
    
    pub fn storage_paid(&self, account_id: ValidAccountId) -> bool {
        self.storage_deposits.contains(account_id.as_ref())
    }
}

'''
'''--- contracts/market-simple/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from NFT Contracts

trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: U64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {

    /// where we add the sale because we know nft owner can only call nft_approve

    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: U64,
        msg: String,
    ) {
        assert!(
            self.storage_deposits.contains(&owner_id),
            "Must call storage_deposit with {} to sell on this market.",
            STORAGE_AMOUNT
        );

        let nft_contract_id = env::predecessor_account_id();
        let sale_args: SaleArgs = near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        let SaleArgs {
            sale_conditions
        } = sale_args;

        let mut conditions = HashMap::new();

        for item in sale_conditions {
            let Price{
                price,
                ft_token_id,
            } = item;
            if !self.ft_token_ids.contains(&ft_token_id) {
                env::panic(format!("Token {} not supported by this market", ft_token_id).as_bytes());
            }
            if let Some(price) = price {
                // sale is denominated in FT
                conditions.insert(ft_token_id, price);
            } else {
                // accepting bids
                conditions.insert(ft_token_id, U128(0));
            }
        }
        
        // env::log(format!("add_sale for owner: {}", &owner_id).as_bytes());

        let bids = HashMap::new();

        let contract_and_token_id = format!("{}:{}", nft_contract_id, token_id);
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone(),
                approval_id,
                conditions,
                bids,
            },
        );

        // extra for views

        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(hash_account_id(&owner_id, Some("by_owner_id".to_string())).try_to_vec().unwrap())
        });
        assert!(by_owner_id.len() <= MAX_SALES_PER_ACCOUNT.into(), "Only 20 active sales allowed on this market");
        by_owner_id.insert(&contract_and_token_id);
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        let mut by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id).unwrap_or_else(|| {
            UnorderedSet::new(hash_account_id(&nft_contract_id, Some("by_nft_contract_id".to_string())).try_to_vec().unwrap())
        });
        by_nft_contract_id.insert(&token_id);
        self.by_nft_contract_id.insert(&nft_contract_id, &by_nft_contract_id);
    }
}

'''
'''--- contracts/market-simple/src/sale.rs ---
use crate::*;

/// measuring how many royalties can be paid
const GAS_FOR_FT_TRANSFER: Gas = 10_000_000_000_000;
/// seems to be max Tgas can attach to resolve_purchase
const GAS_FOR_ROYALTIES: Gas = 120_000_000_000_000;
const GAS_FOR_NFT_TRANSFER: Gas = 15_000_000_000_000;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub owner_id: AccountId,
    pub price: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub approval_id: U64,
    pub conditions: HashMap<FungibleTokenId, U128>,
    pub bids: HashMap<FungibleTokenId, Bid>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleJson {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
    pub conditions: HashMap<FungibleTokenId, U128>,
    pub bids: HashMap<FungibleTokenId, Bid>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub ft_token_id: AccountId,
    pub price: Option<U128>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: Vec<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PurchaseArgs {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
}

#[near_bindgen]
impl Contract {

    /// for add sale see: nft_callbacks.rs

    /// TODO remove without redirect to wallet? panic reverts
    pub fn remove_sale(&mut self, nft_contract_id: ValidAccountId, token_id: String) {
        let sale = self.internal_remove_sale(nft_contract_id.into(), token_id);
        let owner_id = env::predecessor_account_id();
        assert_eq!(owner_id, sale.owner_id, "Must be sale owner");
        self.refund_bids(&sale.bids, None);
    }

    pub fn update_price(
        &mut self,
        nft_contract_id: ValidAccountId,
        token_id: String,
        ft_token_id: ValidAccountId,
        price: U128,
    ) {
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}:{}", contract_id, token_id);
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        assert_eq!(env::predecessor_account_id(), sale.owner_id, "Must be sale owner");
        sale.conditions.insert(ft_token_id.into(), price);
        self.sales.insert(&contract_and_token_id, &sale);
    }

    #[payable]
    pub fn offer(
        &mut self,
        nft_contract_id: ValidAccountId,
        token_id: String,
    ) {
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}:{}", contract_id, token_id);
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let buyer_id = env::predecessor_account_id();
        assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
        let near_token_id = "near".to_string();
        let price = u128::from(*sale.conditions.get(&near_token_id).expect("Not for sale in NEAR"));
        let deposit = env::attached_deposit();

        // there's a fixed price user can buy for
        if deposit == price {
            self.process_purchase(contract_id, token_id, near_token_id, U128(deposit), buyer_id);
        } else {
            assert!(price == 0 || deposit < price, "Can't pay more than fixed price: {}", price);
            // buyer falls short of fixed price, or there is no fixed price
            // store a bid and refund any current bid lower
            let new_bid = Bid{
                owner_id: buyer_id,
                price: U128(deposit),
            };
            let current_bid = sale.bids.get(&near_token_id);
            if let Some(current_bid) = current_bid {
                // refund current bid holder
                let current_price: u128 = current_bid.price.into();
                assert!(deposit > current_price, "Can't pay less than or equal to current bid price: {}", current_price);
                Promise::new(current_bid.owner_id.clone()).transfer(current_bid.price.into());
                sale.bids.insert(near_token_id, new_bid);
            } else {
                sale.bids.insert(near_token_id, new_bid);
            }
            self.sales.insert(&contract_and_token_id, &sale);
        }
    }

    pub fn accept_offer(&mut self, nft_contract_id: ValidAccountId, token_id: String, ft_token_id: ValidAccountId) {
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}:{}", contract_id.clone(), token_id.clone());
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let bid = sale.bids.remove(ft_token_id.as_ref()).expect("No bid");
        self.sales.insert(&contract_and_token_id, &sale);
        // panics at `self.internal_remove_sale` and reverts above if predecessor is not sale.owner_id
        self.process_purchase(
            contract_id,
            token_id,
            ft_token_id.into(),
            bid.price.clone(),
            bid.owner_id.clone(),
        );
    }

    /// private 

    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
        price: U128,
        buyer_id: AccountId,
    ) -> Promise {
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());
        
        ext_contract::nft_transfer_payout(
            buyer_id.clone(),
            token_id,
            sale.owner_id.clone(),
            None,
            price,
            &nft_contract_id,
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::resolve_purchase(
            ft_token_id,
            buyer_id,
            sale,
            price,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))
    }

    /// self callback

    #[private]
    pub fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        price: U128,
    ) -> U128 {

        // checking for payout information
        let payout_option = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {
                None
            },
            PromiseResult::Successful(value) => {
                // None means a bad payout from bad NFT contract
                near_sdk::serde_json::from_slice::<Payout>(&value).ok().and_then(|payout| {
                    // gas to do 10 FT transfers (and definitely 10 NEAR transfers)
                    if payout.len() + sale.bids.len() > 8 {
                        None
                    } else {
                        // payouts must == sale.price, otherwise something wrong with NFT contract
                        // TODO off by 1 e.g. payouts are fractions of 3333 + 3333 + 3333
                        let sum: u128 = payout.values().map(|a| *a).reduce(|a, b| a + b).unwrap();
                        if sum == u128::from(price) {
                            Some(payout)
                        } else {
                            None
                        }
                    }
                })
            }
        };

        // is payout option valid?
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            // env::log(format!("Refunding {} to {}", u128::from(price), buyer_id).as_bytes());
            // refund NEAR
            if ft_token_id == "near" {
                Promise::new(buyer_id).transfer(u128::from(price));
            }
            // leave function and return all FTs in ft_resolve_transfer
            return price;
        };

        // env::log(format!("Payouts {:?}", payout).as_bytes());

        // Payback bids that were not claimed
        self.refund_bids(&sale.bids, Some(ft_token_id.clone()));

        // NEAR payouts
        if ft_token_id == "near" {
            for (receiver_id, amount) in &payout {
                Promise::new(receiver_id.to_string()).transfer(*amount);
            }
            // refund all FTs (won't be any)
            price
        } else {
        // FT payouts
            for (receiver_id, amount) in &payout {
                ext_contract::ft_transfer(
                    receiver_id.to_string(),
                    U128(*amount),
                    None,
                    &ft_token_id,
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
            // keep all FTs (already transferred for payouts)
            U128(0)
        }
    }

    #[private]
    pub fn refund_bids(&mut self, bids: &HashMap<FungibleTokenId, Bid>, ft_token_id: Option<FungibleTokenId>) {
        let mut ft_used = "".to_string();
        if let Some(ft_token_id) = ft_token_id {
            ft_used = ft_token_id
        }
        for (bid_ft, bid) in bids {
            if ft_used == *bid_ft {
                continue;
            }
            if bid_ft == "near" {
                Promise::new(bid.owner_id.clone()).transfer(u128::from(bid.price));
            } else {
                ext_contract::ft_transfer(
                    bid.owner_id.clone(),
                    bid.price,
                    None,
                    bid_ft,
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
        }
    }
}

/// self call

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        price: U128,
    ) -> Promise;
}

'''
'''--- contracts/market-simple/src/sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    /// views

    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: U64,
        limit: U64,
    ) -> Vec<SaleJson> {
        let mut tmp = vec![];
        let by_owner_id = self.by_owner_id.get(&account_id);
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), sales.len());
        for i in start..end {
            let contract_and_token_id = keys.get(i).unwrap();
            let strings: Vec<&str> = contract_and_token_id.split(":").collect();
            let nft_contract_id = strings[0].to_string();
            let token_id = strings[1].to_string();
            let Sale {
                owner_id: _, approval_id: _, conditions, bids
            } = self.sales.get(&contract_and_token_id).unwrap();
            
            tmp.push(SaleJson {
                nft_contract_id: nft_contract_id.clone(),
                token_id,
                conditions,
                bids
            });
        }
        tmp
    }

    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: U64,
        limit: U64,
    ) -> Vec<SaleJson> {
        let mut tmp = vec![];
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), sales.len());
        for i in start..end {
            let token_id = keys.get(i).unwrap();
            let Sale {
                owner_id: _, approval_id: _, conditions, bids
            } = self.sales.get(&format!("{}:{}", &nft_contract_id, &token_id)).unwrap();
            
            tmp.push(SaleJson {
                nft_contract_id: nft_contract_id.clone(),
                token_id,
                conditions,
                bids
            });
        }
        tmp
    }

    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Sale {
        self.sales.get(&nft_contract_token).expect("No sale")
    }
    
}

'''
'''--- contracts/nft-simple/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=3.1.0"

[profile.release]
codegen-units=24
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contracts/nft-simple/README.md ---
# TBD

'''
'''--- contracts/nft-simple/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/main.wasm

'''
'''--- contracts/nft-simple/src/burn.rs ---
use crate::*;

/// CUSTOM - owner can burn a locked token for a given user, reducing the enumerable->nft_supply_for_type
#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_burn(
        &mut self,
        token_id: Option<TokenId>,
    ) {
        assert_eq!(self.is_token_locked(token_id), true, "Token must be locked");
        //TODO burn token
    }
}
'''
'''--- contracts/nft-simple/src/enumerable.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    pub fn nft_tokens(
        &self,
        from_index: U64,
        limit: U64,
    ) -> Vec<JsonToken> {
        let mut tmp = vec![];
        let keys = self.token_metadata_by_id.keys_as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), keys.len());
        for i in start..end {
            tmp.push(self.nft_token(keys.get(i).unwrap()).unwrap());
        }
        tmp
    }

    pub fn nft_tokens_batch(
        &self,
        token_ids: Vec<String>,
    ) -> Vec<JsonToken> {
        let mut tmp = vec![];
        for i in 0..token_ids.len() {
            tmp.push(self.nft_token(token_ids[i].clone()).unwrap());
        }
        tmp
    }
    
    pub fn nft_supply_for_type(
        &self,
        token_type: &String,
    ) -> U64 {
        let tokens_per_type = self.tokens_per_type.get(&token_type);
        if let Some(tokens_per_type) = tokens_per_type {
            U64(tokens_per_type.len())
        } else {
            U64(0)
        }
    }

    pub fn nft_tokens_for_type(
        &self,
        token_type: String,
        from_index: U64,
        limit: U64,
    ) -> Vec<JsonToken> {
        let mut tmp = vec![];
        let tokens_per_type = self.tokens_per_type.get(&token_type);
        let tokens = if let Some(tokens_per_type) = tokens_per_type {
            tokens_per_type
        } else {
            return vec![];
        };
        let keys = tokens.as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), keys.len());
        for i in start..end {
            tmp.push(self.nft_token(keys.get(i).unwrap()).unwrap());
        }
        tmp
    }
    
    pub fn nft_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U64 {
        let tokens_owner = self.tokens_per_owner.get(&account_id);
        if let Some(tokens_owner) = tokens_owner {
            U64(tokens_owner.len())
        } else {
            U64(0)
        }
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: U64,
        limit: U64,
    ) -> Vec<JsonToken> {
        let mut tmp = vec![];
        let tokens_owner = self.tokens_per_owner.get(&account_id);
        let tokens = if let Some(tokens_owner) = tokens_owner {
            tokens_owner
        } else {
            return vec![];
        };
        let keys = tokens.as_vector();
        let start = u64::from(from_index);
        let end = min(start + u64::from(limit), keys.len());
        for i in start..end {
            tmp.push(self.nft_token(keys.get(i).unwrap()).unwrap());
        }
        tmp
    }
}

'''
'''--- contracts/nft-simple/src/internal.rs ---
use crate::*;
use near_sdk::{log, CryptoHash};
use std::mem::size_of;

pub(crate) fn royalty_to_payout(a: u32, b: Balance) -> Balance {
    a as u128 * b / 10_000u128
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

// TODO: need a way for end users to determine how much an approval will cost.
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.len() as u64 + 4 + size_of::<u64>() as u64
}

pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I,
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, U64>,
) -> Promise {
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

impl Contract {
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Owner's method"
        );
    }

    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        tokens_set.insert(token_id);
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            .expect("Token should be owned by the sender");
        tokens_set.remove(token_id);
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
    ) -> Token {
        let token = self.tokens_by_id.get(token_id).expect("Token not found");

        // CUSTOM - token_type can be locked until unlocked by owner
        if token.token_type.is_some() {
            assert_eq!(self.token_types_locked.contains(&token.token_type.clone().unwrap()), false, "Token transfers are locked");
        }

        if sender_id != &token.owner_id && !token.approved_account_ids.contains_key(sender_id) {
            env::panic(b"Unauthorized");
        }

        // If they included an enforce_approval_id, check the receiver approval id
        if let Some(enforced_approval_id) = approval_id {
            let actual_approval_id = token
                .approved_account_ids
                .get(sender_id)
                .expect("Sender is not approved account");
            assert_eq!(
                actual_approval_id, &enforced_approval_id,
                "The actual approval_id {} is different from the given approval_id {}",
                actual_approval_id.0, enforced_approval_id.0,
            );
        }

        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        log!(
            "Transfer {} from @{} to @{}",
            token_id,
            &token.owner_id,
            receiver_id
        );

        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        self.internal_add_token_to_owner(receiver_id, token_id);

        let new_token = Token {
            owner_id: receiver_id.clone(),
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
            royalty: token.royalty.clone(),
            token_type: token.token_type.clone(),
        };
        self.tokens_by_id.insert(token_id, &new_token);

        if let Some(memo) = memo {
            env::log(format!("Memo: {}", memo).as_bytes());
        }

        token
    }
}

'''
'''--- contracts/nft-simple/src/lib.rs ---
use std::collections::HashMap;
use std::cmp::min;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, ValidAccountId, U64, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise, StorageUsage,
};

use crate::internal::*;
pub use crate::metadata::*;
pub use crate::mint::*;
pub use crate::nft_core::*;
pub use crate::token::*;
pub use crate::enumerable::*;

mod internal;
mod metadata;
mod mint;
mod nft_core;
mod token;
mod enumerable;

// CUSTOM types
pub type TokenType = String;
pub type TypeSupplyCaps = HashMap<TokenType, U64>;
pub const CONTRACT_ROYALTY_CAP: u32 = 1000;
pub const MINTER_ROYALTY_CAP: u32 = 2000;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    pub tokens_by_id: LookupMap<TokenId, Token>,

    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,

    pub owner_id: AccountId,

    /// The storage size in bytes for one account.
    pub extra_storage_in_bytes_per_token: StorageUsage,

    pub metadata: LazyOption<NFTMetadata>,

    /// CUSTOM fields
    pub supply_cap_by_type: TypeSupplyCaps,
    pub tokens_per_type: LookupMap<TokenType, UnorderedSet<TokenId>>,
    pub token_types_locked: LookupSet<TokenType>,
    pub contract_royalty: u32,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NftMetadata,
    TokensPerType,
    TokenTypesLocked,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTMetadata, supply_cap_by_type: TypeSupplyCaps) -> Self {
        let mut this = Self {
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            owner_id: owner_id.into(),
            extra_storage_in_bytes_per_token: 0,
            metadata: LazyOption::new(
                StorageKey::NftMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
            supply_cap_by_type,
            tokens_per_type: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            token_types_locked: LookupSet::new(StorageKey::TokenTypesLocked.try_to_vec().unwrap()),
            contract_royalty: 0,
        };

        // CUSTOM - tokens are locked by default
        for (token_type, _) in &this.supply_cap_by_type {
            this.token_types_locked.insert(&token_type);
        }

        this.measure_min_token_storage_cost();

        this
    }

    fn measure_min_token_storage_cost(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        let u = UnorderedSet::new(
            StorageKey::TokenPerOwnerInner {
                account_id_hash: hash_account_id(&tmp_account_id),
            }
            .try_to_vec()
            .unwrap(),
        );
        self.tokens_per_owner.insert(&tmp_account_id, &u);

        let tokens_per_owner_entry_in_bytes = env::storage_usage() - initial_storage_usage;
        let owner_id_extra_cost_in_bytes = (tmp_account_id.len() - self.owner_id.len()) as u64;

        self.extra_storage_in_bytes_per_token =
            tokens_per_owner_entry_in_bytes + owner_id_extra_cost_in_bytes;

        self.tokens_per_owner.remove(&tmp_account_id);
    }

    /// CUSTOM - setters for owner

    pub fn set_contract_royalty(&mut self, contract_royalty: u32) {
        self.assert_owner();
        assert!(contract_royalty <= CONTRACT_ROYALTY_CAP, "Contract royalties limited to 10% for owner");
        self.contract_royalty = contract_royalty;
    }

    pub fn add_token_type(&mut self, token_type: String, hard_cap: U64) {
        self.assert_owner();
        self.token_types_locked.insert(&token_type);
        self.supply_cap_by_type.insert(token_type, hard_cap);
    }

    pub fn unlock_token_type(&mut self, token_type: String) {
        self.token_types_locked.remove(&token_type);
    }

    /// CUSTOM - views

    pub fn get_contract_royalty(&self) -> u32 {
        self.contract_royalty
    }

    pub fn get_supply_caps(&self) -> TypeSupplyCaps {
        self.supply_cap_by_type.clone()
    }

    pub fn is_token_type_locked(&self, token_type: TokenId) -> bool {
        self.token_types_locked.contains(&token_type)
    }

    pub fn is_token_locked(&self, token_id: TokenId) -> bool {
        let token = self.tokens_by_id.get(&token_id).expect("No token");
        assert_eq!(token.token_type.is_some(), true, "Token must have type");
        let token_type = token.token_type.unwrap();
        self.token_types_locked.contains(&token_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde::export::TryFrom;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn alice() -> AccountId {
        String::from("alice.near")
    }
    fn bob() -> AccountId {
        String::from("bob.near")
    }
    fn nft() -> AccountId {
        String::from("nft.near")
    }

    fn get_context(predecessor_account_id: AccountId, attached_deposit: Balance) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit,
            prepaid_gas: 2 * 10u64.pow(14),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    fn helper_contract_metadata() -> NFTMetadata {
        NFTMetadata {
            spec: "".to_string(),
            name: "".to_string(),
            symbol: "".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn helper_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Mochi Rising".to_string()),
            description: Some("Limited edition canvas".to_string()),
            media: None,
            media_hash: None,
            copies: None,
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn helper_mint() -> (Contract, VMContext) {
        let context = get_context(nft(), 10u128.pow(24));
        testing_env!(context.clone());
        let mut contract = Contract::new(
            ValidAccountId::try_from(nft()).unwrap(),
            helper_contract_metadata(),
        );
        contract.nft_mint("0".to_string(), helper_token_metadata());
        (contract, context)
    }

    #[test]
    fn basic_mint_from_owner() {
        helper_mint();
    }

    #[test]
    #[should_panic(expected = "Owner's method")]
    fn failed_mint_from_non_owner() {
        let context = get_context(alice(), 7660000000000000000000);
        testing_env!(context);
        let mut contract = Contract::new(
            ValidAccountId::try_from(nft()).unwrap(),
            helper_contract_metadata(),
        );
        contract.nft_mint("0".to_string(), helper_token_metadata());
    }

    #[test]
    fn simple_transfer() {
        let (mut contract, mut context) = helper_mint();
        let token_info = contract.nft_token("0".to_string());
        assert!(
            token_info.is_some(),
            "Expected to find newly minted token, got None."
        );
        let token_info_obj = token_info.unwrap();
        // Add one yoctoⓃ
        context.attached_deposit = 1;
        testing_env!(context.clone());
        contract.nft_transfer(
            ValidAccountId::try_from(bob()).unwrap(),
            "0".to_string(),
            None,
            Some("my memo".to_string()),
        );
        assert_eq!(
            token_info_obj.approved_account_ids.len(),
            0,
            "Expected number of initial approvers to be 0"
        );
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn failed_simple_transfer_needs_one_yocto() {
        let (mut contract, _) = helper_mint();
        contract.nft_transfer(
            ValidAccountId::try_from(bob()).unwrap(),
            "0".to_string(),
            Some(U64::from(0u64)),
            Some("my memo".to_string()),
        );
    }

    #[test]
    fn transfer_using_approver() {
        let (mut contract, mut context) = helper_mint();
        let mut token_info = contract.nft_token("0".to_string());
        assert!(
            token_info.is_some(),
            "Expected to find newly minted token, got None."
        );
        let mut token_info_obj = token_info.unwrap();
        assert_eq!(
            token_info_obj.approved_account_ids.len(),
            0,
            "Expected no initial approvers."
        );
        contract.nft_approve(
            "0".to_string(),
            ValidAccountId::try_from(alice()).unwrap(),
            None,
        );
        token_info = contract.nft_token("0".to_string());
        assert!(
            token_info.is_some(),
            "Expected to find token after approval, got None."
        );
        token_info_obj = token_info.unwrap();
        assert_eq!(
            token_info_obj.approved_account_ids.len(),
            1,
            "Expected one approver."
        );
        assert_eq!(
            token_info_obj.owner_id,
            nft(),
            "Expected nft.near to own token."
        );
        // Call from alice
        context.predecessor_account_id = alice();
        context.attached_deposit = 1;
        testing_env!(context.clone());
        contract.nft_transfer(
            ValidAccountId::try_from(alice()).unwrap(),
            "0".to_string(),
            Some(U64::from(0u64)),
            Some("thanks for allowing me to take it".to_string()),
        );
        token_info = contract.nft_token("0".to_string());
        assert!(
            token_info.is_some(),
            "Expected to find token after transfer, got None."
        );
        token_info_obj = token_info.unwrap();
        assert_eq!(
            token_info_obj.approved_account_ids.len(),
            0,
            "Expected approvers to reset to zero after transfer."
        );
        assert_eq!(
            token_info_obj.owner_id,
            alice(),
            "Expected alice.near to own token after transferring using approvals."
        );
    }

    #[test]
    #[should_panic(expected = "Unauthorized")]
    fn failed_transfer_using_unauthorized_approver() {
        let (mut contract, mut context) = helper_mint();
        contract.nft_approve(
            "0".to_string(),
            ValidAccountId::try_from(alice()).unwrap(),
            None,
        );
        // Bob tries to transfer when only alice should be allowed to
        context.predecessor_account_id = bob();
        context.attached_deposit = 1;
        testing_env!(context.clone());
        contract.nft_transfer(
            ValidAccountId::try_from(bob()).unwrap(),
            "0".to_string(),
            Some(U64::from(1u64)),
            Some("I am trying to hack you.".to_string()),
        );
    }
}

'''
'''--- contracts/nft-simple/src/metadata.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<U64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
    pub expires_at: Option<String>, // ISO 8601 datetime when token expires
    pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
    pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

pub trait NonFungibleTokenMetadata {
    fn nft_metadata(&self) -> NFTMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- contracts/nft-simple/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: Option<TokenId>,
        metadata: TokenMetadata,
        perpetual_royalties: Option<HashMap<AccountId, u32>>,
        receiver_id: Option<ValidAccountId>,
        token_type: Option<TokenType>,
    ) {

        let mut final_token_id = format!("{}", self.token_metadata_by_id.len() + 1);
        if let Some(token_id) = token_id {
            final_token_id = token_id
        }

        let initial_storage_usage = env::storage_usage();
        let mut owner_id = env::predecessor_account_id();
        if let Some(receiver_id) = receiver_id {
            owner_id = receiver_id.into();
        }

        // CUSTOM - create royalty map
        let mut royalty = HashMap::new();
        let mut total_perpetual = 0;
        // user added perpetual_royalties (percentage paid with every transfer)
        if let Some(perpetual_royalties) = perpetual_royalties {
            assert!(perpetual_royalties.len() < 7, "Cannot add more than 6 perpetual royalty amounts");
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
                total_perpetual += amount;
            }
        }
        // royalty limit for minter capped at 20%
        assert!(total_perpetual <= MINTER_ROYALTY_CAP, "Perpetual royalties cannot be more than 20%");

        // enforce minting caps by token_type 
        if token_type.is_some() {
            let token_type = token_type.clone().unwrap();
            let cap = u64::from(*self.supply_cap_by_type.get(&token_type).expect("Token type must have supply cap."));
            let supply = u64::from(self.nft_supply_for_type(&token_type));
            assert!(supply < cap, "Cannot mint anymore of token type.");
            let mut tokens_per_type = self.tokens_per_type.get(&token_type).unwrap_or_else(|| {
                UnorderedSet::new(hash_account_id(&token_type).try_to_vec().unwrap())
            });
            tokens_per_type.insert(&final_token_id);
            self.tokens_per_type.insert(&token_type, &tokens_per_type);
        }
        // END CUSTOM

        let token = Token {
            owner_id,
            approved_account_ids: Default::default(),
            next_approval_id: 0,
            royalty,
            token_type,
        };
        assert!(
            self.tokens_by_id.insert(&final_token_id, &token).is_none(),
            "Token already exists"
        );
        self.token_metadata_by_id.insert(&final_token_id, &metadata);
        self.internal_add_token_to_owner(&token.owner_id, &final_token_id);

        let new_token_size_in_bytes = env::storage_usage() - initial_storage_usage;
        let required_storage_in_bytes =
            self.extra_storage_in_bytes_per_token + new_token_size_in_bytes;

        refund_deposit(required_storage_in_bytes);
    }
}
'''
'''--- contracts/nft-simple/src/nft_core.rs ---
use crate::*;
use near_sdk::json_types::{ValidAccountId, U64};
use near_sdk::{ext_contract, log, Gas, PromiseResult};

const GAS_FOR_NFT_APPROVE: Gas = 10_000_000_000_000;
const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
const GAS_FOR_NFT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
    );

    fn nft_transfer_payout(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
        balance: Option<U128>,
    ) -> Option<Payout>;

    /// Returns `true` if the token was transferred from the sender's account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
        msg: String,
    ) -> Promise;

    fn nft_approve(&mut self, token_id: TokenId, account_id: ValidAccountId, msg: Option<String>);

    fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId);

    fn nft_revoke_all(&mut self, token_id: TokenId);

    fn nft_total_supply(&self) -> U64;

    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: U64,
        msg: String,
    );
}

// TODO: create nft_on_revoke

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        approved_account_ids: HashMap<AccountId, U64>,
        token_id: TokenId,
    ) -> bool;
}

trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        approved_account_ids: HashMap<AccountId, U64>,
        token_id: TokenId,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
    ) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token = self.internal_transfer(
            &sender_id,
            receiver_id.as_ref(),
            &token_id,
            approval_id,
            memo,
        );
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    // CUSTOM - this method is included for marketplaces that respect royalties
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
        balance: Option<U128>,
    ) -> Option<Payout> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token = self.internal_transfer(
            &sender_id,
            receiver_id.as_ref(),
            &token_id,
            approval_id,
            memo,
        );
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        // compute payouts based on balance option
        // adds in contract_royalty and computes previous owner royalty from remainder
        let owner_id = previous_token.owner_id;
        let royalty = self.tokens_by_id.get(&token_id).expect("No token").royalty;
        let mut total_perpetual = 0;
        let payout = if let Some(balance) = balance {
            let balance_u128 = u128::from(balance);
            let mut payout: Payout = HashMap::new();
            for (k, v) in royalty.iter() {
                let key = k.clone();
                if key != owner_id {
                    payout.insert(key, royalty_to_payout(*v, balance_u128));
                    total_perpetual += *v;
                }
            }
            // payout to contract owner - may be previous token owner -> then they get remainder of balance
            if self.contract_royalty > 0 && self.owner_id != owner_id {
                payout.insert(self.owner_id.clone(), royalty_to_payout(self.contract_royalty, balance_u128));
                total_perpetual += self.contract_royalty;
            }
            assert!(total_perpetual <= MINTER_ROYALTY_CAP + CONTRACT_ROYALTY_CAP, "Royalties should not be more than caps");
            // payout to previous owner
            payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

            env::log(format!("total_perpetual {:?}", total_perpetual).as_bytes());
            env::log(format!("Payouts {:?}", payout).as_bytes());

            Some(payout)
        } else {
            None
        };

        payout
    }

    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<U64>,
        memo: Option<String>,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token = self.internal_transfer(
            &sender_id,
            receiver_id.as_ref(),
            &token_id,
            approval_id,
            memo,
        );
        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_token.owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL,
        )
        .then(ext_self::nft_resolve_transfer(
            previous_token.owner_id,
            receiver_id.into(),
            previous_token.approved_account_ids,
            token_id,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
    }

    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: ValidAccountId, msg: Option<String>) {
        assert_at_least_one_yocto();
        let account_id: AccountId = account_id.into();

        let mut token = self.tokens_by_id.get(&token_id).expect("Token not found");

        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        let approval_id: U64 = token.next_approval_id.into();
        let is_new_approval = token
            .approved_account_ids
            .insert(account_id.clone(), approval_id)
            .is_none();

        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        } else {
            0
        };

        token.next_approval_id += 1;
        self.tokens_by_id.insert(&token_id, &token);

        refund_deposit(storage_used);

        if let Some(msg) = msg {
            ext_non_fungible_approval_receiver::nft_on_approve(
                token_id,
                token.owner_id,
                approval_id,
                msg,
                &account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
            )
            .as_return(); // Returning this promise
        }
    }

    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId) {
        assert_one_yocto();
        let mut token = self.tokens_by_id.get(&token_id).expect("Token not found");
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);
        if token
            .approved_account_ids
            .remove(account_id.as_ref())
            .is_some()
        {
            refund_approved_account_ids_iter(predecessor_account_id, [account_id.into()].iter());
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        assert_one_yocto();
        let mut token = self.tokens_by_id.get(&token_id).expect("Token not found");
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);
        if !token.approved_account_ids.is_empty() {
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            token.approved_account_ids.clear();
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    fn nft_total_supply(&self) -> U64 {
        self.token_metadata_by_id.len().into()
    }

    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                royalty: token.royalty,
                approved_account_ids: token.approved_account_ids,
                token_type: token.token_type,
            })
        } else {
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        approved_account_ids: HashMap<AccountId, U64>,
        token_id: TokenId,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                if !return_token {
                    // Token was successfully received.
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if &token.owner_id != &receiver_id {
                // The token is not owner by the receiver anymore. Can't return it.
                refund_approved_account_ids(owner_id, &approved_account_ids);
                return true;
            }
            token
        } else {
            // The token was burned and doesn't exist anymore.
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        log!("Return {} from @{} to @{}", token_id, receiver_id, owner_id);

        self.internal_remove_token_from_owner(&receiver_id, &token_id);
        self.internal_add_token_to_owner(&owner_id, &token_id);
        token.owner_id = owner_id;
        refund_approved_account_ids(receiver_id, &token.approved_account_ids);
        token.approved_account_ids = approved_account_ids;
        self.tokens_by_id.insert(&token_id, &token);

        false
    }
}

'''
'''--- contracts/nft-simple/src/token.rs ---
use crate::*;

pub type TokenId = String;
pub type Payout = HashMap<AccountId, u128>;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub owner_id: AccountId,
    pub approved_account_ids: HashMap<AccountId, U64>,
    pub next_approval_id: u64,
    
    // CUSTOM - fields
    pub royalty: HashMap<AccountId, u32>,
    pub token_type: Option<String>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: TokenMetadata,
    pub approved_account_ids: HashMap<AccountId, U64>,

    // CUSTOM - fields
    pub royalty: HashMap<AccountId, u32>,
    pub token_type: Option<String>,
}

'''
'''--- jest.config.js ---
module.exports = {
    testEnvironment: "node",
	testTimeout: 30000,
	globals: {
		Uint8Array: Uint8Array,
	},
};
'''
'''--- package.json ---
{
    "name": "react-parcel-boilerplate",
    "version": "1.0.0",
    "description": "React Parcel Boilerplate",
    "author": "Matt Lockyer",
    "license": "ISC",
    "dependencies": {
        "bn": "^1.0.5",
        "near-api-js": "^0.36.2",
        "near-seed-phrase": "^0.1.0",
        "parcel": "^2.0.0-beta.1",
        "react": "^17.0.1",
        "react-dom": "^17.0.1"
    },
    "devDependencies": {
        "cross-env": "^7.0.3",
        "eslint": "^7.14.0",
        "gh-pages": "^3.1.0",
        "jest": "^26.6.3",
        "jest-environment-uint8array": "^1.0.0",
        "node-fetch": "^2.6.1",
        "rimraf": "^3.0.2",
        "sass": "^1.32.8"
    },
    "browserslist": [
        "last 2 Chrome versions"
    ],
    "scripts": {
        "prestart": "rm -rf ./parcel-cache",
        "start:deploy": "yarn test:deploy && yarn start",
        "start": "cross-env REACT_APP_ENV=dev parcel src/index.html --open",
        "prebuild": "rm -rf ./dist",
        "fix": "eslint src/ test/ server/ --fix",
        "build:contracts": "cd contracts/nft-simple && ./build.sh && cd ../.. && cd contracts/market-simple && ./build.sh && cd ../.. && cd contracts/ft && ./build.sh && cd ../..",
        "patch:config": "node ./utils/patch-config.js",
        "dev:deploy": "yarn build:contracts && rm -rf neardev && (near dev-deploy || exit 0) && yarn patch:config",
        "test:unit": "(cd contracts && cargo test -- --nocapture --color always)",
        "test:deploy": "yarn dev:deploy && yarn test",
        "test": "cross-env REACT_APP_ENV=dev jest app.test.js --useStderr",
        "test:server": "cross-env REACT_APP_ENV=dev jest server.test.js --useStderr",

        "patch:deploy-config": "node ./utils/patch-deploy-config.js",
        "build": "parcel build src/index.html --no-source-maps --public-url https://near-apps.github.io/nft-market/",
        "deploy": "yarn patch:deploy-config && cross-env REACT_APP_ENV=dev yarn build && gh-pages -d dist"
    }
}

'''
'''--- server/app.js ---
const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { withNear } = require('./middleware/near');
const { near, contractAccount } = require('./utils/near-utils');
const { contractName, networkId, GAS, contractMethods, GUESTS_ACCOUNT_SECRET } = getConfig();
const {
	Account,
	KeyPair,
	utils: {
		format: {
			parseNearAmount
		}
	}
} = nearAPI;

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
	res.send('Hello World!');
});

/// WARNING NO RESTRICTION ON THIS ENDPOINT
app.post('/add-guest', async (req, res) => {
	const { account_id, public_key } = req.body;
	const contractId = account_id.substr(account_id.indexOf('.') + 1);
	/// setup signer for guestAccount txs
	const guestId = 'guests.' + contractId;
	const guestKeyPair = KeyPair.fromString(GUESTS_ACCOUNT_SECRET);
	near.connection.signer.keyStore.setKey(networkId, guestId, guestKeyPair);
	const guestsAccount = new Account(near.connection, guestId);
	/// try adding key to guestAccount and guest record to contract
	console.log('\nAdding guest account:', account_id);
	try {
		const addKey = await guestsAccount.addKey(public_key, contractId, contractMethods.changeMethods, parseNearAmount('0.1'));
		const add_guest = await contractAccount.functionCall(contractId, 'add_guest', { account_id, public_key }, GAS);
		res.json({ success: true, result: { addKey, add_guest } });
	} catch(e) {
		console.log(e);
		return res.status(403).send({ error: `error adding guest`, e});
	}
});

app.listen(port, () => {
	console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});
'''
'''--- server/middleware/near.js ---

const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const { near, connection, contractAccount } = require('../utils/near-utils');

const withNear = () => (req, res, next) => {
	req.near = near;
	next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
	const nearAccount = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(data).digest();
		let accessKeys = await nearAccount.getAccessKeys();
		if (contractName.length) {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
		} else {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission === 'FullAccess');
		}
		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

const hasAccessKey = async (req, res, next) => {
	const { accountId, contractName, blockNumber, blockNumberSignature } = req.body;
    
	if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
		return res.status(403).send({ error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature' });
	}

	if (!(await validBlock(blockNumber))) {
		return res.status(403).send({ error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
	}

	if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
		return res.status(403).send({ error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
	}

	return await next();
};

module.exports = {
	contractAccount,
	withNear,
	hasAccessKey,
};
'''
'''--- server/nodemon.json ---
{
    "watch": [
      "./app.js",
      "./utils/",
      "./middleware",
      "../src/config.js"
    ],
    "verbose": true
  }
'''
'''--- server/package.json ---
{
    "name": "server",
    "version": "1.0.0",
    "description": "near utility server",
    "main": "app.js",
    "scripts": {
        "start": "REACT_APP_ENV=dev nodemon app.js --config ./nodemon.json",
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "mattlockyer",
    "license": "ISC",
    "dependencies": {
        "bs58": "^4.0.1",
        "cors": "^2.8.5",
        "express": "^4.17.1",
        "near-api-js": "^0.36.2",
        "tweetnacl": "^1.0.3"
    },
    "devDependencies": {
        "nodemon": "^2.0.7"
    }
}

'''
'''--- server/utils/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../../src/config');
const { nodeUrl, networkId, contractName, contractMethods, accessKeyMethods } = getConfig();
const {
	keyStores: { InMemoryKeyStore },
	Near, Account, Contract, KeyPair,
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = new InMemoryKeyStore();
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key));
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	accessKeyMethods,
};
'''
'''--- src/App.js ---
import React, { useContext, useEffect, useState } from 'react';

import { appStore, onAppMount } from './state/app';

import { Wallet } from './components/Wallet';
import { Contract } from './components/Contract';
import { Gallery } from './components/Gallery';

import Avatar from 'url:./img/avatar.jpg';
import NearLogo from 'url:./img/near_icon.svg';

import './App.scss';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	const { app, app: {tab}, near, wallet, contractAccount, account, loading } = state;

	const [profile, setProfile] = useState(false);

	const onMount = () => {
		dispatch(onAppMount());
	};
	useEffect(onMount, []);

	const signedIn = ((wallet && wallet.signedIn));

	if (profile && !signedIn) {
		setProfile(false);
	}

	return <>
		{ loading && <div className="loading">
			<img src={NearLogo} />
		</div>
		}

		<div className="background"></div>

		<div id="menu">
			<div>
				<img style={{ opacity: signedIn ? 1 : 0.25 }} src={Avatar}
					onClick={() => setProfile(!profile)}
				/>
			</div>
			<div>
				{!signedIn ? <Wallet {...{ wallet }} /> : account.accountId}
			</div>
			{
				profile && signedIn && <div id="profile">
					<div>
						{
							wallet && wallet.signedIn && <Wallet {...{ wallet, account, update, dispatch, handleClose: () => setProfile(false) }} />
						}
					</div>
				</div>
			}
		</div>

		{
			signedIn && <div id="tabs">
				<div onClick={() => update('app.tab', 1)} style={{ background: tab === 1 ? '#fed' : '' }}>Market</div>
				<div onClick={() => update('app.tab', 2)} style={{ background: tab === 2 ? '#fed' : '' }}>My NFTs</div>
				<div onClick={() => update('app.tab', 3)} style={{ background: tab === 3 ? '#fed' : '' }}>Mint</div>
			</div>
		}

		{ signedIn && tab === 3 &&
			<div id="contract">
				{
					signedIn &&
					<Contract {...{ near, update, wallet, account }} />
				}
			</div>
		}
		<div id="gallery">
			<Gallery {...{ app, update, loading, contractAccount, account }} />
		</div>
	</>;
};

export default App;

'''
'''--- src/components/Contract.js ---
import React, {useEffect, useState} from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import { 
	contractId,
	isAccountTaken,
	networkId,
} from '../utils/near-utils';

const {
	KeyPair,
} = nearAPI;

export const Contract = ({ near, update, account }) => {
	if (!account) return <p>Please connect your NEAR Wallet</p>;

	const [media, setMedia] = useState('');
	const [validMedia, setValidMedia] = useState('');
	const [royalties, setRoyalties] = useState({});
	const [royalty, setRoyalty] = useState([]);
	const [receiver, setReceiver] = useState([]);

	const handleMint = async () => {
		if (!media.length || !validMedia) {
			alert('Please enter a valid Image Link. You should see a preview below!');
			return;
		}

		// shape royalties data for minting and check max is < 20%
		let perpetual_royalties = Object.entries(royalties).map(([receiver, royalty]) => ({
			[receiver]: royalty * 100
		})).reduce((acc, cur) => Object.assign(acc, cur), {});
		if (Object.values(perpetual_royalties).reduce((a, c) => a + c, 0) > 2000) {
			return alert('Cannot add more than 20% in perpetual NFT royalties when minting');
		}
		
		update('loading', true);
		const metadata = { 
			media,
			issued_at: Date.now().toString()
		};
		const deposit = parseNearAmount('0.1');
		await account.functionCall(contractId, 'nft_mint', {
			token_id: 'token-' + Date.now(),
			metadata,
			perpetual_royalties
		}, GAS, deposit);
		checkFreebies();
		update('loading', false);
		setMetadata('');
	};

	return <>
		<h4>Mint Something</h4>
		<input className="full-width" placeholder="Image Link" value={media} onChange={(e) => setMedia(e.target.value)} />
		<img src={media} onLoad={() => setValidMedia(true)} onError={() => setValidMedia(false)} />
		
		{ !validMedia && <p>Image link is invalid.</p> }
		
		<h4>Royalties</h4>
		{
			Object.keys(royalties).length > 0 ? 
				Object.entries(royalties).map(([receiver, royalty]) => <div key={receiver}>
					{receiver} - {royalty} % <button onClick={() => {
						delete royalties[receiver];
						setRoyalties(Object.assign({}, royalties));
					}}>❌</button>
				</div>)
				:
				<p>No royalties added yet.</p>
		}
		<input className="full-width" placeholder="Account ID" value={receiver} onChange={(e) => setReceiver(e.target.value)} />
		<input type="number" className="full-width" placeholder="Percentage" value={royalty} onChange={(e) => setRoyalty(e.target.value)} />
		<button onClick={async () => {
			const exists = await isAccountTaken(receiver);
			if (!exists) return alert(`Account: ${receiver} does not exist on ${networkId ==='default' ? 'testnet' : 'mainnet'}.`);
			setRoyalties(Object.assign({}, royalties, {
				[receiver]: royalty
			}));
		}}>Add Royalty</button>

		<div className="line"></div>

		<button onClick={() => handleMint()}>Mint</button>
	</>;
};

'''
'''--- src/components/Gallery.js ---
import React, { useEffect, useState } from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import {
	marketId,
	contractId,
	formatAccountId,
} from '../utils/near-utils';

const ADD_SALE = '__ADD_SALE';

const {
	KeyPair,
	utils: { format: { formatNearAmount } }
} = nearAPI;

const token2symbol = {
	"near": "NEAR",
	// "dai": "DAI",
	// "usdc": "USDC",
	// "usdt": "USDT",
};

const n2f = (amount) => parseFloat(parseNearAmount(amount, 8));

const sortFunctions = {
	1: (a, b) => parseInt(a.metadata.issued_at || '0') - parseInt(b.metadata.issued_at || '0'),
	2: (b, a) => parseInt(a.metadata.issued_at || '0') - parseInt(b.metadata.issued_at || '0'),
	3: (a, b) => n2f((a.conditions || {near: '0'}).near) - n2f((b.conditions || {near: '0'}).near),
	4: (b, a) => n2f((a.conditions || {near: '0'}).near) - n2f((b.conditions || {near: '0'}).near),
};
const allTokens = Object.keys(token2symbol);

const getTokenOptions = (value, setter, accepted = allTokens) => (
	<select value={value} onChange={(e) => setter(e.target.value)}>
		{
			accepted.map((value) => <option key={value} value={value}>{token2symbol[value]}</option>)
		}
	</select>);

export const Gallery = ({ app, update, contractAccount, account, loading }) => {
	if (!contractAccount) return null;

	const { tab, sort, filter } = app;

	let accountId = '';
	if (account) accountId = account.accountId;

	/// market
	const [sales, setSales] = useState([]);
	const [allTokens, setAllTokens] = useState([]);
	const [offerPrice, setOfferPrice] = useState('');
	const [offerToken, setOfferToken] = useState('near');

	/// updating user tokens
	const [tokens, setTokens] = useState([]);
	const [storage, setStorage] = useState(false);
	const [price, setPrice] = useState('');
	const [token, setToken] = useState('near');
	const [saleConditions, setSaleConditions] = useState([]);

	useEffect(() => {
		if (!loading) loadItems();
	}, [loading]);

	const loadItems = async () => {
		if (accountId.length) {
			setStorage(await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: account.accountId }));
		}
		/// users tokens
		if (account) {
			const tokens = await contractAccount.viewFunction(contractId, 'nft_tokens_for_owner', {
				account_id: account.accountId,
				from_index: '0',
				limit: '50'
			});
			const sales = await contractAccount.viewFunction(marketId, 'get_sales_by_owner_id', {
				account_id: account.accountId,
				from_index: '0',
				limit: '50'
			});
			// merge tokens with sale data if it's on sale
			for (let i = 0; i < tokens.length; i++) {
				const { token_id } = tokens[i];
				let sale = sales.find(({ token_id: t }) => t === token_id);
				// don't have it in state, go find sale data
				if (!sale) {
					sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ":" + token_id }).catch(() => { });
				}
				tokens[i] = Object.assign(tokens[i], sale || {});
			}
			setTokens(tokens);
		}

		/// all sales
		const sales = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_contract_id', {
			nft_contract_id: contractId,
			from_index: '0',
			limit: '100'
		});
		const tokens = await contractAccount.viewFunction(contractId, 'nft_tokens_batch', {
			token_ids: sales.filter(({ nft_contract_id }) => nft_contract_id === contractId).map(({ token_id }) => token_id)
		});
		// merge sale listing with nft token data
		for (let i = 0; i < sales.length; i++) {
			const { token_id } = sales[i];
			let token = tokens.find(({ token_id: t }) => t === token_id);
			// don't have it in batch, go find token data
			if (!token) {
				token = await contractAccount.viewFunction(contractId, 'nft_token', { token_id });
			}
			sales[i] = Object.assign(sales[i], token);
		}
		setSales(sales);

		// all tokens
		const allTokens = await contractAccount.viewFunction(contractId, 'nft_tokens', {
			from_index: '0',
			limit: '100'
		});
		console.log(allTokens);
		setAllTokens(allTokens);
	};

	/// setters

	const handleOffer = async (token_id) => {
		if (offerToken !== 'near') {
			return alert('currently only accepting NEAR offers');
		}
		if (offerToken === 'near') {
			await account.functionCall(marketId, 'offer', {
				nft_contract_id: contractId,
				token_id,
			}, GAS, parseNearAmount(offerPrice));
		} else {
			///todo ft_transfer_call

		}
	};

	const handleAcceptOffer = async (token_id, ft_token_id) => {
		if (ft_token_id !== 'near') {
			return alert('currently only accepting NEAR offers');
		}
		await account.functionCall(marketId, 'accept_offer', {
			nft_contract_id: contractId,
			token_id,
			ft_token_id,
		}, GAS);
	};

	const handleRegisterStorage = async () => {
		const storageMarket = await account.viewFunction(marketId, 'storage_amount', {}, GAS);
		await account.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => { });
	};

	const handleSaleUpdate = async (token_id, newSaleConditions) => {
		const sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ":" + token_id }).catch(() => { });
		if (sale) {
			await account.functionCall(marketId, 'update_price', {
				nft_contract_id: contractId,
				token_id,
				ft_token_id: newSaleConditions[0].ft_token_id,
				price: newSaleConditions[0].price
			}, GAS);
		} else {
			await account.functionCall(contractId, 'nft_approve', {
				token_id,
				account_id: marketId,
				msg: JSON.stringify({ sale_conditions: newSaleConditions })
			}, GAS, parseNearAmount('0.01'));
		}
	};

	let market = sales;
	if (tab !== 2 && filter === 1) {
		market = market.concat(allTokens.filter(({ token_id }) => !market.some(({ token_id: t}) => t === token_id)));
	}
	market.sort(sortFunctions[sort]);
	tokens.sort(sortFunctions[sort]);

	return <>
		{
			tab < 3 && 
			<center>
				{
					tab !== 2 && <button onClick={() => update('app.filter', filter === 2 ? 1 : 2)} style={{background: '#fed'}}>{filter === 1 ? 'All' : 'Sales'}</button>
				}
				<button onClick={() => update('app.sort', sort === 2 ? 1 : 2)} style={{ background: sort === 1 || sort === 2 ? '#fed' : ''}}>Date {sort === 1 && '⬆️'}{sort === 2 && '⬇️'}</button>
				{
					tab !== 2 && <button onClick={() => update('app.sort', sort === 4 ? 3 : 4)} style={{ background: sort === 3 || sort === 4 ? '#fed' : ''}}>Price {sort === 3 && '⬆️'}{sort === 4 && '⬇️'}</button>
				}
			</center>
		}
		{
			tab === 1 && market.map(({
				metadata: { media },
				owner_id,
				token_id,
				conditions = {},
				bids = {},
				royalty = {}
			}) =>
				<div key={token_id} className="item">
					<img src={media} />
					<p>{accountId !== owner_id ? `Owned by ${formatAccountId(owner_id)}` : `You own this!`}</p>
					{ Object.keys(conditions).length > 0 && <>
						<h4>Royalties</h4>
						{
							Object.keys(royalty).length > 0 ?
								Object.entries(royalty).map(([receiver, amount]) => <div key={receiver}>
									{receiver} - {amount / 100}%
								</div>)
								:
								<p>This token has no royalties.</p>
						}
					</>
					}
					{
						Object.keys(conditions).length > 0 && <>
							<h4>Sale Conditions</h4>
							{
								Object.entries(conditions).map(([ft_token_id, price]) => <div className="margin-bottom" key={ft_token_id}>
									{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
								</div>)
							}
							{
								accountId.length && accountId !== owner_id && <>
									<input type="number" placeholder="Price" value={offerPrice} onChange={(e) => setOfferPrice(e.target.value)} />
									{
										getTokenOptions(offerToken, setOfferToken, Object.keys(conditions))
									}
									<button onClick={() => handleOffer(token_id)}>Offer</button>
								</>
							}
						</>
					}
					{
						Object.keys(bids).length > 0 && <>
							<h4>Offers</h4>
							{
								Object.entries(bids).map(([ft_token_id, { owner_id: bid_owner_id, price }]) => <div className="offers" key={ft_token_id}>
									<div>
										{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]} by {bid_owner_id}
									</div>
									{
										accountId === owner_id &&
										<button onClick={() => handleAcceptOffer(token_id, ft_token_id)}>Accept</button>
									}
								</div>)
							}
						</>
					}
				</div>)
		}

		{
			tab === 2 && <>
				{!tokens.length && <p className="margin">No NFTs. Try minting something!</p>}
				{
					tokens.map(({
						metadata: { media },
						owner_id,
						token_id,
						conditions = {},
						bids = {},
						royalty = {}
					}) => <div key={token_id} className="item">
						<img src={media} />
						{
							storage ? <>
								<h4>Royalties</h4>
								{
									Object.keys(royalty).length > 0 ?
										Object.entries(royalty).map(([receiver, amount]) => <div key={receiver}>
											{receiver} - {amount / 100}%
										</div>)
										:
										<p>This token has no royalties.</p>
								}
								{
									Object.keys(conditions).length > 0 && <>
										<h4>Current Sale Conditions</h4>
										{
											Object.entries(conditions).map(([ft_token_id, price]) => <div className="margin-bottom" key={ft_token_id}>
												{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
											</div>)
										}
									</>
								}
								{
									saleConditions.length > 0 &&
										<div>
											<h4>Pending Sale Updates</h4>
											{
												saleConditions.map(({ price, ft_token_id }) => <div className="margin-bottom" key={ft_token_id}>
													{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
												</div>)
											}
											<button className="pulse-button" onClick={() => handleSaleUpdate(token_id)}>Update Sale Conditions</button>
										</div>
								}
								{
									accountId === owner_id && <>
										<div>
											<h4>Add Sale Conditions</h4>
											<input type="number" placeholder="Price" value={price} onChange={(e) => setPrice(e.target.value)} />
											{
												getTokenOptions(token, setToken)
											}
											<button onClick={() => {
												if (!price.length) {
													return alert('Enter a price');
												}
												const newSaleConditions = saleConditions
													.filter(({ ft_token_id }) => ft_token_id !== token)
													.concat([{
														price: parseNearAmount(price),
														ft_token_id: token,
													}]);
												setSaleConditions(newSaleConditions);
												setPrice('');
												setToken('near');
												handleSaleUpdate(token_id, newSaleConditions);
											}}>Add</button>
										</div>
										<div>
											<i style={{ fontSize: '0.75rem' }}>Note: price 0 means open offers</i>
										</div>
									</>
								}
								{
									Object.keys(bids).length > 0 && <>
										<h4>Offers</h4>
										{
											Object.entries(bids).map(([ft_token_id, { owner_id, price }]) => <div className="offers" key={ft_token_id}>
												<div>
													{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
												</div>
												<button onClick={() => handleAcceptOffer(token_id, ft_token_id)}>Accept</button>
											</div>)
										}
									</>
								}
							</>
								:
								<div className="center">
									<button onClick={() => handleRegisterStorage()}>Register with Market to Sell</button>
								</div>
						}
					</div>)
				}
			</>
		}

	</>;
};

'''
'''--- src/components/Wallet.js ---
import React, { useEffect, useState } from 'react';

import * as nearAPI from 'near-api-js';
import { updateWallet } from '../state/near';
import {
	getContract,
	contractMethods,
	GAS
} from '../utils/near-utils';
const {
	KeyPair,
	utils: { PublicKey,
		format: {
			formatNearAmount
		} }
} = nearAPI;

export const Wallet = ({ wallet, account, update, dispatch, handleClose }) => {

	const [accountId, setAccountId] = useState('');
	const [proceeds, setProceeds] = useState('0');

	if (wallet && wallet.signedIn) {
		return <>
			<h3>Wallet</h3>
			<p>Balance: { wallet.balance } N</p>
			<br />
			<button onClick={handleClose}>Close</button>
			<br />
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>;
	}

	return <>
		<button onClick={() => wallet.signIn()}>Connect Wallet</button>
	</>;
};

'''
'''--- src/config.js ---
const contractName = 'dev-1618702493101-2158436';

module.exports = function getConfig() {
	let config = {
		networkId: 'default',
		nodeUrl: 'https://rpc.testnet.near.org',
		// walletUrl: 'http://localhost:1234',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org',
		contractName,
	};
    
	if (process.env.REACT_APP_ENV !== undefined) {
		config = {
			...config,
			GAS: '200000000000000',
			DEFAULT_NEW_ACCOUNT_AMOUNT: '5',
			DEFAULT_NEW_CONTRACT_AMOUNT: '5',
			GUESTS_ACCOUNT_SECRET: '7UVfzoKZL4WZGF98C3Ue7tmmA6QamHCiB1Wd5pkxVPAc7j6jf3HXz5Y9cR93Y68BfGDtMLQ9Q29Njw5ZtzGhPxv',
			contractMethods: {
				changeMethods: [
					'new', 'nft_mint', 'nft_transfer', 'add_guest', 'remove_guest',
					'nft_approve_account_id', 
					'nft_mint_guest', 'nft_add_sale_guest', 'nft_remove_sale_guest', 'upgrade_guest'
				],
				viewMethods: ['get_guest', 'get_token_ids', 'nft_token', 'get_sale'],
			},
			marketDeposit: '100000000000000000000000',
			marketId: 'market.' + contractName
		};
	}
    
	if (process.env.REACT_APP_ENV === 'prod') {
		config = {
			...config,
			networkId: 'mainnet',
			nodeUrl: 'https://rpc.mainnet.near.org',
			walletUrl: 'https://wallet.near.org',
			helperUrl: 'https://helper.mainnet.near.org',
			contractName: 'near',
		};
	}

	return config;
};

'''
'''--- src/img/near_icon.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 288 288"><g id="Layer_1" data-name="Layer 1"><path d="M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z"/></g></svg>
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DEMO NEAR NFT Market</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { initNear } from './near';

const initialState = {
	app: {
		mounted: false,
		tab: 1,
		sort: 2,
		filter: 1,
	},
	near: {
		initialized: false,
	},
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear());
};

'''
'''--- src/state/near.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';
import { getWallet, postSignedJson } from '../utils/near-utils';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

export const initNear = () => async ({ update, getState, dispatch }) => {
	const { near, wallet, contractAccount } = await getWallet();

	console.log(near);

	wallet.signIn = () => {
		wallet.requestSignIn(contractName, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
		update('', { account: null });
		update('app.tab', 1);
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 4);
		await update('', { near, wallet, contractAccount, account });
	}

	await update('', { near, wallet, contractAccount, account });
};

export const updateWallet = () => async ({ update, getState }) => {
	const { wallet } = await getState();
	wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
	await update('', { wallet });
};

'''
'''--- src/utils/near-utils.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName, contractMethods,
	accessKeyMethods,
} = getConfig();

const {
	Account,
	Contract,
	InMemorySigner,
} = nearAPI;

let near;

// alias
export const contractId = contractName;
export const marketId = 'market.' + contractName;

export const setSignerFromSeed = async (accountId, seedPhrase) => {
	const { secretKey } = parseSeedPhrase(seedPhrase);
	const keyPair = KeyPair.fromString(secretKey);
	near.connection.signer.keyStore.setKey(networkId, accountId, keyPair);
};
export function formatAccountId (accountId, len = 48) {
	if (accountId.length > len) {
		return accountId.substr(0, len - 3) + '...';
	}
	return accountId;
}

export function getContract(account, methods = contractMethods) {
	return new Contract(account, contractName, { ...methods });
}

export const getWallet = async () => {
	near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
	});
	const wallet = new nearAPI.WalletAccount(near);
	const contractAccount = new Account(near.connection, contractName);
	return { near, wallet, contractAccount };
};

export const getSignature = async (account, key) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

export const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
};

export const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({ ...data })
	}).then((res) => res.json());
};

export const createGuestAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, 'guests.' + contractName, key);
	const account = new Account(near.connection, 'guests.' + contractName);
	return account;
};

export const createAccessKeyAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, contractName, key);
	const account = new Account(near.connection, contractName);
	return account;
};

/********************************
Not used
********************************/

export const hasKey = async (near, accountId, publicKey) => {
	const pubKeyStr = publicKey.toString();
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		const accessKeys = await account.getAccessKeys();
		if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
			return true;
		}
	} catch (e) {
		console.warn(e);
	}
	return false;
};

export const isAccountTaken = async (accountId) => {
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		await account.state();
		return true;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return false;
};

export const getContractSigner = async ({ keyPair }) => {
	const signer = await InMemorySigner.fromKeyPair(networkId, contractName, keyPair);
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
	});
	const account = new nearAPI.Account(near.connection, contractName);
	const contract = await new nearAPI.Contract(account, contractName, {
		changeMethods: ['send', 'claim', 'create_account_and_claim'],
		sender: account
	});
	return { contract };
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
	let v = localStorage.getItem(k);
	if (typeof d !== 'object') {
		return v;
	}
	try {
		return JSON.parse(v || JSON.stringify(d));
	} catch (e) {
		return v;
	}
};
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = (k) => localStorage.removeItem(k);
'''
'''--- test/app.test.js ---
const fs = require('fs');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;
const { 
	connection, initContract, getAccount, getAccountBalance,
	contract, contractAccount, contractName, contractMethods, createAccessKeyAccount,
	createOrInitAccount,
	getContract,
} = testUtils;
const { 
	networkId, GAS, GUESTS_ACCOUNT_SECRET
} = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 100000;

describe('deploy contract ' + contractName, () => {
	let alice, aliceId, bob, bobId,
		stableAccount, marketAccount,
		storageMinimum, storageMarket;

	const metadata = {
		media: 'https://media1.tenor.com/images/4c1d96a989150e7019bfbabbebd2ff36/tenor.gif?itemid=20269144',
	};
	const metadata2 = {
		media: 'https://media1.tenor.com/images/818161c07948bac34aa7c5f5712ec3d7/tenor.gif?itemid=15065455',
	};
	const t = Date.now();
	const tokenIds = [
		'token' + t,
		'token' + (t + 1),
		'token' + (t + 2)
	];
	const tokenTypes = [
		'type' + t,
		'type' + (t + 1),
		'type' + (t + 2)
	];
	const contract_royalty = 500;

	/// contractAccount.accountId is the NFT contract and contractAccount is the owner
	/// see initContract in ./test-utils.js for details
	const contractId = contractAccount.accountId;
	console.log('\n\n contractId:', contractId, '\n\n');
	/// the fungible token "stablecoin" contract
	const stableId = 'stable.' + contractId;
	/// the market contract
	const marketId = 'market.' + contractId;

	beforeAll(async () => {
	    await initContract();

		alice = await getAccount();
		aliceId = alice.accountId;
		console.log('\n\n Alice accountId:', aliceId, '\n\n');

		bob = await getAccount();
		bobId = bob.accountId;
		console.log('\n\n Bob accountId:', bobId, '\n\n');

		await contractAccount.functionCall(contractName, 'set_contract_royalty', { contract_royalty }, GAS);
		await contractAccount.functionCall(contractName, 'add_token_type', { token_type: tokenTypes[0], hard_cap: '1' }, GAS);
		
		/// create or get stableAccount and deploy ft.wasm (if not already deployed)
		stableAccount = await createOrInitAccount(stableId, GUESTS_ACCOUNT_SECRET);
		const stableAccountState = await stableAccount.state();
		console.log('\n\nstate:', stableAccountState, '\n\n');
		if (stableAccountState.code_hash === '11111111111111111111111111111111') {
			const fungibleContractByes = fs.readFileSync('./out/ft.wasm');
			console.log('\n\n deploying stableAccount contractBytes:', fungibleContractByes.length, '\n\n');
			const newFungibleArgs = {
				/// will have totalSupply minted to them
				owner_id: contractName,
				total_supply: parseNearAmount('1000000'),
				name: 'Test Stable Coin',
				symbol: 'TSC',
				// not set by user request
				version: '1',
				reference: 'https://github.com/near/core-contracts/tree/master/w-near-141',
				reference_hash: '7c879fa7b49901d0ecc6ff5d64d7f673da5e4a5eb52a8d50a214175760d8919a',
				decimals: 24,
			};
			const actions = [
				deployContract(fungibleContractByes),
				functionCall('new', newFungibleArgs, GAS)
			];
			await stableAccount.signAndSendTransaction(stableId, actions);
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(stableId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
			/// pay storageMinimum for all the royalty receiving accounts
			const promises = [];
			for (let i = 1; i < 6; i++) {
				promises.push(stableAccount.functionCall(stableId, 'storage_deposit', { account_id: `a${i}.testnet` }, GAS, storageMinimum));
			}
			await Promise.all(promises);
		} else {
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(stableId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
		}

		/// create or get market account and deploy market.wasm (if not already deployed)
		marketAccount = await createOrInitAccount(marketId, GUESTS_ACCOUNT_SECRET);
		const marketAccountState = await marketAccount.state();
		console.log('\n\nstate:', marketAccountState, '\n\n');
		if (marketAccountState.code_hash === '11111111111111111111111111111111') {
			const marketContractBytes = fs.readFileSync('./out/market.wasm');
			console.log('\n\n deploying marketAccount contractBytes:', marketContractBytes.length, '\n\n');
			const newMarketArgs = {
				owner_id: contractId
			};
			const actions = [
				deployContract(marketContractBytes),
				functionCall('new', newMarketArgs, GAS)
			];
			await marketAccount.signAndSendTransaction(marketId, actions);
		}
		const supported = await marketAccount.viewFunction(marketId, "supports_token", { ft_token_id: stableId });
		console.log('\n\n market supports token:', stableId, supported, '\n\n');
		if (!supported) {
			await marketAccount.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum);
			const added = await contractAccount.functionCall(marketId, "add_token", { ft_token_id: stableId }, GAS);
			console.log('\n\n added token:', stableId, '\n\n');
		}

		/// find out how much needed for market storage
		storageMarket = await contractAccount.viewFunction(marketId, 'storage_amount');
		console.log('\n\n storageMarket:', storageMarket, '\n\n');
	});

	test('enumerable tests (no tokens)', async () => {
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('0');
		// messing around with index and limit
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', { account_id: bobId, from_index: '1001', limit: '1000' });
		console.log('\n\n bobTokens', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(0);
	});

	test('NFT contract owner mints nft and approves fixed price near sale', async () => {
		const token_id = tokenIds[0];
		await contractAccount.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await contractAccount.functionCall(contractId, 'nft_mint', {
			token_id,
			metadata,
			token_type: tokenTypes[0],
			perpetual_royalties: {
				'a1.testnet': 500,
				'a2.testnet': 250,
				'a3.testnet': 250,
				'a4.testnet': 250,
				'a5.testnet': 250,
			},
		}, GAS, parseNearAmount('1'));

		let sale_conditions = [
			{
				ft_token_id: 'near',
				price: parseNearAmount('1')
			}
		];

		await contractAccount.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({ sale_conditions })
		}, GAS, parseNearAmount('0.01'));

		const sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions.near).toEqual(parseNearAmount('1'));
	});

	test('token transfer locked - owner unlocks token transfer token type', async () => {
		const token_id = tokenIds[0];
		try {
			await contractAccount.functionCall(contractId, 'nft_transfer', {
				receiver_id: bobId,
				token_id
			}, 1);
			expect(false);
		} catch(e) {
			expect(true);
		}
		await contractAccount.functionCall(contractName, 'unlock_token_type', { token_type: tokenTypes[0] }, GAS);
		const tokenLocked = await contractAccount.viewFunction(contractName, 'is_token_locked', { token_id });
		expect(tokenLocked).toEqual(false);
		const tokenTypeLocked = await contractAccount.viewFunction(contractName, 'is_token_type_locked', { token_type: tokenTypes[0] });
		expect(tokenTypeLocked).toEqual(false);
	});

	test('get sales by owner id', async () => {
		const sales_by_owner_id = await contractAccount.viewFunction(marketId, 'get_sales_by_owner_id', {
			account_id: contractId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n', sales_by_owner_id, '\n\n');
		expect(sales_by_owner_id.length).toEqual(1);
	});

	test('get sales by nft contract id', async () => {
		const sales_by_nft_contract_id = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_contract_id', {
			nft_contract_id: contractId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n', sales_by_nft_contract_id, '\n\n');
		expect(sales_by_nft_contract_id.length > 0).toEqual(true);
	});

	test('bob purchase nft with NEAR', async () => {
		const token_id = tokenIds[0];
		const contractBalanceBefore = await getAccountBalance(contractId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('1'));
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(bobId);
		// check contract balance went up by over 80% of 1 N
		const contractBalanceAfter = await getAccountBalance(contractId);
		expect(new BN(contractBalanceAfter.total).sub(new BN(contractBalanceBefore.total)).gt(new BN(parseNearAmount('0.79')))).toEqual(true);
	});

	test('contract account registers bob with market contract', async () => {
		await contractAccount.functionCall(marketId, 'storage_deposit', { account_id: bobId }, GAS, storageMarket).catch(() => {});
		const result = await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: bobId });
		expect(result).toEqual(true);
	});

	test('bob approves sale with FT and NEAR (fixed prices)', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum).catch(() => {});
		const token = await contract.nft_token({ token_id });
		let sale_conditions = [
			{
				ft_token_id: stableId,
				price: parseNearAmount('25')
			},
			{
				ft_token_id: 'near',
				price: parseNearAmount('5')
			}
		];

		console.log('\n\n sale_conditions.length', sale_conditions.length, '\n\n');
		console.log('\n\n token.royalty.length', token.royalty.length, '\n\n');

		if (sale_conditions.length + token.royalty.length > 8) {
			throw new Error("Cannot have more than 8 royalties + sale collateral at the same time");
		}

		await bob.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({ sale_conditions })
		}, GAS, parseNearAmount('0.01'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions[stableId]).toEqual(parseNearAmount('25'));
	});

	test('enumerable tests', async () => {
		const total_supply = await bob.viewFunction(contractName, 'nft_total_supply', {});
		console.log('\n\n total_supply', total_supply, '\n\n');
		// could be several tests in, with many tokens minted
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('1');
		const tokens = await bob.viewFunction(contractName, 'nft_tokens', { from_index: '0', limit: '1000' });
		console.log('\n\n tokens', tokens, '\n\n');
		// proxy for total supply with low limits, could be several tests in, with many tokens minted
		expect(tokens.length > 0).toEqual(true);
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', { account_id: bobId, from_index: '0', limit: '1000' });
		console.log('\n\n bobTokens', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(1);
	});
    
	test('bob changes price of FTs', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall(marketId, 'update_price', {
			nft_contract_id: contractId,
			token_id,
			ft_token_id: stableId,
			price: parseNearAmount('20')
		}, GAS);
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions[stableId]).toEqual(parseNearAmount('20'));
	});

	test('contract owner makes low bid', async () => {
		const token_id = tokenIds[0];
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await contractAccount.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,            
		}, GAS, parseNearAmount('1'));
		
		/// check sale should have 2 N bid for near from contract owner
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(contractId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1'));
	});

	test('alice outbids contract owner', async () => {
		const token_id = tokenIds[0];

		const contractBalanceBefore = await getAccountBalance(contractId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('1.1'));
		
		/// check sale should have 1.1 N bid for near from alice
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1.1'));

		// contract owner gets back 1 N - gas > 0.9
		const contractBalanceAfter = await getAccountBalance(contractId);

		expect(new BN(contractBalanceAfter.total).sub(new BN(contractBalanceBefore.total)).gt(new BN(parseNearAmount('0.9')))).toEqual(true);
	});

	test('alice gets 100 FTs', async () => {
		await alice.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum);
		let amount = parseNearAmount('100');
		await contractAccount.functionCall(stableId, 'ft_transfer', {
			receiver_id: aliceId,
			amount
		}, GAS, 1);
		/// check balance
		const balance = await contractAccount.viewFunction(stableId, 'ft_balance_of', { account_id: aliceId });
		expect(balance).toEqual(amount);
	});

	test('alice purchase NFT with FT', async () => {
		const token_id = tokenIds[0];

		const aliceBalanceBefore = await getAccountBalance(aliceId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall(stableId, 'ft_transfer_call', {
			receiver_id: marketId,
			amount: parseNearAmount('20'),
			msg: JSON.stringify({
				nft_contract_id: contractName,
				token_id,
			})
		}, GAS, 1);
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		/// check token balances
		const aliceBalance = await alice.viewFunction(stableId, 'ft_balance_of', { account_id: aliceId });
		expect(aliceBalance).toEqual(parseNearAmount('80'));
		const marketBalance = await marketAccount.viewFunction(stableId, 'ft_balance_of', { account_id: marketId });
		console.log('\n\n marketBalance', marketBalance, '\n\n');
		/// bob gets 80% of the FTs
		const bobBalance = await bob.viewFunction(stableId, 'ft_balance_of', { account_id: bobId });
		expect(bobBalance).toEqual(parseNearAmount('16'));
		// alice's bid of 1.1 NEAR was returned (check N diff > than 1.1 - gas)
		const aliceBalanceAfter = await getAccountBalance(aliceId);
		expect(new BN(aliceBalanceAfter.total).sub(new BN(aliceBalanceBefore.total)).gt(new BN(parseNearAmount('1')))).toEqual(true);
	});

	/// near bid

	test('bob fails to mint past hard cap for token type', async () => {
		const token_id = tokenIds[1];
		try {
			await bob.functionCall(contractId, 'nft_mint', {
				token_id,
				metadata,
				token_type: tokenTypes[0]
			}, GAS, parseNearAmount('1'));
			expect(false);
		} catch (e) {
			expect(true);
		}
		const hardCap = await bob.viewFunction(contractId, 'nft_supply_for_type', { token_type: tokenTypes[0] });
		expect(hardCap).toEqual('1');
	});

	test('bob: nft mint (no type), approve sale with NEAR open for bids', async () => {
		const token_id = tokenIds[1];
		await bob.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await bob.functionCall(contractId, 'nft_mint', {
			token_id,
			metadata: metadata2,
			perpetual_royalties: {
				[bobId]: 500,
			},
		}, GAS, parseNearAmount('1'));
		await bob.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({
				sale_conditions: [{
					ft_token_id: 'near',
				}]
			})
		}, GAS, parseNearAmount('0.01'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions["near"]).toEqual(parseNearAmount('0'));
	});

	test('alice bid with NEAR', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('0.2'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('0.2'));
	});

	test('bob accept bid', async () => {
		const token_id = tokenIds[1];
		const bobBalanceBefore = await getAccountBalance(bobId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall(marketId, 'accept_offer', {
			nft_contract_id: contractName,
			token_id,
			ft_token_id: 'near',
		}, GAS);
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		const bobBalanceAfter = await getAccountBalance(bobId);
		/// bob got close to 0.18 N (95% - gas) from this sale
		expect(new BN(bobBalanceAfter.total).sub(new BN(bobBalanceBefore.total)).gt(new BN(parseNearAmount('0.17')))).toEqual(true);
	});

	/// for testing frontend

	test('alice lingering sale in marketplace', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await alice.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			perpetual_royalties: {
				[aliceId]: 500,
			},
			msg: JSON.stringify({
				sale_conditions: [{
					ft_token_id: 'near',
				}]
			})
		}, GAS, parseNearAmount('0.01'));
	});

});
'''
'''--- test/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near, Account, Contract, KeyPair,
	utils: {
		format: {
			parseNearAmount
		}
	}
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = new InMemoryKeyStore();
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key));
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) => contractAccount.addKey(publicKey, contractName, contractMethods.changeMethods, parseNearAmount('0.1'));
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	contractMethods,
};
'''
'''--- test/server.test.js ---
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { Account, KeyPair, utils: { format: { parseNearAmount }} } = nearAPI;
const { near, TEST_HOST, initContract, getAccount, contractAccount: ownerAccount, postJson } = testUtils;
const { GAS, contractName: ownerId, networkId } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy API owned by: ' + ownerId, () => {
	let alice, contractAlice, bob, bobId, bobAccount;
	const name = `token-${Date.now()}`;
	const tokenId = `${name}.${ownerId}`;
	const guestId = 'guests.' + ownerId;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract();
	});

	/// API
	test('deploy token', async () => {
		const { success, result } = await postJson({
			url: TEST_HOST + '/launch-token',
			data: {
				name,
				symbol: 'TEST',
				totalSupply: parseNearAmount('1000000'),
			}
		});
		expect(success).toEqual(true);
	});

	/// API
	test('add guest user', async () => {
		bobId = 'bob.' + tokenId;
		const keyPair = KeyPair.fromRandom('ed25519');
		/// bob's key signs tx from guest account (sponsored)
		near.connection.signer.keyStore.setKey(networkId, guestId, keyPair);
		bobAccount = new Account(near.connection, guestId);

		const { success, result } = await postJson({
			url: TEST_HOST + '/add-guest',
			data: {
				account_id: bobId,
				public_key: keyPair.publicKey.toString(),
			}
		});
		expect(success).toEqual(true);
	});

	/// CLIENT
	test('bob guest claim drop self', async () => {
		await bobAccount.functionCall(tokenId, 'claim_drop', {}, GAS);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('100'));
	});

	/// CLIENT
	test('owner transfer tokens to guest (client)', async () => {
		await ownerAccount.functionCall(tokenId, 'ft_transfer', {
			receiver_id: bobId,
			amount: parseNearAmount('50'),
		}, GAS, 1);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('150'));
	});

	/// API
	test('owner transfer tokens to guest (api)', async () => {
		const { success, result } = await postJson({
			url: TEST_HOST + '/transfer-tokens',
			data: {
				tokenId,
				receiver_id: bobId,
				amount: parseNearAmount('50'),
			}
		});
		expect(success).toEqual(true);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('200'));
	});

	/// CLIENT
	test('bob guest transfer to alice', async () => {
		/// send tokens to alice who needs to register her storage
		const storageMinimum = await alice.viewFunction(tokenId, 'storage_minimum_balance', {});
		await alice.functionCall(tokenId, 'storage_deposit', {}, GAS, storageMinimum);
		const amount = parseNearAmount('100');
		await bobAccount.functionCall(tokenId, 'ft_transfer_guest', { receiver_id: alice.accountId, amount }, GAS);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(amount);
		const balance2 = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: alice.accountId }, GAS);
		expect(balance2).toEqual(amount);
	});

	/// CLIENT
	test('bob upgrades to full account', async () => {
		const keyPair = KeyPair.fromRandom('ed25519');
		const keyPair2 = KeyPair.fromRandom('ed25519');
		const public_key = keyPair.publicKey.toString();
		const public_key2 = keyPair2.publicKey.toString();
		near.connection.signer.keyStore.setKey(networkId, bobId, keyPair);
		await bobAccount.functionCall(tokenId, 'upgrade_guest', {
			public_key,
			access_key: public_key2,
			method_names: '',
		}, GAS);
		/// update account and contract for bob (bob now pays gas)
		const balance = await testUtils.getAccountBalance(bobId);
		/// creating account only moves 0.5 NEAR and the rest is still wNEAR
		expect(balance.total).toEqual(parseNearAmount('0.5'));
	});

});
'''
'''--- test/test-utils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('../src/config');
const {
	networkId, contractName, contractMethods,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
} = getConfig();

const TEST_HOST = 'http://localhost:3000';
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			owner_id: contractAccount.accountId,
			metadata: {
				spec: 'nft-1',
				name: 'Test NFT',
				symbol: 'TNFT',
			},
			supply_cap_by_type: {
				test: '1000000',
			}
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const createOrInitAccount = async(accountId, secret) => {
	let account;
	try {
		account = await createAccount(accountId, DEFAULT_NEW_CONTRACT_AMOUNT, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));

		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
	}
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

module.exports = { 
	TEST_HOST,
	near,
	connection,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
};
'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''