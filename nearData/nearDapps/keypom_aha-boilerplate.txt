*GitHub Repository "keypom/aha-boilerplate"*

'''--- README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

'''
'''--- __tests__/create-tix.js ---
const path = require("path");
const homedir = require("os").homedir();
const { KeyPair } = require("@near-js/crypto");
const { createHash } = require("crypto");
const { readFileSync } = require('fs');
const { writeFile, mkdir, readFile } = require('fs/promises');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require('@near-js/accounts');
const { connect, Near } = require("@near-js/wallet-account");
const { parseNearAmount } = require('@near-js/utils');

const NETWORK_ID = 'testnet';

const funderAccountId = 'benjiman.testnet';
const mintbaseContract = "keypom.market.mintspace2.testnet";
const nearconFactory = "keypom-factory.keypom.testnet";
const keypomContract = "nearcon2023.keypom.testnet";

const originalTicketOwner = "benjiman.testnet";
const createDrop = false;
const numKeys = 10;
const numOwners = 0;

const baseUrl = "https://test.near.org/nearpad.testnet/widget/Index?tab=ticket";
const dropId = "nearcon2023";
let basePassword = "nearcon2023-password";

const main = async () => {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const funderAccount = new Account(near.connection, funderAccountId);
    console.log('funderAccount: ', funderAccount)
    const keypomAccount = new Account(near.connection, keypomContract);
    const nearconAccount = new Account(near.connection, nearconFactory);

    await keypomAccount.functionCall({
        contractId: mintbaseContract,
        methodName: 'deposit_storage',
        args: {},
        gas: 300000000000000,
        attachedDeposit: parseNearAmount("10")
    })

    let sellerKeys = await createNearconDrop({
        createDrop,
        funderAccount,
        keypomAccount,
        nearconAccount,
        originalTicketOwner,
        numKeys,
        numOwners,
      });

      let stringToWrite = '';
      // Loop through each secret key
      var i = 0;
      for (const sk of sellerKeys.keys) {
          stringToWrite += `${baseUrl}&secretKey=${sk}&contractId=${keypomContract}` + '\n';
          i++;
      }
  
      await writeFile(path.resolve(__dirname, 'nearcon-keys.json'), stringToWrite);
}

const createNearconDrop = async ({
    createDrop,
    funderAccount,
    keypomAccount,
    nearconAccount,
    originalTicketOwner,
    numKeys,
    numOwners
  }) => {
    let assetData = [
      {uses: 1, assets: [null], config: {permissions: "claim"}}, // Password protected scan into the event
      {uses: 1, assets: [null], config: {permissions: "create_account_and_claim", account_creation_keypom_args: {drop_id_field: "drop_id"}, root_account_id: nearconAccount.accountId}},
        // Create their trial account, deposit their fungible tokens, deploy the contract & call setup
    ];

    if (createDrop == true) {
      await funderAccount.functionCall({
        contractId: keypomAccount.accountId,
        methodName: 'create_drop',
        args: {
          drop_id: dropId,
          key_data: [],
          drop_config: {
              delete_empty_drop: false,
              extra_allowance_per_key: parseNearAmount("0.02").toString()
          },
          asset_data: assetData,
          keep_excess_deposit: true
        },
        gas: 300000000000000,
        attachedDeposit: parseNearAmount("100").toString()
    });
    }
    
  let keyData = {
    keys: [],
    publicKeys: []
  };
  // Loop through from 0 -> numKeys 50 at a time
    for (let i = 0; i < numKeys; i += 50) {
        let {keys, publicKeys} = await addKeys({
            funderAccount,
            keypomAccount,
            originalTicketOwner,
            numKeys: Math.min(numKeys - i, 50),
            numOwners: Math.min(numOwners - i, 50),
            dropId
        })

        keyData.keys = keyData.keys.concat(keys);
        keyData.publicKeys = keyData.publicKeys.concat(publicKeys);
    }
    return keyData;
}

const addKeys = async ({
  funderAccount,
  keypomAccount,
  originalTicketOwner,
  numKeys,
  numOwners,
  dropId,
}) => {
  let { keys, publicKeys } = await generateKeyPairs(numKeys);
  let keyData = [];
  
  let idx = 0;
  for (var pk of publicKeys) {
    let password_by_use = generatePasswordsForKey(pk, [1], basePassword);
    keyData.push({
      public_key: pk,
      password_by_use,
      key_owner: idx < numOwners ? originalTicketOwner.accountId : null,
    });
    idx += 1;
  }

  await funderAccount.functionCall({
    contractId: keypomAccount.accountId,
    methodName: 'add_keys',
    args: {
      drop_id: dropId,
      key_data: keyData,
    },
    gas: 300000000000000,
    attachedDeposit: parseNearAmount("20").toString()
  });

  return { keys, publicKeys };
};

function hash(string, double = false) {
  if (double) {
    return createHash("sha256")
      .update(Buffer.from(string, "hex"))
      .digest("hex");
  }

  return createHash("sha256").update(Buffer.from(string)).digest("hex");
}

function generatePasswordsForKey(
  pubKey,
  usesWithPassword,
  basePassword
) {
  let passwords = {};

  // Loop through usesWithPassword
  for (var use of usesWithPassword) {
    passwords[use] = hash(hash(basePassword + pubKey + use.toString()), true);
  }

  return passwords;
}

async function generateKeyPairs(
  numKeys
 ) {
  // Generate NumKeys public keys
  let kps = [];
  let pks = [];
  for (let i = 0; i < numKeys; i++) {
    let keyPair = await KeyPair.fromRandom("ed25519");
    kps.push(keyPair);
    pks.push(keyPair.getPublicKey().toString());
  }
  return {
    keys: kps,
    publicKeys: pks,
  };
}

main()
'''
'''--- __tests__/nearcon-keys.json ---
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:4vaNpEd7j4ZjdSHjuvrYJgJ9fPm8mw11Txr56WN8S8ArwAweaqAtSEGDWRHP5Ux9TMwpNjoKBz7eu829eac2CYiB&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:2Gr3Q8pwz7cbavqKy21wpgYwiLPnBiYBnpFsGoUxAygGYrG5HSvxUocGaNMKkj5wPKizfWA4yaBSdBiKaKrDcrVm&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:2bbTJhBzEBGDRWU2TeqtqFd8aP7FhrsfZpa3gcCAMNw7UkgMCAfiznc1DnJkdrnKoiJYsegZ9Em4WHCKqmb9tRP&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:43LXW4ejFcaMpUffuEVTUpcpzc4QLbzjsAKXFbU8knCmgxbkq9QF3YwNh8HVADQZt8s8e32FiH4W5v9bchGR9bPq&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:34Firjs8pwLbKgrwT31Avo9R5j2LLP3pBPPXuWRnKFybFJxmnu9zPvsypSjeYyLRD52gmAHsxfzumYJvxMiZXjfh&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:3M1pievnYVtEasPy6tntPXQoWRWn5CLP6ebZJkcw2ZbWNXyESMj2KiLLLimQGUA9mUAGicVBr45yacjbsWGT1h8N&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:5UdDUUynQ8Ke5X2LmxXEbkn4RdcyX2vrqCCUA4o2jRNVRyB3GMFCZgTZYwQDw7wEJjUJhdAQPChN5Bi5aJqchPVR&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:2t4Yi5qqYPUAcVNQxbwHiysasybWzfzMzERe6MAd7S7r1NJMuxkTskdwsNTysvwWmwSesmG8q9qd7sJopqqzrs8Y&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:2z3tbU8fDZd1MbhEZ3GzZGh6sUWtQDibFhHZJHLoJvtusqXnbJEWaoHcAV6TTEzZgsufY8tomzf2Hivpb1KJ93zg&contractId=nearcon2023.keypom.testnet
https://test.near.org/nearpad.testnet/widget/Index?tab=ticket&secretKey=ed25519:5jyaUeDvSLMhc3CwAxTefwzpEio9hkqJ2p2mJ3Ea9n6NJmqHMzike7ZPWUq3D5efE3rG7HaH4bPH2VZcWpRQMapK&contractId=nearcon2023.keypom.testnet

'''
'''--- __tests__/nearcon/nearcon.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import {
  CONTRACT_METADATA,
  claimAndAssertAccountCreated,
  claimWithRequiredGas,
  generateKeyPairs,
  generatePasswordsForKey,
  hash,
} from "../utils/keypom";
import { functionCall } from "../utils/workspaces";
import { createNearconDrop, sellNFT } from "./utils";
import {
  ExtDrop,
  ExtKeyInfo,
  ExtNFTKey,
  ListingJson,
  TrialRules,
} from "../utils/types";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  console.log("Starting test");
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etc.
  const root = worker.rootAccount;
  await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

  const keypom = await root.createSubAccount("keypom");
  await keypom.deploy(`./__tests__/ext-wasm/keypom.wasm`);
  console.log("Deployed Keypom");

  const mintbase = await root.createSubAccount("mintbase");
  await mintbase.deploy(`./__tests__/ext-wasm/mintbase-new.wasm`);
  console.log("Deployed Mintbase");

  const nearcon = await root.createSubAccount("nearcon");
  await nearcon.deploy(`./out/factory.wasm`);
  console.log("Deployed Nearcon");

  // Init empty/default linkdrop contract
  await root.call(root, "new", {});
  await keypom.call(keypom, "new", {
    root_account: "test.near",
    owner_id: keypom,
    contract_metadata: CONTRACT_METADATA,
  });
  await mintbase.call(mintbase, "init", {
    owner: mintbase,
    mintbase_cut: 0,
    fallback_cut: 0,
    listing_lock_seconds: "0",
    keypom_contract_root: keypom.accountId,
  });
  await nearcon.call(nearcon, "new", {
    allowed_drop_id: "nearcon-drop",
    keypom_contract: keypom.accountId,
    starting_ncon_balance: NEAR.parse("1").toString(),
    starting_near_balance: NEAR.parse("1").toString(),
  });
  console.log("Initialized contracts");

  await keypom.call(
    mintbase,
    "deposit_storage",
    {},
    { attachedDeposit: NEAR.parse("10").toString() }
  );

  // Test users
  const funder = await root.createSubAccount("funder");
  const originalTicketOwner = await root.createSubAccount("og-ticket-owner");
  const newTicketBuyer = await root.createSubAccount("new-ticket-buyer");

  // Add 10k $NEAR to owner's account
  await funder.updateAccount({
    amount: NEAR.parse("10000 N").toString(),
  });
  await funder.call(
    keypom,
    "add_to_balance",
    {},
    { attachedDeposit: NEAR.parse("5000").toString() }
  );

  // Save state for test runs
  t.context.worker = worker;
  t.context.accounts = {
    root,
    keypom,
    nearcon,
    funder,
    newTicketBuyer,
    originalTicketOwner,
    mintbase,
  };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to tear down the worker:", error);
  });
});

test("Journey 3: New to NEAR Purchases & Sells on Secondary Marketplace", async (t) => {
  const {
    keypom,
    funder,
    nearcon,
    newTicketBuyer,
    originalTicketOwner,
    root,
    mintbase,
  } = t.context.accounts;
  let sellerKeys = await createNearconDrop({
    funder,
    keypom,
    nearcon,
    originalTicketOwner,
    numKeys: 1,
    numOwners: 0,
  });

  let nfts: Array<ExtNFTKey> = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 1);
  t.is(nfts[0].owner_id, keypom.accountId);

  const buyerKeys = await generateKeyPairs(1);
  await sellNFT({
    t,
    keypom,
    mintbase,
    seller: keypom,
    buyer: newTicketBuyer,
    sellerKeys,
    buyerKeys,
    tokenId: `nearcon-drop:0`,
  });

  // Now that the key was bought, a new $NEAR drop should have been created
  nfts = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 2);

  // Claim seller key and create new account
  let newAccountId = `benji.${root.accountId}`;
  await claimWithRequiredGas({
    keypom,
    root,
    keyPair: sellerKeys.keys[0],
    receiverId: newAccountId,
    createAccount: true,
    useLongAccount: false,
    useImplicitAccount: false,
    shouldPanic: false,
  });
  try {
    const keyInfo = await keypom.view("get_key_information", {
      key: sellerKeys.publicKeys[0],
    });
    t.fail();
  } catch (e) {
    t.pass();
  }

  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: buyerKeys.keys[0],
    receiverId: "foo",
    password: hash("nearcon23-password" + `0` + "1"),
    shouldPanic: false,
  });

  await claimAndAssertAccountCreated({
    t,
    keypom,
    nearcon,
    keyPair: buyerKeys.keys[0],
  });

  nfts = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 0);
});

test("Journey 2: Crypto Native Purchases & Attends Conference", async (t) => {
  const {
    keypom,
    funder,
    nearcon,
    newTicketBuyer,
    originalTicketOwner,
    root,
    mintbase,
  } = t.context.accounts;
  let { keys, publicKeys } = await createNearconDrop({
    funder,
    keypom,
    nearcon,
    originalTicketOwner,
    numKeys: 1,
    numOwners: 1,
  });

  let nfts: Array<ExtNFTKey> = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 1);
  t.is(nfts[0].owner_id, originalTicketOwner.accountId);

  // This should panic because no password is passed in
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    shouldPanic: true,
  });

  // This should pass because the password is correct
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    password: hash("nearcon23-password" + `0` + "1"),
    shouldPanic: false,
  });

  let keyInfo: ExtKeyInfo = await keypom.view("get_key_information", {
    key: publicKeys[0],
  });
  console.log("keyInfo: ", keyInfo);
  t.is(keyInfo.uses_remaining, 1);

  await claimAndAssertAccountCreated({
    t,
    keypom,
    nearcon,
    keyPair: keys[0],
  });

  nfts = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 0);
});

test("Journey 1: New to NEAR Purchases & Attends Conference", async (t) => {
  const {
    keypom,
    funder,
    nearcon,
    newTicketBuyer,
    originalTicketOwner,
    root,
    mintbase,
  } = t.context.accounts;
  let { keys, publicKeys } = await createNearconDrop({
    funder,
    keypom,
    originalTicketOwner,
    nearcon,
    numKeys: 1,
    numOwners: 0,
  });

  let nfts: Array<ExtNFTKey> = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 1);
  t.is(nfts[0].owner_id, keypom.accountId);

  // This should panic because no password is passed in
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    shouldPanic: true,
  });

  // This should pass because the password is correct
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    password: hash("nearcon23-password" + `0` + "1"),
    shouldPanic: false,
  });

  let keyInfo: ExtKeyInfo = await keypom.view("get_key_information", {
    key: publicKeys[0],
  });
  console.log("keyInfo: ", keyInfo);
  t.is(keyInfo.uses_remaining, 1);

  await claimAndAssertAccountCreated({
    t,
    keypom,
    nearcon,
    keyPair: keys[0],
  });
  nfts = await keypom.view("nft_tokens");
  console.log("nfts: ", nfts);
  t.is(nfts.length, 0);
});

test("Creating Lots of Keys & Claiming", async (t) => {
  const {
    keypom,
    funder,
    nearcon,
    newTicketBuyer,
    originalTicketOwner,
    root,
    mintbase,
  } = t.context.accounts;
  let { keys, publicKeys } = await createNearconDrop({
    funder,
    keypom,
    nearcon,
    originalTicketOwner,
    numKeys: 75,
    numOwners: 25,
  });

  let numNfts = await keypom.view("nft_total_supply");
  console.log("numNfts: ", numNfts);
  t.is(numNfts, "75");

  let nftsOwned = await keypom.view("nft_supply_for_owner", {
    account_id: originalTicketOwner.accountId,
  });
  console.log("nftsOwned: ", nftsOwned);
  t.is(nftsOwned, "25");

  // This should panic because no password is passed in
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    shouldPanic: true,
  });

  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair: keys[0],
    receiverId: "foo",
    password: hash("nearcon23-password" + `0` + "1"),
  });

  await claimAndAssertAccountCreated({
    t,
    keypom,
    nearcon,
    keyPair: keys[0],
  });
});

'''
'''--- __tests__/nearcon/utils.ts ---
import { BN } from "bn.js";
import { KeyPair, NEAR, NearAccount } from "near-workspaces";
import { ExtDrop, ExtKeyInfo, ListingJson } from "../utils/types";
import { addKeys, generateKeyPairs, generatePasswordsForKey, getKeyInformation } from "../utils/keypom";
import { functionCall } from "../utils/workspaces";

export const sellNFT = async ({
    keypom, 
    mintbase, 
    seller, 
    buyer, 
    sellerKeys, 
    buyerKeys, 
    t, 
    tokenId
}: {
    keypom: NearAccount;
    mintbase: NearAccount;
    seller: NearAccount;
    buyer: NearAccount;
    sellerKeys: { keys: KeyPair[]; publicKeys: string[] };
    buyerKeys: { keys: KeyPair[]; publicKeys: string[] };
    t: any;
    tokenId: string;
}) => {
    await keypom.setKey(sellerKeys.keys[0]);
    let new_mintbase_args = JSON.stringify({
        price: NEAR.parse('1').toString(),
        owner_pub_key: seller == keypom ? sellerKeys.publicKeys[0] : undefined
    })
    let nftApproveArgs = {account_id: mintbase.accountId, msg: new_mintbase_args}
    console.log('nftApproveArgs: ', nftApproveArgs)
    await keypom.call(keypom, 'nft_approve', nftApproveArgs);
    let getListingArgs = {nft_contract_id: keypom.accountId, token_id: tokenId}
    console.log('getListingArgs: ', getListingArgs)
    let listing: ListingJson = await mintbase.view('get_listing', getListingArgs);
    console.log('listing: ', listing)
    t.assert(listing.nft_token_id === tokenId);
    t.assert(listing.price === NEAR.parse('1').toString());
    t.assert(listing.nft_owner_id === seller.accountId);
    t.assert(listing.nft_contract_id === keypom.accountId);
    t.assert(listing.currency === 'near');

    /// Buyer purchases the key
    await functionCall({
        signer: buyer,
        receiver: mintbase,
        methodName: "buy",
        args: {nft_contract_id: keypom.accountId, token_id: tokenId, new_pub_key: buyerKeys.publicKeys[0]},
        attachedDeposit: NEAR.parse('1').toString(),
        gas: '300000000000000',
        shouldPanic: false,
    });

    // Now that buyer bought the key, his key should have the same allowance as what seller left off with and should have all remaining uses
    let keyInfo = await getKeyInformation(keypom, buyerKeys.publicKeys[0]);
    console.log('keyInfo after purchase: ', keyInfo)
    t.is(keyInfo.owner_id, buyer.accountId);
    t.is(keyInfo.uses_remaining, 2);

    try {
        // Seller should now have a simple $NEAR drop with 0.05 $NEAR less than the 1 $NEAR purchase price
        let dropId = sellerKeys.publicKeys[0].split('ed25519:')[1];
        let sellerNewDrop: ExtDrop = await keypom.view('get_drop_information', {drop_id: dropId});
        console.log('sellerNewDrop: ', sellerNewDrop)
        if (seller == keypom) {
            t.is(sellerNewDrop.asset_data.length, 1);
            t.is(sellerNewDrop.asset_data[0].uses, 1);

            let sellerNewKey: ExtKeyInfo = await keypom.view('get_key_information', {key: sellerKeys.publicKeys[0]});
            console.log('sellerNewKey: ', sellerNewKey)
            t.is(sellerNewKey.uses_remaining, 1);
            t.is(sellerNewKey.owner_id, keypom.accountId);
            t.is(sellerNewKey.yoctonear, NEAR.parse('0.95').toString())
        } else {
            t.fail();
        }
    } catch(e) {
        console.log('e: ', e)
        seller == keypom ? t.fail() : t.pass();
    }
}

export const createNearconDrop = async ({
    funder,
    keypom,
    nearcon,
    originalTicketOwner,
    numKeys,
    numOwners
  }: {
    funder: NearAccount;
    keypom: NearAccount;
    nearcon: NearAccount;
    originalTicketOwner: NearAccount;
    numKeys: number;
    numOwners: number;
  }): Promise<{ keys: KeyPair[]; publicKeys: string[] }> => {
    const dropId = "nearcon-drop";
  let assetData = [
      {uses: 1, assets: [null], config: {permissions: "claim"}}, // Password protected scan into the event
      {uses: 1, assets: [null], config: {permissions: "create_account_and_claim", account_creation_keypom_args: {drop_id_field: "drop_id"}, root_account_id: nearcon.accountId}},
    ];
  await functionCall({
      signer: funder,
      receiver: keypom,
      methodName: 'create_drop',
      args: {
          drop_id: dropId,
          key_data: [],
          drop_config: {
              delete_empty_drop: false,
              extra_allowance_per_key: NEAR.parse("0.02")
          },
          asset_data: assetData,
          keep_excess_deposit: true
      },
      attachedDeposit: NEAR.parse("21").toString()
  })

  let keyData = {
    keys: [],
    publicKeys: []
  };
  // Loop through from 0 -> numKeys 50 at a time
    for (let i = 0; i < numKeys; i += 50) {
        let {keys, publicKeys} = await addKeys({
            funder,
            keypom,
            originalTicketOwner,
            numKeys: Math.min(numKeys - i, 50),
            numOwners: Math.min(numOwners - i, 50),
            dropId
        })

        keyData.keys = keyData.keys.concat(keys as never[]);
        keyData.publicKeys = keyData.publicKeys.concat(publicKeys as never[]);
    }
    return keyData;
}
'''
'''--- __tests__/tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { generateKeyPairs } from "./utils/keypom";
import { TrialRules } from "./utils/types";
import { parseExecutionResults } from "./utils/workspaces";
const { readFileSync } = require("fs");

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
  rpcPort: string;
}>;

test.beforeEach(async (t) => {
  console.log(t.title);
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  const rpcPort = (worker as any).config.rpcAddr;
  console.log(`rpcPort: `, rpcPort);

  // Prepare sandbox for tests, create accounts, deploy contracts, etc.
  const root = worker.rootAccount;

  const nearcon = await root.createSubAccount("nearcon23");

  // Deploy the keypom contract.
  await nearcon.deploy(`./out/factory.wasm`);

  await nearcon.call(nearcon, "new", {
    allowed_drop_id: "nearcon-drop",
    keypom_contract: "keypom.test.near",
    starting_ncon_balance: NEAR.parse("1").toString(),
    starting_near_balance: NEAR.parse("1").toString(),
  });

  let initialBal = await nearcon.view("ft_total_supply");
  t.is(initialBal, "0");

  // Test users
  const funder = await root.createSubAccount("funder");
  const admin = await root.createSubAccount("admin");
  const foodVendor = await root.createSubAccount("food_vendor");
  const merchVendor = await root.createSubAccount("merch_vendor");

  // Save state for test runs
  t.context.worker = worker;
  t.context.accounts = {
    root,
    nearcon,
    funder,
    admin,
    foodVendor,
    merchVendor,
  };
  t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to tear down the worker:", error);
  });
});

test("Create Duplicate Accounts", async (t) => {
  const { root, nearcon, funder } = t.context.accounts;
  const rpcPort = t.context.rpcPort;
  const dropId = "nearcon-drop";
  const keys = await generateKeyPairs(1);
  const newAccountId = `benji.${nearcon.accountId}`;

  // Loop 3 times
  for (let i = 0; i < 3; i++) {
    let rawVal = await nearcon.callRaw(nearcon, "create_account", {
      new_account_id: newAccountId,
      new_public_key: keys.publicKeys[0],
      drop_id: dropId,
      keypom_args: {
        drop_id_field: "drop_id",
      },
    });

    parseExecutionResults(
      "create_account",
      nearcon.accountId,
      rawVal,
      true,
      false
    );

    let expectedAccountId =
      i == 0 ? `benji.${nearcon.accountId}` : `benji-${i}.${nearcon.accountId}`;
    let account = root.getAccount(expectedAccountId);
    let doesExist = await account.exists();
    t.is(doesExist, true, `Account ${expectedAccountId} does not exist`);

    let keyList = await account.viewAccessKeys(expectedAccountId);
    console.log('keyList: ', keyList)
    t.assert(keyList.keys.length === 1);
    t.assert(keyList.keys[0].access_key.permission === "FullAccess");

    let ftBalance = await nearcon.view("ft_balance_of", {
      account_id: expectedAccountId,
    });
    console.log("ftBalance: ", ftBalance);
    t.is(ftBalance, NEAR.parse("1").toString());

    let totalSupply = await nearcon.view("ft_total_supply");
    console.log("totalSupply: ", totalSupply);
    t.is(totalSupply, NEAR.parse((i + 1).toString()).toString());
  }
});

test("Adding Vendor Items", async (t) => {
  const { root, nearcon, funder, admin, merchVendor, foodVendor } =
    t.context.accounts;

  await nearcon.call(nearcon, "add_admin", { account_ids: [admin.accountId] });

  let vendorMetadata = {
    name: "Benji's Homegrown Burgers!",
    description: "The greatest burgers in town.",
    cover_image: "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
  };
  await admin.call(nearcon, "add_vendor", {
    vendor_id: merchVendor,
    vendor_metadata: vendorMetadata,
  });
  let metadata = await nearcon.view("get_vendor_metadata", {
    vendor_id: merchVendor,
  });
  console.log("metadata: ", metadata);
  t.deepEqual(metadata, vendorMetadata);

  let items = await nearcon.view("get_items_for_vendor", {
    vendor_id: merchVendor,
  });
  console.log("items before adding: ", items);
  t.deepEqual(items, []);

  await admin.call(nearcon, "add_item_to_vendor", {
    vendor_id: merchVendor,
    items: [
      {
        name: "Benji Burger",
        image: "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
        price: NEAR.parse("1").toString(),
        in_stock: true,
      },
    ],
  });

  items = await nearcon.view("get_items_for_vendor", {
    vendor_id: merchVendor,
  });
  console.log("items after adding: ", items);
  t.deepEqual(items, [
    {
      id: "0",
      name: "Benji Burger",
      image: "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
      price: NEAR.parse("1").toString(),
      in_stock: true,
    },
  ]);
});

test("Purchase vendor items", async (t) => {
  const { root, nearcon, funder, admin, merchVendor, foodVendor } =
    t.context.accounts;
  let vendorMetadata = {
    name: "Benji's Homegrown Burgers!",
    description: "The greatest burgers in town.",
    cover_image: "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
  };
  await nearcon.call(nearcon, "add_vendor", {
    vendor_id: merchVendor,
    vendor_metadata: vendorMetadata,
  });
  await nearcon.call(nearcon, "add_item_to_vendor", {
    vendor_id: merchVendor,
    items: [
      {
        name: "Benji Burger",
        image: "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
        price: NEAR.parse("1").toString(),
        in_stock: true,
      },
    ],
  });

  let itemInfo = await nearcon.view("get_item_information", {
    vendor_id: merchVendor,
    item_id: 0,
  });
  console.log("itemInfo: ", itemInfo);

  await nearcon.call(nearcon, "ft_mint", {
    account_id: funder.accountId,
    amount: NEAR.parse("10").toString(),
  });
  let response = await funder.call(nearcon, "ft_transfer", {
    receiver_id: merchVendor,
    memo: JSON.stringify([0]),
  });
  console.log("response: ", response);
  t.deepEqual(response, NEAR.parse("1").toString());

  let buyerFtBalance = await nearcon.view("ft_balance_of", {
    account_id: funder.accountId,
  });
  console.log("buyerFtBalance: ", buyerFtBalance);
  t.is(buyerFtBalance, NEAR.parse("9").toString());

  let sellerFtBalance = await nearcon.view("ft_balance_of", {
    account_id: merchVendor.accountId,
  });
  console.log("sellerFtBalance: ", sellerFtBalance);
  t.is(sellerFtBalance, NEAR.parse("1").toString());

  let totalSupply = await nearcon.view("ft_total_supply");
  console.log("totalSupply: ", totalSupply);
  t.is(totalSupply, NEAR.parse("10").toString());
});

'''
'''--- __tests__/utils/keypom.ts ---
import { BN } from "bn.js";
import { createHash } from "crypto";
import { KeyPair, NEAR, NearAccount, PublicKey } from "near-workspaces";
import { ExtKeyInfo, TrialRules, UserProvidedFCArgs } from "./types";
import { functionCall } from "./workspaces";
import { ExecutionContext } from "ava";

export const DEFAULT_GAS: string = "30000000000000";
export const LARGE_GAS: string = "300000000000000";
export const WALLET_GAS: string = "100000000000000";
export const DEFAULT_DEPOSIT: string = "1000000000000000000000000";
export const GAS_PRICE = new BN("100000000");
export const DEFAULT_TERRA_IN_NEAR: string = "3000000000000000000000";
export const CONTRACT_METADATA = {
  version: "1.0.0",
  link: "https://github.com/mattlockyer/proxy/commit/71a943ea8b7f5a3b7d9e9ac2208940f074f8afba",
};

export function hash(string: string, double = false) {
  if (double) {
    return createHash("sha256")
      .update(Buffer.from(string, "hex"))
      .digest("hex");
  }

  return createHash("sha256").update(Buffer.from(string)).digest("hex");
}

export function generatePasswordsForKey(
  pubKey: string,
  usesWithPassword: number[],
  basePassword: string
) {
  let passwords: Record<number, string> = {};

  // Loop through usesWithPassword
  for (var use of usesWithPassword) {
    let pw = basePassword + pubKey + use.toString()
    console.log('pw: ', pw)
    passwords[use] = hash(hash(pw), true);
  }

  return passwords;
}

export async function getKeyInformation(
  keypom: NearAccount,
  publicKey: string
): Promise<ExtKeyInfo> {
  const keyInformation: ExtKeyInfo = await keypom.view("get_key_information", {
    key: publicKey,
  });
  return keyInformation;
}

export async function generateKeyPairs(
  numKeys: number
): Promise<{ keys: KeyPair[]; publicKeys: string[] }> {
  // Generate NumKeys public keys
  let kps: KeyPair[] = [];
  let pks: string[] = [];
  for (let i = 0; i < numKeys; i++) {
    let keyPair = await KeyPair.fromRandom("ed25519");
    kps.push(keyPair);
    pks.push(keyPair.getPublicKey().toString());
  }
  return {
    keys: kps,
    publicKeys: pks,
  };
}

export async function claimWithRequiredGas({
  keypom,
  keyPair,
  root,
  fcArgs,
  password,
  receiverId,
  createAccount = false,
  useLongAccount = true,
  useImplicitAccount = false,
  shouldPanic = false,
}: {
  keypom: NearAccount;
  keyPair: KeyPair;
  root: NearAccount;
  fcArgs?: UserProvidedFCArgs;
  password?: string;
  receiverId?: string;
  createAccount?: boolean;
  useLongAccount?: boolean;
  useImplicitAccount?: boolean;
  shouldPanic?: boolean;
}) {
  // Set key and get required gas
  await keypom.setKey(keyPair);
  let keyPk = keyPair.getPublicKey().toString();

  const keyInfo: { required_gas: string } = await keypom.view(
    "get_key_information",
    { key: keyPk }
  );
  console.log("keyInfo: ", keyInfo);

  // To allow custom receiver ID without needing to specify useLongAccount
  if (receiverId != undefined && !createAccount) {
    useLongAccount = false;
  }

  // customized error message to reduce chances of accidentally passing in this receiverid and throwing an error
  let errorMsg = "Error-" + Date.now();

  // actualReceiverId for non-forced-failure case
  let actualReceiverId = useLongAccount
    ? createAccount
      ? `ac${Date.now().toString().repeat(4)}.${root.accountId}`
      : useImplicitAccount
      ? Buffer.from(PublicKey.fromString(keyPk).data).toString("hex")
      : errorMsg
    : receiverId;
  if (actualReceiverId == errorMsg) {
    throw new Error(
      "Must specify desired usage, see claimWithRequiredGas function for more information"
    );
  }

  if (createAccount) {
    // Generate new keypair
    let keyPairs = await generateKeyPairs(1);
    let newPublicKey = keyPairs.publicKeys[0];

    if (receiverId != undefined) {
      actualReceiverId = receiverId;
    }

    console.log(
      `create_account_and_claim with ${actualReceiverId} with ${keyInfo.required_gas} Gas`
    );
    let response = await functionCall({
      signer: keypom,
      receiver: keypom,
      methodName: "create_account_and_claim",
      args: {
        new_account_id: actualReceiverId,
        new_public_key: newPublicKey,
        fc_args: fcArgs,
        password,
      },
      gas: keyInfo.required_gas,
      shouldPanic,
    });
    console.log(`Response from create_account_and_claim: ${response}`);
    return { response, actualReceiverId };
  }

  console.log(
    `claim with ${actualReceiverId} with ${keyInfo.required_gas} Gas`
  );

  let response = await functionCall({
    signer: keypom,
    receiver: keypom,
    methodName: "claim",
    args: {
      account_id: actualReceiverId,
      fc_args: fcArgs,
      password,
    },
    gas: keyInfo.required_gas,
    shouldPanic,
  });
  console.log(response);
  return { response, actualReceiverId };
}

export const claimAndAssertAccountCreated = async ({
  t,
  keypom,
  nearcon,
  keyPair,
}: {
  t: ExecutionContext;
  keypom: NearAccount;
  nearcon: NearAccount;
  keyPair: KeyPair;
}) => {
  let newAccountId = `benji.${nearcon.accountId}`;
  await claimWithRequiredGas({
    keypom,
    root: keypom,
    keyPair,
    receiverId: newAccountId,
    createAccount: true,
    useLongAccount: false,
    useImplicitAccount: false,
    shouldPanic: false,
  });

  try {
    const keyInfo = await keypom.view("get_key_information", {
      key: keyPair.getPublicKey().toString(),
    });
    t.fail();
  } catch (e) {
    t.pass();
  }

  let account = keypom.getAccount(newAccountId);
  let doesExist = await account.exists();
  t.is(doesExist, true, `Account ${newAccountId} does not exist`);
  let keyList = await account.viewAccessKeys(newAccountId);
  console.log('keyList: ', keyList)
  t.assert(keyList.keys.length === 1);
  t.assert(keyList.keys[0].access_key.permission === "FullAccess");
};

export const addKeys = async ({
  funder,
  keypom,
  originalTicketOwner,
  numKeys,
  numOwners,
  dropId,
}: {
  funder: NearAccount;
  keypom: NearAccount;
  originalTicketOwner: NearAccount;
  numKeys: number;
  numOwners: number;
  dropId: string;
}): Promise<{ keys: KeyPair[]; publicKeys: string[] }> => {
  let { keys, publicKeys } = await generateKeyPairs(numKeys);
  let keyData: Array<any> = [];
  let basePassword = "nearcon23-password";
  let idx = 0;
  for (var pk of publicKeys) {
    let password_by_use = generatePasswordsForKey(idx.toString(), [1], basePassword);
    keyData.push({
      public_key: pk,
      password_by_use,
      key_owner: idx < numOwners ? originalTicketOwner.accountId : null,
    });
    idx += 1;
  }

  await functionCall({
    signer: funder,
    receiver: keypom,
    methodName: "add_keys",
    args: {
      drop_id: dropId,
      key_data: keyData,
    },
    attachedDeposit: NEAR.parse("20").toString(),
  });

  return { keys, publicKeys };
};

'''
'''--- __tests__/utils/types.ts ---
export type ExtNFTKey = {
    owner_id: string;
    token_id: string;
    metadata: TokenMetadata;
    approved_account_ids: Record<string, number>;
    royalty: Record<string, number>;
}

export type ExtKeyInfo = {
   required_gas: string;
   yoctonear: string;
   ft_list: Array<FTListData>;
   nft_list: Array<NFTListData>;
   drop_id: string;
   pub_key: string;
   token_id: string;
   owner_id: string;
   fc_list: Array<FCData>;
   uses_remaining: number
}

export type FCData = {
    methods: Array<MethodData>
}

export type NFTListData = {
    token_id: string;
    contract_id: string;
}

export type FTListData = {
    amount: string;
    contract_id: string;
}

export type ExtDrop = {
    drop_id: string;
    funder_id: string;
    max_key_uses: number;
    asset_data: Array<ExtAssetDataForUses>,
    nft_asset_data: Array<InternalNFTData>,
    ft_asset_data: Array<InternalFTData>,
    drop_config?: DropConfig,
    next_key_id: number
}

export type InternalNFTData = {
    contract_id: string;
    token_ids: Array<string>;
}

export type InternalFTData = {
    contract_id: string;
    registration_cost: string;
    balance_avail: string
}

export type ExtAssetDataForUses = {
    uses: number;
    assets: Array<ExtAsset | null>;
    config?: UseConfig
}

export type ExtAsset = ExtFTData | ExtNFTData | ExtNEARData | Array<MethodData>;

export type ExtFTData = {
    ft_contract_id: string;
    registration_cost: string;
    ft_amount: string
}

export type ExtNFTData = {
    nft_contract_id: string;
}

export type ExtNEARData = {
    yoctonear: string
}

export interface PasswordPerUse {
    /** The password for this given use */
    pw: string;
    /** Which use does the password belong to? These uses are *NOT* zero-indexed so the first use corresponds to `1` not `0`. */
    key_use: number;
}

export type MethodData = {
    receiver_id: string,
    method_name: string,
    args: string,
    attached_deposit: string,
    attached_gas: string,
    keypom_args?: KeypomInjectedArgs,
    receiver_to_claimer?: boolean,
    user_args_rule?: UserArgsRule,
}

export type UserArgsRule = "AllUser" | "FunderPreferred" | "UserPreferred"

export type KeypomInjectedArgs = {
    account_id_field: string,
    drop_id_field: string,
    key_id_field: string,
    funder_id_field: string,
}

export type TimeConfig = {
    start?: number;
    end?: number;
    throttle?: number;
    interval?: number;
}

export type UseConfig = {
    time?: TimeConfig;
    permissions?: "claim" | "create_account_and_claim";
    account_creation_keypom_args?: KeypomInjectedArgs;
    root_account_id?: string;
}

export type DropConfig = {
    metadata?: string;
    nft_keys_config?: {
        token_metadata?: TokenMetadata;
        royalties?: Record<string, number>;
    };
    add_key_allowlist?: Array<string>;
    delete_empty_drop?: boolean;
    extra_allowance_per_key?: string;
}

export type NFTTokenObject = {
    //token ID
    token_id: string,
    //owner of the token
    owner_id: string,
    //token metadata
    metadata: TokenMetadata,
    
    approved_account_ids: Record<string, number>,
    //keep track of the royalty percentages for the token in a hash map
    royalty: Record<string, number>,
}

export type TokenMetadata = {
    title: string | null;
    description: string | null;
    media: string | null;
    media_hash: string | null;
    copies: number | null;
    issued_at: number | null;
    expires_at: number | null;
    starts_at: number | null;
    updated_at: number | null;
    extra: string | null;
    reference: string | null;
    reference_hash: string | null;
}

export interface ListingJson {
    nft_token_id: string,
    nft_approval_id: number,
    nft_owner_id: string,
    nft_contract_id: string,
    price: string,
    currency: string,
    created_at: string,
    current_offer?: OfferJson,
}

export interface OfferJson {
    offerer_id: string,
    amount: string,
    referrer_id?: string,
    referral_cut?: number
}

export interface TrialRules {
    amounts: string, 
    contracts: string, 
    floor: string, 
    funder: string, 
    methods: string, 
    repay: string, 
    current_floor: string 
}

export type UserProvidedFCArgs = Array<AssetSpecificFCArgs>;
export type AssetSpecificFCArgs = Array<string | undefined> | undefined;
'''
'''--- __tests__/utils/workspaces.ts ---
import { BN } from "bn.js";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import {
    AccountBalance,
    NearAccount,
    TransactionResult
} from "near-workspaces";
import { LARGE_GAS } from "./keypom";

export async function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function functionCall({
  signer,
  receiver,
  methodName,
  args,
  attachedDeposit,
  gas,
  shouldLog = true,
  shouldPanic = false,
}: {
  signer: NearAccount;
  receiver: NearAccount;
  methodName: string;
  args: any;
  attachedDeposit?: string;
  gas?: string;
  shouldLog?: boolean;
  shouldPanic?: boolean;
}) {
  let rawValue = await signer.callRaw(receiver, methodName, args, {
    gas: gas || LARGE_GAS,
    attachedDeposit: attachedDeposit || "0",
  });
  parseExecutionResults(
    methodName,
    receiver.accountId,
    rawValue,
    shouldLog,
    shouldPanic
  );

  if (rawValue.SuccessValue) {
    return atob(rawValue.SuccessValue);
  } else {
    return rawValue.Failure?.error_message;
  }
}

export function parseExecutionResults(
  methodName: string,
  receiverId: string,
  transaction: TransactionResult,
  shouldLog: boolean,
  shouldPanic: boolean
) {
  console.log("");
  let logMessages: string[] = [];

  let didPanic = false;
  let panicMessages: string[] = [];

  // Loop through each receipts_outcome in the transaction's result field
  transaction.result.receipts_outcome.forEach((receipt) => {
    const logs = receipt.outcome.logs;

    if (logs.length > 0) {
      // Turn logs into a string
      let logs = receipt.outcome.logs.reduce((acc, log) => {
        return acc.concat(log).concat("\n");
      }, "");

      logs = logs.substring(0, logs.length - 1);
      logMessages.push(logs);
    } else if (
      logMessages[logMessages.length - 1] != `\n` &&
      logMessages.length > 0
    ) {
      logMessages.push(`\n`);
    }

    const status = receipt.outcome.status as any;
    if (status.Failure) {
      let failure = status.Failure.ActionError;
      let str = `Failure for method: ${methodName} Failure: ${JSON.stringify(
        failure
      )}\n`;

      panicMessages.push(str);
      didPanic = true;
    }
  });

  console.log(
    `${methodName} -> ${receiverId}. ${logMessages.length} Logs Found. ${panicMessages.length} Panics Found.`
  );

  if (shouldLog && logMessages.length > 0) {
    let logStr = logMessages.join("\n");
    // Remove the last instance of `\n` from the log string
    logStr = logStr.substring(0, logStr.length - 1);
    console.log(logStr);
  }

  if (panicMessages.length > 0) {
    console.log("Panics:");
    let panicStr = panicMessages.join("\n");
    // Remove the last instance of `\n` from the panic string
    panicStr = panicStr.substring(0, panicStr.length - 1);
    console.log(panicStr);
  }

  if (shouldPanic && !didPanic) {
    throw new Error(`Expected failure for method: ${methodName}`);
  }

  if (!shouldPanic && didPanic) {
    throw new Error("Panic found when not expected");
  }
}

export const displayBalances = (
  initialBalances: AccountBalance,
  finalBalances: AccountBalance
) => {
  const initialBalancesNear = {
    available: formatNearAmount(initialBalances.available.toString()),
    staked: formatNearAmount(initialBalances.staked.toString()),
    stateStaked: formatNearAmount(initialBalances.stateStaked.toString()),
    total: formatNearAmount(initialBalances.total.toString()),
  };

  const finalBalancesNear = {
    available: formatNearAmount(finalBalances.available.toString()),
    staked: formatNearAmount(finalBalances.staked.toString()),
    stateStaked: formatNearAmount(finalBalances.stateStaked.toString()),
    total: formatNearAmount(finalBalances.total.toString()),
  };

  let isMoreState = false;
  if (
    new BN(initialBalances.stateStaked.toString()).lt(
      new BN(finalBalances.stateStaked.toString())
    )
  ) {
    let temp = initialBalances.stateStaked;
    initialBalances.stateStaked = finalBalances.stateStaked;
    finalBalances.stateStaked = temp;
    isMoreState = true;
  }

  console.log(
    `Available: ${initialBalancesNear.available.toString()} -> ${finalBalancesNear.available.toString()}`
  );
  console.log(
    `Staked: ${initialBalancesNear.staked.toString()} -> ${finalBalancesNear.staked.toString()}`
  );
  console.log(
    `State Staked: ${initialBalancesNear.stateStaked.toString()} -> ${finalBalancesNear.stateStaked.toString()}`
  );
  console.log(
    `Total: ${initialBalancesNear.total.toString()} -> ${finalBalancesNear.total.toString()}`
  );
  console.log(``);
  console.log(`NET:`);
  console.log(
    `Available: ${formatNearAmount(
      new BN(finalBalances.available.toString())
        .sub(new BN(initialBalances.available.toString()))
        .toString()
    )}`
  );
  console.log(
    `Staked: ${formatNearAmount(
      new BN(finalBalances.staked.toString())
        .sub(new BN(initialBalances.staked.toString()))
        .toString()
    )}`
  );
  console.log(
    `State Staked ${isMoreState ? "(more)" : "(less)"}: ${formatNearAmount(
      new BN(initialBalances.stateStaked.toString())
        .sub(new BN(finalBalances.stateStaked.toString()))
        .toString()
    )}`
  );
  console.log(
    `Total: ${formatNearAmount(
      new BN(finalBalances.total.toString())
        .sub(new BN(initialBalances.total.toString()))
        .toString()
    )}`
  );
};

'''
'''--- contract/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/factory.wasm

'''
'''--- contract/src/approval.rs ---
// Import necessary dependencies and types
use crate::*;
use near_sdk::{ext_contract, json_types::U64};

// Define the trait for NonFungibleTokenCore
pub trait NonFungibleTokenCore {
    // Approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: U64, account_id: AccountId, msg: Option<String>);

    // Check if the passed-in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: U64,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    // Revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: U64, account_id: AccountId);

    // Revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: U64);
}

// External contract trait for NonFungibleTokenApprovalsReceiver
#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    // Cross-contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: U64,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

// Implement NonFungibleTokenCore for the Contract
#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    // Allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: U64, account_id: AccountId, msg: Option<String>) {
        // Ensure at least one yocto is attached for security reasons, causing a redirect to the NEAR wallet.
        assert_at_least_one_yocto();

        // Get the token object from the token ID
        let mut ticket = self.ticket_by_id.get(&token_id.0).expect("No token");

        // Ensure that the caller of the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &ticket.owner_id,
            "Predecessor must be the token owner."
        );

        // Get the next approval ID if we need a new approval
        let approval_id: u64 = ticket.next_approval_id;

        // Check if the account has been approved already for this token
        let is_new_approval = ticket
            .approved_account_ids
            .insert(account_id.clone(), approval_id)
            .is_none();

        // Calculate the storage used for the new approval if it's a new approval
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        } else {
            0
        };

        // Increment the token's next approval ID by 1
        ticket.next_approval_id += 1;

        // Insert the token back into the tokens_by_id collection
        self.ticket_by_id.insert(&token_id.0, &ticket);

        // Refund any excess storage attached by the user. If the user didn't attach enough, panic.
        refund_deposit(storage_used);

        // If a message was passed into the function, initiate a cross-contract call on the
        // account to which access is granted.
        if let Some(msg) = msg {
            ext_non_fungible_approval_receiver::ext(account_id)
                .nft_on_approve(token_id, ticket.owner_id, approval_id, msg)
                .as_return();
        }
    }

    // Check if the passed-in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: U64,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        // Get the token object from the token_id
        let ticket = self.ticket_by_id.get(&token_id.0).expect("No token");

        // Get the approval number for the passed-in account ID
        let approval = ticket.approved_account_ids.get(&approved_account_id);

        if let Some(approval) = approval {
            if let Some(approval_id) = approval_id {
                // Return if the approval ID passed in matches the actual approval ID for the account
                approval_id == *approval
            } else {
                true
            }
        } else {
            false
        }
    }

    // Revoke a specific account from transferring the token on your behalf
    #[payable]
    fn nft_revoke(&mut self, token_id: U64, account_id: AccountId) {
        // Ensure the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();

        // Get the token object using the passed-in token_id
        let mut ticket = self.ticket_by_id.get(&token_id.0).expect("No token");

        // Get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &ticket.owner_id);

        // If the account ID was in the token's approvals, remove it, and refund the funds released by removing the approved account ID to the caller of the function
        if ticket.approved_account_ids.remove(&account_id).is_some() {
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            // Insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.ticket_by_id.insert(&token_id.0, &ticket);
        }
    }

    // Revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: U64) {
        // Ensure the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        // Get the token object from the passed-in token ID
        let mut ticket = self.ticket_by_id.get(&token_id.0).expect("No token");

        // Get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &ticket.owner_id);

        // Only revoke if the approved account IDs for the token are not empty
        if !ticket.approved_account_ids.is_empty() {
            // Refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &ticket.approved_account_ids);

            // Clear the approved account IDs
            ticket.approved_account_ids.clear();

            // Insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.ticket_by_id.insert(&token_id.0, &ticket);
        }
    }
}

'''
'''--- contract/src/enumeration.rs ---
use crate::nft_core::NonFungibleTokenCore;
use crate::*;

/// Struct to return in views to query for specific data related to an access key.
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonSeries {
    series_id: u64,
    mint_id: u64,
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Owner of the collection (they can update collection ID)
    owner_id: AccountId,
}

#[near_bindgen]
impl Contract {
    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        //return the length of the token metadata by ID
        U128(self.tokens_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each token using an iterator
        self.tokens_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector.
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // Get the total supply of NFTs for a given owner
    pub fn get_supply_series(&self) -> u64 {
        self.series_by_id.len()
    }

    // Paginate through all the series on the contract and return the metadata for each one
    pub fn get_series(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonSeries> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each series using an iterator
        self.series_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the series IDs which are strings into Json Series
            .map(|series_id| self.get_series_info(None, Some(series_id.clone())).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // get info for a specific series
    pub fn get_series_info(
        &self,
        mint_id: Option<u64>,
        series_id: Option<u64>,
    ) -> Option<JsonSeries> {
        // If a series ID was passed in, use that. Otherwise, get the series ID from the mint ID.
        let actual_id = series_id.unwrap_or_else(|| {
            self.series_id_by_mint_id
                .get(&mint_id.expect("No mint ID or series ID passed in"))
                .expect("No series ID found for mint ID")
        });

        // If there was some series, return the series info
        if let Some(series) = self.series_by_id.get(&actual_id) {
            Some(JsonSeries {
                series_id: actual_id,
                mint_id: series.mint_id,
                metadata: series.metadata,
                royalty: series.royalty,
                owner_id: series.owner_id,
            })
        } else {
            //if there isn't a series, we'll return None
            None
        }
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_series(&self, mint_id: Option<u64>, series_id: Option<u64>) -> U128 {
        // If a series ID was passed in, use that. Otherwise, get the series ID from the mint ID.
        let actual_id = series_id.unwrap_or_else(|| {
            self.series_id_by_mint_id
                .get(&mint_id.expect("No mint ID or series ID passed in"))
                .expect("No series ID found for mint ID")
        });

        let series = self.series_by_id.get(&actual_id);

        //if there is some series, get the length of the tokens. Otherwise return -
        if let Some(series) = series {
            U128(series.tokens.len() as u128)
        } else {
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_series(
        &self,
        mint_id: Option<u64>,
        series_id: Option<u64>,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        // If a series ID was passed in, use that. Otherwise, get the series ID from the mint ID.
        let actual_id = series_id.unwrap_or_else(|| {
            self.series_id_by_mint_id
                .get(&mint_id.expect("No mint ID or series ID passed in"))
                .expect("No series ID found for mint ID")
        });

        let series = self.series_by_id.get(&actual_id);
        
        let tokens = if let Some(series) = series {
            series.tokens
        } else {
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}

'''
'''--- contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
}

'''
'''--- contract/src/internal.rs ---
use crate::*;
use near_sdk::CryptoHash;
use std::mem::size_of;

// Convert the royalty percentage and amount to pay into a payout (U128).
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

// Calculate how many bytes the account ID is taking up.
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

// Refund the storage taken up by passed-in approved account IDs and send the funds to the passed-in account ID.
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, // The approved account IDs must be passed in as an iterator.
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    // Get the storage total by going through and summing all the bytes for each approved account IDs.
    let storage_released: u64 = approved_account_ids.map(bytes_for_approved_account_id).sum();
    // Transfer the account the storage that is released.
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

// Refund a map of approved account IDs and send the funds to the passed-in account ID.
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    // Call the refund_approved_account_ids_iter with the approved account IDs as keys.
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

// Used to generate a unique prefix in our storage collections (this is to avoid data collisions).
pub(crate) fn hash_account_id(account_id: &String) -> CryptoHash {
    // Get the default hash.
    let mut hash = CryptoHash::default();
    // We hash the account ID and return it.
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

// Used to make sure the user attached exactly 1 yoctoNEAR.
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    );
}

// Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage).
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    );
}

// Refund the initial deposit based on the amount of storage that was used up.
pub(crate) fn refund_deposit(storage_used: u64) {
    // Get how much it would cost to store the information.
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    // Get the attached deposit.
    let attached_deposit = env::attached_deposit();

    // Make sure that the attached deposit is greater than or equal to the required cost.
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    // Get the refund amount from the attached deposit - required cost.
    let refund = attached_deposit - required_cost;

    // If the refund is greater than 1 yoctoNEAR, we refund the predecessor that amount.
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    // Add a ticket to the set of tickets an owner has.
    pub(crate) fn assert_contract_owner(&mut self) {
        assert!(
            self.owner_id == env::predecessor_account_id(),
            "only contract owner"
        )
    }

    // Add a set of tickets to the set of tickets an owner has.
    pub(crate) fn internal_add_tickets_to_owner(
        &mut self,
        account_id: &AccountId,
        ticket_id: &Vec<TicketId>,
    ) {
        // Get the set of tickets for the given account.
        let mut ticket_set = self.tickets_per_owner.get(account_id).unwrap_or_else(|| {
            // If the account doesn't have any tickets, we create a new unordered set.
            UnorderedSet::new(
                StorageKey::TicketsPerOwnerInner {
                    // Get a new unique prefix for the collection.
                    account_id_hash: hash_account_id(&account_id.to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        // Insert the tickets into the set.
        for ticket in ticket_id {
            ticket_set.insert(ticket);
        }

        // Insert that set for the given account ID.
        self.tickets_per_owner.insert(account_id, &ticket_set);
    }

    // Remove a ticket from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_tickets_from_owner(
        &mut self,
        account_id: &AccountId,
        ticket_id: &Vec<TicketId>,
    ) {
        // Get the set of tickets that the owner has.
        let mut ticket_set = self
            .tickets_per_owner
            .get(account_id)
            // If there is no set of tickets for the owner, we panic with the following message:
            .expect("Ticket should be owned by the sender");

        // Remove the token_id from the set of tokens.
        for ticket in ticket_id {
            ticket_set.remove(ticket);
        }

        // If the ticket set is now empty, we remove the owner from the tickets_per_owner collection.
        if ticket_set.is_empty() {
            self.tickets_per_owner.remove(account_id);
        } else {
            // If the ticket set is not empty, we simply insert it back for the account ID.
            self.tickets_per_owner.insert(account_id, &ticket_set);
        }
    }

    // Transfer the ticket to the receiver_id.
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        ticket_id: TicketId,
        // We introduce an approval ID so that people with that approval ID can transfer the token.
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Ticket {
        // Get the ticket object by passing in the ticket_id.
        let ticket = self.ticket_by_id.get(&ticket_id).expect("No token");

        // If the sender doesn't equal the owner, we check if the sender is in the approval list.
        if sender_id != &ticket.owner_id {
            // If the ticket's approved account IDs don't contain the sender, we panic.
            if !ticket.approved_account_ids.contains_key(sender_id) {
                env::panic_str("Unauthorized");
            }

            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included.
            if let Some(enforced_approval_id) = approval_id {
                // Get the actual approval ID.
                let actual_approval_id = ticket
                    .approved_account_ids
                    .get(sender_id)
                    // If the sender isn't in the map, we panic.
                    .expect("Sender is not an approved account");

                // Make sure that the actual approval ID is the same as the one provided.
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }

        // Make sure that the sender isn't sending the ticket to themselves.
        assert_ne!(
            &ticket.owner_id, receiver_id,
            "The ticket owner and the receiver should be different"
        );

        // Remove the ticket from its current owner's set.
        self.internal_remove_tickets_from_owner(&ticket.owner_id, &vec![ticket_id]);
        // Add the ticket to the receiver_id's set.
        self.internal_add_tickets_to_owner(receiver_id, &vec![ticket_id]);

        // Create a new ticket struct.
        let new_ticket = Ticket {
            raffle_id: ticket.raffle_id,
            owner_id: receiver_id.clone(),
            // Reset the approval account IDs.
            approved_account_ids: Default::default(),
            next_approval_id: ticket.next_approval_id,
        };
        // Insert that new ticket into the tickets_by_id, replacing the old entry.
        self.ticket_by_id.insert(&ticket_id, &new_ticket);

        // If there was some memo attached, we log it.
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        // If the approval ID was provided, set the authorized ID equal to the sender.
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the ticket on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: ticket.owner_id.to_string(),
                // The account ID of the new owner of the ticket.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the ticket IDs as strings.
                token_ids: vec![ticket_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized JSON.
        env::log_str(&nft_transfer_log.to_string());

        // Return the previous ticket object that was transferred.
        ticket
    }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault,
    Promise, PromiseOrValue,
};
use std::collections::HashMap;

pub use crate::approval::*;
pub use crate::events::*;
use crate::internal::*;
pub use crate::metadata::*;
pub use crate::nft_core::*;
pub use crate::owner::*;
pub use crate::royalty::*;
pub use crate::raffle::*;

mod approval;
mod events;
mod internal;
mod metadata;
mod nft_core;
mod owner;
mod royalty;
mod raffle;

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "nft-1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

// Represents the raffle type. All tokens will derive this data.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Raffle {
    // If specified, the drop funder coming from Keypom MUST be equal to this value
    funder_id: Option<AccountId>,
    // If specified, the drop ID coming from Keypom MUST be equal to this value
    drop_id: Option<String>,
    // Metadata including title, num copies, etc., that all tokens will derive from
    metadata: RaffleMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Set of tickets in the collection
    tickets: UnorderedSet<TicketId>,
    // Owner of the raffle
    owner_id: AccountId
}

pub type CollectionId = u64;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // Contract owner
    pub owner_id: AccountId,
    // Approved minters
    pub approved_minters: LookupSet<AccountId>,
    // Approved users that can create raffles
    pub approved_creators: LookupSet<AccountId>,
    // Map the collection ID (stored in Token obj) to the collection data
    pub raffle_by_id: UnorderedMap<CollectionId, Raffle>,
    // Keeps track of the token struct for a given token ID
    pub ticket_by_id: UnorderedMap<TicketId, Ticket>,

    // Keeps track of all the token IDs for a given account
    pub tickets_per_owner: LookupMap<AccountId, UnorderedSet<TicketId>>,
    // Keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    ApprovedMinters,
    ApprovedCreators,
    RaffleById,
    RaffleByTicketId,
    TicketById,
    RaffleTickets { raffle_id_hash: CryptoHash },
    TicketsPerOwner,
    TicketsPerOwnerInner { account_id_hash: CryptoHash },
    Metadata,
}

#[near_bindgen]
impl Contract {
    // Initialization function (can only be called once).
    // This initializes the contract with default metadata so the
    // user doesn't have to manually type metadata.
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "NFT Tutorial Contract".to_string(),
                symbol: "GOTEAM".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    // Initialization function (can only be called once).
    // This initializes the contract with metadata that was passed in and
    // the owner_id.
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        let mut approved_minters =
            LookupSet::new(StorageKey::ApprovedMinters.try_to_vec().unwrap());
        approved_minters.insert(&owner_id);

        let mut approved_creators =
            LookupSet::new(StorageKey::ApprovedCreators.try_to_vec().unwrap());
        approved_creators.insert(&owner_id);

        let this = Self {
            owner_id,
            approved_minters,
            approved_creators,
            raffle_by_id: UnorderedMap::new(StorageKey::RaffleById.try_to_vec().unwrap()),
            ticket_by_id: UnorderedMap::new(
                StorageKey::TicketById.try_to_vec().unwrap(),
            ),
            tickets_per_owner: LookupMap::new(
                StorageKey::TicketsPerOwner.try_to_vec().unwrap(),
            ),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        this
    }
}

'''
'''--- contract/src/metadata.rs ---
use near_sdk::json_types::U64;

use crate::*;
pub type TicketId = u64;
pub type RaffleId = u64;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RaffleMetadata {
    pub title: String, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: String, // free-form description
    pub media: String, // URL to associated media, preferably to decentralized, content-addressed storage
    
    // EXTRA
    pub max_tickets: Option<u64>, // Maximum number of tickets that can be minted
    pub live_tickets: u64 // Total of tickets currently live
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Ticket {
    // Raffle that the token belongs to
    pub raffle_id: u64,
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out.
    pub next_approval_id: u64,
}

//The Json token is what will be returned from view calls.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonTicket {
    pub ticket_id: U64,
    pub raffle_id: U64,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: RaffleMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: Option<HashMap<AccountId, u32>>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- contract/src/nft_core.rs ---
// Import necessary dependencies and types
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult, json_types::U64};
use std::collections::HashMap;

// Define gas constants for resolving transfer and NFT on transfer calls
const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(25_000_000_000_000);

// Define the trait for NonFungibleTokenCore
pub trait NonFungibleTokenCore {
    // Transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: U64,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    // Transfers an NFT to a receiver and calls a function on the receiver ID's contract
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: U64,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    // Get information about the NFT token
    fn nft_token(&self, token_id: U64) -> Option<JsonTicket>;
}

// External contract trait for NonFungibleTokenReceiver
#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: U64,
        msg: String,
    ) -> Promise;
}

// External contract trait for NonFungibleTokenResolver
#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: U64,
        approved_account_ids: HashMap<AccountId, u64>,
        memo: Option<String>,
    ) -> bool;
}

// Implement NonFungibleTokenCore for the Contract
#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    // Implementation of the nft_transfer method.
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: U64,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        // Ensure the user attached exactly 1 yoctoNEAR for security and wallet redirection.
        assert_one_yocto();

        // Get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();

        // Call the internal transfer method and get back the previous token to refund approved account IDs
        let previous_ticket =
            self.internal_transfer(&sender_id, &receiver_id, token_id.0, approval_id, memo);

        // Refund the owner for releasing the storage used up by approved account IDs
        refund_approved_account_ids(
            previous_ticket.owner_id.clone(),
            &previous_ticket.approved_account_ids,
        );
    }

    // Implementation of the transfer call method.
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: U64,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Ensure the user attached exactly 1 yocto for security reasons.
        assert_one_yocto();

        // Get the sender ID
        let sender_id = env::predecessor_account_id();

        // Transfer the token and get the previous token object
        let previous_ticket = self.internal_transfer(
            &sender_id,
            &receiver_id,
            token_id.0,
            approval_id,
            memo.clone(),
        );

        // Default the authorized_id to none
        let mut authorized_id = None;

        // If the sender isn't the owner of the token, set the authorized ID equal to the sender.
        if sender_id != previous_ticket.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_NFT_ON_TRANSFER)
            .nft_on_transfer(
                sender_id,
                previous_ticket.owner_id.clone(),
                token_id.clone(),
                msg,
            )
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        authorized_id,
                        previous_ticket.owner_id,
                        receiver_id,
                        token_id,
                        previous_ticket.approved_account_ids,
                        memo,
                    ),
            )
            .into()
    }

    // Get information for a specific token ID
    fn nft_token(&self, token_id: U64) -> Option<JsonTicket> {
        // If there is a token with the provided ID in the collection
        if let Some(ticket) = self.ticket_by_id.get(&token_id.0) {
            let cur_series = self
                .raffle_by_id
                .get(&ticket.raffle_id)
                .expect("No raffle found");
            let mut metadata = cur_series.metadata;

            // Return the JsonToken wrapped in Some since we return an option
            Some(JsonTicket {
                raffle_id: U64(ticket.raffle_id),
                ticket_id: token_id,
                owner_id: ticket.owner_id,
                metadata,
                approved_account_ids: ticket.approved_account_ids,
                royalty: cur_series.royalty,
            })
        } else {
            // If the token with the provided ID doesn't exist, return None
            None
        }
    }
}

// Implement NonFungibleTokenResolver for the Contract
#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    // Resolve the cross-contract call when calling nft_on_transfer in the nft_transfer_call method
    // Return true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: U64,
        approved_account_ids: HashMap<AccountId, u64>,
        memo: Option<String>,
    ) -> bool {
        // Check whether the receiver wants to return the token back to the sender based on nft_on_transfer result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                if !return_token {
                    // We don't need to return the token, so everything went fine, and we return true.
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        // Get the token object if it exists
        let mut token = if let Some(token) = self.ticket_by_id.get(&token_id.0) {
            if token.owner_id != receiver_id {
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is no longer owned by the receiver. Can't return it.
                return true;
            }
            token
        } else {
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        // Remove the token from the receiver
        self.internal_remove_tickets_from_owner(&receiver_id.clone(), &vec![token_id.0]);
        // Add the token to the original owner
        self.internal_add_tickets_to_owner(&owner_id, &vec![token_id.0]);

        // Change the token struct's owner to be the original owner
        token.owner_id = owner_id.clone();

        // Refund the receiver for any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        // Reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        // Insert the token back into the tokens_by_id collection
        self.ticket_by_id.insert(&token_id.0, &token);

        // Log that the NFT was reverted back to the original owner
        let nft_transfer_log: EventLog = EventLog {
            standard: NFT_STANDARD_NAME.to_string(),
            version: NFT_METADATA_SPEC.to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id,
                old_owner_id: receiver_id.to_string(),
                new_owner_id: owner_id.to_string(),
                token_ids: vec![token_id.0.to_string()],
                memo,
            }]),
        };

        env::log_str(&nft_transfer_log.to_string());

        // Return false
        false
    }
}

'''
'''--- contract/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// approved minters
    pub fn add_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.insert(&account_id);
    }

    pub fn remove_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.remove(&account_id);
    }

    pub fn is_approved_minter(&self, account_id: AccountId) -> bool {
        self.approved_minters.contains(&account_id)
    }

    /// approved creators
    pub fn add_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.insert(&account_id);
    }

    pub fn remove_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.remove(&account_id);
    }
}

'''
'''--- contract/src/raffle.rs ---
use near_sdk::json_types::U64;

use crate::*;

/// Injected Keypom Args struct to be sent to external contracts
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct KeypomArgs {
    pub account_id_field: Option<String>,
    pub funder_id_field: Option<String>,
    pub drop_id_field: Option<String>,
    pub key_id_field: Option<String>
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn create_raffle(
        &mut self,
        raffle_id: u64,
        raffle_metadata: RaffleMetadata,
        funder_id: Option<AccountId>,
        drop_id: Option<String>,
        royalty: Option<HashMap<AccountId, u32>>,
    ) {
        //measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        let caller = env::predecessor_account_id();

        require!(
            self.raffle_by_id
                .get(&raffle_id)
                .is_none(),
            &format!(
                "raffle with ID {} already exists",
                &raffle_id
            )
        );

        require!(
            self.raffle_by_id
                .insert(
                    &raffle_id,
                    &Raffle {
                        funder_id,
                        drop_id,
                        metadata: raffle_metadata,
                        //we add an optional parameter for perpetual royalties
                        royalty,
                        tickets: UnorderedSet::new(StorageKey::RaffleTickets {
                            // We get a new unique prefix for the collection
                            raffle_id_hash: hash_account_id(&format!("{}{}", raffle_id, caller)),
                        }),
                        owner_id: caller
                    }
                )
                .is_none(),
            &format!(
                "raffle with ID {} already exists",
                &raffle_id
            )
        );

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }

    #[payable]
    pub fn mint_ticket(
        &mut self,
        raffle_id: U64,
        receiver_id: AccountId,
        ticket_amount: u64,
        drop_id: String,
        funder_id: AccountId,
        keypom_args: KeypomArgs,
    ) {
        // Ensure the injected keypom args are not malicious
        require!(
            keypom_args.funder_id_field.unwrap() == "funder_id".to_string(),
            "Malicious call. Injected keypom args don't match"
        );
        require!(
            keypom_args.drop_id_field.unwrap() == "drop_id".to_string(),
            "Malicious call. Injected keypom args don't match"
        );
        require!(
            keypom_args.account_id_field.unwrap() == "receiver_id".to_string(),
            "Malicious call. Injected keypom args don't match"
        );

        // Measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        let predecessor = env::predecessor_account_id();
        assert!(
            self.approved_minters.contains(&predecessor),
            "Not approved minter"
        );

        let mut raffle = self.raffle_by_id.get(&raffle_id.0).expect("Not a raffle");
        require!(
            raffle.drop_id.as_ref() == Some(drop_id).as_ref(),
            "drop_id mismatch"
        );
        require!(
            raffle.funder_id.as_ref() == Some(funder_id).as_ref(),
            "funder_id mismatch"
        );

        let cur_len = raffle.tickets.len() - 1 + ticket_amount;
        // Ensure we haven't overflowed on the number of copies minted
        if let Some(max) = raffle.metadata.max_tickets {
            require!(
                cur_len < max,
                "Cannot mint any more tickets for the given raffle. Limit reached"
            );
        }

        let mut tickets = vec![];
        for _ in 0..ticket_amount {
            let ticket_id = raffle.tickets.len();
            tickets.push(ticket_id);

            raffle.tickets.insert(&ticket_id);
            // Specify the ticket struct that contains the owner ID
            let ticket = Ticket {
                // Series ID that the ticket belongs to
                raffle_id: raffle_id.0,
                // Set the owner ID equal to the receiver ID passed into the function
                owner_id: receiver_id.clone(),
                // Set the approved account IDs to the default value (an empty map)
                approved_account_ids: Default::default(),
                // The next approval ID is set to 0
                next_approval_id: 0,
            };

            require!(
                self.ticket_by_id.insert(&ticket_id, &ticket).is_none(),
                "Ticket already exists"
            );

            // Construct the mint log as per the events standard.
            let nft_mint_log: EventLog = EventLog {
                // Standard name ("nep171")
                standard: NFT_STANDARD_NAME.to_string(),
                // Version of the standard ("nft-1.0.0")
                version: NFT_METADATA_SPEC.to_string(),
                // The data related with the event stored in a vector
                event: EventLogVariant::NftMint(vec![NftMintLog {
                    // Owner of the ticket
                    owner_id: receiver_id.to_string(),
                    // Vector of ticket IDs that were minted
                    token_ids: vec![ticket_id.to_string()],
                    // An optional memo to include
                    memo: None,
                }]),
            };

            // Log the serialized JSON
            env::log_str(&nft_mint_log.to_string());
        }
        self.internal_add_tickets_to_owner(&receiver_id, &tickets);
        self.raffle_by_id.insert(&raffle_id.0, &raffle);

        // Calculate the required storage which was used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // Refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }
}

'''
'''--- contract/src/royalty.rs ---
use near_sdk::json_types::U64;
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: U64, balance: U128, max_len_payout: u32) -> Payout;

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: U64,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    // Calculates the payout for a ticket given the passed-in balance. This is a view method.
    fn nft_payout(&self, ticket_id: U64, balance: U128, max_len_payout: u32) -> Payout {
        // Get the ticket object
        let ticket = self.ticket_by_id.get(&ticket_id.0).expect("No ticket");

        // Get the owner of the ticket
        let owner_id = ticket.owner_id;
        // Keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        // Get the u128 version of the passed-in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        // Keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        // Get the royalty object from the ticket
        let raffle = self
            .raffle_by_id
            .get(&ticket.raffle_id)
            .expect("No raffle currently running");
        let royalty_option = raffle.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout { payout: payout };
        }
        let royalty = royalty_option.unwrap();

        // Make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        // Go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            // Get the key
            let key = k.clone();
            // Only insert into the payout if the key isn't the ticket owner (we add their payout at the end)
            if key != owner_id {
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // Payout to the previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        // Return the payout object
        payout_object
    }

    // Transfers the ticket to the receiver ID and returns the payout object that should be paid given the passed-in balance.
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        ticket_id: U64,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        // Assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        // Get the sender ID
        let sender_id = env::predecessor_account_id();
        // Transfer the ticket to the passed-in receiver and get the previous ticket object back
        let previous_ticket =
            self.internal_transfer(&sender_id, &receiver_id, ticket_id.0, Some(approval_id), memo);

        // Refund the previous ticket owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_ticket.owner_id.clone(),
            &previous_ticket.approved_account_ids,
        );

        // Get the owner of the ticket
        let owner_id = previous_ticket.owner_id;
        // Keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        // Get the u128 version of the passed-in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        // Keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };

        // Get the royalty object from the ticket
        let cur_raffle = self
            .raffle_by_id
            .get(&previous_ticket.raffle_id)
            .expect("Not a series");
        let royalty_option = cur_raffle.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout { payout: payout };
        }
        let royalty = royalty_option.unwrap();

        // Make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        // Go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            // Get the key
            let key = k.clone();
            // Only insert into the payout if the key isn't the ticket owner (we add their payout at the end)
            if key != owner_id {
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // Payout to the previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        // Return the payout object
        payout_object
    }
}

'''
'''--- contract/target/.rustc_info.json ---
{"rustc_fingerprint":1690235998764945802,"outputs":{"15729799797837862367":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.dylib\nlib___.dylib\nlib___.a\nlib___.dylib\n/Users/benjaminkurrek/.rustup/toolchains/stable-aarch64-apple-darwin\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_arch=\"aarch64\"\ntarget_endian=\"little\"\ntarget_env=\"\"\ntarget_family=\"unix\"\ntarget_feature=\"aes\"\ntarget_feature=\"crc\"\ntarget_feature=\"dit\"\ntarget_feature=\"dotprod\"\ntarget_feature=\"dpb\"\ntarget_feature=\"dpb2\"\ntarget_feature=\"fcma\"\ntarget_feature=\"fhm\"\ntarget_feature=\"flagm\"\ntarget_feature=\"fp16\"\ntarget_feature=\"frintts\"\ntarget_feature=\"jsconv\"\ntarget_feature=\"lor\"\ntarget_feature=\"lse\"\ntarget_feature=\"neon\"\ntarget_feature=\"paca\"\ntarget_feature=\"pacg\"\ntarget_feature=\"pan\"\ntarget_feature=\"pmuv3\"\ntarget_feature=\"ras\"\ntarget_feature=\"rcpc\"\ntarget_feature=\"rcpc2\"\ntarget_feature=\"rdm\"\ntarget_feature=\"sb\"\ntarget_feature=\"sha2\"\ntarget_feature=\"sha3\"\ntarget_feature=\"ssbs\"\ntarget_feature=\"vh\"\ntarget_has_atomic=\"128\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"macos\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"apple\"\nunix\n","stderr":""},"4614504638168534921":{"success":true,"status":"","code":0,"stdout":"rustc 1.72.1 (d5c2e9c34 2023-09-13)\nbinary: rustc\ncommit-hash: d5c2e9c342b358556da91d61ed4133f6f50fc0c3\ncommit-date: 2023-09-13\nhost: aarch64-apple-darwin\nrelease: 1.72.1\nLLVM version: 16.0.5\n","stderr":""},"14908675589988555557":{"success":true,"status":"","code":0,"stdout":"___.wasm\nlib___.rlib\n___.wasm\nlib___.a\n/Users/benjaminkurrek/.rustup/toolchains/stable-aarch64-apple-darwin\noff\n___\ndebug_assertions\npanic=\"abort\"\nproc_macro\ntarget_arch=\"wasm32\"\ntarget_endian=\"little\"\ntarget_env=\"\"\ntarget_family=\"wasm\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"unknown\"\ntarget_pointer_width=\"32\"\ntarget_vendor=\"unknown\"\n","stderr":"warning: dropping unsupported crate type `dylib` for target `wasm32-unknown-unknown`\n\nwarning: dropping unsupported crate type `proc-macro` for target `wasm32-unknown-unknown`\n\nwarning: 2 warnings emitted\n\n"},"15481046163696847946":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.dylib\nlib___.dylib\nlib___.a\nlib___.dylib\n/Users/benjaminkurrek/.rustup/toolchains/stable-aarch64-apple-darwin\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_arch=\"aarch64\"\ntarget_endian=\"little\"\ntarget_env=\"\"\ntarget_family=\"unix\"\ntarget_feature=\"aes\"\ntarget_feature=\"crc\"\ntarget_feature=\"dit\"\ntarget_feature=\"dotprod\"\ntarget_feature=\"dpb\"\ntarget_feature=\"dpb2\"\ntarget_feature=\"fcma\"\ntarget_feature=\"fhm\"\ntarget_feature=\"flagm\"\ntarget_feature=\"fp16\"\ntarget_feature=\"frintts\"\ntarget_feature=\"jsconv\"\ntarget_feature=\"lor\"\ntarget_feature=\"lse\"\ntarget_feature=\"neon\"\ntarget_feature=\"paca\"\ntarget_feature=\"pacg\"\ntarget_feature=\"pan\"\ntarget_feature=\"pmuv3\"\ntarget_feature=\"ras\"\ntarget_feature=\"rcpc\"\ntarget_feature=\"rcpc2\"\ntarget_feature=\"rdm\"\ntarget_feature=\"sb\"\ntarget_feature=\"sha2\"\ntarget_feature=\"sha3\"\ntarget_feature=\"ssbs\"\ntarget_feature=\"vh\"\ntarget_has_atomic=\"128\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"macos\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"apple\"\nunix\n","stderr":""}},"successes":{}}
'''
'''--- contract/target/debug/.fingerprint/Inflector-a9d5d0565aa26a9b/lib-inflector.json ---
{"rustc":15699327122048238920,"features":"[]","target":894124792023433695,"profile":13904479058746662784,"path":11122834297798179470,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/Inflector-a9d5d0565aa26a9b/dep-lib-inflector"}}],"rustflags":[],"metadata":6849597462678386541,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ahash-672bd2931ec6a4a8/lib-ahash.json ---
{"rustc":15699327122048238920,"features":"[]","target":295758560010665018,"profile":8106212204186106853,"path":8421458435079503437,"deps":[[4424799446218848649,"once_cell",false,8792749180053218143],[6564554279330852038,"build_script_build",false,566105992360054371],[12202314575583203756,"getrandom",false,3276245713234940752]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ahash-672bd2931ec6a4a8/dep-lib-ahash"}}],"rustflags":[],"metadata":6548036084630991988,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ahash-988591fdd6bdb6e2/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[6564554279330852038,"build_script_build",false,14456192302139913149]],"local":[{"RerunIfChanged":{"output":"debug/build/ahash-988591fdd6bdb6e2/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ahash-a2329d604145205d/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":2297296889237502566,"profile":13904479058746662784,"path":7447198088260506862,"deps":[[16079472387499994964,"version_check",false,4685054622422357781]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ahash-a2329d604145205d/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":6548036084630991988,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/arrayref-c8b64655e1ccaaba/lib-arrayref.json ---
{"rustc":15699327122048238920,"features":"[]","target":13658717622884259089,"profile":8106212204186106853,"path":15051356330635772824,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/arrayref-c8b64655e1ccaaba/dep-lib-arrayref"}}],"rustflags":[],"metadata":5065701478231546975,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/arrayvec-2bbca17f484924d4/lib-arrayvec.json ---
{"rustc":15699327122048238920,"features":"[]","target":9102904644320696625,"profile":8106212204186106853,"path":18248458273236919410,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/arrayvec-2bbca17f484924d4/dep-lib-arrayvec"}}],"rustflags":[],"metadata":5019420986621020735,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/arrayvec-5547cda376c3ec60/lib-arrayvec.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":9102904644320696625,"profile":8106212204186106853,"path":11245355480170518531,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/arrayvec-5547cda376c3ec60/dep-lib-arrayvec"}}],"rustflags":[],"metadata":5019420986621020735,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/autocfg-5af00b76086a596d/lib-autocfg.json ---
{"rustc":15699327122048238920,"features":"[]","target":14886237245231788030,"profile":13904479058746662784,"path":3778067506699563520,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/autocfg-5af00b76086a596d/dep-lib-autocfg"}}],"rustflags":[],"metadata":13102859075309379048,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/base64-b3faa90ca2e064a6/lib-base64.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":16778825523953873731,"profile":8106212204186106853,"path":13189321443260612335,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/base64-b3faa90ca2e064a6/dep-lib-base64"}}],"rustflags":[],"metadata":13936919950537592407,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/base64-f1fdacb6fbeab256/lib-base64.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":16778825523953873731,"profile":8106212204186106853,"path":4651863785387530832,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/base64-f1fdacb6fbeab256/dep-lib-base64"}}],"rustflags":[],"metadata":13936919950537592407,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/bitvec-6d66d60a4bb74df7/lib-bitvec.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"std\"]","target":6701579296773358966,"profile":8106212204186106853,"path":1528894561967823641,"deps":[[188905226975056936,"radium",false,13719312863203764091],[6290779380211241362,"tap",false,18176472468655944009],[7789681275229131466,"wyz",false,16158962485632666825],[15433456967963170366,"funty",false,8320869354839249977]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/bitvec-6d66d60a4bb74df7/dep-lib-bitvec"}}],"rustflags":[],"metadata":6379644401324879731,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/blake2-2da85ddf0c66af50/lib-blake2.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":12927166087276115034,"profile":8106212204186106853,"path":12182447997222985739,"deps":[[6014497622236959678,"opaque_debug",false,8908775514494022079],[8884615759848737972,"crypto_mac",false,2859817791738572628],[12829070662860118430,"digest",false,17168197620239039330]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/blake2-2da85ddf0c66af50/dep-lib-blake2"}}],"rustflags":[],"metadata":2523818277111752649,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/block-buffer-15495cd87911817d/lib-block-buffer.json ---
{"rustc":15699327122048238920,"features":"[]","target":2661632913477203689,"profile":8106212204186106853,"path":15318322062130729622,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/block-buffer-15495cd87911817d/dep-lib-block-buffer"}}],"rustflags":[],"metadata":15558279325495868285,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/block-buffer-d976ca211eb89f5a/lib-block-buffer.json ---
{"rustc":15699327122048238920,"features":"[]","target":2661632913477203689,"profile":8106212204186106853,"path":12258943219350190653,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/block-buffer-d976ca211eb89f5a/dep-lib-block-buffer"}}],"rustflags":[],"metadata":5573904726092117450,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/borsh-derive-fd514b5ce8d53b0c/lib-borsh-derive.json ---
{"rustc":15699327122048238920,"features":"[]","target":14484299583844374162,"profile":13904479058746662784,"path":11450951485296481208,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[2345288959107110519,"borsh_schema_derive_internal",false,1821650707498870437],[3971538142687143787,"proc_macro_crate",false,972189456792295897],[8324001644593655249,"borsh_derive_internal",false,8058930634015891609],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/borsh-derive-fd514b5ce8d53b0c/dep-lib-borsh-derive"}}],"rustflags":[],"metadata":6341613096556135379,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/borsh-derive-internal-ba0949be12139283/lib-borsh-derive-internal.json ---
{"rustc":15699327122048238920,"features":"[]","target":9985232031898684131,"profile":13904479058746662784,"path":2594658786862283272,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/borsh-derive-internal-ba0949be12139283/dep-lib-borsh-derive-internal"}}],"rustflags":[],"metadata":6341613096556135379,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/borsh-e22f757c0018fd56/lib-borsh.json ---
{"rustc":15699327122048238920,"features":"[\"const-generics\", \"default\", \"rc\", \"std\"]","target":5127993436019407528,"profile":8106212204186106853,"path":406704560459441769,"deps":[[1759060122986695407,"borsh_derive",false,1708654979707797701],[16284710795702459458,"hashbrown",false,17101262696806322668]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/borsh-e22f757c0018fd56/dep-lib-borsh"}}],"rustflags":[],"metadata":7032358266178414993,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/borsh-schema-derive-internal-f72e2ec7f265a76d/lib-borsh-schema-derive-internal.json ---
{"rustc":15699327122048238920,"features":"[]","target":15664144342437137661,"profile":13904479058746662784,"path":6573703121797019932,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/borsh-schema-derive-internal-f72e2ec7f265a76d/dep-lib-borsh-schema-derive-internal"}}],"rustflags":[],"metadata":7685215035480038221,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/bs58-97859ce9ec9577ac/lib-bs58.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"std\"]","target":18352831503079783019,"profile":8106212204186106853,"path":7315557794883744608,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/bs58-97859ce9ec9577ac/dep-lib-bs58"}}],"rustflags":[],"metadata":13637435404263704389,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/byte-slice-cast-201c1ba21e1ed168/lib-byte-slice-cast.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":6808208250546668251,"profile":8106212204186106853,"path":3345755493236771301,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/byte-slice-cast-201c1ba21e1ed168/dep-lib-byte-slice-cast"}}],"rustflags":[],"metadata":4028636240650239297,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/byteorder-ac21c6fb65aa883b/lib-byteorder.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"i128\", \"std\"]","target":7579581527673517627,"profile":8106212204186106853,"path":14274820638163703284,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/byteorder-ac21c6fb65aa883b/dep-lib-byteorder"}}],"rustflags":[],"metadata":5398730104718078656,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/bytesize-0f18e0df42f9c9e0/lib-bytesize.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":5760977173082594167,"profile":8106212204186106853,"path":6963500624529868336,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/bytesize-0f18e0df42f9c9e0/dep-lib-bytesize"}}],"rustflags":[],"metadata":12146819253632092093,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/c2-chacha-00ff6b3f83302d8f/lib-c2-chacha.json ---
{"rustc":15699327122048238920,"features":"[\"cipher\", \"default\", \"rustcrypto_api\", \"std\"]","target":3305040737512747465,"profile":8106212204186106853,"path":16585084744317423320,"deps":[[4511957894497802922,"ppv_lite86",false,37336623232875757],[7120793223608721021,"cipher",false,4358449189791738622]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/c2-chacha-00ff6b3f83302d8f/dep-lib-c2-chacha"}}],"rustflags":[],"metadata":12544136120782019599,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cc-56df56d9b8687284/lib-cc.json ---
{"rustc":15699327122048238920,"features":"[]","target":15023190189141807623,"profile":13904479058746662784,"path":11392397616668327619,"deps":[[2798846484360888381,"libc",false,10041381624682854320]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cc-56df56d9b8687284/dep-lib-cc"}}],"rustflags":[],"metadata":5862599371499774553,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cfg-if-3684f691ab83e331/lib-cfg-if.json ---
{"rustc":15699327122048238920,"features":"[]","target":10623512480563079566,"profile":8106212204186106853,"path":8957231522740584638,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cfg-if-3684f691ab83e331/dep-lib-cfg-if"}}],"rustflags":[],"metadata":8462187951337715540,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cfg-if-472a251764bcb4db/lib-cfg-if.json ---
{"rustc":15699327122048238920,"features":"[]","target":10623512480563079566,"profile":13904479058746662784,"path":8957231522740584638,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cfg-if-472a251764bcb4db/dep-lib-cfg-if"}}],"rustflags":[],"metadata":8462187951337715540,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cfg-if-9213a1a06b9e4053/lib-cfg-if.json ---
{"rustc":15699327122048238920,"features":"[]","target":10623512480563079566,"profile":8106212204186106853,"path":6374127092075372262,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cfg-if-9213a1a06b9e4053/dep-lib-cfg-if"}}],"rustflags":[],"metadata":8462187951337715540,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/chrono-4646a16935d79532/lib-chrono.json ---
{"rustc":15699327122048238920,"features":"[\"clock\", \"default\", \"iana-time-zone\", \"js-sys\", \"oldtime\", \"serde\", \"std\", \"time\", \"wasm-bindgen\", \"wasmbind\", \"winapi\"]","target":11745563112108967737,"profile":8106212204186106853,"path":2979100862135025148,"deps":[[2169378189951667729,"iana_time_zone",false,15092947664620859663],[10539592998943336449,"num_traits",false,9133487546206414773],[14585307122936621441,"time",false,12415487716260611277],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/chrono-4646a16935d79532/dep-lib-chrono"}}],"rustflags":[],"metadata":9803565982372010724,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cipher-756136346095f559/lib-cipher.json ---
{"rustc":15699327122048238920,"features":"[]","target":12819517308274213455,"profile":8106212204186106853,"path":9872421558979699102,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cipher-756136346095f559/dep-lib-cipher"}}],"rustflags":[],"metadata":8273356103737446388,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/convert_case-0c4b31b357014ce8/lib-convert_case.json ---
{"rustc":15699327122048238920,"features":"[]","target":13988420919824902104,"profile":13904479058746662784,"path":10545277551054529305,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/convert_case-0c4b31b357014ce8/dep-lib-convert_case"}}],"rustflags":[],"metadata":8130279976740482636,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/core-foundation-sys-f44387363f7e5e35/lib-core-foundation-sys.json ---
{"rustc":15699327122048238920,"features":"[]","target":6095274920289913569,"profile":8106212204186106853,"path":2193038314491415175,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/core-foundation-sys-f44387363f7e5e35/dep-lib-core-foundation-sys"}}],"rustflags":[],"metadata":7246173313922784557,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/cpufeatures-a32fc4710e1c4645/lib-cpufeatures.json ---
{"rustc":15699327122048238920,"features":"[]","target":12245745790804801655,"profile":8106212204186106853,"path":3392061506561902621,"deps":[[2798846484360888381,"libc",false,1987128554771639862]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cpufeatures-a32fc4710e1c4645/dep-lib-cpufeatures"}}],"rustflags":[],"metadata":5592991748584184974,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/crunchy-6f9f212811594b4d/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"limit_128\", \"std\"]","target":8188216131759486267,"profile":13904479058746662784,"path":168528902147622291,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/crunchy-6f9f212811594b4d/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":5553159513701433177,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/crunchy-d803e387cc75866e/lib-crunchy.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"limit_128\", \"std\"]","target":10037286194704498616,"profile":8106212204186106853,"path":18366618347609434870,"deps":[[15144909498828475009,"build_script_build",false,8280153955747816309]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/crunchy-d803e387cc75866e/dep-lib-crunchy"}}],"rustflags":[],"metadata":5553159513701433177,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/crunchy-ddaff50b37de4df2/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[15144909498828475009,"build_script_build",false,14329757622219885396]],"local":[{"Precalculated":"0.2.2"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/crypto-common-228a17245f07b3cc/lib-crypto-common.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":2257523260353492199,"profile":8106212204186106853,"path":4838485060842188793,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520],[11395083745183091805,"typenum",false,803350758387535478]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/crypto-common-228a17245f07b3cc/dep-lib-crypto-common"}}],"rustflags":[],"metadata":3401955368041756111,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/crypto-mac-2577276ccb689c21/lib-crypto-mac.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":1084682306982316767,"profile":8106212204186106853,"path":5942211914558802241,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520],[11652100930071167282,"subtle",false,4266431561348681734]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/crypto-mac-2577276ccb689c21/dep-lib-crypto-mac"}}],"rustflags":[],"metadata":2483852330705237446,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/curve25519-dalek-2b37687683b1f27a/lib-curve25519-dalek.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"std\", \"u64_backend\"]","target":9193775365486874731,"profile":8106212204186106853,"path":16079504675401734023,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[7879775654530620242,"zeroize",false,12966527863841236361],[11652100930071167282,"subtle",false,4266431561348681734],[11761531122794857361,"rand_core",false,2666242172052674960],[12829070662860118430,"digest",false,17168197620239039330]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/curve25519-dalek-2b37687683b1f27a/dep-lib-curve25519-dalek"}}],"rustflags":[],"metadata":4666180542459884904,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/derive_more-81e3007be6b6bcad/lib-derive_more.json ---
{"rustc":15699327122048238920,"features":"[\"add\", \"add_assign\", \"as_mut\", \"as_ref\", \"constructor\", \"convert_case\", \"default\", \"deref\", \"deref_mut\", \"display\", \"error\", \"from\", \"from_str\", \"index\", \"index_mut\", \"into\", \"into_iterator\", \"is_variant\", \"iterator\", \"mul\", \"mul_assign\", \"not\", \"rustc_version\", \"sum\", \"try_into\", \"unwrap\"]","target":6509599423921459844,"profile":13904479058746662784,"path":7238056086162440691,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[9614823402458505899,"convert_case",false,3762208823881596419],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/derive_more-81e3007be6b6bcad/dep-lib-derive_more"}}],"rustflags":[],"metadata":8950704488499756937,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/digest-8ce86c113abb95ac/lib-digest.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"block-buffer\", \"core-api\", \"default\", \"std\"]","target":15504360929955102184,"profile":8106212204186106853,"path":10072506988749111673,"deps":[[15349877456970498084,"crypto_common",false,17522845454954615526],[18291355527327864993,"block_buffer",false,18200094625975043382]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/digest-8ce86c113abb95ac/dep-lib-digest"}}],"rustflags":[],"metadata":2664789385760777065,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/digest-f5ac998d64d83b30/lib-digest.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"std\"]","target":15504360929955102184,"profile":8106212204186106853,"path":3979938907344542148,"deps":[[9665562089965330559,"generic_array",false,10543991267170581520]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/digest-f5ac998d64d83b30/dep-lib-digest"}}],"rustflags":[],"metadata":5974257212182257802,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/dyn-clone-c9ffa55d6f7567d6/lib-dyn-clone.json ---
{"rustc":15699327122048238920,"features":"[]","target":456433028138942822,"profile":8106212204186106853,"path":5197101175864803496,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/dyn-clone-c9ffa55d6f7567d6/dep-lib-dyn-clone"}}],"rustflags":[],"metadata":10939357194659760099,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/easy-ext-98d8acfd023548de/lib-easy-ext.json ---
{"rustc":15699327122048238920,"features":"[]","target":17015224937156141358,"profile":13904479058746662784,"path":15928823708571317561,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/easy-ext-98d8acfd023548de/dep-lib-easy-ext"}}],"rustflags":[],"metadata":12123150640952772219,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ed25519-a342ebffeab01359/lib-ed25519.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":18170347052797393979,"profile":8106212204186106853,"path":4034062879041959389,"deps":[[13425634913538847917,"signature",false,15880774657470438179]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ed25519-a342ebffeab01359/dep-lib-ed25519"}}],"rustflags":[],"metadata":10784947986374962029,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ed25519-dalek-f8776d76654bc772/lib-ed25519-dalek.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"rand\", \"serde_crate\", \"std\", \"u64_backend\"]","target":10283645625438885884,"profile":8106212204186106853,"path":15656201050339893057,"deps":[[288937492735761168,"sha2",false,13487683500328730470],[2174722005733178090,"ed25519",false,16725684035340010577],[6730075568351986827,"curve25519_dalek",false,3695814637708764742],[7879775654530620242,"zeroize",false,12966527863841236361],[14778545527639897399,"rand",false,9242952068168568544],[18260804926946925357,"serde_crate",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ed25519-dalek-f8776d76654bc772/dep-lib-ed25519-dalek"}}],"rustflags":[],"metadata":14415899641967170644,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/equivalent-b1b430f24fff849d/lib-equivalent.json ---
{"rustc":15699327122048238920,"features":"[]","target":5369500857569226296,"profile":13904479058746662784,"path":7673156394929240681,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/equivalent-b1b430f24fff849d/dep-lib-equivalent"}}],"rustflags":[],"metadata":4899064301576391224,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/fixed-hash-8d12a5bd0026a574/lib-fixed-hash.json ---
{"rustc":15699327122048238920,"features":"[\"byteorder\", \"rand\", \"rustc-hex\", \"std\"]","target":11927488339380359092,"profile":8106212204186106853,"path":956694880792436418,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[5910892534286594076,"rand",false,12119139654645086933],[6476817338883840430,"static_assertions",false,5549146325225610330],[13370790239003944599,"rustc_hex",false,6182892224176002984]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/fixed-hash-8d12a5bd0026a574/dep-lib-fixed-hash"}}],"rustflags":[],"metadata":13792661670533051741,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/funty-1c4e7e1c1aadfaca/lib-funty.json ---
{"rustc":15699327122048238920,"features":"[]","target":3041465511605302338,"profile":8106212204186106853,"path":16513283975910573535,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/funty-1c4e7e1c1aadfaca/dep-lib-funty"}}],"rustflags":[],"metadata":9237712608396048968,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/generic-array-1c8bb2caf70d8c87/lib-generic_array.json ---
{"rustc":15699327122048238920,"features":"[\"more_lengths\"]","target":1954542678444077814,"profile":8106212204186106853,"path":9408313423266524052,"deps":[[9665562089965330559,"build_script_build",false,5653098060343226732],[11395083745183091805,"typenum",false,803350758387535478]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/generic-array-1c8bb2caf70d8c87/dep-lib-generic_array"}}],"rustflags":[],"metadata":3504643559825856545,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/generic-array-b1ce76c93772ff3c/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"more_lengths\"]","target":8188216131759486267,"profile":13904479058746662784,"path":10021301280718850922,"deps":[[16079472387499994964,"version_check",false,4685054622422357781]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/generic-array-b1ce76c93772ff3c/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":3504643559825856545,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/generic-array-c527a6a11b9662e4/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[9665562089965330559,"build_script_build",false,9984970284941693318]],"local":[{"Precalculated":"0.14.7"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/getrandom-1115d65dc459b699/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":18266660653689588643,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/getrandom-1115d65dc459b699/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":12606519392706294666,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/getrandom-6b0de468cffbca18/lib-getrandom.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":16789414514566550411,"profile":8106212204186106853,"path":16578022024192305065,"deps":[[2452538001284770427,"cfg_if",false,5764025957637320001],[2798846484360888381,"libc",false,1987128554771639862],[6453573393678185459,"build_script_build",false,4885672498151784445]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/getrandom-6b0de468cffbca18/dep-lib-getrandom"}}],"rustflags":[],"metadata":12606519392706294666,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/getrandom-99809381601c096b/lib-getrandom.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":16789414514566550411,"profile":8106212204186106853,"path":14220430705516715995,"deps":[[2452538001284770427,"cfg_if",false,5764025957637320001],[2798846484360888381,"libc",false,1987128554771639862]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/getrandom-99809381601c096b/dep-lib-getrandom"}}],"rustflags":[],"metadata":12606519392706294666,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/getrandom-b7106af2cd28e076/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[6453573393678185459,"build_script_build",false,2802053160340943572]],"local":[{"Precalculated":"0.1.16"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/hashbrown-a4660b9e3fc4e170/lib-hashbrown.json ---
{"rustc":15699327122048238920,"features":"[\"ahash\", \"default\", \"inline-more\"]","target":11240190406153278838,"profile":8106212204186106853,"path":12348266937490265093,"deps":[[6564554279330852038,"ahash",false,12062296791202482615]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/hashbrown-a4660b9e3fc4e170/dep-lib-hashbrown"}}],"rustflags":[],"metadata":6228333144549390726,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/hashbrown-f815b7fe1bbcb797/lib-hashbrown.json ---
{"rustc":15699327122048238920,"features":"[\"raw\"]","target":2387001741810630927,"profile":13904479058746662784,"path":5807479545884993206,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/hashbrown-f815b7fe1bbcb797/dep-lib-hashbrown"}}],"rustflags":[],"metadata":6228333144549390726,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/heck-0e5877dfd4b68df8/lib-heck.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":11271119367433188140,"profile":13904479058746662784,"path":6989652837753753700,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/heck-0e5877dfd4b68df8/dep-lib-heck"}}],"rustflags":[],"metadata":4968006677088137060,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/hex-79229d51a3eeaed8/lib-hex.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"std\"]","target":2806462642998046779,"profile":8106212204186106853,"path":5704342148300224406,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/hex-79229d51a3eeaed8/dep-lib-hex"}}],"rustflags":[],"metadata":14751499657425910276,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/iana-time-zone-941a09cc4148cfa5/lib-iana-time-zone.json ---
{"rustc":15699327122048238920,"features":"[\"fallback\"]","target":14189373027157833265,"profile":8106212204186106853,"path":3840184951679906702,"deps":[[11136748990336542442,"core_foundation_sys",false,993775275831501149]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/iana-time-zone-941a09cc4148cfa5/dep-lib-iana-time-zone"}}],"rustflags":[],"metadata":14816295700462397125,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/impl-codec-9067e2deccee9395/lib-impl-codec.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":9931327379393627303,"profile":8106212204186106853,"path":6991320075570824743,"deps":[[397054333907348796,"parity_scale_codec",false,12980816355959003655]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/impl-codec-9067e2deccee9395/dep-lib-impl-codec"}}],"rustflags":[],"metadata":5277811016856928684,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/impl-trait-for-tuples-1f528ea456f12cd2/lib-impl-trait-for-tuples.json ---
{"rustc":15699327122048238920,"features":"[]","target":7437455607898735753,"profile":13904479058746662784,"path":9073304232921617800,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/impl-trait-for-tuples-1f528ea456f12cd2/dep-lib-impl-trait-for-tuples"}}],"rustflags":[],"metadata":5996218443431542618,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/indexmap-bccc87a31a2111ea/lib-indexmap.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":2462882088093504370,"profile":13904479058746662784,"path":18085904500092235962,"deps":[[15758785351647784501,"equivalent",false,4534489907548071919],[17754313664244986564,"hashbrown",false,16176222844800055251]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/indexmap-bccc87a31a2111ea/dep-lib-indexmap"}}],"rustflags":[],"metadata":17706083020874861743,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/itoa-630cf89b825b2b41/lib-itoa.json ---
{"rustc":15699327122048238920,"features":"[]","target":17114873591667335244,"profile":8106212204186106853,"path":12832357535484239742,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/itoa-630cf89b825b2b41/dep-lib-itoa"}}],"rustflags":[],"metadata":851671291587502216,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/keccak-f0eee331f101a48d/lib-keccak.json ---
{"rustc":15699327122048238920,"features":"[]","target":2079549898976005017,"profile":8106212204186106853,"path":15934768203302093888,"deps":[[17351364991019179981,"cpufeatures",false,7104279565031596590]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/keccak-f0eee331f101a48d/dep-lib-keccak"}}],"rustflags":[],"metadata":17580716165873092201,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/lazy_static-78b1e2c47f102258/lib-lazy_static.json ---
{"rustc":15699327122048238920,"features":"[\"spin\", \"spin_no_std\"]","target":1623840821729021818,"profile":8106212204186106853,"path":5523042254165457566,"deps":[[15752510154921626426,"spin",false,16262991967970674462]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/lazy_static-78b1e2c47f102258/dep-lib-lazy_static"}}],"rustflags":[],"metadata":111743654650316589,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/libc-219a6fea0e319a92/lib-libc.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1307715644349195660,"profile":8106212204186106853,"path":2344063006591633611,"deps":[[2798846484360888381,"build_script_build",false,6143497777401192887]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/libc-219a6fea0e319a92/dep-lib-libc"}}],"rustflags":[],"metadata":14998826085014762512,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/libc-4c6b0fbf491c9823/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":8188216131759486267,"profile":13904479058746662784,"path":4298656184704119386,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/libc-4c6b0fbf491c9823/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":14998826085014762512,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/libc-6de21bff115d96c3/lib-libc.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1307715644349195660,"profile":13904479058746662784,"path":2344063006591633611,"deps":[[2798846484360888381,"build_script_build",false,6143497777401192887]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/libc-6de21bff115d96c3/dep-lib-libc"}}],"rustflags":[],"metadata":14998826085014762512,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/libc-ac01fc990d58b73c/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[2798846484360888381,"build_script_build",false,5679297973784050940]],"local":[{"RerunIfChanged":{"output":"debug/build/libc-ac01fc990d58b73c/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/memory_units-2c238ce58d31d060/lib-memory_units.json ---
{"rustc":15699327122048238920,"features":"[]","target":14318584593297629915,"profile":8106212204186106853,"path":9747641232677581986,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/memory_units-2c238ce58d31d060/dep-lib-memory_units"}}],"rustflags":[],"metadata":16366510313631463741,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-abi-1581ced7b83346a8/lib-near-abi.json ---
{"rustc":15699327122048238920,"features":"[\"__chunked-entries\"]","target":3772619746852673170,"profile":8106212204186106853,"path":9976207718907102603,"deps":[[8370833984941964102,"semver",false,17376342669785469182],[13434381959712907675,"borsh",false,8927826740933816849],[13519362093482305381,"schemars",false,12318024354050982525],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-abi-1581ced7b83346a8/dep-lib-near-abi"}}],"rustflags":[],"metadata":2664010391987966176,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-account-id-496a93e9ea5256f6/lib-near-account-id.json ---
{"rustc":15699327122048238920,"features":"[\"borsh\", \"default\", \"internal_unstable\", \"serde\"]","target":1112919889467187854,"profile":8106212204186106853,"path":5143785633286586107,"deps":[[13434381959712907675,"borsh",false,8927826740933816849],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-account-id-496a93e9ea5256f6/dep-lib-near-account-id"}}],"rustflags":[],"metadata":6147166356502881175,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-crypto-8ff35c89d15cbec2/lib-near-crypto.json ---
{"rustc":15699327122048238920,"features":"[]","target":8139541167423765329,"profile":8106212204186106853,"path":9211736250195005533,"deps":[[2141327583381695929,"near_account_id",false,12814558262176044412],[2481462472726891783,"derive_more",false,16561258881570860039],[2711478123133662383,"bs58",false,10621309685841401131],[4424799446218848649,"once_cell",false,8792749180053218143],[4748012609204464776,"arrayref",false,17202610631094475176],[5751920542139757056,"serde_json",false,8714104782801396660],[6730075568351986827,"curve25519_dalek",false,3695814637708764742],[7588362918154833280,"blake2",false,7129888240964092434],[7704765042583084768,"secp256k1",false,2685866441854633899],[11351592370471351887,"c2_chacha",false,18320186358789680502],[11652100930071167282,"subtle",false,4266431561348681734],[11761531122794857361,"rand_core",false,2666242172052674960],[13434381959712907675,"borsh",false,8927826740933816849],[14242825848293686207,"primitive_types",false,793999423088881993],[14778545527639897399,"rand",false,9242952068168568544],[16541512147832429655,"ed25519_dalek",false,14599227444243051071],[17901055676239590300,"thiserror",false,9049002425650416125],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-crypto-8ff35c89d15cbec2/dep-lib-near-crypto"}}],"rustflags":[],"metadata":12117534483879381657,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-primitives-core-8098bc88d2ee8003/lib-near-primitives-core.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"protocol_feature_alt_bn128\"]","target":2344394982970728828,"profile":8106212204186106853,"path":3673705687629640915,"deps":[[2141327583381695929,"near_account_id",false,12814558262176044412],[2481462472726891783,"derive_more",false,16561258881570860039],[2711478123133662383,"bs58",false,10621309685841401131],[5276859243446452557,"strum",false,2839125926144757544],[7262467505971810787,"sha2",false,16344936082252861471],[11928408529930203077,"num_rational",false,2915398947813913809],[13434381959712907675,"borsh",false,8927826740933816849],[14594032103777070403,"base64",false,10118307754179242473],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-primitives-core-8098bc88d2ee8003/dep-lib-near-primitives-core"}}],"rustflags":[],"metadata":5142335245828182684,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-primitives-f22de9f6fff287cd/lib-near-primitives.json ---
{"rustc":15699327122048238920,"features":"[]","target":4604409214736594808,"profile":8106212204186106853,"path":7176500472357347664,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[2481462472726891783,"derive_more",false,16561258881570860039],[2586768231193208483,"near_vm_errors",false,858834630573520996],[4424799446218848649,"once_cell",false,8792749180053218143],[4485243235582659819,"hex",false,4349120191336758986],[4954895508850935142,"near_crypto",false,12261506581225080558],[5211592845914903421,"smart_default",false,16684736684581679684],[5276859243446452557,"strum",false,2839125926144757544],[5385186903921993813,"bytesize",false,12288701669862277037],[5610977137992594292,"near_rpc_error_macro",false,9811210718746699732],[5751920542139757056,"serde_json",false,8714104782801396660],[7546918406050397588,"reed_solomon_erasure",false,9622563689862481559],[8996812700995868408,"near_primitives_core",false,4972822534321846433],[10957551418120553867,"chrono",false,14192972905719546238],[11928408529930203077,"num_rational",false,2915398947813913809],[13434381959712907675,"borsh",false,8927826740933816849],[14242825848293686207,"primitive_types",false,793999423088881993],[14678326912100390537,"easy_ext",false,5024772744819050667],[14778545527639897399,"rand",false,9242952068168568544],[17901055676239590300,"thiserror",false,9049002425650416125],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-primitives-f22de9f6fff287cd/dep-lib-near-primitives"}}],"rustflags":[],"metadata":8957259720546107715,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-rpc-error-core-fb312fbb1f015a8d/lib-near-rpc-error-core.json ---
{"rustc":15699327122048238920,"features":"[]","target":16926289585757093748,"profile":13904479058746662784,"path":16400636455810111628,"deps":[[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004],[18260804926946925357,"serde",false,16183104204101699925]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-rpc-error-core-fb312fbb1f015a8d/dep-lib-near-rpc-error-core"}}],"rustflags":[],"metadata":8565167639935453145,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-rpc-error-macro-219d7688fe6eb695/lib-near-rpc-error-macro.json ---
{"rustc":15699327122048238920,"features":"[]","target":1212076242871055603,"profile":13904479058746662784,"path":13162455868889312286,"deps":[[13787844107785009363,"near_rpc_error_core",false,9473878357709482410],[17143850428905299221,"syn",false,4518100268820504004],[18260804926946925357,"serde",false,16183104204101699925]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-rpc-error-macro-219d7688fe6eb695/dep-lib-near-rpc-error-macro"}}],"rustflags":[],"metadata":8565167639935453145,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-sdk-56be9cd540418aeb/lib-near-sdk.json ---
{"rustc":15699327122048238920,"features":"[\"abi\", \"default\", \"legacy\", \"near-abi\", \"near-crypto\", \"near-primitives\", \"near-primitives-core\", \"near-vm-logic\", \"schemars\", \"unit-testing\", \"wee_alloc\"]","target":11925494537554991322,"profile":8106212204186106853,"path":12456458662647203773,"deps":[[2711478123133662383,"bs58",false,10621309685841401131],[2748724984193634118,"near_abi",false,5765444684137100632],[3178493835647231921,"wee_alloc",false,11321101365246796105],[4424799446218848649,"once_cell",false,8792749180053218143],[4790332501662844689,"base64",false,3016440964827096068],[4954895508850935142,"near_crypto",false,12261506581225080558],[5751920542139757056,"serde_json",false,8714104782801396660],[5932706134621176765,"near_vm_logic",false,307316016282071376],[8996812700995868408,"near_primitives_core",false,4972822534321846433],[9608617076544306583,"near_sys",false,7679201922102088172],[13195315199838120338,"near_sdk_macros",false,4401860644342240599],[13434381959712907675,"borsh",false,8927826740933816849],[13519362093482305381,"schemars",false,12318024354050982525],[14899769415963221159,"near_primitives",false,10784442935703240342],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-sdk-56be9cd540418aeb/dep-lib-near-sdk"}}],"rustflags":[],"metadata":9215943102709044213,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-sdk-macros-dc50b03c07589078/lib-near-sdk-macros.json ---
{"rustc":15699327122048238920,"features":"[\"abi\"]","target":16568417427542612,"profile":13904479058746662784,"path":9780430594623096928,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[7454270075138479745,"inflector",false,16096232338324107185],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-sdk-macros-dc50b03c07589078/dep-lib-near-sdk-macros"}}],"rustflags":[],"metadata":9520434766592551999,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-sys-586a7840206e1b78/lib-near-sys.json ---
{"rustc":15699327122048238920,"features":"[]","target":4927594367761543910,"profile":8106212204186106853,"path":10750026643164942851,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-sys-586a7840206e1b78/dep-lib-near-sys"}}],"rustflags":[],"metadata":14904885344401450229,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-vm-errors-d89b1c3f1e9dac00/lib-near-vm-errors.json ---
{"rustc":15699327122048238920,"features":"[\"protocol_feature_alt_bn128\"]","target":18069981547234658038,"profile":8106212204186106853,"path":4343621220498405118,"deps":[[2141327583381695929,"near_account_id",false,12814558262176044412],[5610977137992594292,"near_rpc_error_macro",false,9811210718746699732],[13434381959712907675,"borsh",false,8927826740933816849],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-vm-errors-d89b1c3f1e9dac00/dep-lib-near-vm-errors"}}],"rustflags":[],"metadata":8179371643365061792,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/near-vm-logic-fc3563aef34fdc9f/lib-near-vm-logic.json ---
{"rustc":15699327122048238920,"features":"[\"bn\", \"default\", \"protocol_feature_alt_bn128\"]","target":6965730565760654885,"profile":8106212204186106853,"path":9250440989648222591,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[2141327583381695929,"near_account_id",false,12814558262176044412],[2586768231193208483,"near_vm_errors",false,858834630573520996],[2711478123133662383,"bs58",false,10621309685841401131],[4790332501662844689,"base64",false,3016440964827096068],[4954895508850935142,"near_crypto",false,12261506581225080558],[7262467505971810787,"sha2",false,16344936082252861471],[8996812700995868408,"near_primitives_core",false,4972822534321846433],[11631693908364750144,"ripemd",false,15202103403277753488],[12558261799987326271,"bn",false,4971254382442706590],[13434381959712907675,"borsh",false,8927826740933816849],[14899769415963221159,"near_primitives",false,10784442935703240342],[16401311334194785499,"sha3",false,1987220810567415443],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/near-vm-logic-fc3563aef34fdc9f/dep-lib-near-vm-logic"}}],"rustflags":[],"metadata":5606999395439952070,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/nearcon-factory-contract-297f47154745ebc0/test-lib-nearcon-factory-contract.json ---
{"rustc":15699327122048238920,"features":"[]","target":6817780012199052871,"profile":13053956386274884697,"path":17523903030608720598,"deps":[[5751920542139757056,"serde_json",false,8714104782801396660],[14706394349651137205,"near_sdk",false,8053708400207440836]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/nearcon-factory-contract-297f47154745ebc0/dep-test-lib-nearcon-factory-contract"}}],"rustflags":[],"metadata":9592253857461293192,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/nearcon-factory-contract-6428cc0caf93dca9/lib-nearcon-factory-contract.json ---
{"rustc":15699327122048238920,"features":"[]","target":6817780012199052871,"profile":13396965805329499462,"path":17523903030608720598,"deps":[[5751920542139757056,"serde_json",false,8714104782801396660],[14706394349651137205,"near_sdk",false,8053708400207440836]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/nearcon-factory-contract-6428cc0caf93dca9/dep-lib-nearcon-factory-contract"}}],"rustflags":[],"metadata":9592253857461293192,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-bigint-2c16c5b9ee8bebf3/lib-num-bigint.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":2482347320759620647,"profile":8106212204186106853,"path":18386927591516392194,"deps":[[1494750142361447113,"num_integer",false,12889075508347676609],[7201007571111540716,"build_script_build",false,9618708535425416871],[10539592998943336449,"num_traits",false,9133487546206414773]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-bigint-2c16c5b9ee8bebf3/dep-lib-num-bigint"}}],"rustflags":[],"metadata":10601054166942238371,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-bigint-36a6f3c0609f61e5/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":17948478381310111067,"deps":[[14832468857926148571,"autocfg",false,1938374451548980170]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-bigint-36a6f3c0609f61e5/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":10601054166942238371,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-bigint-e456b3fc23ac8e2a/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[7201007571111540716,"build_script_build",false,8623171455147219678]],"local":[{"RerunIfChanged":{"output":"debug/build/num-bigint-e456b3fc23ac8e2a/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-integer-890ccace086c54ce/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"i128\", \"std\"]","target":8188216131759486267,"profile":13904479058746662784,"path":16186467233101850543,"deps":[[14832468857926148571,"autocfg",false,1938374451548980170]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-integer-890ccace086c54ce/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":58200369117550911,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-integer-9712ca33704be101/lib-num-integer.json ---
{"rustc":15699327122048238920,"features":"[\"i128\", \"std\"]","target":3383076079041854775,"profile":8106212204186106853,"path":13483982641064524480,"deps":[[1494750142361447113,"build_script_build",false,9128166778871374068],[10539592998943336449,"num_traits",false,9133487546206414773]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-integer-9712ca33704be101/dep-lib-num-integer"}}],"rustflags":[],"metadata":58200369117550911,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-integer-b553ada80577b514/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[1494750142361447113,"build_script_build",false,323090331715559252]],"local":[{"RerunIfChanged":{"output":"debug/build/num-integer-b553ada80577b514/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-rational-cbf21db3966cd0e3/lib-num-rational.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"num-bigint\", \"num-bigint-std\", \"serde\", \"std\"]","target":15205359493017569073,"profile":8106212204186106853,"path":3068561216327930239,"deps":[[1494750142361447113,"num_integer",false,12889075508347676609],[7201007571111540716,"num_bigint",false,10548395762193114740],[10539592998943336449,"num_traits",false,9133487546206414773],[11928408529930203077,"build_script_build",false,1097853269058542686],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-rational-cbf21db3966cd0e3/dep-lib-num-rational"}}],"rustflags":[],"metadata":18311408697950330488,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-rational-d291a986acdd5623/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"num-bigint\", \"num-bigint-std\", \"serde\", \"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":10235814943221294556,"deps":[[14832468857926148571,"autocfg",false,1938374451548980170]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-rational-d291a986acdd5623/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":18311408697950330488,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-rational-e301223049b3d19f/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[11928408529930203077,"build_script_build",false,17850489113544177830]],"local":[{"RerunIfChanged":{"output":"debug/build/num-rational-e301223049b3d19f/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-traits-51369917f0575d6c/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[10539592998943336449,"build_script_build",false,3961436412215347476]],"local":[{"RerunIfChanged":{"output":"debug/build/num-traits-51369917f0575d6c/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-traits-621f8a1603e58da8/lib-num-traits.json ---
{"rustc":15699327122048238920,"features":"[\"i128\", \"std\"]","target":13532427974969447295,"profile":8106212204186106853,"path":4133029519948750106,"deps":[[10539592998943336449,"build_script_build",false,4392153257636423880]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-traits-621f8a1603e58da8/dep-lib-num-traits"}}],"rustflags":[],"metadata":14621636500951049976,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/num-traits-d5e58469c9e6fe2e/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"i128\", \"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":12806378744301844499,"deps":[[14832468857926148571,"autocfg",false,1938374451548980170]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-traits-d5e58469c9e6fe2e/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":14621636500951049976,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/once_cell-b568a843e91ccb0e/lib-once_cell.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"race\", \"std\"]","target":14856186769647684053,"profile":13904479058746662784,"path":4383825698887745490,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/once_cell-b568a843e91ccb0e/dep-lib-once_cell"}}],"rustflags":[],"metadata":14177539708254521827,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/once_cell-d984bb228aa77599/lib-once_cell.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"race\", \"std\"]","target":14856186769647684053,"profile":8106212204186106853,"path":4383825698887745490,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/once_cell-d984bb228aa77599/dep-lib-once_cell"}}],"rustflags":[],"metadata":14177539708254521827,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/opaque-debug-3c95d24f1cf5e5d2/lib-opaque-debug.json ---
{"rustc":15699327122048238920,"features":"[]","target":7371314991062858825,"profile":8106212204186106853,"path":12728053362660090820,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/opaque-debug-3c95d24f1cf5e5d2/dep-lib-opaque-debug"}}],"rustflags":[],"metadata":8060500437326165382,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/parity-scale-codec-3c4aeba41aeb2ca2/lib-parity-scale-codec.json ---
{"rustc":15699327122048238920,"features":"[\"bitvec\", \"chain-error\", \"max-encoded-len\", \"parity-scale-codec-derive\", \"serde\", \"std\"]","target":18009624782468700923,"profile":8106212204186106853,"path":13891297256464362218,"deps":[[6780837041381009114,"parity_scale_codec_derive",false,8840471476544061268],[7203772136960224430,"arrayvec",false,3413444073449318922],[8865365780650178877,"bitvec",false,15816616818593873191],[15445385477726562306,"impl_trait_for_tuples",false,8239740469386745406],[15874152742692298584,"byte_slice_cast",false,15131956339241092615],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/parity-scale-codec-3c4aeba41aeb2ca2/dep-lib-parity-scale-codec"}}],"rustflags":[],"metadata":11875060396614366296,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/parity-scale-codec-derive-73b3f503b157ecd5/lib-parity-scale-codec-derive.json ---
{"rustc":15699327122048238920,"features":"[\"max-encoded-len\"]","target":14504831501163380313,"profile":13904479058746662784,"path":11467235643737188857,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17003263645728167380,"proc_macro_crate",false,14131438790639296442],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/parity-scale-codec-derive-73b3f503b157ecd5/dep-lib-parity-scale-codec-derive"}}],"rustflags":[],"metadata":14884885833291977123,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/parity-secp256k1-4b1a395a29783579/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[7704765042583084768,"build_script_build",false,15466894369446290700]],"local":[{"RerunIfEnvChanged":{"var":"CC_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"CC_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_CC","val":null}},{"RerunIfEnvChanged":{"var":"CC","val":null}},{"RerunIfEnvChanged":{"var":"CRATE_CC_NO_DEFAULTS","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_CFLAGS","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS","val":null}},{"RerunIfEnvChanged":{"var":"CC_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"CC_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_CC","val":null}},{"RerunIfEnvChanged":{"var":"CC","val":null}},{"RerunIfEnvChanged":{"var":"CRATE_CC_NO_DEFAULTS","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_CFLAGS","val":null}},{"RerunIfEnvChanged":{"var":"CFLAGS","val":null}},{"RerunIfEnvChanged":{"var":"AR_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"AR_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_AR","val":null}},{"RerunIfEnvChanged":{"var":"AR","val":null}},{"RerunIfEnvChanged":{"var":"ARFLAGS_aarch64-apple-darwin","val":null}},{"RerunIfEnvChanged":{"var":"ARFLAGS_aarch64_apple_darwin","val":null}},{"RerunIfEnvChanged":{"var":"HOST_ARFLAGS","val":null}},{"RerunIfEnvChanged":{"var":"ARFLAGS","val":null}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/parity-secp256k1-6fc39df9c3b0a0d5/lib-secp256k1.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":17470044212437035966,"profile":8106212204186106853,"path":14922584308608173407,"deps":[[7704765042583084768,"build_script_build",false,2887821064506332006],[13133975285667102737,"arrayvec",false,11002665959367997331],[14778545527639897399,"rand",false,9242952068168568544]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/parity-secp256k1-6fc39df9c3b0a0d5/dep-lib-secp256k1"}}],"rustflags":[],"metadata":9768936618333975934,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/parity-secp256k1-e093f35a94512032/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":8188216131759486267,"profile":13904479058746662784,"path":10992723647500227330,"deps":[[4222409690985087007,"cc",false,2763567876637030593],[11311719388751911026,"cfg_if",false,13741155399363260674]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/parity-secp256k1-e093f35a94512032/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":9768936618333975934,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ppv-lite86-2d02af8d3a7cc1b6/lib-ppv-lite86.json ---
{"rustc":15699327122048238920,"features":"[\"simd\", \"std\"]","target":602634026009422966,"profile":8106212204186106853,"path":4036206313684995868,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ppv-lite86-2d02af8d3a7cc1b6/dep-lib-ppv-lite86"}}],"rustflags":[],"metadata":14155036307809790115,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/primitive-types-3d072a0064657f1a/lib-primitive-types.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"impl-codec\", \"std\"]","target":7171438785384587657,"profile":8106212204186106853,"path":12194688762646719859,"deps":[[1048698513431552377,"fixed_hash",false,7439150028037963227],[2354418988992935079,"impl_codec",false,17650086102410166310],[6802633723977166222,"uint",false,18193284074914033484]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/primitive-types-3d072a0064657f1a/dep-lib-primitive-types"}}],"rustflags":[],"metadata":14754221332772532696,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/proc-macro-crate-19810ca75a8bf1b9/lib-proc-macro-crate.json ---
{"rustc":15699327122048238920,"features":"[]","target":12659122973440766864,"profile":13904479058746662784,"path":1417307583507920386,"deps":[[4424799446218848649,"once_cell",false,114352588314515434],[8296793532158321601,"toml_edit",false,10449295702267883629]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro-crate-19810ca75a8bf1b9/dep-lib-proc-macro-crate"}}],"rustflags":[],"metadata":4875023412952309093,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/proc-macro-crate-6ca60b8a9baf297a/lib-proc-macro-crate.json ---
{"rustc":15699327122048238920,"features":"[]","target":7474588766210387923,"profile":13904479058746662784,"path":227868375118459675,"deps":[[6554997584025100622,"toml",false,13592549270093858642]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro-crate-6ca60b8a9baf297a/dep-lib-proc-macro-crate"}}],"rustflags":[],"metadata":4875023412952309093,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/proc-macro2-161b2d59a9f9cd1e/lib-proc-macro2.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":16714894217519287322,"profile":13904479058746662784,"path":11796634835171484160,"deps":[[2275467556785573469,"build_script_build",false,9727168569871984133],[10721203361745528474,"unicode_ident",false,18348556455743024392]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-161b2d59a9f9cd1e/dep-lib-proc-macro2"}}],"rustflags":[],"metadata":7635439851376710101,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/proc-macro2-afe4a2ee50c0a3a0/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[2275467556785573469,"build_script_build",false,5783996948327216656]],"local":[{"RerunIfChanged":{"output":"debug/build/proc-macro2-afe4a2ee50c0a3a0/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/proc-macro2-c8fba50fc9fb8a29/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":427768481117760528,"profile":13904479058746662784,"path":8992500073505163134,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-c8fba50fc9fb8a29/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":7635439851376710101,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/quote-721312e3b935274c/lib-quote.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":10824007166531090010,"profile":13904479058746662784,"path":13692805388911958044,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/quote-721312e3b935274c/dep-lib-quote"}}],"rustflags":[],"metadata":2717943770976187624,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/radium-04ca0a7e873e16de/lib-radium.json ---
{"rustc":15699327122048238920,"features":"[]","target":8067319890566194752,"profile":8106212204186106853,"path":3859037225576075840,"deps":[[188905226975056936,"build_script_build",false,17093409072272282489]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/radium-04ca0a7e873e16de/dep-lib-radium"}}],"rustflags":[],"metadata":13584132765049742942,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/radium-155d1d9c0a92dde6/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":2297296889237502566,"profile":13904479058746662784,"path":2949163377135508883,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/radium-155d1d9c0a92dde6/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":13584132765049742942,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/radium-de881ebf9ed57bad/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[188905226975056936,"build_script_build",false,12580618988109239019]],"local":[{"Precalculated":"0.6.2"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand-91eb593592fb21b1/lib-rand.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"getrandom\", \"libc\", \"rand_chacha\", \"std\"]","target":17786277519600763311,"profile":8106212204186106853,"path":17052163523667617235,"deps":[[1565494060434293766,"rand_core",false,6744651114466834215],[2798846484360888381,"libc",false,1987128554771639862],[12017018019769837221,"rand_chacha",false,10100689257038665110]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand-91eb593592fb21b1/dep-lib-rand"}}],"rustflags":[],"metadata":16964019146302480911,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand-f4716ac8cb8c98a6/lib-rand.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"getrandom\", \"getrandom_package\", \"libc\", \"std\"]","target":17786277519600763311,"profile":8106212204186106853,"path":9889932960695192476,"deps":[[2798846484360888381,"libc",false,1987128554771639862],[6453573393678185459,"getrandom_package",false,12711997416183943843],[11761531122794857361,"rand_core",false,2666242172052674960],[15629295216311830669,"rand_chacha",false,8107817312712444579]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand-f4716ac8cb8c98a6/dep-lib-rand"}}],"rustflags":[],"metadata":7119169968661360791,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand_chacha-573426e073102c31/lib-rand_chacha.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":3291831172522752161,"profile":8106212204186106853,"path":8371936914834061075,"deps":[[1565494060434293766,"rand_core",false,6744651114466834215],[4511957894497802922,"ppv_lite86",false,37336623232875757]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand_chacha-573426e073102c31/dep-lib-rand_chacha"}}],"rustflags":[],"metadata":2235018391756195449,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand_chacha-794ae634bbbe0856/lib-rand_chacha.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":3291831172522752161,"profile":8106212204186106853,"path":9546066552619178891,"deps":[[4511957894497802922,"ppv_lite86",false,37336623232875757],[11761531122794857361,"rand_core",false,2666242172052674960]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand_chacha-794ae634bbbe0856/dep-lib-rand_chacha"}}],"rustflags":[],"metadata":4815341205625856913,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand_core-6dbe07e2eb3ff81f/lib-rand_core.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"getrandom\", \"std\"]","target":3042383198953219556,"profile":8106212204186106853,"path":7749460294886114753,"deps":[[12202314575583203756,"getrandom",false,3276245713234940752]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand_core-6dbe07e2eb3ff81f/dep-lib-rand_core"}}],"rustflags":[],"metadata":3275543247315060703,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rand_core-ccec530b473799c5/lib-rand_core.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"getrandom\", \"std\"]","target":3042383198953219556,"profile":8106212204186106853,"path":14001692085453202096,"deps":[[6453573393678185459,"getrandom",false,12711997416183943843]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rand_core-ccec530b473799c5/dep-lib-rand_core"}}],"rustflags":[],"metadata":3036601509445419820,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/reed-solomon-erasure-1d5748c3d5bb1e80/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[7546918406050397588,"build_script_build",false,7977624074352603856]],"local":[{"Precalculated":"4.0.2"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/reed-solomon-erasure-36b7bd2106ddd63b/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":2297296889237502566,"profile":13904479058746662784,"path":12732055152935381135,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/reed-solomon-erasure-36b7bd2106ddd63b/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":18181909252143981725,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/reed-solomon-erasure-451cbf124b6408ad/lib-reed-solomon-erasure.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":14858778984349257557,"profile":8106212204186106853,"path":12629167912278095062,"deps":[[7546918406050397588,"build_script_build",false,13689480604232505814],[13327724608739232567,"smallvec",false,13821984955464914357]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/reed-solomon-erasure-451cbf124b6408ad/dep-lib-reed-solomon-erasure"}}],"rustflags":[],"metadata":18181909252143981725,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ripemd-ac7061830d013250/lib-ripemd.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1613712687734081624,"profile":8106212204186106853,"path":10391529471111358348,"deps":[[8784844846616271080,"digest",false,214638896538188420]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ripemd-ac7061830d013250/dep-lib-ripemd"}}],"rustflags":[],"metadata":14578198798605781854,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rustc-hex-af71e3ad5dce6c3b/lib-rustc-hex.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":12485990117678741081,"profile":8106212204186106853,"path":1964029717413694603,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rustc-hex-af71e3ad5dce6c3b/dep-lib-rustc-hex"}}],"rustflags":[],"metadata":11278451656052502128,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rustversion-0fad854280035e63/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":2297296889237502566,"profile":13904479058746662784,"path":2607271446995556262,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rustversion-0fad854280035e63/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11946384680894284015,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rustversion-30092f0adc775e42/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[18418909915171392423,"build_script_build",false,7772960559634574151]],"local":[{"RerunIfChanged":{"output":"debug/build/rustversion-30092f0adc775e42/output","paths":["build/build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/rustversion-aea023e24dec6e95/lib-rustversion.json ---
{"rustc":15699327122048238920,"features":"[]","target":8237524127607741655,"profile":13904479058746662784,"path":499052486164044438,"deps":[[18418909915171392423,"build_script_build",false,10728744452952601505]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/rustversion-aea023e24dec6e95/dep-lib-rustversion"}}],"rustflags":[],"metadata":11946384680894284015,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/ryu-4576bdd4ef42192d/lib-ryu.json ---
{"rustc":15699327122048238920,"features":"[]","target":13901881936739684103,"profile":8106212204186106853,"path":4867907593234663134,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/ryu-4576bdd4ef42192d/dep-lib-ryu"}}],"rustflags":[],"metadata":10387617312689919117,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/schemars-77f51b19dbc9e025/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"impl_json_schema\", \"schemars_derive\"]","target":2297296889237502566,"profile":13904479058746662784,"path":6992114467550045648,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/schemars-77f51b19dbc9e025/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11679674351051169359,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/schemars-c91bf22923ad1a77/lib-schemars.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"impl_json_schema\", \"schemars_derive\"]","target":16218395617641602000,"profile":8106212204186106853,"path":14006680898418958582,"deps":[[538174865708573463,"dyn_clone",false,12341807538230630698],[5751920542139757056,"serde_json",false,8714104782801396660],[13519362093482305381,"build_script_build",false,12568416823900128381],[13685478631301934036,"schemars_derive",false,18215425752160005656],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/schemars-c91bf22923ad1a77/dep-lib-schemars"}}],"rustflags":[],"metadata":11679674351051169359,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/schemars-eaa6d55151d957cb/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[13519362093482305381,"build_script_build",false,3629269299123281666]],"local":[{"Precalculated":"0.8.12"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/schemars_derive-5a797176dbe55f84/lib-schemars_derive.json ---
{"rustc":15699327122048238920,"features":"[]","target":6818468949020714808,"profile":13904479058746662784,"path":3640997363547260656,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[15472200400644609968,"serde_derive_internals",false,1008500854427805674],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/schemars_derive-5a797176dbe55f84/dep-lib-schemars_derive"}}],"rustflags":[],"metadata":17573214762644668264,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/semver-455bdad277cb89d0/lib-semver.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1855717086744217893,"profile":8106212204186106853,"path":3905156107758913639,"deps":[[8370833984941964102,"build_script_build",false,13773564392399236201]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/semver-455bdad277cb89d0/dep-lib-semver"}}],"rustflags":[],"metadata":7480721012031345649,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/semver-97b71a2632309c3d/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[8370833984941964102,"build_script_build",false,17551132073278405351]],"local":[{"RerunIfChanged":{"output":"debug/build/semver-97b71a2632309c3d/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/semver-eb00ec944cb822e8/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":9351936425294567869,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/semver-eb00ec944cb822e8/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":7480721012031345649,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde-06e006b6be40131e/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":2297296889237502566,"profile":13904479058746662784,"path":2816091323965661388,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-06e006b6be40131e/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde-63fee5d4e9e873c0/lib-serde.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":12518487807107382959,"profile":13904479058746662784,"path":2059293589033131972,"deps":[[10264775547355706342,"serde_derive",false,11344089877990510565],[18260804926946925357,"build_script_build",false,13918768112710417258]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-63fee5d4e9e873c0/dep-lib-serde"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde-7f246fb020a7ac43/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[18260804926946925357,"build_script_build",false,7669161124701997354]],"local":[{"RerunIfChanged":{"output":"debug/build/serde-7f246fb020a7ac43/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde-e4f38f7d7b365cff/lib-serde.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":12518487807107382959,"profile":8106212204186106853,"path":2059293589033131972,"deps":[[10264775547355706342,"serde_derive",false,11344089877990510565],[18260804926946925357,"build_script_build",false,13918768112710417258]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-e4f38f7d7b365cff/dep-lib-serde"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde_derive-7394c41afaeef2d8/lib-serde_derive.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":17975654915224872304,"profile":13904479058746662784,"path":4286166998206562974,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[15257104365642082152,"syn",false,15238332361278338973]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_derive-7394c41afaeef2d8/dep-lib-serde_derive"}}],"rustflags":[],"metadata":7087207080818960155,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde_derive_internals-a17d754758cc6888/lib-serde_derive_internals.json ---
{"rustc":15699327122048238920,"features":"[]","target":10801114250991275972,"profile":13904479058746662784,"path":7370719870937853850,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_derive_internals-a17d754758cc6888/dep-lib-serde_derive_internals"}}],"rustflags":[],"metadata":7691849674774261228,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde_json-3cbd03e9e93eedc8/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":427768481117760528,"profile":13904479058746662784,"path":12845853630429608721,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_json-3cbd03e9e93eedc8/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":16261601059619201932,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde_json-7520268d9f9e75c1/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[5751920542139757056,"build_script_build",false,17637677612642774708]],"local":[{"RerunIfChanged":{"output":"debug/build/serde_json-7520268d9f9e75c1/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/serde_json-abd6bfbe3d466646/lib-serde_json.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1572482250304784865,"profile":8106212204186106853,"path":2192819217601010030,"deps":[[5751920542139757056,"build_script_build",false,18083501121199108589],[10680519162924001902,"itoa",false,10596406609728260005],[12140443443804514189,"ryu",false,659722825241415152],[18260804926946925357,"serde",false,8569345683583977006]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_json-abd6bfbe3d466646/dep-lib-serde_json"}}],"rustflags":[],"metadata":16261601059619201932,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/sha2-9c60ee92fb2c0d17/lib-sha2.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":6041420389508982234,"profile":8106212204186106853,"path":818578323090564959,"deps":[[2452538001284770427,"cfg_if",false,5764025957637320001],[8784844846616271080,"digest",false,214638896538188420],[17351364991019179981,"cpufeatures",false,7104279565031596590]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/sha2-9c60ee92fb2c0d17/dep-lib-sha2"}}],"rustflags":[],"metadata":13125521705435454745,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/sha2-a1963bd813ee64eb/lib-sha2.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":6041420389508982234,"profile":8106212204186106853,"path":7967924118235619991,"deps":[[2452538001284770427,"cfg_if",false,5764025957637320001],[5380073082773161146,"block_buffer",false,17103989519836330868],[6014497622236959678,"opaque_debug",false,8908775514494022079],[12829070662860118430,"digest",false,17168197620239039330],[17351364991019179981,"cpufeatures",false,7104279565031596590]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/sha2-a1963bd813ee64eb/dep-lib-sha2"}}],"rustflags":[],"metadata":13125521705435454745,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/sha3-12c3d5b230c646d7/lib-sha3.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":17735848975723662600,"profile":8106212204186106853,"path":16517596479815316990,"deps":[[8784844846616271080,"digest",false,214638896538188420],[17850633121171198749,"keccak",false,2163158102745868235]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/sha3-12c3d5b230c646d7/dep-lib-sha3"}}],"rustflags":[],"metadata":14642484976072726362,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/signature-e2f7f77a89fd0388/lib-signature.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":13175919239257514164,"profile":8106212204186106853,"path":10587212200474681567,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/signature-e2f7f77a89fd0388/dep-lib-signature"}}],"rustflags":[],"metadata":3639813390204373107,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/smallvec-8eb59e85d9e3d38d/lib-smallvec.json ---
{"rustc":15699327122048238920,"features":"[]","target":15021638563153388439,"profile":8106212204186106853,"path":4542481496232315379,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/smallvec-8eb59e85d9e3d38d/dep-lib-smallvec"}}],"rustflags":[],"metadata":15767570753543272391,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/smart-default-e2f5b9e32ec42de7/lib-smart-default.json ---
{"rustc":15699327122048238920,"features":"[]","target":5136326791199682166,"profile":13904479058746662784,"path":17297871344933358003,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[17143850428905299221,"syn",false,4518100268820504004]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/smart-default-e2f5b9e32ec42de7/dep-lib-smart-default"}}],"rustflags":[],"metadata":14558014737287565990,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/spin-d050a7e122e817cc/lib-spin.json ---
{"rustc":15699327122048238920,"features":"[]","target":1472938512845949657,"profile":8106212204186106853,"path":10180934020156896171,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/spin-d050a7e122e817cc/dep-lib-spin"}}],"rustflags":[],"metadata":6620005600999123125,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/static_assertions-cbce9ad72d4b115d/lib-static_assertions.json ---
{"rustc":15699327122048238920,"features":"[]","target":4661364776663884960,"profile":8106212204186106853,"path":2428128509129933866,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/static_assertions-cbce9ad72d4b115d/dep-lib-static_assertions"}}],"rustflags":[],"metadata":16420956093413671072,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/strum-2263894788645e09/lib-strum.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"std\", \"strum_macros\"]","target":17081374028075893283,"profile":8106212204186106853,"path":14763817108314368515,"deps":[[1446301735678115251,"strum_macros",false,10889515638630772745]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/strum-2263894788645e09/dep-lib-strum"}}],"rustflags":[],"metadata":11680211291368566339,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/strum_macros-47e1ffb02862960f/lib-strum_macros.json ---
{"rustc":15699327122048238920,"features":"[]","target":12061214918595282268,"profile":13904479058746662784,"path":5880934372317029956,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[11709930968028960932,"heck",false,10720763146281602345],[17143850428905299221,"syn",false,4518100268820504004],[18418909915171392423,"rustversion",false,3806806209386009625]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/strum_macros-47e1ffb02862960f/dep-lib-strum_macros"}}],"rustflags":[],"metadata":11680211291368566339,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/subtle-a8b2e27c0f4fbf7b/lib-subtle.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"i128\", \"std\"]","target":3031033441136664259,"profile":8106212204186106853,"path":9554963135521855233,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/subtle-a8b2e27c0f4fbf7b/dep-lib-subtle"}}],"rustflags":[],"metadata":9136318916805708739,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/syn-3e1fc02ea761d0a1/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[17143850428905299221,"build_script_build",false,16751855834135428509]],"local":[{"Precalculated":"1.0.109"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/syn-8cc5f140ffb68dc9/lib-syn.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":9229941241798225847,"profile":13904479058746662784,"path":16345241445430471193,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[10721203361745528474,"unicode_ident",false,18348556455743024392]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-8cc5f140ffb68dc9/dep-lib-syn"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/syn-d41ae393905b7af4/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":2297296889237502566,"profile":13904479058746662784,"path":16324885284038255013,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-d41ae393905b7af4/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/syn-e37ea7b92d3b2181/lib-syn.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":8516813339728780372,"profile":13904479058746662784,"path":11168288741992561292,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[10721203361745528474,"unicode_ident",false,18348556455743024392],[17143850428905299221,"build_script_build",false,5758899672336397990]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-e37ea7b92d3b2181/dep-lib-syn"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/tap-4db4c964def1b60a/lib-tap.json ---
{"rustc":15699327122048238920,"features":"[]","target":15858538858624274805,"profile":8106212204186106853,"path":12688800255560109896,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/tap-4db4c964def1b60a/dep-lib-tap"}}],"rustflags":[],"metadata":6574141762495208141,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/thiserror-7bfaa635d19f8650/lib-thiserror.json ---
{"rustc":15699327122048238920,"features":"[]","target":9665835530640840921,"profile":8106212204186106853,"path":5423145339976680400,"deps":[[11961173708853031679,"thiserror_impl",false,16559659856480893874],[17901055676239590300,"build_script_build",false,8854072369847270024]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-7bfaa635d19f8650/dep-lib-thiserror"}}],"rustflags":[],"metadata":11722078131081488174,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/thiserror-9a2c9322856ed3aa/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":427768481117760528,"profile":13904479058746662784,"path":5641545276295539174,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-9a2c9322856ed3aa/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11722078131081488174,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/thiserror-b630d4dc70d62ee8/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[17901055676239590300,"build_script_build",false,14493631693884267029]],"local":[{"Precalculated":"1.0.44"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/thiserror-impl-f26ef10496e1a989/lib-thiserror-impl.json ---
{"rustc":15699327122048238920,"features":"[]","target":4581653930231680166,"profile":13904479058746662784,"path":2188021992136016919,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[15257104365642082152,"syn",false,15238332361278338973]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-impl-f26ef10496e1a989/dep-lib-thiserror-impl"}}],"rustflags":[],"metadata":14048383283908260854,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/time-d9ad227f18c3f944/lib-time.json ---
{"rustc":15699327122048238920,"features":"[]","target":5868266217181056409,"profile":8106212204186106853,"path":13435524364708458258,"deps":[[2798846484360888381,"libc",false,1987128554771639862]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/time-d9ad227f18c3f944/dep-lib-time"}}],"rustflags":[],"metadata":8937303733317455548,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/toml-dfb0bc9ce1118439/lib-toml.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":12757549743382924349,"profile":13904479058746662784,"path":12642978622691932116,"deps":[[18260804926946925357,"serde",false,16183104204101699925]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/toml-dfb0bc9ce1118439/dep-lib-toml"}}],"rustflags":[],"metadata":13437692833141290973,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/toml_datetime-a8925f6bc8d62d39/lib-toml_datetime.json ---
{"rustc":15699327122048238920,"features":"[]","target":14371082279898781439,"profile":13904479058746662784,"path":9106351526329375041,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/toml_datetime-a8925f6bc8d62d39/dep-lib-toml_datetime"}}],"rustflags":[],"metadata":4457034034663589510,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/toml_edit-2b1a9fd145b489e1/lib-toml_edit.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":2019625632009298928,"profile":13904479058746662784,"path":9830341757607965289,"deps":[[743430741442777269,"toml_datetime",false,10158837784448320001],[6016697943151911368,"indexmap",false,2353297953705516945],[7190284625941413814,"winnow",false,5515665356812032813]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/toml_edit-2b1a9fd145b489e1/dep-lib-toml_edit"}}],"rustflags":[],"metadata":17436163843096124214,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/typenum-ae266bb20c1c0bd6/run-build-script-build-script-main.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[11395083745183091805,"build_script_main",false,13872683810254863903]],"local":[{"RerunIfChanged":{"output":"debug/build/typenum-ae266bb20c1c0bd6/output","paths":["build/main.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/typenum-f9a606bcdd288876/lib-typenum.json ---
{"rustc":15699327122048238920,"features":"[]","target":1667919871804902043,"profile":8106212204186106853,"path":14906253602305252104,"deps":[[11395083745183091805,"build_script_main",false,855459674065436783]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/typenum-f9a606bcdd288876/dep-lib-typenum"}}],"rustflags":[],"metadata":5976975242777358168,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/typenum-ffeb346f11a1ef0e/build-script-build-script-main.json ---
{"rustc":15699327122048238920,"features":"[]","target":9021408344364460610,"profile":13904479058746662784,"path":8020855622319277709,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/typenum-ffeb346f11a1ef0e/dep-build-script-build-script-main"}}],"rustflags":[],"metadata":5976975242777358168,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/uint-752f54f20f902ae7/lib-uint.json ---
{"rustc":15699327122048238920,"features":"[\"std\"]","target":7672966471245941834,"profile":8106212204186106853,"path":9455510451727858965,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[4485243235582659819,"hex",false,4349120191336758986],[6476817338883840430,"static_assertions",false,5549146325225610330],[15144909498828475009,"crunchy",false,10134860502340467483]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uint-752f54f20f902ae7/dep-lib-uint"}}],"rustflags":[],"metadata":7122085937130173941,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/unicode-ident-d9624bf63a3259cf/lib-unicode-ident.json ---
{"rustc":15699327122048238920,"features":"[]","target":7243519288898877878,"profile":13904479058746662784,"path":5667461645529735126,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/unicode-ident-d9624bf63a3259cf/dep-lib-unicode-ident"}}],"rustflags":[],"metadata":1159190378059262574,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/version_check-dcd9d58a259cfebc/lib-version_check.json ---
{"rustc":15699327122048238920,"features":"[]","target":1907215788979932987,"profile":13904479058746662784,"path":9409674391701698002,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/version_check-dcd9d58a259cfebc/dep-lib-version_check"}}],"rustflags":[],"metadata":14847206692933921638,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/wee_alloc-acd96d6cf582aad7/lib-wee_alloc.json ---
{"rustc":15699327122048238920,"features":"[]","target":4386990340108308755,"profile":8106212204186106853,"path":6329283078616733185,"deps":[[1429323848562539564,"memory_units",false,9699587010942272462],[2798846484360888381,"libc",false,1987128554771639862],[3178493835647231921,"build_script_build",false,935440369694585929],[11311719388751911026,"cfg_if",false,9797775534309082437]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/wee_alloc-acd96d6cf582aad7/dep-lib-wee_alloc"}}],"rustflags":[],"metadata":11837593470300214873,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/wee_alloc-b2fe6707d88087e1/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":8188216131759486267,"profile":13904479058746662784,"path":2340182334242780106,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/wee_alloc-b2fe6707d88087e1/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11837593470300214873,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/wee_alloc-e8ba7f89fb28bf35/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[3178493835647231921,"build_script_build",false,5816061297954096441]],"local":[{"RerunIfChanged":{"output":"debug/build/wee_alloc-e8ba7f89fb28bf35/output","paths":["./Cargo.toml","./build.rs","./src/lib.rs","./src/imp_static_array.rs"]}},{"RerunIfEnvChanged":{"var":"WEE_ALLOC_STATIC_ARRAY_BACKEND_BYTES","val":null}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/winnow-bada6a86463a7ed4/lib-winnow.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"std\"]","target":1434475815273837950,"profile":13904479058746662784,"path":9431983308943754114,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/winnow-bada6a86463a7ed4/dep-lib-winnow"}}],"rustflags":[],"metadata":7482876514514569712,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/wyz-eb4998c640f6ac75/lib-wyz.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\"]","target":3227559903989411901,"profile":8106212204186106853,"path":8165924934298144738,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/wyz-eb4998c640f6ac75/dep-lib-wyz"}}],"rustflags":[],"metadata":18109821273324682741,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/zeroize-cd75413f03090d30/lib-zeroize.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"zeroize_derive\"]","target":12104206478143992192,"profile":8106212204186106853,"path":15367271038033774461,"deps":[[17194429470758112918,"zeroize_derive",false,4061798282269874643]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/zeroize-cd75413f03090d30/dep-lib-zeroize"}}],"rustflags":[],"metadata":4317945585732210332,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/zeroize_derive-868aec49869db6bc/lib-zeroize_derive.json ---
{"rustc":15699327122048238920,"features":"[]","target":2076303734171676484,"profile":13904479058746662784,"path":6217343133351172599,"deps":[[2275467556785573469,"proc_macro2",false,11208362716596209809],[3475017103742128739,"quote",false,8184889199649644647],[15257104365642082152,"syn",false,15238332361278338973]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/zeroize_derive-868aec49869db6bc/dep-lib-zeroize_derive"}}],"rustflags":[],"metadata":7526780439083680197,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/.fingerprint/zeropool-bn-7c2c2fd97dacfa5f/lib-zeropool-bn.json ---
{"rustc":15699327122048238920,"features":"[\"borsh\", \"default\", \"std\"]","target":3307770964703969394,"profile":8106212204186106853,"path":17062098815741311554,"deps":[[486069622437963759,"byteorder",false,7875851034336734252],[5910892534286594076,"rand",false,12119139654645086933],[6685014296130524576,"lazy_static",false,13484233813409128623],[13370790239003944599,"rustc_hex",false,6182892224176002984],[13434381959712907675,"borsh",false,8927826740933816849],[15144909498828475009,"crunchy",false,10134860502340467483]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/zeropool-bn-7c2c2fd97dacfa5f/dep-lib-zeropool-bn"}}],"rustflags":[],"metadata":3962099761543278488,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/debug/build/crunchy-ddaff50b37de4df2/out/lib.rs ---

/// Unroll the given for loop
///
/// Example:
///
/// ```ignore
/// unroll! {
///   for i in 0..5 {
///     println!("Iteration {}", i);
///   }
/// }
/// ```
///
/// will expand into:
///
/// ```ignore
/// { println!("Iteration {}", 0); }
/// { println!("Iteration {}", 1); }
/// { println!("Iteration {}", 2); }
/// { println!("Iteration {}", 3); }
/// { println!("Iteration {}", 4); }
/// ```
#[macro_export]
macro_rules! unroll {
    (for $v:ident in 0..0 $c:block) => {};

    (for $v:ident < $max:tt in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) => {
        {
            let step = $val;
            let start = $start;
            let end = start + ($end - start) / step;
            unroll! {
                for val < $max in start..end {
                    let $v: usize = ((val - start) * step) + start;

                    $($c)*
                }
            }
        }
    };

    (for $v:ident in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) => {
        unroll! {
            for $v < $end in ($start..$end).step_by($val) {$($c)*}
        }
    };

    (for $v:ident in ($start:tt..$end:tt) {$($c:tt)*}) => {
        unroll!{
            for $v in $start..$end {$($c)*}
        }
    };

    (for $v:ident in $start:tt..$end:tt {$($c:tt)*}) => {
        #[allow(non_upper_case_globals)]
        #[allow(unused_comparisons)]
        {
            unroll!(@$v, 0, $end, {
                    if $v >= $start {$($c)*}
                }
            );
        }
    };

    (for $v:ident < $max:tt in $start:tt..$end:tt $c:block) => {
        #[allow(non_upper_case_globals)]
        {
            let range = $start..$end;
            assert!(
                $max >= range.end,
                "`{}` out of range `{:?}`",
                stringify!($max),
                range,
            );
            unroll!(
                @$v,
                0,
                $max,
                {
                    if $v >= range.start && $v < range.end {
                        $c
                    }
                }
            );
        }
    };

    (for $v:ident in 0..$end:tt {$($statement:tt)*}) => {
        #[allow(non_upper_case_globals)]
        { unroll!(@$v, 0, $end, {$($statement)*}); }
    };

    (@$v:ident, $a:expr, 0, $c:block) => {
        { const $v: usize = $a; $c }
    };

    (@$v:ident, $a:expr, 1, $c:block) => {
        { const $v: usize = $a; $c }
    };

    (@$v:ident, $a:expr, 2, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
    };

    (@$v:ident, $a:expr, 3, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
    };

    (@$v:ident, $a:expr, 4, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
    };

    (@$v:ident, $a:expr, 5, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
    };

    (@$v:ident, $a:expr, 6, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
    };

    (@$v:ident, $a:expr, 7, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
    };

    (@$v:ident, $a:expr, 8, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
    };

    (@$v:ident, $a:expr, 9, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
    };

    (@$v:ident, $a:expr, 10, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
    };

    (@$v:ident, $a:expr, 11, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
    };

    (@$v:ident, $a:expr, 12, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
        { const $v: usize = $a + 11; $c }
    };

    (@$v:ident, $a:expr, 13, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
        { const $v: usize = $a + 11; $c }
        { const $v: usize = $a + 12; $c }
    };

    (@$v:ident, $a:expr, 14, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
        { const $v: usize = $a + 11; $c }
        { const $v: usize = $a + 12; $c }
        { const $v: usize = $a + 13; $c }
    };

    (@$v:ident, $a:expr, 15, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
        { const $v: usize = $a + 11; $c }
        { const $v: usize = $a + 12; $c }
        { const $v: usize = $a + 13; $c }
        { const $v: usize = $a + 14; $c }
    };

    (@$v:ident, $a:expr, 16, $c:block) => {
        { const $v: usize = $a; $c }
        { const $v: usize = $a + 1; $c }
        { const $v: usize = $a + 2; $c }
        { const $v: usize = $a + 3; $c }
        { const $v: usize = $a + 4; $c }
        { const $v: usize = $a + 5; $c }
        { const $v: usize = $a + 6; $c }
        { const $v: usize = $a + 7; $c }
        { const $v: usize = $a + 8; $c }
        { const $v: usize = $a + 9; $c }
        { const $v: usize = $a + 10; $c }
        { const $v: usize = $a + 11; $c }
        { const $v: usize = $a + 12; $c }
        { const $v: usize = $a + 13; $c }
        { const $v: usize = $a + 14; $c }
        { const $v: usize = $a + 15; $c }
    };

    (@$v:ident, $a:expr, 17, $c:block) => {
        unroll!(@$v, $a, 16, $c);
        { const $v: usize = $a + 16; $c }
    };

    (@$v:ident, $a:expr, 18, $c:block) => {
        unroll!(@$v, $a, 9, $c);
        unroll!(@$v, $a + 9, 9, $c);
    };

    (@$v:ident, $a:expr, 19, $c:block) => {
        unroll!(@$v, $a, 18, $c);
        { const $v: usize = $a + 18; $c }
    };

    (@$v:ident, $a:expr, 20, $c:block) => {
        unroll!(@$v, $a, 10, $c);
        unroll!(@$v, $a + 10, 10, $c);
    };

    (@$v:ident, $a:expr, 21, $c:block) => {
        unroll!(@$v, $a, 20, $c);
        { const $v: usize = $a + 20; $c }
    };

    (@$v:ident, $a:expr, 22, $c:block) => {
        unroll!(@$v, $a, 11, $c);
        unroll!(@$v, $a + 11, 11, $c);
    };

    (@$v:ident, $a:expr, 23, $c:block) => {
        unroll!(@$v, $a, 22, $c);
        { const $v: usize = $a + 22; $c }
    };

    (@$v:ident, $a:expr, 24, $c:block) => {
        unroll!(@$v, $a, 12, $c);
        unroll!(@$v, $a + 12, 12, $c);
    };

    (@$v:ident, $a:expr, 25, $c:block) => {
        unroll!(@$v, $a, 24, $c);
        { const $v: usize = $a + 24; $c }
    };

    (@$v:ident, $a:expr, 26, $c:block) => {
        unroll!(@$v, $a, 13, $c);
        unroll!(@$v, $a + 13, 13, $c);
    };

    (@$v:ident, $a:expr, 27, $c:block) => {
        unroll!(@$v, $a, 26, $c);
        { const $v: usize = $a + 26; $c }
    };

    (@$v:ident, $a:expr, 28, $c:block) => {
        unroll!(@$v, $a, 14, $c);
        unroll!(@$v, $a + 14, 14, $c);
    };

    (@$v:ident, $a:expr, 29, $c:block) => {
        unroll!(@$v, $a, 28, $c);
        { const $v: usize = $a + 28; $c }
    };

    (@$v:ident, $a:expr, 30, $c:block) => {
        unroll!(@$v, $a, 15, $c);
        unroll!(@$v, $a + 15, 15, $c);
    };

    (@$v:ident, $a:expr, 31, $c:block) => {
        unroll!(@$v, $a, 30, $c);
        { const $v: usize = $a + 30; $c }
    };

    (@$v:ident, $a:expr, 32, $c:block) => {
        unroll!(@$v, $a, 16, $c);
        unroll!(@$v, $a + 16, 16, $c);
    };

    (@$v:ident, $a:expr, 33, $c:block) => {
        unroll!(@$v, $a, 32, $c);
        { const $v: usize = $a + 32; $c }
    };

    (@$v:ident, $a:expr, 34, $c:block) => {
        unroll!(@$v, $a, 17, $c);
        unroll!(@$v, $a + 17, 17, $c);
    };

    (@$v:ident, $a:expr, 35, $c:block) => {
        unroll!(@$v, $a, 34, $c);
        { const $v: usize = $a + 34; $c }
    };

    (@$v:ident, $a:expr, 36, $c:block) => {
        unroll!(@$v, $a, 18, $c);
        unroll!(@$v, $a + 18, 18, $c);
    };

    (@$v:ident, $a:expr, 37, $c:block) => {
        unroll!(@$v, $a, 36, $c);
        { const $v: usize = $a + 36; $c }
    };

    (@$v:ident, $a:expr, 38, $c:block) => {
        unroll!(@$v, $a, 19, $c);
        unroll!(@$v, $a + 19, 19, $c);
    };

    (@$v:ident, $a:expr, 39, $c:block) => {
        unroll!(@$v, $a, 38, $c);
        { const $v: usize = $a + 38; $c }
    };

    (@$v:ident, $a:expr, 40, $c:block) => {
        unroll!(@$v, $a, 20, $c);
        unroll!(@$v, $a + 20, 20, $c);
    };

    (@$v:ident, $a:expr, 41, $c:block) => {
        unroll!(@$v, $a, 40, $c);
        { const $v: usize = $a + 40; $c }
    };

    (@$v:ident, $a:expr, 42, $c:block) => {
        unroll!(@$v, $a, 21, $c);
        unroll!(@$v, $a + 21, 21, $c);
    };

    (@$v:ident, $a:expr, 43, $c:block) => {
        unroll!(@$v, $a, 42, $c);
        { const $v: usize = $a + 42; $c }
    };

    (@$v:ident, $a:expr, 44, $c:block) => {
        unroll!(@$v, $a, 22, $c);
        unroll!(@$v, $a + 22, 22, $c);
    };

    (@$v:ident, $a:expr, 45, $c:block) => {
        unroll!(@$v, $a, 44, $c);
        { const $v: usize = $a + 44; $c }
    };

    (@$v:ident, $a:expr, 46, $c:block) => {
        unroll!(@$v, $a, 23, $c);
        unroll!(@$v, $a + 23, 23, $c);
    };

    (@$v:ident, $a:expr, 47, $c:block) => {
        unroll!(@$v, $a, 46, $c);
        { const $v: usize = $a + 46; $c }
    };

    (@$v:ident, $a:expr, 48, $c:block) => {
        unroll!(@$v, $a, 24, $c);
        unroll!(@$v, $a + 24, 24, $c);
    };

    (@$v:ident, $a:expr, 49, $c:block) => {
        unroll!(@$v, $a, 48, $c);
        { const $v: usize = $a + 48; $c }
    };

    (@$v:ident, $a:expr, 50, $c:block) => {
        unroll!(@$v, $a, 25, $c);
        unroll!(@$v, $a + 25, 25, $c);
    };

    (@$v:ident, $a:expr, 51, $c:block) => {
        unroll!(@$v, $a, 50, $c);
        { const $v: usize = $a + 50; $c }
    };

    (@$v:ident, $a:expr, 52, $c:block) => {
        unroll!(@$v, $a, 26, $c);
        unroll!(@$v, $a + 26, 26, $c);
    };

    (@$v:ident, $a:expr, 53, $c:block) => {
        unroll!(@$v, $a, 52, $c);
        { const $v: usize = $a + 52; $c }
    };

    (@$v:ident, $a:expr, 54, $c:block) => {
        unroll!(@$v, $a, 27, $c);
        unroll!(@$v, $a + 27, 27, $c);
    };

    (@$v:ident, $a:expr, 55, $c:block) => {
        unroll!(@$v, $a, 54, $c);
        { const $v: usize = $a + 54; $c }
    };

    (@$v:ident, $a:expr, 56, $c:block) => {
        unroll!(@$v, $a, 28, $c);
        unroll!(@$v, $a + 28, 28, $c);
    };

    (@$v:ident, $a:expr, 57, $c:block) => {
        unroll!(@$v, $a, 56, $c);
        { const $v: usize = $a + 56; $c }
    };

    (@$v:ident, $a:expr, 58, $c:block) => {
        unroll!(@$v, $a, 29, $c);
        unroll!(@$v, $a + 29, 29, $c);
    };

    (@$v:ident, $a:expr, 59, $c:block) => {
        unroll!(@$v, $a, 58, $c);
        { const $v: usize = $a + 58; $c }
    };

    (@$v:ident, $a:expr, 60, $c:block) => {
        unroll!(@$v, $a, 30, $c);
        unroll!(@$v, $a + 30, 30, $c);
    };

    (@$v:ident, $a:expr, 61, $c:block) => {
        unroll!(@$v, $a, 60, $c);
        { const $v: usize = $a + 60; $c }
    };

    (@$v:ident, $a:expr, 62, $c:block) => {
        unroll!(@$v, $a, 31, $c);
        unroll!(@$v, $a + 31, 31, $c);
    };

    (@$v:ident, $a:expr, 63, $c:block) => {
        unroll!(@$v, $a, 62, $c);
        { const $v: usize = $a + 62; $c }
    };

    (@$v:ident, $a:expr, 64, $c:block) => {
        unroll!(@$v, $a, 32, $c);
        unroll!(@$v, $a + 32, 32, $c);
    };

    (@$v:ident, $a:expr, 65, $c:block) => {
        unroll!(@$v, $a, 64, $c);
        { const $v: usize = $a + 64; $c }
    };

    (@$v:ident, $a:expr, 66, $c:block) => {
        unroll!(@$v, $a, 33, $c);
        unroll!(@$v, $a + 33, 33, $c);
    };

    (@$v:ident, $a:expr, 67, $c:block) => {
        unroll!(@$v, $a, 66, $c);
        { const $v: usize = $a + 66; $c }
    };

    (@$v:ident, $a:expr, 68, $c:block) => {
        unroll!(@$v, $a, 34, $c);
        unroll!(@$v, $a + 34, 34, $c);
    };

    (@$v:ident, $a:expr, 69, $c:block) => {
        unroll!(@$v, $a, 68, $c);
        { const $v: usize = $a + 68; $c }
    };

    (@$v:ident, $a:expr, 70, $c:block) => {
        unroll!(@$v, $a, 35, $c);
        unroll!(@$v, $a + 35, 35, $c);
    };

    (@$v:ident, $a:expr, 71, $c:block) => {
        unroll!(@$v, $a, 70, $c);
        { const $v: usize = $a + 70; $c }
    };

    (@$v:ident, $a:expr, 72, $c:block) => {
        unroll!(@$v, $a, 36, $c);
        unroll!(@$v, $a + 36, 36, $c);
    };

    (@$v:ident, $a:expr, 73, $c:block) => {
        unroll!(@$v, $a, 72, $c);
        { const $v: usize = $a + 72; $c }
    };

    (@$v:ident, $a:expr, 74, $c:block) => {
        unroll!(@$v, $a, 37, $c);
        unroll!(@$v, $a + 37, 37, $c);
    };

    (@$v:ident, $a:expr, 75, $c:block) => {
        unroll!(@$v, $a, 74, $c);
        { const $v: usize = $a + 74; $c }
    };

    (@$v:ident, $a:expr, 76, $c:block) => {
        unroll!(@$v, $a, 38, $c);
        unroll!(@$v, $a + 38, 38, $c);
    };

    (@$v:ident, $a:expr, 77, $c:block) => {
        unroll!(@$v, $a, 76, $c);
        { const $v: usize = $a + 76; $c }
    };

    (@$v:ident, $a:expr, 78, $c:block) => {
        unroll!(@$v, $a, 39, $c);
        unroll!(@$v, $a + 39, 39, $c);
    };

    (@$v:ident, $a:expr, 79, $c:block) => {
        unroll!(@$v, $a, 78, $c);
        { const $v: usize = $a + 78; $c }
    };

    (@$v:ident, $a:expr, 80, $c:block) => {
        unroll!(@$v, $a, 40, $c);
        unroll!(@$v, $a + 40, 40, $c);
    };

    (@$v:ident, $a:expr, 81, $c:block) => {
        unroll!(@$v, $a, 80, $c);
        { const $v: usize = $a + 80; $c }
    };

    (@$v:ident, $a:expr, 82, $c:block) => {
        unroll!(@$v, $a, 41, $c);
        unroll!(@$v, $a + 41, 41, $c);
    };

    (@$v:ident, $a:expr, 83, $c:block) => {
        unroll!(@$v, $a, 82, $c);
        { const $v: usize = $a + 82; $c }
    };

    (@$v:ident, $a:expr, 84, $c:block) => {
        unroll!(@$v, $a, 42, $c);
        unroll!(@$v, $a + 42, 42, $c);
    };

    (@$v:ident, $a:expr, 85, $c:block) => {
        unroll!(@$v, $a, 84, $c);
        { const $v: usize = $a + 84; $c }
    };

    (@$v:ident, $a:expr, 86, $c:block) => {
        unroll!(@$v, $a, 43, $c);
        unroll!(@$v, $a + 43, 43, $c);
    };

    (@$v:ident, $a:expr, 87, $c:block) => {
        unroll!(@$v, $a, 86, $c);
        { const $v: usize = $a + 86; $c }
    };

    (@$v:ident, $a:expr, 88, $c:block) => {
        unroll!(@$v, $a, 44, $c);
        unroll!(@$v, $a + 44, 44, $c);
    };

    (@$v:ident, $a:expr, 89, $c:block) => {
        unroll!(@$v, $a, 88, $c);
        { const $v: usize = $a + 88; $c }
    };

    (@$v:ident, $a:expr, 90, $c:block) => {
        unroll!(@$v, $a, 45, $c);
        unroll!(@$v, $a + 45, 45, $c);
    };

    (@$v:ident, $a:expr, 91, $c:block) => {
        unroll!(@$v, $a, 90, $c);
        { const $v: usize = $a + 90; $c }
    };

    (@$v:ident, $a:expr, 92, $c:block) => {
        unroll!(@$v, $a, 46, $c);
        unroll!(@$v, $a + 46, 46, $c);
    };

    (@$v:ident, $a:expr, 93, $c:block) => {
        unroll!(@$v, $a, 92, $c);
        { const $v: usize = $a + 92; $c }
    };

    (@$v:ident, $a:expr, 94, $c:block) => {
        unroll!(@$v, $a, 47, $c);
        unroll!(@$v, $a + 47, 47, $c);
    };

    (@$v:ident, $a:expr, 95, $c:block) => {
        unroll!(@$v, $a, 94, $c);
        { const $v: usize = $a + 94; $c }
    };

    (@$v:ident, $a:expr, 96, $c:block) => {
        unroll!(@$v, $a, 48, $c);
        unroll!(@$v, $a + 48, 48, $c);
    };

    (@$v:ident, $a:expr, 97, $c:block) => {
        unroll!(@$v, $a, 96, $c);
        { const $v: usize = $a + 96; $c }
    };

    (@$v:ident, $a:expr, 98, $c:block) => {
        unroll!(@$v, $a, 49, $c);
        unroll!(@$v, $a + 49, 49, $c);
    };

    (@$v:ident, $a:expr, 99, $c:block) => {
        unroll!(@$v, $a, 98, $c);
        { const $v: usize = $a + 98; $c }
    };

    (@$v:ident, $a:expr, 100, $c:block) => {
        unroll!(@$v, $a, 50, $c);
        unroll!(@$v, $a + 50, 50, $c);
    };

    (@$v:ident, $a:expr, 101, $c:block) => {
        unroll!(@$v, $a, 100, $c);
        { const $v: usize = $a + 100; $c }
    };

    (@$v:ident, $a:expr, 102, $c:block) => {
        unroll!(@$v, $a, 51, $c);
        unroll!(@$v, $a + 51, 51, $c);
    };

    (@$v:ident, $a:expr, 103, $c:block) => {
        unroll!(@$v, $a, 102, $c);
        { const $v: usize = $a + 102; $c }
    };

    (@$v:ident, $a:expr, 104, $c:block) => {
        unroll!(@$v, $a, 52, $c);
        unroll!(@$v, $a + 52, 52, $c);
    };

    (@$v:ident, $a:expr, 105, $c:block) => {
        unroll!(@$v, $a, 104, $c);
        { const $v: usize = $a + 104; $c }
    };

    (@$v:ident, $a:expr, 106, $c:block) => {
        unroll!(@$v, $a, 53, $c);
        unroll!(@$v, $a + 53, 53, $c);
    };

    (@$v:ident, $a:expr, 107, $c:block) => {
        unroll!(@$v, $a, 106, $c);
        { const $v: usize = $a + 106; $c }
    };

    (@$v:ident, $a:expr, 108, $c:block) => {
        unroll!(@$v, $a, 54, $c);
        unroll!(@$v, $a + 54, 54, $c);
    };

    (@$v:ident, $a:expr, 109, $c:block) => {
        unroll!(@$v, $a, 108, $c);
        { const $v: usize = $a + 108; $c }
    };

    (@$v:ident, $a:expr, 110, $c:block) => {
        unroll!(@$v, $a, 55, $c);
        unroll!(@$v, $a + 55, 55, $c);
    };

    (@$v:ident, $a:expr, 111, $c:block) => {
        unroll!(@$v, $a, 110, $c);
        { const $v: usize = $a + 110; $c }
    };

    (@$v:ident, $a:expr, 112, $c:block) => {
        unroll!(@$v, $a, 56, $c);
        unroll!(@$v, $a + 56, 56, $c);
    };

    (@$v:ident, $a:expr, 113, $c:block) => {
        unroll!(@$v, $a, 112, $c);
        { const $v: usize = $a + 112; $c }
    };

    (@$v:ident, $a:expr, 114, $c:block) => {
        unroll!(@$v, $a, 57, $c);
        unroll!(@$v, $a + 57, 57, $c);
    };

    (@$v:ident, $a:expr, 115, $c:block) => {
        unroll!(@$v, $a, 114, $c);
        { const $v: usize = $a + 114; $c }
    };

    (@$v:ident, $a:expr, 116, $c:block) => {
        unroll!(@$v, $a, 58, $c);
        unroll!(@$v, $a + 58, 58, $c);
    };

    (@$v:ident, $a:expr, 117, $c:block) => {
        unroll!(@$v, $a, 116, $c);
        { const $v: usize = $a + 116; $c }
    };

    (@$v:ident, $a:expr, 118, $c:block) => {
        unroll!(@$v, $a, 59, $c);
        unroll!(@$v, $a + 59, 59, $c);
    };

    (@$v:ident, $a:expr, 119, $c:block) => {
        unroll!(@$v, $a, 118, $c);
        { const $v: usize = $a + 118; $c }
    };

    (@$v:ident, $a:expr, 120, $c:block) => {
        unroll!(@$v, $a, 60, $c);
        unroll!(@$v, $a + 60, 60, $c);
    };

    (@$v:ident, $a:expr, 121, $c:block) => {
        unroll!(@$v, $a, 120, $c);
        { const $v: usize = $a + 120; $c }
    };

    (@$v:ident, $a:expr, 122, $c:block) => {
        unroll!(@$v, $a, 61, $c);
        unroll!(@$v, $a + 61, 61, $c);
    };

    (@$v:ident, $a:expr, 123, $c:block) => {
        unroll!(@$v, $a, 122, $c);
        { const $v: usize = $a + 122; $c }
    };

    (@$v:ident, $a:expr, 124, $c:block) => {
        unroll!(@$v, $a, 62, $c);
        unroll!(@$v, $a + 62, 62, $c);
    };

    (@$v:ident, $a:expr, 125, $c:block) => {
        unroll!(@$v, $a, 124, $c);
        { const $v: usize = $a + 124; $c }
    };

    (@$v:ident, $a:expr, 126, $c:block) => {
        unroll!(@$v, $a, 63, $c);
        unroll!(@$v, $a + 63, 63, $c);
    };

    (@$v:ident, $a:expr, 127, $c:block) => {
        unroll!(@$v, $a, 126, $c);
        { const $v: usize = $a + 126; $c }
    };

    (@$v:ident, $a:expr, 128, $c:block) => {
        unroll!(@$v, $a, 64, $c);
        unroll!(@$v, $a + 64, 64, $c);
    };

}

#[cfg(all(test, feature = "std"))]
mod tests {
    #[test]
    fn invalid_range() {
        let mut a: Vec<usize> = vec![];
        unroll! {
                for i in (5..4) {
                    a.push(i);
                }
            }
        assert_eq!(a, vec![]);
    }

    #[test]
    fn start_at_one_with_step() {
        let mut a: Vec<usize> = vec![];
        unroll! {
                for i in (2..4).step_by(1) {
                    a.push(i);
                }
            }
        assert_eq!(a, vec![2, 3]);
    }

    #[test]
    fn start_at_one() {
        let mut a: Vec<usize> = vec![];
        unroll! {
                for i in 1..4 {
                    a.push(i);
                }
            }
        assert_eq!(a, vec![1, 2, 3]);
    }

    #[test]
    fn test_all() {
        {
            let a: Vec<usize> = vec![];
            unroll! {
                for i in 0..0 {
                    a.push(i);
                }
            }
            assert_eq!(a, (0..0).collect::<Vec<usize>>());
        }
        {
            let mut a: Vec<usize> = vec![];
            unroll! {
                for i in 0..1 {
                    a.push(i);
                }
            }
            assert_eq!(a, (0..1).collect::<Vec<usize>>());
        }
        {
            let mut a: Vec<usize> = vec![];
            unroll! {
                for i in 0..128 {
                    a.push(i);
                }
            }
            assert_eq!(a, (0..128).collect::<Vec<usize>>());
        }
        {
            let mut a: Vec<usize> = vec![];
            let start = 128 / 4;
            let end = start * 3;
            unroll! {
                for i < 128 in start..end {
                    a.push(i);
                }
            }
            assert_eq!(a, (start..end).collect::<Vec<usize>>());
        }
        {
            let mut a: Vec<usize> = vec![];
            unroll! {
                for i in (0..128).step_by(2) {
                    a.push(i);
                }
            }
            assert_eq!(a, (0..128 / 2).map(|x| x * 2).collect::<Vec<usize>>());
        }
        {
            let mut a: Vec<usize> = vec![];
            let start = 128 / 4;
            let end = start * 3;
            unroll! {
                for i < 128 in (start..end).step_by(2) {
                    a.push(i);
                }
            }
            assert_eq!(a, (start..end).filter(|x| x % 2 == 0).collect::<Vec<usize>>());
        }
    }
}

'''
'''--- contract/target/debug/build/num-bigint-e456b3fc23ac8e2a/out/radix_bases.rs ---
#[deny(overflowing_literals)]
pub(crate) static BASES_16: [(u16, usize); 257] = [
    (0, 0), // 0
    (0, 0), // 1
    (0, 0), // 2
    (59049, 10), // 3
    (0, 0), // 4
    (15625, 6), // 5
    (46656, 6), // 6
    (16807, 5), // 7
    (0, 0), // 8
    (59049, 5), // 9
    (10000, 4), // 10
    (14641, 4), // 11
    (20736, 4), // 12
    (28561, 4), // 13
    (38416, 4), // 14
    (50625, 4), // 15
    (0, 0), // 16
    (4913, 3), // 17
    (5832, 3), // 18
    (6859, 3), // 19
    (8000, 3), // 20
    (9261, 3), // 21
    (10648, 3), // 22
    (12167, 3), // 23
    (13824, 3), // 24
    (15625, 3), // 25
    (17576, 3), // 26
    (19683, 3), // 27
    (21952, 3), // 28
    (24389, 3), // 29
    (27000, 3), // 30
    (29791, 3), // 31
    (0, 0), // 32
    (35937, 3), // 33
    (39304, 3), // 34
    (42875, 3), // 35
    (46656, 3), // 36
    (50653, 3), // 37
    (54872, 3), // 38
    (59319, 3), // 39
    (64000, 3), // 40
    (1681, 2), // 41
    (1764, 2), // 42
    (1849, 2), // 43
    (1936, 2), // 44
    (2025, 2), // 45
    (2116, 2), // 46
    (2209, 2), // 47
    (2304, 2), // 48
    (2401, 2), // 49
    (2500, 2), // 50
    (2601, 2), // 51
    (2704, 2), // 52
    (2809, 2), // 53
    (2916, 2), // 54
    (3025, 2), // 55
    (3136, 2), // 56
    (3249, 2), // 57
    (3364, 2), // 58
    (3481, 2), // 59
    (3600, 2), // 60
    (3721, 2), // 61
    (3844, 2), // 62
    (3969, 2), // 63
    (0, 0), // 64
    (4225, 2), // 65
    (4356, 2), // 66
    (4489, 2), // 67
    (4624, 2), // 68
    (4761, 2), // 69
    (4900, 2), // 70
    (5041, 2), // 71
    (5184, 2), // 72
    (5329, 2), // 73
    (5476, 2), // 74
    (5625, 2), // 75
    (5776, 2), // 76
    (5929, 2), // 77
    (6084, 2), // 78
    (6241, 2), // 79
    (6400, 2), // 80
    (6561, 2), // 81
    (6724, 2), // 82
    (6889, 2), // 83
    (7056, 2), // 84
    (7225, 2), // 85
    (7396, 2), // 86
    (7569, 2), // 87
    (7744, 2), // 88
    (7921, 2), // 89
    (8100, 2), // 90
    (8281, 2), // 91
    (8464, 2), // 92
    (8649, 2), // 93
    (8836, 2), // 94
    (9025, 2), // 95
    (9216, 2), // 96
    (9409, 2), // 97
    (9604, 2), // 98
    (9801, 2), // 99
    (10000, 2), // 100
    (10201, 2), // 101
    (10404, 2), // 102
    (10609, 2), // 103
    (10816, 2), // 104
    (11025, 2), // 105
    (11236, 2), // 106
    (11449, 2), // 107
    (11664, 2), // 108
    (11881, 2), // 109
    (12100, 2), // 110
    (12321, 2), // 111
    (12544, 2), // 112
    (12769, 2), // 113
    (12996, 2), // 114
    (13225, 2), // 115
    (13456, 2), // 116
    (13689, 2), // 117
    (13924, 2), // 118
    (14161, 2), // 119
    (14400, 2), // 120
    (14641, 2), // 121
    (14884, 2), // 122
    (15129, 2), // 123
    (15376, 2), // 124
    (15625, 2), // 125
    (15876, 2), // 126
    (16129, 2), // 127
    (0, 0), // 128
    (16641, 2), // 129
    (16900, 2), // 130
    (17161, 2), // 131
    (17424, 2), // 132
    (17689, 2), // 133
    (17956, 2), // 134
    (18225, 2), // 135
    (18496, 2), // 136
    (18769, 2), // 137
    (19044, 2), // 138
    (19321, 2), // 139
    (19600, 2), // 140
    (19881, 2), // 141
    (20164, 2), // 142
    (20449, 2), // 143
    (20736, 2), // 144
    (21025, 2), // 145
    (21316, 2), // 146
    (21609, 2), // 147
    (21904, 2), // 148
    (22201, 2), // 149
    (22500, 2), // 150
    (22801, 2), // 151
    (23104, 2), // 152
    (23409, 2), // 153
    (23716, 2), // 154
    (24025, 2), // 155
    (24336, 2), // 156
    (24649, 2), // 157
    (24964, 2), // 158
    (25281, 2), // 159
    (25600, 2), // 160
    (25921, 2), // 161
    (26244, 2), // 162
    (26569, 2), // 163
    (26896, 2), // 164
    (27225, 2), // 165
    (27556, 2), // 166
    (27889, 2), // 167
    (28224, 2), // 168
    (28561, 2), // 169
    (28900, 2), // 170
    (29241, 2), // 171
    (29584, 2), // 172
    (29929, 2), // 173
    (30276, 2), // 174
    (30625, 2), // 175
    (30976, 2), // 176
    (31329, 2), // 177
    (31684, 2), // 178
    (32041, 2), // 179
    (32400, 2), // 180
    (32761, 2), // 181
    (33124, 2), // 182
    (33489, 2), // 183
    (33856, 2), // 184
    (34225, 2), // 185
    (34596, 2), // 186
    (34969, 2), // 187
    (35344, 2), // 188
    (35721, 2), // 189
    (36100, 2), // 190
    (36481, 2), // 191
    (36864, 2), // 192
    (37249, 2), // 193
    (37636, 2), // 194
    (38025, 2), // 195
    (38416, 2), // 196
    (38809, 2), // 197
    (39204, 2), // 198
    (39601, 2), // 199
    (40000, 2), // 200
    (40401, 2), // 201
    (40804, 2), // 202
    (41209, 2), // 203
    (41616, 2), // 204
    (42025, 2), // 205
    (42436, 2), // 206
    (42849, 2), // 207
    (43264, 2), // 208
    (43681, 2), // 209
    (44100, 2), // 210
    (44521, 2), // 211
    (44944, 2), // 212
    (45369, 2), // 213
    (45796, 2), // 214
    (46225, 2), // 215
    (46656, 2), // 216
    (47089, 2), // 217
    (47524, 2), // 218
    (47961, 2), // 219
    (48400, 2), // 220
    (48841, 2), // 221
    (49284, 2), // 222
    (49729, 2), // 223
    (50176, 2), // 224
    (50625, 2), // 225
    (51076, 2), // 226
    (51529, 2), // 227
    (51984, 2), // 228
    (52441, 2), // 229
    (52900, 2), // 230
    (53361, 2), // 231
    (53824, 2), // 232
    (54289, 2), // 233
    (54756, 2), // 234
    (55225, 2), // 235
    (55696, 2), // 236
    (56169, 2), // 237
    (56644, 2), // 238
    (57121, 2), // 239
    (57600, 2), // 240
    (58081, 2), // 241
    (58564, 2), // 242
    (59049, 2), // 243
    (59536, 2), // 244
    (60025, 2), // 245
    (60516, 2), // 246
    (61009, 2), // 247
    (61504, 2), // 248
    (62001, 2), // 249
    (62500, 2), // 250
    (63001, 2), // 251
    (63504, 2), // 252
    (64009, 2), // 253
    (64516, 2), // 254
    (65025, 2), // 255
    (0, 0), // 256
];
#[deny(overflowing_literals)]
pub(crate) static BASES_32: [(u32, usize); 257] = [
    (0, 0), // 0
    (0, 0), // 1
    (0, 0), // 2
    (3486784401, 20), // 3
    (0, 0), // 4
    (1220703125, 13), // 5
    (2176782336, 12), // 6
    (1977326743, 11), // 7
    (0, 0), // 8
    (3486784401, 10), // 9
    (1000000000, 9), // 10
    (2357947691, 9), // 11
    (429981696, 8), // 12
    (815730721, 8), // 13
    (1475789056, 8), // 14
    (2562890625, 8), // 15
    (0, 0), // 16
    (410338673, 7), // 17
    (612220032, 7), // 18
    (893871739, 7), // 19
    (1280000000, 7), // 20
    (1801088541, 7), // 21
    (2494357888, 7), // 22
    (3404825447, 7), // 23
    (191102976, 6), // 24
    (244140625, 6), // 25
    (308915776, 6), // 26
    (387420489, 6), // 27
    (481890304, 6), // 28
    (594823321, 6), // 29
    (729000000, 6), // 30
    (887503681, 6), // 31
    (0, 0), // 32
    (1291467969, 6), // 33
    (1544804416, 6), // 34
    (1838265625, 6), // 35
    (2176782336, 6), // 36
    (2565726409, 6), // 37
    (3010936384, 6), // 38
    (3518743761, 6), // 39
    (4096000000, 6), // 40
    (115856201, 5), // 41
    (130691232, 5), // 42
    (147008443, 5), // 43
    (164916224, 5), // 44
    (184528125, 5), // 45
    (205962976, 5), // 46
    (229345007, 5), // 47
    (254803968, 5), // 48
    (282475249, 5), // 49
    (312500000, 5), // 50
    (345025251, 5), // 51
    (380204032, 5), // 52
    (418195493, 5), // 53
    (459165024, 5), // 54
    (503284375, 5), // 55
    (550731776, 5), // 56
    (601692057, 5), // 57
    (656356768, 5), // 58
    (714924299, 5), // 59
    (777600000, 5), // 60
    (844596301, 5), // 61
    (916132832, 5), // 62
    (992436543, 5), // 63
    (0, 0), // 64
    (1160290625, 5), // 65
    (1252332576, 5), // 66
    (1350125107, 5), // 67
    (1453933568, 5), // 68
    (1564031349, 5), // 69
    (1680700000, 5), // 70
    (1804229351, 5), // 71
    (1934917632, 5), // 72
    (2073071593, 5), // 73
    (2219006624, 5), // 74
    (2373046875, 5), // 75
    (2535525376, 5), // 76
    (2706784157, 5), // 77
    (2887174368, 5), // 78
    (3077056399, 5), // 79
    (3276800000, 5), // 80
    (3486784401, 5), // 81
    (3707398432, 5), // 82
    (3939040643, 5), // 83
    (4182119424, 5), // 84
    (52200625, 4), // 85
    (54700816, 4), // 86
    (57289761, 4), // 87
    (59969536, 4), // 88
    (62742241, 4), // 89
    (65610000, 4), // 90
    (68574961, 4), // 91
    (71639296, 4), // 92
    (74805201, 4), // 93
    (78074896, 4), // 94
    (81450625, 4), // 95
    (84934656, 4), // 96
    (88529281, 4), // 97
    (92236816, 4), // 98
    (96059601, 4), // 99
    (100000000, 4), // 100
    (104060401, 4), // 101
    (108243216, 4), // 102
    (112550881, 4), // 103
    (116985856, 4), // 104
    (121550625, 4), // 105
    (126247696, 4), // 106
    (131079601, 4), // 107
    (136048896, 4), // 108
    (141158161, 4), // 109
    (146410000, 4), // 110
    (151807041, 4), // 111
    (157351936, 4), // 112
    (163047361, 4), // 113
    (168896016, 4), // 114
    (174900625, 4), // 115
    (181063936, 4), // 116
    (187388721, 4), // 117
    (193877776, 4), // 118
    (200533921, 4), // 119
    (207360000, 4), // 120
    (214358881, 4), // 121
    (221533456, 4), // 122
    (228886641, 4), // 123
    (236421376, 4), // 124
    (244140625, 4), // 125
    (252047376, 4), // 126
    (260144641, 4), // 127
    (0, 0), // 128
    (276922881, 4), // 129
    (285610000, 4), // 130
    (294499921, 4), // 131
    (303595776, 4), // 132
    (312900721, 4), // 133
    (322417936, 4), // 134
    (332150625, 4), // 135
    (342102016, 4), // 136
    (352275361, 4), // 137
    (362673936, 4), // 138
    (373301041, 4), // 139
    (384160000, 4), // 140
    (395254161, 4), // 141
    (406586896, 4), // 142
    (418161601, 4), // 143
    (429981696, 4), // 144
    (442050625, 4), // 145
    (454371856, 4), // 146
    (466948881, 4), // 147
    (479785216, 4), // 148
    (492884401, 4), // 149
    (506250000, 4), // 150
    (519885601, 4), // 151
    (533794816, 4), // 152
    (547981281, 4), // 153
    (562448656, 4), // 154
    (577200625, 4), // 155
    (592240896, 4), // 156
    (607573201, 4), // 157
    (623201296, 4), // 158
    (639128961, 4), // 159
    (655360000, 4), // 160
    (671898241, 4), // 161
    (688747536, 4), // 162
    (705911761, 4), // 163
    (723394816, 4), // 164
    (741200625, 4), // 165
    (759333136, 4), // 166
    (777796321, 4), // 167
    (796594176, 4), // 168
    (815730721, 4), // 169
    (835210000, 4), // 170
    (855036081, 4), // 171
    (875213056, 4), // 172
    (895745041, 4), // 173
    (916636176, 4), // 174
    (937890625, 4), // 175
    (959512576, 4), // 176
    (981506241, 4), // 177
    (1003875856, 4), // 178
    (1026625681, 4), // 179
    (1049760000, 4), // 180
    (1073283121, 4), // 181
    (1097199376, 4), // 182
    (1121513121, 4), // 183
    (1146228736, 4), // 184
    (1171350625, 4), // 185
    (1196883216, 4), // 186
    (1222830961, 4), // 187
    (1249198336, 4), // 188
    (1275989841, 4), // 189
    (1303210000, 4), // 190
    (1330863361, 4), // 191
    (1358954496, 4), // 192
    (1387488001, 4), // 193
    (1416468496, 4), // 194
    (1445900625, 4), // 195
    (1475789056, 4), // 196
    (1506138481, 4), // 197
    (1536953616, 4), // 198
    (1568239201, 4), // 199
    (1600000000, 4), // 200
    (1632240801, 4), // 201
    (1664966416, 4), // 202
    (1698181681, 4), // 203
    (1731891456, 4), // 204
    (1766100625, 4), // 205
    (1800814096, 4), // 206
    (1836036801, 4), // 207
    (1871773696, 4), // 208
    (1908029761, 4), // 209
    (1944810000, 4), // 210
    (1982119441, 4), // 211
    (2019963136, 4), // 212
    (2058346161, 4), // 213
    (2097273616, 4), // 214
    (2136750625, 4), // 215
    (2176782336, 4), // 216
    (2217373921, 4), // 217
    (2258530576, 4), // 218
    (2300257521, 4), // 219
    (2342560000, 4), // 220
    (2385443281, 4), // 221
    (2428912656, 4), // 222
    (2472973441, 4), // 223
    (2517630976, 4), // 224
    (2562890625, 4), // 225
    (2608757776, 4), // 226
    (2655237841, 4), // 227
    (2702336256, 4), // 228
    (2750058481, 4), // 229
    (2798410000, 4), // 230
    (2847396321, 4), // 231
    (2897022976, 4), // 232
    (2947295521, 4), // 233
    (2998219536, 4), // 234
    (3049800625, 4), // 235
    (3102044416, 4), // 236
    (3154956561, 4), // 237
    (3208542736, 4), // 238
    (3262808641, 4), // 239
    (3317760000, 4), // 240
    (3373402561, 4), // 241
    (3429742096, 4), // 242
    (3486784401, 4), // 243
    (3544535296, 4), // 244
    (3603000625, 4), // 245
    (3662186256, 4), // 246
    (3722098081, 4), // 247
    (3782742016, 4), // 248
    (3844124001, 4), // 249
    (3906250000, 4), // 250
    (3969126001, 4), // 251
    (4032758016, 4), // 252
    (4097152081, 4), // 253
    (4162314256, 4), // 254
    (4228250625, 4), // 255
    (0, 0), // 256
];
#[deny(overflowing_literals)]
pub(crate) static BASES_64: [(u64, usize); 257] = [
    (0, 0), // 0
    (0, 0), // 1
    (0, 0), // 2
    (12157665459056928801, 40), // 3
    (0, 0), // 4
    (7450580596923828125, 27), // 5
    (4738381338321616896, 24), // 6
    (3909821048582988049, 22), // 7
    (0, 0), // 8
    (12157665459056928801, 20), // 9
    (10000000000000000000, 19), // 10
    (5559917313492231481, 18), // 11
    (2218611106740436992, 17), // 12
    (8650415919381337933, 17), // 13
    (2177953337809371136, 16), // 14
    (6568408355712890625, 16), // 15
    (0, 0), // 16
    (2862423051509815793, 15), // 17
    (6746640616477458432, 15), // 18
    (15181127029874798299, 15), // 19
    (1638400000000000000, 14), // 20
    (3243919932521508681, 14), // 21
    (6221821273427820544, 14), // 22
    (11592836324538749809, 14), // 23
    (876488338465357824, 13), // 24
    (1490116119384765625, 13), // 25
    (2481152873203736576, 13), // 26
    (4052555153018976267, 13), // 27
    (6502111422497947648, 13), // 28
    (10260628712958602189, 13), // 29
    (15943230000000000000, 13), // 30
    (787662783788549761, 12), // 31
    (0, 0), // 32
    (1667889514952984961, 12), // 33
    (2386420683693101056, 12), // 34
    (3379220508056640625, 12), // 35
    (4738381338321616896, 12), // 36
    (6582952005840035281, 12), // 37
    (9065737908494995456, 12), // 38
    (12381557655576425121, 12), // 39
    (16777216000000000000, 12), // 40
    (550329031716248441, 11), // 41
    (717368321110468608, 11), // 42
    (929293739471222707, 11), // 43
    (1196683881290399744, 11), // 44
    (1532278301220703125, 11), // 45
    (1951354384207722496, 11), // 46
    (2472159215084012303, 11), // 47
    (3116402981210161152, 11), // 48
    (3909821048582988049, 11), // 49
    (4882812500000000000, 11), // 50
    (6071163615208263051, 11), // 51
    (7516865509350965248, 11), // 52
    (9269035929372191597, 11), // 53
    (11384956040305711104, 11), // 54
    (13931233916552734375, 11), // 55
    (16985107389382393856, 11), // 56
    (362033331456891249, 10), // 57
    (430804206899405824, 10), // 58
    (511116753300641401, 10), // 59
    (604661760000000000, 10), // 60
    (713342911662882601, 10), // 61
    (839299365868340224, 10), // 62
    (984930291881790849, 10), // 63
    (0, 0), // 64
    (1346274334462890625, 10), // 65
    (1568336880910795776, 10), // 66
    (1822837804551761449, 10), // 67
    (2113922820157210624, 10), // 68
    (2446194060654759801, 10), // 69
    (2824752490000000000, 10), // 70
    (3255243551009881201, 10), // 71
    (3743906242624487424, 10), // 72
    (4297625829703557649, 10), // 73
    (4923990397355877376, 10), // 74
    (5631351470947265625, 10), // 75
    (6428888932339941376, 10), // 76
    (7326680472586200649, 10), // 77
    (8335775831236199424, 10), // 78
    (9468276082626847201, 10), // 79
    (10737418240000000000, 10), // 80
    (12157665459056928801, 10), // 81
    (13744803133596058624, 10), // 82
    (15516041187205853449, 10), // 83
    (17490122876598091776, 10), // 84
    (231616946283203125, 9), // 85
    (257327417311663616, 9), // 86
    (285544154243029527, 9), // 87
    (316478381828866048, 9), // 88
    (350356403707485209, 9), // 89
    (387420489000000000, 9), // 90
    (427929800129788411, 9), // 91
    (472161363286556672, 9), // 92
    (520411082988487293, 9), // 93
    (572994802228616704, 9), // 94
    (630249409724609375, 9), // 95
    (692533995824480256, 9), // 96
    (760231058654565217, 9), // 97
    (833747762130149888, 9), // 98
    (913517247483640899, 9), // 99
    (1000000000000000000, 9), // 100
    (1093685272684360901, 9), // 101
    (1195092568622310912, 9), // 102
    (1304773183829244583, 9), // 103
    (1423311812421484544, 9), // 104
    (1551328215978515625, 9), // 105
    (1689478959002692096, 9), // 106
    (1838459212420154507, 9), // 107
    (1999004627104432128, 9), // 108
    (2171893279442309389, 9), // 109
    (2357947691000000000, 9), // 110
    (2558036924386500591, 9), // 111
    (2773078757450186752, 9), // 112
    (3004041937984268273, 9), // 113
    (3251948521156637184, 9), // 114
    (3517876291919921875, 9), // 115
    (3802961274698203136, 9), // 116
    (4108400332687853397, 9), // 117
    (4435453859151328768, 9), // 118
    (4785448563124474679, 9), // 119
    (5159780352000000000, 9), // 120
    (5559917313492231481, 9), // 121
    (5987402799531080192, 9), // 122
    (6443858614676334363, 9), // 123
    (6930988311686938624, 9), // 124
    (7450580596923828125, 9), // 125
    (8004512848309157376, 9), // 126
    (8594754748609397887, 9), // 127
    (0, 0), // 128
    (9892530380752880769, 9), // 129
    (10604499373000000000, 9), // 130
    (11361656654439817571, 9), // 131
    (12166492167065567232, 9), // 132
    (13021612539908538853, 9), // 133
    (13929745610903012864, 9), // 134
    (14893745087865234375, 9), // 135
    (15916595351771938816, 9), // 136
    (17001416405572203977, 9), // 137
    (18151468971815029248, 9), // 138
    (139353667211683681, 8), // 139
    (147578905600000000, 8), // 140
    (156225851787813921, 8), // 141
    (165312903998914816, 8), // 142
    (174859124550883201, 8), // 143
    (184884258895036416, 8), // 144
    (195408755062890625, 8), // 145
    (206453783524884736, 8), // 146
    (218041257467152161, 8), // 147
    (230193853492166656, 8), // 148
    (242935032749128801, 8), // 149
    (256289062500000000, 8), // 150
    (270281038127131201, 8), // 151
    (284936905588473856, 8), // 152
    (300283484326400961, 8), // 153
    (316348490636206336, 8), // 154
    (333160561500390625, 8), // 155
    (350749278894882816, 8), // 156
    (369145194573386401, 8), // 157
    (388379855336079616, 8), // 158
    (408485828788939521, 8), // 159
    (429496729600000000, 8), // 160
    (451447246258894081, 8), // 161
    (474373168346071296, 8), // 162
    (498311414318121121, 8), // 163
    (523300059815673856, 8), // 164
    (549378366500390625, 8), // 165
    (576586811427594496, 8), // 166
    (604967116961135041, 8), // 167
    (634562281237118976, 8), // 168
    (665416609183179841, 8), // 169
    (697575744100000000, 8), // 170
    (731086699811838561, 8), // 171
    (765997893392859136, 8), // 172
    (802359178476091681, 8), // 173
    (840221879151902976, 8), // 174
    (879638824462890625, 8), // 175
    (920664383502155776, 8), // 176
    (963354501121950081, 8), // 177
    (1007766734259732736, 8), // 178
    (1053960288888713761, 8), // 179
    (1101996057600000000, 8), // 180
    (1151936657823500641, 8), // 181
    (1203846470694789376, 8), // 182
    (1257791680575160641, 8), // 183
    (1313840315232157696, 8), // 184
    (1372062286687890625, 8), // 185
    (1432529432742502656, 8), // 186
    (1495315559180183521, 8), // 187
    (1560496482665168896, 8), // 188
    (1628150074335205281, 8), // 189
    (1698356304100000000, 8), // 190
    (1771197285652216321, 8), // 191
    (1846757322198614016, 8), // 192
    (1925122952918976001, 8), // 193
    (2006383000160502016, 8), // 194
    (2090628617375390625, 8), // 195
    (2177953337809371136, 8), // 196
    (2268453123948987361, 8), // 197
    (2362226417735475456, 8), // 198
    (2459374191553118401, 8), // 199
    (2560000000000000000, 8), // 200
    (2664210032449121601, 8), // 201
    (2772113166407885056, 8), // 202
    (2883821021683985761, 8), // 203
    (2999448015365799936, 8), // 204
    (3119111417625390625, 8), // 205
    (3242931408352297216, 8), // 206
    (3371031134626313601, 8), // 207
    (3503536769037500416, 8), // 208
    (3640577568861717121, 8), // 209
    (3782285936100000000, 8), // 210
    (3928797478390152481, 8), // 211
    (4080251070798954496, 8), // 212
    (4236788918503437921, 8), // 213
    (4398556620369715456, 8), // 214
    (4565703233437890625, 8), // 215
    (4738381338321616896, 8), // 216
    (4916747105530914241, 8), // 217
    (5100960362726891776, 8), // 218
    (5291184662917065441, 8), // 219
    (5487587353600000000, 8), // 220
    (5690339646868044961, 8), // 221
    (5899616690476974336, 8), // 222
    (6115597639891380481, 8), // 223
    (6338465731314712576, 8), // 224
    (6568408355712890625, 8), // 225
    (6805617133840466176, 8), // 226
    (7050287992278341281, 8), // 227
    (7302621240492097536, 8), // 228
    (7562821648920027361, 8), // 229
    (7831098528100000000, 8), // 230
    (8107665808844335041, 8), // 231
    (8392742123471896576, 8), // 232
    (8686550888106661441, 8), // 233
    (8989320386052055296, 8), // 234
    (9301283852250390625, 8), // 235
    (9622679558836781056, 8), // 236
    (9953750901796946721, 8), // 237
    (10294746488738365696, 8), // 238
    (10645920227784266881, 8), // 239
    (11007531417600000000, 8), // 240
    (11379844838561358721, 8), // 241
    (11763130845074473216, 8), // 242
    (12157665459056928801, 8), // 243
    (12563730464589807616, 8), // 244
    (12981613503750390625, 8), // 245
    (13411608173635297536, 8), // 246
    (13854014124583882561, 8), // 247
    (14309137159611744256, 8), // 248
    (14777289335064248001, 8), // 249
    (15258789062500000000, 8), // 250
    (15753961211814252001, 8), // 251
    (16263137215612256256, 8), // 252
    (16786655174842630561, 8), // 253
    (17324859965700833536, 8), // 254
    (17878103347812890625, 8), // 255
    (0, 0), // 256
];

'''
'''--- contract/target/debug/build/parity-secp256k1-4b1a395a29783579/out/flag_check.c ---
int main(void) { return 0; }
'''
'''--- contract/target/debug/build/reed-solomon-erasure-1d5748c3d5bb1e80/out/table.rs ---
pub static LOG_TABLE: [u8; 256] = [0, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4, 100, 224, 14, 52, 141, 239, 129, 28, 193, 105, 248, 200, 8, 76, 113, 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218, 240, 18, 130, 69, 29, 181, 194, 125, 106, 39, 249, 185, 201, 154, 9, 120, 77, 228, 114, 166, 6, 191, 139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16, 145, 34, 136, 54, 208, 148, 206, 143, 150, 219, 189, 241, 210, 19, 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72, 126, 110, 107, 58, 40, 84, 250, 133, 186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78, 212, 229, 172, 115, 243, 167, 87, 7, 112, 192, 247, 140, 128, 99, 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38, 184, 180, 124, 17, 68, 146, 217, 35, 32, 137, 46, 55, 63, 209, 91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190, 97, 242, 86, 211, 171, 20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31, 45, 67, 216, 183, 123, 164, 118, 196, 23, 73, 236, 127, 12, 111, 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177, 187, 204, 62, 90, 203, 89, 95, 176, 156, 169, 160, 81, 11, 245, 22, 235, 122, 117, 44, 215, 79, 174, 213, 233, 230, 231, 173, 232, 116, 214, 244, 234, 168, 80, 88, 175, ];
pub static EXP_TABLE: [u8; 510] = [1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201, 143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193, 159, 35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137, 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68, 136, 13, 26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248, 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, 46, 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77, 154, 41, 82, 164, 85, 170, 73, 146, 57, 114, 228, 213, 183, 115, 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246, 241, 255, 227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220, 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7, 14, 28, 56, 112, 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195, 155, 43, 86, 172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245, 247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233, 207, 131, 27, 54, 108, 216, 173, 71, 142, 1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201, 143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193, 159, 35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137, 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68, 136, 13, 26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248, 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, 46, 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77, 154, 41, 82, 164, 85, 170, 73, 146, 57, 114, 228, 213, 183, 115, 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246, 241, 255, 227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220, 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7, 14, 28, 56, 112, 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195, 155, 43, 86, 172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245, 247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233, 207, 131, 27, 54, 108, 216, 173, 71, 142, ];
pub static MUL_TABLE: [[u8; 256]; 256] = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, ],
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 29, 31, 25, 27, 21, 23, 17, 19, 13, 15, 9, 11, 5, 7, 1, 3, 61, 63, 57, 59, 53, 55, 49, 51, 45, 47, 41, 43, 37, 39, 33, 35, 93, 95, 89, 91, 85, 87, 81, 83, 77, 79, 73, 75, 69, 71, 65, 67, 125, 127, 121, 123, 117, 119, 113, 115, 109, 111, 105, 107, 101, 103, 97, 99, 157, 159, 153, 155, 149, 151, 145, 147, 141, 143, 137, 139, 133, 135, 129, 131, 189, 191, 185, 187, 181, 183, 177, 179, 173, 175, 169, 171, 165, 167, 161, 163, 221, 223, 217, 219, 213, 215, 209, 211, 205, 207, 201, 203, 197, 199, 193, 195, 253, 255, 249, 251, 245, 247, 241, 243, 237, 239, 233, 235, 229, 231, 225, 227, ],
[0, 3, 6, 5, 12, 15, 10, 9, 24, 27, 30, 29, 20, 23, 18, 17, 48, 51, 54, 53, 60, 63, 58, 57, 40, 43, 46, 45, 36, 39, 34, 33, 96, 99, 102, 101, 108, 111, 106, 105, 120, 123, 126, 125, 116, 119, 114, 113, 80, 83, 86, 85, 92, 95, 90, 89, 72, 75, 78, 77, 68, 71, 66, 65, 192, 195, 198, 197, 204, 207, 202, 201, 216, 219, 222, 221, 212, 215, 210, 209, 240, 243, 246, 245, 252, 255, 250, 249, 232, 235, 238, 237, 228, 231, 226, 225, 160, 163, 166, 165, 172, 175, 170, 169, 184, 187, 190, 189, 180, 183, 178, 177, 144, 147, 150, 149, 156, 159, 154, 153, 136, 139, 142, 141, 132, 135, 130, 129, 157, 158, 155, 152, 145, 146, 151, 148, 133, 134, 131, 128, 137, 138, 143, 140, 173, 174, 171, 168, 161, 162, 167, 164, 181, 182, 179, 176, 185, 186, 191, 188, 253, 254, 251, 248, 241, 242, 247, 244, 229, 230, 227, 224, 233, 234, 239, 236, 205, 206, 203, 200, 193, 194, 199, 196, 213, 214, 211, 208, 217, 218, 223, 220, 93, 94, 91, 88, 81, 82, 87, 84, 69, 70, 67, 64, 73, 74, 79, 76, 109, 110, 107, 104, 97, 98, 103, 100, 117, 118, 115, 112, 121, 122, 127, 124, 61, 62, 59, 56, 49, 50, 55, 52, 37, 38, 35, 32, 41, 42, 47, 44, 13, 14, 11, 8, 1, 2, 7, 4, 21, 22, 19, 16, 25, 26, 31, 28, ],
[0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 29, 25, 21, 17, 13, 9, 5, 1, 61, 57, 53, 49, 45, 41, 37, 33, 93, 89, 85, 81, 77, 73, 69, 65, 125, 121, 117, 113, 109, 105, 101, 97, 157, 153, 149, 145, 141, 137, 133, 129, 189, 185, 181, 177, 173, 169, 165, 161, 221, 217, 213, 209, 205, 201, 197, 193, 253, 249, 245, 241, 237, 233, 229, 225, 58, 62, 50, 54, 42, 46, 34, 38, 26, 30, 18, 22, 10, 14, 2, 6, 122, 126, 114, 118, 106, 110, 98, 102, 90, 94, 82, 86, 74, 78, 66, 70, 186, 190, 178, 182, 170, 174, 162, 166, 154, 158, 146, 150, 138, 142, 130, 134, 250, 254, 242, 246, 234, 238, 226, 230, 218, 222, 210, 214, 202, 206, 194, 198, 39, 35, 47, 43, 55, 51, 63, 59, 7, 3, 15, 11, 23, 19, 31, 27, 103, 99, 111, 107, 119, 115, 127, 123, 71, 67, 79, 75, 87, 83, 95, 91, 167, 163, 175, 171, 183, 179, 191, 187, 135, 131, 143, 139, 151, 147, 159, 155, 231, 227, 239, 235, 247, 243, 255, 251, 199, 195, 207, 203, 215, 211, 223, 219, ],
[0, 5, 10, 15, 20, 17, 30, 27, 40, 45, 34, 39, 60, 57, 54, 51, 80, 85, 90, 95, 68, 65, 78, 75, 120, 125, 114, 119, 108, 105, 102, 99, 160, 165, 170, 175, 180, 177, 190, 187, 136, 141, 130, 135, 156, 153, 150, 147, 240, 245, 250, 255, 228, 225, 238, 235, 216, 221, 210, 215, 204, 201, 198, 195, 93, 88, 87, 82, 73, 76, 67, 70, 117, 112, 127, 122, 97, 100, 107, 110, 13, 8, 7, 2, 25, 28, 19, 22, 37, 32, 47, 42, 49, 52, 59, 62, 253, 248, 247, 242, 233, 236, 227, 230, 213, 208, 223, 218, 193, 196, 203, 206, 173, 168, 167, 162, 185, 188, 179, 182, 133, 128, 143, 138, 145, 148, 155, 158, 186, 191, 176, 181, 174, 171, 164, 161, 146, 151, 152, 157, 134, 131, 140, 137, 234, 239, 224, 229, 254, 251, 244, 241, 194, 199, 200, 205, 214, 211, 220, 217, 26, 31, 16, 21, 14, 11, 4, 1, 50, 55, 56, 61, 38, 35, 44, 41, 74, 79, 64, 69, 94, 91, 84, 81, 98, 103, 104, 109, 118, 115, 124, 121, 231, 226, 237, 232, 243, 246, 249, 252, 207, 202, 197, 192, 219, 222, 209, 212, 183, 178, 189, 184, 163, 166, 169, 172, 159, 154, 149, 144, 139, 142, 129, 132, 71, 66, 77, 72, 83, 86, 89, 92, 111, 106, 101, 96, 123, 126, 113, 116, 23, 18, 29, 24, 3, 6, 9, 12, 63, 58, 53, 48, 43, 46, 33, 36, ],
[0, 6, 12, 10, 24, 30, 20, 18, 48, 54, 60, 58, 40, 46, 36, 34, 96, 102, 108, 106, 120, 126, 116, 114, 80, 86, 92, 90, 72, 78, 68, 66, 192, 198, 204, 202, 216, 222, 212, 210, 240, 246, 252, 250, 232, 238, 228, 226, 160, 166, 172, 170, 184, 190, 180, 178, 144, 150, 156, 154, 136, 142, 132, 130, 157, 155, 145, 151, 133, 131, 137, 143, 173, 171, 161, 167, 181, 179, 185, 191, 253, 251, 241, 247, 229, 227, 233, 239, 205, 203, 193, 199, 213, 211, 217, 223, 93, 91, 81, 87, 69, 67, 73, 79, 109, 107, 97, 103, 117, 115, 121, 127, 61, 59, 49, 55, 37, 35, 41, 47, 13, 11, 1, 7, 21, 19, 25, 31, 39, 33, 43, 45, 63, 57, 51, 53, 23, 17, 27, 29, 15, 9, 3, 5, 71, 65, 75, 77, 95, 89, 83, 85, 119, 113, 123, 125, 111, 105, 99, 101, 231, 225, 235, 237, 255, 249, 243, 245, 215, 209, 219, 221, 207, 201, 195, 197, 135, 129, 139, 141, 159, 153, 147, 149, 183, 177, 187, 189, 175, 169, 163, 165, 186, 188, 182, 176, 162, 164, 174, 168, 138, 140, 134, 128, 146, 148, 158, 152, 218, 220, 214, 208, 194, 196, 206, 200, 234, 236, 230, 224, 242, 244, 254, 248, 122, 124, 118, 112, 98, 100, 110, 104, 74, 76, 70, 64, 82, 84, 94, 88, 26, 28, 22, 16, 2, 4, 14, 8, 42, 44, 38, 32, 50, 52, 62, 56, ],
[0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 221, 218, 211, 212, 193, 198, 207, 200, 229, 226, 235, 236, 249, 254, 247, 240, 173, 170, 163, 164, 177, 182, 191, 184, 149, 146, 155, 156, 137, 142, 135, 128, 61, 58, 51, 52, 33, 38, 47, 40, 5, 2, 11, 12, 25, 30, 23, 16, 77, 74, 67, 68, 81, 86, 95, 88, 117, 114, 123, 124, 105, 110, 103, 96, 167, 160, 169, 174, 187, 188, 181, 178, 159, 152, 145, 150, 131, 132, 141, 138, 215, 208, 217, 222, 203, 204, 197, 194, 239, 232, 225, 230, 243, 244, 253, 250, 71, 64, 73, 78, 91, 92, 85, 82, 127, 120, 113, 118, 99, 100, 109, 106, 55, 48, 57, 62, 43, 44, 37, 34, 15, 8, 1, 6, 19, 20, 29, 26, 122, 125, 116, 115, 102, 97, 104, 111, 66, 69, 76, 75, 94, 89, 80, 87, 10, 13, 4, 3, 22, 17, 24, 31, 50, 53, 60, 59, 46, 41, 32, 39, 154, 157, 148, 147, 134, 129, 136, 143, 162, 165, 172, 171, 190, 185, 176, 183, 234, 237, 228, 227, 246, 241, 248, 255, 210, 213, 220, 219, 206, 201, 192, 199, ],
[0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 152, 160, 168, 176, 184, 192, 200, 208, 216, 224, 232, 240, 248, 29, 21, 13, 5, 61, 53, 45, 37, 93, 85, 77, 69, 125, 117, 109, 101, 157, 149, 141, 133, 189, 181, 173, 165, 221, 213, 205, 197, 253, 245, 237, 229, 58, 50, 42, 34, 26, 18, 10, 2, 122, 114, 106, 98, 90, 82, 74, 66, 186, 178, 170, 162, 154, 146, 138, 130, 250, 242, 234, 226, 218, 210, 202, 194, 39, 47, 55, 63, 7, 15, 23, 31, 103, 111, 119, 127, 71, 79, 87, 95, 167, 175, 183, 191, 135, 143, 151, 159, 231, 239, 247, 255, 199, 207, 215, 223, 116, 124, 100, 108, 84, 92, 68, 76, 52, 60, 36, 44, 20, 28, 4, 12, 244, 252, 228, 236, 212, 220, 196, 204, 180, 188, 164, 172, 148, 156, 132, 140, 105, 97, 121, 113, 73, 65, 89, 81, 41, 33, 57, 49, 9, 1, 25, 17, 233, 225, 249, 241, 201, 193, 217, 209, 169, 161, 185, 177, 137, 129, 153, 145, 78, 70, 94, 86, 110, 102, 126, 118, 14, 6, 30, 22, 46, 38, 62, 54, 206, 198, 222, 214, 238, 230, 254, 246, 142, 134, 158, 150, 174, 166, 190, 182, 83, 91, 67, 75, 115, 123, 99, 107, 19, 27, 3, 11, 51, 59, 35, 43, 211, 219, 195, 203, 243, 251, 227, 235, 147, 155, 131, 139, 179, 187, 163, 171, ],
[0, 9, 18, 27, 36, 45, 54, 63, 72, 65, 90, 83, 108, 101, 126, 119, 144, 153, 130, 139, 180, 189, 166, 175, 216, 209, 202, 195, 252, 245, 238, 231, 61, 52, 47, 38, 25, 16, 11, 2, 117, 124, 103, 110, 81, 88, 67, 74, 173, 164, 191, 182, 137, 128, 155, 146, 229, 236, 247, 254, 193, 200, 211, 218, 122, 115, 104, 97, 94, 87, 76, 69, 50, 59, 32, 41, 22, 31, 4, 13, 234, 227, 248, 241, 206, 199, 220, 213, 162, 171, 176, 185, 134, 143, 148, 157, 71, 78, 85, 92, 99, 106, 113, 120, 15, 6, 29, 20, 43, 34, 57, 48, 215, 222, 197, 204, 243, 250, 225, 232, 159, 150, 141, 132, 187, 178, 169, 160, 244, 253, 230, 239, 208, 217, 194, 203, 188, 181, 174, 167, 152, 145, 138, 131, 100, 109, 118, 127, 64, 73, 82, 91, 44, 37, 62, 55, 8, 1, 26, 19, 201, 192, 219, 210, 237, 228, 255, 246, 129, 136, 147, 154, 165, 172, 183, 190, 89, 80, 75, 66, 125, 116, 111, 102, 17, 24, 3, 10, 53, 60, 39, 46, 142, 135, 156, 149, 170, 163, 184, 177, 198, 207, 212, 221, 226, 235, 240, 249, 30, 23, 12, 5, 58, 51, 40, 33, 86, 95, 68, 77, 114, 123, 96, 105, 179, 186, 161, 168, 151, 158, 133, 140, 251, 242, 233, 224, 223, 214, 205, 196, 35, 42, 49, 56, 7, 14, 21, 28, 107, 98, 121, 112, 79, 70, 93, 84, ],
[0, 10, 20, 30, 40, 34, 60, 54, 80, 90, 68, 78, 120, 114, 108, 102, 160, 170, 180, 190, 136, 130, 156, 150, 240, 250, 228, 238, 216, 210, 204, 198, 93, 87, 73, 67, 117, 127, 97, 107, 13, 7, 25, 19, 37, 47, 49, 59, 253, 247, 233, 227, 213, 223, 193, 203, 173, 167, 185, 179, 133, 143, 145, 155, 186, 176, 174, 164, 146, 152, 134, 140, 234, 224, 254, 244, 194, 200, 214, 220, 26, 16, 14, 4, 50, 56, 38, 44, 74, 64, 94, 84, 98, 104, 118, 124, 231, 237, 243, 249, 207, 197, 219, 209, 183, 189, 163, 169, 159, 149, 139, 129, 71, 77, 83, 89, 111, 101, 123, 113, 23, 29, 3, 9, 63, 53, 43, 33, 105, 99, 125, 119, 65, 75, 85, 95, 57, 51, 45, 39, 17, 27, 5, 15, 201, 195, 221, 215, 225, 235, 245, 255, 153, 147, 141, 135, 177, 187, 165, 175, 52, 62, 32, 42, 28, 22, 8, 2, 100, 110, 112, 122, 76, 70, 88, 82, 148, 158, 128, 138, 188, 182, 168, 162, 196, 206, 208, 218, 236, 230, 248, 242, 211, 217, 199, 205, 251, 241, 239, 229, 131, 137, 151, 157, 171, 161, 191, 181, 115, 121, 103, 109, 91, 81, 79, 69, 35, 41, 55, 61, 11, 1, 31, 21, 142, 132, 154, 144, 166, 172, 178, 184, 222, 212, 202, 192, 246, 252, 226, 232, 46, 36, 58, 48, 6, 12, 18, 24, 126, 116, 106, 96, 86, 92, 66, 72, ],
[0, 11, 22, 29, 44, 39, 58, 49, 88, 83, 78, 69, 116, 127, 98, 105, 176, 187, 166, 173, 156, 151, 138, 129, 232, 227, 254, 245, 196, 207, 210, 217, 125, 118, 107, 96, 81, 90, 71, 76, 37, 46, 51, 56, 9, 2, 31, 20, 205, 198, 219, 208, 225, 234, 247, 252, 149, 158, 131, 136, 185, 178, 175, 164, 250, 241, 236, 231, 214, 221, 192, 203, 162, 169, 180, 191, 142, 133, 152, 147, 74, 65, 92, 87, 102, 109, 112, 123, 18, 25, 4, 15, 62, 53, 40, 35, 135, 140, 145, 154, 171, 160, 189, 182, 223, 212, 201, 194, 243, 248, 229, 238, 55, 60, 33, 42, 27, 16, 13, 6, 111, 100, 121, 114, 67, 72, 85, 94, 233, 226, 255, 244, 197, 206, 211, 216, 177, 186, 167, 172, 157, 150, 139, 128, 89, 82, 79, 68, 117, 126, 99, 104, 1, 10, 23, 28, 45, 38, 59, 48, 148, 159, 130, 137, 184, 179, 174, 165, 204, 199, 218, 209, 224, 235, 246, 253, 36, 47, 50, 57, 8, 3, 30, 21, 124, 119, 106, 97, 80, 91, 70, 77, 19, 24, 5, 14, 63, 52, 41, 34, 75, 64, 93, 86, 103, 108, 113, 122, 163, 168, 181, 190, 143, 132, 153, 146, 251, 240, 237, 230, 215, 220, 193, 202, 110, 101, 120, 115, 66, 73, 84, 95, 54, 61, 32, 43, 26, 17, 12, 7, 222, 213, 200, 195, 242, 249, 228, 239, 134, 141, 144, 155, 170, 161, 188, 183, ],
[0, 12, 24, 20, 48, 60, 40, 36, 96, 108, 120, 116, 80, 92, 72, 68, 192, 204, 216, 212, 240, 252, 232, 228, 160, 172, 184, 180, 144, 156, 136, 132, 157, 145, 133, 137, 173, 161, 181, 185, 253, 241, 229, 233, 205, 193, 213, 217, 93, 81, 69, 73, 109, 97, 117, 121, 61, 49, 37, 41, 13, 1, 21, 25, 39, 43, 63, 51, 23, 27, 15, 3, 71, 75, 95, 83, 119, 123, 111, 99, 231, 235, 255, 243, 215, 219, 207, 195, 135, 139, 159, 147, 183, 187, 175, 163, 186, 182, 162, 174, 138, 134, 146, 158, 218, 214, 194, 206, 234, 230, 242, 254, 122, 118, 98, 110, 74, 70, 82, 94, 26, 22, 2, 14, 42, 38, 50, 62, 78, 66, 86, 90, 126, 114, 102, 106, 46, 34, 54, 58, 30, 18, 6, 10, 142, 130, 150, 154, 190, 178, 166, 170, 238, 226, 246, 250, 222, 210, 198, 202, 211, 223, 203, 199, 227, 239, 251, 247, 179, 191, 171, 167, 131, 143, 155, 151, 19, 31, 11, 7, 35, 47, 59, 55, 115, 127, 107, 103, 67, 79, 91, 87, 105, 101, 113, 125, 89, 85, 65, 77, 9, 5, 17, 29, 57, 53, 33, 45, 169, 165, 177, 189, 153, 149, 129, 141, 201, 197, 209, 221, 249, 245, 225, 237, 244, 248, 236, 224, 196, 200, 220, 208, 148, 152, 140, 128, 164, 168, 188, 176, 52, 56, 44, 32, 4, 8, 28, 16, 84, 88, 76, 64, 100, 104, 124, 112, ],
[0, 13, 26, 23, 52, 57, 46, 35, 104, 101, 114, 127, 92, 81, 70, 75, 208, 221, 202, 199, 228, 233, 254, 243, 184, 181, 162, 175, 140, 129, 150, 155, 189, 176, 167, 170, 137, 132, 147, 158, 213, 216, 207, 194, 225, 236, 251, 246, 109, 96, 119, 122, 89, 84, 67, 78, 5, 8, 31, 18, 49, 60, 43, 38, 103, 106, 125, 112, 83, 94, 73, 68, 15, 2, 21, 24, 59, 54, 33, 44, 183, 186, 173, 160, 131, 142, 153, 148, 223, 210, 197, 200, 235, 230, 241, 252, 218, 215, 192, 205, 238, 227, 244, 249, 178, 191, 168, 165, 134, 139, 156, 145, 10, 7, 16, 29, 62, 51, 36, 41, 98, 111, 120, 117, 86, 91, 76, 65, 206, 195, 212, 217, 250, 247, 224, 237, 166, 171, 188, 177, 146, 159, 136, 133, 30, 19, 4, 9, 42, 39, 48, 61, 118, 123, 108, 97, 66, 79, 88, 85, 115, 126, 105, 100, 71, 74, 93, 80, 27, 22, 1, 12, 47, 34, 53, 56, 163, 174, 185, 180, 151, 154, 141, 128, 203, 198, 209, 220, 255, 242, 229, 232, 169, 164, 179, 190, 157, 144, 135, 138, 193, 204, 219, 214, 245, 248, 239, 226, 121, 116, 99, 110, 77, 64, 87, 90, 17, 28, 11, 6, 37, 40, 63, 50, 20, 25, 14, 3, 32, 45, 58, 55, 124, 113, 102, 107, 72, 69, 82, 95, 196, 201, 222, 211, 240, 253, 234, 231, 172, 161, 182, 187, 152, 149, 130, 143, ],
[0, 14, 28, 18, 56, 54, 36, 42, 112, 126, 108, 98, 72, 70, 84, 90, 224, 238, 252, 242, 216, 214, 196, 202, 144, 158, 140, 130, 168, 166, 180, 186, 221, 211, 193, 207, 229, 235, 249, 247, 173, 163, 177, 191, 149, 155, 137, 135, 61, 51, 33, 47, 5, 11, 25, 23, 77, 67, 81, 95, 117, 123, 105, 103, 167, 169, 187, 181, 159, 145, 131, 141, 215, 217, 203, 197, 239, 225, 243, 253, 71, 73, 91, 85, 127, 113, 99, 109, 55, 57, 43, 37, 15, 1, 19, 29, 122, 116, 102, 104, 66, 76, 94, 80, 10, 4, 22, 24, 50, 60, 46, 32, 154, 148, 134, 136, 162, 172, 190, 176, 234, 228, 246, 248, 210, 220, 206, 192, 83, 93, 79, 65, 107, 101, 119, 121, 35, 45, 63, 49, 27, 21, 7, 9, 179, 189, 175, 161, 139, 133, 151, 153, 195, 205, 223, 209, 251, 245, 231, 233, 142, 128, 146, 156, 182, 184, 170, 164, 254, 240, 226, 236, 198, 200, 218, 212, 110, 96, 114, 124, 86, 88, 74, 68, 30, 16, 2, 12, 38, 40, 58, 52, 244, 250, 232, 230, 204, 194, 208, 222, 132, 138, 152, 150, 188, 178, 160, 174, 20, 26, 8, 6, 44, 34, 48, 62, 100, 106, 120, 118, 92, 82, 64, 78, 41, 39, 53, 59, 17, 31, 13, 3, 89, 87, 69, 75, 97, 111, 125, 115, 201, 199, 213, 219, 241, 255, 237, 227, 185, 183, 165, 171, 129, 143, 157, 147, ],
[0, 15, 30, 17, 60, 51, 34, 45, 120, 119, 102, 105, 68, 75, 90, 85, 240, 255, 238, 225, 204, 195, 210, 221, 136, 135, 150, 153, 180, 187, 170, 165, 253, 242, 227, 236, 193, 206, 223, 208, 133, 138, 155, 148, 185, 182, 167, 168, 13, 2, 19, 28, 49, 62, 47, 32, 117, 122, 107, 100, 73, 70, 87, 88, 231, 232, 249, 246, 219, 212, 197, 202, 159, 144, 129, 142, 163, 172, 189, 178, 23, 24, 9, 6, 43, 36, 53, 58, 111, 96, 113, 126, 83, 92, 77, 66, 26, 21, 4, 11, 38, 41, 56, 55, 98, 109, 124, 115, 94, 81, 64, 79, 234, 229, 244, 251, 214, 217, 200, 199, 146, 157, 140, 131, 174, 161, 176, 191, 211, 220, 205, 194, 239, 224, 241, 254, 171, 164, 181, 186, 151, 152, 137, 134, 35, 44, 61, 50, 31, 16, 1, 14, 91, 84, 69, 74, 103, 104, 121, 118, 46, 33, 48, 63, 18, 29, 12, 3, 86, 89, 72, 71, 106, 101, 116, 123, 222, 209, 192, 207, 226, 237, 252, 243, 166, 169, 184, 183, 154, 149, 132, 139, 52, 59, 42, 37, 8, 7, 22, 25, 76, 67, 82, 93, 112, 127, 110, 97, 196, 203, 218, 213, 248, 247, 230, 233, 188, 179, 162, 173, 128, 143, 158, 145, 201, 198, 215, 216, 245, 250, 235, 228, 177, 190, 175, 160, 141, 130, 147, 156, 57, 54, 39, 40, 5, 10, 27, 20, 65, 78, 95, 80, 125, 114, 99, 108, ],
[0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 29, 13, 61, 45, 93, 77, 125, 109, 157, 141, 189, 173, 221, 205, 253, 237, 58, 42, 26, 10, 122, 106, 90, 74, 186, 170, 154, 138, 250, 234, 218, 202, 39, 55, 7, 23, 103, 119, 71, 87, 167, 183, 135, 151, 231, 247, 199, 215, 116, 100, 84, 68, 52, 36, 20, 4, 244, 228, 212, 196, 180, 164, 148, 132, 105, 121, 73, 89, 41, 57, 9, 25, 233, 249, 201, 217, 169, 185, 137, 153, 78, 94, 110, 126, 14, 30, 46, 62, 206, 222, 238, 254, 142, 158, 174, 190, 83, 67, 115, 99, 19, 3, 51, 35, 211, 195, 243, 227, 147, 131, 179, 163, 232, 248, 200, 216, 168, 184, 136, 152, 104, 120, 72, 88, 40, 56, 8, 24, 245, 229, 213, 197, 181, 165, 149, 133, 117, 101, 85, 69, 53, 37, 21, 5, 210, 194, 242, 226, 146, 130, 178, 162, 82, 66, 114, 98, 18, 2, 50, 34, 207, 223, 239, 255, 143, 159, 175, 191, 79, 95, 111, 127, 15, 31, 47, 63, 156, 140, 188, 172, 220, 204, 252, 236, 28, 12, 60, 44, 92, 76, 124, 108, 129, 145, 161, 177, 193, 209, 225, 241, 1, 17, 33, 49, 65, 81, 97, 113, 166, 182, 134, 150, 230, 246, 198, 214, 38, 54, 6, 22, 102, 118, 70, 86, 187, 171, 155, 139, 251, 235, 219, 203, 59, 43, 27, 11, 123, 107, 91, 75, ],
[0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255, 13, 28, 47, 62, 73, 88, 107, 122, 133, 148, 167, 182, 193, 208, 227, 242, 26, 11, 56, 41, 94, 79, 124, 109, 146, 131, 176, 161, 214, 199, 244, 229, 23, 6, 53, 36, 83, 66, 113, 96, 159, 142, 189, 172, 219, 202, 249, 232, 52, 37, 22, 7, 112, 97, 82, 67, 188, 173, 158, 143, 248, 233, 218, 203, 57, 40, 27, 10, 125, 108, 95, 78, 177, 160, 147, 130, 245, 228, 215, 198, 46, 63, 12, 29, 106, 123, 72, 89, 166, 183, 132, 149, 226, 243, 192, 209, 35, 50, 1, 16, 103, 118, 69, 84, 171, 186, 137, 152, 239, 254, 205, 220, 104, 121, 74, 91, 44, 61, 14, 31, 224, 241, 194, 211, 164, 181, 134, 151, 101, 116, 71, 86, 33, 48, 3, 18, 237, 252, 207, 222, 169, 184, 139, 154, 114, 99, 80, 65, 54, 39, 20, 5, 250, 235, 216, 201, 190, 175, 156, 141, 127, 110, 93, 76, 59, 42, 25, 8, 247, 230, 213, 196, 179, 162, 145, 128, 92, 77, 126, 111, 24, 9, 58, 43, 212, 197, 246, 231, 144, 129, 178, 163, 81, 64, 115, 98, 21, 4, 55, 38, 217, 200, 251, 234, 157, 140, 191, 174, 70, 87, 100, 117, 2, 19, 32, 49, 206, 223, 236, 253, 138, 155, 168, 185, 75, 90, 105, 120, 15, 30, 45, 60, 195, 210, 225, 240, 135, 150, 165, 180, ],
[0, 18, 36, 54, 72, 90, 108, 126, 144, 130, 180, 166, 216, 202, 252, 238, 61, 47, 25, 11, 117, 103, 81, 67, 173, 191, 137, 155, 229, 247, 193, 211, 122, 104, 94, 76, 50, 32, 22, 4, 234, 248, 206, 220, 162, 176, 134, 148, 71, 85, 99, 113, 15, 29, 43, 57, 215, 197, 243, 225, 159, 141, 187, 169, 244, 230, 208, 194, 188, 174, 152, 138, 100, 118, 64, 82, 44, 62, 8, 26, 201, 219, 237, 255, 129, 147, 165, 183, 89, 75, 125, 111, 17, 3, 53, 39, 142, 156, 170, 184, 198, 212, 226, 240, 30, 12, 58, 40, 86, 68, 114, 96, 179, 161, 151, 133, 251, 233, 223, 205, 35, 49, 7, 21, 107, 121, 79, 93, 245, 231, 209, 195, 189, 175, 153, 139, 101, 119, 65, 83, 45, 63, 9, 27, 200, 218, 236, 254, 128, 146, 164, 182, 88, 74, 124, 110, 16, 2, 52, 38, 143, 157, 171, 185, 199, 213, 227, 241, 31, 13, 59, 41, 87, 69, 115, 97, 178, 160, 150, 132, 250, 232, 222, 204, 34, 48, 6, 20, 106, 120, 78, 92, 1, 19, 37, 55, 73, 91, 109, 127, 145, 131, 181, 167, 217, 203, 253, 239, 60, 46, 24, 10, 116, 102, 80, 66, 172, 190, 136, 154, 228, 246, 192, 210, 123, 105, 95, 77, 51, 33, 23, 5, 235, 249, 207, 221, 163, 177, 135, 149, 70, 84, 98, 112, 14, 28, 42, 56, 214, 196, 242, 224, 158, 140, 186, 168, ],
[0, 19, 38, 53, 76, 95, 106, 121, 152, 139, 190, 173, 212, 199, 242, 225, 45, 62, 11, 24, 97, 114, 71, 84, 181, 166, 147, 128, 249, 234, 223, 204, 90, 73, 124, 111, 22, 5, 48, 35, 194, 209, 228, 247, 142, 157, 168, 187, 119, 100, 81, 66, 59, 40, 29, 14, 239, 252, 201, 218, 163, 176, 133, 150, 180, 167, 146, 129, 248, 235, 222, 205, 44, 63, 10, 25, 96, 115, 70, 85, 153, 138, 191, 172, 213, 198, 243, 224, 1, 18, 39, 52, 77, 94, 107, 120, 238, 253, 200, 219, 162, 177, 132, 151, 118, 101, 80, 67, 58, 41, 28, 15, 195, 208, 229, 246, 143, 156, 169, 186, 91, 72, 125, 110, 23, 4, 49, 34, 117, 102, 83, 64, 57, 42, 31, 12, 237, 254, 203, 216, 161, 178, 135, 148, 88, 75, 126, 109, 20, 7, 50, 33, 192, 211, 230, 245, 140, 159, 170, 185, 47, 60, 9, 26, 99, 112, 69, 86, 183, 164, 145, 130, 251, 232, 221, 206, 2, 17, 36, 55, 78, 93, 104, 123, 154, 137, 188, 175, 214, 197, 240, 227, 193, 210, 231, 244, 141, 158, 171, 184, 89, 74, 127, 108, 21, 6, 51, 32, 236, 255, 202, 217, 160, 179, 134, 149, 116, 103, 82, 65, 56, 43, 30, 13, 155, 136, 189, 174, 215, 196, 241, 226, 3, 16, 37, 54, 79, 92, 105, 122, 182, 165, 144, 131, 250, 233, 220, 207, 46, 61, 8, 27, 98, 113, 68, 87, ],
[0, 20, 40, 60, 80, 68, 120, 108, 160, 180, 136, 156, 240, 228, 216, 204, 93, 73, 117, 97, 13, 25, 37, 49, 253, 233, 213, 193, 173, 185, 133, 145, 186, 174, 146, 134, 234, 254, 194, 214, 26, 14, 50, 38, 74, 94, 98, 118, 231, 243, 207, 219, 183, 163, 159, 139, 71, 83, 111, 123, 23, 3, 63, 43, 105, 125, 65, 85, 57, 45, 17, 5, 201, 221, 225, 245, 153, 141, 177, 165, 52, 32, 28, 8, 100, 112, 76, 88, 148, 128, 188, 168, 196, 208, 236, 248, 211, 199, 251, 239, 131, 151, 171, 191, 115, 103, 91, 79, 35, 55, 11, 31, 142, 154, 166, 178, 222, 202, 246, 226, 46, 58, 6, 18, 126, 106, 86, 66, 210, 198, 250, 238, 130, 150, 170, 190, 114, 102, 90, 78, 34, 54, 10, 30, 143, 155, 167, 179, 223, 203, 247, 227, 47, 59, 7, 19, 127, 107, 87, 67, 104, 124, 64, 84, 56, 44, 16, 4, 200, 220, 224, 244, 152, 140, 176, 164, 53, 33, 29, 9, 101, 113, 77, 89, 149, 129, 189, 169, 197, 209, 237, 249, 187, 175, 147, 135, 235, 255, 195, 215, 27, 15, 51, 39, 75, 95, 99, 119, 230, 242, 206, 218, 182, 162, 158, 138, 70, 82, 110, 122, 22, 2, 62, 42, 1, 21, 41, 61, 81, 69, 121, 109, 161, 181, 137, 157, 241, 229, 217, 205, 92, 72, 116, 96, 12, 24, 36, 48, 252, 232, 212, 192, 172, 184, 132, 144, ],
[0, 21, 42, 63, 84, 65, 126, 107, 168, 189, 130, 151, 252, 233, 214, 195, 77, 88, 103, 114, 25, 12, 51, 38, 229, 240, 207, 218, 177, 164, 155, 142, 154, 143, 176, 165, 206, 219, 228, 241, 50, 39, 24, 13, 102, 115, 76, 89, 215, 194, 253, 232, 131, 150, 169, 188, 127, 106, 85, 64, 43, 62, 1, 20, 41, 60, 3, 22, 125, 104, 87, 66, 129, 148, 171, 190, 213, 192, 255, 234, 100, 113, 78, 91, 48, 37, 26, 15, 204, 217, 230, 243, 152, 141, 178, 167, 179, 166, 153, 140, 231, 242, 205, 216, 27, 14, 49, 36, 79, 90, 101, 112, 254, 235, 212, 193, 170, 191, 128, 149, 86, 67, 124, 105, 2, 23, 40, 61, 82, 71, 120, 109, 6, 19, 44, 57, 250, 239, 208, 197, 174, 187, 132, 145, 31, 10, 53, 32, 75, 94, 97, 116, 183, 162, 157, 136, 227, 246, 201, 220, 200, 221, 226, 247, 156, 137, 182, 163, 96, 117, 74, 95, 52, 33, 30, 11, 133, 144, 175, 186, 209, 196, 251, 238, 45, 56, 7, 18, 121, 108, 83, 70, 123, 110, 81, 68, 47, 58, 5, 16, 211, 198, 249, 236, 135, 146, 173, 184, 54, 35, 28, 9, 98, 119, 72, 93, 158, 139, 180, 161, 202, 223, 224, 245, 225, 244, 203, 222, 181, 160, 159, 138, 73, 92, 99, 118, 29, 8, 55, 34, 172, 185, 134, 147, 248, 237, 210, 199, 4, 17, 46, 59, 80, 69, 122, 111, ],
[0, 22, 44, 58, 88, 78, 116, 98, 176, 166, 156, 138, 232, 254, 196, 210, 125, 107, 81, 71, 37, 51, 9, 31, 205, 219, 225, 247, 149, 131, 185, 175, 250, 236, 214, 192, 162, 180, 142, 152, 74, 92, 102, 112, 18, 4, 62, 40, 135, 145, 171, 189, 223, 201, 243, 229, 55, 33, 27, 13, 111, 121, 67, 85, 233, 255, 197, 211, 177, 167, 157, 139, 89, 79, 117, 99, 1, 23, 45, 59, 148, 130, 184, 174, 204, 218, 224, 246, 36, 50, 8, 30, 124, 106, 80, 70, 19, 5, 63, 41, 75, 93, 103, 113, 163, 181, 143, 153, 251, 237, 215, 193, 110, 120, 66, 84, 54, 32, 26, 12, 222, 200, 242, 228, 134, 144, 170, 188, 207, 217, 227, 245, 151, 129, 187, 173, 127, 105, 83, 69, 39, 49, 11, 29, 178, 164, 158, 136, 234, 252, 198, 208, 2, 20, 46, 56, 90, 76, 118, 96, 53, 35, 25, 15, 109, 123, 65, 87, 133, 147, 169, 191, 221, 203, 241, 231, 72, 94, 100, 114, 16, 6, 60, 42, 248, 238, 212, 194, 160, 182, 140, 154, 38, 48, 10, 28, 126, 104, 82, 68, 150, 128, 186, 172, 206, 216, 226, 244, 91, 77, 119, 97, 3, 21, 47, 57, 235, 253, 199, 209, 179, 165, 159, 137, 220, 202, 240, 230, 132, 146, 168, 190, 108, 122, 64, 86, 52, 34, 24, 14, 161, 183, 141, 155, 249, 239, 213, 195, 17, 7, 61, 43, 73, 95, 101, 115, ],
[0, 23, 46, 57, 92, 75, 114, 101, 184, 175, 150, 129, 228, 243, 202, 221, 109, 122, 67, 84, 49, 38, 31, 8, 213, 194, 251, 236, 137, 158, 167, 176, 218, 205, 244, 227, 134, 145, 168, 191, 98, 117, 76, 91, 62, 41, 16, 7, 183, 160, 153, 142, 235, 252, 197, 210, 15, 24, 33, 54, 83, 68, 125, 106, 169, 190, 135, 144, 245, 226, 219, 204, 17, 6, 63, 40, 77, 90, 99, 116, 196, 211, 234, 253, 152, 143, 182, 161, 124, 107, 82, 69, 32, 55, 14, 25, 115, 100, 93, 74, 47, 56, 1, 22, 203, 220, 229, 242, 151, 128, 185, 174, 30, 9, 48, 39, 66, 85, 108, 123, 166, 177, 136, 159, 250, 237, 212, 195, 79, 88, 97, 118, 19, 4, 61, 42, 247, 224, 217, 206, 171, 188, 133, 146, 34, 53, 12, 27, 126, 105, 80, 71, 154, 141, 180, 163, 198, 209, 232, 255, 149, 130, 187, 172, 201, 222, 231, 240, 45, 58, 3, 20, 113, 102, 95, 72, 248, 239, 214, 193, 164, 179, 138, 157, 64, 87, 110, 121, 28, 11, 50, 37, 230, 241, 200, 223, 186, 173, 148, 131, 94, 73, 112, 103, 2, 21, 44, 59, 139, 156, 165, 178, 215, 192, 249, 238, 51, 36, 29, 10, 111, 120, 65, 86, 60, 43, 18, 5, 96, 119, 78, 89, 132, 147, 170, 189, 216, 207, 246, 225, 81, 70, 127, 104, 13, 26, 35, 52, 233, 254, 199, 208, 181, 162, 155, 140, ],
[0, 24, 48, 40, 96, 120, 80, 72, 192, 216, 240, 232, 160, 184, 144, 136, 157, 133, 173, 181, 253, 229, 205, 213, 93, 69, 109, 117, 61, 37, 13, 21, 39, 63, 23, 15, 71, 95, 119, 111, 231, 255, 215, 207, 135, 159, 183, 175, 186, 162, 138, 146, 218, 194, 234, 242, 122, 98, 74, 82, 26, 2, 42, 50, 78, 86, 126, 102, 46, 54, 30, 6, 142, 150, 190, 166, 238, 246, 222, 198, 211, 203, 227, 251, 179, 171, 131, 155, 19, 11, 35, 59, 115, 107, 67, 91, 105, 113, 89, 65, 9, 17, 57, 33, 169, 177, 153, 129, 201, 209, 249, 225, 244, 236, 196, 220, 148, 140, 164, 188, 52, 44, 4, 28, 84, 76, 100, 124, 156, 132, 172, 180, 252, 228, 204, 212, 92, 68, 108, 116, 60, 36, 12, 20, 1, 25, 49, 41, 97, 121, 81, 73, 193, 217, 241, 233, 161, 185, 145, 137, 187, 163, 139, 147, 219, 195, 235, 243, 123, 99, 75, 83, 27, 3, 43, 51, 38, 62, 22, 14, 70, 94, 118, 110, 230, 254, 214, 206, 134, 158, 182, 174, 210, 202, 226, 250, 178, 170, 130, 154, 18, 10, 34, 58, 114, 106, 66, 90, 79, 87, 127, 103, 47, 55, 31, 7, 143, 151, 191, 167, 239, 247, 223, 199, 245, 237, 197, 221, 149, 141, 165, 189, 53, 45, 5, 29, 85, 77, 101, 125, 104, 112, 88, 64, 8, 16, 56, 32, 168, 176, 152, 128, 200, 208, 248, 224, ],
[0, 25, 50, 43, 100, 125, 86, 79, 200, 209, 250, 227, 172, 181, 158, 135, 141, 148, 191, 166, 233, 240, 219, 194, 69, 92, 119, 110, 33, 56, 19, 10, 7, 30, 53, 44, 99, 122, 81, 72, 207, 214, 253, 228, 171, 178, 153, 128, 138, 147, 184, 161, 238, 247, 220, 197, 66, 91, 112, 105, 38, 63, 20, 13, 14, 23, 60, 37, 106, 115, 88, 65, 198, 223, 244, 237, 162, 187, 144, 137, 131, 154, 177, 168, 231, 254, 213, 204, 75, 82, 121, 96, 47, 54, 29, 4, 9, 16, 59, 34, 109, 116, 95, 70, 193, 216, 243, 234, 165, 188, 151, 142, 132, 157, 182, 175, 224, 249, 210, 203, 76, 85, 126, 103, 40, 49, 26, 3, 28, 5, 46, 55, 120, 97, 74, 83, 212, 205, 230, 255, 176, 169, 130, 155, 145, 136, 163, 186, 245, 236, 199, 222, 89, 64, 107, 114, 61, 36, 15, 22, 27, 2, 41, 48, 127, 102, 77, 84, 211, 202, 225, 248, 183, 174, 133, 156, 150, 143, 164, 189, 242, 235, 192, 217, 94, 71, 108, 117, 58, 35, 8, 17, 18, 11, 32, 57, 118, 111, 68, 93, 218, 195, 232, 241, 190, 167, 140, 149, 159, 134, 173, 180, 251, 226, 201, 208, 87, 78, 101, 124, 51, 42, 1, 24, 21, 12, 39, 62, 113, 104, 67, 90, 221, 196, 239, 246, 185, 160, 139, 146, 152, 129, 170, 179, 252, 229, 206, 215, 80, 73, 98, 123, 52, 45, 6, 31, ],
[0, 26, 52, 46, 104, 114, 92, 70, 208, 202, 228, 254, 184, 162, 140, 150, 189, 167, 137, 147, 213, 207, 225, 251, 109, 119, 89, 67, 5, 31, 49, 43, 103, 125, 83, 73, 15, 21, 59, 33, 183, 173, 131, 153, 223, 197, 235, 241, 218, 192, 238, 244, 178, 168, 134, 156, 10, 16, 62, 36, 98, 120, 86, 76, 206, 212, 250, 224, 166, 188, 146, 136, 30, 4, 42, 48, 118, 108, 66, 88, 115, 105, 71, 93, 27, 1, 47, 53, 163, 185, 151, 141, 203, 209, 255, 229, 169, 179, 157, 135, 193, 219, 245, 239, 121, 99, 77, 87, 17, 11, 37, 63, 20, 14, 32, 58, 124, 102, 72, 82, 196, 222, 240, 234, 172, 182, 152, 130, 129, 155, 181, 175, 233, 243, 221, 199, 81, 75, 101, 127, 57, 35, 13, 23, 60, 38, 8, 18, 84, 78, 96, 122, 236, 246, 216, 194, 132, 158, 176, 170, 230, 252, 210, 200, 142, 148, 186, 160, 54, 44, 2, 24, 94, 68, 106, 112, 91, 65, 111, 117, 51, 41, 7, 29, 139, 145, 191, 165, 227, 249, 215, 205, 79, 85, 123, 97, 39, 61, 19, 9, 159, 133, 171, 177, 247, 237, 195, 217, 242, 232, 198, 220, 154, 128, 174, 180, 34, 56, 22, 12, 74, 80, 126, 100, 40, 50, 28, 6, 64, 90, 116, 110, 248, 226, 204, 214, 144, 138, 164, 190, 149, 143, 161, 187, 253, 231, 201, 211, 69, 95, 113, 107, 45, 55, 25, 3, ],
[0, 27, 54, 45, 108, 119, 90, 65, 216, 195, 238, 245, 180, 175, 130, 153, 173, 182, 155, 128, 193, 218, 247, 236, 117, 110, 67, 88, 25, 2, 47, 52, 71, 92, 113, 106, 43, 48, 29, 6, 159, 132, 169, 178, 243, 232, 197, 222, 234, 241, 220, 199, 134, 157, 176, 171, 50, 41, 4, 31, 94, 69, 104, 115, 142, 149, 184, 163, 226, 249, 212, 207, 86, 77, 96, 123, 58, 33, 12, 23, 35, 56, 21, 14, 79, 84, 121, 98, 251, 224, 205, 214, 151, 140, 161, 186, 201, 210, 255, 228, 165, 190, 147, 136, 17, 10, 39, 60, 125, 102, 75, 80, 100, 127, 82, 73, 8, 19, 62, 37, 188, 167, 138, 145, 208, 203, 230, 253, 1, 26, 55, 44, 109, 118, 91, 64, 217, 194, 239, 244, 181, 174, 131, 152, 172, 183, 154, 129, 192, 219, 246, 237, 116, 111, 66, 89, 24, 3, 46, 53, 70, 93, 112, 107, 42, 49, 28, 7, 158, 133, 168, 179, 242, 233, 196, 223, 235, 240, 221, 198, 135, 156, 177, 170, 51, 40, 5, 30, 95, 68, 105, 114, 143, 148, 185, 162, 227, 248, 213, 206, 87, 76, 97, 122, 59, 32, 13, 22, 34, 57, 20, 15, 78, 85, 120, 99, 250, 225, 204, 215, 150, 141, 160, 187, 200, 211, 254, 229, 164, 191, 146, 137, 16, 11, 38, 61, 124, 103, 74, 81, 101, 126, 83, 72, 9, 18, 63, 36, 189, 166, 139, 144, 209, 202, 231, 252, ],
[0, 28, 56, 36, 112, 108, 72, 84, 224, 252, 216, 196, 144, 140, 168, 180, 221, 193, 229, 249, 173, 177, 149, 137, 61, 33, 5, 25, 77, 81, 117, 105, 167, 187, 159, 131, 215, 203, 239, 243, 71, 91, 127, 99, 55, 43, 15, 19, 122, 102, 66, 94, 10, 22, 50, 46, 154, 134, 162, 190, 234, 246, 210, 206, 83, 79, 107, 119, 35, 63, 27, 7, 179, 175, 139, 151, 195, 223, 251, 231, 142, 146, 182, 170, 254, 226, 198, 218, 110, 114, 86, 74, 30, 2, 38, 58, 244, 232, 204, 208, 132, 152, 188, 160, 20, 8, 44, 48, 100, 120, 92, 64, 41, 53, 17, 13, 89, 69, 97, 125, 201, 213, 241, 237, 185, 165, 129, 157, 166, 186, 158, 130, 214, 202, 238, 242, 70, 90, 126, 98, 54, 42, 14, 18, 123, 103, 67, 95, 11, 23, 51, 47, 155, 135, 163, 191, 235, 247, 211, 207, 1, 29, 57, 37, 113, 109, 73, 85, 225, 253, 217, 197, 145, 141, 169, 181, 220, 192, 228, 248, 172, 176, 148, 136, 60, 32, 4, 24, 76, 80, 116, 104, 245, 233, 205, 209, 133, 153, 189, 161, 21, 9, 45, 49, 101, 121, 93, 65, 40, 52, 16, 12, 88, 68, 96, 124, 200, 212, 240, 236, 184, 164, 128, 156, 82, 78, 106, 118, 34, 62, 26, 6, 178, 174, 138, 150, 194, 222, 250, 230, 143, 147, 183, 171, 255, 227, 199, 219, 111, 115, 87, 75, 31, 3, 39, 59, ],
[0, 29, 58, 39, 116, 105, 78, 83, 232, 245, 210, 207, 156, 129, 166, 187, 205, 208, 247, 234, 185, 164, 131, 158, 37, 56, 31, 2, 81, 76, 107, 118, 135, 154, 189, 160, 243, 238, 201, 212, 111, 114, 85, 72, 27, 6, 33, 60, 74, 87, 112, 109, 62, 35, 4, 25, 162, 191, 152, 133, 214, 203, 236, 241, 19, 14, 41, 52, 103, 122, 93, 64, 251, 230, 193, 220, 143, 146, 181, 168, 222, 195, 228, 249, 170, 183, 144, 141, 54, 43, 12, 17, 66, 95, 120, 101, 148, 137, 174, 179, 224, 253, 218, 199, 124, 97, 70, 91, 8, 21, 50, 47, 89, 68, 99, 126, 45, 48, 23, 10, 177, 172, 139, 150, 197, 216, 255, 226, 38, 59, 28, 1, 82, 79, 104, 117, 206, 211, 244, 233, 186, 167, 128, 157, 235, 246, 209, 204, 159, 130, 165, 184, 3, 30, 57, 36, 119, 106, 77, 80, 161, 188, 155, 134, 213, 200, 239, 242, 73, 84, 115, 110, 61, 32, 7, 26, 108, 113, 86, 75, 24, 5, 34, 63, 132, 153, 190, 163, 240, 237, 202, 215, 53, 40, 15, 18, 65, 92, 123, 102, 221, 192, 231, 250, 169, 180, 147, 142, 248, 229, 194, 223, 140, 145, 182, 171, 16, 13, 42, 55, 100, 121, 94, 67, 178, 175, 136, 149, 198, 219, 252, 225, 90, 71, 96, 125, 46, 51, 20, 9, 127, 98, 69, 88, 11, 22, 49, 44, 151, 138, 173, 176, 227, 254, 217, 196, ],
[0, 30, 60, 34, 120, 102, 68, 90, 240, 238, 204, 210, 136, 150, 180, 170, 253, 227, 193, 223, 133, 155, 185, 167, 13, 19, 49, 47, 117, 107, 73, 87, 231, 249, 219, 197, 159, 129, 163, 189, 23, 9, 43, 53, 111, 113, 83, 77, 26, 4, 38, 56, 98, 124, 94, 64, 234, 244, 214, 200, 146, 140, 174, 176, 211, 205, 239, 241, 171, 181, 151, 137, 35, 61, 31, 1, 91, 69, 103, 121, 46, 48, 18, 12, 86, 72, 106, 116, 222, 192, 226, 252, 166, 184, 154, 132, 52, 42, 8, 22, 76, 82, 112, 110, 196, 218, 248, 230, 188, 162, 128, 158, 201, 215, 245, 235, 177, 175, 141, 147, 57, 39, 5, 27, 65, 95, 125, 99, 187, 165, 135, 153, 195, 221, 255, 225, 75, 85, 119, 105, 51, 45, 15, 17, 70, 88, 122, 100, 62, 32, 2, 28, 182, 168, 138, 148, 206, 208, 242, 236, 92, 66, 96, 126, 36, 58, 24, 6, 172, 178, 144, 142, 212, 202, 232, 246, 161, 191, 157, 131, 217, 199, 229, 251, 81, 79, 109, 115, 41, 55, 21, 11, 104, 118, 84, 74, 16, 14, 44, 50, 152, 134, 164, 186, 224, 254, 220, 194, 149, 139, 169, 183, 237, 243, 209, 207, 101, 123, 89, 71, 29, 3, 33, 63, 143, 145, 179, 173, 247, 233, 203, 213, 127, 97, 67, 93, 7, 25, 59, 37, 114, 108, 78, 80, 10, 20, 54, 40, 130, 156, 190, 160, 250, 228, 198, 216, ],
[0, 31, 62, 33, 124, 99, 66, 93, 248, 231, 198, 217, 132, 155, 186, 165, 237, 242, 211, 204, 145, 142, 175, 176, 21, 10, 43, 52, 105, 118, 87, 72, 199, 216, 249, 230, 187, 164, 133, 154, 63, 32, 1, 30, 67, 92, 125, 98, 42, 53, 20, 11, 86, 73, 104, 119, 210, 205, 236, 243, 174, 177, 144, 143, 147, 140, 173, 178, 239, 240, 209, 206, 107, 116, 85, 74, 23, 8, 41, 54, 126, 97, 64, 95, 2, 29, 60, 35, 134, 153, 184, 167, 250, 229, 196, 219, 84, 75, 106, 117, 40, 55, 22, 9, 172, 179, 146, 141, 208, 207, 238, 241, 185, 166, 135, 152, 197, 218, 251, 228, 65, 94, 127, 96, 61, 34, 3, 28, 59, 36, 5, 26, 71, 88, 121, 102, 195, 220, 253, 226, 191, 160, 129, 158, 214, 201, 232, 247, 170, 181, 148, 139, 46, 49, 16, 15, 82, 77, 108, 115, 252, 227, 194, 221, 128, 159, 190, 161, 4, 27, 58, 37, 120, 103, 70, 89, 17, 14, 47, 48, 109, 114, 83, 76, 233, 246, 215, 200, 149, 138, 171, 180, 168, 183, 150, 137, 212, 203, 234, 245, 80, 79, 110, 113, 44, 51, 18, 13, 69, 90, 123, 100, 57, 38, 7, 24, 189, 162, 131, 156, 193, 222, 255, 224, 111, 112, 81, 78, 19, 12, 45, 50, 151, 136, 169, 182, 235, 244, 213, 202, 130, 157, 188, 163, 254, 225, 192, 223, 122, 101, 68, 91, 6, 25, 56, 39, ],
[0, 32, 64, 96, 128, 160, 192, 224, 29, 61, 93, 125, 157, 189, 221, 253, 58, 26, 122, 90, 186, 154, 250, 218, 39, 7, 103, 71, 167, 135, 231, 199, 116, 84, 52, 20, 244, 212, 180, 148, 105, 73, 41, 9, 233, 201, 169, 137, 78, 110, 14, 46, 206, 238, 142, 174, 83, 115, 19, 51, 211, 243, 147, 179, 232, 200, 168, 136, 104, 72, 40, 8, 245, 213, 181, 149, 117, 85, 53, 21, 210, 242, 146, 178, 82, 114, 18, 50, 207, 239, 143, 175, 79, 111, 15, 47, 156, 188, 220, 252, 28, 60, 92, 124, 129, 161, 193, 225, 1, 33, 65, 97, 166, 134, 230, 198, 38, 6, 102, 70, 187, 155, 251, 219, 59, 27, 123, 91, 205, 237, 141, 173, 77, 109, 13, 45, 208, 240, 144, 176, 80, 112, 16, 48, 247, 215, 183, 151, 119, 87, 55, 23, 234, 202, 170, 138, 106, 74, 42, 10, 185, 153, 249, 217, 57, 25, 121, 89, 164, 132, 228, 196, 36, 4, 100, 68, 131, 163, 195, 227, 3, 35, 67, 99, 158, 190, 222, 254, 30, 62, 94, 126, 37, 5, 101, 69, 165, 133, 229, 197, 56, 24, 120, 88, 184, 152, 248, 216, 31, 63, 95, 127, 159, 191, 223, 255, 2, 34, 66, 98, 130, 162, 194, 226, 81, 113, 17, 49, 209, 241, 145, 177, 76, 108, 12, 44, 204, 236, 140, 172, 107, 75, 43, 11, 235, 203, 171, 139, 118, 86, 54, 22, 246, 214, 182, 150, ],
[0, 33, 66, 99, 132, 165, 198, 231, 21, 52, 87, 118, 145, 176, 211, 242, 42, 11, 104, 73, 174, 143, 236, 205, 63, 30, 125, 92, 187, 154, 249, 216, 84, 117, 22, 55, 208, 241, 146, 179, 65, 96, 3, 34, 197, 228, 135, 166, 126, 95, 60, 29, 250, 219, 184, 153, 107, 74, 41, 8, 239, 206, 173, 140, 168, 137, 234, 203, 44, 13, 110, 79, 189, 156, 255, 222, 57, 24, 123, 90, 130, 163, 192, 225, 6, 39, 68, 101, 151, 182, 213, 244, 19, 50, 81, 112, 252, 221, 190, 159, 120, 89, 58, 27, 233, 200, 171, 138, 109, 76, 47, 14, 214, 247, 148, 181, 82, 115, 16, 49, 195, 226, 129, 160, 71, 102, 5, 36, 77, 108, 15, 46, 201, 232, 139, 170, 88, 121, 26, 59, 220, 253, 158, 191, 103, 70, 37, 4, 227, 194, 161, 128, 114, 83, 48, 17, 246, 215, 180, 149, 25, 56, 91, 122, 157, 188, 223, 254, 12, 45, 78, 111, 136, 169, 202, 235, 51, 18, 113, 80, 183, 150, 245, 212, 38, 7, 100, 69, 162, 131, 224, 193, 229, 196, 167, 134, 97, 64, 35, 2, 240, 209, 178, 147, 116, 85, 54, 23, 207, 238, 141, 172, 75, 106, 9, 40, 218, 251, 152, 185, 94, 127, 28, 61, 177, 144, 243, 210, 53, 20, 119, 86, 164, 133, 230, 199, 32, 1, 98, 67, 155, 186, 217, 248, 31, 62, 93, 124, 142, 175, 204, 237, 10, 43, 72, 105, ],
[0, 34, 68, 102, 136, 170, 204, 238, 13, 47, 73, 107, 133, 167, 193, 227, 26, 56, 94, 124, 146, 176, 214, 244, 23, 53, 83, 113, 159, 189, 219, 249, 52, 22, 112, 82, 188, 158, 248, 218, 57, 27, 125, 95, 177, 147, 245, 215, 46, 12, 106, 72, 166, 132, 226, 192, 35, 1, 103, 69, 171, 137, 239, 205, 104, 74, 44, 14, 224, 194, 164, 134, 101, 71, 33, 3, 237, 207, 169, 139, 114, 80, 54, 20, 250, 216, 190, 156, 127, 93, 59, 25, 247, 213, 179, 145, 92, 126, 24, 58, 212, 246, 144, 178, 81, 115, 21, 55, 217, 251, 157, 191, 70, 100, 2, 32, 206, 236, 138, 168, 75, 105, 15, 45, 195, 225, 135, 165, 208, 242, 148, 182, 88, 122, 28, 62, 221, 255, 153, 187, 85, 119, 17, 51, 202, 232, 142, 172, 66, 96, 6, 36, 199, 229, 131, 161, 79, 109, 11, 41, 228, 198, 160, 130, 108, 78, 40, 10, 233, 203, 173, 143, 97, 67, 37, 7, 254, 220, 186, 152, 118, 84, 50, 16, 243, 209, 183, 149, 123, 89, 63, 29, 184, 154, 252, 222, 48, 18, 116, 86, 181, 151, 241, 211, 61, 31, 121, 91, 162, 128, 230, 196, 42, 8, 110, 76, 175, 141, 235, 201, 39, 5, 99, 65, 140, 174, 200, 234, 4, 38, 64, 98, 129, 163, 197, 231, 9, 43, 77, 111, 150, 180, 210, 240, 30, 60, 90, 120, 155, 185, 223, 253, 19, 49, 87, 117, ],
[0, 35, 70, 101, 140, 175, 202, 233, 5, 38, 67, 96, 137, 170, 207, 236, 10, 41, 76, 111, 134, 165, 192, 227, 15, 44, 73, 106, 131, 160, 197, 230, 20, 55, 82, 113, 152, 187, 222, 253, 17, 50, 87, 116, 157, 190, 219, 248, 30, 61, 88, 123, 146, 177, 212, 247, 27, 56, 93, 126, 151, 180, 209, 242, 40, 11, 110, 77, 164, 135, 226, 193, 45, 14, 107, 72, 161, 130, 231, 196, 34, 1, 100, 71, 174, 141, 232, 203, 39, 4, 97, 66, 171, 136, 237, 206, 60, 31, 122, 89, 176, 147, 246, 213, 57, 26, 127, 92, 181, 150, 243, 208, 54, 21, 112, 83, 186, 153, 252, 223, 51, 16, 117, 86, 191, 156, 249, 218, 80, 115, 22, 53, 220, 255, 154, 185, 85, 118, 19, 48, 217, 250, 159, 188, 90, 121, 28, 63, 214, 245, 144, 179, 95, 124, 25, 58, 211, 240, 149, 182, 68, 103, 2, 33, 200, 235, 142, 173, 65, 98, 7, 36, 205, 238, 139, 168, 78, 109, 8, 43, 194, 225, 132, 167, 75, 104, 13, 46, 199, 228, 129, 162, 120, 91, 62, 29, 244, 215, 178, 145, 125, 94, 59, 24, 241, 210, 183, 148, 114, 81, 52, 23, 254, 221, 184, 155, 119, 84, 49, 18, 251, 216, 189, 158, 108, 79, 42, 9, 224, 195, 166, 133, 105, 74, 47, 12, 229, 198, 163, 128, 102, 69, 32, 3, 234, 201, 172, 143, 99, 64, 37, 6, 239, 204, 169, 138, ],
[0, 36, 72, 108, 144, 180, 216, 252, 61, 25, 117, 81, 173, 137, 229, 193, 122, 94, 50, 22, 234, 206, 162, 134, 71, 99, 15, 43, 215, 243, 159, 187, 244, 208, 188, 152, 100, 64, 44, 8, 201, 237, 129, 165, 89, 125, 17, 53, 142, 170, 198, 226, 30, 58, 86, 114, 179, 151, 251, 223, 35, 7, 107, 79, 245, 209, 189, 153, 101, 65, 45, 9, 200, 236, 128, 164, 88, 124, 16, 52, 143, 171, 199, 227, 31, 59, 87, 115, 178, 150, 250, 222, 34, 6, 106, 78, 1, 37, 73, 109, 145, 181, 217, 253, 60, 24, 116, 80, 172, 136, 228, 192, 123, 95, 51, 23, 235, 207, 163, 135, 70, 98, 14, 42, 214, 242, 158, 186, 247, 211, 191, 155, 103, 67, 47, 11, 202, 238, 130, 166, 90, 126, 18, 54, 141, 169, 197, 225, 29, 57, 85, 113, 176, 148, 248, 220, 32, 4, 104, 76, 3, 39, 75, 111, 147, 183, 219, 255, 62, 26, 118, 82, 174, 138, 230, 194, 121, 93, 49, 21, 233, 205, 161, 133, 68, 96, 12, 40, 212, 240, 156, 184, 2, 38, 74, 110, 146, 182, 218, 254, 63, 27, 119, 83, 175, 139, 231, 195, 120, 92, 48, 20, 232, 204, 160, 132, 69, 97, 13, 41, 213, 241, 157, 185, 246, 210, 190, 154, 102, 66, 46, 10, 203, 239, 131, 167, 91, 127, 19, 55, 140, 168, 196, 224, 28, 56, 84, 112, 177, 149, 249, 221, 33, 5, 105, 77, ],
[0, 37, 74, 111, 148, 177, 222, 251, 53, 16, 127, 90, 161, 132, 235, 206, 106, 79, 32, 5, 254, 219, 180, 145, 95, 122, 21, 48, 203, 238, 129, 164, 212, 241, 158, 187, 64, 101, 10, 47, 225, 196, 171, 142, 117, 80, 63, 26, 190, 155, 244, 209, 42, 15, 96, 69, 139, 174, 193, 228, 31, 58, 85, 112, 181, 144, 255, 218, 33, 4, 107, 78, 128, 165, 202, 239, 20, 49, 94, 123, 223, 250, 149, 176, 75, 110, 1, 36, 234, 207, 160, 133, 126, 91, 52, 17, 97, 68, 43, 14, 245, 208, 191, 154, 84, 113, 30, 59, 192, 229, 138, 175, 11, 46, 65, 100, 159, 186, 213, 240, 62, 27, 116, 81, 170, 143, 224, 197, 119, 82, 61, 24, 227, 198, 169, 140, 66, 103, 8, 45, 214, 243, 156, 185, 29, 56, 87, 114, 137, 172, 195, 230, 40, 13, 98, 71, 188, 153, 246, 211, 163, 134, 233, 204, 55, 18, 125, 88, 150, 179, 220, 249, 2, 39, 72, 109, 201, 236, 131, 166, 93, 120, 23, 50, 252, 217, 182, 147, 104, 77, 34, 7, 194, 231, 136, 173, 86, 115, 28, 57, 247, 210, 189, 152, 99, 70, 41, 12, 168, 141, 226, 199, 60, 25, 118, 83, 157, 184, 215, 242, 9, 44, 67, 102, 22, 51, 92, 121, 130, 167, 200, 237, 35, 6, 105, 76, 183, 146, 253, 216, 124, 89, 54, 19, 232, 205, 162, 135, 73, 108, 3, 38, 221, 248, 151, 178, ],
[0, 38, 76, 106, 152, 190, 212, 242, 45, 11, 97, 71, 181, 147, 249, 223, 90, 124, 22, 48, 194, 228, 142, 168, 119, 81, 59, 29, 239, 201, 163, 133, 180, 146, 248, 222, 44, 10, 96, 70, 153, 191, 213, 243, 1, 39, 77, 107, 238, 200, 162, 132, 118, 80, 58, 28, 195, 229, 143, 169, 91, 125, 23, 49, 117, 83, 57, 31, 237, 203, 161, 135, 88, 126, 20, 50, 192, 230, 140, 170, 47, 9, 99, 69, 183, 145, 251, 221, 2, 36, 78, 104, 154, 188, 214, 240, 193, 231, 141, 171, 89, 127, 21, 51, 236, 202, 160, 134, 116, 82, 56, 30, 155, 189, 215, 241, 3, 37, 79, 105, 182, 144, 250, 220, 46, 8, 98, 68, 234, 204, 166, 128, 114, 84, 62, 24, 199, 225, 139, 173, 95, 121, 19, 53, 176, 150, 252, 218, 40, 14, 100, 66, 157, 187, 209, 247, 5, 35, 73, 111, 94, 120, 18, 52, 198, 224, 138, 172, 115, 85, 63, 25, 235, 205, 167, 129, 4, 34, 72, 110, 156, 186, 208, 246, 41, 15, 101, 67, 177, 151, 253, 219, 159, 185, 211, 245, 7, 33, 75, 109, 178, 148, 254, 216, 42, 12, 102, 64, 197, 227, 137, 175, 93, 123, 17, 55, 232, 206, 164, 130, 112, 86, 60, 26, 43, 13, 103, 65, 179, 149, 255, 217, 6, 32, 74, 108, 158, 184, 210, 244, 113, 87, 61, 27, 233, 207, 165, 131, 92, 122, 16, 54, 196, 226, 136, 174, ],
[0, 39, 78, 105, 156, 187, 210, 245, 37, 2, 107, 76, 185, 158, 247, 208, 74, 109, 4, 35, 214, 241, 152, 191, 111, 72, 33, 6, 243, 212, 189, 154, 148, 179, 218, 253, 8, 47, 70, 97, 177, 150, 255, 216, 45, 10, 99, 68, 222, 249, 144, 183, 66, 101, 12, 43, 251, 220, 181, 146, 103, 64, 41, 14, 53, 18, 123, 92, 169, 142, 231, 192, 16, 55, 94, 121, 140, 171, 194, 229, 127, 88, 49, 22, 227, 196, 173, 138, 90, 125, 20, 51, 198, 225, 136, 175, 161, 134, 239, 200, 61, 26, 115, 84, 132, 163, 202, 237, 24, 63, 86, 113, 235, 204, 165, 130, 119, 80, 57, 30, 206, 233, 128, 167, 82, 117, 28, 59, 106, 77, 36, 3, 246, 209, 184, 159, 79, 104, 1, 38, 211, 244, 157, 186, 32, 7, 110, 73, 188, 155, 242, 213, 5, 34, 75, 108, 153, 190, 215, 240, 254, 217, 176, 151, 98, 69, 44, 11, 219, 252, 149, 178, 71, 96, 9, 46, 180, 147, 250, 221, 40, 15, 102, 65, 145, 182, 223, 248, 13, 42, 67, 100, 95, 120, 17, 54, 195, 228, 141, 170, 122, 93, 52, 19, 230, 193, 168, 143, 21, 50, 91, 124, 137, 174, 199, 224, 48, 23, 126, 89, 172, 139, 226, 197, 203, 236, 133, 162, 87, 112, 25, 62, 238, 201, 160, 135, 114, 85, 60, 27, 129, 166, 207, 232, 29, 58, 83, 116, 164, 131, 234, 205, 56, 31, 118, 81, ],
[0, 40, 80, 120, 160, 136, 240, 216, 93, 117, 13, 37, 253, 213, 173, 133, 186, 146, 234, 194, 26, 50, 74, 98, 231, 207, 183, 159, 71, 111, 23, 63, 105, 65, 57, 17, 201, 225, 153, 177, 52, 28, 100, 76, 148, 188, 196, 236, 211, 251, 131, 171, 115, 91, 35, 11, 142, 166, 222, 246, 46, 6, 126, 86, 210, 250, 130, 170, 114, 90, 34, 10, 143, 167, 223, 247, 47, 7, 127, 87, 104, 64, 56, 16, 200, 224, 152, 176, 53, 29, 101, 77, 149, 189, 197, 237, 187, 147, 235, 195, 27, 51, 75, 99, 230, 206, 182, 158, 70, 110, 22, 62, 1, 41, 81, 121, 161, 137, 241, 217, 92, 116, 12, 36, 252, 212, 172, 132, 185, 145, 233, 193, 25, 49, 73, 97, 228, 204, 180, 156, 68, 108, 20, 60, 3, 43, 83, 123, 163, 139, 243, 219, 94, 118, 14, 38, 254, 214, 174, 134, 208, 248, 128, 168, 112, 88, 32, 8, 141, 165, 221, 245, 45, 5, 125, 85, 106, 66, 58, 18, 202, 226, 154, 178, 55, 31, 103, 79, 151, 191, 199, 239, 107, 67, 59, 19, 203, 227, 155, 179, 54, 30, 102, 78, 150, 190, 198, 238, 209, 249, 129, 169, 113, 89, 33, 9, 140, 164, 220, 244, 44, 4, 124, 84, 2, 42, 82, 122, 162, 138, 242, 218, 95, 119, 15, 39, 255, 215, 175, 135, 184, 144, 232, 192, 24, 48, 72, 96, 229, 205, 181, 157, 69, 109, 21, 61, ],
[0, 41, 82, 123, 164, 141, 246, 223, 85, 124, 7, 46, 241, 216, 163, 138, 170, 131, 248, 209, 14, 39, 92, 117, 255, 214, 173, 132, 91, 114, 9, 32, 73, 96, 27, 50, 237, 196, 191, 150, 28, 53, 78, 103, 184, 145, 234, 195, 227, 202, 177, 152, 71, 110, 21, 60, 182, 159, 228, 205, 18, 59, 64, 105, 146, 187, 192, 233, 54, 31, 100, 77, 199, 238, 149, 188, 99, 74, 49, 24, 56, 17, 106, 67, 156, 181, 206, 231, 109, 68, 63, 22, 201, 224, 155, 178, 219, 242, 137, 160, 127, 86, 45, 4, 142, 167, 220, 245, 42, 3, 120, 81, 113, 88, 35, 10, 213, 252, 135, 174, 36, 13, 118, 95, 128, 169, 210, 251, 57, 16, 107, 66, 157, 180, 207, 230, 108, 69, 62, 23, 200, 225, 154, 179, 147, 186, 193, 232, 55, 30, 101, 76, 198, 239, 148, 189, 98, 75, 48, 25, 112, 89, 34, 11, 212, 253, 134, 175, 37, 12, 119, 94, 129, 168, 211, 250, 218, 243, 136, 161, 126, 87, 44, 5, 143, 166, 221, 244, 43, 2, 121, 80, 171, 130, 249, 208, 15, 38, 93, 116, 254, 215, 172, 133, 90, 115, 8, 33, 1, 40, 83, 122, 165, 140, 247, 222, 84, 125, 6, 47, 240, 217, 162, 139, 226, 203, 176, 153, 70, 111, 20, 61, 183, 158, 229, 204, 19, 58, 65, 104, 72, 97, 26, 51, 236, 197, 190, 151, 29, 52, 79, 102, 185, 144, 235, 194, ],
[0, 42, 84, 126, 168, 130, 252, 214, 77, 103, 25, 51, 229, 207, 177, 155, 154, 176, 206, 228, 50, 24, 102, 76, 215, 253, 131, 169, 127, 85, 43, 1, 41, 3, 125, 87, 129, 171, 213, 255, 100, 78, 48, 26, 204, 230, 152, 178, 179, 153, 231, 205, 27, 49, 79, 101, 254, 212, 170, 128, 86, 124, 2, 40, 82, 120, 6, 44, 250, 208, 174, 132, 31, 53, 75, 97, 183, 157, 227, 201, 200, 226, 156, 182, 96, 74, 52, 30, 133, 175, 209, 251, 45, 7, 121, 83, 123, 81, 47, 5, 211, 249, 135, 173, 54, 28, 98, 72, 158, 180, 202, 224, 225, 203, 181, 159, 73, 99, 29, 55, 172, 134, 248, 210, 4, 46, 80, 122, 164, 142, 240, 218, 12, 38, 88, 114, 233, 195, 189, 151, 65, 107, 21, 63, 62, 20, 106, 64, 150, 188, 194, 232, 115, 89, 39, 13, 219, 241, 143, 165, 141, 167, 217, 243, 37, 15, 113, 91, 192, 234, 148, 190, 104, 66, 60, 22, 23, 61, 67, 105, 191, 149, 235, 193, 90, 112, 14, 36, 242, 216, 166, 140, 246, 220, 162, 136, 94, 116, 10, 32, 187, 145, 239, 197, 19, 57, 71, 109, 108, 70, 56, 18, 196, 238, 144, 186, 33, 11, 117, 95, 137, 163, 221, 247, 223, 245, 139, 161, 119, 93, 35, 9, 146, 184, 198, 236, 58, 16, 110, 68, 69, 111, 17, 59, 237, 199, 185, 147, 8, 34, 92, 118, 160, 138, 244, 222, ],
[0, 43, 86, 125, 172, 135, 250, 209, 69, 110, 19, 56, 233, 194, 191, 148, 138, 161, 220, 247, 38, 13, 112, 91, 207, 228, 153, 178, 99, 72, 53, 30, 9, 34, 95, 116, 165, 142, 243, 216, 76, 103, 26, 49, 224, 203, 182, 157, 131, 168, 213, 254, 47, 4, 121, 82, 198, 237, 144, 187, 106, 65, 60, 23, 18, 57, 68, 111, 190, 149, 232, 195, 87, 124, 1, 42, 251, 208, 173, 134, 152, 179, 206, 229, 52, 31, 98, 73, 221, 246, 139, 160, 113, 90, 39, 12, 27, 48, 77, 102, 183, 156, 225, 202, 94, 117, 8, 35, 242, 217, 164, 143, 145, 186, 199, 236, 61, 22, 107, 64, 212, 255, 130, 169, 120, 83, 46, 5, 36, 15, 114, 89, 136, 163, 222, 245, 97, 74, 55, 28, 205, 230, 155, 176, 174, 133, 248, 211, 2, 41, 84, 127, 235, 192, 189, 150, 71, 108, 17, 58, 45, 6, 123, 80, 129, 170, 215, 252, 104, 67, 62, 21, 196, 239, 146, 185, 167, 140, 241, 218, 11, 32, 93, 118, 226, 201, 180, 159, 78, 101, 24, 51, 54, 29, 96, 75, 154, 177, 204, 231, 115, 88, 37, 14, 223, 244, 137, 162, 188, 151, 234, 193, 16, 59, 70, 109, 249, 210, 175, 132, 85, 126, 3, 40, 63, 20, 105, 66, 147, 184, 197, 238, 122, 81, 44, 7, 214, 253, 128, 171, 181, 158, 227, 200, 25, 50, 79, 100, 240, 219, 166, 141, 92, 119, 10, 33, ],
[0, 44, 88, 116, 176, 156, 232, 196, 125, 81, 37, 9, 205, 225, 149, 185, 250, 214, 162, 142, 74, 102, 18, 62, 135, 171, 223, 243, 55, 27, 111, 67, 233, 197, 177, 157, 89, 117, 1, 45, 148, 184, 204, 224, 36, 8, 124, 80, 19, 63, 75, 103, 163, 143, 251, 215, 110, 66, 54, 26, 222, 242, 134, 170, 207, 227, 151, 187, 127, 83, 39, 11, 178, 158, 234, 198, 2, 46, 90, 118, 53, 25, 109, 65, 133, 169, 221, 241, 72, 100, 16, 60, 248, 212, 160, 140, 38, 10, 126, 82, 150, 186, 206, 226, 91, 119, 3, 47, 235, 199, 179, 159, 220, 240, 132, 168, 108, 64, 52, 24, 161, 141, 249, 213, 17, 61, 73, 101, 131, 175, 219, 247, 51, 31, 107, 71, 254, 210, 166, 138, 78, 98, 22, 58, 121, 85, 33, 13, 201, 229, 145, 189, 4, 40, 92, 112, 180, 152, 236, 192, 106, 70, 50, 30, 218, 246, 130, 174, 23, 59, 79, 99, 167, 139, 255, 211, 144, 188, 200, 228, 32, 12, 120, 84, 237, 193, 181, 153, 93, 113, 5, 41, 76, 96, 20, 56, 252, 208, 164, 136, 49, 29, 105, 69, 129, 173, 217, 245, 182, 154, 238, 194, 6, 42, 94, 114, 203, 231, 147, 191, 123, 87, 35, 15, 165, 137, 253, 209, 21, 57, 77, 97, 216, 244, 128, 172, 104, 68, 48, 28, 95, 115, 7, 43, 239, 195, 183, 155, 34, 14, 122, 86, 146, 190, 202, 230, ],
[0, 45, 90, 119, 180, 153, 238, 195, 117, 88, 47, 2, 193, 236, 155, 182, 234, 199, 176, 157, 94, 115, 4, 41, 159, 178, 197, 232, 43, 6, 113, 92, 201, 228, 147, 190, 125, 80, 39, 10, 188, 145, 230, 203, 8, 37, 82, 127, 35, 14, 121, 84, 151, 186, 205, 224, 86, 123, 12, 33, 226, 207, 184, 149, 143, 162, 213, 248, 59, 22, 97, 76, 250, 215, 160, 141, 78, 99, 20, 57, 101, 72, 63, 18, 209, 252, 139, 166, 16, 61, 74, 103, 164, 137, 254, 211, 70, 107, 28, 49, 242, 223, 168, 133, 51, 30, 105, 68, 135, 170, 221, 240, 172, 129, 246, 219, 24, 53, 66, 111, 217, 244, 131, 174, 109, 64, 55, 26, 3, 46, 89, 116, 183, 154, 237, 192, 118, 91, 44, 1, 194, 239, 152, 181, 233, 196, 179, 158, 93, 112, 7, 42, 156, 177, 198, 235, 40, 5, 114, 95, 202, 231, 144, 189, 126, 83, 36, 9, 191, 146, 229, 200, 11, 38, 81, 124, 32, 13, 122, 87, 148, 185, 206, 227, 85, 120, 15, 34, 225, 204, 187, 150, 140, 161, 214, 251, 56, 21, 98, 79, 249, 212, 163, 142, 77, 96, 23, 58, 102, 75, 60, 17, 210, 255, 136, 165, 19, 62, 73, 100, 167, 138, 253, 208, 69, 104, 31, 50, 241, 220, 171, 134, 48, 29, 106, 71, 132, 169, 222, 243, 175, 130, 245, 216, 27, 54, 65, 108, 218, 247, 128, 173, 110, 67, 52, 25, ],
[0, 46, 92, 114, 184, 150, 228, 202, 109, 67, 49, 31, 213, 251, 137, 167, 218, 244, 134, 168, 98, 76, 62, 16, 183, 153, 235, 197, 15, 33, 83, 125, 169, 135, 245, 219, 17, 63, 77, 99, 196, 234, 152, 182, 124, 82, 32, 14, 115, 93, 47, 1, 203, 229, 151, 185, 30, 48, 66, 108, 166, 136, 250, 212, 79, 97, 19, 61, 247, 217, 171, 133, 34, 12, 126, 80, 154, 180, 198, 232, 149, 187, 201, 231, 45, 3, 113, 95, 248, 214, 164, 138, 64, 110, 28, 50, 230, 200, 186, 148, 94, 112, 2, 44, 139, 165, 215, 249, 51, 29, 111, 65, 60, 18, 96, 78, 132, 170, 216, 246, 81, 127, 13, 35, 233, 199, 181, 155, 158, 176, 194, 236, 38, 8, 122, 84, 243, 221, 175, 129, 75, 101, 23, 57, 68, 106, 24, 54, 252, 210, 160, 142, 41, 7, 117, 91, 145, 191, 205, 227, 55, 25, 107, 69, 143, 161, 211, 253, 90, 116, 6, 40, 226, 204, 190, 144, 237, 195, 177, 159, 85, 123, 9, 39, 128, 174, 220, 242, 56, 22, 100, 74, 209, 255, 141, 163, 105, 71, 53, 27, 188, 146, 224, 206, 4, 42, 88, 118, 11, 37, 87, 121, 179, 157, 239, 193, 102, 72, 58, 20, 222, 240, 130, 172, 120, 86, 36, 10, 192, 238, 156, 178, 21, 59, 73, 103, 173, 131, 241, 223, 162, 140, 254, 208, 26, 52, 70, 104, 207, 225, 147, 189, 119, 89, 43, 5, ],
[0, 47, 94, 113, 188, 147, 226, 205, 101, 74, 59, 20, 217, 246, 135, 168, 202, 229, 148, 187, 118, 89, 40, 7, 175, 128, 241, 222, 19, 60, 77, 98, 137, 166, 215, 248, 53, 26, 107, 68, 236, 195, 178, 157, 80, 127, 14, 33, 67, 108, 29, 50, 255, 208, 161, 142, 38, 9, 120, 87, 154, 181, 196, 235, 15, 32, 81, 126, 179, 156, 237, 194, 106, 69, 52, 27, 214, 249, 136, 167, 197, 234, 155, 180, 121, 86, 39, 8, 160, 143, 254, 209, 28, 51, 66, 109, 134, 169, 216, 247, 58, 21, 100, 75, 227, 204, 189, 146, 95, 112, 1, 46, 76, 99, 18, 61, 240, 223, 174, 129, 41, 6, 119, 88, 149, 186, 203, 228, 30, 49, 64, 111, 162, 141, 252, 211, 123, 84, 37, 10, 199, 232, 153, 182, 212, 251, 138, 165, 104, 71, 54, 25, 177, 158, 239, 192, 13, 34, 83, 124, 151, 184, 201, 230, 43, 4, 117, 90, 242, 221, 172, 131, 78, 97, 16, 63, 93, 114, 3, 44, 225, 206, 191, 144, 56, 23, 102, 73, 132, 171, 218, 245, 17, 62, 79, 96, 173, 130, 243, 220, 116, 91, 42, 5, 200, 231, 150, 185, 219, 244, 133, 170, 103, 72, 57, 22, 190, 145, 224, 207, 2, 45, 92, 115, 152, 183, 198, 233, 36, 11, 122, 85, 253, 210, 163, 140, 65, 110, 31, 48, 82, 125, 12, 35, 238, 193, 176, 159, 55, 24, 105, 70, 139, 164, 213, 250, ],
[0, 48, 96, 80, 192, 240, 160, 144, 157, 173, 253, 205, 93, 109, 61, 13, 39, 23, 71, 119, 231, 215, 135, 183, 186, 138, 218, 234, 122, 74, 26, 42, 78, 126, 46, 30, 142, 190, 238, 222, 211, 227, 179, 131, 19, 35, 115, 67, 105, 89, 9, 57, 169, 153, 201, 249, 244, 196, 148, 164, 52, 4, 84, 100, 156, 172, 252, 204, 92, 108, 60, 12, 1, 49, 97, 81, 193, 241, 161, 145, 187, 139, 219, 235, 123, 75, 27, 43, 38, 22, 70, 118, 230, 214, 134, 182, 210, 226, 178, 130, 18, 34, 114, 66, 79, 127, 47, 31, 143, 191, 239, 223, 245, 197, 149, 165, 53, 5, 85, 101, 104, 88, 8, 56, 168, 152, 200, 248, 37, 21, 69, 117, 229, 213, 133, 181, 184, 136, 216, 232, 120, 72, 24, 40, 2, 50, 98, 82, 194, 242, 162, 146, 159, 175, 255, 207, 95, 111, 63, 15, 107, 91, 11, 59, 171, 155, 203, 251, 246, 198, 150, 166, 54, 6, 86, 102, 76, 124, 44, 28, 140, 188, 236, 220, 209, 225, 177, 129, 17, 33, 113, 65, 185, 137, 217, 233, 121, 73, 25, 41, 36, 20, 68, 116, 228, 212, 132, 180, 158, 174, 254, 206, 94, 110, 62, 14, 3, 51, 99, 83, 195, 243, 163, 147, 247, 199, 151, 167, 55, 7, 87, 103, 106, 90, 10, 58, 170, 154, 202, 250, 208, 224, 176, 128, 16, 32, 112, 64, 77, 125, 45, 29, 141, 189, 237, 221, ],
[0, 49, 98, 83, 196, 245, 166, 151, 149, 164, 247, 198, 81, 96, 51, 2, 55, 6, 85, 100, 243, 194, 145, 160, 162, 147, 192, 241, 102, 87, 4, 53, 110, 95, 12, 61, 170, 155, 200, 249, 251, 202, 153, 168, 63, 14, 93, 108, 89, 104, 59, 10, 157, 172, 255, 206, 204, 253, 174, 159, 8, 57, 106, 91, 220, 237, 190, 143, 24, 41, 122, 75, 73, 120, 43, 26, 141, 188, 239, 222, 235, 218, 137, 184, 47, 30, 77, 124, 126, 79, 28, 45, 186, 139, 216, 233, 178, 131, 208, 225, 118, 71, 20, 37, 39, 22, 69, 116, 227, 210, 129, 176, 133, 180, 231, 214, 65, 112, 35, 18, 16, 33, 114, 67, 212, 229, 182, 135, 165, 148, 199, 246, 97, 80, 3, 50, 48, 1, 82, 99, 244, 197, 150, 167, 146, 163, 240, 193, 86, 103, 52, 5, 7, 54, 101, 84, 195, 242, 161, 144, 203, 250, 169, 152, 15, 62, 109, 92, 94, 111, 60, 13, 154, 171, 248, 201, 252, 205, 158, 175, 56, 9, 90, 107, 105, 88, 11, 58, 173, 156, 207, 254, 121, 72, 27, 42, 189, 140, 223, 238, 236, 221, 142, 191, 40, 25, 74, 123, 78, 127, 44, 29, 138, 187, 232, 217, 219, 234, 185, 136, 31, 46, 125, 76, 23, 38, 117, 68, 211, 226, 177, 128, 130, 179, 224, 209, 70, 119, 36, 21, 32, 17, 66, 115, 228, 213, 134, 183, 181, 132, 215, 230, 113, 64, 19, 34, ],
[0, 50, 100, 86, 200, 250, 172, 158, 141, 191, 233, 219, 69, 119, 33, 19, 7, 53, 99, 81, 207, 253, 171, 153, 138, 184, 238, 220, 66, 112, 38, 20, 14, 60, 106, 88, 198, 244, 162, 144, 131, 177, 231, 213, 75, 121, 47, 29, 9, 59, 109, 95, 193, 243, 165, 151, 132, 182, 224, 210, 76, 126, 40, 26, 28, 46, 120, 74, 212, 230, 176, 130, 145, 163, 245, 199, 89, 107, 61, 15, 27, 41, 127, 77, 211, 225, 183, 133, 150, 164, 242, 192, 94, 108, 58, 8, 18, 32, 118, 68, 218, 232, 190, 140, 159, 173, 251, 201, 87, 101, 51, 1, 21, 39, 113, 67, 221, 239, 185, 139, 152, 170, 252, 206, 80, 98, 52, 6, 56, 10, 92, 110, 240, 194, 148, 166, 181, 135, 209, 227, 125, 79, 25, 43, 63, 13, 91, 105, 247, 197, 147, 161, 178, 128, 214, 228, 122, 72, 30, 44, 54, 4, 82, 96, 254, 204, 154, 168, 187, 137, 223, 237, 115, 65, 23, 37, 49, 3, 85, 103, 249, 203, 157, 175, 188, 142, 216, 234, 116, 70, 16, 34, 36, 22, 64, 114, 236, 222, 136, 186, 169, 155, 205, 255, 97, 83, 5, 55, 35, 17, 71, 117, 235, 217, 143, 189, 174, 156, 202, 248, 102, 84, 2, 48, 42, 24, 78, 124, 226, 208, 134, 180, 167, 149, 195, 241, 111, 93, 11, 57, 45, 31, 73, 123, 229, 215, 129, 179, 160, 146, 196, 246, 104, 90, 12, 62, ],
[0, 51, 102, 85, 204, 255, 170, 153, 133, 182, 227, 208, 73, 122, 47, 28, 23, 36, 113, 66, 219, 232, 189, 142, 146, 161, 244, 199, 94, 109, 56, 11, 46, 29, 72, 123, 226, 209, 132, 183, 171, 152, 205, 254, 103, 84, 1, 50, 57, 10, 95, 108, 245, 198, 147, 160, 188, 143, 218, 233, 112, 67, 22, 37, 92, 111, 58, 9, 144, 163, 246, 197, 217, 234, 191, 140, 21, 38, 115, 64, 75, 120, 45, 30, 135, 180, 225, 210, 206, 253, 168, 155, 2, 49, 100, 87, 114, 65, 20, 39, 190, 141, 216, 235, 247, 196, 145, 162, 59, 8, 93, 110, 101, 86, 3, 48, 169, 154, 207, 252, 224, 211, 134, 181, 44, 31, 74, 121, 184, 139, 222, 237, 116, 71, 18, 33, 61, 14, 91, 104, 241, 194, 151, 164, 175, 156, 201, 250, 99, 80, 5, 54, 42, 25, 76, 127, 230, 213, 128, 179, 150, 165, 240, 195, 90, 105, 60, 15, 19, 32, 117, 70, 223, 236, 185, 138, 129, 178, 231, 212, 77, 126, 43, 24, 4, 55, 98, 81, 200, 251, 174, 157, 228, 215, 130, 177, 40, 27, 78, 125, 97, 82, 7, 52, 173, 158, 203, 248, 243, 192, 149, 166, 63, 12, 89, 106, 118, 69, 16, 35, 186, 137, 220, 239, 202, 249, 172, 159, 6, 53, 96, 83, 79, 124, 41, 26, 131, 176, 229, 214, 221, 238, 187, 136, 17, 34, 119, 68, 88, 107, 62, 13, 148, 167, 242, 193, ],
[0, 52, 104, 92, 208, 228, 184, 140, 189, 137, 213, 225, 109, 89, 5, 49, 103, 83, 15, 59, 183, 131, 223, 235, 218, 238, 178, 134, 10, 62, 98, 86, 206, 250, 166, 146, 30, 42, 118, 66, 115, 71, 27, 47, 163, 151, 203, 255, 169, 157, 193, 245, 121, 77, 17, 37, 20, 32, 124, 72, 196, 240, 172, 152, 129, 181, 233, 221, 81, 101, 57, 13, 60, 8, 84, 96, 236, 216, 132, 176, 230, 210, 142, 186, 54, 2, 94, 106, 91, 111, 51, 7, 139, 191, 227, 215, 79, 123, 39, 19, 159, 171, 247, 195, 242, 198, 154, 174, 34, 22, 74, 126, 40, 28, 64, 116, 248, 204, 144, 164, 149, 161, 253, 201, 69, 113, 45, 25, 31, 43, 119, 67, 207, 251, 167, 147, 162, 150, 202, 254, 114, 70, 26, 46, 120, 76, 16, 36, 168, 156, 192, 244, 197, 241, 173, 153, 21, 33, 125, 73, 209, 229, 185, 141, 1, 53, 105, 93, 108, 88, 4, 48, 188, 136, 212, 224, 182, 130, 222, 234, 102, 82, 14, 58, 11, 63, 99, 87, 219, 239, 179, 135, 158, 170, 246, 194, 78, 122, 38, 18, 35, 23, 75, 127, 243, 199, 155, 175, 249, 205, 145, 165, 41, 29, 65, 117, 68, 112, 44, 24, 148, 160, 252, 200, 80, 100, 56, 12, 128, 180, 232, 220, 237, 217, 133, 177, 61, 9, 85, 97, 55, 3, 95, 107, 231, 211, 143, 187, 138, 190, 226, 214, 90, 110, 50, 6, ],
[0, 53, 106, 95, 212, 225, 190, 139, 181, 128, 223, 234, 97, 84, 11, 62, 119, 66, 29, 40, 163, 150, 201, 252, 194, 247, 168, 157, 22, 35, 124, 73, 238, 219, 132, 177, 58, 15, 80, 101, 91, 110, 49, 4, 143, 186, 229, 208, 153, 172, 243, 198, 77, 120, 39, 18, 44, 25, 70, 115, 248, 205, 146, 167, 193, 244, 171, 158, 21, 32, 127, 74, 116, 65, 30, 43, 160, 149, 202, 255, 182, 131, 220, 233, 98, 87, 8, 61, 3, 54, 105, 92, 215, 226, 189, 136, 47, 26, 69, 112, 251, 206, 145, 164, 154, 175, 240, 197, 78, 123, 36, 17, 88, 109, 50, 7, 140, 185, 230, 211, 237, 216, 135, 178, 57, 12, 83, 102, 159, 170, 245, 192, 75, 126, 33, 20, 42, 31, 64, 117, 254, 203, 148, 161, 232, 221, 130, 183, 60, 9, 86, 99, 93, 104, 55, 2, 137, 188, 227, 214, 113, 68, 27, 46, 165, 144, 207, 250, 196, 241, 174, 155, 16, 37, 122, 79, 6, 51, 108, 89, 210, 231, 184, 141, 179, 134, 217, 236, 103, 82, 13, 56, 94, 107, 52, 1, 138, 191, 224, 213, 235, 222, 129, 180, 63, 10, 85, 96, 41, 28, 67, 118, 253, 200, 151, 162, 156, 169, 246, 195, 72, 125, 34, 23, 176, 133, 218, 239, 100, 81, 14, 59, 5, 48, 111, 90, 209, 228, 187, 142, 199, 242, 173, 152, 19, 38, 121, 76, 114, 71, 24, 45, 166, 147, 204, 249, ],
[0, 54, 108, 90, 216, 238, 180, 130, 173, 155, 193, 247, 117, 67, 25, 47, 71, 113, 43, 29, 159, 169, 243, 197, 234, 220, 134, 176, 50, 4, 94, 104, 142, 184, 226, 212, 86, 96, 58, 12, 35, 21, 79, 121, 251, 205, 151, 161, 201, 255, 165, 147, 17, 39, 125, 75, 100, 82, 8, 62, 188, 138, 208, 230, 1, 55, 109, 91, 217, 239, 181, 131, 172, 154, 192, 246, 116, 66, 24, 46, 70, 112, 42, 28, 158, 168, 242, 196, 235, 221, 135, 177, 51, 5, 95, 105, 143, 185, 227, 213, 87, 97, 59, 13, 34, 20, 78, 120, 250, 204, 150, 160, 200, 254, 164, 146, 16, 38, 124, 74, 101, 83, 9, 63, 189, 139, 209, 231, 2, 52, 110, 88, 218, 236, 182, 128, 175, 153, 195, 245, 119, 65, 27, 45, 69, 115, 41, 31, 157, 171, 241, 199, 232, 222, 132, 178, 48, 6, 92, 106, 140, 186, 224, 214, 84, 98, 56, 14, 33, 23, 77, 123, 249, 207, 149, 163, 203, 253, 167, 145, 19, 37, 127, 73, 102, 80, 10, 60, 190, 136, 210, 228, 3, 53, 111, 89, 219, 237, 183, 129, 174, 152, 194, 244, 118, 64, 26, 44, 68, 114, 40, 30, 156, 170, 240, 198, 233, 223, 133, 179, 49, 7, 93, 107, 141, 187, 225, 215, 85, 99, 57, 15, 32, 22, 76, 122, 248, 206, 148, 162, 202, 252, 166, 144, 18, 36, 126, 72, 103, 81, 11, 61, 191, 137, 211, 229, ],
[0, 55, 110, 89, 220, 235, 178, 133, 165, 146, 203, 252, 121, 78, 23, 32, 87, 96, 57, 14, 139, 188, 229, 210, 242, 197, 156, 171, 46, 25, 64, 119, 174, 153, 192, 247, 114, 69, 28, 43, 11, 60, 101, 82, 215, 224, 185, 142, 249, 206, 151, 160, 37, 18, 75, 124, 92, 107, 50, 5, 128, 183, 238, 217, 65, 118, 47, 24, 157, 170, 243, 196, 228, 211, 138, 189, 56, 15, 86, 97, 22, 33, 120, 79, 202, 253, 164, 147, 179, 132, 221, 234, 111, 88, 1, 54, 239, 216, 129, 182, 51, 4, 93, 106, 74, 125, 36, 19, 150, 161, 248, 207, 184, 143, 214, 225, 100, 83, 10, 61, 29, 42, 115, 68, 193, 246, 175, 152, 130, 181, 236, 219, 94, 105, 48, 7, 39, 16, 73, 126, 251, 204, 149, 162, 213, 226, 187, 140, 9, 62, 103, 80, 112, 71, 30, 41, 172, 155, 194, 245, 44, 27, 66, 117, 240, 199, 158, 169, 137, 190, 231, 208, 85, 98, 59, 12, 123, 76, 21, 34, 167, 144, 201, 254, 222, 233, 176, 135, 2, 53, 108, 91, 195, 244, 173, 154, 31, 40, 113, 70, 102, 81, 8, 63, 186, 141, 212, 227, 148, 163, 250, 205, 72, 127, 38, 17, 49, 6, 95, 104, 237, 218, 131, 180, 109, 90, 3, 52, 177, 134, 223, 232, 200, 255, 166, 145, 20, 35, 122, 77, 58, 13, 84, 99, 230, 209, 136, 191, 159, 168, 241, 198, 67, 116, 45, 26, ],
[0, 56, 112, 72, 224, 216, 144, 168, 221, 229, 173, 149, 61, 5, 77, 117, 167, 159, 215, 239, 71, 127, 55, 15, 122, 66, 10, 50, 154, 162, 234, 210, 83, 107, 35, 27, 179, 139, 195, 251, 142, 182, 254, 198, 110, 86, 30, 38, 244, 204, 132, 188, 20, 44, 100, 92, 41, 17, 89, 97, 201, 241, 185, 129, 166, 158, 214, 238, 70, 126, 54, 14, 123, 67, 11, 51, 155, 163, 235, 211, 1, 57, 113, 73, 225, 217, 145, 169, 220, 228, 172, 148, 60, 4, 76, 116, 245, 205, 133, 189, 21, 45, 101, 93, 40, 16, 88, 96, 200, 240, 184, 128, 82, 106, 34, 26, 178, 138, 194, 250, 143, 183, 255, 199, 111, 87, 31, 39, 81, 105, 33, 25, 177, 137, 193, 249, 140, 180, 252, 196, 108, 84, 28, 36, 246, 206, 134, 190, 22, 46, 102, 94, 43, 19, 91, 99, 203, 243, 187, 131, 2, 58, 114, 74, 226, 218, 146, 170, 223, 231, 175, 151, 63, 7, 79, 119, 165, 157, 213, 237, 69, 125, 53, 13, 120, 64, 8, 48, 152, 160, 232, 208, 247, 207, 135, 191, 23, 47, 103, 95, 42, 18, 90, 98, 202, 242, 186, 130, 80, 104, 32, 24, 176, 136, 192, 248, 141, 181, 253, 197, 109, 85, 29, 37, 164, 156, 212, 236, 68, 124, 52, 12, 121, 65, 9, 49, 153, 161, 233, 209, 3, 59, 115, 75, 227, 219, 147, 171, 222, 230, 174, 150, 62, 6, 78, 118, ],
[0, 57, 114, 75, 228, 221, 150, 175, 213, 236, 167, 158, 49, 8, 67, 122, 183, 142, 197, 252, 83, 106, 33, 24, 98, 91, 16, 41, 134, 191, 244, 205, 115, 74, 1, 56, 151, 174, 229, 220, 166, 159, 212, 237, 66, 123, 48, 9, 196, 253, 182, 143, 32, 25, 82, 107, 17, 40, 99, 90, 245, 204, 135, 190, 230, 223, 148, 173, 2, 59, 112, 73, 51, 10, 65, 120, 215, 238, 165, 156, 81, 104, 35, 26, 181, 140, 199, 254, 132, 189, 246, 207, 96, 89, 18, 43, 149, 172, 231, 222, 113, 72, 3, 58, 64, 121, 50, 11, 164, 157, 214, 239, 34, 27, 80, 105, 198, 255, 180, 141, 247, 206, 133, 188, 19, 42, 97, 88, 209, 232, 163, 154, 53, 12, 71, 126, 4, 61, 118, 79, 224, 217, 146, 171, 102, 95, 20, 45, 130, 187, 240, 201, 179, 138, 193, 248, 87, 110, 37, 28, 162, 155, 208, 233, 70, 127, 52, 13, 119, 78, 5, 60, 147, 170, 225, 216, 21, 44, 103, 94, 241, 200, 131, 186, 192, 249, 178, 139, 36, 29, 86, 111, 55, 14, 69, 124, 211, 234, 161, 152, 226, 219, 144, 169, 6, 63, 116, 77, 128, 185, 242, 203, 100, 93, 22, 47, 85, 108, 39, 30, 177, 136, 195, 250, 68, 125, 54, 15, 160, 153, 210, 235, 145, 168, 227, 218, 117, 76, 7, 62, 243, 202, 129, 184, 23, 46, 101, 92, 38, 31, 84, 109, 194, 251, 176, 137, ],
[0, 58, 116, 78, 232, 210, 156, 166, 205, 247, 185, 131, 37, 31, 81, 107, 135, 189, 243, 201, 111, 85, 27, 33, 74, 112, 62, 4, 162, 152, 214, 236, 19, 41, 103, 93, 251, 193, 143, 181, 222, 228, 170, 144, 54, 12, 66, 120, 148, 174, 224, 218, 124, 70, 8, 50, 89, 99, 45, 23, 177, 139, 197, 255, 38, 28, 82, 104, 206, 244, 186, 128, 235, 209, 159, 165, 3, 57, 119, 77, 161, 155, 213, 239, 73, 115, 61, 7, 108, 86, 24, 34, 132, 190, 240, 202, 53, 15, 65, 123, 221, 231, 169, 147, 248, 194, 140, 182, 16, 42, 100, 94, 178, 136, 198, 252, 90, 96, 46, 20, 127, 69, 11, 49, 151, 173, 227, 217, 76, 118, 56, 2, 164, 158, 208, 234, 129, 187, 245, 207, 105, 83, 29, 39, 203, 241, 191, 133, 35, 25, 87, 109, 6, 60, 114, 72, 238, 212, 154, 160, 95, 101, 43, 17, 183, 141, 195, 249, 146, 168, 230, 220, 122, 64, 14, 52, 216, 226, 172, 150, 48, 10, 68, 126, 21, 47, 97, 91, 253, 199, 137, 179, 106, 80, 30, 36, 130, 184, 246, 204, 167, 157, 211, 233, 79, 117, 59, 1, 237, 215, 153, 163, 5, 63, 113, 75, 32, 26, 84, 110, 200, 242, 188, 134, 121, 67, 13, 55, 145, 171, 229, 223, 180, 142, 192, 250, 92, 102, 40, 18, 254, 196, 138, 176, 22, 44, 98, 88, 51, 9, 71, 125, 219, 225, 175, 149, ],
[0, 59, 118, 77, 236, 215, 154, 161, 197, 254, 179, 136, 41, 18, 95, 100, 151, 172, 225, 218, 123, 64, 13, 54, 82, 105, 36, 31, 190, 133, 200, 243, 51, 8, 69, 126, 223, 228, 169, 146, 246, 205, 128, 187, 26, 33, 108, 87, 164, 159, 210, 233, 72, 115, 62, 5, 97, 90, 23, 44, 141, 182, 251, 192, 102, 93, 16, 43, 138, 177, 252, 199, 163, 152, 213, 238, 79, 116, 57, 2, 241, 202, 135, 188, 29, 38, 107, 80, 52, 15, 66, 121, 216, 227, 174, 149, 85, 110, 35, 24, 185, 130, 207, 244, 144, 171, 230, 221, 124, 71, 10, 49, 194, 249, 180, 143, 46, 21, 88, 99, 7, 60, 113, 74, 235, 208, 157, 166, 204, 247, 186, 129, 32, 27, 86, 109, 9, 50, 127, 68, 229, 222, 147, 168, 91, 96, 45, 22, 183, 140, 193, 250, 158, 165, 232, 211, 114, 73, 4, 63, 255, 196, 137, 178, 19, 40, 101, 94, 58, 1, 76, 119, 214, 237, 160, 155, 104, 83, 30, 37, 132, 191, 242, 201, 173, 150, 219, 224, 65, 122, 55, 12, 170, 145, 220, 231, 70, 125, 48, 11, 111, 84, 25, 34, 131, 184, 245, 206, 61, 6, 75, 112, 209, 234, 167, 156, 248, 195, 142, 181, 20, 47, 98, 89, 153, 162, 239, 212, 117, 78, 3, 56, 92, 103, 42, 17, 176, 139, 198, 253, 14, 53, 120, 67, 226, 217, 148, 175, 203, 240, 189, 134, 39, 28, 81, 106, ],
[0, 60, 120, 68, 240, 204, 136, 180, 253, 193, 133, 185, 13, 49, 117, 73, 231, 219, 159, 163, 23, 43, 111, 83, 26, 38, 98, 94, 234, 214, 146, 174, 211, 239, 171, 151, 35, 31, 91, 103, 46, 18, 86, 106, 222, 226, 166, 154, 52, 8, 76, 112, 196, 248, 188, 128, 201, 245, 177, 141, 57, 5, 65, 125, 187, 135, 195, 255, 75, 119, 51, 15, 70, 122, 62, 2, 182, 138, 206, 242, 92, 96, 36, 24, 172, 144, 212, 232, 161, 157, 217, 229, 81, 109, 41, 21, 104, 84, 16, 44, 152, 164, 224, 220, 149, 169, 237, 209, 101, 89, 29, 33, 143, 179, 247, 203, 127, 67, 7, 59, 114, 78, 10, 54, 130, 190, 250, 198, 107, 87, 19, 47, 155, 167, 227, 223, 150, 170, 238, 210, 102, 90, 30, 34, 140, 176, 244, 200, 124, 64, 4, 56, 113, 77, 9, 53, 129, 189, 249, 197, 184, 132, 192, 252, 72, 116, 48, 12, 69, 121, 61, 1, 181, 137, 205, 241, 95, 99, 39, 27, 175, 147, 215, 235, 162, 158, 218, 230, 82, 110, 42, 22, 208, 236, 168, 148, 32, 28, 88, 100, 45, 17, 85, 105, 221, 225, 165, 153, 55, 11, 79, 115, 199, 251, 191, 131, 202, 246, 178, 142, 58, 6, 66, 126, 3, 63, 123, 71, 243, 207, 139, 183, 254, 194, 134, 186, 14, 50, 118, 74, 228, 216, 156, 160, 20, 40, 108, 80, 25, 37, 97, 93, 233, 213, 145, 173, ],
[0, 61, 122, 71, 244, 201, 142, 179, 245, 200, 143, 178, 1, 60, 123, 70, 247, 202, 141, 176, 3, 62, 121, 68, 2, 63, 120, 69, 246, 203, 140, 177, 243, 206, 137, 180, 7, 58, 125, 64, 6, 59, 124, 65, 242, 207, 136, 181, 4, 57, 126, 67, 240, 205, 138, 183, 241, 204, 139, 182, 5, 56, 127, 66, 251, 198, 129, 188, 15, 50, 117, 72, 14, 51, 116, 73, 250, 199, 128, 189, 12, 49, 118, 75, 248, 197, 130, 191, 249, 196, 131, 190, 13, 48, 119, 74, 8, 53, 114, 79, 252, 193, 134, 187, 253, 192, 135, 186, 9, 52, 115, 78, 255, 194, 133, 184, 11, 54, 113, 76, 10, 55, 112, 77, 254, 195, 132, 185, 235, 214, 145, 172, 31, 34, 101, 88, 30, 35, 100, 89, 234, 215, 144, 173, 28, 33, 102, 91, 232, 213, 146, 175, 233, 212, 147, 174, 29, 32, 103, 90, 24, 37, 98, 95, 236, 209, 150, 171, 237, 208, 151, 170, 25, 36, 99, 94, 239, 210, 149, 168, 27, 38, 97, 92, 26, 39, 96, 93, 238, 211, 148, 169, 16, 45, 106, 87, 228, 217, 158, 163, 229, 216, 159, 162, 17, 44, 107, 86, 231, 218, 157, 160, 19, 46, 105, 84, 18, 47, 104, 85, 230, 219, 156, 161, 227, 222, 153, 164, 23, 42, 109, 80, 22, 43, 108, 81, 226, 223, 152, 165, 20, 41, 110, 83, 224, 221, 154, 167, 225, 220, 155, 166, 21, 40, 111, 82, ],
[0, 62, 124, 66, 248, 198, 132, 186, 237, 211, 145, 175, 21, 43, 105, 87, 199, 249, 187, 133, 63, 1, 67, 125, 42, 20, 86, 104, 210, 236, 174, 144, 147, 173, 239, 209, 107, 85, 23, 41, 126, 64, 2, 60, 134, 184, 250, 196, 84, 106, 40, 22, 172, 146, 208, 238, 185, 135, 197, 251, 65, 127, 61, 3, 59, 5, 71, 121, 195, 253, 191, 129, 214, 232, 170, 148, 46, 16, 82, 108, 252, 194, 128, 190, 4, 58, 120, 70, 17, 47, 109, 83, 233, 215, 149, 171, 168, 150, 212, 234, 80, 110, 44, 18, 69, 123, 57, 7, 189, 131, 193, 255, 111, 81, 19, 45, 151, 169, 235, 213, 130, 188, 254, 192, 122, 68, 6, 56, 118, 72, 10, 52, 142, 176, 242, 204, 155, 165, 231, 217, 99, 93, 31, 33, 177, 143, 205, 243, 73, 119, 53, 11, 92, 98, 32, 30, 164, 154, 216, 230, 229, 219, 153, 167, 29, 35, 97, 95, 8, 54, 116, 74, 240, 206, 140, 178, 34, 28, 94, 96, 218, 228, 166, 152, 207, 241, 179, 141, 55, 9, 75, 117, 77, 115, 49, 15, 181, 139, 201, 247, 160, 158, 220, 226, 88, 102, 36, 26, 138, 180, 246, 200, 114, 76, 14, 48, 103, 89, 27, 37, 159, 161, 227, 221, 222, 224, 162, 156, 38, 24, 90, 100, 51, 13, 79, 113, 203, 245, 183, 137, 25, 39, 101, 91, 225, 223, 157, 163, 244, 202, 136, 182, 12, 50, 112, 78, ],
[0, 63, 126, 65, 252, 195, 130, 189, 229, 218, 155, 164, 25, 38, 103, 88, 215, 232, 169, 150, 43, 20, 85, 106, 50, 13, 76, 115, 206, 241, 176, 143, 179, 140, 205, 242, 79, 112, 49, 14, 86, 105, 40, 23, 170, 149, 212, 235, 100, 91, 26, 37, 152, 167, 230, 217, 129, 190, 255, 192, 125, 66, 3, 60, 123, 68, 5, 58, 135, 184, 249, 198, 158, 161, 224, 223, 98, 93, 28, 35, 172, 147, 210, 237, 80, 111, 46, 17, 73, 118, 55, 8, 181, 138, 203, 244, 200, 247, 182, 137, 52, 11, 74, 117, 45, 18, 83, 108, 209, 238, 175, 144, 31, 32, 97, 94, 227, 220, 157, 162, 250, 197, 132, 187, 6, 57, 120, 71, 246, 201, 136, 183, 10, 53, 116, 75, 19, 44, 109, 82, 239, 208, 145, 174, 33, 30, 95, 96, 221, 226, 163, 156, 196, 251, 186, 133, 56, 7, 70, 121, 69, 122, 59, 4, 185, 134, 199, 248, 160, 159, 222, 225, 92, 99, 34, 29, 146, 173, 236, 211, 110, 81, 16, 47, 119, 72, 9, 54, 139, 180, 245, 202, 141, 178, 243, 204, 113, 78, 15, 48, 104, 87, 22, 41, 148, 171, 234, 213, 90, 101, 36, 27, 166, 153, 216, 231, 191, 128, 193, 254, 67, 124, 61, 2, 62, 1, 64, 127, 194, 253, 188, 131, 219, 228, 165, 154, 39, 24, 89, 102, 233, 214, 151, 168, 21, 42, 107, 84, 12, 51, 114, 77, 240, 207, 142, 177, ],
[0, 64, 128, 192, 29, 93, 157, 221, 58, 122, 186, 250, 39, 103, 167, 231, 116, 52, 244, 180, 105, 41, 233, 169, 78, 14, 206, 142, 83, 19, 211, 147, 232, 168, 104, 40, 245, 181, 117, 53, 210, 146, 82, 18, 207, 143, 79, 15, 156, 220, 28, 92, 129, 193, 1, 65, 166, 230, 38, 102, 187, 251, 59, 123, 205, 141, 77, 13, 208, 144, 80, 16, 247, 183, 119, 55, 234, 170, 106, 42, 185, 249, 57, 121, 164, 228, 36, 100, 131, 195, 3, 67, 158, 222, 30, 94, 37, 101, 165, 229, 56, 120, 184, 248, 31, 95, 159, 223, 2, 66, 130, 194, 81, 17, 209, 145, 76, 12, 204, 140, 107, 43, 235, 171, 118, 54, 246, 182, 135, 199, 7, 71, 154, 218, 26, 90, 189, 253, 61, 125, 160, 224, 32, 96, 243, 179, 115, 51, 238, 174, 110, 46, 201, 137, 73, 9, 212, 148, 84, 20, 111, 47, 239, 175, 114, 50, 242, 178, 85, 21, 213, 149, 72, 8, 200, 136, 27, 91, 155, 219, 6, 70, 134, 198, 33, 97, 161, 225, 60, 124, 188, 252, 74, 10, 202, 138, 87, 23, 215, 151, 112, 48, 240, 176, 109, 45, 237, 173, 62, 126, 190, 254, 35, 99, 163, 227, 4, 68, 132, 196, 25, 89, 153, 217, 162, 226, 34, 98, 191, 255, 63, 127, 152, 216, 24, 88, 133, 197, 5, 69, 214, 150, 86, 22, 203, 139, 75, 11, 236, 172, 108, 44, 241, 177, 113, 49, ],
[0, 65, 130, 195, 25, 88, 155, 218, 50, 115, 176, 241, 43, 106, 169, 232, 100, 37, 230, 167, 125, 60, 255, 190, 86, 23, 212, 149, 79, 14, 205, 140, 200, 137, 74, 11, 209, 144, 83, 18, 250, 187, 120, 57, 227, 162, 97, 32, 172, 237, 46, 111, 181, 244, 55, 118, 158, 223, 28, 93, 135, 198, 5, 68, 141, 204, 15, 78, 148, 213, 22, 87, 191, 254, 61, 124, 166, 231, 36, 101, 233, 168, 107, 42, 240, 177, 114, 51, 219, 154, 89, 24, 194, 131, 64, 1, 69, 4, 199, 134, 92, 29, 222, 159, 119, 54, 245, 180, 110, 47, 236, 173, 33, 96, 163, 226, 56, 121, 186, 251, 19, 82, 145, 208, 10, 75, 136, 201, 7, 70, 133, 196, 30, 95, 156, 221, 53, 116, 183, 246, 44, 109, 174, 239, 99, 34, 225, 160, 122, 59, 248, 185, 81, 16, 211, 146, 72, 9, 202, 139, 207, 142, 77, 12, 214, 151, 84, 21, 253, 188, 127, 62, 228, 165, 102, 39, 171, 234, 41, 104, 178, 243, 48, 113, 153, 216, 27, 90, 128, 193, 2, 67, 138, 203, 8, 73, 147, 210, 17, 80, 184, 249, 58, 123, 161, 224, 35, 98, 238, 175, 108, 45, 247, 182, 117, 52, 220, 157, 94, 31, 197, 132, 71, 6, 66, 3, 192, 129, 91, 26, 217, 152, 112, 49, 242, 179, 105, 40, 235, 170, 38, 103, 164, 229, 63, 126, 189, 252, 20, 85, 150, 215, 13, 76, 143, 206, ],
[0, 66, 132, 198, 21, 87, 145, 211, 42, 104, 174, 236, 63, 125, 187, 249, 84, 22, 208, 146, 65, 3, 197, 135, 126, 60, 250, 184, 107, 41, 239, 173, 168, 234, 44, 110, 189, 255, 57, 123, 130, 192, 6, 68, 151, 213, 19, 81, 252, 190, 120, 58, 233, 171, 109, 47, 214, 148, 82, 16, 195, 129, 71, 5, 77, 15, 201, 139, 88, 26, 220, 158, 103, 37, 227, 161, 114, 48, 246, 180, 25, 91, 157, 223, 12, 78, 136, 202, 51, 113, 183, 245, 38, 100, 162, 224, 229, 167, 97, 35, 240, 178, 116, 54, 207, 141, 75, 9, 218, 152, 94, 28, 177, 243, 53, 119, 164, 230, 32, 98, 155, 217, 31, 93, 142, 204, 10, 72, 154, 216, 30, 92, 143, 205, 11, 73, 176, 242, 52, 118, 165, 231, 33, 99, 206, 140, 74, 8, 219, 153, 95, 29, 228, 166, 96, 34, 241, 179, 117, 55, 50, 112, 182, 244, 39, 101, 163, 225, 24, 90, 156, 222, 13, 79, 137, 203, 102, 36, 226, 160, 115, 49, 247, 181, 76, 14, 200, 138, 89, 27, 221, 159, 215, 149, 83, 17, 194, 128, 70, 4, 253, 191, 121, 59, 232, 170, 108, 46, 131, 193, 7, 69, 150, 212, 18, 80, 169, 235, 45, 111, 188, 254, 56, 122, 127, 61, 251, 185, 106, 40, 238, 172, 85, 23, 209, 147, 64, 2, 196, 134, 43, 105, 175, 237, 62, 124, 186, 248, 1, 67, 133, 199, 20, 86, 144, 210, ],
[0, 67, 134, 197, 17, 82, 151, 212, 34, 97, 164, 231, 51, 112, 181, 246, 68, 7, 194, 129, 85, 22, 211, 144, 102, 37, 224, 163, 119, 52, 241, 178, 136, 203, 14, 77, 153, 218, 31, 92, 170, 233, 44, 111, 187, 248, 61, 126, 204, 143, 74, 9, 221, 158, 91, 24, 238, 173, 104, 43, 255, 188, 121, 58, 13, 78, 139, 200, 28, 95, 154, 217, 47, 108, 169, 234, 62, 125, 184, 251, 73, 10, 207, 140, 88, 27, 222, 157, 107, 40, 237, 174, 122, 57, 252, 191, 133, 198, 3, 64, 148, 215, 18, 81, 167, 228, 33, 98, 182, 245, 48, 115, 193, 130, 71, 4, 208, 147, 86, 21, 227, 160, 101, 38, 242, 177, 116, 55, 26, 89, 156, 223, 11, 72, 141, 206, 56, 123, 190, 253, 41, 106, 175, 236, 94, 29, 216, 155, 79, 12, 201, 138, 124, 63, 250, 185, 109, 46, 235, 168, 146, 209, 20, 87, 131, 192, 5, 70, 176, 243, 54, 117, 161, 226, 39, 100, 214, 149, 80, 19, 199, 132, 65, 2, 244, 183, 114, 49, 229, 166, 99, 32, 23, 84, 145, 210, 6, 69, 128, 195, 53, 118, 179, 240, 36, 103, 162, 225, 83, 16, 213, 150, 66, 1, 196, 135, 113, 50, 247, 180, 96, 35, 230, 165, 159, 220, 25, 90, 142, 205, 8, 75, 189, 254, 59, 120, 172, 239, 42, 105, 219, 152, 93, 30, 202, 137, 76, 15, 249, 186, 127, 60, 232, 171, 110, 45, ],
[0, 68, 136, 204, 13, 73, 133, 193, 26, 94, 146, 214, 23, 83, 159, 219, 52, 112, 188, 248, 57, 125, 177, 245, 46, 106, 166, 226, 35, 103, 171, 239, 104, 44, 224, 164, 101, 33, 237, 169, 114, 54, 250, 190, 127, 59, 247, 179, 92, 24, 212, 144, 81, 21, 217, 157, 70, 2, 206, 138, 75, 15, 195, 135, 208, 148, 88, 28, 221, 153, 85, 17, 202, 142, 66, 6, 199, 131, 79, 11, 228, 160, 108, 40, 233, 173, 97, 37, 254, 186, 118, 50, 243, 183, 123, 63, 184, 252, 48, 116, 181, 241, 61, 121, 162, 230, 42, 110, 175, 235, 39, 99, 140, 200, 4, 64, 129, 197, 9, 77, 150, 210, 30, 90, 155, 223, 19, 87, 189, 249, 53, 113, 176, 244, 56, 124, 167, 227, 47, 107, 170, 238, 34, 102, 137, 205, 1, 69, 132, 192, 12, 72, 147, 215, 27, 95, 158, 218, 22, 82, 213, 145, 93, 25, 216, 156, 80, 20, 207, 139, 71, 3, 194, 134, 74, 14, 225, 165, 105, 45, 236, 168, 100, 32, 251, 191, 115, 55, 246, 178, 126, 58, 109, 41, 229, 161, 96, 36, 232, 172, 119, 51, 255, 187, 122, 62, 242, 182, 89, 29, 209, 149, 84, 16, 220, 152, 67, 7, 203, 143, 78, 10, 198, 130, 5, 65, 141, 201, 8, 76, 128, 196, 31, 91, 151, 211, 18, 86, 154, 222, 49, 117, 185, 253, 60, 120, 180, 240, 43, 111, 163, 231, 38, 98, 174, 234, ],
[0, 69, 138, 207, 9, 76, 131, 198, 18, 87, 152, 221, 27, 94, 145, 212, 36, 97, 174, 235, 45, 104, 167, 226, 54, 115, 188, 249, 63, 122, 181, 240, 72, 13, 194, 135, 65, 4, 203, 142, 90, 31, 208, 149, 83, 22, 217, 156, 108, 41, 230, 163, 101, 32, 239, 170, 126, 59, 244, 177, 119, 50, 253, 184, 144, 213, 26, 95, 153, 220, 19, 86, 130, 199, 8, 77, 139, 206, 1, 68, 180, 241, 62, 123, 189, 248, 55, 114, 166, 227, 44, 105, 175, 234, 37, 96, 216, 157, 82, 23, 209, 148, 91, 30, 202, 143, 64, 5, 195, 134, 73, 12, 252, 185, 118, 51, 245, 176, 127, 58, 238, 171, 100, 33, 231, 162, 109, 40, 61, 120, 183, 242, 52, 113, 190, 251, 47, 106, 165, 224, 38, 99, 172, 233, 25, 92, 147, 214, 16, 85, 154, 223, 11, 78, 129, 196, 2, 71, 136, 205, 117, 48, 255, 186, 124, 57, 246, 179, 103, 34, 237, 168, 110, 43, 228, 161, 81, 20, 219, 158, 88, 29, 210, 151, 67, 6, 201, 140, 74, 15, 192, 133, 173, 232, 39, 98, 164, 225, 46, 107, 191, 250, 53, 112, 182, 243, 60, 121, 137, 204, 3, 70, 128, 197, 10, 79, 155, 222, 17, 84, 146, 215, 24, 93, 229, 160, 111, 42, 236, 169, 102, 35, 247, 178, 125, 56, 254, 187, 116, 49, 193, 132, 75, 14, 200, 141, 66, 7, 211, 150, 89, 28, 218, 159, 80, 21, ],
[0, 70, 140, 202, 5, 67, 137, 207, 10, 76, 134, 192, 15, 73, 131, 197, 20, 82, 152, 222, 17, 87, 157, 219, 30, 88, 146, 212, 27, 93, 151, 209, 40, 110, 164, 226, 45, 107, 161, 231, 34, 100, 174, 232, 39, 97, 171, 237, 60, 122, 176, 246, 57, 127, 181, 243, 54, 112, 186, 252, 51, 117, 191, 249, 80, 22, 220, 154, 85, 19, 217, 159, 90, 28, 214, 144, 95, 25, 211, 149, 68, 2, 200, 142, 65, 7, 205, 139, 78, 8, 194, 132, 75, 13, 199, 129, 120, 62, 244, 178, 125, 59, 241, 183, 114, 52, 254, 184, 119, 49, 251, 189, 108, 42, 224, 166, 105, 47, 229, 163, 102, 32, 234, 172, 99, 37, 239, 169, 160, 230, 44, 106, 165, 227, 41, 111, 170, 236, 38, 96, 175, 233, 35, 101, 180, 242, 56, 126, 177, 247, 61, 123, 190, 248, 50, 116, 187, 253, 55, 113, 136, 206, 4, 66, 141, 203, 1, 71, 130, 196, 14, 72, 135, 193, 11, 77, 156, 218, 16, 86, 153, 223, 21, 83, 150, 208, 26, 92, 147, 213, 31, 89, 240, 182, 124, 58, 245, 179, 121, 63, 250, 188, 118, 48, 255, 185, 115, 53, 228, 162, 104, 46, 225, 167, 109, 43, 238, 168, 98, 36, 235, 173, 103, 33, 216, 158, 84, 18, 221, 155, 81, 23, 210, 148, 94, 24, 215, 145, 91, 29, 204, 138, 64, 6, 201, 143, 69, 3, 198, 128, 74, 12, 195, 133, 79, 9, ],
[0, 71, 142, 201, 1, 70, 143, 200, 2, 69, 140, 203, 3, 68, 141, 202, 4, 67, 138, 205, 5, 66, 139, 204, 6, 65, 136, 207, 7, 64, 137, 206, 8, 79, 134, 193, 9, 78, 135, 192, 10, 77, 132, 195, 11, 76, 133, 194, 12, 75, 130, 197, 13, 74, 131, 196, 14, 73, 128, 199, 15, 72, 129, 198, 16, 87, 158, 217, 17, 86, 159, 216, 18, 85, 156, 219, 19, 84, 157, 218, 20, 83, 154, 221, 21, 82, 155, 220, 22, 81, 152, 223, 23, 80, 153, 222, 24, 95, 150, 209, 25, 94, 151, 208, 26, 93, 148, 211, 27, 92, 149, 210, 28, 91, 146, 213, 29, 90, 147, 212, 30, 89, 144, 215, 31, 88, 145, 214, 32, 103, 174, 233, 33, 102, 175, 232, 34, 101, 172, 235, 35, 100, 173, 234, 36, 99, 170, 237, 37, 98, 171, 236, 38, 97, 168, 239, 39, 96, 169, 238, 40, 111, 166, 225, 41, 110, 167, 224, 42, 109, 164, 227, 43, 108, 165, 226, 44, 107, 162, 229, 45, 106, 163, 228, 46, 105, 160, 231, 47, 104, 161, 230, 48, 119, 190, 249, 49, 118, 191, 248, 50, 117, 188, 251, 51, 116, 189, 250, 52, 115, 186, 253, 53, 114, 187, 252, 54, 113, 184, 255, 55, 112, 185, 254, 56, 127, 182, 241, 57, 126, 183, 240, 58, 125, 180, 243, 59, 124, 181, 242, 60, 123, 178, 245, 61, 122, 179, 244, 62, 121, 176, 247, 63, 120, 177, 246, ],
[0, 72, 144, 216, 61, 117, 173, 229, 122, 50, 234, 162, 71, 15, 215, 159, 244, 188, 100, 44, 201, 129, 89, 17, 142, 198, 30, 86, 179, 251, 35, 107, 245, 189, 101, 45, 200, 128, 88, 16, 143, 199, 31, 87, 178, 250, 34, 106, 1, 73, 145, 217, 60, 116, 172, 228, 123, 51, 235, 163, 70, 14, 214, 158, 247, 191, 103, 47, 202, 130, 90, 18, 141, 197, 29, 85, 176, 248, 32, 104, 3, 75, 147, 219, 62, 118, 174, 230, 121, 49, 233, 161, 68, 12, 212, 156, 2, 74, 146, 218, 63, 119, 175, 231, 120, 48, 232, 160, 69, 13, 213, 157, 246, 190, 102, 46, 203, 131, 91, 19, 140, 196, 28, 84, 177, 249, 33, 105, 243, 187, 99, 43, 206, 134, 94, 22, 137, 193, 25, 81, 180, 252, 36, 108, 7, 79, 151, 223, 58, 114, 170, 226, 125, 53, 237, 165, 64, 8, 208, 152, 6, 78, 150, 222, 59, 115, 171, 227, 124, 52, 236, 164, 65, 9, 209, 153, 242, 186, 98, 42, 207, 135, 95, 23, 136, 192, 24, 80, 181, 253, 37, 109, 4, 76, 148, 220, 57, 113, 169, 225, 126, 54, 238, 166, 67, 11, 211, 155, 240, 184, 96, 40, 205, 133, 93, 21, 138, 194, 26, 82, 183, 255, 39, 111, 241, 185, 97, 41, 204, 132, 92, 20, 139, 195, 27, 83, 182, 254, 38, 110, 5, 77, 149, 221, 56, 112, 168, 224, 127, 55, 239, 167, 66, 10, 210, 154, ],
[0, 73, 146, 219, 57, 112, 171, 226, 114, 59, 224, 169, 75, 2, 217, 144, 228, 173, 118, 63, 221, 148, 79, 6, 150, 223, 4, 77, 175, 230, 61, 116, 213, 156, 71, 14, 236, 165, 126, 55, 167, 238, 53, 124, 158, 215, 12, 69, 49, 120, 163, 234, 8, 65, 154, 211, 67, 10, 209, 152, 122, 51, 232, 161, 183, 254, 37, 108, 142, 199, 28, 85, 197, 140, 87, 30, 252, 181, 110, 39, 83, 26, 193, 136, 106, 35, 248, 177, 33, 104, 179, 250, 24, 81, 138, 195, 98, 43, 240, 185, 91, 18, 201, 128, 16, 89, 130, 203, 41, 96, 187, 242, 134, 207, 20, 93, 191, 246, 45, 100, 244, 189, 102, 47, 205, 132, 95, 22, 115, 58, 225, 168, 74, 3, 216, 145, 1, 72, 147, 218, 56, 113, 170, 227, 151, 222, 5, 76, 174, 231, 60, 117, 229, 172, 119, 62, 220, 149, 78, 7, 166, 239, 52, 125, 159, 214, 13, 68, 212, 157, 70, 15, 237, 164, 127, 54, 66, 11, 208, 153, 123, 50, 233, 160, 48, 121, 162, 235, 9, 64, 155, 210, 196, 141, 86, 31, 253, 180, 111, 38, 182, 255, 36, 109, 143, 198, 29, 84, 32, 105, 178, 251, 25, 80, 139, 194, 82, 27, 192, 137, 107, 34, 249, 176, 17, 88, 131, 202, 40, 97, 186, 243, 99, 42, 241, 184, 90, 19, 200, 129, 245, 188, 103, 46, 204, 133, 94, 23, 135, 206, 21, 92, 190, 247, 44, 101, ],
[0, 74, 148, 222, 53, 127, 161, 235, 106, 32, 254, 180, 95, 21, 203, 129, 212, 158, 64, 10, 225, 171, 117, 63, 190, 244, 42, 96, 139, 193, 31, 85, 181, 255, 33, 107, 128, 202, 20, 94, 223, 149, 75, 1, 234, 160, 126, 52, 97, 43, 245, 191, 84, 30, 192, 138, 11, 65, 159, 213, 62, 116, 170, 224, 119, 61, 227, 169, 66, 8, 214, 156, 29, 87, 137, 195, 40, 98, 188, 246, 163, 233, 55, 125, 150, 220, 2, 72, 201, 131, 93, 23, 252, 182, 104, 34, 194, 136, 86, 28, 247, 189, 99, 41, 168, 226, 60, 118, 157, 215, 9, 67, 22, 92, 130, 200, 35, 105, 183, 253, 124, 54, 232, 162, 73, 3, 221, 151, 238, 164, 122, 48, 219, 145, 79, 5, 132, 206, 16, 90, 177, 251, 37, 111, 58, 112, 174, 228, 15, 69, 155, 209, 80, 26, 196, 142, 101, 47, 241, 187, 91, 17, 207, 133, 110, 36, 250, 176, 49, 123, 165, 239, 4, 78, 144, 218, 143, 197, 27, 81, 186, 240, 46, 100, 229, 175, 113, 59, 208, 154, 68, 14, 153, 211, 13, 71, 172, 230, 56, 114, 243, 185, 103, 45, 198, 140, 82, 24, 77, 7, 217, 147, 120, 50, 236, 166, 39, 109, 179, 249, 18, 88, 134, 204, 44, 102, 184, 242, 25, 83, 141, 199, 70, 12, 210, 152, 115, 57, 231, 173, 248, 178, 108, 38, 205, 135, 89, 19, 146, 216, 6, 76, 167, 237, 51, 121, ],
[0, 75, 150, 221, 49, 122, 167, 236, 98, 41, 244, 191, 83, 24, 197, 142, 196, 143, 82, 25, 245, 190, 99, 40, 166, 237, 48, 123, 151, 220, 1, 74, 149, 222, 3, 72, 164, 239, 50, 121, 247, 188, 97, 42, 198, 141, 80, 27, 81, 26, 199, 140, 96, 43, 246, 189, 51, 120, 165, 238, 2, 73, 148, 223, 55, 124, 161, 234, 6, 77, 144, 219, 85, 30, 195, 136, 100, 47, 242, 185, 243, 184, 101, 46, 194, 137, 84, 31, 145, 218, 7, 76, 160, 235, 54, 125, 162, 233, 52, 127, 147, 216, 5, 78, 192, 139, 86, 29, 241, 186, 103, 44, 102, 45, 240, 187, 87, 28, 193, 138, 4, 79, 146, 217, 53, 126, 163, 232, 110, 37, 248, 179, 95, 20, 201, 130, 12, 71, 154, 209, 61, 118, 171, 224, 170, 225, 60, 119, 155, 208, 13, 70, 200, 131, 94, 21, 249, 178, 111, 36, 251, 176, 109, 38, 202, 129, 92, 23, 153, 210, 15, 68, 168, 227, 62, 117, 63, 116, 169, 226, 14, 69, 152, 211, 93, 22, 203, 128, 108, 39, 250, 177, 89, 18, 207, 132, 104, 35, 254, 181, 59, 112, 173, 230, 10, 65, 156, 215, 157, 214, 11, 64, 172, 231, 58, 113, 255, 180, 105, 34, 206, 133, 88, 19, 204, 135, 90, 17, 253, 182, 107, 32, 174, 229, 56, 115, 159, 212, 9, 66, 8, 67, 158, 213, 57, 114, 175, 228, 106, 33, 252, 183, 91, 16, 205, 134, ],
[0, 76, 152, 212, 45, 97, 181, 249, 90, 22, 194, 142, 119, 59, 239, 163, 180, 248, 44, 96, 153, 213, 1, 77, 238, 162, 118, 58, 195, 143, 91, 23, 117, 57, 237, 161, 88, 20, 192, 140, 47, 99, 183, 251, 2, 78, 154, 214, 193, 141, 89, 21, 236, 160, 116, 56, 155, 215, 3, 79, 182, 250, 46, 98, 234, 166, 114, 62, 199, 139, 95, 19, 176, 252, 40, 100, 157, 209, 5, 73, 94, 18, 198, 138, 115, 63, 235, 167, 4, 72, 156, 208, 41, 101, 177, 253, 159, 211, 7, 75, 178, 254, 42, 102, 197, 137, 93, 17, 232, 164, 112, 60, 43, 103, 179, 255, 6, 74, 158, 210, 113, 61, 233, 165, 92, 16, 196, 136, 201, 133, 81, 29, 228, 168, 124, 48, 147, 223, 11, 71, 190, 242, 38, 106, 125, 49, 229, 169, 80, 28, 200, 132, 39, 107, 191, 243, 10, 70, 146, 222, 188, 240, 36, 104, 145, 221, 9, 69, 230, 170, 126, 50, 203, 135, 83, 31, 8, 68, 144, 220, 37, 105, 189, 241, 82, 30, 202, 134, 127, 51, 231, 171, 35, 111, 187, 247, 14, 66, 150, 218, 121, 53, 225, 173, 84, 24, 204, 128, 151, 219, 15, 67, 186, 246, 34, 110, 205, 129, 85, 25, 224, 172, 120, 52, 86, 26, 206, 130, 123, 55, 227, 175, 12, 64, 148, 216, 33, 109, 185, 245, 226, 174, 122, 54, 207, 131, 87, 27, 184, 244, 32, 108, 149, 217, 13, 65, ],
[0, 77, 154, 215, 41, 100, 179, 254, 82, 31, 200, 133, 123, 54, 225, 172, 164, 233, 62, 115, 141, 192, 23, 90, 246, 187, 108, 33, 223, 146, 69, 8, 85, 24, 207, 130, 124, 49, 230, 171, 7, 74, 157, 208, 46, 99, 180, 249, 241, 188, 107, 38, 216, 149, 66, 15, 163, 238, 57, 116, 138, 199, 16, 93, 170, 231, 48, 125, 131, 206, 25, 84, 248, 181, 98, 47, 209, 156, 75, 6, 14, 67, 148, 217, 39, 106, 189, 240, 92, 17, 198, 139, 117, 56, 239, 162, 255, 178, 101, 40, 214, 155, 76, 1, 173, 224, 55, 122, 132, 201, 30, 83, 91, 22, 193, 140, 114, 63, 232, 165, 9, 68, 147, 222, 32, 109, 186, 247, 73, 4, 211, 158, 96, 45, 250, 183, 27, 86, 129, 204, 50, 127, 168, 229, 237, 160, 119, 58, 196, 137, 94, 19, 191, 242, 37, 104, 150, 219, 12, 65, 28, 81, 134, 203, 53, 120, 175, 226, 78, 3, 212, 153, 103, 42, 253, 176, 184, 245, 34, 111, 145, 220, 11, 70, 234, 167, 112, 61, 195, 142, 89, 20, 227, 174, 121, 52, 202, 135, 80, 29, 177, 252, 43, 102, 152, 213, 2, 79, 71, 10, 221, 144, 110, 35, 244, 185, 21, 88, 143, 194, 60, 113, 166, 235, 182, 251, 44, 97, 159, 210, 5, 72, 228, 169, 126, 51, 205, 128, 87, 26, 18, 95, 136, 197, 59, 118, 161, 236, 64, 13, 218, 151, 105, 36, 243, 190, ],
[0, 78, 156, 210, 37, 107, 185, 247, 74, 4, 214, 152, 111, 33, 243, 189, 148, 218, 8, 70, 177, 255, 45, 99, 222, 144, 66, 12, 251, 181, 103, 41, 53, 123, 169, 231, 16, 94, 140, 194, 127, 49, 227, 173, 90, 20, 198, 136, 161, 239, 61, 115, 132, 202, 24, 86, 235, 165, 119, 57, 206, 128, 82, 28, 106, 36, 246, 184, 79, 1, 211, 157, 32, 110, 188, 242, 5, 75, 153, 215, 254, 176, 98, 44, 219, 149, 71, 9, 180, 250, 40, 102, 145, 223, 13, 67, 95, 17, 195, 141, 122, 52, 230, 168, 21, 91, 137, 199, 48, 126, 172, 226, 203, 133, 87, 25, 238, 160, 114, 60, 129, 207, 29, 83, 164, 234, 56, 118, 212, 154, 72, 6, 241, 191, 109, 35, 158, 208, 2, 76, 187, 245, 39, 105, 64, 14, 220, 146, 101, 43, 249, 183, 10, 68, 150, 216, 47, 97, 179, 253, 225, 175, 125, 51, 196, 138, 88, 22, 171, 229, 55, 121, 142, 192, 18, 92, 117, 59, 233, 167, 80, 30, 204, 130, 63, 113, 163, 237, 26, 84, 134, 200, 190, 240, 34, 108, 155, 213, 7, 73, 244, 186, 104, 38, 209, 159, 77, 3, 42, 100, 182, 248, 15, 65, 147, 221, 96, 46, 252, 178, 69, 11, 217, 151, 139, 197, 23, 89, 174, 224, 50, 124, 193, 143, 93, 19, 228, 170, 120, 54, 31, 81, 131, 205, 58, 116, 166, 232, 85, 27, 201, 135, 112, 62, 236, 162, ],
[0, 79, 158, 209, 33, 110, 191, 240, 66, 13, 220, 147, 99, 44, 253, 178, 132, 203, 26, 85, 165, 234, 59, 116, 198, 137, 88, 23, 231, 168, 121, 54, 21, 90, 139, 196, 52, 123, 170, 229, 87, 24, 201, 134, 118, 57, 232, 167, 145, 222, 15, 64, 176, 255, 46, 97, 211, 156, 77, 2, 242, 189, 108, 35, 42, 101, 180, 251, 11, 68, 149, 218, 104, 39, 246, 185, 73, 6, 215, 152, 174, 225, 48, 127, 143, 192, 17, 94, 236, 163, 114, 61, 205, 130, 83, 28, 63, 112, 161, 238, 30, 81, 128, 207, 125, 50, 227, 172, 92, 19, 194, 141, 187, 244, 37, 106, 154, 213, 4, 75, 249, 182, 103, 40, 216, 151, 70, 9, 84, 27, 202, 133, 117, 58, 235, 164, 22, 89, 136, 199, 55, 120, 169, 230, 208, 159, 78, 1, 241, 190, 111, 32, 146, 221, 12, 67, 179, 252, 45, 98, 65, 14, 223, 144, 96, 47, 254, 177, 3, 76, 157, 210, 34, 109, 188, 243, 197, 138, 91, 20, 228, 171, 122, 53, 135, 200, 25, 86, 166, 233, 56, 119, 126, 49, 224, 175, 95, 16, 193, 142, 60, 115, 162, 237, 29, 82, 131, 204, 250, 181, 100, 43, 219, 148, 69, 10, 184, 247, 38, 105, 153, 214, 7, 72, 107, 36, 245, 186, 74, 5, 212, 155, 41, 102, 183, 248, 8, 71, 150, 217, 239, 160, 113, 62, 206, 129, 80, 31, 173, 226, 51, 124, 140, 195, 18, 93, ],
[0, 80, 160, 240, 93, 13, 253, 173, 186, 234, 26, 74, 231, 183, 71, 23, 105, 57, 201, 153, 52, 100, 148, 196, 211, 131, 115, 35, 142, 222, 46, 126, 210, 130, 114, 34, 143, 223, 47, 127, 104, 56, 200, 152, 53, 101, 149, 197, 187, 235, 27, 75, 230, 182, 70, 22, 1, 81, 161, 241, 92, 12, 252, 172, 185, 233, 25, 73, 228, 180, 68, 20, 3, 83, 163, 243, 94, 14, 254, 174, 208, 128, 112, 32, 141, 221, 45, 125, 106, 58, 202, 154, 55, 103, 151, 199, 107, 59, 203, 155, 54, 102, 150, 198, 209, 129, 113, 33, 140, 220, 44, 124, 2, 82, 162, 242, 95, 15, 255, 175, 184, 232, 24, 72, 229, 181, 69, 21, 111, 63, 207, 159, 50, 98, 146, 194, 213, 133, 117, 37, 136, 216, 40, 120, 6, 86, 166, 246, 91, 11, 251, 171, 188, 236, 28, 76, 225, 177, 65, 17, 189, 237, 29, 77, 224, 176, 64, 16, 7, 87, 167, 247, 90, 10, 250, 170, 212, 132, 116, 36, 137, 217, 41, 121, 110, 62, 206, 158, 51, 99, 147, 195, 214, 134, 118, 38, 139, 219, 43, 123, 108, 60, 204, 156, 49, 97, 145, 193, 191, 239, 31, 79, 226, 178, 66, 18, 5, 85, 165, 245, 88, 8, 248, 168, 4, 84, 164, 244, 89, 9, 249, 169, 190, 238, 30, 78, 227, 179, 67, 19, 109, 61, 205, 157, 48, 96, 144, 192, 215, 135, 119, 39, 138, 218, 42, 122, ],
[0, 81, 162, 243, 89, 8, 251, 170, 178, 227, 16, 65, 235, 186, 73, 24, 121, 40, 219, 138, 32, 113, 130, 211, 203, 154, 105, 56, 146, 195, 48, 97, 242, 163, 80, 1, 171, 250, 9, 88, 64, 17, 226, 179, 25, 72, 187, 234, 139, 218, 41, 120, 210, 131, 112, 33, 57, 104, 155, 202, 96, 49, 194, 147, 249, 168, 91, 10, 160, 241, 2, 83, 75, 26, 233, 184, 18, 67, 176, 225, 128, 209, 34, 115, 217, 136, 123, 42, 50, 99, 144, 193, 107, 58, 201, 152, 11, 90, 169, 248, 82, 3, 240, 161, 185, 232, 27, 74, 224, 177, 66, 19, 114, 35, 208, 129, 43, 122, 137, 216, 192, 145, 98, 51, 153, 200, 59, 106, 239, 190, 77, 28, 182, 231, 20, 69, 93, 12, 255, 174, 4, 85, 166, 247, 150, 199, 52, 101, 207, 158, 109, 60, 36, 117, 134, 215, 125, 44, 223, 142, 29, 76, 191, 238, 68, 21, 230, 183, 175, 254, 13, 92, 246, 167, 84, 5, 100, 53, 198, 151, 61, 108, 159, 206, 214, 135, 116, 37, 143, 222, 45, 124, 22, 71, 180, 229, 79, 30, 237, 188, 164, 245, 6, 87, 253, 172, 95, 14, 111, 62, 205, 156, 54, 103, 148, 197, 221, 140, 127, 46, 132, 213, 38, 119, 228, 181, 70, 23, 189, 236, 31, 78, 86, 7, 244, 165, 15, 94, 173, 252, 157, 204, 63, 110, 196, 149, 102, 55, 47, 126, 141, 220, 118, 39, 212, 133, ],
[0, 82, 164, 246, 85, 7, 241, 163, 170, 248, 14, 92, 255, 173, 91, 9, 73, 27, 237, 191, 28, 78, 184, 234, 227, 177, 71, 21, 182, 228, 18, 64, 146, 192, 54, 100, 199, 149, 99, 49, 56, 106, 156, 206, 109, 63, 201, 155, 219, 137, 127, 45, 142, 220, 42, 120, 113, 35, 213, 135, 36, 118, 128, 210, 57, 107, 157, 207, 108, 62, 200, 154, 147, 193, 55, 101, 198, 148, 98, 48, 112, 34, 212, 134, 37, 119, 129, 211, 218, 136, 126, 44, 143, 221, 43, 121, 171, 249, 15, 93, 254, 172, 90, 8, 1, 83, 165, 247, 84, 6, 240, 162, 226, 176, 70, 20, 183, 229, 19, 65, 72, 26, 236, 190, 29, 79, 185, 235, 114, 32, 214, 132, 39, 117, 131, 209, 216, 138, 124, 46, 141, 223, 41, 123, 59, 105, 159, 205, 110, 60, 202, 152, 145, 195, 53, 103, 196, 150, 96, 50, 224, 178, 68, 22, 181, 231, 17, 67, 74, 24, 238, 188, 31, 77, 187, 233, 169, 251, 13, 95, 252, 174, 88, 10, 3, 81, 167, 245, 86, 4, 242, 160, 75, 25, 239, 189, 30, 76, 186, 232, 225, 179, 69, 23, 180, 230, 16, 66, 2, 80, 166, 244, 87, 5, 243, 161, 168, 250, 12, 94, 253, 175, 89, 11, 217, 139, 125, 47, 140, 222, 40, 122, 115, 33, 215, 133, 38, 116, 130, 208, 144, 194, 52, 102, 197, 151, 97, 51, 58, 104, 158, 204, 111, 61, 203, 153, ],
[0, 83, 166, 245, 81, 2, 247, 164, 162, 241, 4, 87, 243, 160, 85, 6, 89, 10, 255, 172, 8, 91, 174, 253, 251, 168, 93, 14, 170, 249, 12, 95, 178, 225, 20, 71, 227, 176, 69, 22, 16, 67, 182, 229, 65, 18, 231, 180, 235, 184, 77, 30, 186, 233, 28, 79, 73, 26, 239, 188, 24, 75, 190, 237, 121, 42, 223, 140, 40, 123, 142, 221, 219, 136, 125, 46, 138, 217, 44, 127, 32, 115, 134, 213, 113, 34, 215, 132, 130, 209, 36, 119, 211, 128, 117, 38, 203, 152, 109, 62, 154, 201, 60, 111, 105, 58, 207, 156, 56, 107, 158, 205, 146, 193, 52, 103, 195, 144, 101, 54, 48, 99, 150, 197, 97, 50, 199, 148, 242, 161, 84, 7, 163, 240, 5, 86, 80, 3, 246, 165, 1, 82, 167, 244, 171, 248, 13, 94, 250, 169, 92, 15, 9, 90, 175, 252, 88, 11, 254, 173, 64, 19, 230, 181, 17, 66, 183, 228, 226, 177, 68, 23, 179, 224, 21, 70, 25, 74, 191, 236, 72, 27, 238, 189, 187, 232, 29, 78, 234, 185, 76, 31, 139, 216, 45, 126, 218, 137, 124, 47, 41, 122, 143, 220, 120, 43, 222, 141, 210, 129, 116, 39, 131, 208, 37, 118, 112, 35, 214, 133, 33, 114, 135, 212, 57, 106, 159, 204, 104, 59, 206, 157, 155, 200, 61, 110, 202, 153, 108, 63, 96, 51, 198, 149, 49, 98, 151, 196, 194, 145, 100, 55, 147, 192, 53, 102, ],
[0, 84, 168, 252, 77, 25, 229, 177, 154, 206, 50, 102, 215, 131, 127, 43, 41, 125, 129, 213, 100, 48, 204, 152, 179, 231, 27, 79, 254, 170, 86, 2, 82, 6, 250, 174, 31, 75, 183, 227, 200, 156, 96, 52, 133, 209, 45, 121, 123, 47, 211, 135, 54, 98, 158, 202, 225, 181, 73, 29, 172, 248, 4, 80, 164, 240, 12, 88, 233, 189, 65, 21, 62, 106, 150, 194, 115, 39, 219, 143, 141, 217, 37, 113, 192, 148, 104, 60, 23, 67, 191, 235, 90, 14, 242, 166, 246, 162, 94, 10, 187, 239, 19, 71, 108, 56, 196, 144, 33, 117, 137, 221, 223, 139, 119, 35, 146, 198, 58, 110, 69, 17, 237, 185, 8, 92, 160, 244, 85, 1, 253, 169, 24, 76, 176, 228, 207, 155, 103, 51, 130, 214, 42, 126, 124, 40, 212, 128, 49, 101, 153, 205, 230, 178, 78, 26, 171, 255, 3, 87, 7, 83, 175, 251, 74, 30, 226, 182, 157, 201, 53, 97, 208, 132, 120, 44, 46, 122, 134, 210, 99, 55, 203, 159, 180, 224, 28, 72, 249, 173, 81, 5, 241, 165, 89, 13, 188, 232, 20, 64, 107, 63, 195, 151, 38, 114, 142, 218, 216, 140, 112, 36, 149, 193, 61, 105, 66, 22, 234, 190, 15, 91, 167, 243, 163, 247, 11, 95, 238, 186, 70, 18, 57, 109, 145, 197, 116, 32, 220, 136, 138, 222, 34, 118, 199, 147, 111, 59, 16, 68, 184, 236, 93, 9, 245, 161, ],
[0, 85, 170, 255, 73, 28, 227, 182, 146, 199, 56, 109, 219, 142, 113, 36, 57, 108, 147, 198, 112, 37, 218, 143, 171, 254, 1, 84, 226, 183, 72, 29, 114, 39, 216, 141, 59, 110, 145, 196, 224, 181, 74, 31, 169, 252, 3, 86, 75, 30, 225, 180, 2, 87, 168, 253, 217, 140, 115, 38, 144, 197, 58, 111, 228, 177, 78, 27, 173, 248, 7, 82, 118, 35, 220, 137, 63, 106, 149, 192, 221, 136, 119, 34, 148, 193, 62, 107, 79, 26, 229, 176, 6, 83, 172, 249, 150, 195, 60, 105, 223, 138, 117, 32, 4, 81, 174, 251, 77, 24, 231, 178, 175, 250, 5, 80, 230, 179, 76, 25, 61, 104, 151, 194, 116, 33, 222, 139, 213, 128, 127, 42, 156, 201, 54, 99, 71, 18, 237, 184, 14, 91, 164, 241, 236, 185, 70, 19, 165, 240, 15, 90, 126, 43, 212, 129, 55, 98, 157, 200, 167, 242, 13, 88, 238, 187, 68, 17, 53, 96, 159, 202, 124, 41, 214, 131, 158, 203, 52, 97, 215, 130, 125, 40, 12, 89, 166, 243, 69, 16, 239, 186, 49, 100, 155, 206, 120, 45, 210, 135, 163, 246, 9, 92, 234, 191, 64, 21, 8, 93, 162, 247, 65, 20, 235, 190, 154, 207, 48, 101, 211, 134, 121, 44, 67, 22, 233, 188, 10, 95, 160, 245, 209, 132, 123, 46, 152, 205, 50, 103, 122, 47, 208, 133, 51, 102, 153, 204, 232, 189, 66, 23, 161, 244, 11, 94, ],
[0, 86, 172, 250, 69, 19, 233, 191, 138, 220, 38, 112, 207, 153, 99, 53, 9, 95, 165, 243, 76, 26, 224, 182, 131, 213, 47, 121, 198, 144, 106, 60, 18, 68, 190, 232, 87, 1, 251, 173, 152, 206, 52, 98, 221, 139, 113, 39, 27, 77, 183, 225, 94, 8, 242, 164, 145, 199, 61, 107, 212, 130, 120, 46, 36, 114, 136, 222, 97, 55, 205, 155, 174, 248, 2, 84, 235, 189, 71, 17, 45, 123, 129, 215, 104, 62, 196, 146, 167, 241, 11, 93, 226, 180, 78, 24, 54, 96, 154, 204, 115, 37, 223, 137, 188, 234, 16, 70, 249, 175, 85, 3, 63, 105, 147, 197, 122, 44, 214, 128, 181, 227, 25, 79, 240, 166, 92, 10, 72, 30, 228, 178, 13, 91, 161, 247, 194, 148, 110, 56, 135, 209, 43, 125, 65, 23, 237, 187, 4, 82, 168, 254, 203, 157, 103, 49, 142, 216, 34, 116, 90, 12, 246, 160, 31, 73, 179, 229, 208, 134, 124, 42, 149, 195, 57, 111, 83, 5, 255, 169, 22, 64, 186, 236, 217, 143, 117, 35, 156, 202, 48, 102, 108, 58, 192, 150, 41, 127, 133, 211, 230, 176, 74, 28, 163, 245, 15, 89, 101, 51, 201, 159, 32, 118, 140, 218, 239, 185, 67, 21, 170, 252, 6, 80, 126, 40, 210, 132, 59, 109, 151, 193, 244, 162, 88, 14, 177, 231, 29, 75, 119, 33, 219, 141, 50, 100, 158, 200, 253, 171, 81, 7, 184, 238, 20, 66, ],
[0, 87, 174, 249, 65, 22, 239, 184, 130, 213, 44, 123, 195, 148, 109, 58, 25, 78, 183, 224, 88, 15, 246, 161, 155, 204, 53, 98, 218, 141, 116, 35, 50, 101, 156, 203, 115, 36, 221, 138, 176, 231, 30, 73, 241, 166, 95, 8, 43, 124, 133, 210, 106, 61, 196, 147, 169, 254, 7, 80, 232, 191, 70, 17, 100, 51, 202, 157, 37, 114, 139, 220, 230, 177, 72, 31, 167, 240, 9, 94, 125, 42, 211, 132, 60, 107, 146, 197, 255, 168, 81, 6, 190, 233, 16, 71, 86, 1, 248, 175, 23, 64, 185, 238, 212, 131, 122, 45, 149, 194, 59, 108, 79, 24, 225, 182, 14, 89, 160, 247, 205, 154, 99, 52, 140, 219, 34, 117, 200, 159, 102, 49, 137, 222, 39, 112, 74, 29, 228, 179, 11, 92, 165, 242, 209, 134, 127, 40, 144, 199, 62, 105, 83, 4, 253, 170, 18, 69, 188, 235, 250, 173, 84, 3, 187, 236, 21, 66, 120, 47, 214, 129, 57, 110, 151, 192, 227, 180, 77, 26, 162, 245, 12, 91, 97, 54, 207, 152, 32, 119, 142, 217, 172, 251, 2, 85, 237, 186, 67, 20, 46, 121, 128, 215, 111, 56, 193, 150, 181, 226, 27, 76, 244, 163, 90, 13, 55, 96, 153, 206, 118, 33, 216, 143, 158, 201, 48, 103, 223, 136, 113, 38, 28, 75, 178, 229, 93, 10, 243, 164, 135, 208, 41, 126, 198, 145, 104, 63, 5, 82, 171, 252, 68, 19, 234, 189, ],
[0, 88, 176, 232, 125, 37, 205, 149, 250, 162, 74, 18, 135, 223, 55, 111, 233, 177, 89, 1, 148, 204, 36, 124, 19, 75, 163, 251, 110, 54, 222, 134, 207, 151, 127, 39, 178, 234, 2, 90, 53, 109, 133, 221, 72, 16, 248, 160, 38, 126, 150, 206, 91, 3, 235, 179, 220, 132, 108, 52, 161, 249, 17, 73, 131, 219, 51, 107, 254, 166, 78, 22, 121, 33, 201, 145, 4, 92, 180, 236, 106, 50, 218, 130, 23, 79, 167, 255, 144, 200, 32, 120, 237, 181, 93, 5, 76, 20, 252, 164, 49, 105, 129, 217, 182, 238, 6, 94, 203, 147, 123, 35, 165, 253, 21, 77, 216, 128, 104, 48, 95, 7, 239, 183, 34, 122, 146, 202, 27, 67, 171, 243, 102, 62, 214, 142, 225, 185, 81, 9, 156, 196, 44, 116, 242, 170, 66, 26, 143, 215, 63, 103, 8, 80, 184, 224, 117, 45, 197, 157, 212, 140, 100, 60, 169, 241, 25, 65, 46, 118, 158, 198, 83, 11, 227, 187, 61, 101, 141, 213, 64, 24, 240, 168, 199, 159, 119, 47, 186, 226, 10, 82, 152, 192, 40, 112, 229, 189, 85, 13, 98, 58, 210, 138, 31, 71, 175, 247, 113, 41, 193, 153, 12, 84, 188, 228, 139, 211, 59, 99, 246, 174, 70, 30, 87, 15, 231, 191, 42, 114, 154, 194, 173, 245, 29, 69, 208, 136, 96, 56, 190, 230, 14, 86, 195, 155, 115, 43, 68, 28, 244, 172, 57, 97, 137, 209, ],
[0, 89, 178, 235, 121, 32, 203, 146, 242, 171, 64, 25, 139, 210, 57, 96, 249, 160, 75, 18, 128, 217, 50, 107, 11, 82, 185, 224, 114, 43, 192, 153, 239, 182, 93, 4, 150, 207, 36, 125, 29, 68, 175, 246, 100, 61, 214, 143, 22, 79, 164, 253, 111, 54, 221, 132, 228, 189, 86, 15, 157, 196, 47, 118, 195, 154, 113, 40, 186, 227, 8, 81, 49, 104, 131, 218, 72, 17, 250, 163, 58, 99, 136, 209, 67, 26, 241, 168, 200, 145, 122, 35, 177, 232, 3, 90, 44, 117, 158, 199, 85, 12, 231, 190, 222, 135, 108, 53, 167, 254, 21, 76, 213, 140, 103, 62, 172, 245, 30, 71, 39, 126, 149, 204, 94, 7, 236, 181, 155, 194, 41, 112, 226, 187, 80, 9, 105, 48, 219, 130, 16, 73, 162, 251, 98, 59, 208, 137, 27, 66, 169, 240, 144, 201, 34, 123, 233, 176, 91, 2, 116, 45, 198, 159, 13, 84, 191, 230, 134, 223, 52, 109, 255, 166, 77, 20, 141, 212, 63, 102, 244, 173, 70, 31, 127, 38, 205, 148, 6, 95, 180, 237, 88, 1, 234, 179, 33, 120, 147, 202, 170, 243, 24, 65, 211, 138, 97, 56, 161, 248, 19, 74, 216, 129, 106, 51, 83, 10, 225, 184, 42, 115, 152, 193, 183, 238, 5, 92, 206, 151, 124, 37, 69, 28, 247, 174, 60, 101, 142, 215, 78, 23, 252, 165, 55, 110, 133, 220, 188, 229, 14, 87, 197, 156, 119, 46, ],
[0, 90, 180, 238, 117, 47, 193, 155, 234, 176, 94, 4, 159, 197, 43, 113, 201, 147, 125, 39, 188, 230, 8, 82, 35, 121, 151, 205, 86, 12, 226, 184, 143, 213, 59, 97, 250, 160, 78, 20, 101, 63, 209, 139, 16, 74, 164, 254, 70, 28, 242, 168, 51, 105, 135, 221, 172, 246, 24, 66, 217, 131, 109, 55, 3, 89, 183, 237, 118, 44, 194, 152, 233, 179, 93, 7, 156, 198, 40, 114, 202, 144, 126, 36, 191, 229, 11, 81, 32, 122, 148, 206, 85, 15, 225, 187, 140, 214, 56, 98, 249, 163, 77, 23, 102, 60, 210, 136, 19, 73, 167, 253, 69, 31, 241, 171, 48, 106, 132, 222, 175, 245, 27, 65, 218, 128, 110, 52, 6, 92, 178, 232, 115, 41, 199, 157, 236, 182, 88, 2, 153, 195, 45, 119, 207, 149, 123, 33, 186, 224, 14, 84, 37, 127, 145, 203, 80, 10, 228, 190, 137, 211, 61, 103, 252, 166, 72, 18, 99, 57, 215, 141, 22, 76, 162, 248, 64, 26, 244, 174, 53, 111, 129, 219, 170, 240, 30, 68, 223, 133, 107, 49, 5, 95, 177, 235, 112, 42, 196, 158, 239, 181, 91, 1, 154, 192, 46, 116, 204, 150, 120, 34, 185, 227, 13, 87, 38, 124, 146, 200, 83, 9, 231, 189, 138, 208, 62, 100, 255, 165, 75, 17, 96, 58, 212, 142, 21, 79, 161, 251, 67, 25, 247, 173, 54, 108, 130, 216, 169, 243, 29, 71, 220, 134, 104, 50, ],
[0, 91, 182, 237, 113, 42, 199, 156, 226, 185, 84, 15, 147, 200, 37, 126, 217, 130, 111, 52, 168, 243, 30, 69, 59, 96, 141, 214, 74, 17, 252, 167, 175, 244, 25, 66, 222, 133, 104, 51, 77, 22, 251, 160, 60, 103, 138, 209, 118, 45, 192, 155, 7, 92, 177, 234, 148, 207, 34, 121, 229, 190, 83, 8, 67, 24, 245, 174, 50, 105, 132, 223, 161, 250, 23, 76, 208, 139, 102, 61, 154, 193, 44, 119, 235, 176, 93, 6, 120, 35, 206, 149, 9, 82, 191, 228, 236, 183, 90, 1, 157, 198, 43, 112, 14, 85, 184, 227, 127, 36, 201, 146, 53, 110, 131, 216, 68, 31, 242, 169, 215, 140, 97, 58, 166, 253, 16, 75, 134, 221, 48, 107, 247, 172, 65, 26, 100, 63, 210, 137, 21, 78, 163, 248, 95, 4, 233, 178, 46, 117, 152, 195, 189, 230, 11, 80, 204, 151, 122, 33, 41, 114, 159, 196, 88, 3, 238, 181, 203, 144, 125, 38, 186, 225, 12, 87, 240, 171, 70, 29, 129, 218, 55, 108, 18, 73, 164, 255, 99, 56, 213, 142, 197, 158, 115, 40, 180, 239, 2, 89, 39, 124, 145, 202, 86, 13, 224, 187, 28, 71, 170, 241, 109, 54, 219, 128, 254, 165, 72, 19, 143, 212, 57, 98, 106, 49, 220, 135, 27, 64, 173, 246, 136, 211, 62, 101, 249, 162, 79, 20, 179, 232, 5, 94, 194, 153, 116, 47, 81, 10, 231, 188, 32, 123, 150, 205, ],
[0, 92, 184, 228, 109, 49, 213, 137, 218, 134, 98, 62, 183, 235, 15, 83, 169, 245, 17, 77, 196, 152, 124, 32, 115, 47, 203, 151, 30, 66, 166, 250, 79, 19, 247, 171, 34, 126, 154, 198, 149, 201, 45, 113, 248, 164, 64, 28, 230, 186, 94, 2, 139, 215, 51, 111, 60, 96, 132, 216, 81, 13, 233, 181, 158, 194, 38, 122, 243, 175, 75, 23, 68, 24, 252, 160, 41, 117, 145, 205, 55, 107, 143, 211, 90, 6, 226, 190, 237, 177, 85, 9, 128, 220, 56, 100, 209, 141, 105, 53, 188, 224, 4, 88, 11, 87, 179, 239, 102, 58, 222, 130, 120, 36, 192, 156, 21, 73, 173, 241, 162, 254, 26, 70, 207, 147, 119, 43, 33, 125, 153, 197, 76, 16, 244, 168, 251, 167, 67, 31, 150, 202, 46, 114, 136, 212, 48, 108, 229, 185, 93, 1, 82, 14, 234, 182, 63, 99, 135, 219, 110, 50, 214, 138, 3, 95, 187, 231, 180, 232, 12, 80, 217, 133, 97, 61, 199, 155, 127, 35, 170, 246, 18, 78, 29, 65, 165, 249, 112, 44, 200, 148, 191, 227, 7, 91, 210, 142, 106, 54, 101, 57, 221, 129, 8, 84, 176, 236, 22, 74, 174, 242, 123, 39, 195, 159, 204, 144, 116, 40, 161, 253, 25, 69, 240, 172, 72, 20, 157, 193, 37, 121, 42, 118, 146, 206, 71, 27, 255, 163, 89, 5, 225, 189, 52, 104, 140, 208, 131, 223, 59, 103, 238, 178, 86, 10, ],
[0, 93, 186, 231, 105, 52, 211, 142, 210, 143, 104, 53, 187, 230, 1, 92, 185, 228, 3, 94, 208, 141, 106, 55, 107, 54, 209, 140, 2, 95, 184, 229, 111, 50, 213, 136, 6, 91, 188, 225, 189, 224, 7, 90, 212, 137, 110, 51, 214, 139, 108, 49, 191, 226, 5, 88, 4, 89, 190, 227, 109, 48, 215, 138, 222, 131, 100, 57, 183, 234, 13, 80, 12, 81, 182, 235, 101, 56, 223, 130, 103, 58, 221, 128, 14, 83, 180, 233, 181, 232, 15, 82, 220, 129, 102, 59, 177, 236, 11, 86, 216, 133, 98, 63, 99, 62, 217, 132, 10, 87, 176, 237, 8, 85, 178, 239, 97, 60, 219, 134, 218, 135, 96, 61, 179, 238, 9, 84, 161, 252, 27, 70, 200, 149, 114, 47, 115, 46, 201, 148, 26, 71, 160, 253, 24, 69, 162, 255, 113, 44, 203, 150, 202, 151, 112, 45, 163, 254, 25, 68, 206, 147, 116, 41, 167, 250, 29, 64, 28, 65, 166, 251, 117, 40, 207, 146, 119, 42, 205, 144, 30, 67, 164, 249, 165, 248, 31, 66, 204, 145, 118, 43, 127, 34, 197, 152, 22, 75, 172, 241, 173, 240, 23, 74, 196, 153, 126, 35, 198, 155, 124, 33, 175, 242, 21, 72, 20, 73, 174, 243, 125, 32, 199, 154, 16, 77, 170, 247, 121, 36, 195, 158, 194, 159, 120, 37, 171, 246, 17, 76, 169, 244, 19, 78, 192, 157, 122, 39, 123, 38, 193, 156, 18, 79, 168, 245, ],
[0, 94, 188, 226, 101, 59, 217, 135, 202, 148, 118, 40, 175, 241, 19, 77, 137, 215, 53, 107, 236, 178, 80, 14, 67, 29, 255, 161, 38, 120, 154, 196, 15, 81, 179, 237, 106, 52, 214, 136, 197, 155, 121, 39, 160, 254, 28, 66, 134, 216, 58, 100, 227, 189, 95, 1, 76, 18, 240, 174, 41, 119, 149, 203, 30, 64, 162, 252, 123, 37, 199, 153, 212, 138, 104, 54, 177, 239, 13, 83, 151, 201, 43, 117, 242, 172, 78, 16, 93, 3, 225, 191, 56, 102, 132, 218, 17, 79, 173, 243, 116, 42, 200, 150, 219, 133, 103, 57, 190, 224, 2, 92, 152, 198, 36, 122, 253, 163, 65, 31, 82, 12, 238, 176, 55, 105, 139, 213, 60, 98, 128, 222, 89, 7, 229, 187, 246, 168, 74, 20, 147, 205, 47, 113, 181, 235, 9, 87, 208, 142, 108, 50, 127, 33, 195, 157, 26, 68, 166, 248, 51, 109, 143, 209, 86, 8, 234, 180, 249, 167, 69, 27, 156, 194, 32, 126, 186, 228, 6, 88, 223, 129, 99, 61, 112, 46, 204, 146, 21, 75, 169, 247, 34, 124, 158, 192, 71, 25, 251, 165, 232, 182, 84, 10, 141, 211, 49, 111, 171, 245, 23, 73, 206, 144, 114, 44, 97, 63, 221, 131, 4, 90, 184, 230, 45, 115, 145, 207, 72, 22, 244, 170, 231, 185, 91, 5, 130, 220, 62, 96, 164, 250, 24, 70, 193, 159, 125, 35, 110, 48, 210, 140, 11, 85, 183, 233, ],
[0, 95, 190, 225, 97, 62, 223, 128, 194, 157, 124, 35, 163, 252, 29, 66, 153, 198, 39, 120, 248, 167, 70, 25, 91, 4, 229, 186, 58, 101, 132, 219, 47, 112, 145, 206, 78, 17, 240, 175, 237, 178, 83, 12, 140, 211, 50, 109, 182, 233, 8, 87, 215, 136, 105, 54, 116, 43, 202, 149, 21, 74, 171, 244, 94, 1, 224, 191, 63, 96, 129, 222, 156, 195, 34, 125, 253, 162, 67, 28, 199, 152, 121, 38, 166, 249, 24, 71, 5, 90, 187, 228, 100, 59, 218, 133, 113, 46, 207, 144, 16, 79, 174, 241, 179, 236, 13, 82, 210, 141, 108, 51, 232, 183, 86, 9, 137, 214, 55, 104, 42, 117, 148, 203, 75, 20, 245, 170, 188, 227, 2, 93, 221, 130, 99, 60, 126, 33, 192, 159, 31, 64, 161, 254, 37, 122, 155, 196, 68, 27, 250, 165, 231, 184, 89, 6, 134, 217, 56, 103, 147, 204, 45, 114, 242, 173, 76, 19, 81, 14, 239, 176, 48, 111, 142, 209, 10, 85, 180, 235, 107, 52, 213, 138, 200, 151, 118, 41, 169, 246, 23, 72, 226, 189, 92, 3, 131, 220, 61, 98, 32, 127, 158, 193, 65, 30, 255, 160, 123, 36, 197, 154, 26, 69, 164, 251, 185, 230, 7, 88, 216, 135, 102, 57, 205, 146, 115, 44, 172, 243, 18, 77, 15, 80, 177, 238, 110, 49, 208, 143, 84, 11, 234, 181, 53, 106, 139, 212, 150, 201, 40, 119, 247, 168, 73, 22, ],
[0, 96, 192, 160, 157, 253, 93, 61, 39, 71, 231, 135, 186, 218, 122, 26, 78, 46, 142, 238, 211, 179, 19, 115, 105, 9, 169, 201, 244, 148, 52, 84, 156, 252, 92, 60, 1, 97, 193, 161, 187, 219, 123, 27, 38, 70, 230, 134, 210, 178, 18, 114, 79, 47, 143, 239, 245, 149, 53, 85, 104, 8, 168, 200, 37, 69, 229, 133, 184, 216, 120, 24, 2, 98, 194, 162, 159, 255, 95, 63, 107, 11, 171, 203, 246, 150, 54, 86, 76, 44, 140, 236, 209, 177, 17, 113, 185, 217, 121, 25, 36, 68, 228, 132, 158, 254, 94, 62, 3, 99, 195, 163, 247, 151, 55, 87, 106, 10, 170, 202, 208, 176, 16, 112, 77, 45, 141, 237, 74, 42, 138, 234, 215, 183, 23, 119, 109, 13, 173, 205, 240, 144, 48, 80, 4, 100, 196, 164, 153, 249, 89, 57, 35, 67, 227, 131, 190, 222, 126, 30, 214, 182, 22, 118, 75, 43, 139, 235, 241, 145, 49, 81, 108, 12, 172, 204, 152, 248, 88, 56, 5, 101, 197, 165, 191, 223, 127, 31, 34, 66, 226, 130, 111, 15, 175, 207, 242, 146, 50, 82, 72, 40, 136, 232, 213, 181, 21, 117, 33, 65, 225, 129, 188, 220, 124, 28, 6, 102, 198, 166, 155, 251, 91, 59, 243, 147, 51, 83, 110, 14, 174, 206, 212, 180, 20, 116, 73, 41, 137, 233, 189, 221, 125, 29, 32, 64, 224, 128, 154, 250, 90, 58, 7, 103, 199, 167, ],
[0, 97, 194, 163, 153, 248, 91, 58, 47, 78, 237, 140, 182, 215, 116, 21, 94, 63, 156, 253, 199, 166, 5, 100, 113, 16, 179, 210, 232, 137, 42, 75, 188, 221, 126, 31, 37, 68, 231, 134, 147, 242, 81, 48, 10, 107, 200, 169, 226, 131, 32, 65, 123, 26, 185, 216, 205, 172, 15, 110, 84, 53, 150, 247, 101, 4, 167, 198, 252, 157, 62, 95, 74, 43, 136, 233, 211, 178, 17, 112, 59, 90, 249, 152, 162, 195, 96, 1, 20, 117, 214, 183, 141, 236, 79, 46, 217, 184, 27, 122, 64, 33, 130, 227, 246, 151, 52, 85, 111, 14, 173, 204, 135, 230, 69, 36, 30, 127, 220, 189, 168, 201, 106, 11, 49, 80, 243, 146, 202, 171, 8, 105, 83, 50, 145, 240, 229, 132, 39, 70, 124, 29, 190, 223, 148, 245, 86, 55, 13, 108, 207, 174, 187, 218, 121, 24, 34, 67, 224, 129, 118, 23, 180, 213, 239, 142, 45, 76, 89, 56, 155, 250, 192, 161, 2, 99, 40, 73, 234, 139, 177, 208, 115, 18, 7, 102, 197, 164, 158, 255, 92, 61, 175, 206, 109, 12, 54, 87, 244, 149, 128, 225, 66, 35, 25, 120, 219, 186, 241, 144, 51, 82, 104, 9, 170, 203, 222, 191, 28, 125, 71, 38, 133, 228, 19, 114, 209, 176, 138, 235, 72, 41, 60, 93, 254, 159, 165, 196, 103, 6, 77, 44, 143, 238, 212, 181, 22, 119, 98, 3, 160, 193, 251, 154, 57, 88, ],
[0, 98, 196, 166, 149, 247, 81, 51, 55, 85, 243, 145, 162, 192, 102, 4, 110, 12, 170, 200, 251, 153, 63, 93, 89, 59, 157, 255, 204, 174, 8, 106, 220, 190, 24, 122, 73, 43, 141, 239, 235, 137, 47, 77, 126, 28, 186, 216, 178, 208, 118, 20, 39, 69, 227, 129, 133, 231, 65, 35, 16, 114, 212, 182, 165, 199, 97, 3, 48, 82, 244, 150, 146, 240, 86, 52, 7, 101, 195, 161, 203, 169, 15, 109, 94, 60, 154, 248, 252, 158, 56, 90, 105, 11, 173, 207, 121, 27, 189, 223, 236, 142, 40, 74, 78, 44, 138, 232, 219, 185, 31, 125, 23, 117, 211, 177, 130, 224, 70, 36, 32, 66, 228, 134, 181, 215, 113, 19, 87, 53, 147, 241, 194, 160, 6, 100, 96, 2, 164, 198, 245, 151, 49, 83, 57, 91, 253, 159, 172, 206, 104, 10, 14, 108, 202, 168, 155, 249, 95, 61, 139, 233, 79, 45, 30, 124, 218, 184, 188, 222, 120, 26, 41, 75, 237, 143, 229, 135, 33, 67, 112, 18, 180, 214, 210, 176, 22, 116, 71, 37, 131, 225, 242, 144, 54, 84, 103, 5, 163, 193, 197, 167, 1, 99, 80, 50, 148, 246, 156, 254, 88, 58, 9, 107, 205, 175, 171, 201, 111, 13, 62, 92, 250, 152, 46, 76, 234, 136, 187, 217, 127, 29, 25, 123, 221, 191, 140, 238, 72, 42, 64, 34, 132, 230, 213, 183, 17, 115, 119, 21, 179, 209, 226, 128, 38, 68, ],
[0, 99, 198, 165, 145, 242, 87, 52, 63, 92, 249, 154, 174, 205, 104, 11, 126, 29, 184, 219, 239, 140, 41, 74, 65, 34, 135, 228, 208, 179, 22, 117, 252, 159, 58, 89, 109, 14, 171, 200, 195, 160, 5, 102, 82, 49, 148, 247, 130, 225, 68, 39, 19, 112, 213, 182, 189, 222, 123, 24, 44, 79, 234, 137, 229, 134, 35, 64, 116, 23, 178, 209, 218, 185, 28, 127, 75, 40, 141, 238, 155, 248, 93, 62, 10, 105, 204, 175, 164, 199, 98, 1, 53, 86, 243, 144, 25, 122, 223, 188, 136, 235, 78, 45, 38, 69, 224, 131, 183, 212, 113, 18, 103, 4, 161, 194, 246, 149, 48, 83, 88, 59, 158, 253, 201, 170, 15, 108, 215, 180, 17, 114, 70, 37, 128, 227, 232, 139, 46, 77, 121, 26, 191, 220, 169, 202, 111, 12, 56, 91, 254, 157, 150, 245, 80, 51, 7, 100, 193, 162, 43, 72, 237, 142, 186, 217, 124, 31, 20, 119, 210, 177, 133, 230, 67, 32, 85, 54, 147, 240, 196, 167, 2, 97, 106, 9, 172, 207, 251, 152, 61, 94, 50, 81, 244, 151, 163, 192, 101, 6, 13, 110, 203, 168, 156, 255, 90, 57, 76, 47, 138, 233, 221, 190, 27, 120, 115, 16, 181, 214, 226, 129, 36, 71, 206, 173, 8, 107, 95, 60, 153, 250, 241, 146, 55, 84, 96, 3, 166, 197, 176, 211, 118, 21, 33, 66, 231, 132, 143, 236, 73, 42, 30, 125, 216, 187, ],
[0, 100, 200, 172, 141, 233, 69, 33, 7, 99, 207, 171, 138, 238, 66, 38, 14, 106, 198, 162, 131, 231, 75, 47, 9, 109, 193, 165, 132, 224, 76, 40, 28, 120, 212, 176, 145, 245, 89, 61, 27, 127, 211, 183, 150, 242, 94, 58, 18, 118, 218, 190, 159, 251, 87, 51, 21, 113, 221, 185, 152, 252, 80, 52, 56, 92, 240, 148, 181, 209, 125, 25, 63, 91, 247, 147, 178, 214, 122, 30, 54, 82, 254, 154, 187, 223, 115, 23, 49, 85, 249, 157, 188, 216, 116, 16, 36, 64, 236, 136, 169, 205, 97, 5, 35, 71, 235, 143, 174, 202, 102, 2, 42, 78, 226, 134, 167, 195, 111, 11, 45, 73, 229, 129, 160, 196, 104, 12, 112, 20, 184, 220, 253, 153, 53, 81, 119, 19, 191, 219, 250, 158, 50, 86, 126, 26, 182, 210, 243, 151, 59, 95, 121, 29, 177, 213, 244, 144, 60, 88, 108, 8, 164, 192, 225, 133, 41, 77, 107, 15, 163, 199, 230, 130, 46, 74, 98, 6, 170, 206, 239, 139, 39, 67, 101, 1, 173, 201, 232, 140, 32, 68, 72, 44, 128, 228, 197, 161, 13, 105, 79, 43, 135, 227, 194, 166, 10, 110, 70, 34, 142, 234, 203, 175, 3, 103, 65, 37, 137, 237, 204, 168, 4, 96, 84, 48, 156, 248, 217, 189, 17, 117, 83, 55, 155, 255, 222, 186, 22, 114, 90, 62, 146, 246, 215, 179, 31, 123, 93, 57, 149, 241, 208, 180, 24, 124, ],
[0, 101, 202, 175, 137, 236, 67, 38, 15, 106, 197, 160, 134, 227, 76, 41, 30, 123, 212, 177, 151, 242, 93, 56, 17, 116, 219, 190, 152, 253, 82, 55, 60, 89, 246, 147, 181, 208, 127, 26, 51, 86, 249, 156, 186, 223, 112, 21, 34, 71, 232, 141, 171, 206, 97, 4, 45, 72, 231, 130, 164, 193, 110, 11, 120, 29, 178, 215, 241, 148, 59, 94, 119, 18, 189, 216, 254, 155, 52, 81, 102, 3, 172, 201, 239, 138, 37, 64, 105, 12, 163, 198, 224, 133, 42, 79, 68, 33, 142, 235, 205, 168, 7, 98, 75, 46, 129, 228, 194, 167, 8, 109, 90, 63, 144, 245, 211, 182, 25, 124, 85, 48, 159, 250, 220, 185, 22, 115, 240, 149, 58, 95, 121, 28, 179, 214, 255, 154, 53, 80, 118, 19, 188, 217, 238, 139, 36, 65, 103, 2, 173, 200, 225, 132, 43, 78, 104, 13, 162, 199, 204, 169, 6, 99, 69, 32, 143, 234, 195, 166, 9, 108, 74, 47, 128, 229, 210, 183, 24, 125, 91, 62, 145, 244, 221, 184, 23, 114, 84, 49, 158, 251, 136, 237, 66, 39, 1, 100, 203, 174, 135, 226, 77, 40, 14, 107, 196, 161, 150, 243, 92, 57, 31, 122, 213, 176, 153, 252, 83, 54, 16, 117, 218, 191, 180, 209, 126, 27, 61, 88, 247, 146, 187, 222, 113, 20, 50, 87, 248, 157, 170, 207, 96, 5, 35, 70, 233, 140, 165, 192, 111, 10, 44, 73, 230, 131, ],
[0, 102, 204, 170, 133, 227, 73, 47, 23, 113, 219, 189, 146, 244, 94, 56, 46, 72, 226, 132, 171, 205, 103, 1, 57, 95, 245, 147, 188, 218, 112, 22, 92, 58, 144, 246, 217, 191, 21, 115, 75, 45, 135, 225, 206, 168, 2, 100, 114, 20, 190, 216, 247, 145, 59, 93, 101, 3, 169, 207, 224, 134, 44, 74, 184, 222, 116, 18, 61, 91, 241, 151, 175, 201, 99, 5, 42, 76, 230, 128, 150, 240, 90, 60, 19, 117, 223, 185, 129, 231, 77, 43, 4, 98, 200, 174, 228, 130, 40, 78, 97, 7, 173, 203, 243, 149, 63, 89, 118, 16, 186, 220, 202, 172, 6, 96, 79, 41, 131, 229, 221, 187, 17, 119, 88, 62, 148, 242, 109, 11, 161, 199, 232, 142, 36, 66, 122, 28, 182, 208, 255, 153, 51, 85, 67, 37, 143, 233, 198, 160, 10, 108, 84, 50, 152, 254, 209, 183, 29, 123, 49, 87, 253, 155, 180, 210, 120, 30, 38, 64, 234, 140, 163, 197, 111, 9, 31, 121, 211, 181, 154, 252, 86, 48, 8, 110, 196, 162, 141, 235, 65, 39, 213, 179, 25, 127, 80, 54, 156, 250, 194, 164, 14, 104, 71, 33, 139, 237, 251, 157, 55, 81, 126, 24, 178, 212, 236, 138, 32, 70, 105, 15, 165, 195, 137, 239, 69, 35, 12, 106, 192, 166, 158, 248, 82, 52, 27, 125, 215, 177, 167, 193, 107, 13, 34, 68, 238, 136, 176, 214, 124, 26, 53, 83, 249, 159, ],
[0, 103, 206, 169, 129, 230, 79, 40, 31, 120, 209, 182, 158, 249, 80, 55, 62, 89, 240, 151, 191, 216, 113, 22, 33, 70, 239, 136, 160, 199, 110, 9, 124, 27, 178, 213, 253, 154, 51, 84, 99, 4, 173, 202, 226, 133, 44, 75, 66, 37, 140, 235, 195, 164, 13, 106, 93, 58, 147, 244, 220, 187, 18, 117, 248, 159, 54, 81, 121, 30, 183, 208, 231, 128, 41, 78, 102, 1, 168, 207, 198, 161, 8, 111, 71, 32, 137, 238, 217, 190, 23, 112, 88, 63, 150, 241, 132, 227, 74, 45, 5, 98, 203, 172, 155, 252, 85, 50, 26, 125, 212, 179, 186, 221, 116, 19, 59, 92, 245, 146, 165, 194, 107, 12, 36, 67, 234, 141, 237, 138, 35, 68, 108, 11, 162, 197, 242, 149, 60, 91, 115, 20, 189, 218, 211, 180, 29, 122, 82, 53, 156, 251, 204, 171, 2, 101, 77, 42, 131, 228, 145, 246, 95, 56, 16, 119, 222, 185, 142, 233, 64, 39, 15, 104, 193, 166, 175, 200, 97, 6, 46, 73, 224, 135, 176, 215, 126, 25, 49, 86, 255, 152, 21, 114, 219, 188, 148, 243, 90, 61, 10, 109, 196, 163, 139, 236, 69, 34, 43, 76, 229, 130, 170, 205, 100, 3, 52, 83, 250, 157, 181, 210, 123, 28, 105, 14, 167, 192, 232, 143, 38, 65, 118, 17, 184, 223, 247, 144, 57, 94, 87, 48, 153, 254, 214, 177, 24, 127, 72, 47, 134, 225, 201, 174, 7, 96, ],
[0, 104, 208, 184, 189, 213, 109, 5, 103, 15, 183, 223, 218, 178, 10, 98, 206, 166, 30, 118, 115, 27, 163, 203, 169, 193, 121, 17, 20, 124, 196, 172, 129, 233, 81, 57, 60, 84, 236, 132, 230, 142, 54, 94, 91, 51, 139, 227, 79, 39, 159, 247, 242, 154, 34, 74, 40, 64, 248, 144, 149, 253, 69, 45, 31, 119, 207, 167, 162, 202, 114, 26, 120, 16, 168, 192, 197, 173, 21, 125, 209, 185, 1, 105, 108, 4, 188, 212, 182, 222, 102, 14, 11, 99, 219, 179, 158, 246, 78, 38, 35, 75, 243, 155, 249, 145, 41, 65, 68, 44, 148, 252, 80, 56, 128, 232, 237, 133, 61, 85, 55, 95, 231, 143, 138, 226, 90, 50, 62, 86, 238, 134, 131, 235, 83, 59, 89, 49, 137, 225, 228, 140, 52, 92, 240, 152, 32, 72, 77, 37, 157, 245, 151, 255, 71, 47, 42, 66, 250, 146, 191, 215, 111, 7, 2, 106, 210, 186, 216, 176, 8, 96, 101, 13, 181, 221, 113, 25, 161, 201, 204, 164, 28, 116, 22, 126, 198, 174, 171, 195, 123, 19, 33, 73, 241, 153, 156, 244, 76, 36, 70, 46, 150, 254, 251, 147, 43, 67, 239, 135, 63, 87, 82, 58, 130, 234, 136, 224, 88, 48, 53, 93, 229, 141, 160, 200, 112, 24, 29, 117, 205, 165, 199, 175, 23, 127, 122, 18, 170, 194, 110, 6, 190, 214, 211, 187, 3, 107, 9, 97, 217, 177, 180, 220, 100, 12, ],
[0, 105, 210, 187, 185, 208, 107, 2, 111, 6, 189, 212, 214, 191, 4, 109, 222, 183, 12, 101, 103, 14, 181, 220, 177, 216, 99, 10, 8, 97, 218, 179, 161, 200, 115, 26, 24, 113, 202, 163, 206, 167, 28, 117, 119, 30, 165, 204, 127, 22, 173, 196, 198, 175, 20, 125, 16, 121, 194, 171, 169, 192, 123, 18, 95, 54, 141, 228, 230, 143, 52, 93, 48, 89, 226, 139, 137, 224, 91, 50, 129, 232, 83, 58, 56, 81, 234, 131, 238, 135, 60, 85, 87, 62, 133, 236, 254, 151, 44, 69, 71, 46, 149, 252, 145, 248, 67, 42, 40, 65, 250, 147, 32, 73, 242, 155, 153, 240, 75, 34, 79, 38, 157, 244, 246, 159, 36, 77, 190, 215, 108, 5, 7, 110, 213, 188, 209, 184, 3, 106, 104, 1, 186, 211, 96, 9, 178, 219, 217, 176, 11, 98, 15, 102, 221, 180, 182, 223, 100, 13, 31, 118, 205, 164, 166, 207, 116, 29, 112, 25, 162, 203, 201, 160, 27, 114, 193, 168, 19, 122, 120, 17, 170, 195, 174, 199, 124, 21, 23, 126, 197, 172, 225, 136, 51, 90, 88, 49, 138, 227, 142, 231, 92, 53, 55, 94, 229, 140, 63, 86, 237, 132, 134, 239, 84, 61, 80, 57, 130, 235, 233, 128, 59, 82, 64, 41, 146, 251, 249, 144, 43, 66, 47, 70, 253, 148, 150, 255, 68, 45, 158, 247, 76, 37, 39, 78, 245, 156, 241, 152, 35, 74, 72, 33, 154, 243, ],
[0, 106, 212, 190, 181, 223, 97, 11, 119, 29, 163, 201, 194, 168, 22, 124, 238, 132, 58, 80, 91, 49, 143, 229, 153, 243, 77, 39, 44, 70, 248, 146, 193, 171, 21, 127, 116, 30, 160, 202, 182, 220, 98, 8, 3, 105, 215, 189, 47, 69, 251, 145, 154, 240, 78, 36, 88, 50, 140, 230, 237, 135, 57, 83, 159, 245, 75, 33, 42, 64, 254, 148, 232, 130, 60, 86, 93, 55, 137, 227, 113, 27, 165, 207, 196, 174, 16, 122, 6, 108, 210, 184, 179, 217, 103, 13, 94, 52, 138, 224, 235, 129, 63, 85, 41, 67, 253, 151, 156, 246, 72, 34, 176, 218, 100, 14, 5, 111, 209, 187, 199, 173, 19, 121, 114, 24, 166, 204, 35, 73, 247, 157, 150, 252, 66, 40, 84, 62, 128, 234, 225, 139, 53, 95, 205, 167, 25, 115, 120, 18, 172, 198, 186, 208, 110, 4, 15, 101, 219, 177, 226, 136, 54, 92, 87, 61, 131, 233, 149, 255, 65, 43, 32, 74, 244, 158, 12, 102, 216, 178, 185, 211, 109, 7, 123, 17, 175, 197, 206, 164, 26, 112, 188, 214, 104, 2, 9, 99, 221, 183, 203, 161, 31, 117, 126, 20, 170, 192, 82, 56, 134, 236, 231, 141, 51, 89, 37, 79, 241, 155, 144, 250, 68, 46, 125, 23, 169, 195, 200, 162, 28, 118, 10, 96, 222, 180, 191, 213, 107, 1, 147, 249, 71, 45, 38, 76, 242, 152, 228, 142, 48, 90, 81, 59, 133, 239, ],
[0, 107, 214, 189, 177, 218, 103, 12, 127, 20, 169, 194, 206, 165, 24, 115, 254, 149, 40, 67, 79, 36, 153, 242, 129, 234, 87, 60, 48, 91, 230, 141, 225, 138, 55, 92, 80, 59, 134, 237, 158, 245, 72, 35, 47, 68, 249, 146, 31, 116, 201, 162, 174, 197, 120, 19, 96, 11, 182, 221, 209, 186, 7, 108, 223, 180, 9, 98, 110, 5, 184, 211, 160, 203, 118, 29, 17, 122, 199, 172, 33, 74, 247, 156, 144, 251, 70, 45, 94, 53, 136, 227, 239, 132, 57, 82, 62, 85, 232, 131, 143, 228, 89, 50, 65, 42, 151, 252, 240, 155, 38, 77, 192, 171, 22, 125, 113, 26, 167, 204, 191, 212, 105, 2, 14, 101, 216, 179, 163, 200, 117, 30, 18, 121, 196, 175, 220, 183, 10, 97, 109, 6, 187, 208, 93, 54, 139, 224, 236, 135, 58, 81, 34, 73, 244, 159, 147, 248, 69, 46, 66, 41, 148, 255, 243, 152, 37, 78, 61, 86, 235, 128, 140, 231, 90, 49, 188, 215, 106, 1, 13, 102, 219, 176, 195, 168, 21, 126, 114, 25, 164, 207, 124, 23, 170, 193, 205, 166, 27, 112, 3, 104, 213, 190, 178, 217, 100, 15, 130, 233, 84, 63, 51, 88, 229, 142, 253, 150, 43, 64, 76, 39, 154, 241, 157, 246, 75, 32, 44, 71, 250, 145, 226, 137, 52, 95, 83, 56, 133, 238, 99, 8, 181, 222, 210, 185, 4, 111, 28, 119, 202, 161, 173, 198, 123, 16, ],
[0, 108, 216, 180, 173, 193, 117, 25, 71, 43, 159, 243, 234, 134, 50, 94, 142, 226, 86, 58, 35, 79, 251, 151, 201, 165, 17, 125, 100, 8, 188, 208, 1, 109, 217, 181, 172, 192, 116, 24, 70, 42, 158, 242, 235, 135, 51, 95, 143, 227, 87, 59, 34, 78, 250, 150, 200, 164, 16, 124, 101, 9, 189, 209, 2, 110, 218, 182, 175, 195, 119, 27, 69, 41, 157, 241, 232, 132, 48, 92, 140, 224, 84, 56, 33, 77, 249, 149, 203, 167, 19, 127, 102, 10, 190, 210, 3, 111, 219, 183, 174, 194, 118, 26, 68, 40, 156, 240, 233, 133, 49, 93, 141, 225, 85, 57, 32, 76, 248, 148, 202, 166, 18, 126, 103, 11, 191, 211, 4, 104, 220, 176, 169, 197, 113, 29, 67, 47, 155, 247, 238, 130, 54, 90, 138, 230, 82, 62, 39, 75, 255, 147, 205, 161, 21, 121, 96, 12, 184, 212, 5, 105, 221, 177, 168, 196, 112, 28, 66, 46, 154, 246, 239, 131, 55, 91, 139, 231, 83, 63, 38, 74, 254, 146, 204, 160, 20, 120, 97, 13, 185, 213, 6, 106, 222, 178, 171, 199, 115, 31, 65, 45, 153, 245, 236, 128, 52, 88, 136, 228, 80, 60, 37, 73, 253, 145, 207, 163, 23, 123, 98, 14, 186, 214, 7, 107, 223, 179, 170, 198, 114, 30, 64, 44, 152, 244, 237, 129, 53, 89, 137, 229, 81, 61, 36, 72, 252, 144, 206, 162, 22, 122, 99, 15, 187, 215, ],
[0, 109, 218, 183, 169, 196, 115, 30, 79, 34, 149, 248, 230, 139, 60, 81, 158, 243, 68, 41, 55, 90, 237, 128, 209, 188, 11, 102, 120, 21, 162, 207, 33, 76, 251, 150, 136, 229, 82, 63, 110, 3, 180, 217, 199, 170, 29, 112, 191, 210, 101, 8, 22, 123, 204, 161, 240, 157, 42, 71, 89, 52, 131, 238, 66, 47, 152, 245, 235, 134, 49, 92, 13, 96, 215, 186, 164, 201, 126, 19, 220, 177, 6, 107, 117, 24, 175, 194, 147, 254, 73, 36, 58, 87, 224, 141, 99, 14, 185, 212, 202, 167, 16, 125, 44, 65, 246, 155, 133, 232, 95, 50, 253, 144, 39, 74, 84, 57, 142, 227, 178, 223, 104, 5, 27, 118, 193, 172, 132, 233, 94, 51, 45, 64, 247, 154, 203, 166, 17, 124, 98, 15, 184, 213, 26, 119, 192, 173, 179, 222, 105, 4, 85, 56, 143, 226, 252, 145, 38, 75, 165, 200, 127, 18, 12, 97, 214, 187, 234, 135, 48, 93, 67, 46, 153, 244, 59, 86, 225, 140, 146, 255, 72, 37, 116, 25, 174, 195, 221, 176, 7, 106, 198, 171, 28, 113, 111, 2, 181, 216, 137, 228, 83, 62, 32, 77, 250, 151, 88, 53, 130, 239, 241, 156, 43, 70, 23, 122, 205, 160, 190, 211, 100, 9, 231, 138, 61, 80, 78, 35, 148, 249, 168, 197, 114, 31, 1, 108, 219, 182, 121, 20, 163, 206, 208, 189, 10, 103, 54, 91, 236, 129, 159, 242, 69, 40, ],
[0, 110, 220, 178, 165, 203, 121, 23, 87, 57, 139, 229, 242, 156, 46, 64, 174, 192, 114, 28, 11, 101, 215, 185, 249, 151, 37, 75, 92, 50, 128, 238, 65, 47, 157, 243, 228, 138, 56, 86, 22, 120, 202, 164, 179, 221, 111, 1, 239, 129, 51, 93, 74, 36, 150, 248, 184, 214, 100, 10, 29, 115, 193, 175, 130, 236, 94, 48, 39, 73, 251, 149, 213, 187, 9, 103, 112, 30, 172, 194, 44, 66, 240, 158, 137, 231, 85, 59, 123, 21, 167, 201, 222, 176, 2, 108, 195, 173, 31, 113, 102, 8, 186, 212, 148, 250, 72, 38, 49, 95, 237, 131, 109, 3, 177, 223, 200, 166, 20, 122, 58, 84, 230, 136, 159, 241, 67, 45, 25, 119, 197, 171, 188, 210, 96, 14, 78, 32, 146, 252, 235, 133, 55, 89, 183, 217, 107, 5, 18, 124, 206, 160, 224, 142, 60, 82, 69, 43, 153, 247, 88, 54, 132, 234, 253, 147, 33, 79, 15, 97, 211, 189, 170, 196, 118, 24, 246, 152, 42, 68, 83, 61, 143, 225, 161, 207, 125, 19, 4, 106, 216, 182, 155, 245, 71, 41, 62, 80, 226, 140, 204, 162, 16, 126, 105, 7, 181, 219, 53, 91, 233, 135, 144, 254, 76, 34, 98, 12, 190, 208, 199, 169, 27, 117, 218, 180, 6, 104, 127, 17, 163, 205, 141, 227, 81, 63, 40, 70, 244, 154, 116, 26, 168, 198, 209, 191, 13, 99, 35, 77, 255, 145, 134, 232, 90, 52, ],
[0, 111, 222, 177, 161, 206, 127, 16, 95, 48, 129, 238, 254, 145, 32, 79, 190, 209, 96, 15, 31, 112, 193, 174, 225, 142, 63, 80, 64, 47, 158, 241, 97, 14, 191, 208, 192, 175, 30, 113, 62, 81, 224, 143, 159, 240, 65, 46, 223, 176, 1, 110, 126, 17, 160, 207, 128, 239, 94, 49, 33, 78, 255, 144, 194, 173, 28, 115, 99, 12, 189, 210, 157, 242, 67, 44, 60, 83, 226, 141, 124, 19, 162, 205, 221, 178, 3, 108, 35, 76, 253, 146, 130, 237, 92, 51, 163, 204, 125, 18, 2, 109, 220, 179, 252, 147, 34, 77, 93, 50, 131, 236, 29, 114, 195, 172, 188, 211, 98, 13, 66, 45, 156, 243, 227, 140, 61, 82, 153, 246, 71, 40, 56, 87, 230, 137, 198, 169, 24, 119, 103, 8, 185, 214, 39, 72, 249, 150, 134, 233, 88, 55, 120, 23, 166, 201, 217, 182, 7, 104, 248, 151, 38, 73, 89, 54, 135, 232, 167, 200, 121, 22, 6, 105, 216, 183, 70, 41, 152, 247, 231, 136, 57, 86, 25, 118, 199, 168, 184, 215, 102, 9, 91, 52, 133, 234, 250, 149, 36, 75, 4, 107, 218, 181, 165, 202, 123, 20, 229, 138, 59, 84, 68, 43, 154, 245, 186, 213, 100, 11, 27, 116, 197, 170, 58, 85, 228, 139, 155, 244, 69, 42, 101, 10, 187, 212, 196, 171, 26, 117, 132, 235, 90, 53, 37, 74, 251, 148, 219, 180, 5, 106, 122, 21, 164, 203, ],
[0, 112, 224, 144, 221, 173, 61, 77, 167, 215, 71, 55, 122, 10, 154, 234, 83, 35, 179, 195, 142, 254, 110, 30, 244, 132, 20, 100, 41, 89, 201, 185, 166, 214, 70, 54, 123, 11, 155, 235, 1, 113, 225, 145, 220, 172, 60, 76, 245, 133, 21, 101, 40, 88, 200, 184, 82, 34, 178, 194, 143, 255, 111, 31, 81, 33, 177, 193, 140, 252, 108, 28, 246, 134, 22, 102, 43, 91, 203, 187, 2, 114, 226, 146, 223, 175, 63, 79, 165, 213, 69, 53, 120, 8, 152, 232, 247, 135, 23, 103, 42, 90, 202, 186, 80, 32, 176, 192, 141, 253, 109, 29, 164, 212, 68, 52, 121, 9, 153, 233, 3, 115, 227, 147, 222, 174, 62, 78, 162, 210, 66, 50, 127, 15, 159, 239, 5, 117, 229, 149, 216, 168, 56, 72, 241, 129, 17, 97, 44, 92, 204, 188, 86, 38, 182, 198, 139, 251, 107, 27, 4, 116, 228, 148, 217, 169, 57, 73, 163, 211, 67, 51, 126, 14, 158, 238, 87, 39, 183, 199, 138, 250, 106, 26, 240, 128, 16, 96, 45, 93, 205, 189, 243, 131, 19, 99, 46, 94, 206, 190, 84, 36, 180, 196, 137, 249, 105, 25, 160, 208, 64, 48, 125, 13, 157, 237, 7, 119, 231, 151, 218, 170, 58, 74, 85, 37, 181, 197, 136, 248, 104, 24, 242, 130, 18, 98, 47, 95, 207, 191, 6, 118, 230, 150, 219, 171, 59, 75, 161, 209, 65, 49, 124, 12, 156, 236, ],
[0, 113, 226, 147, 217, 168, 59, 74, 175, 222, 77, 60, 118, 7, 148, 229, 67, 50, 161, 208, 154, 235, 120, 9, 236, 157, 14, 127, 53, 68, 215, 166, 134, 247, 100, 21, 95, 46, 189, 204, 41, 88, 203, 186, 240, 129, 18, 99, 197, 180, 39, 86, 28, 109, 254, 143, 106, 27, 136, 249, 179, 194, 81, 32, 17, 96, 243, 130, 200, 185, 42, 91, 190, 207, 92, 45, 103, 22, 133, 244, 82, 35, 176, 193, 139, 250, 105, 24, 253, 140, 31, 110, 36, 85, 198, 183, 151, 230, 117, 4, 78, 63, 172, 221, 56, 73, 218, 171, 225, 144, 3, 114, 212, 165, 54, 71, 13, 124, 239, 158, 123, 10, 153, 232, 162, 211, 64, 49, 34, 83, 192, 177, 251, 138, 25, 104, 141, 252, 111, 30, 84, 37, 182, 199, 97, 16, 131, 242, 184, 201, 90, 43, 206, 191, 44, 93, 23, 102, 245, 132, 164, 213, 70, 55, 125, 12, 159, 238, 11, 122, 233, 152, 210, 163, 48, 65, 231, 150, 5, 116, 62, 79, 220, 173, 72, 57, 170, 219, 145, 224, 115, 2, 51, 66, 209, 160, 234, 155, 8, 121, 156, 237, 126, 15, 69, 52, 167, 214, 112, 1, 146, 227, 169, 216, 75, 58, 223, 174, 61, 76, 6, 119, 228, 149, 181, 196, 87, 38, 108, 29, 142, 255, 26, 107, 248, 137, 195, 178, 33, 80, 246, 135, 20, 101, 47, 94, 205, 188, 89, 40, 187, 202, 128, 241, 98, 19, ],
[0, 114, 228, 150, 213, 167, 49, 67, 183, 197, 83, 33, 98, 16, 134, 244, 115, 1, 151, 229, 166, 212, 66, 48, 196, 182, 32, 82, 17, 99, 245, 135, 230, 148, 2, 112, 51, 65, 215, 165, 81, 35, 181, 199, 132, 246, 96, 18, 149, 231, 113, 3, 64, 50, 164, 214, 34, 80, 198, 180, 247, 133, 19, 97, 209, 163, 53, 71, 4, 118, 224, 146, 102, 20, 130, 240, 179, 193, 87, 37, 162, 208, 70, 52, 119, 5, 147, 225, 21, 103, 241, 131, 192, 178, 36, 86, 55, 69, 211, 161, 226, 144, 6, 116, 128, 242, 100, 22, 85, 39, 177, 195, 68, 54, 160, 210, 145, 227, 117, 7, 243, 129, 23, 101, 38, 84, 194, 176, 191, 205, 91, 41, 106, 24, 142, 252, 8, 122, 236, 158, 221, 175, 57, 75, 204, 190, 40, 90, 25, 107, 253, 143, 123, 9, 159, 237, 174, 220, 74, 56, 89, 43, 189, 207, 140, 254, 104, 26, 238, 156, 10, 120, 59, 73, 223, 173, 42, 88, 206, 188, 255, 141, 27, 105, 157, 239, 121, 11, 72, 58, 172, 222, 110, 28, 138, 248, 187, 201, 95, 45, 217, 171, 61, 79, 12, 126, 232, 154, 29, 111, 249, 139, 200, 186, 44, 94, 170, 216, 78, 60, 127, 13, 155, 233, 136, 250, 108, 30, 93, 47, 185, 203, 63, 77, 219, 169, 234, 152, 14, 124, 251, 137, 31, 109, 46, 92, 202, 184, 76, 62, 168, 218, 153, 235, 125, 15, ],
[0, 115, 230, 149, 209, 162, 55, 68, 191, 204, 89, 42, 110, 29, 136, 251, 99, 16, 133, 246, 178, 193, 84, 39, 220, 175, 58, 73, 13, 126, 235, 152, 198, 181, 32, 83, 23, 100, 241, 130, 121, 10, 159, 236, 168, 219, 78, 61, 165, 214, 67, 48, 116, 7, 146, 225, 26, 105, 252, 143, 203, 184, 45, 94, 145, 226, 119, 4, 64, 51, 166, 213, 46, 93, 200, 187, 255, 140, 25, 106, 242, 129, 20, 103, 35, 80, 197, 182, 77, 62, 171, 216, 156, 239, 122, 9, 87, 36, 177, 194, 134, 245, 96, 19, 232, 155, 14, 125, 57, 74, 223, 172, 52, 71, 210, 161, 229, 150, 3, 112, 139, 248, 109, 30, 90, 41, 188, 207, 63, 76, 217, 170, 238, 157, 8, 123, 128, 243, 102, 21, 81, 34, 183, 196, 92, 47, 186, 201, 141, 254, 107, 24, 227, 144, 5, 118, 50, 65, 212, 167, 249, 138, 31, 108, 40, 91, 206, 189, 70, 53, 160, 211, 151, 228, 113, 2, 154, 233, 124, 15, 75, 56, 173, 222, 37, 86, 195, 176, 244, 135, 18, 97, 174, 221, 72, 59, 127, 12, 153, 234, 17, 98, 247, 132, 192, 179, 38, 85, 205, 190, 43, 88, 28, 111, 250, 137, 114, 1, 148, 231, 163, 208, 69, 54, 104, 27, 142, 253, 185, 202, 95, 44, 215, 164, 49, 66, 6, 117, 224, 147, 11, 120, 237, 158, 218, 169, 60, 79, 180, 199, 82, 33, 101, 22, 131, 240, ],
[0, 116, 232, 156, 205, 185, 37, 81, 135, 243, 111, 27, 74, 62, 162, 214, 19, 103, 251, 143, 222, 170, 54, 66, 148, 224, 124, 8, 89, 45, 177, 197, 38, 82, 206, 186, 235, 159, 3, 119, 161, 213, 73, 61, 108, 24, 132, 240, 53, 65, 221, 169, 248, 140, 16, 100, 178, 198, 90, 46, 127, 11, 151, 227, 76, 56, 164, 208, 129, 245, 105, 29, 203, 191, 35, 87, 6, 114, 238, 154, 95, 43, 183, 195, 146, 230, 122, 14, 216, 172, 48, 68, 21, 97, 253, 137, 106, 30, 130, 246, 167, 211, 79, 59, 237, 153, 5, 113, 32, 84, 200, 188, 121, 13, 145, 229, 180, 192, 92, 40, 254, 138, 22, 98, 51, 71, 219, 175, 152, 236, 112, 4, 85, 33, 189, 201, 31, 107, 247, 131, 210, 166, 58, 78, 139, 255, 99, 23, 70, 50, 174, 218, 12, 120, 228, 144, 193, 181, 41, 93, 190, 202, 86, 34, 115, 7, 155, 239, 57, 77, 209, 165, 244, 128, 28, 104, 173, 217, 69, 49, 96, 20, 136, 252, 42, 94, 194, 182, 231, 147, 15, 123, 212, 160, 60, 72, 25, 109, 241, 133, 83, 39, 187, 207, 158, 234, 118, 2, 199, 179, 47, 91, 10, 126, 226, 150, 64, 52, 168, 220, 141, 249, 101, 17, 242, 134, 26, 110, 63, 75, 215, 163, 117, 1, 157, 233, 184, 204, 80, 36, 225, 149, 9, 125, 44, 88, 196, 176, 102, 18, 142, 250, 171, 223, 67, 55, ],
[0, 117, 234, 159, 201, 188, 35, 86, 143, 250, 101, 16, 70, 51, 172, 217, 3, 118, 233, 156, 202, 191, 32, 85, 140, 249, 102, 19, 69, 48, 175, 218, 6, 115, 236, 153, 207, 186, 37, 80, 137, 252, 99, 22, 64, 53, 170, 223, 5, 112, 239, 154, 204, 185, 38, 83, 138, 255, 96, 21, 67, 54, 169, 220, 12, 121, 230, 147, 197, 176, 47, 90, 131, 246, 105, 28, 74, 63, 160, 213, 15, 122, 229, 144, 198, 179, 44, 89, 128, 245, 106, 31, 73, 60, 163, 214, 10, 127, 224, 149, 195, 182, 41, 92, 133, 240, 111, 26, 76, 57, 166, 211, 9, 124, 227, 150, 192, 181, 42, 95, 134, 243, 108, 25, 79, 58, 165, 208, 24, 109, 242, 135, 209, 164, 59, 78, 151, 226, 125, 8, 94, 43, 180, 193, 27, 110, 241, 132, 210, 167, 56, 77, 148, 225, 126, 11, 93, 40, 183, 194, 30, 107, 244, 129, 215, 162, 61, 72, 145, 228, 123, 14, 88, 45, 178, 199, 29, 104, 247, 130, 212, 161, 62, 75, 146, 231, 120, 13, 91, 46, 177, 196, 20, 97, 254, 139, 221, 168, 55, 66, 155, 238, 113, 4, 82, 39, 184, 205, 23, 98, 253, 136, 222, 171, 52, 65, 152, 237, 114, 7, 81, 36, 187, 206, 18, 103, 248, 141, 219, 174, 49, 68, 157, 232, 119, 2, 84, 33, 190, 203, 17, 100, 251, 142, 216, 173, 50, 71, 158, 235, 116, 1, 87, 34, 189, 200, ],
[0, 118, 236, 154, 197, 179, 41, 95, 151, 225, 123, 13, 82, 36, 190, 200, 51, 69, 223, 169, 246, 128, 26, 108, 164, 210, 72, 62, 97, 23, 141, 251, 102, 16, 138, 252, 163, 213, 79, 57, 241, 135, 29, 107, 52, 66, 216, 174, 85, 35, 185, 207, 144, 230, 124, 10, 194, 180, 46, 88, 7, 113, 235, 157, 204, 186, 32, 86, 9, 127, 229, 147, 91, 45, 183, 193, 158, 232, 114, 4, 255, 137, 19, 101, 58, 76, 214, 160, 104, 30, 132, 242, 173, 219, 65, 55, 170, 220, 70, 48, 111, 25, 131, 245, 61, 75, 209, 167, 248, 142, 20, 98, 153, 239, 117, 3, 92, 42, 176, 198, 14, 120, 226, 148, 203, 189, 39, 81, 133, 243, 105, 31, 64, 54, 172, 218, 18, 100, 254, 136, 215, 161, 59, 77, 182, 192, 90, 44, 115, 5, 159, 233, 33, 87, 205, 187, 228, 146, 8, 126, 227, 149, 15, 121, 38, 80, 202, 188, 116, 2, 152, 238, 177, 199, 93, 43, 208, 166, 60, 74, 21, 99, 249, 143, 71, 49, 171, 221, 130, 244, 110, 24, 73, 63, 165, 211, 140, 250, 96, 22, 222, 168, 50, 68, 27, 109, 247, 129, 122, 12, 150, 224, 191, 201, 83, 37, 237, 155, 1, 119, 40, 94, 196, 178, 47, 89, 195, 181, 234, 156, 6, 112, 184, 206, 84, 34, 125, 11, 145, 231, 28, 106, 240, 134, 217, 175, 53, 67, 139, 253, 103, 17, 78, 56, 162, 212, ],
[0, 119, 238, 153, 193, 182, 47, 88, 159, 232, 113, 6, 94, 41, 176, 199, 35, 84, 205, 186, 226, 149, 12, 123, 188, 203, 82, 37, 125, 10, 147, 228, 70, 49, 168, 223, 135, 240, 105, 30, 217, 174, 55, 64, 24, 111, 246, 129, 101, 18, 139, 252, 164, 211, 74, 61, 250, 141, 20, 99, 59, 76, 213, 162, 140, 251, 98, 21, 77, 58, 163, 212, 19, 100, 253, 138, 210, 165, 60, 75, 175, 216, 65, 54, 110, 25, 128, 247, 48, 71, 222, 169, 241, 134, 31, 104, 202, 189, 36, 83, 11, 124, 229, 146, 85, 34, 187, 204, 148, 227, 122, 13, 233, 158, 7, 112, 40, 95, 198, 177, 118, 1, 152, 239, 183, 192, 89, 46, 5, 114, 235, 156, 196, 179, 42, 93, 154, 237, 116, 3, 91, 44, 181, 194, 38, 81, 200, 191, 231, 144, 9, 126, 185, 206, 87, 32, 120, 15, 150, 225, 67, 52, 173, 218, 130, 245, 108, 27, 220, 171, 50, 69, 29, 106, 243, 132, 96, 23, 142, 249, 161, 214, 79, 56, 255, 136, 17, 102, 62, 73, 208, 167, 137, 254, 103, 16, 72, 63, 166, 209, 22, 97, 248, 143, 215, 160, 57, 78, 170, 221, 68, 51, 107, 28, 133, 242, 53, 66, 219, 172, 244, 131, 26, 109, 207, 184, 33, 86, 14, 121, 224, 151, 80, 39, 190, 201, 145, 230, 127, 8, 236, 155, 2, 117, 45, 90, 195, 180, 115, 4, 157, 234, 178, 197, 92, 43, ],
[0, 120, 240, 136, 253, 133, 13, 117, 231, 159, 23, 111, 26, 98, 234, 146, 211, 171, 35, 91, 46, 86, 222, 166, 52, 76, 196, 188, 201, 177, 57, 65, 187, 195, 75, 51, 70, 62, 182, 206, 92, 36, 172, 212, 161, 217, 81, 41, 104, 16, 152, 224, 149, 237, 101, 29, 143, 247, 127, 7, 114, 10, 130, 250, 107, 19, 155, 227, 150, 238, 102, 30, 140, 244, 124, 4, 113, 9, 129, 249, 184, 192, 72, 48, 69, 61, 181, 205, 95, 39, 175, 215, 162, 218, 82, 42, 208, 168, 32, 88, 45, 85, 221, 165, 55, 79, 199, 191, 202, 178, 58, 66, 3, 123, 243, 139, 254, 134, 14, 118, 228, 156, 20, 108, 25, 97, 233, 145, 214, 174, 38, 94, 43, 83, 219, 163, 49, 73, 193, 185, 204, 180, 60, 68, 5, 125, 245, 141, 248, 128, 8, 112, 226, 154, 18, 106, 31, 103, 239, 151, 109, 21, 157, 229, 144, 232, 96, 24, 138, 242, 122, 2, 119, 15, 135, 255, 190, 198, 78, 54, 67, 59, 179, 203, 89, 33, 169, 209, 164, 220, 84, 44, 189, 197, 77, 53, 64, 56, 176, 200, 90, 34, 170, 210, 167, 223, 87, 47, 110, 22, 158, 230, 147, 235, 99, 27, 137, 241, 121, 1, 116, 12, 132, 252, 6, 126, 246, 142, 251, 131, 11, 115, 225, 153, 17, 105, 28, 100, 236, 148, 213, 173, 37, 93, 40, 80, 216, 160, 50, 74, 194, 186, 207, 183, 63, 71, ],
[0, 121, 242, 139, 249, 128, 11, 114, 239, 150, 29, 100, 22, 111, 228, 157, 195, 186, 49, 72, 58, 67, 200, 177, 44, 85, 222, 167, 213, 172, 39, 94, 155, 226, 105, 16, 98, 27, 144, 233, 116, 13, 134, 255, 141, 244, 127, 6, 88, 33, 170, 211, 161, 216, 83, 42, 183, 206, 69, 60, 78, 55, 188, 197, 43, 82, 217, 160, 210, 171, 32, 89, 196, 189, 54, 79, 61, 68, 207, 182, 232, 145, 26, 99, 17, 104, 227, 154, 7, 126, 245, 140, 254, 135, 12, 117, 176, 201, 66, 59, 73, 48, 187, 194, 95, 38, 173, 212, 166, 223, 84, 45, 115, 10, 129, 248, 138, 243, 120, 1, 156, 229, 110, 23, 101, 28, 151, 238, 86, 47, 164, 221, 175, 214, 93, 36, 185, 192, 75, 50, 64, 57, 178, 203, 149, 236, 103, 30, 108, 21, 158, 231, 122, 3, 136, 241, 131, 250, 113, 8, 205, 180, 63, 70, 52, 77, 198, 191, 34, 91, 208, 169, 219, 162, 41, 80, 14, 119, 252, 133, 247, 142, 5, 124, 225, 152, 19, 106, 24, 97, 234, 147, 125, 4, 143, 246, 132, 253, 118, 15, 146, 235, 96, 25, 107, 18, 153, 224, 190, 199, 76, 53, 71, 62, 181, 204, 81, 40, 163, 218, 168, 209, 90, 35, 230, 159, 20, 109, 31, 102, 237, 148, 9, 112, 251, 130, 240, 137, 2, 123, 37, 92, 215, 174, 220, 165, 46, 87, 202, 179, 56, 65, 51, 74, 193, 184, ],
[0, 122, 244, 142, 245, 143, 1, 123, 247, 141, 3, 121, 2, 120, 246, 140, 243, 137, 7, 125, 6, 124, 242, 136, 4, 126, 240, 138, 241, 139, 5, 127, 251, 129, 15, 117, 14, 116, 250, 128, 12, 118, 248, 130, 249, 131, 13, 119, 8, 114, 252, 134, 253, 135, 9, 115, 255, 133, 11, 113, 10, 112, 254, 132, 235, 145, 31, 101, 30, 100, 234, 144, 28, 102, 232, 146, 233, 147, 29, 103, 24, 98, 236, 150, 237, 151, 25, 99, 239, 149, 27, 97, 26, 96, 238, 148, 16, 106, 228, 158, 229, 159, 17, 107, 231, 157, 19, 105, 18, 104, 230, 156, 227, 153, 23, 109, 22, 108, 226, 152, 20, 110, 224, 154, 225, 155, 21, 111, 203, 177, 63, 69, 62, 68, 202, 176, 60, 70, 200, 178, 201, 179, 61, 71, 56, 66, 204, 182, 205, 183, 57, 67, 207, 181, 59, 65, 58, 64, 206, 180, 48, 74, 196, 190, 197, 191, 49, 75, 199, 189, 51, 73, 50, 72, 198, 188, 195, 185, 55, 77, 54, 76, 194, 184, 52, 78, 192, 186, 193, 187, 53, 79, 32, 90, 212, 174, 213, 175, 33, 91, 215, 173, 35, 89, 34, 88, 214, 172, 211, 169, 39, 93, 38, 92, 210, 168, 36, 94, 208, 170, 209, 171, 37, 95, 219, 161, 47, 85, 46, 84, 218, 160, 44, 86, 216, 162, 217, 163, 45, 87, 40, 82, 220, 166, 221, 167, 41, 83, 223, 165, 43, 81, 42, 80, 222, 164, ],
[0, 123, 246, 141, 241, 138, 7, 124, 255, 132, 9, 114, 14, 117, 248, 131, 227, 152, 21, 110, 18, 105, 228, 159, 28, 103, 234, 145, 237, 150, 27, 96, 219, 160, 45, 86, 42, 81, 220, 167, 36, 95, 210, 169, 213, 174, 35, 88, 56, 67, 206, 181, 201, 178, 63, 68, 199, 188, 49, 74, 54, 77, 192, 187, 171, 208, 93, 38, 90, 33, 172, 215, 84, 47, 162, 217, 165, 222, 83, 40, 72, 51, 190, 197, 185, 194, 79, 52, 183, 204, 65, 58, 70, 61, 176, 203, 112, 11, 134, 253, 129, 250, 119, 12, 143, 244, 121, 2, 126, 5, 136, 243, 147, 232, 101, 30, 98, 25, 148, 239, 108, 23, 154, 225, 157, 230, 107, 16, 75, 48, 189, 198, 186, 193, 76, 55, 180, 207, 66, 57, 69, 62, 179, 200, 168, 211, 94, 37, 89, 34, 175, 212, 87, 44, 161, 218, 166, 221, 80, 43, 144, 235, 102, 29, 97, 26, 151, 236, 111, 20, 153, 226, 158, 229, 104, 19, 115, 8, 133, 254, 130, 249, 116, 15, 140, 247, 122, 1, 125, 6, 139, 240, 224, 155, 22, 109, 17, 106, 231, 156, 31, 100, 233, 146, 238, 149, 24, 99, 3, 120, 245, 142, 242, 137, 4, 127, 252, 135, 10, 113, 13, 118, 251, 128, 59, 64, 205, 182, 202, 177, 60, 71, 196, 191, 50, 73, 53, 78, 195, 184, 216, 163, 46, 85, 41, 82, 223, 164, 39, 92, 209, 170, 214, 173, 32, 91, ],
[0, 124, 248, 132, 237, 145, 21, 105, 199, 187, 63, 67, 42, 86, 210, 174, 147, 239, 107, 23, 126, 2, 134, 250, 84, 40, 172, 208, 185, 197, 65, 61, 59, 71, 195, 191, 214, 170, 46, 82, 252, 128, 4, 120, 17, 109, 233, 149, 168, 212, 80, 44, 69, 57, 189, 193, 111, 19, 151, 235, 130, 254, 122, 6, 118, 10, 142, 242, 155, 231, 99, 31, 177, 205, 73, 53, 92, 32, 164, 216, 229, 153, 29, 97, 8, 116, 240, 140, 34, 94, 218, 166, 207, 179, 55, 75, 77, 49, 181, 201, 160, 220, 88, 36, 138, 246, 114, 14, 103, 27, 159, 227, 222, 162, 38, 90, 51, 79, 203, 183, 25, 101, 225, 157, 244, 136, 12, 112, 236, 144, 20, 104, 1, 125, 249, 133, 43, 87, 211, 175, 198, 186, 62, 66, 127, 3, 135, 251, 146, 238, 106, 22, 184, 196, 64, 60, 85, 41, 173, 209, 215, 171, 47, 83, 58, 70, 194, 190, 16, 108, 232, 148, 253, 129, 5, 121, 68, 56, 188, 192, 169, 213, 81, 45, 131, 255, 123, 7, 110, 18, 150, 234, 154, 230, 98, 30, 119, 11, 143, 243, 93, 33, 165, 217, 176, 204, 72, 52, 9, 117, 241, 141, 228, 152, 28, 96, 206, 178, 54, 74, 35, 95, 219, 167, 161, 221, 89, 37, 76, 48, 180, 200, 102, 26, 158, 226, 139, 247, 115, 15, 50, 78, 202, 182, 223, 163, 39, 91, 245, 137, 13, 113, 24, 100, 224, 156, ],
[0, 125, 250, 135, 233, 148, 19, 110, 207, 178, 53, 72, 38, 91, 220, 161, 131, 254, 121, 4, 106, 23, 144, 237, 76, 49, 182, 203, 165, 216, 95, 34, 27, 102, 225, 156, 242, 143, 8, 117, 212, 169, 46, 83, 61, 64, 199, 186, 152, 229, 98, 31, 113, 12, 139, 246, 87, 42, 173, 208, 190, 195, 68, 57, 54, 75, 204, 177, 223, 162, 37, 88, 249, 132, 3, 126, 16, 109, 234, 151, 181, 200, 79, 50, 92, 33, 166, 219, 122, 7, 128, 253, 147, 238, 105, 20, 45, 80, 215, 170, 196, 185, 62, 67, 226, 159, 24, 101, 11, 118, 241, 140, 174, 211, 84, 41, 71, 58, 189, 192, 97, 28, 155, 230, 136, 245, 114, 15, 108, 17, 150, 235, 133, 248, 127, 2, 163, 222, 89, 36, 74, 55, 176, 205, 239, 146, 21, 104, 6, 123, 252, 129, 32, 93, 218, 167, 201, 180, 51, 78, 119, 10, 141, 240, 158, 227, 100, 25, 184, 197, 66, 63, 81, 44, 171, 214, 244, 137, 14, 115, 29, 96, 231, 154, 59, 70, 193, 188, 210, 175, 40, 85, 90, 39, 160, 221, 179, 206, 73, 52, 149, 232, 111, 18, 124, 1, 134, 251, 217, 164, 35, 94, 48, 77, 202, 183, 22, 107, 236, 145, 255, 130, 5, 120, 65, 60, 187, 198, 168, 213, 82, 47, 142, 243, 116, 9, 103, 26, 157, 224, 194, 191, 56, 69, 43, 86, 209, 172, 13, 112, 247, 138, 228, 153, 30, 99, ],
[0, 126, 252, 130, 229, 155, 25, 103, 215, 169, 43, 85, 50, 76, 206, 176, 179, 205, 79, 49, 86, 40, 170, 212, 100, 26, 152, 230, 129, 255, 125, 3, 123, 5, 135, 249, 158, 224, 98, 28, 172, 210, 80, 46, 73, 55, 181, 203, 200, 182, 52, 74, 45, 83, 209, 175, 31, 97, 227, 157, 250, 132, 6, 120, 246, 136, 10, 116, 19, 109, 239, 145, 33, 95, 221, 163, 196, 186, 56, 70, 69, 59, 185, 199, 160, 222, 92, 34, 146, 236, 110, 16, 119, 9, 139, 245, 141, 243, 113, 15, 104, 22, 148, 234, 90, 36, 166, 216, 191, 193, 67, 61, 62, 64, 194, 188, 219, 165, 39, 89, 233, 151, 21, 107, 12, 114, 240, 142, 241, 143, 13, 115, 20, 106, 232, 150, 38, 88, 218, 164, 195, 189, 63, 65, 66, 60, 190, 192, 167, 217, 91, 37, 149, 235, 105, 23, 112, 14, 140, 242, 138, 244, 118, 8, 111, 17, 147, 237, 93, 35, 161, 223, 184, 198, 68, 58, 57, 71, 197, 187, 220, 162, 32, 94, 238, 144, 18, 108, 11, 117, 247, 137, 7, 121, 251, 133, 226, 156, 30, 96, 208, 174, 44, 82, 53, 75, 201, 183, 180, 202, 72, 54, 81, 47, 173, 211, 99, 29, 159, 225, 134, 248, 122, 4, 124, 2, 128, 254, 153, 231, 101, 27, 171, 213, 87, 41, 78, 48, 178, 204, 207, 177, 51, 77, 42, 84, 214, 168, 24, 102, 228, 154, 253, 131, 1, 127, ],
[0, 127, 254, 129, 225, 158, 31, 96, 223, 160, 33, 94, 62, 65, 192, 191, 163, 220, 93, 34, 66, 61, 188, 195, 124, 3, 130, 253, 157, 226, 99, 28, 91, 36, 165, 218, 186, 197, 68, 59, 132, 251, 122, 5, 101, 26, 155, 228, 248, 135, 6, 121, 25, 102, 231, 152, 39, 88, 217, 166, 198, 185, 56, 71, 182, 201, 72, 55, 87, 40, 169, 214, 105, 22, 151, 232, 136, 247, 118, 9, 21, 106, 235, 148, 244, 139, 10, 117, 202, 181, 52, 75, 43, 84, 213, 170, 237, 146, 19, 108, 12, 115, 242, 141, 50, 77, 204, 179, 211, 172, 45, 82, 78, 49, 176, 207, 175, 208, 81, 46, 145, 238, 111, 16, 112, 15, 142, 241, 113, 14, 143, 240, 144, 239, 110, 17, 174, 209, 80, 47, 79, 48, 177, 206, 210, 173, 44, 83, 51, 76, 205, 178, 13, 114, 243, 140, 236, 147, 18, 109, 42, 85, 212, 171, 203, 180, 53, 74, 245, 138, 11, 116, 20, 107, 234, 149, 137, 246, 119, 8, 104, 23, 150, 233, 86, 41, 168, 215, 183, 200, 73, 54, 199, 184, 57, 70, 38, 89, 216, 167, 24, 103, 230, 153, 249, 134, 7, 120, 100, 27, 154, 229, 133, 250, 123, 4, 187, 196, 69, 58, 90, 37, 164, 219, 156, 227, 98, 29, 125, 2, 131, 252, 67, 60, 189, 194, 162, 221, 92, 35, 63, 64, 193, 190, 222, 161, 32, 95, 224, 159, 30, 97, 1, 126, 255, 128, ],
[0, 128, 29, 157, 58, 186, 39, 167, 116, 244, 105, 233, 78, 206, 83, 211, 232, 104, 245, 117, 210, 82, 207, 79, 156, 28, 129, 1, 166, 38, 187, 59, 205, 77, 208, 80, 247, 119, 234, 106, 185, 57, 164, 36, 131, 3, 158, 30, 37, 165, 56, 184, 31, 159, 2, 130, 81, 209, 76, 204, 107, 235, 118, 246, 135, 7, 154, 26, 189, 61, 160, 32, 243, 115, 238, 110, 201, 73, 212, 84, 111, 239, 114, 242, 85, 213, 72, 200, 27, 155, 6, 134, 33, 161, 60, 188, 74, 202, 87, 215, 112, 240, 109, 237, 62, 190, 35, 163, 4, 132, 25, 153, 162, 34, 191, 63, 152, 24, 133, 5, 214, 86, 203, 75, 236, 108, 241, 113, 19, 147, 14, 142, 41, 169, 52, 180, 103, 231, 122, 250, 93, 221, 64, 192, 251, 123, 230, 102, 193, 65, 220, 92, 143, 15, 146, 18, 181, 53, 168, 40, 222, 94, 195, 67, 228, 100, 249, 121, 170, 42, 183, 55, 144, 16, 141, 13, 54, 182, 43, 171, 12, 140, 17, 145, 66, 194, 95, 223, 120, 248, 101, 229, 148, 20, 137, 9, 174, 46, 179, 51, 224, 96, 253, 125, 218, 90, 199, 71, 124, 252, 97, 225, 70, 198, 91, 219, 8, 136, 21, 149, 50, 178, 47, 175, 89, 217, 68, 196, 99, 227, 126, 254, 45, 173, 48, 176, 23, 151, 10, 138, 177, 49, 172, 44, 139, 11, 150, 22, 197, 69, 216, 88, 255, 127, 226, 98, ],
[0, 129, 31, 158, 62, 191, 33, 160, 124, 253, 99, 226, 66, 195, 93, 220, 248, 121, 231, 102, 198, 71, 217, 88, 132, 5, 155, 26, 186, 59, 165, 36, 237, 108, 242, 115, 211, 82, 204, 77, 145, 16, 142, 15, 175, 46, 176, 49, 21, 148, 10, 139, 43, 170, 52, 181, 105, 232, 118, 247, 87, 214, 72, 201, 199, 70, 216, 89, 249, 120, 230, 103, 187, 58, 164, 37, 133, 4, 154, 27, 63, 190, 32, 161, 1, 128, 30, 159, 67, 194, 92, 221, 125, 252, 98, 227, 42, 171, 53, 180, 20, 149, 11, 138, 86, 215, 73, 200, 104, 233, 119, 246, 210, 83, 205, 76, 236, 109, 243, 114, 174, 47, 177, 48, 144, 17, 143, 14, 147, 18, 140, 13, 173, 44, 178, 51, 239, 110, 240, 113, 209, 80, 206, 79, 107, 234, 116, 245, 85, 212, 74, 203, 23, 150, 8, 137, 41, 168, 54, 183, 126, 255, 97, 224, 64, 193, 95, 222, 2, 131, 29, 156, 60, 189, 35, 162, 134, 7, 153, 24, 184, 57, 167, 38, 250, 123, 229, 100, 196, 69, 219, 90, 84, 213, 75, 202, 106, 235, 117, 244, 40, 169, 55, 182, 22, 151, 9, 136, 172, 45, 179, 50, 146, 19, 141, 12, 208, 81, 207, 78, 238, 111, 241, 112, 185, 56, 166, 39, 135, 6, 152, 25, 197, 68, 218, 91, 251, 122, 228, 101, 65, 192, 94, 223, 127, 254, 96, 225, 61, 188, 34, 163, 3, 130, 28, 157, ],
[0, 130, 25, 155, 50, 176, 43, 169, 100, 230, 125, 255, 86, 212, 79, 205, 200, 74, 209, 83, 250, 120, 227, 97, 172, 46, 181, 55, 158, 28, 135, 5, 141, 15, 148, 22, 191, 61, 166, 36, 233, 107, 240, 114, 219, 89, 194, 64, 69, 199, 92, 222, 119, 245, 110, 236, 33, 163, 56, 186, 19, 145, 10, 136, 7, 133, 30, 156, 53, 183, 44, 174, 99, 225, 122, 248, 81, 211, 72, 202, 207, 77, 214, 84, 253, 127, 228, 102, 171, 41, 178, 48, 153, 27, 128, 2, 138, 8, 147, 17, 184, 58, 161, 35, 238, 108, 247, 117, 220, 94, 197, 71, 66, 192, 91, 217, 112, 242, 105, 235, 38, 164, 63, 189, 20, 150, 13, 143, 14, 140, 23, 149, 60, 190, 37, 167, 106, 232, 115, 241, 88, 218, 65, 195, 198, 68, 223, 93, 244, 118, 237, 111, 162, 32, 187, 57, 144, 18, 137, 11, 131, 1, 154, 24, 177, 51, 168, 42, 231, 101, 254, 124, 213, 87, 204, 78, 75, 201, 82, 208, 121, 251, 96, 226, 47, 173, 54, 180, 29, 159, 4, 134, 9, 139, 16, 146, 59, 185, 34, 160, 109, 239, 116, 246, 95, 221, 70, 196, 193, 67, 216, 90, 243, 113, 234, 104, 165, 39, 188, 62, 151, 21, 142, 12, 132, 6, 157, 31, 182, 52, 175, 45, 224, 98, 249, 123, 210, 80, 203, 73, 76, 206, 85, 215, 126, 252, 103, 229, 40, 170, 49, 179, 26, 152, 3, 129, ],
[0, 131, 27, 152, 54, 181, 45, 174, 108, 239, 119, 244, 90, 217, 65, 194, 216, 91, 195, 64, 238, 109, 245, 118, 180, 55, 175, 44, 130, 1, 153, 26, 173, 46, 182, 53, 155, 24, 128, 3, 193, 66, 218, 89, 247, 116, 236, 111, 117, 246, 110, 237, 67, 192, 88, 219, 25, 154, 2, 129, 47, 172, 52, 183, 71, 196, 92, 223, 113, 242, 106, 233, 43, 168, 48, 179, 29, 158, 6, 133, 159, 28, 132, 7, 169, 42, 178, 49, 243, 112, 232, 107, 197, 70, 222, 93, 234, 105, 241, 114, 220, 95, 199, 68, 134, 5, 157, 30, 176, 51, 171, 40, 50, 177, 41, 170, 4, 135, 31, 156, 94, 221, 69, 198, 104, 235, 115, 240, 142, 13, 149, 22, 184, 59, 163, 32, 226, 97, 249, 122, 212, 87, 207, 76, 86, 213, 77, 206, 96, 227, 123, 248, 58, 185, 33, 162, 12, 143, 23, 148, 35, 160, 56, 187, 21, 150, 14, 141, 79, 204, 84, 215, 121, 250, 98, 225, 251, 120, 224, 99, 205, 78, 214, 85, 151, 20, 140, 15, 161, 34, 186, 57, 201, 74, 210, 81, 255, 124, 228, 103, 165, 38, 190, 61, 147, 16, 136, 11, 17, 146, 10, 137, 39, 164, 60, 191, 125, 254, 102, 229, 75, 200, 80, 211, 100, 231, 127, 252, 82, 209, 73, 202, 8, 139, 19, 144, 62, 189, 37, 166, 188, 63, 167, 36, 138, 9, 145, 18, 208, 83, 203, 72, 230, 101, 253, 126, ],
[0, 132, 21, 145, 42, 174, 63, 187, 84, 208, 65, 197, 126, 250, 107, 239, 168, 44, 189, 57, 130, 6, 151, 19, 252, 120, 233, 109, 214, 82, 195, 71, 77, 201, 88, 220, 103, 227, 114, 246, 25, 157, 12, 136, 51, 183, 38, 162, 229, 97, 240, 116, 207, 75, 218, 94, 177, 53, 164, 32, 155, 31, 142, 10, 154, 30, 143, 11, 176, 52, 165, 33, 206, 74, 219, 95, 228, 96, 241, 117, 50, 182, 39, 163, 24, 156, 13, 137, 102, 226, 115, 247, 76, 200, 89, 221, 215, 83, 194, 70, 253, 121, 232, 108, 131, 7, 150, 18, 169, 45, 188, 56, 127, 251, 106, 238, 85, 209, 64, 196, 43, 175, 62, 186, 1, 133, 20, 144, 41, 173, 60, 184, 3, 135, 22, 146, 125, 249, 104, 236, 87, 211, 66, 198, 129, 5, 148, 16, 171, 47, 190, 58, 213, 81, 192, 68, 255, 123, 234, 110, 100, 224, 113, 245, 78, 202, 91, 223, 48, 180, 37, 161, 26, 158, 15, 139, 204, 72, 217, 93, 230, 98, 243, 119, 152, 28, 141, 9, 178, 54, 167, 35, 179, 55, 166, 34, 153, 29, 140, 8, 231, 99, 242, 118, 205, 73, 216, 92, 27, 159, 14, 138, 49, 181, 36, 160, 79, 203, 90, 222, 101, 225, 112, 244, 254, 122, 235, 111, 212, 80, 193, 69, 170, 46, 191, 59, 128, 4, 149, 17, 86, 210, 67, 199, 124, 248, 105, 237, 2, 134, 23, 147, 40, 172, 61, 185, ],
[0, 133, 23, 146, 46, 171, 57, 188, 92, 217, 75, 206, 114, 247, 101, 224, 184, 61, 175, 42, 150, 19, 129, 4, 228, 97, 243, 118, 202, 79, 221, 88, 109, 232, 122, 255, 67, 198, 84, 209, 49, 180, 38, 163, 31, 154, 8, 141, 213, 80, 194, 71, 251, 126, 236, 105, 137, 12, 158, 27, 167, 34, 176, 53, 218, 95, 205, 72, 244, 113, 227, 102, 134, 3, 145, 20, 168, 45, 191, 58, 98, 231, 117, 240, 76, 201, 91, 222, 62, 187, 41, 172, 16, 149, 7, 130, 183, 50, 160, 37, 153, 28, 142, 11, 235, 110, 252, 121, 197, 64, 210, 87, 15, 138, 24, 157, 33, 164, 54, 179, 83, 214, 68, 193, 125, 248, 106, 239, 169, 44, 190, 59, 135, 2, 144, 21, 245, 112, 226, 103, 219, 94, 204, 73, 17, 148, 6, 131, 63, 186, 40, 173, 77, 200, 90, 223, 99, 230, 116, 241, 196, 65, 211, 86, 234, 111, 253, 120, 152, 29, 143, 10, 182, 51, 161, 36, 124, 249, 107, 238, 82, 215, 69, 192, 32, 165, 55, 178, 14, 139, 25, 156, 115, 246, 100, 225, 93, 216, 74, 207, 47, 170, 56, 189, 1, 132, 22, 147, 203, 78, 220, 89, 229, 96, 242, 119, 151, 18, 128, 5, 185, 60, 174, 43, 30, 155, 9, 140, 48, 181, 39, 162, 66, 199, 85, 208, 108, 233, 123, 254, 166, 35, 177, 52, 136, 13, 159, 26, 250, 127, 237, 104, 212, 81, 195, 70, ],
[0, 134, 17, 151, 34, 164, 51, 181, 68, 194, 85, 211, 102, 224, 119, 241, 136, 14, 153, 31, 170, 44, 187, 61, 204, 74, 221, 91, 238, 104, 255, 121, 13, 139, 28, 154, 47, 169, 62, 184, 73, 207, 88, 222, 107, 237, 122, 252, 133, 3, 148, 18, 167, 33, 182, 48, 193, 71, 208, 86, 227, 101, 242, 116, 26, 156, 11, 141, 56, 190, 41, 175, 94, 216, 79, 201, 124, 250, 109, 235, 146, 20, 131, 5, 176, 54, 161, 39, 214, 80, 199, 65, 244, 114, 229, 99, 23, 145, 6, 128, 53, 179, 36, 162, 83, 213, 66, 196, 113, 247, 96, 230, 159, 25, 142, 8, 189, 59, 172, 42, 219, 93, 202, 76, 249, 127, 232, 110, 52, 178, 37, 163, 22, 144, 7, 129, 112, 246, 97, 231, 82, 212, 67, 197, 188, 58, 173, 43, 158, 24, 143, 9, 248, 126, 233, 111, 218, 92, 203, 77, 57, 191, 40, 174, 27, 157, 10, 140, 125, 251, 108, 234, 95, 217, 78, 200, 177, 55, 160, 38, 147, 21, 130, 4, 245, 115, 228, 98, 215, 81, 198, 64, 46, 168, 63, 185, 12, 138, 29, 155, 106, 236, 123, 253, 72, 206, 89, 223, 166, 32, 183, 49, 132, 2, 149, 19, 226, 100, 243, 117, 192, 70, 209, 87, 35, 165, 50, 180, 1, 135, 16, 150, 103, 225, 118, 240, 69, 195, 84, 210, 171, 45, 186, 60, 137, 15, 152, 30, 239, 105, 254, 120, 205, 75, 220, 90, ],
[0, 135, 19, 148, 38, 161, 53, 178, 76, 203, 95, 216, 106, 237, 121, 254, 152, 31, 139, 12, 190, 57, 173, 42, 212, 83, 199, 64, 242, 117, 225, 102, 45, 170, 62, 185, 11, 140, 24, 159, 97, 230, 114, 245, 71, 192, 84, 211, 181, 50, 166, 33, 147, 20, 128, 7, 249, 126, 234, 109, 223, 88, 204, 75, 90, 221, 73, 206, 124, 251, 111, 232, 22, 145, 5, 130, 48, 183, 35, 164, 194, 69, 209, 86, 228, 99, 247, 112, 142, 9, 157, 26, 168, 47, 187, 60, 119, 240, 100, 227, 81, 214, 66, 197, 59, 188, 40, 175, 29, 154, 14, 137, 239, 104, 252, 123, 201, 78, 218, 93, 163, 36, 176, 55, 133, 2, 150, 17, 180, 51, 167, 32, 146, 21, 129, 6, 248, 127, 235, 108, 222, 89, 205, 74, 44, 171, 63, 184, 10, 141, 25, 158, 96, 231, 115, 244, 70, 193, 85, 210, 153, 30, 138, 13, 191, 56, 172, 43, 213, 82, 198, 65, 243, 116, 224, 103, 1, 134, 18, 149, 39, 160, 52, 179, 77, 202, 94, 217, 107, 236, 120, 255, 238, 105, 253, 122, 200, 79, 219, 92, 162, 37, 177, 54, 132, 3, 151, 16, 118, 241, 101, 226, 80, 215, 67, 196, 58, 189, 41, 174, 28, 155, 15, 136, 195, 68, 208, 87, 229, 98, 246, 113, 143, 8, 156, 27, 169, 46, 186, 61, 91, 220, 72, 207, 125, 250, 110, 233, 23, 144, 4, 131, 49, 182, 34, 165, ],
[0, 136, 13, 133, 26, 146, 23, 159, 52, 188, 57, 177, 46, 166, 35, 171, 104, 224, 101, 237, 114, 250, 127, 247, 92, 212, 81, 217, 70, 206, 75, 195, 208, 88, 221, 85, 202, 66, 199, 79, 228, 108, 233, 97, 254, 118, 243, 123, 184, 48, 181, 61, 162, 42, 175, 39, 140, 4, 129, 9, 150, 30, 155, 19, 189, 53, 176, 56, 167, 47, 170, 34, 137, 1, 132, 12, 147, 27, 158, 22, 213, 93, 216, 80, 207, 71, 194, 74, 225, 105, 236, 100, 251, 115, 246, 126, 109, 229, 96, 232, 119, 255, 122, 242, 89, 209, 84, 220, 67, 203, 78, 198, 5, 141, 8, 128, 31, 151, 18, 154, 49, 185, 60, 180, 43, 163, 38, 174, 103, 239, 106, 226, 125, 245, 112, 248, 83, 219, 94, 214, 73, 193, 68, 204, 15, 135, 2, 138, 21, 157, 24, 144, 59, 179, 54, 190, 33, 169, 44, 164, 183, 63, 186, 50, 173, 37, 160, 40, 131, 11, 142, 6, 153, 17, 148, 28, 223, 87, 210, 90, 197, 77, 200, 64, 235, 99, 230, 110, 241, 121, 252, 116, 218, 82, 215, 95, 192, 72, 205, 69, 238, 102, 227, 107, 244, 124, 249, 113, 178, 58, 191, 55, 168, 32, 165, 45, 134, 14, 139, 3, 156, 20, 145, 25, 10, 130, 7, 143, 16, 152, 29, 149, 62, 182, 51, 187, 36, 172, 41, 161, 98, 234, 111, 231, 120, 240, 117, 253, 86, 222, 91, 211, 76, 196, 65, 201, ],
[0, 137, 15, 134, 30, 151, 17, 152, 60, 181, 51, 186, 34, 171, 45, 164, 120, 241, 119, 254, 102, 239, 105, 224, 68, 205, 75, 194, 90, 211, 85, 220, 240, 121, 255, 118, 238, 103, 225, 104, 204, 69, 195, 74, 210, 91, 221, 84, 136, 1, 135, 14, 150, 31, 153, 16, 180, 61, 187, 50, 170, 35, 165, 44, 253, 116, 242, 123, 227, 106, 236, 101, 193, 72, 206, 71, 223, 86, 208, 89, 133, 12, 138, 3, 155, 18, 148, 29, 185, 48, 182, 63, 167, 46, 168, 33, 13, 132, 2, 139, 19, 154, 28, 149, 49, 184, 62, 183, 47, 166, 32, 169, 117, 252, 122, 243, 107, 226, 100, 237, 73, 192, 70, 207, 87, 222, 88, 209, 231, 110, 232, 97, 249, 112, 246, 127, 219, 82, 212, 93, 197, 76, 202, 67, 159, 22, 144, 25, 129, 8, 142, 7, 163, 42, 172, 37, 189, 52, 178, 59, 23, 158, 24, 145, 9, 128, 6, 143, 43, 162, 36, 173, 53, 188, 58, 179, 111, 230, 96, 233, 113, 248, 126, 247, 83, 218, 92, 213, 77, 196, 66, 203, 26, 147, 21, 156, 4, 141, 11, 130, 38, 175, 41, 160, 56, 177, 55, 190, 98, 235, 109, 228, 124, 245, 115, 250, 94, 215, 81, 216, 64, 201, 79, 198, 234, 99, 229, 108, 244, 125, 251, 114, 214, 95, 217, 80, 200, 65, 199, 78, 146, 27, 157, 20, 140, 5, 131, 10, 174, 39, 161, 40, 176, 57, 191, 54, ],
[0, 138, 9, 131, 18, 152, 27, 145, 36, 174, 45, 167, 54, 188, 63, 181, 72, 194, 65, 203, 90, 208, 83, 217, 108, 230, 101, 239, 126, 244, 119, 253, 144, 26, 153, 19, 130, 8, 139, 1, 180, 62, 189, 55, 166, 44, 175, 37, 216, 82, 209, 91, 202, 64, 195, 73, 252, 118, 245, 127, 238, 100, 231, 109, 61, 183, 52, 190, 47, 165, 38, 172, 25, 147, 16, 154, 11, 129, 2, 136, 117, 255, 124, 246, 103, 237, 110, 228, 81, 219, 88, 210, 67, 201, 74, 192, 173, 39, 164, 46, 191, 53, 182, 60, 137, 3, 128, 10, 155, 17, 146, 24, 229, 111, 236, 102, 247, 125, 254, 116, 193, 75, 200, 66, 211, 89, 218, 80, 122, 240, 115, 249, 104, 226, 97, 235, 94, 212, 87, 221, 76, 198, 69, 207, 50, 184, 59, 177, 32, 170, 41, 163, 22, 156, 31, 149, 4, 142, 13, 135, 234, 96, 227, 105, 248, 114, 241, 123, 206, 68, 199, 77, 220, 86, 213, 95, 162, 40, 171, 33, 176, 58, 185, 51, 134, 12, 143, 5, 148, 30, 157, 23, 71, 205, 78, 196, 85, 223, 92, 214, 99, 233, 106, 224, 113, 251, 120, 242, 15, 133, 6, 140, 29, 151, 20, 158, 43, 161, 34, 168, 57, 179, 48, 186, 215, 93, 222, 84, 197, 79, 204, 70, 243, 121, 250, 112, 225, 107, 232, 98, 159, 21, 150, 28, 141, 7, 132, 14, 187, 49, 178, 56, 169, 35, 160, 42, ],
[0, 139, 11, 128, 22, 157, 29, 150, 44, 167, 39, 172, 58, 177, 49, 186, 88, 211, 83, 216, 78, 197, 69, 206, 116, 255, 127, 244, 98, 233, 105, 226, 176, 59, 187, 48, 166, 45, 173, 38, 156, 23, 151, 28, 138, 1, 129, 10, 232, 99, 227, 104, 254, 117, 245, 126, 196, 79, 207, 68, 210, 89, 217, 82, 125, 246, 118, 253, 107, 224, 96, 235, 81, 218, 90, 209, 71, 204, 76, 199, 37, 174, 46, 165, 51, 184, 56, 179, 9, 130, 2, 137, 31, 148, 20, 159, 205, 70, 198, 77, 219, 80, 208, 91, 225, 106, 234, 97, 247, 124, 252, 119, 149, 30, 158, 21, 131, 8, 136, 3, 185, 50, 178, 57, 175, 36, 164, 47, 250, 113, 241, 122, 236, 103, 231, 108, 214, 93, 221, 86, 192, 75, 203, 64, 162, 41, 169, 34, 180, 63, 191, 52, 142, 5, 133, 14, 152, 19, 147, 24, 74, 193, 65, 202, 92, 215, 87, 220, 102, 237, 109, 230, 112, 251, 123, 240, 18, 153, 25, 146, 4, 143, 15, 132, 62, 181, 53, 190, 40, 163, 35, 168, 135, 12, 140, 7, 145, 26, 154, 17, 171, 32, 160, 43, 189, 54, 182, 61, 223, 84, 212, 95, 201, 66, 194, 73, 243, 120, 248, 115, 229, 110, 238, 101, 55, 188, 60, 183, 33, 170, 42, 161, 27, 144, 16, 155, 13, 134, 6, 141, 111, 228, 100, 239, 121, 242, 114, 249, 67, 200, 72, 195, 85, 222, 94, 213, ],
[0, 140, 5, 137, 10, 134, 15, 131, 20, 152, 17, 157, 30, 146, 27, 151, 40, 164, 45, 161, 34, 174, 39, 171, 60, 176, 57, 181, 54, 186, 51, 191, 80, 220, 85, 217, 90, 214, 95, 211, 68, 200, 65, 205, 78, 194, 75, 199, 120, 244, 125, 241, 114, 254, 119, 251, 108, 224, 105, 229, 102, 234, 99, 239, 160, 44, 165, 41, 170, 38, 175, 35, 180, 56, 177, 61, 190, 50, 187, 55, 136, 4, 141, 1, 130, 14, 135, 11, 156, 16, 153, 21, 150, 26, 147, 31, 240, 124, 245, 121, 250, 118, 255, 115, 228, 104, 225, 109, 238, 98, 235, 103, 216, 84, 221, 81, 210, 94, 215, 91, 204, 64, 201, 69, 198, 74, 195, 79, 93, 209, 88, 212, 87, 219, 82, 222, 73, 197, 76, 192, 67, 207, 70, 202, 117, 249, 112, 252, 127, 243, 122, 246, 97, 237, 100, 232, 107, 231, 110, 226, 13, 129, 8, 132, 7, 139, 2, 142, 25, 149, 28, 144, 19, 159, 22, 154, 37, 169, 32, 172, 47, 163, 42, 166, 49, 189, 52, 184, 59, 183, 62, 178, 253, 113, 248, 116, 247, 123, 242, 126, 233, 101, 236, 96, 227, 111, 230, 106, 213, 89, 208, 92, 223, 83, 218, 86, 193, 77, 196, 72, 203, 71, 206, 66, 173, 33, 168, 36, 167, 43, 162, 46, 185, 53, 188, 48, 179, 63, 182, 58, 133, 9, 128, 12, 143, 3, 138, 6, 145, 29, 148, 24, 155, 23, 158, 18, ],
[0, 141, 7, 138, 14, 131, 9, 132, 28, 145, 27, 150, 18, 159, 21, 152, 56, 181, 63, 178, 54, 187, 49, 188, 36, 169, 35, 174, 42, 167, 45, 160, 112, 253, 119, 250, 126, 243, 121, 244, 108, 225, 107, 230, 98, 239, 101, 232, 72, 197, 79, 194, 70, 203, 65, 204, 84, 217, 83, 222, 90, 215, 93, 208, 224, 109, 231, 106, 238, 99, 233, 100, 252, 113, 251, 118, 242, 127, 245, 120, 216, 85, 223, 82, 214, 91, 209, 92, 196, 73, 195, 78, 202, 71, 205, 64, 144, 29, 151, 26, 158, 19, 153, 20, 140, 1, 139, 6, 130, 15, 133, 8, 168, 37, 175, 34, 166, 43, 161, 44, 180, 57, 179, 62, 186, 55, 189, 48, 221, 80, 218, 87, 211, 94, 212, 89, 193, 76, 198, 75, 207, 66, 200, 69, 229, 104, 226, 111, 235, 102, 236, 97, 249, 116, 254, 115, 247, 122, 240, 125, 173, 32, 170, 39, 163, 46, 164, 41, 177, 60, 182, 59, 191, 50, 184, 53, 149, 24, 146, 31, 155, 22, 156, 17, 137, 4, 142, 3, 135, 10, 128, 13, 61, 176, 58, 183, 51, 190, 52, 185, 33, 172, 38, 171, 47, 162, 40, 165, 5, 136, 2, 143, 11, 134, 12, 129, 25, 148, 30, 147, 23, 154, 16, 157, 77, 192, 74, 199, 67, 206, 68, 201, 81, 220, 86, 219, 95, 210, 88, 213, 117, 248, 114, 255, 123, 246, 124, 241, 105, 228, 110, 227, 103, 234, 96, 237, ],
[0, 142, 1, 143, 2, 140, 3, 141, 4, 138, 5, 139, 6, 136, 7, 137, 8, 134, 9, 135, 10, 132, 11, 133, 12, 130, 13, 131, 14, 128, 15, 129, 16, 158, 17, 159, 18, 156, 19, 157, 20, 154, 21, 155, 22, 152, 23, 153, 24, 150, 25, 151, 26, 148, 27, 149, 28, 146, 29, 147, 30, 144, 31, 145, 32, 174, 33, 175, 34, 172, 35, 173, 36, 170, 37, 171, 38, 168, 39, 169, 40, 166, 41, 167, 42, 164, 43, 165, 44, 162, 45, 163, 46, 160, 47, 161, 48, 190, 49, 191, 50, 188, 51, 189, 52, 186, 53, 187, 54, 184, 55, 185, 56, 182, 57, 183, 58, 180, 59, 181, 60, 178, 61, 179, 62, 176, 63, 177, 64, 206, 65, 207, 66, 204, 67, 205, 68, 202, 69, 203, 70, 200, 71, 201, 72, 198, 73, 199, 74, 196, 75, 197, 76, 194, 77, 195, 78, 192, 79, 193, 80, 222, 81, 223, 82, 220, 83, 221, 84, 218, 85, 219, 86, 216, 87, 217, 88, 214, 89, 215, 90, 212, 91, 213, 92, 210, 93, 211, 94, 208, 95, 209, 96, 238, 97, 239, 98, 236, 99, 237, 100, 234, 101, 235, 102, 232, 103, 233, 104, 230, 105, 231, 106, 228, 107, 229, 108, 226, 109, 227, 110, 224, 111, 225, 112, 254, 113, 255, 114, 252, 115, 253, 116, 250, 117, 251, 118, 248, 119, 249, 120, 246, 121, 247, 122, 244, 123, 245, 124, 242, 125, 243, 126, 240, 127, 241, ],
[0, 143, 3, 140, 6, 137, 5, 138, 12, 131, 15, 128, 10, 133, 9, 134, 24, 151, 27, 148, 30, 145, 29, 146, 20, 155, 23, 152, 18, 157, 17, 158, 48, 191, 51, 188, 54, 185, 53, 186, 60, 179, 63, 176, 58, 181, 57, 182, 40, 167, 43, 164, 46, 161, 45, 162, 36, 171, 39, 168, 34, 173, 33, 174, 96, 239, 99, 236, 102, 233, 101, 234, 108, 227, 111, 224, 106, 229, 105, 230, 120, 247, 123, 244, 126, 241, 125, 242, 116, 251, 119, 248, 114, 253, 113, 254, 80, 223, 83, 220, 86, 217, 85, 218, 92, 211, 95, 208, 90, 213, 89, 214, 72, 199, 75, 196, 78, 193, 77, 194, 68, 203, 71, 200, 66, 205, 65, 206, 192, 79, 195, 76, 198, 73, 197, 74, 204, 67, 207, 64, 202, 69, 201, 70, 216, 87, 219, 84, 222, 81, 221, 82, 212, 91, 215, 88, 210, 93, 209, 94, 240, 127, 243, 124, 246, 121, 245, 122, 252, 115, 255, 112, 250, 117, 249, 118, 232, 103, 235, 100, 238, 97, 237, 98, 228, 107, 231, 104, 226, 109, 225, 110, 160, 47, 163, 44, 166, 41, 165, 42, 172, 35, 175, 32, 170, 37, 169, 38, 184, 55, 187, 52, 190, 49, 189, 50, 180, 59, 183, 56, 178, 61, 177, 62, 144, 31, 147, 28, 150, 25, 149, 26, 156, 19, 159, 16, 154, 21, 153, 22, 136, 7, 139, 4, 142, 1, 141, 2, 132, 11, 135, 8, 130, 13, 129, 14, ],
[0, 144, 61, 173, 122, 234, 71, 215, 244, 100, 201, 89, 142, 30, 179, 35, 245, 101, 200, 88, 143, 31, 178, 34, 1, 145, 60, 172, 123, 235, 70, 214, 247, 103, 202, 90, 141, 29, 176, 32, 3, 147, 62, 174, 121, 233, 68, 212, 2, 146, 63, 175, 120, 232, 69, 213, 246, 102, 203, 91, 140, 28, 177, 33, 243, 99, 206, 94, 137, 25, 180, 36, 7, 151, 58, 170, 125, 237, 64, 208, 6, 150, 59, 171, 124, 236, 65, 209, 242, 98, 207, 95, 136, 24, 181, 37, 4, 148, 57, 169, 126, 238, 67, 211, 240, 96, 205, 93, 138, 26, 183, 39, 241, 97, 204, 92, 139, 27, 182, 38, 5, 149, 56, 168, 127, 239, 66, 210, 251, 107, 198, 86, 129, 17, 188, 44, 15, 159, 50, 162, 117, 229, 72, 216, 14, 158, 51, 163, 116, 228, 73, 217, 250, 106, 199, 87, 128, 16, 189, 45, 12, 156, 49, 161, 118, 230, 75, 219, 248, 104, 197, 85, 130, 18, 191, 47, 249, 105, 196, 84, 131, 19, 190, 46, 13, 157, 48, 160, 119, 231, 74, 218, 8, 152, 53, 165, 114, 226, 79, 223, 252, 108, 193, 81, 134, 22, 187, 43, 253, 109, 192, 80, 135, 23, 186, 42, 9, 153, 52, 164, 115, 227, 78, 222, 255, 111, 194, 82, 133, 21, 184, 40, 11, 155, 54, 166, 113, 225, 76, 220, 10, 154, 55, 167, 112, 224, 77, 221, 254, 110, 195, 83, 132, 20, 185, 41, ],
[0, 145, 63, 174, 126, 239, 65, 208, 252, 109, 195, 82, 130, 19, 189, 44, 229, 116, 218, 75, 155, 10, 164, 53, 25, 136, 38, 183, 103, 246, 88, 201, 215, 70, 232, 121, 169, 56, 150, 7, 43, 186, 20, 133, 85, 196, 106, 251, 50, 163, 13, 156, 76, 221, 115, 226, 206, 95, 241, 96, 176, 33, 143, 30, 179, 34, 140, 29, 205, 92, 242, 99, 79, 222, 112, 225, 49, 160, 14, 159, 86, 199, 105, 248, 40, 185, 23, 134, 170, 59, 149, 4, 212, 69, 235, 122, 100, 245, 91, 202, 26, 139, 37, 180, 152, 9, 167, 54, 230, 119, 217, 72, 129, 16, 190, 47, 255, 110, 192, 81, 125, 236, 66, 211, 3, 146, 60, 173, 123, 234, 68, 213, 5, 148, 58, 171, 135, 22, 184, 41, 249, 104, 198, 87, 158, 15, 161, 48, 224, 113, 223, 78, 98, 243, 93, 204, 28, 141, 35, 178, 172, 61, 147, 2, 210, 67, 237, 124, 80, 193, 111, 254, 46, 191, 17, 128, 73, 216, 118, 231, 55, 166, 8, 153, 181, 36, 138, 27, 203, 90, 244, 101, 200, 89, 247, 102, 182, 39, 137, 24, 52, 165, 11, 154, 74, 219, 117, 228, 45, 188, 18, 131, 83, 194, 108, 253, 209, 64, 238, 127, 175, 62, 144, 1, 31, 142, 32, 177, 97, 240, 94, 207, 227, 114, 220, 77, 157, 12, 162, 51, 250, 107, 197, 84, 132, 21, 187, 42, 6, 151, 57, 168, 120, 233, 71, 214, ],
[0, 146, 57, 171, 114, 224, 75, 217, 228, 118, 221, 79, 150, 4, 175, 61, 213, 71, 236, 126, 167, 53, 158, 12, 49, 163, 8, 154, 67, 209, 122, 232, 183, 37, 142, 28, 197, 87, 252, 110, 83, 193, 106, 248, 33, 179, 24, 138, 98, 240, 91, 201, 16, 130, 41, 187, 134, 20, 191, 45, 244, 102, 205, 95, 115, 225, 74, 216, 1, 147, 56, 170, 151, 5, 174, 60, 229, 119, 220, 78, 166, 52, 159, 13, 212, 70, 237, 127, 66, 208, 123, 233, 48, 162, 9, 155, 196, 86, 253, 111, 182, 36, 143, 29, 32, 178, 25, 139, 82, 192, 107, 249, 17, 131, 40, 186, 99, 241, 90, 200, 245, 103, 204, 94, 135, 21, 190, 44, 230, 116, 223, 77, 148, 6, 173, 63, 2, 144, 59, 169, 112, 226, 73, 219, 51, 161, 10, 152, 65, 211, 120, 234, 215, 69, 238, 124, 165, 55, 156, 14, 81, 195, 104, 250, 35, 177, 26, 136, 181, 39, 140, 30, 199, 85, 254, 108, 132, 22, 189, 47, 246, 100, 207, 93, 96, 242, 89, 203, 18, 128, 43, 185, 149, 7, 172, 62, 231, 117, 222, 76, 113, 227, 72, 218, 3, 145, 58, 168, 64, 210, 121, 235, 50, 160, 11, 153, 164, 54, 157, 15, 214, 68, 239, 125, 34, 176, 27, 137, 80, 194, 105, 251, 198, 84, 255, 109, 180, 38, 141, 31, 247, 101, 206, 92, 133, 23, 188, 46, 19, 129, 42, 184, 97, 243, 88, 202, ],
[0, 147, 59, 168, 118, 229, 77, 222, 236, 127, 215, 68, 154, 9, 161, 50, 197, 86, 254, 109, 179, 32, 136, 27, 41, 186, 18, 129, 95, 204, 100, 247, 151, 4, 172, 63, 225, 114, 218, 73, 123, 232, 64, 211, 13, 158, 54, 165, 82, 193, 105, 250, 36, 183, 31, 140, 190, 45, 133, 22, 200, 91, 243, 96, 51, 160, 8, 155, 69, 214, 126, 237, 223, 76, 228, 119, 169, 58, 146, 1, 246, 101, 205, 94, 128, 19, 187, 40, 26, 137, 33, 178, 108, 255, 87, 196, 164, 55, 159, 12, 210, 65, 233, 122, 72, 219, 115, 224, 62, 173, 5, 150, 97, 242, 90, 201, 23, 132, 44, 191, 141, 30, 182, 37, 251, 104, 192, 83, 102, 245, 93, 206, 16, 131, 43, 184, 138, 25, 177, 34, 252, 111, 199, 84, 163, 48, 152, 11, 213, 70, 238, 125, 79, 220, 116, 231, 57, 170, 2, 145, 241, 98, 202, 89, 135, 20, 188, 47, 29, 142, 38, 181, 107, 248, 80, 195, 52, 167, 15, 156, 66, 209, 121, 234, 216, 75, 227, 112, 174, 61, 149, 6, 85, 198, 110, 253, 35, 176, 24, 139, 185, 42, 130, 17, 207, 92, 244, 103, 144, 3, 171, 56, 230, 117, 221, 78, 124, 239, 71, 212, 10, 153, 49, 162, 194, 81, 249, 106, 180, 39, 143, 28, 46, 189, 21, 134, 88, 203, 99, 240, 7, 148, 60, 175, 113, 226, 74, 217, 235, 120, 208, 67, 157, 14, 166, 53, ],
[0, 148, 53, 161, 106, 254, 95, 203, 212, 64, 225, 117, 190, 42, 139, 31, 181, 33, 128, 20, 223, 75, 234, 126, 97, 245, 84, 192, 11, 159, 62, 170, 119, 227, 66, 214, 29, 137, 40, 188, 163, 55, 150, 2, 201, 93, 252, 104, 194, 86, 247, 99, 168, 60, 157, 9, 22, 130, 35, 183, 124, 232, 73, 221, 238, 122, 219, 79, 132, 16, 177, 37, 58, 174, 15, 155, 80, 196, 101, 241, 91, 207, 110, 250, 49, 165, 4, 144, 143, 27, 186, 46, 229, 113, 208, 68, 153, 13, 172, 56, 243, 103, 198, 82, 77, 217, 120, 236, 39, 179, 18, 134, 44, 184, 25, 141, 70, 210, 115, 231, 248, 108, 205, 89, 146, 6, 167, 51, 193, 85, 244, 96, 171, 63, 158, 10, 21, 129, 32, 180, 127, 235, 74, 222, 116, 224, 65, 213, 30, 138, 43, 191, 160, 52, 149, 1, 202, 94, 255, 107, 182, 34, 131, 23, 220, 72, 233, 125, 98, 246, 87, 195, 8, 156, 61, 169, 3, 151, 54, 162, 105, 253, 92, 200, 215, 67, 226, 118, 189, 41, 136, 28, 47, 187, 26, 142, 69, 209, 112, 228, 251, 111, 206, 90, 145, 5, 164, 48, 154, 14, 175, 59, 240, 100, 197, 81, 78, 218, 123, 239, 36, 176, 17, 133, 88, 204, 109, 249, 50, 166, 7, 147, 140, 24, 185, 45, 230, 114, 211, 71, 237, 121, 216, 76, 135, 19, 178, 38, 57, 173, 12, 152, 83, 199, 102, 242, ],
[0, 149, 55, 162, 110, 251, 89, 204, 220, 73, 235, 126, 178, 39, 133, 16, 165, 48, 146, 7, 203, 94, 252, 105, 121, 236, 78, 219, 23, 130, 32, 181, 87, 194, 96, 245, 57, 172, 14, 155, 139, 30, 188, 41, 229, 112, 210, 71, 242, 103, 197, 80, 156, 9, 171, 62, 46, 187, 25, 140, 64, 213, 119, 226, 174, 59, 153, 12, 192, 85, 247, 98, 114, 231, 69, 208, 28, 137, 43, 190, 11, 158, 60, 169, 101, 240, 82, 199, 215, 66, 224, 117, 185, 44, 142, 27, 249, 108, 206, 91, 151, 2, 160, 53, 37, 176, 18, 135, 75, 222, 124, 233, 92, 201, 107, 254, 50, 167, 5, 144, 128, 21, 183, 34, 238, 123, 217, 76, 65, 212, 118, 227, 47, 186, 24, 141, 157, 8, 170, 63, 243, 102, 196, 81, 228, 113, 211, 70, 138, 31, 189, 40, 56, 173, 15, 154, 86, 195, 97, 244, 22, 131, 33, 180, 120, 237, 79, 218, 202, 95, 253, 104, 164, 49, 147, 6, 179, 38, 132, 17, 221, 72, 234, 127, 111, 250, 88, 205, 1, 148, 54, 163, 239, 122, 216, 77, 129, 20, 182, 35, 51, 166, 4, 145, 93, 200, 106, 255, 74, 223, 125, 232, 36, 177, 19, 134, 150, 3, 161, 52, 248, 109, 207, 90, 184, 45, 143, 26, 214, 67, 225, 116, 100, 241, 83, 198, 10, 159, 61, 168, 29, 136, 42, 191, 115, 230, 68, 209, 193, 84, 246, 99, 175, 58, 152, 13, ],
[0, 150, 49, 167, 98, 244, 83, 197, 196, 82, 245, 99, 166, 48, 151, 1, 149, 3, 164, 50, 247, 97, 198, 80, 81, 199, 96, 246, 51, 165, 2, 148, 55, 161, 6, 144, 85, 195, 100, 242, 243, 101, 194, 84, 145, 7, 160, 54, 162, 52, 147, 5, 192, 86, 241, 103, 102, 240, 87, 193, 4, 146, 53, 163, 110, 248, 95, 201, 12, 154, 61, 171, 170, 60, 155, 13, 200, 94, 249, 111, 251, 109, 202, 92, 153, 15, 168, 62, 63, 169, 14, 152, 93, 203, 108, 250, 89, 207, 104, 254, 59, 173, 10, 156, 157, 11, 172, 58, 255, 105, 206, 88, 204, 90, 253, 107, 174, 56, 159, 9, 8, 158, 57, 175, 106, 252, 91, 205, 220, 74, 237, 123, 190, 40, 143, 25, 24, 142, 41, 191, 122, 236, 75, 221, 73, 223, 120, 238, 43, 189, 26, 140, 141, 27, 188, 42, 239, 121, 222, 72, 235, 125, 218, 76, 137, 31, 184, 46, 47, 185, 30, 136, 77, 219, 124, 234, 126, 232, 79, 217, 28, 138, 45, 187, 186, 44, 139, 29, 216, 78, 233, 127, 178, 36, 131, 21, 208, 70, 225, 119, 118, 224, 71, 209, 20, 130, 37, 179, 39, 177, 22, 128, 69, 211, 116, 226, 227, 117, 210, 68, 129, 23, 176, 38, 133, 19, 180, 34, 231, 113, 214, 64, 65, 215, 112, 230, 35, 181, 18, 132, 16, 134, 33, 183, 114, 228, 67, 213, 212, 66, 229, 115, 182, 32, 135, 17, ],
[0, 151, 51, 164, 102, 241, 85, 194, 204, 91, 255, 104, 170, 61, 153, 14, 133, 18, 182, 33, 227, 116, 208, 71, 73, 222, 122, 237, 47, 184, 28, 139, 23, 128, 36, 179, 113, 230, 66, 213, 219, 76, 232, 127, 189, 42, 142, 25, 146, 5, 161, 54, 244, 99, 199, 80, 94, 201, 109, 250, 56, 175, 11, 156, 46, 185, 29, 138, 72, 223, 123, 236, 226, 117, 209, 70, 132, 19, 183, 32, 171, 60, 152, 15, 205, 90, 254, 105, 103, 240, 84, 195, 1, 150, 50, 165, 57, 174, 10, 157, 95, 200, 108, 251, 245, 98, 198, 81, 147, 4, 160, 55, 188, 43, 143, 24, 218, 77, 233, 126, 112, 231, 67, 212, 22, 129, 37, 178, 92, 203, 111, 248, 58, 173, 9, 158, 144, 7, 163, 52, 246, 97, 197, 82, 217, 78, 234, 125, 191, 40, 140, 27, 21, 130, 38, 177, 115, 228, 64, 215, 75, 220, 120, 239, 45, 186, 30, 137, 135, 16, 180, 35, 225, 118, 210, 69, 206, 89, 253, 106, 168, 63, 155, 12, 2, 149, 49, 166, 100, 243, 87, 192, 114, 229, 65, 214, 20, 131, 39, 176, 190, 41, 141, 26, 216, 79, 235, 124, 247, 96, 196, 83, 145, 6, 162, 53, 59, 172, 8, 159, 93, 202, 110, 249, 101, 242, 86, 193, 3, 148, 48, 167, 169, 62, 154, 13, 207, 88, 252, 107, 224, 119, 211, 68, 134, 17, 181, 34, 44, 187, 31, 136, 74, 221, 121, 238, ],
[0, 152, 45, 181, 90, 194, 119, 239, 180, 44, 153, 1, 238, 118, 195, 91, 117, 237, 88, 192, 47, 183, 2, 154, 193, 89, 236, 116, 155, 3, 182, 46, 234, 114, 199, 95, 176, 40, 157, 5, 94, 198, 115, 235, 4, 156, 41, 177, 159, 7, 178, 42, 197, 93, 232, 112, 43, 179, 6, 158, 113, 233, 92, 196, 201, 81, 228, 124, 147, 11, 190, 38, 125, 229, 80, 200, 39, 191, 10, 146, 188, 36, 145, 9, 230, 126, 203, 83, 8, 144, 37, 189, 82, 202, 127, 231, 35, 187, 14, 150, 121, 225, 84, 204, 151, 15, 186, 34, 205, 85, 224, 120, 86, 206, 123, 227, 12, 148, 33, 185, 226, 122, 207, 87, 184, 32, 149, 13, 143, 23, 162, 58, 213, 77, 248, 96, 59, 163, 22, 142, 97, 249, 76, 212, 250, 98, 215, 79, 160, 56, 141, 21, 78, 214, 99, 251, 20, 140, 57, 161, 101, 253, 72, 208, 63, 167, 18, 138, 209, 73, 252, 100, 139, 19, 166, 62, 16, 136, 61, 165, 74, 210, 103, 255, 164, 60, 137, 17, 254, 102, 211, 75, 70, 222, 107, 243, 28, 132, 49, 169, 242, 106, 223, 71, 168, 48, 133, 29, 51, 171, 30, 134, 105, 241, 68, 220, 135, 31, 170, 50, 221, 69, 240, 104, 172, 52, 129, 25, 246, 110, 219, 67, 24, 128, 53, 173, 66, 218, 111, 247, 217, 65, 244, 108, 131, 27, 174, 54, 109, 245, 64, 216, 55, 175, 26, 130, ],
[0, 153, 47, 182, 94, 199, 113, 232, 188, 37, 147, 10, 226, 123, 205, 84, 101, 252, 74, 211, 59, 162, 20, 141, 217, 64, 246, 111, 135, 30, 168, 49, 202, 83, 229, 124, 148, 13, 187, 34, 118, 239, 89, 192, 40, 177, 7, 158, 175, 54, 128, 25, 241, 104, 222, 71, 19, 138, 60, 165, 77, 212, 98, 251, 137, 16, 166, 63, 215, 78, 248, 97, 53, 172, 26, 131, 107, 242, 68, 221, 236, 117, 195, 90, 178, 43, 157, 4, 80, 201, 127, 230, 14, 151, 33, 184, 67, 218, 108, 245, 29, 132, 50, 171, 255, 102, 208, 73, 161, 56, 142, 23, 38, 191, 9, 144, 120, 225, 87, 206, 154, 3, 181, 44, 196, 93, 235, 114, 15, 150, 32, 185, 81, 200, 126, 231, 179, 42, 156, 5, 237, 116, 194, 91, 106, 243, 69, 220, 52, 173, 27, 130, 214, 79, 249, 96, 136, 17, 167, 62, 197, 92, 234, 115, 155, 2, 180, 45, 121, 224, 86, 207, 39, 190, 8, 145, 160, 57, 143, 22, 254, 103, 209, 72, 28, 133, 51, 170, 66, 219, 109, 244, 134, 31, 169, 48, 216, 65, 247, 110, 58, 163, 21, 140, 100, 253, 75, 210, 227, 122, 204, 85, 189, 36, 146, 11, 95, 198, 112, 233, 1, 152, 46, 183, 76, 213, 99, 250, 18, 139, 61, 164, 240, 105, 223, 70, 174, 55, 129, 24, 41, 176, 6, 159, 119, 238, 88, 193, 149, 12, 186, 35, 203, 82, 228, 125, ],
[0, 154, 41, 179, 82, 200, 123, 225, 164, 62, 141, 23, 246, 108, 223, 69, 85, 207, 124, 230, 7, 157, 46, 180, 241, 107, 216, 66, 163, 57, 138, 16, 170, 48, 131, 25, 248, 98, 209, 75, 14, 148, 39, 189, 92, 198, 117, 239, 255, 101, 214, 76, 173, 55, 132, 30, 91, 193, 114, 232, 9, 147, 32, 186, 73, 211, 96, 250, 27, 129, 50, 168, 237, 119, 196, 94, 191, 37, 150, 12, 28, 134, 53, 175, 78, 212, 103, 253, 184, 34, 145, 11, 234, 112, 195, 89, 227, 121, 202, 80, 177, 43, 152, 2, 71, 221, 110, 244, 21, 143, 60, 166, 182, 44, 159, 5, 228, 126, 205, 87, 18, 136, 59, 161, 64, 218, 105, 243, 146, 8, 187, 33, 192, 90, 233, 115, 54, 172, 31, 133, 100, 254, 77, 215, 199, 93, 238, 116, 149, 15, 188, 38, 99, 249, 74, 208, 49, 171, 24, 130, 56, 162, 17, 139, 106, 240, 67, 217, 156, 6, 181, 47, 206, 84, 231, 125, 109, 247, 68, 222, 63, 165, 22, 140, 201, 83, 224, 122, 155, 1, 178, 40, 219, 65, 242, 104, 137, 19, 160, 58, 127, 229, 86, 204, 45, 183, 4, 158, 142, 20, 167, 61, 220, 70, 245, 111, 42, 176, 3, 153, 120, 226, 81, 203, 113, 235, 88, 194, 35, 185, 10, 144, 213, 79, 252, 102, 135, 29, 174, 52, 36, 190, 13, 151, 118, 236, 95, 197, 128, 26, 169, 51, 210, 72, 251, 97, ],
[0, 155, 43, 176, 86, 205, 125, 230, 172, 55, 135, 28, 250, 97, 209, 74, 69, 222, 110, 245, 19, 136, 56, 163, 233, 114, 194, 89, 191, 36, 148, 15, 138, 17, 161, 58, 220, 71, 247, 108, 38, 189, 13, 150, 112, 235, 91, 192, 207, 84, 228, 127, 153, 2, 178, 41, 99, 248, 72, 211, 53, 174, 30, 133, 9, 146, 34, 185, 95, 196, 116, 239, 165, 62, 142, 21, 243, 104, 216, 67, 76, 215, 103, 252, 26, 129, 49, 170, 224, 123, 203, 80, 182, 45, 157, 6, 131, 24, 168, 51, 213, 78, 254, 101, 47, 180, 4, 159, 121, 226, 82, 201, 198, 93, 237, 118, 144, 11, 187, 32, 106, 241, 65, 218, 60, 167, 23, 140, 18, 137, 57, 162, 68, 223, 111, 244, 190, 37, 149, 14, 232, 115, 195, 88, 87, 204, 124, 231, 1, 154, 42, 177, 251, 96, 208, 75, 173, 54, 134, 29, 152, 3, 179, 40, 206, 85, 229, 126, 52, 175, 31, 132, 98, 249, 73, 210, 221, 70, 246, 109, 139, 16, 160, 59, 113, 234, 90, 193, 39, 188, 12, 151, 27, 128, 48, 171, 77, 214, 102, 253, 183, 44, 156, 7, 225, 122, 202, 81, 94, 197, 117, 238, 8, 147, 35, 184, 242, 105, 217, 66, 164, 63, 143, 20, 145, 10, 186, 33, 199, 92, 236, 119, 61, 166, 22, 141, 107, 240, 64, 219, 212, 79, 255, 100, 130, 25, 169, 50, 120, 227, 83, 200, 46, 181, 5, 158, ],
[0, 156, 37, 185, 74, 214, 111, 243, 148, 8, 177, 45, 222, 66, 251, 103, 53, 169, 16, 140, 127, 227, 90, 198, 161, 61, 132, 24, 235, 119, 206, 82, 106, 246, 79, 211, 32, 188, 5, 153, 254, 98, 219, 71, 180, 40, 145, 13, 95, 195, 122, 230, 21, 137, 48, 172, 203, 87, 238, 114, 129, 29, 164, 56, 212, 72, 241, 109, 158, 2, 187, 39, 64, 220, 101, 249, 10, 150, 47, 179, 225, 125, 196, 88, 171, 55, 142, 18, 117, 233, 80, 204, 63, 163, 26, 134, 190, 34, 155, 7, 244, 104, 209, 77, 42, 182, 15, 147, 96, 252, 69, 217, 139, 23, 174, 50, 193, 93, 228, 120, 31, 131, 58, 166, 85, 201, 112, 236, 181, 41, 144, 12, 255, 99, 218, 70, 33, 189, 4, 152, 107, 247, 78, 210, 128, 28, 165, 57, 202, 86, 239, 115, 20, 136, 49, 173, 94, 194, 123, 231, 223, 67, 250, 102, 149, 9, 176, 44, 75, 215, 110, 242, 1, 157, 36, 184, 234, 118, 207, 83, 160, 60, 133, 25, 126, 226, 91, 199, 52, 168, 17, 141, 97, 253, 68, 216, 43, 183, 14, 146, 245, 105, 208, 76, 191, 35, 154, 6, 84, 200, 113, 237, 30, 130, 59, 167, 192, 92, 229, 121, 138, 22, 175, 51, 11, 151, 46, 178, 65, 221, 100, 248, 159, 3, 186, 38, 213, 73, 240, 108, 62, 162, 27, 135, 116, 232, 81, 205, 170, 54, 143, 19, 224, 124, 197, 89, ],
[0, 157, 39, 186, 78, 211, 105, 244, 156, 1, 187, 38, 210, 79, 245, 104, 37, 184, 2, 159, 107, 246, 76, 209, 185, 36, 158, 3, 247, 106, 208, 77, 74, 215, 109, 240, 4, 153, 35, 190, 214, 75, 241, 108, 152, 5, 191, 34, 111, 242, 72, 213, 33, 188, 6, 155, 243, 110, 212, 73, 189, 32, 154, 7, 148, 9, 179, 46, 218, 71, 253, 96, 8, 149, 47, 178, 70, 219, 97, 252, 177, 44, 150, 11, 255, 98, 216, 69, 45, 176, 10, 151, 99, 254, 68, 217, 222, 67, 249, 100, 144, 13, 183, 42, 66, 223, 101, 248, 12, 145, 43, 182, 251, 102, 220, 65, 181, 40, 146, 15, 103, 250, 64, 221, 41, 180, 14, 147, 53, 168, 18, 143, 123, 230, 92, 193, 169, 52, 142, 19, 231, 122, 192, 93, 16, 141, 55, 170, 94, 195, 121, 228, 140, 17, 171, 54, 194, 95, 229, 120, 127, 226, 88, 197, 49, 172, 22, 139, 227, 126, 196, 89, 173, 48, 138, 23, 90, 199, 125, 224, 20, 137, 51, 174, 198, 91, 225, 124, 136, 21, 175, 50, 161, 60, 134, 27, 239, 114, 200, 85, 61, 160, 26, 135, 115, 238, 84, 201, 132, 25, 163, 62, 202, 87, 237, 112, 24, 133, 63, 162, 86, 203, 113, 236, 235, 118, 204, 81, 165, 56, 130, 31, 119, 234, 80, 205, 57, 164, 30, 131, 206, 83, 233, 116, 128, 29, 167, 58, 82, 207, 117, 232, 28, 129, 59, 166, ],
[0, 158, 33, 191, 66, 220, 99, 253, 132, 26, 165, 59, 198, 88, 231, 121, 21, 139, 52, 170, 87, 201, 118, 232, 145, 15, 176, 46, 211, 77, 242, 108, 42, 180, 11, 149, 104, 246, 73, 215, 174, 48, 143, 17, 236, 114, 205, 83, 63, 161, 30, 128, 125, 227, 92, 194, 187, 37, 154, 4, 249, 103, 216, 70, 84, 202, 117, 235, 22, 136, 55, 169, 208, 78, 241, 111, 146, 12, 179, 45, 65, 223, 96, 254, 3, 157, 34, 188, 197, 91, 228, 122, 135, 25, 166, 56, 126, 224, 95, 193, 60, 162, 29, 131, 250, 100, 219, 69, 184, 38, 153, 7, 107, 245, 74, 212, 41, 183, 8, 150, 239, 113, 206, 80, 173, 51, 140, 18, 168, 54, 137, 23, 234, 116, 203, 85, 44, 178, 13, 147, 110, 240, 79, 209, 189, 35, 156, 2, 255, 97, 222, 64, 57, 167, 24, 134, 123, 229, 90, 196, 130, 28, 163, 61, 192, 94, 225, 127, 6, 152, 39, 185, 68, 218, 101, 251, 151, 9, 182, 40, 213, 75, 244, 106, 19, 141, 50, 172, 81, 207, 112, 238, 252, 98, 221, 67, 190, 32, 159, 1, 120, 230, 89, 199, 58, 164, 27, 133, 233, 119, 200, 86, 171, 53, 138, 20, 109, 243, 76, 210, 47, 177, 14, 144, 214, 72, 247, 105, 148, 10, 181, 43, 82, 204, 115, 237, 16, 142, 49, 175, 195, 93, 226, 124, 129, 31, 160, 62, 71, 217, 102, 248, 5, 155, 36, 186, ],
[0, 159, 35, 188, 70, 217, 101, 250, 140, 19, 175, 48, 202, 85, 233, 118, 5, 154, 38, 185, 67, 220, 96, 255, 137, 22, 170, 53, 207, 80, 236, 115, 10, 149, 41, 182, 76, 211, 111, 240, 134, 25, 165, 58, 192, 95, 227, 124, 15, 144, 44, 179, 73, 214, 106, 245, 131, 28, 160, 63, 197, 90, 230, 121, 20, 139, 55, 168, 82, 205, 113, 238, 152, 7, 187, 36, 222, 65, 253, 98, 17, 142, 50, 173, 87, 200, 116, 235, 157, 2, 190, 33, 219, 68, 248, 103, 30, 129, 61, 162, 88, 199, 123, 228, 146, 13, 177, 46, 212, 75, 247, 104, 27, 132, 56, 167, 93, 194, 126, 225, 151, 8, 180, 43, 209, 78, 242, 109, 40, 183, 11, 148, 110, 241, 77, 210, 164, 59, 135, 24, 226, 125, 193, 94, 45, 178, 14, 145, 107, 244, 72, 215, 161, 62, 130, 29, 231, 120, 196, 91, 34, 189, 1, 158, 100, 251, 71, 216, 174, 49, 141, 18, 232, 119, 203, 84, 39, 184, 4, 155, 97, 254, 66, 221, 171, 52, 136, 23, 237, 114, 206, 81, 60, 163, 31, 128, 122, 229, 89, 198, 176, 47, 147, 12, 246, 105, 213, 74, 57, 166, 26, 133, 127, 224, 92, 195, 181, 42, 150, 9, 243, 108, 208, 79, 54, 169, 21, 138, 112, 239, 83, 204, 186, 37, 153, 6, 252, 99, 223, 64, 51, 172, 16, 143, 117, 234, 86, 201, 191, 32, 156, 3, 249, 102, 218, 69, ],
[0, 160, 93, 253, 186, 26, 231, 71, 105, 201, 52, 148, 211, 115, 142, 46, 210, 114, 143, 47, 104, 200, 53, 149, 187, 27, 230, 70, 1, 161, 92, 252, 185, 25, 228, 68, 3, 163, 94, 254, 208, 112, 141, 45, 106, 202, 55, 151, 107, 203, 54, 150, 209, 113, 140, 44, 2, 162, 95, 255, 184, 24, 229, 69, 111, 207, 50, 146, 213, 117, 136, 40, 6, 166, 91, 251, 188, 28, 225, 65, 189, 29, 224, 64, 7, 167, 90, 250, 212, 116, 137, 41, 110, 206, 51, 147, 214, 118, 139, 43, 108, 204, 49, 145, 191, 31, 226, 66, 5, 165, 88, 248, 4, 164, 89, 249, 190, 30, 227, 67, 109, 205, 48, 144, 215, 119, 138, 42, 222, 126, 131, 35, 100, 196, 57, 153, 183, 23, 234, 74, 13, 173, 80, 240, 12, 172, 81, 241, 182, 22, 235, 75, 101, 197, 56, 152, 223, 127, 130, 34, 103, 199, 58, 154, 221, 125, 128, 32, 14, 174, 83, 243, 180, 20, 233, 73, 181, 21, 232, 72, 15, 175, 82, 242, 220, 124, 129, 33, 102, 198, 59, 155, 177, 17, 236, 76, 11, 171, 86, 246, 216, 120, 133, 37, 98, 194, 63, 159, 99, 195, 62, 158, 217, 121, 132, 36, 10, 170, 87, 247, 176, 16, 237, 77, 8, 168, 85, 245, 178, 18, 239, 79, 97, 193, 60, 156, 219, 123, 134, 38, 218, 122, 135, 39, 96, 192, 61, 157, 179, 19, 238, 78, 9, 169, 84, 244, ],
[0, 161, 95, 254, 190, 31, 225, 64, 97, 192, 62, 159, 223, 126, 128, 33, 194, 99, 157, 60, 124, 221, 35, 130, 163, 2, 252, 93, 29, 188, 66, 227, 153, 56, 198, 103, 39, 134, 120, 217, 248, 89, 167, 6, 70, 231, 25, 184, 91, 250, 4, 165, 229, 68, 186, 27, 58, 155, 101, 196, 132, 37, 219, 122, 47, 142, 112, 209, 145, 48, 206, 111, 78, 239, 17, 176, 240, 81, 175, 14, 237, 76, 178, 19, 83, 242, 12, 173, 140, 45, 211, 114, 50, 147, 109, 204, 182, 23, 233, 72, 8, 169, 87, 246, 215, 118, 136, 41, 105, 200, 54, 151, 116, 213, 43, 138, 202, 107, 149, 52, 21, 180, 74, 235, 171, 10, 244, 85, 94, 255, 1, 160, 224, 65, 191, 30, 63, 158, 96, 193, 129, 32, 222, 127, 156, 61, 195, 98, 34, 131, 125, 220, 253, 92, 162, 3, 67, 226, 28, 189, 199, 102, 152, 57, 121, 216, 38, 135, 166, 7, 249, 88, 24, 185, 71, 230, 5, 164, 90, 251, 187, 26, 228, 69, 100, 197, 59, 154, 218, 123, 133, 36, 113, 208, 46, 143, 207, 110, 144, 49, 16, 177, 79, 238, 174, 15, 241, 80, 179, 18, 236, 77, 13, 172, 82, 243, 210, 115, 141, 44, 108, 205, 51, 146, 232, 73, 183, 22, 86, 247, 9, 168, 137, 40, 214, 119, 55, 150, 104, 201, 42, 139, 117, 212, 148, 53, 203, 106, 75, 234, 20, 181, 245, 84, 170, 11, ],
[0, 162, 89, 251, 178, 16, 235, 73, 121, 219, 32, 130, 203, 105, 146, 48, 242, 80, 171, 9, 64, 226, 25, 187, 139, 41, 210, 112, 57, 155, 96, 194, 249, 91, 160, 2, 75, 233, 18, 176, 128, 34, 217, 123, 50, 144, 107, 201, 11, 169, 82, 240, 185, 27, 224, 66, 114, 208, 43, 137, 192, 98, 153, 59, 239, 77, 182, 20, 93, 255, 4, 166, 150, 52, 207, 109, 36, 134, 125, 223, 29, 191, 68, 230, 175, 13, 246, 84, 100, 198, 61, 159, 214, 116, 143, 45, 22, 180, 79, 237, 164, 6, 253, 95, 111, 205, 54, 148, 221, 127, 132, 38, 228, 70, 189, 31, 86, 244, 15, 173, 157, 63, 196, 102, 47, 141, 118, 212, 195, 97, 154, 56, 113, 211, 40, 138, 186, 24, 227, 65, 8, 170, 81, 243, 49, 147, 104, 202, 131, 33, 218, 120, 72, 234, 17, 179, 250, 88, 163, 1, 58, 152, 99, 193, 136, 42, 209, 115, 67, 225, 26, 184, 241, 83, 168, 10, 200, 106, 145, 51, 122, 216, 35, 129, 177, 19, 232, 74, 3, 161, 90, 248, 44, 142, 117, 215, 158, 60, 199, 101, 85, 247, 12, 174, 231, 69, 190, 28, 222, 124, 135, 37, 108, 206, 53, 151, 167, 5, 254, 92, 21, 183, 76, 238, 213, 119, 140, 46, 103, 197, 62, 156, 172, 14, 245, 87, 30, 188, 71, 229, 39, 133, 126, 220, 149, 55, 204, 110, 94, 252, 7, 165, 236, 78, 181, 23, ],
[0, 163, 91, 248, 182, 21, 237, 78, 113, 210, 42, 137, 199, 100, 156, 63, 226, 65, 185, 26, 84, 247, 15, 172, 147, 48, 200, 107, 37, 134, 126, 221, 217, 122, 130, 33, 111, 204, 52, 151, 168, 11, 243, 80, 30, 189, 69, 230, 59, 152, 96, 195, 141, 46, 214, 117, 74, 233, 17, 178, 252, 95, 167, 4, 175, 12, 244, 87, 25, 186, 66, 225, 222, 125, 133, 38, 104, 203, 51, 144, 77, 238, 22, 181, 251, 88, 160, 3, 60, 159, 103, 196, 138, 41, 209, 114, 118, 213, 45, 142, 192, 99, 155, 56, 7, 164, 92, 255, 177, 18, 234, 73, 148, 55, 207, 108, 34, 129, 121, 218, 229, 70, 190, 29, 83, 240, 8, 171, 67, 224, 24, 187, 245, 86, 174, 13, 50, 145, 105, 202, 132, 39, 223, 124, 161, 2, 250, 89, 23, 180, 76, 239, 208, 115, 139, 40, 102, 197, 61, 158, 154, 57, 193, 98, 44, 143, 119, 212, 235, 72, 176, 19, 93, 254, 6, 165, 120, 219, 35, 128, 206, 109, 149, 54, 9, 170, 82, 241, 191, 28, 228, 71, 236, 79, 183, 20, 90, 249, 1, 162, 157, 62, 198, 101, 43, 136, 112, 211, 14, 173, 85, 246, 184, 27, 227, 64, 127, 220, 36, 135, 201, 106, 146, 49, 53, 150, 110, 205, 131, 32, 216, 123, 68, 231, 31, 188, 242, 81, 169, 10, 215, 116, 140, 47, 97, 194, 58, 153, 166, 5, 253, 94, 16, 179, 75, 232, ],
[0, 164, 85, 241, 170, 14, 255, 91, 73, 237, 28, 184, 227, 71, 182, 18, 146, 54, 199, 99, 56, 156, 109, 201, 219, 127, 142, 42, 113, 213, 36, 128, 57, 157, 108, 200, 147, 55, 198, 98, 112, 212, 37, 129, 218, 126, 143, 43, 171, 15, 254, 90, 1, 165, 84, 240, 226, 70, 183, 19, 72, 236, 29, 185, 114, 214, 39, 131, 216, 124, 141, 41, 59, 159, 110, 202, 145, 53, 196, 96, 224, 68, 181, 17, 74, 238, 31, 187, 169, 13, 252, 88, 3, 167, 86, 242, 75, 239, 30, 186, 225, 69, 180, 16, 2, 166, 87, 243, 168, 12, 253, 89, 217, 125, 140, 40, 115, 215, 38, 130, 144, 52, 197, 97, 58, 158, 111, 203, 228, 64, 177, 21, 78, 234, 27, 191, 173, 9, 248, 92, 7, 163, 82, 246, 118, 210, 35, 135, 220, 120, 137, 45, 63, 155, 106, 206, 149, 49, 192, 100, 221, 121, 136, 44, 119, 211, 34, 134, 148, 48, 193, 101, 62, 154, 107, 207, 79, 235, 26, 190, 229, 65, 176, 20, 6, 162, 83, 247, 172, 8, 249, 93, 150, 50, 195, 103, 60, 152, 105, 205, 223, 123, 138, 46, 117, 209, 32, 132, 4, 160, 81, 245, 174, 10, 251, 95, 77, 233, 24, 188, 231, 67, 178, 22, 175, 11, 250, 94, 5, 161, 80, 244, 230, 66, 179, 23, 76, 232, 25, 189, 61, 153, 104, 204, 151, 51, 194, 102, 116, 208, 33, 133, 222, 122, 139, 47, ],
[0, 165, 87, 242, 174, 11, 249, 92, 65, 228, 22, 179, 239, 74, 184, 29, 130, 39, 213, 112, 44, 137, 123, 222, 195, 102, 148, 49, 109, 200, 58, 159, 25, 188, 78, 235, 183, 18, 224, 69, 88, 253, 15, 170, 246, 83, 161, 4, 155, 62, 204, 105, 53, 144, 98, 199, 218, 127, 141, 40, 116, 209, 35, 134, 50, 151, 101, 192, 156, 57, 203, 110, 115, 214, 36, 129, 221, 120, 138, 47, 176, 21, 231, 66, 30, 187, 73, 236, 241, 84, 166, 3, 95, 250, 8, 173, 43, 142, 124, 217, 133, 32, 210, 119, 106, 207, 61, 152, 196, 97, 147, 54, 169, 12, 254, 91, 7, 162, 80, 245, 232, 77, 191, 26, 70, 227, 17, 180, 100, 193, 51, 150, 202, 111, 157, 56, 37, 128, 114, 215, 139, 46, 220, 121, 230, 67, 177, 20, 72, 237, 31, 186, 167, 2, 240, 85, 9, 172, 94, 251, 125, 216, 42, 143, 211, 118, 132, 33, 60, 153, 107, 206, 146, 55, 197, 96, 255, 90, 168, 13, 81, 244, 6, 163, 190, 27, 233, 76, 16, 181, 71, 226, 86, 243, 1, 164, 248, 93, 175, 10, 23, 178, 64, 229, 185, 28, 238, 75, 212, 113, 131, 38, 122, 223, 45, 136, 149, 48, 194, 103, 59, 158, 108, 201, 79, 234, 24, 189, 225, 68, 182, 19, 14, 171, 89, 252, 160, 5, 247, 82, 205, 104, 154, 63, 99, 198, 52, 145, 140, 41, 219, 126, 34, 135, 117, 208, ],
[0, 166, 81, 247, 162, 4, 243, 85, 89, 255, 8, 174, 251, 93, 170, 12, 178, 20, 227, 69, 16, 182, 65, 231, 235, 77, 186, 28, 73, 239, 24, 190, 121, 223, 40, 142, 219, 125, 138, 44, 32, 134, 113, 215, 130, 36, 211, 117, 203, 109, 154, 60, 105, 207, 56, 158, 146, 52, 195, 101, 48, 150, 97, 199, 242, 84, 163, 5, 80, 246, 1, 167, 171, 13, 250, 92, 9, 175, 88, 254, 64, 230, 17, 183, 226, 68, 179, 21, 25, 191, 72, 238, 187, 29, 234, 76, 139, 45, 218, 124, 41, 143, 120, 222, 210, 116, 131, 37, 112, 214, 33, 135, 57, 159, 104, 206, 155, 61, 202, 108, 96, 198, 49, 151, 194, 100, 147, 53, 249, 95, 168, 14, 91, 253, 10, 172, 160, 6, 241, 87, 2, 164, 83, 245, 75, 237, 26, 188, 233, 79, 184, 30, 18, 180, 67, 229, 176, 22, 225, 71, 128, 38, 209, 119, 34, 132, 115, 213, 217, 127, 136, 46, 123, 221, 42, 140, 50, 148, 99, 197, 144, 54, 193, 103, 107, 205, 58, 156, 201, 111, 152, 62, 11, 173, 90, 252, 169, 15, 248, 94, 82, 244, 3, 165, 240, 86, 161, 7, 185, 31, 232, 78, 27, 189, 74, 236, 224, 70, 177, 23, 66, 228, 19, 181, 114, 212, 35, 133, 208, 118, 129, 39, 43, 141, 122, 220, 137, 47, 216, 126, 192, 102, 145, 55, 98, 196, 51, 149, 153, 63, 200, 110, 59, 157, 106, 204, ],
[0, 167, 83, 244, 166, 1, 245, 82, 81, 246, 2, 165, 247, 80, 164, 3, 162, 5, 241, 86, 4, 163, 87, 240, 243, 84, 160, 7, 85, 242, 6, 161, 89, 254, 10, 173, 255, 88, 172, 11, 8, 175, 91, 252, 174, 9, 253, 90, 251, 92, 168, 15, 93, 250, 14, 169, 170, 13, 249, 94, 12, 171, 95, 248, 178, 21, 225, 70, 20, 179, 71, 224, 227, 68, 176, 23, 69, 226, 22, 177, 16, 183, 67, 228, 182, 17, 229, 66, 65, 230, 18, 181, 231, 64, 180, 19, 235, 76, 184, 31, 77, 234, 30, 185, 186, 29, 233, 78, 28, 187, 79, 232, 73, 238, 26, 189, 239, 72, 188, 27, 24, 191, 75, 236, 190, 25, 237, 74, 121, 222, 42, 141, 223, 120, 140, 43, 40, 143, 123, 220, 142, 41, 221, 122, 219, 124, 136, 47, 125, 218, 46, 137, 138, 45, 217, 126, 44, 139, 127, 216, 32, 135, 115, 212, 134, 33, 213, 114, 113, 214, 34, 133, 215, 112, 132, 35, 130, 37, 209, 118, 36, 131, 119, 208, 211, 116, 128, 39, 117, 210, 38, 129, 203, 108, 152, 63, 109, 202, 62, 153, 154, 61, 201, 110, 60, 155, 111, 200, 105, 206, 58, 157, 207, 104, 156, 59, 56, 159, 107, 204, 158, 57, 205, 106, 146, 53, 193, 102, 52, 147, 103, 192, 195, 100, 144, 55, 101, 194, 54, 145, 48, 151, 99, 196, 150, 49, 197, 98, 97, 198, 50, 149, 199, 96, 148, 51, ],
[0, 168, 77, 229, 154, 50, 215, 127, 41, 129, 100, 204, 179, 27, 254, 86, 82, 250, 31, 183, 200, 96, 133, 45, 123, 211, 54, 158, 225, 73, 172, 4, 164, 12, 233, 65, 62, 150, 115, 219, 141, 37, 192, 104, 23, 191, 90, 242, 246, 94, 187, 19, 108, 196, 33, 137, 223, 119, 146, 58, 69, 237, 8, 160, 85, 253, 24, 176, 207, 103, 130, 42, 124, 212, 49, 153, 230, 78, 171, 3, 7, 175, 74, 226, 157, 53, 208, 120, 46, 134, 99, 203, 180, 28, 249, 81, 241, 89, 188, 20, 107, 195, 38, 142, 216, 112, 149, 61, 66, 234, 15, 167, 163, 11, 238, 70, 57, 145, 116, 220, 138, 34, 199, 111, 16, 184, 93, 245, 170, 2, 231, 79, 48, 152, 125, 213, 131, 43, 206, 102, 25, 177, 84, 252, 248, 80, 181, 29, 98, 202, 47, 135, 209, 121, 156, 52, 75, 227, 6, 174, 14, 166, 67, 235, 148, 60, 217, 113, 39, 143, 106, 194, 189, 21, 240, 88, 92, 244, 17, 185, 198, 110, 139, 35, 117, 221, 56, 144, 239, 71, 162, 10, 255, 87, 178, 26, 101, 205, 40, 128, 214, 126, 155, 51, 76, 228, 1, 169, 173, 5, 224, 72, 55, 159, 122, 210, 132, 44, 201, 97, 30, 182, 83, 251, 91, 243, 22, 190, 193, 105, 140, 36, 114, 218, 63, 151, 232, 64, 165, 13, 9, 161, 68, 236, 147, 59, 222, 118, 32, 136, 109, 197, 186, 18, 247, 95, ],
[0, 169, 79, 230, 158, 55, 209, 120, 33, 136, 110, 199, 191, 22, 240, 89, 66, 235, 13, 164, 220, 117, 147, 58, 99, 202, 44, 133, 253, 84, 178, 27, 132, 45, 203, 98, 26, 179, 85, 252, 165, 12, 234, 67, 59, 146, 116, 221, 198, 111, 137, 32, 88, 241, 23, 190, 231, 78, 168, 1, 121, 208, 54, 159, 21, 188, 90, 243, 139, 34, 196, 109, 52, 157, 123, 210, 170, 3, 229, 76, 87, 254, 24, 177, 201, 96, 134, 47, 118, 223, 57, 144, 232, 65, 167, 14, 145, 56, 222, 119, 15, 166, 64, 233, 176, 25, 255, 86, 46, 135, 97, 200, 211, 122, 156, 53, 77, 228, 2, 171, 242, 91, 189, 20, 108, 197, 35, 138, 42, 131, 101, 204, 180, 29, 251, 82, 11, 162, 68, 237, 149, 60, 218, 115, 104, 193, 39, 142, 246, 95, 185, 16, 73, 224, 6, 175, 215, 126, 152, 49, 174, 7, 225, 72, 48, 153, 127, 214, 143, 38, 192, 105, 17, 184, 94, 247, 236, 69, 163, 10, 114, 219, 61, 148, 205, 100, 130, 43, 83, 250, 28, 181, 63, 150, 112, 217, 161, 8, 238, 71, 30, 183, 81, 248, 128, 41, 207, 102, 125, 212, 50, 155, 227, 74, 172, 5, 92, 245, 19, 186, 194, 107, 141, 36, 187, 18, 244, 93, 37, 140, 106, 195, 154, 51, 213, 124, 4, 173, 75, 226, 249, 80, 182, 31, 103, 206, 40, 129, 216, 113, 151, 62, 70, 239, 9, 160, ],
[0, 170, 73, 227, 146, 56, 219, 113, 57, 147, 112, 218, 171, 1, 226, 72, 114, 216, 59, 145, 224, 74, 169, 3, 75, 225, 2, 168, 217, 115, 144, 58, 228, 78, 173, 7, 118, 220, 63, 149, 221, 119, 148, 62, 79, 229, 6, 172, 150, 60, 223, 117, 4, 174, 77, 231, 175, 5, 230, 76, 61, 151, 116, 222, 213, 127, 156, 54, 71, 237, 14, 164, 236, 70, 165, 15, 126, 212, 55, 157, 167, 13, 238, 68, 53, 159, 124, 214, 158, 52, 215, 125, 12, 166, 69, 239, 49, 155, 120, 210, 163, 9, 234, 64, 8, 162, 65, 235, 154, 48, 211, 121, 67, 233, 10, 160, 209, 123, 152, 50, 122, 208, 51, 153, 232, 66, 161, 11, 183, 29, 254, 84, 37, 143, 108, 198, 142, 36, 199, 109, 28, 182, 85, 255, 197, 111, 140, 38, 87, 253, 30, 180, 252, 86, 181, 31, 110, 196, 39, 141, 83, 249, 26, 176, 193, 107, 136, 34, 106, 192, 35, 137, 248, 82, 177, 27, 33, 139, 104, 194, 179, 25, 250, 80, 24, 178, 81, 251, 138, 32, 195, 105, 98, 200, 43, 129, 240, 90, 185, 19, 91, 241, 18, 184, 201, 99, 128, 42, 16, 186, 89, 243, 130, 40, 203, 97, 41, 131, 96, 202, 187, 17, 242, 88, 134, 44, 207, 101, 20, 190, 93, 247, 191, 21, 246, 92, 45, 135, 100, 206, 244, 94, 189, 23, 102, 204, 47, 133, 205, 103, 132, 46, 95, 245, 22, 188, ],
[0, 171, 75, 224, 150, 61, 221, 118, 49, 154, 122, 209, 167, 12, 236, 71, 98, 201, 41, 130, 244, 95, 191, 20, 83, 248, 24, 179, 197, 110, 142, 37, 196, 111, 143, 36, 82, 249, 25, 178, 245, 94, 190, 21, 99, 200, 40, 131, 166, 13, 237, 70, 48, 155, 123, 208, 151, 60, 220, 119, 1, 170, 74, 225, 149, 62, 222, 117, 3, 168, 72, 227, 164, 15, 239, 68, 50, 153, 121, 210, 247, 92, 188, 23, 97, 202, 42, 129, 198, 109, 141, 38, 80, 251, 27, 176, 81, 250, 26, 177, 199, 108, 140, 39, 96, 203, 43, 128, 246, 93, 189, 22, 51, 152, 120, 211, 165, 14, 238, 69, 2, 169, 73, 226, 148, 63, 223, 116, 55, 156, 124, 215, 161, 10, 234, 65, 6, 173, 77, 230, 144, 59, 219, 112, 85, 254, 30, 181, 195, 104, 136, 35, 100, 207, 47, 132, 242, 89, 185, 18, 243, 88, 184, 19, 101, 206, 46, 133, 194, 105, 137, 34, 84, 255, 31, 180, 145, 58, 218, 113, 7, 172, 76, 231, 160, 11, 235, 64, 54, 157, 125, 214, 162, 9, 233, 66, 52, 159, 127, 212, 147, 56, 216, 115, 5, 174, 78, 229, 192, 107, 139, 32, 86, 253, 29, 182, 241, 90, 186, 17, 103, 204, 44, 135, 102, 205, 45, 134, 240, 91, 187, 16, 87, 252, 28, 183, 193, 106, 138, 33, 4, 175, 79, 228, 146, 57, 217, 114, 53, 158, 126, 213, 163, 8, 232, 67, ],
[0, 172, 69, 233, 138, 38, 207, 99, 9, 165, 76, 224, 131, 47, 198, 106, 18, 190, 87, 251, 152, 52, 221, 113, 27, 183, 94, 242, 145, 61, 212, 120, 36, 136, 97, 205, 174, 2, 235, 71, 45, 129, 104, 196, 167, 11, 226, 78, 54, 154, 115, 223, 188, 16, 249, 85, 63, 147, 122, 214, 181, 25, 240, 92, 72, 228, 13, 161, 194, 110, 135, 43, 65, 237, 4, 168, 203, 103, 142, 34, 90, 246, 31, 179, 208, 124, 149, 57, 83, 255, 22, 186, 217, 117, 156, 48, 108, 192, 41, 133, 230, 74, 163, 15, 101, 201, 32, 140, 239, 67, 170, 6, 126, 210, 59, 151, 244, 88, 177, 29, 119, 219, 50, 158, 253, 81, 184, 20, 144, 60, 213, 121, 26, 182, 95, 243, 153, 53, 220, 112, 19, 191, 86, 250, 130, 46, 199, 107, 8, 164, 77, 225, 139, 39, 206, 98, 1, 173, 68, 232, 180, 24, 241, 93, 62, 146, 123, 215, 189, 17, 248, 84, 55, 155, 114, 222, 166, 10, 227, 79, 44, 128, 105, 197, 175, 3, 234, 70, 37, 137, 96, 204, 216, 116, 157, 49, 82, 254, 23, 187, 209, 125, 148, 56, 91, 247, 30, 178, 202, 102, 143, 35, 64, 236, 5, 169, 195, 111, 134, 42, 73, 229, 12, 160, 252, 80, 185, 21, 118, 218, 51, 159, 245, 89, 176, 28, 127, 211, 58, 150, 238, 66, 171, 7, 100, 200, 33, 141, 231, 75, 162, 14, 109, 193, 40, 132, ],
[0, 173, 71, 234, 142, 35, 201, 100, 1, 172, 70, 235, 143, 34, 200, 101, 2, 175, 69, 232, 140, 33, 203, 102, 3, 174, 68, 233, 141, 32, 202, 103, 4, 169, 67, 238, 138, 39, 205, 96, 5, 168, 66, 239, 139, 38, 204, 97, 6, 171, 65, 236, 136, 37, 207, 98, 7, 170, 64, 237, 137, 36, 206, 99, 8, 165, 79, 226, 134, 43, 193, 108, 9, 164, 78, 227, 135, 42, 192, 109, 10, 167, 77, 224, 132, 41, 195, 110, 11, 166, 76, 225, 133, 40, 194, 111, 12, 161, 75, 230, 130, 47, 197, 104, 13, 160, 74, 231, 131, 46, 196, 105, 14, 163, 73, 228, 128, 45, 199, 106, 15, 162, 72, 229, 129, 44, 198, 107, 16, 189, 87, 250, 158, 51, 217, 116, 17, 188, 86, 251, 159, 50, 216, 117, 18, 191, 85, 248, 156, 49, 219, 118, 19, 190, 84, 249, 157, 48, 218, 119, 20, 185, 83, 254, 154, 55, 221, 112, 21, 184, 82, 255, 155, 54, 220, 113, 22, 187, 81, 252, 152, 53, 223, 114, 23, 186, 80, 253, 153, 52, 222, 115, 24, 181, 95, 242, 150, 59, 209, 124, 25, 180, 94, 243, 151, 58, 208, 125, 26, 183, 93, 240, 148, 57, 211, 126, 27, 182, 92, 241, 149, 56, 210, 127, 28, 177, 91, 246, 146, 63, 213, 120, 29, 176, 90, 247, 147, 62, 212, 121, 30, 179, 89, 244, 144, 61, 215, 122, 31, 178, 88, 245, 145, 60, 214, 123, ],
[0, 174, 65, 239, 130, 44, 195, 109, 25, 183, 88, 246, 155, 53, 218, 116, 50, 156, 115, 221, 176, 30, 241, 95, 43, 133, 106, 196, 169, 7, 232, 70, 100, 202, 37, 139, 230, 72, 167, 9, 125, 211, 60, 146, 255, 81, 190, 16, 86, 248, 23, 185, 212, 122, 149, 59, 79, 225, 14, 160, 205, 99, 140, 34, 200, 102, 137, 39, 74, 228, 11, 165, 209, 127, 144, 62, 83, 253, 18, 188, 250, 84, 187, 21, 120, 214, 57, 151, 227, 77, 162, 12, 97, 207, 32, 142, 172, 2, 237, 67, 46, 128, 111, 193, 181, 27, 244, 90, 55, 153, 118, 216, 158, 48, 223, 113, 28, 178, 93, 243, 135, 41, 198, 104, 5, 171, 68, 234, 141, 35, 204, 98, 15, 161, 78, 224, 148, 58, 213, 123, 22, 184, 87, 249, 191, 17, 254, 80, 61, 147, 124, 210, 166, 8, 231, 73, 36, 138, 101, 203, 233, 71, 168, 6, 107, 197, 42, 132, 240, 94, 177, 31, 114, 220, 51, 157, 219, 117, 154, 52, 89, 247, 24, 182, 194, 108, 131, 45, 64, 238, 1, 175, 69, 235, 4, 170, 199, 105, 134, 40, 92, 242, 29, 179, 222, 112, 159, 49, 119, 217, 54, 152, 245, 91, 180, 26, 110, 192, 47, 129, 236, 66, 173, 3, 33, 143, 96, 206, 163, 13, 226, 76, 56, 150, 121, 215, 186, 20, 251, 85, 19, 189, 82, 252, 145, 63, 208, 126, 10, 164, 75, 229, 136, 38, 201, 103, ],
[0, 175, 67, 236, 134, 41, 197, 106, 17, 190, 82, 253, 151, 56, 212, 123, 34, 141, 97, 206, 164, 11, 231, 72, 51, 156, 112, 223, 181, 26, 246, 89, 68, 235, 7, 168, 194, 109, 129, 46, 85, 250, 22, 185, 211, 124, 144, 63, 102, 201, 37, 138, 224, 79, 163, 12, 119, 216, 52, 155, 241, 94, 178, 29, 136, 39, 203, 100, 14, 161, 77, 226, 153, 54, 218, 117, 31, 176, 92, 243, 170, 5, 233, 70, 44, 131, 111, 192, 187, 20, 248, 87, 61, 146, 126, 209, 204, 99, 143, 32, 74, 229, 9, 166, 221, 114, 158, 49, 91, 244, 24, 183, 238, 65, 173, 2, 104, 199, 43, 132, 255, 80, 188, 19, 121, 214, 58, 149, 13, 162, 78, 225, 139, 36, 200, 103, 28, 179, 95, 240, 154, 53, 217, 118, 47, 128, 108, 195, 169, 6, 234, 69, 62, 145, 125, 210, 184, 23, 251, 84, 73, 230, 10, 165, 207, 96, 140, 35, 88, 247, 27, 180, 222, 113, 157, 50, 107, 196, 40, 135, 237, 66, 174, 1, 122, 213, 57, 150, 252, 83, 191, 16, 133, 42, 198, 105, 3, 172, 64, 239, 148, 59, 215, 120, 18, 189, 81, 254, 167, 8, 228, 75, 33, 142, 98, 205, 182, 25, 245, 90, 48, 159, 115, 220, 193, 110, 130, 45, 71, 232, 4, 171, 208, 127, 147, 60, 86, 249, 21, 186, 227, 76, 160, 15, 101, 202, 38, 137, 242, 93, 177, 30, 116, 219, 55, 152, ],
[0, 176, 125, 205, 250, 74, 135, 55, 233, 89, 148, 36, 19, 163, 110, 222, 207, 127, 178, 2, 53, 133, 72, 248, 38, 150, 91, 235, 220, 108, 161, 17, 131, 51, 254, 78, 121, 201, 4, 180, 106, 218, 23, 167, 144, 32, 237, 93, 76, 252, 49, 129, 182, 6, 203, 123, 165, 21, 216, 104, 95, 239, 34, 146, 27, 171, 102, 214, 225, 81, 156, 44, 242, 66, 143, 63, 8, 184, 117, 197, 212, 100, 169, 25, 46, 158, 83, 227, 61, 141, 64, 240, 199, 119, 186, 10, 152, 40, 229, 85, 98, 210, 31, 175, 113, 193, 12, 188, 139, 59, 246, 70, 87, 231, 42, 154, 173, 29, 208, 96, 190, 14, 195, 115, 68, 244, 57, 137, 54, 134, 75, 251, 204, 124, 177, 1, 223, 111, 162, 18, 37, 149, 88, 232, 249, 73, 132, 52, 3, 179, 126, 206, 16, 160, 109, 221, 234, 90, 151, 39, 181, 5, 200, 120, 79, 255, 50, 130, 92, 236, 33, 145, 166, 22, 219, 107, 122, 202, 7, 183, 128, 48, 253, 77, 147, 35, 238, 94, 105, 217, 20, 164, 45, 157, 80, 224, 215, 103, 170, 26, 196, 116, 185, 9, 62, 142, 67, 243, 226, 82, 159, 47, 24, 168, 101, 213, 11, 187, 118, 198, 241, 65, 140, 60, 174, 30, 211, 99, 84, 228, 41, 153, 71, 247, 58, 138, 189, 13, 192, 112, 97, 209, 28, 172, 155, 43, 230, 86, 136, 56, 245, 69, 114, 194, 15, 191, ],
[0, 177, 127, 206, 254, 79, 129, 48, 225, 80, 158, 47, 31, 174, 96, 209, 223, 110, 160, 17, 33, 144, 94, 239, 62, 143, 65, 240, 192, 113, 191, 14, 163, 18, 220, 109, 93, 236, 34, 147, 66, 243, 61, 140, 188, 13, 195, 114, 124, 205, 3, 178, 130, 51, 253, 76, 157, 44, 226, 83, 99, 210, 28, 173, 91, 234, 36, 149, 165, 20, 218, 107, 186, 11, 197, 116, 68, 245, 59, 138, 132, 53, 251, 74, 122, 203, 5, 180, 101, 212, 26, 171, 155, 42, 228, 85, 248, 73, 135, 54, 6, 183, 121, 200, 25, 168, 102, 215, 231, 86, 152, 41, 39, 150, 88, 233, 217, 104, 166, 23, 198, 119, 185, 8, 56, 137, 71, 246, 182, 7, 201, 120, 72, 249, 55, 134, 87, 230, 40, 153, 169, 24, 214, 103, 105, 216, 22, 167, 151, 38, 232, 89, 136, 57, 247, 70, 118, 199, 9, 184, 21, 164, 106, 219, 235, 90, 148, 37, 244, 69, 139, 58, 10, 187, 117, 196, 202, 123, 181, 4, 52, 133, 75, 250, 43, 154, 84, 229, 213, 100, 170, 27, 237, 92, 146, 35, 19, 162, 108, 221, 12, 189, 115, 194, 242, 67, 141, 60, 50, 131, 77, 252, 204, 125, 179, 2, 211, 98, 172, 29, 45, 156, 82, 227, 78, 255, 49, 128, 176, 1, 207, 126, 175, 30, 208, 97, 81, 224, 46, 159, 145, 32, 238, 95, 111, 222, 16, 161, 112, 193, 15, 190, 142, 63, 241, 64, ],
[0, 178, 121, 203, 242, 64, 139, 57, 249, 75, 128, 50, 11, 185, 114, 192, 239, 93, 150, 36, 29, 175, 100, 214, 22, 164, 111, 221, 228, 86, 157, 47, 195, 113, 186, 8, 49, 131, 72, 250, 58, 136, 67, 241, 200, 122, 177, 3, 44, 158, 85, 231, 222, 108, 167, 21, 213, 103, 172, 30, 39, 149, 94, 236, 155, 41, 226, 80, 105, 219, 16, 162, 98, 208, 27, 169, 144, 34, 233, 91, 116, 198, 13, 191, 134, 52, 255, 77, 141, 63, 244, 70, 127, 205, 6, 180, 88, 234, 33, 147, 170, 24, 211, 97, 161, 19, 216, 106, 83, 225, 42, 152, 183, 5, 206, 124, 69, 247, 60, 142, 78, 252, 55, 133, 188, 14, 197, 119, 43, 153, 82, 224, 217, 107, 160, 18, 210, 96, 171, 25, 32, 146, 89, 235, 196, 118, 189, 15, 54, 132, 79, 253, 61, 143, 68, 246, 207, 125, 182, 4, 232, 90, 145, 35, 26, 168, 99, 209, 17, 163, 104, 218, 227, 81, 154, 40, 7, 181, 126, 204, 245, 71, 140, 62, 254, 76, 135, 53, 12, 190, 117, 199, 176, 2, 201, 123, 66, 240, 59, 137, 73, 251, 48, 130, 187, 9, 194, 112, 95, 237, 38, 148, 173, 31, 212, 102, 166, 20, 223, 109, 84, 230, 45, 159, 115, 193, 10, 184, 129, 51, 248, 74, 138, 56, 243, 65, 120, 202, 1, 179, 156, 46, 229, 87, 110, 220, 23, 165, 101, 215, 28, 174, 151, 37, 238, 92, ],
[0, 179, 123, 200, 246, 69, 141, 62, 241, 66, 138, 57, 7, 180, 124, 207, 255, 76, 132, 55, 9, 186, 114, 193, 14, 189, 117, 198, 248, 75, 131, 48, 227, 80, 152, 43, 21, 166, 110, 221, 18, 161, 105, 218, 228, 87, 159, 44, 28, 175, 103, 212, 234, 89, 145, 34, 237, 94, 150, 37, 27, 168, 96, 211, 219, 104, 160, 19, 45, 158, 86, 229, 42, 153, 81, 226, 220, 111, 167, 20, 36, 151, 95, 236, 210, 97, 169, 26, 213, 102, 174, 29, 35, 144, 88, 235, 56, 139, 67, 240, 206, 125, 181, 6, 201, 122, 178, 1, 63, 140, 68, 247, 199, 116, 188, 15, 49, 130, 74, 249, 54, 133, 77, 254, 192, 115, 187, 8, 171, 24, 208, 99, 93, 238, 38, 149, 90, 233, 33, 146, 172, 31, 215, 100, 84, 231, 47, 156, 162, 17, 217, 106, 165, 22, 222, 109, 83, 224, 40, 155, 72, 251, 51, 128, 190, 13, 197, 118, 185, 10, 194, 113, 79, 252, 52, 135, 183, 4, 204, 127, 65, 242, 58, 137, 70, 245, 61, 142, 176, 3, 203, 120, 112, 195, 11, 184, 134, 53, 253, 78, 129, 50, 250, 73, 119, 196, 12, 191, 143, 60, 244, 71, 121, 202, 2, 177, 126, 205, 5, 182, 136, 59, 243, 64, 147, 32, 232, 91, 101, 214, 30, 173, 98, 209, 25, 170, 148, 39, 239, 92, 108, 223, 23, 164, 154, 41, 225, 82, 157, 46, 230, 85, 107, 216, 16, 163, ],
[0, 180, 117, 193, 234, 94, 159, 43, 201, 125, 188, 8, 35, 151, 86, 226, 143, 59, 250, 78, 101, 209, 16, 164, 70, 242, 51, 135, 172, 24, 217, 109, 3, 183, 118, 194, 233, 93, 156, 40, 202, 126, 191, 11, 32, 148, 85, 225, 140, 56, 249, 77, 102, 210, 19, 167, 69, 241, 48, 132, 175, 27, 218, 110, 6, 178, 115, 199, 236, 88, 153, 45, 207, 123, 186, 14, 37, 145, 80, 228, 137, 61, 252, 72, 99, 215, 22, 162, 64, 244, 53, 129, 170, 30, 223, 107, 5, 177, 112, 196, 239, 91, 154, 46, 204, 120, 185, 13, 38, 146, 83, 231, 138, 62, 255, 75, 96, 212, 21, 161, 67, 247, 54, 130, 169, 29, 220, 104, 12, 184, 121, 205, 230, 82, 147, 39, 197, 113, 176, 4, 47, 155, 90, 238, 131, 55, 246, 66, 105, 221, 28, 168, 74, 254, 63, 139, 160, 20, 213, 97, 15, 187, 122, 206, 229, 81, 144, 36, 198, 114, 179, 7, 44, 152, 89, 237, 128, 52, 245, 65, 106, 222, 31, 171, 73, 253, 60, 136, 163, 23, 214, 98, 10, 190, 127, 203, 224, 84, 149, 33, 195, 119, 182, 2, 41, 157, 92, 232, 133, 49, 240, 68, 111, 219, 26, 174, 76, 248, 57, 141, 166, 18, 211, 103, 9, 189, 124, 200, 227, 87, 150, 34, 192, 116, 181, 1, 42, 158, 95, 235, 134, 50, 243, 71, 108, 216, 25, 173, 79, 251, 58, 142, 165, 17, 208, 100, ],
[0, 181, 119, 194, 238, 91, 153, 44, 193, 116, 182, 3, 47, 154, 88, 237, 159, 42, 232, 93, 113, 196, 6, 179, 94, 235, 41, 156, 176, 5, 199, 114, 35, 150, 84, 225, 205, 120, 186, 15, 226, 87, 149, 32, 12, 185, 123, 206, 188, 9, 203, 126, 82, 231, 37, 144, 125, 200, 10, 191, 147, 38, 228, 81, 70, 243, 49, 132, 168, 29, 223, 106, 135, 50, 240, 69, 105, 220, 30, 171, 217, 108, 174, 27, 55, 130, 64, 245, 24, 173, 111, 218, 246, 67, 129, 52, 101, 208, 18, 167, 139, 62, 252, 73, 164, 17, 211, 102, 74, 255, 61, 136, 250, 79, 141, 56, 20, 161, 99, 214, 59, 142, 76, 249, 213, 96, 162, 23, 140, 57, 251, 78, 98, 215, 21, 160, 77, 248, 58, 143, 163, 22, 212, 97, 19, 166, 100, 209, 253, 72, 138, 63, 210, 103, 165, 16, 60, 137, 75, 254, 175, 26, 216, 109, 65, 244, 54, 131, 110, 219, 25, 172, 128, 53, 247, 66, 48, 133, 71, 242, 222, 107, 169, 28, 241, 68, 134, 51, 31, 170, 104, 221, 202, 127, 189, 8, 36, 145, 83, 230, 11, 190, 124, 201, 229, 80, 146, 39, 85, 224, 34, 151, 187, 14, 204, 121, 148, 33, 227, 86, 122, 207, 13, 184, 233, 92, 158, 43, 7, 178, 112, 197, 40, 157, 95, 234, 198, 115, 177, 4, 118, 195, 1, 180, 152, 45, 239, 90, 183, 2, 192, 117, 89, 236, 46, 155, ],
[0, 182, 113, 199, 226, 84, 147, 37, 217, 111, 168, 30, 59, 141, 74, 252, 175, 25, 222, 104, 77, 251, 60, 138, 118, 192, 7, 177, 148, 34, 229, 83, 67, 245, 50, 132, 161, 23, 208, 102, 154, 44, 235, 93, 120, 206, 9, 191, 236, 90, 157, 43, 14, 184, 127, 201, 53, 131, 68, 242, 215, 97, 166, 16, 134, 48, 247, 65, 100, 210, 21, 163, 95, 233, 46, 152, 189, 11, 204, 122, 41, 159, 88, 238, 203, 125, 186, 12, 240, 70, 129, 55, 18, 164, 99, 213, 197, 115, 180, 2, 39, 145, 86, 224, 28, 170, 109, 219, 254, 72, 143, 57, 106, 220, 27, 173, 136, 62, 249, 79, 179, 5, 194, 116, 81, 231, 32, 150, 17, 167, 96, 214, 243, 69, 130, 52, 200, 126, 185, 15, 42, 156, 91, 237, 190, 8, 207, 121, 92, 234, 45, 155, 103, 209, 22, 160, 133, 51, 244, 66, 82, 228, 35, 149, 176, 6, 193, 119, 139, 61, 250, 76, 105, 223, 24, 174, 253, 75, 140, 58, 31, 169, 110, 216, 36, 146, 85, 227, 198, 112, 183, 1, 151, 33, 230, 80, 117, 195, 4, 178, 78, 248, 63, 137, 172, 26, 221, 107, 56, 142, 73, 255, 218, 108, 171, 29, 225, 87, 144, 38, 3, 181, 114, 196, 212, 98, 165, 19, 54, 128, 71, 241, 13, 187, 124, 202, 239, 89, 158, 40, 123, 205, 10, 188, 153, 47, 232, 94, 162, 20, 211, 101, 64, 246, 49, 135, ],
[0, 183, 115, 196, 230, 81, 149, 34, 209, 102, 162, 21, 55, 128, 68, 243, 191, 8, 204, 123, 89, 238, 42, 157, 110, 217, 29, 170, 136, 63, 251, 76, 99, 212, 16, 167, 133, 50, 246, 65, 178, 5, 193, 118, 84, 227, 39, 144, 220, 107, 175, 24, 58, 141, 73, 254, 13, 186, 126, 201, 235, 92, 152, 47, 198, 113, 181, 2, 32, 151, 83, 228, 23, 160, 100, 211, 241, 70, 130, 53, 121, 206, 10, 189, 159, 40, 236, 91, 168, 31, 219, 108, 78, 249, 61, 138, 165, 18, 214, 97, 67, 244, 48, 135, 116, 195, 7, 176, 146, 37, 225, 86, 26, 173, 105, 222, 252, 75, 143, 56, 203, 124, 184, 15, 45, 154, 94, 233, 145, 38, 226, 85, 119, 192, 4, 179, 64, 247, 51, 132, 166, 17, 213, 98, 46, 153, 93, 234, 200, 127, 187, 12, 255, 72, 140, 59, 25, 174, 106, 221, 242, 69, 129, 54, 20, 163, 103, 208, 35, 148, 80, 231, 197, 114, 182, 1, 77, 250, 62, 137, 171, 28, 216, 111, 156, 43, 239, 88, 122, 205, 9, 190, 87, 224, 36, 147, 177, 6, 194, 117, 134, 49, 245, 66, 96, 215, 19, 164, 232, 95, 155, 44, 14, 185, 125, 202, 57, 142, 74, 253, 223, 104, 172, 27, 52, 131, 71, 240, 210, 101, 161, 22, 229, 82, 150, 33, 3, 180, 112, 199, 139, 60, 248, 79, 109, 218, 30, 169, 90, 237, 41, 158, 188, 11, 207, 120, ],
[0, 184, 109, 213, 218, 98, 183, 15, 169, 17, 196, 124, 115, 203, 30, 166, 79, 247, 34, 154, 149, 45, 248, 64, 230, 94, 139, 51, 60, 132, 81, 233, 158, 38, 243, 75, 68, 252, 41, 145, 55, 143, 90, 226, 237, 85, 128, 56, 209, 105, 188, 4, 11, 179, 102, 222, 120, 192, 21, 173, 162, 26, 207, 119, 33, 153, 76, 244, 251, 67, 150, 46, 136, 48, 229, 93, 82, 234, 63, 135, 110, 214, 3, 187, 180, 12, 217, 97, 199, 127, 170, 18, 29, 165, 112, 200, 191, 7, 210, 106, 101, 221, 8, 176, 22, 174, 123, 195, 204, 116, 161, 25, 240, 72, 157, 37, 42, 146, 71, 255, 89, 225, 52, 140, 131, 59, 238, 86, 66, 250, 47, 151, 152, 32, 245, 77, 235, 83, 134, 62, 49, 137, 92, 228, 13, 181, 96, 216, 215, 111, 186, 2, 164, 28, 201, 113, 126, 198, 19, 171, 220, 100, 177, 9, 6, 190, 107, 211, 117, 205, 24, 160, 175, 23, 194, 122, 147, 43, 254, 70, 73, 241, 36, 156, 58, 130, 87, 239, 224, 88, 141, 53, 99, 219, 14, 182, 185, 1, 212, 108, 202, 114, 167, 31, 16, 168, 125, 197, 44, 148, 65, 249, 246, 78, 155, 35, 133, 61, 232, 80, 95, 231, 50, 138, 253, 69, 144, 40, 39, 159, 74, 242, 84, 236, 57, 129, 142, 54, 227, 91, 178, 10, 223, 103, 104, 208, 5, 189, 27, 163, 118, 206, 193, 121, 172, 20, ],
[0, 185, 111, 214, 222, 103, 177, 8, 161, 24, 206, 119, 127, 198, 16, 169, 95, 230, 48, 137, 129, 56, 238, 87, 254, 71, 145, 40, 32, 153, 79, 246, 190, 7, 209, 104, 96, 217, 15, 182, 31, 166, 112, 201, 193, 120, 174, 23, 225, 88, 142, 55, 63, 134, 80, 233, 64, 249, 47, 150, 158, 39, 241, 72, 97, 216, 14, 183, 191, 6, 208, 105, 192, 121, 175, 22, 30, 167, 113, 200, 62, 135, 81, 232, 224, 89, 143, 54, 159, 38, 240, 73, 65, 248, 46, 151, 223, 102, 176, 9, 1, 184, 110, 215, 126, 199, 17, 168, 160, 25, 207, 118, 128, 57, 239, 86, 94, 231, 49, 136, 33, 152, 78, 247, 255, 70, 144, 41, 194, 123, 173, 20, 28, 165, 115, 202, 99, 218, 12, 181, 189, 4, 210, 107, 157, 36, 242, 75, 67, 250, 44, 149, 60, 133, 83, 234, 226, 91, 141, 52, 124, 197, 19, 170, 162, 27, 205, 116, 221, 100, 178, 11, 3, 186, 108, 213, 35, 154, 76, 245, 253, 68, 146, 43, 130, 59, 237, 84, 92, 229, 51, 138, 163, 26, 204, 117, 125, 196, 18, 171, 2, 187, 109, 212, 220, 101, 179, 10, 252, 69, 147, 42, 34, 155, 77, 244, 93, 228, 50, 139, 131, 58, 236, 85, 29, 164, 114, 203, 195, 122, 172, 21, 188, 5, 211, 106, 98, 219, 13, 180, 66, 251, 45, 148, 156, 37, 243, 74, 227, 90, 140, 53, 61, 132, 82, 235, ],
[0, 186, 105, 211, 210, 104, 187, 1, 185, 3, 208, 106, 107, 209, 2, 184, 111, 213, 6, 188, 189, 7, 212, 110, 214, 108, 191, 5, 4, 190, 109, 215, 222, 100, 183, 13, 12, 182, 101, 223, 103, 221, 14, 180, 181, 15, 220, 102, 177, 11, 216, 98, 99, 217, 10, 176, 8, 178, 97, 219, 218, 96, 179, 9, 161, 27, 200, 114, 115, 201, 26, 160, 24, 162, 113, 203, 202, 112, 163, 25, 206, 116, 167, 29, 28, 166, 117, 207, 119, 205, 30, 164, 165, 31, 204, 118, 127, 197, 22, 172, 173, 23, 196, 126, 198, 124, 175, 21, 20, 174, 125, 199, 16, 170, 121, 195, 194, 120, 171, 17, 169, 19, 192, 122, 123, 193, 18, 168, 95, 229, 54, 140, 141, 55, 228, 94, 230, 92, 143, 53, 52, 142, 93, 231, 48, 138, 89, 227, 226, 88, 139, 49, 137, 51, 224, 90, 91, 225, 50, 136, 129, 59, 232, 82, 83, 233, 58, 128, 56, 130, 81, 235, 234, 80, 131, 57, 238, 84, 135, 61, 60, 134, 85, 239, 87, 237, 62, 132, 133, 63, 236, 86, 254, 68, 151, 45, 44, 150, 69, 255, 71, 253, 46, 148, 149, 47, 252, 70, 145, 43, 248, 66, 67, 249, 42, 144, 40, 146, 65, 251, 250, 64, 147, 41, 32, 154, 73, 243, 242, 72, 155, 33, 153, 35, 240, 74, 75, 241, 34, 152, 79, 245, 38, 156, 157, 39, 244, 78, 246, 76, 159, 37, 36, 158, 77, 247, ],
[0, 187, 107, 208, 214, 109, 189, 6, 177, 10, 218, 97, 103, 220, 12, 183, 127, 196, 20, 175, 169, 18, 194, 121, 206, 117, 165, 30, 24, 163, 115, 200, 254, 69, 149, 46, 40, 147, 67, 248, 79, 244, 36, 159, 153, 34, 242, 73, 129, 58, 234, 81, 87, 236, 60, 135, 48, 139, 91, 224, 230, 93, 141, 54, 225, 90, 138, 49, 55, 140, 92, 231, 80, 235, 59, 128, 134, 61, 237, 86, 158, 37, 245, 78, 72, 243, 35, 152, 47, 148, 68, 255, 249, 66, 146, 41, 31, 164, 116, 207, 201, 114, 162, 25, 174, 21, 197, 126, 120, 195, 19, 168, 96, 219, 11, 176, 182, 13, 221, 102, 209, 106, 186, 1, 7, 188, 108, 215, 223, 100, 180, 15, 9, 178, 98, 217, 110, 213, 5, 190, 184, 3, 211, 104, 160, 27, 203, 112, 118, 205, 29, 166, 17, 170, 122, 193, 199, 124, 172, 23, 33, 154, 74, 241, 247, 76, 156, 39, 144, 43, 251, 64, 70, 253, 45, 150, 94, 229, 53, 142, 136, 51, 227, 88, 239, 84, 132, 63, 57, 130, 82, 233, 62, 133, 85, 238, 232, 83, 131, 56, 143, 52, 228, 95, 89, 226, 50, 137, 65, 250, 42, 145, 151, 44, 252, 71, 240, 75, 155, 32, 38, 157, 77, 246, 192, 123, 171, 16, 22, 173, 125, 198, 113, 202, 26, 161, 167, 28, 204, 119, 191, 4, 212, 111, 105, 210, 2, 185, 14, 181, 101, 222, 216, 99, 179, 8, ],
[0, 188, 101, 217, 202, 118, 175, 19, 137, 53, 236, 80, 67, 255, 38, 154, 15, 179, 106, 214, 197, 121, 160, 28, 134, 58, 227, 95, 76, 240, 41, 149, 30, 162, 123, 199, 212, 104, 177, 13, 151, 43, 242, 78, 93, 225, 56, 132, 17, 173, 116, 200, 219, 103, 190, 2, 152, 36, 253, 65, 82, 238, 55, 139, 60, 128, 89, 229, 246, 74, 147, 47, 181, 9, 208, 108, 127, 195, 26, 166, 51, 143, 86, 234, 249, 69, 156, 32, 186, 6, 223, 99, 112, 204, 21, 169, 34, 158, 71, 251, 232, 84, 141, 49, 171, 23, 206, 114, 97, 221, 4, 184, 45, 145, 72, 244, 231, 91, 130, 62, 164, 24, 193, 125, 110, 210, 11, 183, 120, 196, 29, 161, 178, 14, 215, 107, 241, 77, 148, 40, 59, 135, 94, 226, 119, 203, 18, 174, 189, 1, 216, 100, 254, 66, 155, 39, 52, 136, 81, 237, 102, 218, 3, 191, 172, 16, 201, 117, 239, 83, 138, 54, 37, 153, 64, 252, 105, 213, 12, 176, 163, 31, 198, 122, 224, 92, 133, 57, 42, 150, 79, 243, 68, 248, 33, 157, 142, 50, 235, 87, 205, 113, 168, 20, 7, 187, 98, 222, 75, 247, 46, 146, 129, 61, 228, 88, 194, 126, 167, 27, 8, 180, 109, 209, 90, 230, 63, 131, 144, 44, 245, 73, 211, 111, 182, 10, 25, 165, 124, 192, 85, 233, 48, 140, 159, 35, 250, 70, 220, 96, 185, 5, 22, 170, 115, 207, ],
[0, 189, 103, 218, 206, 115, 169, 20, 129, 60, 230, 91, 79, 242, 40, 149, 31, 162, 120, 197, 209, 108, 182, 11, 158, 35, 249, 68, 80, 237, 55, 138, 62, 131, 89, 228, 240, 77, 151, 42, 191, 2, 216, 101, 113, 204, 22, 171, 33, 156, 70, 251, 239, 82, 136, 53, 160, 29, 199, 122, 110, 211, 9, 180, 124, 193, 27, 166, 178, 15, 213, 104, 253, 64, 154, 39, 51, 142, 84, 233, 99, 222, 4, 185, 173, 16, 202, 119, 226, 95, 133, 56, 44, 145, 75, 246, 66, 255, 37, 152, 140, 49, 235, 86, 195, 126, 164, 25, 13, 176, 106, 215, 93, 224, 58, 135, 147, 46, 244, 73, 220, 97, 187, 6, 18, 175, 117, 200, 248, 69, 159, 34, 54, 139, 81, 236, 121, 196, 30, 163, 183, 10, 208, 109, 231, 90, 128, 61, 41, 148, 78, 243, 102, 219, 1, 188, 168, 21, 207, 114, 198, 123, 161, 28, 8, 181, 111, 210, 71, 250, 32, 157, 137, 52, 238, 83, 217, 100, 190, 3, 23, 170, 112, 205, 88, 229, 63, 130, 150, 43, 241, 76, 132, 57, 227, 94, 74, 247, 45, 144, 5, 184, 98, 223, 203, 118, 172, 17, 155, 38, 252, 65, 85, 232, 50, 143, 26, 167, 125, 192, 212, 105, 179, 14, 186, 7, 221, 96, 116, 201, 19, 174, 59, 134, 92, 225, 245, 72, 146, 47, 165, 24, 194, 127, 107, 214, 12, 177, 36, 153, 67, 254, 234, 87, 141, 48, ],
[0, 190, 97, 223, 194, 124, 163, 29, 153, 39, 248, 70, 91, 229, 58, 132, 47, 145, 78, 240, 237, 83, 140, 50, 182, 8, 215, 105, 116, 202, 21, 171, 94, 224, 63, 129, 156, 34, 253, 67, 199, 121, 166, 24, 5, 187, 100, 218, 113, 207, 16, 174, 179, 13, 210, 108, 232, 86, 137, 55, 42, 148, 75, 245, 188, 2, 221, 99, 126, 192, 31, 161, 37, 155, 68, 250, 231, 89, 134, 56, 147, 45, 242, 76, 81, 239, 48, 142, 10, 180, 107, 213, 200, 118, 169, 23, 226, 92, 131, 61, 32, 158, 65, 255, 123, 197, 26, 164, 185, 7, 216, 102, 205, 115, 172, 18, 15, 177, 110, 208, 84, 234, 53, 139, 150, 40, 247, 73, 101, 219, 4, 186, 167, 25, 198, 120, 252, 66, 157, 35, 62, 128, 95, 225, 74, 244, 43, 149, 136, 54, 233, 87, 211, 109, 178, 12, 17, 175, 112, 206, 59, 133, 90, 228, 249, 71, 152, 38, 162, 28, 195, 125, 96, 222, 1, 191, 20, 170, 117, 203, 214, 104, 183, 9, 141, 51, 236, 82, 79, 241, 46, 144, 217, 103, 184, 6, 27, 165, 122, 196, 64, 254, 33, 159, 130, 60, 227, 93, 246, 72, 151, 41, 52, 138, 85, 235, 111, 209, 14, 176, 173, 19, 204, 114, 135, 57, 230, 88, 69, 251, 36, 154, 30, 160, 127, 193, 220, 98, 189, 3, 168, 22, 201, 119, 106, 212, 11, 181, 49, 143, 80, 238, 243, 77, 146, 44, ],
[0, 191, 99, 220, 198, 121, 165, 26, 145, 46, 242, 77, 87, 232, 52, 139, 63, 128, 92, 227, 249, 70, 154, 37, 174, 17, 205, 114, 104, 215, 11, 180, 126, 193, 29, 162, 184, 7, 219, 100, 239, 80, 140, 51, 41, 150, 74, 245, 65, 254, 34, 157, 135, 56, 228, 91, 208, 111, 179, 12, 22, 169, 117, 202, 252, 67, 159, 32, 58, 133, 89, 230, 109, 210, 14, 177, 171, 20, 200, 119, 195, 124, 160, 31, 5, 186, 102, 217, 82, 237, 49, 142, 148, 43, 247, 72, 130, 61, 225, 94, 68, 251, 39, 152, 19, 172, 112, 207, 213, 106, 182, 9, 189, 2, 222, 97, 123, 196, 24, 167, 44, 147, 79, 240, 234, 85, 137, 54, 229, 90, 134, 57, 35, 156, 64, 255, 116, 203, 23, 168, 178, 13, 209, 110, 218, 101, 185, 6, 28, 163, 127, 192, 75, 244, 40, 151, 141, 50, 238, 81, 155, 36, 248, 71, 93, 226, 62, 129, 10, 181, 105, 214, 204, 115, 175, 16, 164, 27, 199, 120, 98, 221, 1, 190, 53, 138, 86, 233, 243, 76, 144, 47, 25, 166, 122, 197, 223, 96, 188, 3, 136, 55, 235, 84, 78, 241, 45, 146, 38, 153, 69, 250, 224, 95, 131, 60, 183, 8, 212, 107, 113, 206, 18, 173, 103, 216, 4, 187, 161, 30, 194, 125, 246, 73, 149, 42, 48, 143, 83, 236, 88, 231, 59, 132, 158, 33, 253, 66, 201, 118, 170, 21, 15, 176, 108, 211, ],
[0, 192, 157, 93, 39, 231, 186, 122, 78, 142, 211, 19, 105, 169, 244, 52, 156, 92, 1, 193, 187, 123, 38, 230, 210, 18, 79, 143, 245, 53, 104, 168, 37, 229, 184, 120, 2, 194, 159, 95, 107, 171, 246, 54, 76, 140, 209, 17, 185, 121, 36, 228, 158, 94, 3, 195, 247, 55, 106, 170, 208, 16, 77, 141, 74, 138, 215, 23, 109, 173, 240, 48, 4, 196, 153, 89, 35, 227, 190, 126, 214, 22, 75, 139, 241, 49, 108, 172, 152, 88, 5, 197, 191, 127, 34, 226, 111, 175, 242, 50, 72, 136, 213, 21, 33, 225, 188, 124, 6, 198, 155, 91, 243, 51, 110, 174, 212, 20, 73, 137, 189, 125, 32, 224, 154, 90, 7, 199, 148, 84, 9, 201, 179, 115, 46, 238, 218, 26, 71, 135, 253, 61, 96, 160, 8, 200, 149, 85, 47, 239, 178, 114, 70, 134, 219, 27, 97, 161, 252, 60, 177, 113, 44, 236, 150, 86, 11, 203, 255, 63, 98, 162, 216, 24, 69, 133, 45, 237, 176, 112, 10, 202, 151, 87, 99, 163, 254, 62, 68, 132, 217, 25, 222, 30, 67, 131, 249, 57, 100, 164, 144, 80, 13, 205, 183, 119, 42, 234, 66, 130, 223, 31, 101, 165, 248, 56, 12, 204, 145, 81, 43, 235, 182, 118, 251, 59, 102, 166, 220, 28, 65, 129, 181, 117, 40, 232, 146, 82, 15, 207, 103, 167, 250, 58, 64, 128, 221, 29, 41, 233, 180, 116, 14, 206, 147, 83, ],
[0, 193, 159, 94, 35, 226, 188, 125, 70, 135, 217, 24, 101, 164, 250, 59, 140, 77, 19, 210, 175, 110, 48, 241, 202, 11, 85, 148, 233, 40, 118, 183, 5, 196, 154, 91, 38, 231, 185, 120, 67, 130, 220, 29, 96, 161, 255, 62, 137, 72, 22, 215, 170, 107, 53, 244, 207, 14, 80, 145, 236, 45, 115, 178, 10, 203, 149, 84, 41, 232, 182, 119, 76, 141, 211, 18, 111, 174, 240, 49, 134, 71, 25, 216, 165, 100, 58, 251, 192, 1, 95, 158, 227, 34, 124, 189, 15, 206, 144, 81, 44, 237, 179, 114, 73, 136, 214, 23, 106, 171, 245, 52, 131, 66, 28, 221, 160, 97, 63, 254, 197, 4, 90, 155, 230, 39, 121, 184, 20, 213, 139, 74, 55, 246, 168, 105, 82, 147, 205, 12, 113, 176, 238, 47, 152, 89, 7, 198, 187, 122, 36, 229, 222, 31, 65, 128, 253, 60, 98, 163, 17, 208, 142, 79, 50, 243, 173, 108, 87, 150, 200, 9, 116, 181, 235, 42, 157, 92, 2, 195, 190, 127, 33, 224, 219, 26, 68, 133, 248, 57, 103, 166, 30, 223, 129, 64, 61, 252, 162, 99, 88, 153, 199, 6, 123, 186, 228, 37, 146, 83, 13, 204, 177, 112, 46, 239, 212, 21, 75, 138, 247, 54, 104, 169, 27, 218, 132, 69, 56, 249, 167, 102, 93, 156, 194, 3, 126, 191, 225, 32, 151, 86, 8, 201, 180, 117, 43, 234, 209, 16, 78, 143, 242, 51, 109, 172, ],
[0, 194, 153, 91, 47, 237, 182, 116, 94, 156, 199, 5, 113, 179, 232, 42, 188, 126, 37, 231, 147, 81, 10, 200, 226, 32, 123, 185, 205, 15, 84, 150, 101, 167, 252, 62, 74, 136, 211, 17, 59, 249, 162, 96, 20, 214, 141, 79, 217, 27, 64, 130, 246, 52, 111, 173, 135, 69, 30, 220, 168, 106, 49, 243, 202, 8, 83, 145, 229, 39, 124, 190, 148, 86, 13, 207, 187, 121, 34, 224, 118, 180, 239, 45, 89, 155, 192, 2, 40, 234, 177, 115, 7, 197, 158, 92, 175, 109, 54, 244, 128, 66, 25, 219, 241, 51, 104, 170, 222, 28, 71, 133, 19, 209, 138, 72, 60, 254, 165, 103, 77, 143, 212, 22, 98, 160, 251, 57, 137, 75, 16, 210, 166, 100, 63, 253, 215, 21, 78, 140, 248, 58, 97, 163, 53, 247, 172, 110, 26, 216, 131, 65, 107, 169, 242, 48, 68, 134, 221, 31, 236, 46, 117, 183, 195, 1, 90, 152, 178, 112, 43, 233, 157, 95, 4, 198, 80, 146, 201, 11, 127, 189, 230, 36, 14, 204, 151, 85, 33, 227, 184, 122, 67, 129, 218, 24, 108, 174, 245, 55, 29, 223, 132, 70, 50, 240, 171, 105, 255, 61, 102, 164, 208, 18, 73, 139, 161, 99, 56, 250, 142, 76, 23, 213, 38, 228, 191, 125, 9, 203, 144, 82, 120, 186, 225, 35, 87, 149, 206, 12, 154, 88, 3, 193, 181, 119, 44, 238, 196, 6, 93, 159, 235, 41, 114, 176, ],
[0, 195, 155, 88, 43, 232, 176, 115, 86, 149, 205, 14, 125, 190, 230, 37, 172, 111, 55, 244, 135, 68, 28, 223, 250, 57, 97, 162, 209, 18, 74, 137, 69, 134, 222, 29, 110, 173, 245, 54, 19, 208, 136, 75, 56, 251, 163, 96, 233, 42, 114, 177, 194, 1, 89, 154, 191, 124, 36, 231, 148, 87, 15, 204, 138, 73, 17, 210, 161, 98, 58, 249, 220, 31, 71, 132, 247, 52, 108, 175, 38, 229, 189, 126, 13, 206, 150, 85, 112, 179, 235, 40, 91, 152, 192, 3, 207, 12, 84, 151, 228, 39, 127, 188, 153, 90, 2, 193, 178, 113, 41, 234, 99, 160, 248, 59, 72, 139, 211, 16, 53, 246, 174, 109, 30, 221, 133, 70, 9, 202, 146, 81, 34, 225, 185, 122, 95, 156, 196, 7, 116, 183, 239, 44, 165, 102, 62, 253, 142, 77, 21, 214, 243, 48, 104, 171, 216, 27, 67, 128, 76, 143, 215, 20, 103, 164, 252, 63, 26, 217, 129, 66, 49, 242, 170, 105, 224, 35, 123, 184, 203, 8, 80, 147, 182, 117, 45, 238, 157, 94, 6, 197, 131, 64, 24, 219, 168, 107, 51, 240, 213, 22, 78, 141, 254, 61, 101, 166, 47, 236, 180, 119, 4, 199, 159, 92, 121, 186, 226, 33, 82, 145, 201, 10, 198, 5, 93, 158, 237, 46, 118, 181, 144, 83, 11, 200, 187, 120, 32, 227, 106, 169, 241, 50, 65, 130, 218, 25, 60, 255, 167, 100, 23, 212, 140, 79, ],
[0, 196, 149, 81, 55, 243, 162, 102, 110, 170, 251, 63, 89, 157, 204, 8, 220, 24, 73, 141, 235, 47, 126, 186, 178, 118, 39, 227, 133, 65, 16, 212, 165, 97, 48, 244, 146, 86, 7, 195, 203, 15, 94, 154, 252, 56, 105, 173, 121, 189, 236, 40, 78, 138, 219, 31, 23, 211, 130, 70, 32, 228, 181, 113, 87, 147, 194, 6, 96, 164, 245, 49, 57, 253, 172, 104, 14, 202, 155, 95, 139, 79, 30, 218, 188, 120, 41, 237, 229, 33, 112, 180, 210, 22, 71, 131, 242, 54, 103, 163, 197, 1, 80, 148, 156, 88, 9, 205, 171, 111, 62, 250, 46, 234, 187, 127, 25, 221, 140, 72, 64, 132, 213, 17, 119, 179, 226, 38, 174, 106, 59, 255, 153, 93, 12, 200, 192, 4, 85, 145, 247, 51, 98, 166, 114, 182, 231, 35, 69, 129, 208, 20, 28, 216, 137, 77, 43, 239, 190, 122, 11, 207, 158, 90, 60, 248, 169, 109, 101, 161, 240, 52, 82, 150, 199, 3, 215, 19, 66, 134, 224, 36, 117, 177, 185, 125, 44, 232, 142, 74, 27, 223, 249, 61, 108, 168, 206, 10, 91, 159, 151, 83, 2, 198, 160, 100, 53, 241, 37, 225, 176, 116, 18, 214, 135, 67, 75, 143, 222, 26, 124, 184, 233, 45, 92, 152, 201, 13, 107, 175, 254, 58, 50, 246, 167, 99, 5, 193, 144, 84, 128, 68, 21, 209, 183, 115, 34, 230, 238, 42, 123, 191, 217, 29, 76, 136, ],
[0, 197, 151, 82, 51, 246, 164, 97, 102, 163, 241, 52, 85, 144, 194, 7, 204, 9, 91, 158, 255, 58, 104, 173, 170, 111, 61, 248, 153, 92, 14, 203, 133, 64, 18, 215, 182, 115, 33, 228, 227, 38, 116, 177, 208, 21, 71, 130, 73, 140, 222, 27, 122, 191, 237, 40, 47, 234, 184, 125, 28, 217, 139, 78, 23, 210, 128, 69, 36, 225, 179, 118, 113, 180, 230, 35, 66, 135, 213, 16, 219, 30, 76, 137, 232, 45, 127, 186, 189, 120, 42, 239, 142, 75, 25, 220, 146, 87, 5, 192, 161, 100, 54, 243, 244, 49, 99, 166, 199, 2, 80, 149, 94, 155, 201, 12, 109, 168, 250, 63, 56, 253, 175, 106, 11, 206, 156, 89, 46, 235, 185, 124, 29, 216, 138, 79, 72, 141, 223, 26, 123, 190, 236, 41, 226, 39, 117, 176, 209, 20, 70, 131, 132, 65, 19, 214, 183, 114, 32, 229, 171, 110, 60, 249, 152, 93, 15, 202, 205, 8, 90, 159, 254, 59, 105, 172, 103, 162, 240, 53, 84, 145, 195, 6, 1, 196, 150, 83, 50, 247, 165, 96, 57, 252, 174, 107, 10, 207, 157, 88, 95, 154, 200, 13, 108, 169, 251, 62, 245, 48, 98, 167, 198, 3, 81, 148, 147, 86, 4, 193, 160, 101, 55, 242, 188, 121, 43, 238, 143, 74, 24, 221, 218, 31, 77, 136, 233, 44, 126, 187, 112, 181, 231, 34, 67, 134, 212, 17, 22, 211, 129, 68, 37, 224, 178, 119, ],
[0, 198, 145, 87, 63, 249, 174, 104, 126, 184, 239, 41, 65, 135, 208, 22, 252, 58, 109, 171, 195, 5, 82, 148, 130, 68, 19, 213, 189, 123, 44, 234, 229, 35, 116, 178, 218, 28, 75, 141, 155, 93, 10, 204, 164, 98, 53, 243, 25, 223, 136, 78, 38, 224, 183, 113, 103, 161, 246, 48, 88, 158, 201, 15, 215, 17, 70, 128, 232, 46, 121, 191, 169, 111, 56, 254, 150, 80, 7, 193, 43, 237, 186, 124, 20, 210, 133, 67, 85, 147, 196, 2, 106, 172, 251, 61, 50, 244, 163, 101, 13, 203, 156, 90, 76, 138, 221, 27, 115, 181, 226, 36, 206, 8, 95, 153, 241, 55, 96, 166, 176, 118, 33, 231, 143, 73, 30, 216, 179, 117, 34, 228, 140, 74, 29, 219, 205, 11, 92, 154, 242, 52, 99, 165, 79, 137, 222, 24, 112, 182, 225, 39, 49, 247, 160, 102, 14, 200, 159, 89, 86, 144, 199, 1, 105, 175, 248, 62, 40, 238, 185, 127, 23, 209, 134, 64, 170, 108, 59, 253, 149, 83, 4, 194, 212, 18, 69, 131, 235, 45, 122, 188, 100, 162, 245, 51, 91, 157, 202, 12, 26, 220, 139, 77, 37, 227, 180, 114, 152, 94, 9, 207, 167, 97, 54, 240, 230, 32, 119, 177, 217, 31, 72, 142, 129, 71, 16, 214, 190, 120, 47, 233, 255, 57, 110, 168, 192, 6, 81, 151, 125, 187, 236, 42, 66, 132, 211, 21, 3, 197, 146, 84, 60, 250, 173, 107, ],
[0, 199, 147, 84, 59, 252, 168, 111, 118, 177, 229, 34, 77, 138, 222, 25, 236, 43, 127, 184, 215, 16, 68, 131, 154, 93, 9, 206, 161, 102, 50, 245, 197, 2, 86, 145, 254, 57, 109, 170, 179, 116, 32, 231, 136, 79, 27, 220, 41, 238, 186, 125, 18, 213, 129, 70, 95, 152, 204, 11, 100, 163, 247, 48, 151, 80, 4, 195, 172, 107, 63, 248, 225, 38, 114, 181, 218, 29, 73, 142, 123, 188, 232, 47, 64, 135, 211, 20, 13, 202, 158, 89, 54, 241, 165, 98, 82, 149, 193, 6, 105, 174, 250, 61, 36, 227, 183, 112, 31, 216, 140, 75, 190, 121, 45, 234, 133, 66, 22, 209, 200, 15, 91, 156, 243, 52, 96, 167, 51, 244, 160, 103, 8, 207, 155, 92, 69, 130, 214, 17, 126, 185, 237, 42, 223, 24, 76, 139, 228, 35, 119, 176, 169, 110, 58, 253, 146, 85, 1, 198, 246, 49, 101, 162, 205, 10, 94, 153, 128, 71, 19, 212, 187, 124, 40, 239, 26, 221, 137, 78, 33, 230, 178, 117, 108, 171, 255, 56, 87, 144, 196, 3, 164, 99, 55, 240, 159, 88, 12, 203, 210, 21, 65, 134, 233, 46, 122, 189, 72, 143, 219, 28, 115, 180, 224, 39, 62, 249, 173, 106, 5, 194, 150, 81, 97, 166, 242, 53, 90, 157, 201, 14, 23, 208, 132, 67, 44, 235, 191, 120, 141, 74, 30, 217, 182, 113, 37, 226, 251, 60, 104, 175, 192, 7, 83, 148, ],
[0, 200, 141, 69, 7, 207, 138, 66, 14, 198, 131, 75, 9, 193, 132, 76, 28, 212, 145, 89, 27, 211, 150, 94, 18, 218, 159, 87, 21, 221, 152, 80, 56, 240, 181, 125, 63, 247, 178, 122, 54, 254, 187, 115, 49, 249, 188, 116, 36, 236, 169, 97, 35, 235, 174, 102, 42, 226, 167, 111, 45, 229, 160, 104, 112, 184, 253, 53, 119, 191, 250, 50, 126, 182, 243, 59, 121, 177, 244, 60, 108, 164, 225, 41, 107, 163, 230, 46, 98, 170, 239, 39, 101, 173, 232, 32, 72, 128, 197, 13, 79, 135, 194, 10, 70, 142, 203, 3, 65, 137, 204, 4, 84, 156, 217, 17, 83, 155, 222, 22, 90, 146, 215, 31, 93, 149, 208, 24, 224, 40, 109, 165, 231, 47, 106, 162, 238, 38, 99, 171, 233, 33, 100, 172, 252, 52, 113, 185, 251, 51, 118, 190, 242, 58, 127, 183, 245, 61, 120, 176, 216, 16, 85, 157, 223, 23, 82, 154, 214, 30, 91, 147, 209, 25, 92, 148, 196, 12, 73, 129, 195, 11, 78, 134, 202, 2, 71, 143, 205, 5, 64, 136, 144, 88, 29, 213, 151, 95, 26, 210, 158, 86, 19, 219, 153, 81, 20, 220, 140, 68, 1, 201, 139, 67, 6, 206, 130, 74, 15, 199, 133, 77, 8, 192, 168, 96, 37, 237, 175, 103, 34, 234, 166, 110, 43, 227, 161, 105, 44, 228, 180, 124, 57, 241, 179, 123, 62, 246, 186, 114, 55, 255, 189, 117, 48, 248, ],
[0, 201, 143, 70, 3, 202, 140, 69, 6, 207, 137, 64, 5, 204, 138, 67, 12, 197, 131, 74, 15, 198, 128, 73, 10, 195, 133, 76, 9, 192, 134, 79, 24, 209, 151, 94, 27, 210, 148, 93, 30, 215, 145, 88, 29, 212, 146, 91, 20, 221, 155, 82, 23, 222, 152, 81, 18, 219, 157, 84, 17, 216, 158, 87, 48, 249, 191, 118, 51, 250, 188, 117, 54, 255, 185, 112, 53, 252, 186, 115, 60, 245, 179, 122, 63, 246, 176, 121, 58, 243, 181, 124, 57, 240, 182, 127, 40, 225, 167, 110, 43, 226, 164, 109, 46, 231, 161, 104, 45, 228, 162, 107, 36, 237, 171, 98, 39, 238, 168, 97, 34, 235, 173, 100, 33, 232, 174, 103, 96, 169, 239, 38, 99, 170, 236, 37, 102, 175, 233, 32, 101, 172, 234, 35, 108, 165, 227, 42, 111, 166, 224, 41, 106, 163, 229, 44, 105, 160, 230, 47, 120, 177, 247, 62, 123, 178, 244, 61, 126, 183, 241, 56, 125, 180, 242, 59, 116, 189, 251, 50, 119, 190, 248, 49, 114, 187, 253, 52, 113, 184, 254, 55, 80, 153, 223, 22, 83, 154, 220, 21, 86, 159, 217, 16, 85, 156, 218, 19, 92, 149, 211, 26, 95, 150, 208, 25, 90, 147, 213, 28, 89, 144, 214, 31, 72, 129, 199, 14, 75, 130, 196, 13, 78, 135, 193, 8, 77, 132, 194, 11, 68, 141, 203, 2, 71, 142, 200, 1, 66, 139, 205, 4, 65, 136, 206, 7, ],
[0, 202, 137, 67, 15, 197, 134, 76, 30, 212, 151, 93, 17, 219, 152, 82, 60, 246, 181, 127, 51, 249, 186, 112, 34, 232, 171, 97, 45, 231, 164, 110, 120, 178, 241, 59, 119, 189, 254, 52, 102, 172, 239, 37, 105, 163, 224, 42, 68, 142, 205, 7, 75, 129, 194, 8, 90, 144, 211, 25, 85, 159, 220, 22, 240, 58, 121, 179, 255, 53, 118, 188, 238, 36, 103, 173, 225, 43, 104, 162, 204, 6, 69, 143, 195, 9, 74, 128, 210, 24, 91, 145, 221, 23, 84, 158, 136, 66, 1, 203, 135, 77, 14, 196, 150, 92, 31, 213, 153, 83, 16, 218, 180, 126, 61, 247, 187, 113, 50, 248, 170, 96, 35, 233, 165, 111, 44, 230, 253, 55, 116, 190, 242, 56, 123, 177, 227, 41, 106, 160, 236, 38, 101, 175, 193, 11, 72, 130, 206, 4, 71, 141, 223, 21, 86, 156, 208, 26, 89, 147, 133, 79, 12, 198, 138, 64, 3, 201, 155, 81, 18, 216, 148, 94, 29, 215, 185, 115, 48, 250, 182, 124, 63, 245, 167, 109, 46, 228, 168, 98, 33, 235, 13, 199, 132, 78, 2, 200, 139, 65, 19, 217, 154, 80, 28, 214, 149, 95, 49, 251, 184, 114, 62, 244, 183, 125, 47, 229, 166, 108, 32, 234, 169, 99, 117, 191, 252, 54, 122, 176, 243, 57, 107, 161, 226, 40, 100, 174, 237, 39, 73, 131, 192, 10, 70, 140, 207, 5, 87, 157, 222, 20, 88, 146, 209, 27, ],
[0, 203, 139, 64, 11, 192, 128, 75, 22, 221, 157, 86, 29, 214, 150, 93, 44, 231, 167, 108, 39, 236, 172, 103, 58, 241, 177, 122, 49, 250, 186, 113, 88, 147, 211, 24, 83, 152, 216, 19, 78, 133, 197, 14, 69, 142, 206, 5, 116, 191, 255, 52, 127, 180, 244, 63, 98, 169, 233, 34, 105, 162, 226, 41, 176, 123, 59, 240, 187, 112, 48, 251, 166, 109, 45, 230, 173, 102, 38, 237, 156, 87, 23, 220, 151, 92, 28, 215, 138, 65, 1, 202, 129, 74, 10, 193, 232, 35, 99, 168, 227, 40, 104, 163, 254, 53, 117, 190, 245, 62, 126, 181, 196, 15, 79, 132, 207, 4, 68, 143, 210, 25, 89, 146, 217, 18, 82, 153, 125, 182, 246, 61, 118, 189, 253, 54, 107, 160, 224, 43, 96, 171, 235, 32, 81, 154, 218, 17, 90, 145, 209, 26, 71, 140, 204, 7, 76, 135, 199, 12, 37, 238, 174, 101, 46, 229, 165, 110, 51, 248, 184, 115, 56, 243, 179, 120, 9, 194, 130, 73, 2, 201, 137, 66, 31, 212, 148, 95, 20, 223, 159, 84, 205, 6, 70, 141, 198, 13, 77, 134, 219, 16, 80, 155, 208, 27, 91, 144, 225, 42, 106, 161, 234, 33, 97, 170, 247, 60, 124, 183, 252, 55, 119, 188, 149, 94, 30, 213, 158, 85, 21, 222, 131, 72, 8, 195, 136, 67, 3, 200, 185, 114, 50, 249, 178, 121, 57, 242, 175, 100, 36, 239, 164, 111, 47, 228, ],
[0, 204, 133, 73, 23, 219, 146, 94, 46, 226, 171, 103, 57, 245, 188, 112, 92, 144, 217, 21, 75, 135, 206, 2, 114, 190, 247, 59, 101, 169, 224, 44, 184, 116, 61, 241, 175, 99, 42, 230, 150, 90, 19, 223, 129, 77, 4, 200, 228, 40, 97, 173, 243, 63, 118, 186, 202, 6, 79, 131, 221, 17, 88, 148, 109, 161, 232, 36, 122, 182, 255, 51, 67, 143, 198, 10, 84, 152, 209, 29, 49, 253, 180, 120, 38, 234, 163, 111, 31, 211, 154, 86, 8, 196, 141, 65, 213, 25, 80, 156, 194, 14, 71, 139, 251, 55, 126, 178, 236, 32, 105, 165, 137, 69, 12, 192, 158, 82, 27, 215, 167, 107, 34, 238, 176, 124, 53, 249, 218, 22, 95, 147, 205, 1, 72, 132, 244, 56, 113, 189, 227, 47, 102, 170, 134, 74, 3, 207, 145, 93, 20, 216, 168, 100, 45, 225, 191, 115, 58, 246, 98, 174, 231, 43, 117, 185, 240, 60, 76, 128, 201, 5, 91, 151, 222, 18, 62, 242, 187, 119, 41, 229, 172, 96, 16, 220, 149, 89, 7, 203, 130, 78, 183, 123, 50, 254, 160, 108, 37, 233, 153, 85, 28, 208, 142, 66, 11, 199, 235, 39, 110, 162, 252, 48, 121, 181, 197, 9, 64, 140, 210, 30, 87, 155, 15, 195, 138, 70, 24, 212, 157, 81, 33, 237, 164, 104, 54, 250, 179, 127, 83, 159, 214, 26, 68, 136, 193, 13, 125, 177, 248, 52, 106, 166, 239, 35, ],
[0, 205, 135, 74, 19, 222, 148, 89, 38, 235, 161, 108, 53, 248, 178, 127, 76, 129, 203, 6, 95, 146, 216, 21, 106, 167, 237, 32, 121, 180, 254, 51, 152, 85, 31, 210, 139, 70, 12, 193, 190, 115, 57, 244, 173, 96, 42, 231, 212, 25, 83, 158, 199, 10, 64, 141, 242, 63, 117, 184, 225, 44, 102, 171, 45, 224, 170, 103, 62, 243, 185, 116, 11, 198, 140, 65, 24, 213, 159, 82, 97, 172, 230, 43, 114, 191, 245, 56, 71, 138, 192, 13, 84, 153, 211, 30, 181, 120, 50, 255, 166, 107, 33, 236, 147, 94, 20, 217, 128, 77, 7, 202, 249, 52, 126, 179, 234, 39, 109, 160, 223, 18, 88, 149, 204, 1, 75, 134, 90, 151, 221, 16, 73, 132, 206, 3, 124, 177, 251, 54, 111, 162, 232, 37, 22, 219, 145, 92, 5, 200, 130, 79, 48, 253, 183, 122, 35, 238, 164, 105, 194, 15, 69, 136, 209, 28, 86, 155, 228, 41, 99, 174, 247, 58, 112, 189, 142, 67, 9, 196, 157, 80, 26, 215, 168, 101, 47, 226, 187, 118, 60, 241, 119, 186, 240, 61, 100, 169, 227, 46, 81, 156, 214, 27, 66, 143, 197, 8, 59, 246, 188, 113, 40, 229, 175, 98, 29, 208, 154, 87, 14, 195, 137, 68, 239, 34, 104, 165, 252, 49, 123, 182, 201, 4, 78, 131, 218, 23, 93, 144, 163, 110, 36, 233, 176, 125, 55, 250, 133, 72, 2, 207, 150, 91, 17, 220, ],
[0, 206, 129, 79, 31, 209, 158, 80, 62, 240, 191, 113, 33, 239, 160, 110, 124, 178, 253, 51, 99, 173, 226, 44, 66, 140, 195, 13, 93, 147, 220, 18, 248, 54, 121, 183, 231, 41, 102, 168, 198, 8, 71, 137, 217, 23, 88, 150, 132, 74, 5, 203, 155, 85, 26, 212, 186, 116, 59, 245, 165, 107, 36, 234, 237, 35, 108, 162, 242, 60, 115, 189, 211, 29, 82, 156, 204, 2, 77, 131, 145, 95, 16, 222, 142, 64, 15, 193, 175, 97, 46, 224, 176, 126, 49, 255, 21, 219, 148, 90, 10, 196, 139, 69, 43, 229, 170, 100, 52, 250, 181, 123, 105, 167, 232, 38, 118, 184, 247, 57, 87, 153, 214, 24, 72, 134, 201, 7, 199, 9, 70, 136, 216, 22, 89, 151, 249, 55, 120, 182, 230, 40, 103, 169, 187, 117, 58, 244, 164, 106, 37, 235, 133, 75, 4, 202, 154, 84, 27, 213, 63, 241, 190, 112, 32, 238, 161, 111, 1, 207, 128, 78, 30, 208, 159, 81, 67, 141, 194, 12, 92, 146, 221, 19, 125, 179, 252, 50, 98, 172, 227, 45, 42, 228, 171, 101, 53, 251, 180, 122, 20, 218, 149, 91, 11, 197, 138, 68, 86, 152, 215, 25, 73, 135, 200, 6, 104, 166, 233, 39, 119, 185, 246, 56, 210, 28, 83, 157, 205, 3, 76, 130, 236, 34, 109, 163, 243, 61, 114, 188, 174, 96, 47, 225, 177, 127, 48, 254, 144, 94, 17, 223, 143, 65, 14, 192, ],
[0, 207, 131, 76, 27, 212, 152, 87, 54, 249, 181, 122, 45, 226, 174, 97, 108, 163, 239, 32, 119, 184, 244, 59, 90, 149, 217, 22, 65, 142, 194, 13, 216, 23, 91, 148, 195, 12, 64, 143, 238, 33, 109, 162, 245, 58, 118, 185, 180, 123, 55, 248, 175, 96, 44, 227, 130, 77, 1, 206, 153, 86, 26, 213, 173, 98, 46, 225, 182, 121, 53, 250, 155, 84, 24, 215, 128, 79, 3, 204, 193, 14, 66, 141, 218, 21, 89, 150, 247, 56, 116, 187, 236, 35, 111, 160, 117, 186, 246, 57, 110, 161, 237, 34, 67, 140, 192, 15, 88, 151, 219, 20, 25, 214, 154, 85, 2, 205, 129, 78, 47, 224, 172, 99, 52, 251, 183, 120, 71, 136, 196, 11, 92, 147, 223, 16, 113, 190, 242, 61, 106, 165, 233, 38, 43, 228, 168, 103, 48, 255, 179, 124, 29, 210, 158, 81, 6, 201, 133, 74, 159, 80, 28, 211, 132, 75, 7, 200, 169, 102, 42, 229, 178, 125, 49, 254, 243, 60, 112, 191, 232, 39, 107, 164, 197, 10, 70, 137, 222, 17, 93, 146, 234, 37, 105, 166, 241, 62, 114, 189, 220, 19, 95, 144, 199, 8, 68, 139, 134, 73, 5, 202, 157, 82, 30, 209, 176, 127, 51, 252, 171, 100, 40, 231, 50, 253, 177, 126, 41, 230, 170, 101, 4, 203, 135, 72, 31, 208, 156, 83, 94, 145, 221, 18, 69, 138, 198, 9, 104, 167, 235, 36, 115, 188, 240, 63, ],
[0, 208, 189, 109, 103, 183, 218, 10, 206, 30, 115, 163, 169, 121, 20, 196, 129, 81, 60, 236, 230, 54, 91, 139, 79, 159, 242, 34, 40, 248, 149, 69, 31, 207, 162, 114, 120, 168, 197, 21, 209, 1, 108, 188, 182, 102, 11, 219, 158, 78, 35, 243, 249, 41, 68, 148, 80, 128, 237, 61, 55, 231, 138, 90, 62, 238, 131, 83, 89, 137, 228, 52, 240, 32, 77, 157, 151, 71, 42, 250, 191, 111, 2, 210, 216, 8, 101, 181, 113, 161, 204, 28, 22, 198, 171, 123, 33, 241, 156, 76, 70, 150, 251, 43, 239, 63, 82, 130, 136, 88, 53, 229, 160, 112, 29, 205, 199, 23, 122, 170, 110, 190, 211, 3, 9, 217, 180, 100, 124, 172, 193, 17, 27, 203, 166, 118, 178, 98, 15, 223, 213, 5, 104, 184, 253, 45, 64, 144, 154, 74, 39, 247, 51, 227, 142, 94, 84, 132, 233, 57, 99, 179, 222, 14, 4, 212, 185, 105, 173, 125, 16, 192, 202, 26, 119, 167, 226, 50, 95, 143, 133, 85, 56, 232, 44, 252, 145, 65, 75, 155, 246, 38, 66, 146, 255, 47, 37, 245, 152, 72, 140, 92, 49, 225, 235, 59, 86, 134, 195, 19, 126, 174, 164, 116, 25, 201, 13, 221, 176, 96, 106, 186, 215, 7, 93, 141, 224, 48, 58, 234, 135, 87, 147, 67, 46, 254, 244, 36, 73, 153, 220, 12, 97, 177, 187, 107, 6, 214, 18, 194, 175, 127, 117, 165, 200, 24, ],
[0, 209, 191, 110, 99, 178, 220, 13, 198, 23, 121, 168, 165, 116, 26, 203, 145, 64, 46, 255, 242, 35, 77, 156, 87, 134, 232, 57, 52, 229, 139, 90, 63, 238, 128, 81, 92, 141, 227, 50, 249, 40, 70, 151, 154, 75, 37, 244, 174, 127, 17, 192, 205, 28, 114, 163, 104, 185, 215, 6, 11, 218, 180, 101, 126, 175, 193, 16, 29, 204, 162, 115, 184, 105, 7, 214, 219, 10, 100, 181, 239, 62, 80, 129, 140, 93, 51, 226, 41, 248, 150, 71, 74, 155, 245, 36, 65, 144, 254, 47, 34, 243, 157, 76, 135, 86, 56, 233, 228, 53, 91, 138, 208, 1, 111, 190, 179, 98, 12, 221, 22, 199, 169, 120, 117, 164, 202, 27, 252, 45, 67, 146, 159, 78, 32, 241, 58, 235, 133, 84, 89, 136, 230, 55, 109, 188, 210, 3, 14, 223, 177, 96, 171, 122, 20, 197, 200, 25, 119, 166, 195, 18, 124, 173, 160, 113, 31, 206, 5, 212, 186, 107, 102, 183, 217, 8, 82, 131, 237, 60, 49, 224, 142, 95, 148, 69, 43, 250, 247, 38, 72, 153, 130, 83, 61, 236, 225, 48, 94, 143, 68, 149, 251, 42, 39, 246, 152, 73, 19, 194, 172, 125, 112, 161, 207, 30, 213, 4, 106, 187, 182, 103, 9, 216, 189, 108, 2, 211, 222, 15, 97, 176, 123, 170, 196, 21, 24, 201, 167, 118, 44, 253, 147, 66, 79, 158, 240, 33, 234, 59, 85, 132, 137, 88, 54, 231, ],
[0, 210, 185, 107, 111, 189, 214, 4, 222, 12, 103, 181, 177, 99, 8, 218, 161, 115, 24, 202, 206, 28, 119, 165, 127, 173, 198, 20, 16, 194, 169, 123, 95, 141, 230, 52, 48, 226, 137, 91, 129, 83, 56, 234, 238, 60, 87, 133, 254, 44, 71, 149, 145, 67, 40, 250, 32, 242, 153, 75, 79, 157, 246, 36, 190, 108, 7, 213, 209, 3, 104, 186, 96, 178, 217, 11, 15, 221, 182, 100, 31, 205, 166, 116, 112, 162, 201, 27, 193, 19, 120, 170, 174, 124, 23, 197, 225, 51, 88, 138, 142, 92, 55, 229, 63, 237, 134, 84, 80, 130, 233, 59, 64, 146, 249, 43, 47, 253, 150, 68, 158, 76, 39, 245, 241, 35, 72, 154, 97, 179, 216, 10, 14, 220, 183, 101, 191, 109, 6, 212, 208, 2, 105, 187, 192, 18, 121, 171, 175, 125, 22, 196, 30, 204, 167, 117, 113, 163, 200, 26, 62, 236, 135, 85, 81, 131, 232, 58, 224, 50, 89, 139, 143, 93, 54, 228, 159, 77, 38, 244, 240, 34, 73, 155, 65, 147, 248, 42, 46, 252, 151, 69, 223, 13, 102, 180, 176, 98, 9, 219, 1, 211, 184, 106, 110, 188, 215, 5, 126, 172, 199, 21, 17, 195, 168, 122, 160, 114, 25, 203, 207, 29, 118, 164, 128, 82, 57, 235, 239, 61, 86, 132, 94, 140, 231, 53, 49, 227, 136, 90, 33, 243, 152, 74, 78, 156, 247, 37, 255, 45, 70, 148, 144, 66, 41, 251, ],
[0, 211, 187, 104, 107, 184, 208, 3, 214, 5, 109, 190, 189, 110, 6, 213, 177, 98, 10, 217, 218, 9, 97, 178, 103, 180, 220, 15, 12, 223, 183, 100, 127, 172, 196, 23, 20, 199, 175, 124, 169, 122, 18, 193, 194, 17, 121, 170, 206, 29, 117, 166, 165, 118, 30, 205, 24, 203, 163, 112, 115, 160, 200, 27, 254, 45, 69, 150, 149, 70, 46, 253, 40, 251, 147, 64, 67, 144, 248, 43, 79, 156, 244, 39, 36, 247, 159, 76, 153, 74, 34, 241, 242, 33, 73, 154, 129, 82, 58, 233, 234, 57, 81, 130, 87, 132, 236, 63, 60, 239, 135, 84, 48, 227, 139, 88, 91, 136, 224, 51, 230, 53, 93, 142, 141, 94, 54, 229, 225, 50, 90, 137, 138, 89, 49, 226, 55, 228, 140, 95, 92, 143, 231, 52, 80, 131, 235, 56, 59, 232, 128, 83, 134, 85, 61, 238, 237, 62, 86, 133, 158, 77, 37, 246, 245, 38, 78, 157, 72, 155, 243, 32, 35, 240, 152, 75, 47, 252, 148, 71, 68, 151, 255, 44, 249, 42, 66, 145, 146, 65, 41, 250, 31, 204, 164, 119, 116, 167, 207, 28, 201, 26, 114, 161, 162, 113, 25, 202, 174, 125, 21, 198, 197, 22, 126, 173, 120, 171, 195, 16, 19, 192, 168, 123, 96, 179, 219, 8, 11, 216, 176, 99, 182, 101, 13, 222, 221, 14, 102, 181, 209, 2, 106, 185, 186, 105, 1, 210, 7, 212, 188, 111, 108, 191, 215, 4, ],
[0, 212, 181, 97, 119, 163, 194, 22, 238, 58, 91, 143, 153, 77, 44, 248, 193, 21, 116, 160, 182, 98, 3, 215, 47, 251, 154, 78, 88, 140, 237, 57, 159, 75, 42, 254, 232, 60, 93, 137, 113, 165, 196, 16, 6, 210, 179, 103, 94, 138, 235, 63, 41, 253, 156, 72, 176, 100, 5, 209, 199, 19, 114, 166, 35, 247, 150, 66, 84, 128, 225, 53, 205, 25, 120, 172, 186, 110, 15, 219, 226, 54, 87, 131, 149, 65, 32, 244, 12, 216, 185, 109, 123, 175, 206, 26, 188, 104, 9, 221, 203, 31, 126, 170, 82, 134, 231, 51, 37, 241, 144, 68, 125, 169, 200, 28, 10, 222, 191, 107, 147, 71, 38, 242, 228, 48, 81, 133, 70, 146, 243, 39, 49, 229, 132, 80, 168, 124, 29, 201, 223, 11, 106, 190, 135, 83, 50, 230, 240, 36, 69, 145, 105, 189, 220, 8, 30, 202, 171, 127, 217, 13, 108, 184, 174, 122, 27, 207, 55, 227, 130, 86, 64, 148, 245, 33, 24, 204, 173, 121, 111, 187, 218, 14, 246, 34, 67, 151, 129, 85, 52, 224, 101, 177, 208, 4, 18, 198, 167, 115, 139, 95, 62, 234, 252, 40, 73, 157, 164, 112, 17, 197, 211, 7, 102, 178, 74, 158, 255, 43, 61, 233, 136, 92, 250, 46, 79, 155, 141, 89, 56, 236, 20, 192, 161, 117, 99, 183, 214, 2, 59, 239, 142, 90, 76, 152, 249, 45, 213, 1, 96, 180, 162, 118, 23, 195, ],
[0, 213, 183, 98, 115, 166, 196, 17, 230, 51, 81, 132, 149, 64, 34, 247, 209, 4, 102, 179, 162, 119, 21, 192, 55, 226, 128, 85, 68, 145, 243, 38, 191, 106, 8, 221, 204, 25, 123, 174, 89, 140, 238, 59, 42, 255, 157, 72, 110, 187, 217, 12, 29, 200, 170, 127, 136, 93, 63, 234, 251, 46, 76, 153, 99, 182, 212, 1, 16, 197, 167, 114, 133, 80, 50, 231, 246, 35, 65, 148, 178, 103, 5, 208, 193, 20, 118, 163, 84, 129, 227, 54, 39, 242, 144, 69, 220, 9, 107, 190, 175, 122, 24, 205, 58, 239, 141, 88, 73, 156, 254, 43, 13, 216, 186, 111, 126, 171, 201, 28, 235, 62, 92, 137, 152, 77, 47, 250, 198, 19, 113, 164, 181, 96, 2, 215, 32, 245, 151, 66, 83, 134, 228, 49, 23, 194, 160, 117, 100, 177, 211, 6, 241, 36, 70, 147, 130, 87, 53, 224, 121, 172, 206, 27, 10, 223, 189, 104, 159, 74, 40, 253, 236, 57, 91, 142, 168, 125, 31, 202, 219, 14, 108, 185, 78, 155, 249, 44, 61, 232, 138, 95, 165, 112, 18, 199, 214, 3, 97, 180, 67, 150, 244, 33, 48, 229, 135, 82, 116, 161, 195, 22, 7, 210, 176, 101, 146, 71, 37, 240, 225, 52, 86, 131, 26, 207, 173, 120, 105, 188, 222, 11, 252, 41, 75, 158, 143, 90, 56, 237, 203, 30, 124, 169, 184, 109, 15, 218, 45, 248, 154, 79, 94, 139, 233, 60, ],
[0, 214, 177, 103, 127, 169, 206, 24, 254, 40, 79, 153, 129, 87, 48, 230, 225, 55, 80, 134, 158, 72, 47, 249, 31, 201, 174, 120, 96, 182, 209, 7, 223, 9, 110, 184, 160, 118, 17, 199, 33, 247, 144, 70, 94, 136, 239, 57, 62, 232, 143, 89, 65, 151, 240, 38, 192, 22, 113, 167, 191, 105, 14, 216, 163, 117, 18, 196, 220, 10, 109, 187, 93, 139, 236, 58, 34, 244, 147, 69, 66, 148, 243, 37, 61, 235, 140, 90, 188, 106, 13, 219, 195, 21, 114, 164, 124, 170, 205, 27, 3, 213, 178, 100, 130, 84, 51, 229, 253, 43, 76, 154, 157, 75, 44, 250, 226, 52, 83, 133, 99, 181, 210, 4, 28, 202, 173, 123, 91, 141, 234, 60, 36, 242, 149, 67, 165, 115, 20, 194, 218, 12, 107, 189, 186, 108, 11, 221, 197, 19, 116, 162, 68, 146, 245, 35, 59, 237, 138, 92, 132, 82, 53, 227, 251, 45, 74, 156, 122, 172, 203, 29, 5, 211, 180, 98, 101, 179, 212, 2, 26, 204, 171, 125, 155, 77, 42, 252, 228, 50, 85, 131, 248, 46, 73, 159, 135, 81, 54, 224, 6, 208, 183, 97, 121, 175, 200, 30, 25, 207, 168, 126, 102, 176, 215, 1, 231, 49, 86, 128, 152, 78, 41, 255, 39, 241, 150, 64, 88, 142, 233, 63, 217, 15, 104, 190, 166, 112, 23, 193, 198, 16, 119, 161, 185, 111, 8, 222, 56, 238, 137, 95, 71, 145, 246, 32, ],
[0, 215, 179, 100, 123, 172, 200, 31, 246, 33, 69, 146, 141, 90, 62, 233, 241, 38, 66, 149, 138, 93, 57, 238, 7, 208, 180, 99, 124, 171, 207, 24, 255, 40, 76, 155, 132, 83, 55, 224, 9, 222, 186, 109, 114, 165, 193, 22, 14, 217, 189, 106, 117, 162, 198, 17, 248, 47, 75, 156, 131, 84, 48, 231, 227, 52, 80, 135, 152, 79, 43, 252, 21, 194, 166, 113, 110, 185, 221, 10, 18, 197, 161, 118, 105, 190, 218, 13, 228, 51, 87, 128, 159, 72, 44, 251, 28, 203, 175, 120, 103, 176, 212, 3, 234, 61, 89, 142, 145, 70, 34, 245, 237, 58, 94, 137, 150, 65, 37, 242, 27, 204, 168, 127, 96, 183, 211, 4, 219, 12, 104, 191, 160, 119, 19, 196, 45, 250, 158, 73, 86, 129, 229, 50, 42, 253, 153, 78, 81, 134, 226, 53, 220, 11, 111, 184, 167, 112, 20, 195, 36, 243, 151, 64, 95, 136, 236, 59, 210, 5, 97, 182, 169, 126, 26, 205, 213, 2, 102, 177, 174, 121, 29, 202, 35, 244, 144, 71, 88, 143, 235, 60, 56, 239, 139, 92, 67, 148, 240, 39, 206, 25, 125, 170, 181, 98, 6, 209, 201, 30, 122, 173, 178, 101, 1, 214, 63, 232, 140, 91, 68, 147, 247, 32, 199, 16, 116, 163, 188, 107, 15, 216, 49, 230, 130, 85, 74, 157, 249, 46, 54, 225, 133, 82, 77, 154, 254, 41, 192, 23, 115, 164, 187, 108, 8, 223, ],
[0, 216, 173, 117, 71, 159, 234, 50, 142, 86, 35, 251, 201, 17, 100, 188, 1, 217, 172, 116, 70, 158, 235, 51, 143, 87, 34, 250, 200, 16, 101, 189, 2, 218, 175, 119, 69, 157, 232, 48, 140, 84, 33, 249, 203, 19, 102, 190, 3, 219, 174, 118, 68, 156, 233, 49, 141, 85, 32, 248, 202, 18, 103, 191, 4, 220, 169, 113, 67, 155, 238, 54, 138, 82, 39, 255, 205, 21, 96, 184, 5, 221, 168, 112, 66, 154, 239, 55, 139, 83, 38, 254, 204, 20, 97, 185, 6, 222, 171, 115, 65, 153, 236, 52, 136, 80, 37, 253, 207, 23, 98, 186, 7, 223, 170, 114, 64, 152, 237, 53, 137, 81, 36, 252, 206, 22, 99, 187, 8, 208, 165, 125, 79, 151, 226, 58, 134, 94, 43, 243, 193, 25, 108, 180, 9, 209, 164, 124, 78, 150, 227, 59, 135, 95, 42, 242, 192, 24, 109, 181, 10, 210, 167, 127, 77, 149, 224, 56, 132, 92, 41, 241, 195, 27, 110, 182, 11, 211, 166, 126, 76, 148, 225, 57, 133, 93, 40, 240, 194, 26, 111, 183, 12, 212, 161, 121, 75, 147, 230, 62, 130, 90, 47, 247, 197, 29, 104, 176, 13, 213, 160, 120, 74, 146, 231, 63, 131, 91, 46, 246, 196, 28, 105, 177, 14, 214, 163, 123, 73, 145, 228, 60, 128, 88, 45, 245, 199, 31, 106, 178, 15, 215, 162, 122, 72, 144, 229, 61, 129, 89, 44, 244, 198, 30, 107, 179, ],
[0, 217, 175, 118, 67, 154, 236, 53, 134, 95, 41, 240, 197, 28, 106, 179, 17, 200, 190, 103, 82, 139, 253, 36, 151, 78, 56, 225, 212, 13, 123, 162, 34, 251, 141, 84, 97, 184, 206, 23, 164, 125, 11, 210, 231, 62, 72, 145, 51, 234, 156, 69, 112, 169, 223, 6, 181, 108, 26, 195, 246, 47, 89, 128, 68, 157, 235, 50, 7, 222, 168, 113, 194, 27, 109, 180, 129, 88, 46, 247, 85, 140, 250, 35, 22, 207, 185, 96, 211, 10, 124, 165, 144, 73, 63, 230, 102, 191, 201, 16, 37, 252, 138, 83, 224, 57, 79, 150, 163, 122, 12, 213, 119, 174, 216, 1, 52, 237, 155, 66, 241, 40, 94, 135, 178, 107, 29, 196, 136, 81, 39, 254, 203, 18, 100, 189, 14, 215, 161, 120, 77, 148, 226, 59, 153, 64, 54, 239, 218, 3, 117, 172, 31, 198, 176, 105, 92, 133, 243, 42, 170, 115, 5, 220, 233, 48, 70, 159, 44, 245, 131, 90, 111, 182, 192, 25, 187, 98, 20, 205, 248, 33, 87, 142, 61, 228, 146, 75, 126, 167, 209, 8, 204, 21, 99, 186, 143, 86, 32, 249, 74, 147, 229, 60, 9, 208, 166, 127, 221, 4, 114, 171, 158, 71, 49, 232, 91, 130, 244, 45, 24, 193, 183, 110, 238, 55, 65, 152, 173, 116, 2, 219, 104, 177, 199, 30, 43, 242, 132, 93, 255, 38, 80, 137, 188, 101, 19, 202, 121, 160, 214, 15, 58, 227, 149, 76, ],
[0, 218, 169, 115, 79, 149, 230, 60, 158, 68, 55, 237, 209, 11, 120, 162, 33, 251, 136, 82, 110, 180, 199, 29, 191, 101, 22, 204, 240, 42, 89, 131, 66, 152, 235, 49, 13, 215, 164, 126, 220, 6, 117, 175, 147, 73, 58, 224, 99, 185, 202, 16, 44, 246, 133, 95, 253, 39, 84, 142, 178, 104, 27, 193, 132, 94, 45, 247, 203, 17, 98, 184, 26, 192, 179, 105, 85, 143, 252, 38, 165, 127, 12, 214, 234, 48, 67, 153, 59, 225, 146, 72, 116, 174, 221, 7, 198, 28, 111, 181, 137, 83, 32, 250, 88, 130, 241, 43, 23, 205, 190, 100, 231, 61, 78, 148, 168, 114, 1, 219, 121, 163, 208, 10, 54, 236, 159, 69, 21, 207, 188, 102, 90, 128, 243, 41, 139, 81, 34, 248, 196, 30, 109, 183, 52, 238, 157, 71, 123, 161, 210, 8, 170, 112, 3, 217, 229, 63, 76, 150, 87, 141, 254, 36, 24, 194, 177, 107, 201, 19, 96, 186, 134, 92, 47, 245, 118, 172, 223, 5, 57, 227, 144, 74, 232, 50, 65, 155, 167, 125, 14, 212, 145, 75, 56, 226, 222, 4, 119, 173, 15, 213, 166, 124, 64, 154, 233, 51, 176, 106, 25, 195, 255, 37, 86, 140, 46, 244, 135, 93, 97, 187, 200, 18, 211, 9, 122, 160, 156, 70, 53, 239, 77, 151, 228, 62, 2, 216, 171, 113, 242, 40, 91, 129, 189, 103, 20, 206, 108, 182, 197, 31, 35, 249, 138, 80, ],
[0, 219, 171, 112, 75, 144, 224, 59, 150, 77, 61, 230, 221, 6, 118, 173, 49, 234, 154, 65, 122, 161, 209, 10, 167, 124, 12, 215, 236, 55, 71, 156, 98, 185, 201, 18, 41, 242, 130, 89, 244, 47, 95, 132, 191, 100, 20, 207, 83, 136, 248, 35, 24, 195, 179, 104, 197, 30, 110, 181, 142, 85, 37, 254, 196, 31, 111, 180, 143, 84, 36, 255, 82, 137, 249, 34, 25, 194, 178, 105, 245, 46, 94, 133, 190, 101, 21, 206, 99, 184, 200, 19, 40, 243, 131, 88, 166, 125, 13, 214, 237, 54, 70, 157, 48, 235, 155, 64, 123, 160, 208, 11, 151, 76, 60, 231, 220, 7, 119, 172, 1, 218, 170, 113, 74, 145, 225, 58, 149, 78, 62, 229, 222, 5, 117, 174, 3, 216, 168, 115, 72, 147, 227, 56, 164, 127, 15, 212, 239, 52, 68, 159, 50, 233, 153, 66, 121, 162, 210, 9, 247, 44, 92, 135, 188, 103, 23, 204, 97, 186, 202, 17, 42, 241, 129, 90, 198, 29, 109, 182, 141, 86, 38, 253, 80, 139, 251, 32, 27, 192, 176, 107, 81, 138, 250, 33, 26, 193, 177, 106, 199, 28, 108, 183, 140, 87, 39, 252, 96, 187, 203, 16, 43, 240, 128, 91, 246, 45, 93, 134, 189, 102, 22, 205, 51, 232, 152, 67, 120, 163, 211, 8, 165, 126, 14, 213, 238, 53, 69, 158, 2, 217, 169, 114, 73, 146, 226, 57, 148, 79, 63, 228, 223, 4, 116, 175, ],
[0, 220, 165, 121, 87, 139, 242, 46, 174, 114, 11, 215, 249, 37, 92, 128, 65, 157, 228, 56, 22, 202, 179, 111, 239, 51, 74, 150, 184, 100, 29, 193, 130, 94, 39, 251, 213, 9, 112, 172, 44, 240, 137, 85, 123, 167, 222, 2, 195, 31, 102, 186, 148, 72, 49, 237, 109, 177, 200, 20, 58, 230, 159, 67, 25, 197, 188, 96, 78, 146, 235, 55, 183, 107, 18, 206, 224, 60, 69, 153, 88, 132, 253, 33, 15, 211, 170, 118, 246, 42, 83, 143, 161, 125, 4, 216, 155, 71, 62, 226, 204, 16, 105, 181, 53, 233, 144, 76, 98, 190, 199, 27, 218, 6, 127, 163, 141, 81, 40, 244, 116, 168, 209, 13, 35, 255, 134, 90, 50, 238, 151, 75, 101, 185, 192, 28, 156, 64, 57, 229, 203, 23, 110, 178, 115, 175, 214, 10, 36, 248, 129, 93, 221, 1, 120, 164, 138, 86, 47, 243, 176, 108, 21, 201, 231, 59, 66, 158, 30, 194, 187, 103, 73, 149, 236, 48, 241, 45, 84, 136, 166, 122, 3, 223, 95, 131, 250, 38, 8, 212, 173, 113, 43, 247, 142, 82, 124, 160, 217, 5, 133, 89, 32, 252, 210, 14, 119, 171, 106, 182, 207, 19, 61, 225, 152, 68, 196, 24, 97, 189, 147, 79, 54, 234, 169, 117, 12, 208, 254, 34, 91, 135, 7, 219, 162, 126, 80, 140, 245, 41, 232, 52, 77, 145, 191, 99, 26, 198, 70, 154, 227, 63, 17, 205, 180, 104, ],
[0, 221, 167, 122, 83, 142, 244, 41, 166, 123, 1, 220, 245, 40, 82, 143, 81, 140, 246, 43, 2, 223, 165, 120, 247, 42, 80, 141, 164, 121, 3, 222, 162, 127, 5, 216, 241, 44, 86, 139, 4, 217, 163, 126, 87, 138, 240, 45, 243, 46, 84, 137, 160, 125, 7, 218, 85, 136, 242, 47, 6, 219, 161, 124, 89, 132, 254, 35, 10, 215, 173, 112, 255, 34, 88, 133, 172, 113, 11, 214, 8, 213, 175, 114, 91, 134, 252, 33, 174, 115, 9, 212, 253, 32, 90, 135, 251, 38, 92, 129, 168, 117, 15, 210, 93, 128, 250, 39, 14, 211, 169, 116, 170, 119, 13, 208, 249, 36, 94, 131, 12, 209, 171, 118, 95, 130, 248, 37, 178, 111, 21, 200, 225, 60, 70, 155, 20, 201, 179, 110, 71, 154, 224, 61, 227, 62, 68, 153, 176, 109, 23, 202, 69, 152, 226, 63, 22, 203, 177, 108, 16, 205, 183, 106, 67, 158, 228, 57, 182, 107, 17, 204, 229, 56, 66, 159, 65, 156, 230, 59, 18, 207, 181, 104, 231, 58, 64, 157, 180, 105, 19, 206, 235, 54, 76, 145, 184, 101, 31, 194, 77, 144, 234, 55, 30, 195, 185, 100, 186, 103, 29, 192, 233, 52, 78, 147, 28, 193, 187, 102, 79, 146, 232, 53, 73, 148, 238, 51, 26, 199, 189, 96, 239, 50, 72, 149, 188, 97, 27, 198, 24, 197, 191, 98, 75, 150, 236, 49, 190, 99, 25, 196, 237, 48, 74, 151, ],
[0, 222, 161, 127, 95, 129, 254, 32, 190, 96, 31, 193, 225, 63, 64, 158, 97, 191, 192, 30, 62, 224, 159, 65, 223, 1, 126, 160, 128, 94, 33, 255, 194, 28, 99, 189, 157, 67, 60, 226, 124, 162, 221, 3, 35, 253, 130, 92, 163, 125, 2, 220, 252, 34, 93, 131, 29, 195, 188, 98, 66, 156, 227, 61, 153, 71, 56, 230, 198, 24, 103, 185, 39, 249, 134, 88, 120, 166, 217, 7, 248, 38, 89, 135, 167, 121, 6, 216, 70, 152, 231, 57, 25, 199, 184, 102, 91, 133, 250, 36, 4, 218, 165, 123, 229, 59, 68, 154, 186, 100, 27, 197, 58, 228, 155, 69, 101, 187, 196, 26, 132, 90, 37, 251, 219, 5, 122, 164, 47, 241, 142, 80, 112, 174, 209, 15, 145, 79, 48, 238, 206, 16, 111, 177, 78, 144, 239, 49, 17, 207, 176, 110, 240, 46, 81, 143, 175, 113, 14, 208, 237, 51, 76, 146, 178, 108, 19, 205, 83, 141, 242, 44, 12, 210, 173, 115, 140, 82, 45, 243, 211, 13, 114, 172, 50, 236, 147, 77, 109, 179, 204, 18, 182, 104, 23, 201, 233, 55, 72, 150, 8, 214, 169, 119, 87, 137, 246, 40, 215, 9, 118, 168, 136, 86, 41, 247, 105, 183, 200, 22, 54, 232, 151, 73, 116, 170, 213, 11, 43, 245, 138, 84, 202, 20, 107, 181, 149, 75, 52, 234, 21, 203, 180, 106, 74, 148, 235, 53, 171, 117, 10, 212, 244, 42, 85, 139, ],
[0, 223, 163, 124, 91, 132, 248, 39, 182, 105, 21, 202, 237, 50, 78, 145, 113, 174, 210, 13, 42, 245, 137, 86, 199, 24, 100, 187, 156, 67, 63, 224, 226, 61, 65, 158, 185, 102, 26, 197, 84, 139, 247, 40, 15, 208, 172, 115, 147, 76, 48, 239, 200, 23, 107, 180, 37, 250, 134, 89, 126, 161, 221, 2, 217, 6, 122, 165, 130, 93, 33, 254, 111, 176, 204, 19, 52, 235, 151, 72, 168, 119, 11, 212, 243, 44, 80, 143, 30, 193, 189, 98, 69, 154, 230, 57, 59, 228, 152, 71, 96, 191, 195, 28, 141, 82, 46, 241, 214, 9, 117, 170, 74, 149, 233, 54, 17, 206, 178, 109, 252, 35, 95, 128, 167, 120, 4, 219, 175, 112, 12, 211, 244, 43, 87, 136, 25, 198, 186, 101, 66, 157, 225, 62, 222, 1, 125, 162, 133, 90, 38, 249, 104, 183, 203, 20, 51, 236, 144, 79, 77, 146, 238, 49, 22, 201, 181, 106, 251, 36, 88, 135, 160, 127, 3, 220, 60, 227, 159, 64, 103, 184, 196, 27, 138, 85, 41, 246, 209, 14, 114, 173, 118, 169, 213, 10, 45, 242, 142, 81, 192, 31, 99, 188, 155, 68, 56, 231, 7, 216, 164, 123, 92, 131, 255, 32, 177, 110, 18, 205, 234, 53, 73, 150, 148, 75, 55, 232, 207, 16, 108, 179, 34, 253, 129, 94, 121, 166, 218, 5, 229, 58, 70, 153, 190, 97, 29, 194, 83, 140, 240, 47, 8, 215, 171, 116, ],
[0, 224, 221, 61, 167, 71, 122, 154, 83, 179, 142, 110, 244, 20, 41, 201, 166, 70, 123, 155, 1, 225, 220, 60, 245, 21, 40, 200, 82, 178, 143, 111, 81, 177, 140, 108, 246, 22, 43, 203, 2, 226, 223, 63, 165, 69, 120, 152, 247, 23, 42, 202, 80, 176, 141, 109, 164, 68, 121, 153, 3, 227, 222, 62, 162, 66, 127, 159, 5, 229, 216, 56, 241, 17, 44, 204, 86, 182, 139, 107, 4, 228, 217, 57, 163, 67, 126, 158, 87, 183, 138, 106, 240, 16, 45, 205, 243, 19, 46, 206, 84, 180, 137, 105, 160, 64, 125, 157, 7, 231, 218, 58, 85, 181, 136, 104, 242, 18, 47, 207, 6, 230, 219, 59, 161, 65, 124, 156, 89, 185, 132, 100, 254, 30, 35, 195, 10, 234, 215, 55, 173, 77, 112, 144, 255, 31, 34, 194, 88, 184, 133, 101, 172, 76, 113, 145, 11, 235, 214, 54, 8, 232, 213, 53, 175, 79, 114, 146, 91, 187, 134, 102, 252, 28, 33, 193, 174, 78, 115, 147, 9, 233, 212, 52, 253, 29, 32, 192, 90, 186, 135, 103, 251, 27, 38, 198, 92, 188, 129, 97, 168, 72, 117, 149, 15, 239, 210, 50, 93, 189, 128, 96, 250, 26, 39, 199, 14, 238, 211, 51, 169, 73, 116, 148, 170, 74, 119, 151, 13, 237, 208, 48, 249, 25, 36, 196, 94, 190, 131, 99, 12, 236, 209, 49, 171, 75, 118, 150, 95, 191, 130, 98, 248, 24, 37, 197, ],
[0, 225, 223, 62, 163, 66, 124, 157, 91, 186, 132, 101, 248, 25, 39, 198, 182, 87, 105, 136, 21, 244, 202, 43, 237, 12, 50, 211, 78, 175, 145, 112, 113, 144, 174, 79, 210, 51, 13, 236, 42, 203, 245, 20, 137, 104, 86, 183, 199, 38, 24, 249, 100, 133, 187, 90, 156, 125, 67, 162, 63, 222, 224, 1, 226, 3, 61, 220, 65, 160, 158, 127, 185, 88, 102, 135, 26, 251, 197, 36, 84, 181, 139, 106, 247, 22, 40, 201, 15, 238, 208, 49, 172, 77, 115, 146, 147, 114, 76, 173, 48, 209, 239, 14, 200, 41, 23, 246, 107, 138, 180, 85, 37, 196, 250, 27, 134, 103, 89, 184, 126, 159, 161, 64, 221, 60, 2, 227, 217, 56, 6, 231, 122, 155, 165, 68, 130, 99, 93, 188, 33, 192, 254, 31, 111, 142, 176, 81, 204, 45, 19, 242, 52, 213, 235, 10, 151, 118, 72, 169, 168, 73, 119, 150, 11, 234, 212, 53, 243, 18, 44, 205, 80, 177, 143, 110, 30, 255, 193, 32, 189, 92, 98, 131, 69, 164, 154, 123, 230, 7, 57, 216, 59, 218, 228, 5, 152, 121, 71, 166, 96, 129, 191, 94, 195, 34, 28, 253, 141, 108, 82, 179, 46, 207, 241, 16, 214, 55, 9, 232, 117, 148, 170, 75, 74, 171, 149, 116, 233, 8, 54, 215, 17, 240, 206, 47, 178, 83, 109, 140, 252, 29, 35, 194, 95, 190, 128, 97, 167, 70, 120, 153, 4, 229, 219, 58, ],
[0, 226, 217, 59, 175, 77, 118, 148, 67, 161, 154, 120, 236, 14, 53, 215, 134, 100, 95, 189, 41, 203, 240, 18, 197, 39, 28, 254, 106, 136, 179, 81, 17, 243, 200, 42, 190, 92, 103, 133, 82, 176, 139, 105, 253, 31, 36, 198, 151, 117, 78, 172, 56, 218, 225, 3, 212, 54, 13, 239, 123, 153, 162, 64, 34, 192, 251, 25, 141, 111, 84, 182, 97, 131, 184, 90, 206, 44, 23, 245, 164, 70, 125, 159, 11, 233, 210, 48, 231, 5, 62, 220, 72, 170, 145, 115, 51, 209, 234, 8, 156, 126, 69, 167, 112, 146, 169, 75, 223, 61, 6, 228, 181, 87, 108, 142, 26, 248, 195, 33, 246, 20, 47, 205, 89, 187, 128, 98, 68, 166, 157, 127, 235, 9, 50, 208, 7, 229, 222, 60, 168, 74, 113, 147, 194, 32, 27, 249, 109, 143, 180, 86, 129, 99, 88, 186, 46, 204, 247, 21, 85, 183, 140, 110, 250, 24, 35, 193, 22, 244, 207, 45, 185, 91, 96, 130, 211, 49, 10, 232, 124, 158, 165, 71, 144, 114, 73, 171, 63, 221, 230, 4, 102, 132, 191, 93, 201, 43, 16, 242, 37, 199, 252, 30, 138, 104, 83, 177, 224, 2, 57, 219, 79, 173, 150, 116, 163, 65, 122, 152, 12, 238, 213, 55, 119, 149, 174, 76, 216, 58, 1, 227, 52, 214, 237, 15, 155, 121, 66, 160, 241, 19, 40, 202, 94, 188, 135, 101, 178, 80, 107, 137, 29, 255, 196, 38, ],
[0, 227, 219, 56, 171, 72, 112, 147, 75, 168, 144, 115, 224, 3, 59, 216, 150, 117, 77, 174, 61, 222, 230, 5, 221, 62, 6, 229, 118, 149, 173, 78, 49, 210, 234, 9, 154, 121, 65, 162, 122, 153, 161, 66, 209, 50, 10, 233, 167, 68, 124, 159, 12, 239, 215, 52, 236, 15, 55, 212, 71, 164, 156, 127, 98, 129, 185, 90, 201, 42, 18, 241, 41, 202, 242, 17, 130, 97, 89, 186, 244, 23, 47, 204, 95, 188, 132, 103, 191, 92, 100, 135, 20, 247, 207, 44, 83, 176, 136, 107, 248, 27, 35, 192, 24, 251, 195, 32, 179, 80, 104, 139, 197, 38, 30, 253, 110, 141, 181, 86, 142, 109, 85, 182, 37, 198, 254, 29, 196, 39, 31, 252, 111, 140, 180, 87, 143, 108, 84, 183, 36, 199, 255, 28, 82, 177, 137, 106, 249, 26, 34, 193, 25, 250, 194, 33, 178, 81, 105, 138, 245, 22, 46, 205, 94, 189, 133, 102, 190, 93, 101, 134, 21, 246, 206, 45, 99, 128, 184, 91, 200, 43, 19, 240, 40, 203, 243, 16, 131, 96, 88, 187, 166, 69, 125, 158, 13, 238, 214, 53, 237, 14, 54, 213, 70, 165, 157, 126, 48, 211, 235, 8, 155, 120, 64, 163, 123, 152, 160, 67, 208, 51, 11, 232, 151, 116, 76, 175, 60, 223, 231, 4, 220, 63, 7, 228, 119, 148, 172, 79, 1, 226, 218, 57, 170, 73, 113, 146, 74, 169, 145, 114, 225, 2, 58, 217, ],
[0, 228, 213, 49, 183, 83, 98, 134, 115, 151, 166, 66, 196, 32, 17, 245, 230, 2, 51, 215, 81, 181, 132, 96, 149, 113, 64, 164, 34, 198, 247, 19, 209, 53, 4, 224, 102, 130, 179, 87, 162, 70, 119, 147, 21, 241, 192, 36, 55, 211, 226, 6, 128, 100, 85, 177, 68, 160, 145, 117, 243, 23, 38, 194, 191, 91, 106, 142, 8, 236, 221, 57, 204, 40, 25, 253, 123, 159, 174, 74, 89, 189, 140, 104, 238, 10, 59, 223, 42, 206, 255, 27, 157, 121, 72, 172, 110, 138, 187, 95, 217, 61, 12, 232, 29, 249, 200, 44, 170, 78, 127, 155, 136, 108, 93, 185, 63, 219, 234, 14, 251, 31, 46, 202, 76, 168, 153, 125, 99, 135, 182, 82, 212, 48, 1, 229, 16, 244, 197, 33, 167, 67, 114, 150, 133, 97, 80, 180, 50, 214, 231, 3, 246, 18, 35, 199, 65, 165, 148, 112, 178, 86, 103, 131, 5, 225, 208, 52, 193, 37, 20, 240, 118, 146, 163, 71, 84, 176, 129, 101, 227, 7, 54, 210, 39, 195, 242, 22, 144, 116, 69, 161, 220, 56, 9, 237, 107, 143, 190, 90, 175, 75, 122, 158, 24, 252, 205, 41, 58, 222, 239, 11, 141, 105, 88, 188, 73, 173, 156, 120, 254, 26, 43, 207, 13, 233, 216, 60, 186, 94, 111, 139, 126, 154, 171, 79, 201, 45, 28, 248, 235, 15, 62, 218, 92, 184, 137, 109, 152, 124, 77, 169, 47, 203, 250, 30, ],
[0, 229, 215, 50, 179, 86, 100, 129, 123, 158, 172, 73, 200, 45, 31, 250, 246, 19, 33, 196, 69, 160, 146, 119, 141, 104, 90, 191, 62, 219, 233, 12, 241, 20, 38, 195, 66, 167, 149, 112, 138, 111, 93, 184, 57, 220, 238, 11, 7, 226, 208, 53, 180, 81, 99, 134, 124, 153, 171, 78, 207, 42, 24, 253, 255, 26, 40, 205, 76, 169, 155, 126, 132, 97, 83, 182, 55, 210, 224, 5, 9, 236, 222, 59, 186, 95, 109, 136, 114, 151, 165, 64, 193, 36, 22, 243, 14, 235, 217, 60, 189, 88, 106, 143, 117, 144, 162, 71, 198, 35, 17, 244, 248, 29, 47, 202, 75, 174, 156, 121, 131, 102, 84, 177, 48, 213, 231, 2, 227, 6, 52, 209, 80, 181, 135, 98, 152, 125, 79, 170, 43, 206, 252, 25, 21, 240, 194, 39, 166, 67, 113, 148, 110, 139, 185, 92, 221, 56, 10, 239, 18, 247, 197, 32, 161, 68, 118, 147, 105, 140, 190, 91, 218, 63, 13, 232, 228, 1, 51, 214, 87, 178, 128, 101, 159, 122, 72, 173, 44, 201, 251, 30, 28, 249, 203, 46, 175, 74, 120, 157, 103, 130, 176, 85, 212, 49, 3, 230, 234, 15, 61, 216, 89, 188, 142, 107, 145, 116, 70, 163, 34, 199, 245, 16, 237, 8, 58, 223, 94, 187, 137, 108, 150, 115, 65, 164, 37, 192, 242, 23, 27, 254, 204, 41, 168, 77, 127, 154, 96, 133, 183, 82, 211, 54, 4, 225, ],
[0, 230, 209, 55, 191, 89, 110, 136, 99, 133, 178, 84, 220, 58, 13, 235, 198, 32, 23, 241, 121, 159, 168, 78, 165, 67, 116, 146, 26, 252, 203, 45, 145, 119, 64, 166, 46, 200, 255, 25, 242, 20, 35, 197, 77, 171, 156, 122, 87, 177, 134, 96, 232, 14, 57, 223, 52, 210, 229, 3, 139, 109, 90, 188, 63, 217, 238, 8, 128, 102, 81, 183, 92, 186, 141, 107, 227, 5, 50, 212, 249, 31, 40, 206, 70, 160, 151, 113, 154, 124, 75, 173, 37, 195, 244, 18, 174, 72, 127, 153, 17, 247, 192, 38, 205, 43, 28, 250, 114, 148, 163, 69, 104, 142, 185, 95, 215, 49, 6, 224, 11, 237, 218, 60, 180, 82, 101, 131, 126, 152, 175, 73, 193, 39, 16, 246, 29, 251, 204, 42, 162, 68, 115, 149, 184, 94, 105, 143, 7, 225, 214, 48, 219, 61, 10, 236, 100, 130, 181, 83, 239, 9, 62, 216, 80, 182, 129, 103, 140, 106, 93, 187, 51, 213, 226, 4, 41, 207, 248, 30, 150, 112, 71, 161, 74, 172, 155, 125, 245, 19, 36, 194, 65, 167, 144, 118, 254, 24, 47, 201, 34, 196, 243, 21, 157, 123, 76, 170, 135, 97, 86, 176, 56, 222, 233, 15, 228, 2, 53, 211, 91, 189, 138, 108, 208, 54, 1, 231, 111, 137, 190, 88, 179, 85, 98, 132, 12, 234, 221, 59, 22, 240, 199, 33, 169, 79, 120, 158, 117, 147, 164, 66, 202, 44, 27, 253, ],
[0, 231, 211, 52, 187, 92, 104, 143, 107, 140, 184, 95, 208, 55, 3, 228, 214, 49, 5, 226, 109, 138, 190, 89, 189, 90, 110, 137, 6, 225, 213, 50, 177, 86, 98, 133, 10, 237, 217, 62, 218, 61, 9, 238, 97, 134, 178, 85, 103, 128, 180, 83, 220, 59, 15, 232, 12, 235, 223, 56, 183, 80, 100, 131, 127, 152, 172, 75, 196, 35, 23, 240, 20, 243, 199, 32, 175, 72, 124, 155, 169, 78, 122, 157, 18, 245, 193, 38, 194, 37, 17, 246, 121, 158, 170, 77, 206, 41, 29, 250, 117, 146, 166, 65, 165, 66, 118, 145, 30, 249, 205, 42, 24, 255, 203, 44, 163, 68, 112, 151, 115, 148, 160, 71, 200, 47, 27, 252, 254, 25, 45, 202, 69, 162, 150, 113, 149, 114, 70, 161, 46, 201, 253, 26, 40, 207, 251, 28, 147, 116, 64, 167, 67, 164, 144, 119, 248, 31, 43, 204, 79, 168, 156, 123, 244, 19, 39, 192, 36, 195, 247, 16, 159, 120, 76, 171, 153, 126, 74, 173, 34, 197, 241, 22, 242, 21, 33, 198, 73, 174, 154, 125, 129, 102, 82, 181, 58, 221, 233, 14, 234, 13, 57, 222, 81, 182, 130, 101, 87, 176, 132, 99, 236, 11, 63, 216, 60, 219, 239, 8, 135, 96, 84, 179, 48, 215, 227, 4, 139, 108, 88, 191, 91, 188, 136, 111, 224, 7, 51, 212, 230, 1, 53, 210, 93, 186, 142, 105, 141, 106, 94, 185, 54, 209, 229, 2, ],
[0, 232, 205, 37, 135, 111, 74, 162, 19, 251, 222, 54, 148, 124, 89, 177, 38, 206, 235, 3, 161, 73, 108, 132, 53, 221, 248, 16, 178, 90, 127, 151, 76, 164, 129, 105, 203, 35, 6, 238, 95, 183, 146, 122, 216, 48, 21, 253, 106, 130, 167, 79, 237, 5, 32, 200, 121, 145, 180, 92, 254, 22, 51, 219, 152, 112, 85, 189, 31, 247, 210, 58, 139, 99, 70, 174, 12, 228, 193, 41, 190, 86, 115, 155, 57, 209, 244, 28, 173, 69, 96, 136, 42, 194, 231, 15, 212, 60, 25, 241, 83, 187, 158, 118, 199, 47, 10, 226, 64, 168, 141, 101, 242, 26, 63, 215, 117, 157, 184, 80, 225, 9, 44, 196, 102, 142, 171, 67, 45, 197, 224, 8, 170, 66, 103, 143, 62, 214, 243, 27, 185, 81, 116, 156, 11, 227, 198, 46, 140, 100, 65, 169, 24, 240, 213, 61, 159, 119, 82, 186, 97, 137, 172, 68, 230, 14, 43, 195, 114, 154, 191, 87, 245, 29, 56, 208, 71, 175, 138, 98, 192, 40, 13, 229, 84, 188, 153, 113, 211, 59, 30, 246, 181, 93, 120, 144, 50, 218, 255, 23, 166, 78, 107, 131, 33, 201, 236, 4, 147, 123, 94, 182, 20, 252, 217, 49, 128, 104, 77, 165, 7, 239, 202, 34, 249, 17, 52, 220, 126, 150, 179, 91, 234, 2, 39, 207, 109, 133, 160, 72, 223, 55, 18, 250, 88, 176, 149, 125, 204, 36, 1, 233, 75, 163, 134, 110, ],
[0, 233, 207, 38, 131, 106, 76, 165, 27, 242, 212, 61, 152, 113, 87, 190, 54, 223, 249, 16, 181, 92, 122, 147, 45, 196, 226, 11, 174, 71, 97, 136, 108, 133, 163, 74, 239, 6, 32, 201, 119, 158, 184, 81, 244, 29, 59, 210, 90, 179, 149, 124, 217, 48, 22, 255, 65, 168, 142, 103, 194, 43, 13, 228, 216, 49, 23, 254, 91, 178, 148, 125, 195, 42, 12, 229, 64, 169, 143, 102, 238, 7, 33, 200, 109, 132, 162, 75, 245, 28, 58, 211, 118, 159, 185, 80, 180, 93, 123, 146, 55, 222, 248, 17, 175, 70, 96, 137, 44, 197, 227, 10, 130, 107, 77, 164, 1, 232, 206, 39, 153, 112, 86, 191, 26, 243, 213, 60, 173, 68, 98, 139, 46, 199, 225, 8, 182, 95, 121, 144, 53, 220, 250, 19, 155, 114, 84, 189, 24, 241, 215, 62, 128, 105, 79, 166, 3, 234, 204, 37, 193, 40, 14, 231, 66, 171, 141, 100, 218, 51, 21, 252, 89, 176, 150, 127, 247, 30, 56, 209, 116, 157, 187, 82, 236, 5, 35, 202, 111, 134, 160, 73, 117, 156, 186, 83, 246, 31, 57, 208, 110, 135, 161, 72, 237, 4, 34, 203, 67, 170, 140, 101, 192, 41, 15, 230, 88, 177, 151, 126, 219, 50, 20, 253, 25, 240, 214, 63, 154, 115, 85, 188, 2, 235, 205, 36, 129, 104, 78, 167, 47, 198, 224, 9, 172, 69, 99, 138, 52, 221, 251, 18, 183, 94, 120, 145, ],
[0, 234, 201, 35, 143, 101, 70, 172, 3, 233, 202, 32, 140, 102, 69, 175, 6, 236, 207, 37, 137, 99, 64, 170, 5, 239, 204, 38, 138, 96, 67, 169, 12, 230, 197, 47, 131, 105, 74, 160, 15, 229, 198, 44, 128, 106, 73, 163, 10, 224, 195, 41, 133, 111, 76, 166, 9, 227, 192, 42, 134, 108, 79, 165, 24, 242, 209, 59, 151, 125, 94, 180, 27, 241, 210, 56, 148, 126, 93, 183, 30, 244, 215, 61, 145, 123, 88, 178, 29, 247, 212, 62, 146, 120, 91, 177, 20, 254, 221, 55, 155, 113, 82, 184, 23, 253, 222, 52, 152, 114, 81, 187, 18, 248, 219, 49, 157, 119, 84, 190, 17, 251, 216, 50, 158, 116, 87, 189, 48, 218, 249, 19, 191, 85, 118, 156, 51, 217, 250, 16, 188, 86, 117, 159, 54, 220, 255, 21, 185, 83, 112, 154, 53, 223, 252, 22, 186, 80, 115, 153, 60, 214, 245, 31, 179, 89, 122, 144, 63, 213, 246, 28, 176, 90, 121, 147, 58, 208, 243, 25, 181, 95, 124, 150, 57, 211, 240, 26, 182, 92, 127, 149, 40, 194, 225, 11, 167, 77, 110, 132, 43, 193, 226, 8, 164, 78, 109, 135, 46, 196, 231, 13, 161, 75, 104, 130, 45, 199, 228, 14, 162, 72, 107, 129, 36, 206, 237, 7, 171, 65, 98, 136, 39, 205, 238, 4, 168, 66, 97, 139, 34, 200, 235, 1, 173, 71, 100, 142, 33, 203, 232, 2, 174, 68, 103, 141, ],
[0, 235, 203, 32, 139, 96, 64, 171, 11, 224, 192, 43, 128, 107, 75, 160, 22, 253, 221, 54, 157, 118, 86, 189, 29, 246, 214, 61, 150, 125, 93, 182, 44, 199, 231, 12, 167, 76, 108, 135, 39, 204, 236, 7, 172, 71, 103, 140, 58, 209, 241, 26, 177, 90, 122, 145, 49, 218, 250, 17, 186, 81, 113, 154, 88, 179, 147, 120, 211, 56, 24, 243, 83, 184, 152, 115, 216, 51, 19, 248, 78, 165, 133, 110, 197, 46, 14, 229, 69, 174, 142, 101, 206, 37, 5, 238, 116, 159, 191, 84, 255, 20, 52, 223, 127, 148, 180, 95, 244, 31, 63, 212, 98, 137, 169, 66, 233, 2, 34, 201, 105, 130, 162, 73, 226, 9, 41, 194, 176, 91, 123, 144, 59, 208, 240, 27, 187, 80, 112, 155, 48, 219, 251, 16, 166, 77, 109, 134, 45, 198, 230, 13, 173, 70, 102, 141, 38, 205, 237, 6, 156, 119, 87, 188, 23, 252, 220, 55, 151, 124, 92, 183, 28, 247, 215, 60, 138, 97, 65, 170, 1, 234, 202, 33, 129, 106, 74, 161, 10, 225, 193, 42, 232, 3, 35, 200, 99, 136, 168, 67, 227, 8, 40, 195, 104, 131, 163, 72, 254, 21, 53, 222, 117, 158, 190, 85, 245, 30, 62, 213, 126, 149, 181, 94, 196, 47, 15, 228, 79, 164, 132, 111, 207, 36, 4, 239, 68, 175, 143, 100, 210, 57, 25, 242, 89, 178, 146, 121, 217, 50, 18, 249, 82, 185, 153, 114, ],
[0, 236, 197, 41, 151, 123, 82, 190, 51, 223, 246, 26, 164, 72, 97, 141, 102, 138, 163, 79, 241, 29, 52, 216, 85, 185, 144, 124, 194, 46, 7, 235, 204, 32, 9, 229, 91, 183, 158, 114, 255, 19, 58, 214, 104, 132, 173, 65, 170, 70, 111, 131, 61, 209, 248, 20, 153, 117, 92, 176, 14, 226, 203, 39, 133, 105, 64, 172, 18, 254, 215, 59, 182, 90, 115, 159, 33, 205, 228, 8, 227, 15, 38, 202, 116, 152, 177, 93, 208, 60, 21, 249, 71, 171, 130, 110, 73, 165, 140, 96, 222, 50, 27, 247, 122, 150, 191, 83, 237, 1, 40, 196, 47, 195, 234, 6, 184, 84, 125, 145, 28, 240, 217, 53, 139, 103, 78, 162, 23, 251, 210, 62, 128, 108, 69, 169, 36, 200, 225, 13, 179, 95, 118, 154, 113, 157, 180, 88, 230, 10, 35, 207, 66, 174, 135, 107, 213, 57, 16, 252, 219, 55, 30, 242, 76, 160, 137, 101, 232, 4, 45, 193, 127, 147, 186, 86, 189, 81, 120, 148, 42, 198, 239, 3, 142, 98, 75, 167, 25, 245, 220, 48, 146, 126, 87, 187, 5, 233, 192, 44, 161, 77, 100, 136, 54, 218, 243, 31, 244, 24, 49, 221, 99, 143, 166, 74, 199, 43, 2, 238, 80, 188, 149, 121, 94, 178, 155, 119, 201, 37, 12, 224, 109, 129, 168, 68, 250, 22, 63, 211, 56, 212, 253, 17, 175, 67, 106, 134, 11, 231, 206, 34, 156, 112, 89, 181, ],
[0, 237, 199, 42, 147, 126, 84, 185, 59, 214, 252, 17, 168, 69, 111, 130, 118, 155, 177, 92, 229, 8, 34, 207, 77, 160, 138, 103, 222, 51, 25, 244, 236, 1, 43, 198, 127, 146, 184, 85, 215, 58, 16, 253, 68, 169, 131, 110, 154, 119, 93, 176, 9, 228, 206, 35, 161, 76, 102, 139, 50, 223, 245, 24, 197, 40, 2, 239, 86, 187, 145, 124, 254, 19, 57, 212, 109, 128, 170, 71, 179, 94, 116, 153, 32, 205, 231, 10, 136, 101, 79, 162, 27, 246, 220, 49, 41, 196, 238, 3, 186, 87, 125, 144, 18, 255, 213, 56, 129, 108, 70, 171, 95, 178, 152, 117, 204, 33, 11, 230, 100, 137, 163, 78, 247, 26, 48, 221, 151, 122, 80, 189, 4, 233, 195, 46, 172, 65, 107, 134, 63, 210, 248, 21, 225, 12, 38, 203, 114, 159, 181, 88, 218, 55, 29, 240, 73, 164, 142, 99, 123, 150, 188, 81, 232, 5, 47, 194, 64, 173, 135, 106, 211, 62, 20, 249, 13, 224, 202, 39, 158, 115, 89, 180, 54, 219, 241, 28, 165, 72, 98, 143, 82, 191, 149, 120, 193, 44, 6, 235, 105, 132, 174, 67, 250, 23, 61, 208, 36, 201, 227, 14, 183, 90, 112, 157, 31, 242, 216, 53, 140, 97, 75, 166, 190, 83, 121, 148, 45, 192, 234, 7, 133, 104, 66, 175, 22, 251, 209, 60, 200, 37, 15, 226, 91, 182, 156, 113, 243, 30, 52, 217, 96, 141, 167, 74, ],
[0, 238, 193, 47, 159, 113, 94, 176, 35, 205, 226, 12, 188, 82, 125, 147, 70, 168, 135, 105, 217, 55, 24, 246, 101, 139, 164, 74, 250, 20, 59, 213, 140, 98, 77, 163, 19, 253, 210, 60, 175, 65, 110, 128, 48, 222, 241, 31, 202, 36, 11, 229, 85, 187, 148, 122, 233, 7, 40, 198, 118, 152, 183, 89, 5, 235, 196, 42, 154, 116, 91, 181, 38, 200, 231, 9, 185, 87, 120, 150, 67, 173, 130, 108, 220, 50, 29, 243, 96, 142, 161, 79, 255, 17, 62, 208, 137, 103, 72, 166, 22, 248, 215, 57, 170, 68, 107, 133, 53, 219, 244, 26, 207, 33, 14, 224, 80, 190, 145, 127, 236, 2, 45, 195, 115, 157, 178, 92, 10, 228, 203, 37, 149, 123, 84, 186, 41, 199, 232, 6, 182, 88, 119, 153, 76, 162, 141, 99, 211, 61, 18, 252, 111, 129, 174, 64, 240, 30, 49, 223, 134, 104, 71, 169, 25, 247, 216, 54, 165, 75, 100, 138, 58, 212, 251, 21, 192, 46, 1, 239, 95, 177, 158, 112, 227, 13, 34, 204, 124, 146, 189, 83, 15, 225, 206, 32, 144, 126, 81, 191, 44, 194, 237, 3, 179, 93, 114, 156, 73, 167, 136, 102, 214, 56, 23, 249, 106, 132, 171, 69, 245, 27, 52, 218, 131, 109, 66, 172, 28, 242, 221, 51, 160, 78, 97, 143, 63, 209, 254, 16, 197, 43, 4, 234, 90, 180, 155, 117, 230, 8, 39, 201, 121, 151, 184, 86, ],
[0, 239, 195, 44, 155, 116, 88, 183, 43, 196, 232, 7, 176, 95, 115, 156, 86, 185, 149, 122, 205, 34, 14, 225, 125, 146, 190, 81, 230, 9, 37, 202, 172, 67, 111, 128, 55, 216, 244, 27, 135, 104, 68, 171, 28, 243, 223, 48, 250, 21, 57, 214, 97, 142, 162, 77, 209, 62, 18, 253, 74, 165, 137, 102, 69, 170, 134, 105, 222, 49, 29, 242, 110, 129, 173, 66, 245, 26, 54, 217, 19, 252, 208, 63, 136, 103, 75, 164, 56, 215, 251, 20, 163, 76, 96, 143, 233, 6, 42, 197, 114, 157, 177, 94, 194, 45, 1, 238, 89, 182, 154, 117, 191, 80, 124, 147, 36, 203, 231, 8, 148, 123, 87, 184, 15, 224, 204, 35, 138, 101, 73, 166, 17, 254, 210, 61, 161, 78, 98, 141, 58, 213, 249, 22, 220, 51, 31, 240, 71, 168, 132, 107, 247, 24, 52, 219, 108, 131, 175, 64, 38, 201, 229, 10, 189, 82, 126, 145, 13, 226, 206, 33, 150, 121, 85, 186, 112, 159, 179, 92, 235, 4, 40, 199, 91, 180, 152, 119, 192, 47, 3, 236, 207, 32, 12, 227, 84, 187, 151, 120, 228, 11, 39, 200, 127, 144, 188, 83, 153, 118, 90, 181, 2, 237, 193, 46, 178, 93, 113, 158, 41, 198, 234, 5, 99, 140, 160, 79, 248, 23, 59, 212, 72, 167, 139, 100, 211, 60, 16, 255, 53, 218, 246, 25, 174, 65, 109, 130, 30, 241, 221, 50, 133, 106, 70, 169, ],
[0, 240, 253, 13, 231, 23, 26, 234, 211, 35, 46, 222, 52, 196, 201, 57, 187, 75, 70, 182, 92, 172, 161, 81, 104, 152, 149, 101, 143, 127, 114, 130, 107, 155, 150, 102, 140, 124, 113, 129, 184, 72, 69, 181, 95, 175, 162, 82, 208, 32, 45, 221, 55, 199, 202, 58, 3, 243, 254, 14, 228, 20, 25, 233, 214, 38, 43, 219, 49, 193, 204, 60, 5, 245, 248, 8, 226, 18, 31, 239, 109, 157, 144, 96, 138, 122, 119, 135, 190, 78, 67, 179, 89, 169, 164, 84, 189, 77, 64, 176, 90, 170, 167, 87, 110, 158, 147, 99, 137, 121, 116, 132, 6, 246, 251, 11, 225, 17, 28, 236, 213, 37, 40, 216, 50, 194, 207, 63, 177, 65, 76, 188, 86, 166, 171, 91, 98, 146, 159, 111, 133, 117, 120, 136, 10, 250, 247, 7, 237, 29, 16, 224, 217, 41, 36, 212, 62, 206, 195, 51, 218, 42, 39, 215, 61, 205, 192, 48, 9, 249, 244, 4, 238, 30, 19, 227, 97, 145, 156, 108, 134, 118, 123, 139, 178, 66, 79, 191, 85, 165, 168, 88, 103, 151, 154, 106, 128, 112, 125, 141, 180, 68, 73, 185, 83, 163, 174, 94, 220, 44, 33, 209, 59, 203, 198, 54, 15, 255, 242, 2, 232, 24, 21, 229, 12, 252, 241, 1, 235, 27, 22, 230, 223, 47, 34, 210, 56, 200, 197, 53, 183, 71, 74, 186, 80, 160, 173, 93, 100, 148, 153, 105, 131, 115, 126, 142, ],
[0, 241, 255, 14, 227, 18, 28, 237, 219, 42, 36, 213, 56, 201, 199, 54, 171, 90, 84, 165, 72, 185, 183, 70, 112, 129, 143, 126, 147, 98, 108, 157, 75, 186, 180, 69, 168, 89, 87, 166, 144, 97, 111, 158, 115, 130, 140, 125, 224, 17, 31, 238, 3, 242, 252, 13, 59, 202, 196, 53, 216, 41, 39, 214, 150, 103, 105, 152, 117, 132, 138, 123, 77, 188, 178, 67, 174, 95, 81, 160, 61, 204, 194, 51, 222, 47, 33, 208, 230, 23, 25, 232, 5, 244, 250, 11, 221, 44, 34, 211, 62, 207, 193, 48, 6, 247, 249, 8, 229, 20, 26, 235, 118, 135, 137, 120, 149, 100, 106, 155, 173, 92, 82, 163, 78, 191, 177, 64, 49, 192, 206, 63, 210, 35, 45, 220, 234, 27, 21, 228, 9, 248, 246, 7, 154, 107, 101, 148, 121, 136, 134, 119, 65, 176, 190, 79, 162, 83, 93, 172, 122, 139, 133, 116, 153, 104, 102, 151, 161, 80, 94, 175, 66, 179, 189, 76, 209, 32, 46, 223, 50, 195, 205, 60, 10, 251, 245, 4, 233, 24, 22, 231, 167, 86, 88, 169, 68, 181, 187, 74, 124, 141, 131, 114, 159, 110, 96, 145, 12, 253, 243, 2, 239, 30, 16, 225, 215, 38, 40, 217, 52, 197, 203, 58, 236, 29, 19, 226, 15, 254, 240, 1, 55, 198, 200, 57, 212, 37, 43, 218, 71, 182, 184, 73, 164, 85, 91, 170, 156, 109, 99, 146, 127, 142, 128, 113, ],
[0, 242, 249, 11, 239, 29, 22, 228, 195, 49, 58, 200, 44, 222, 213, 39, 155, 105, 98, 144, 116, 134, 141, 127, 88, 170, 161, 83, 183, 69, 78, 188, 43, 217, 210, 32, 196, 54, 61, 207, 232, 26, 17, 227, 7, 245, 254, 12, 176, 66, 73, 187, 95, 173, 166, 84, 115, 129, 138, 120, 156, 110, 101, 151, 86, 164, 175, 93, 185, 75, 64, 178, 149, 103, 108, 158, 122, 136, 131, 113, 205, 63, 52, 198, 34, 208, 219, 41, 14, 252, 247, 5, 225, 19, 24, 234, 125, 143, 132, 118, 146, 96, 107, 153, 190, 76, 71, 181, 81, 163, 168, 90, 230, 20, 31, 237, 9, 251, 240, 2, 37, 215, 220, 46, 202, 56, 51, 193, 172, 94, 85, 167, 67, 177, 186, 72, 111, 157, 150, 100, 128, 114, 121, 139, 55, 197, 206, 60, 216, 42, 33, 211, 244, 6, 13, 255, 27, 233, 226, 16, 135, 117, 126, 140, 104, 154, 145, 99, 68, 182, 189, 79, 171, 89, 82, 160, 28, 238, 229, 23, 243, 1, 10, 248, 223, 45, 38, 212, 48, 194, 201, 59, 250, 8, 3, 241, 21, 231, 236, 30, 57, 203, 192, 50, 214, 36, 47, 221, 97, 147, 152, 106, 142, 124, 119, 133, 162, 80, 91, 169, 77, 191, 180, 70, 209, 35, 40, 218, 62, 204, 199, 53, 18, 224, 235, 25, 253, 15, 4, 246, 74, 184, 179, 65, 165, 87, 92, 174, 137, 123, 112, 130, 102, 148, 159, 109, ],
[0, 243, 251, 8, 235, 24, 16, 227, 203, 56, 48, 195, 32, 211, 219, 40, 139, 120, 112, 131, 96, 147, 155, 104, 64, 179, 187, 72, 171, 88, 80, 163, 11, 248, 240, 3, 224, 19, 27, 232, 192, 51, 59, 200, 43, 216, 208, 35, 128, 115, 123, 136, 107, 152, 144, 99, 75, 184, 176, 67, 160, 83, 91, 168, 22, 229, 237, 30, 253, 14, 6, 245, 221, 46, 38, 213, 54, 197, 205, 62, 157, 110, 102, 149, 118, 133, 141, 126, 86, 165, 173, 94, 189, 78, 70, 181, 29, 238, 230, 21, 246, 5, 13, 254, 214, 37, 45, 222, 61, 206, 198, 53, 150, 101, 109, 158, 125, 142, 134, 117, 93, 174, 166, 85, 182, 69, 77, 190, 44, 223, 215, 36, 199, 52, 60, 207, 231, 20, 28, 239, 12, 255, 247, 4, 167, 84, 92, 175, 76, 191, 183, 68, 108, 159, 151, 100, 135, 116, 124, 143, 39, 212, 220, 47, 204, 63, 55, 196, 236, 31, 23, 228, 7, 244, 252, 15, 172, 95, 87, 164, 71, 180, 188, 79, 103, 148, 156, 111, 140, 127, 119, 132, 58, 201, 193, 50, 209, 34, 42, 217, 241, 2, 10, 249, 26, 233, 225, 18, 177, 66, 74, 185, 90, 169, 161, 82, 122, 137, 129, 114, 145, 98, 106, 153, 49, 194, 202, 57, 218, 41, 33, 210, 250, 9, 1, 242, 17, 226, 234, 25, 186, 73, 65, 178, 81, 162, 170, 89, 113, 130, 138, 121, 154, 105, 97, 146, ],
[0, 244, 245, 1, 247, 3, 2, 246, 243, 7, 6, 242, 4, 240, 241, 5, 251, 15, 14, 250, 12, 248, 249, 13, 8, 252, 253, 9, 255, 11, 10, 254, 235, 31, 30, 234, 28, 232, 233, 29, 24, 236, 237, 25, 239, 27, 26, 238, 16, 228, 229, 17, 231, 19, 18, 230, 227, 23, 22, 226, 20, 224, 225, 21, 203, 63, 62, 202, 60, 200, 201, 61, 56, 204, 205, 57, 207, 59, 58, 206, 48, 196, 197, 49, 199, 51, 50, 198, 195, 55, 54, 194, 52, 192, 193, 53, 32, 212, 213, 33, 215, 35, 34, 214, 211, 39, 38, 210, 36, 208, 209, 37, 219, 47, 46, 218, 44, 216, 217, 45, 40, 220, 221, 41, 223, 43, 42, 222, 139, 127, 126, 138, 124, 136, 137, 125, 120, 140, 141, 121, 143, 123, 122, 142, 112, 132, 133, 113, 135, 115, 114, 134, 131, 119, 118, 130, 116, 128, 129, 117, 96, 148, 149, 97, 151, 99, 98, 150, 147, 103, 102, 146, 100, 144, 145, 101, 155, 111, 110, 154, 108, 152, 153, 109, 104, 156, 157, 105, 159, 107, 106, 158, 64, 180, 181, 65, 183, 67, 66, 182, 179, 71, 70, 178, 68, 176, 177, 69, 187, 79, 78, 186, 76, 184, 185, 77, 72, 188, 189, 73, 191, 75, 74, 190, 171, 95, 94, 170, 92, 168, 169, 93, 88, 172, 173, 89, 175, 91, 90, 174, 80, 164, 165, 81, 167, 83, 82, 166, 163, 87, 86, 162, 84, 160, 161, 85, ],
[0, 245, 247, 2, 243, 6, 4, 241, 251, 14, 12, 249, 8, 253, 255, 10, 235, 30, 28, 233, 24, 237, 239, 26, 16, 229, 231, 18, 227, 22, 20, 225, 203, 62, 60, 201, 56, 205, 207, 58, 48, 197, 199, 50, 195, 54, 52, 193, 32, 213, 215, 34, 211, 38, 36, 209, 219, 46, 44, 217, 40, 221, 223, 42, 139, 126, 124, 137, 120, 141, 143, 122, 112, 133, 135, 114, 131, 118, 116, 129, 96, 149, 151, 98, 147, 102, 100, 145, 155, 110, 108, 153, 104, 157, 159, 106, 64, 181, 183, 66, 179, 70, 68, 177, 187, 78, 76, 185, 72, 189, 191, 74, 171, 94, 92, 169, 88, 173, 175, 90, 80, 165, 167, 82, 163, 86, 84, 161, 11, 254, 252, 9, 248, 13, 15, 250, 240, 5, 7, 242, 3, 246, 244, 1, 224, 21, 23, 226, 19, 230, 228, 17, 27, 238, 236, 25, 232, 29, 31, 234, 192, 53, 55, 194, 51, 198, 196, 49, 59, 206, 204, 57, 200, 61, 63, 202, 43, 222, 220, 41, 216, 45, 47, 218, 208, 37, 39, 210, 35, 214, 212, 33, 128, 117, 119, 130, 115, 134, 132, 113, 123, 142, 140, 121, 136, 125, 127, 138, 107, 158, 156, 105, 152, 109, 111, 154, 144, 101, 103, 146, 99, 150, 148, 97, 75, 190, 188, 73, 184, 77, 79, 186, 176, 69, 71, 178, 67, 182, 180, 65, 160, 85, 87, 162, 83, 166, 164, 81, 91, 174, 172, 89, 168, 93, 95, 170, ],
[0, 246, 241, 7, 255, 9, 14, 248, 227, 21, 18, 228, 28, 234, 237, 27, 219, 45, 42, 220, 36, 210, 213, 35, 56, 206, 201, 63, 199, 49, 54, 192, 171, 93, 90, 172, 84, 162, 165, 83, 72, 190, 185, 79, 183, 65, 70, 176, 112, 134, 129, 119, 143, 121, 126, 136, 147, 101, 98, 148, 108, 154, 157, 107, 75, 189, 186, 76, 180, 66, 69, 179, 168, 94, 89, 175, 87, 161, 166, 80, 144, 102, 97, 151, 111, 153, 158, 104, 115, 133, 130, 116, 140, 122, 125, 139, 224, 22, 17, 231, 31, 233, 238, 24, 3, 245, 242, 4, 252, 10, 13, 251, 59, 205, 202, 60, 196, 50, 53, 195, 216, 46, 41, 223, 39, 209, 214, 32, 150, 96, 103, 145, 105, 159, 152, 110, 117, 131, 132, 114, 138, 124, 123, 141, 77, 187, 188, 74, 178, 68, 67, 181, 174, 88, 95, 169, 81, 167, 160, 86, 61, 203, 204, 58, 194, 52, 51, 197, 222, 40, 47, 217, 33, 215, 208, 38, 230, 16, 23, 225, 25, 239, 232, 30, 5, 243, 244, 2, 250, 12, 11, 253, 221, 43, 44, 218, 34, 212, 211, 37, 62, 200, 207, 57, 193, 55, 48, 198, 6, 240, 247, 1, 249, 15, 8, 254, 229, 19, 20, 226, 26, 236, 235, 29, 118, 128, 135, 113, 137, 127, 120, 142, 149, 99, 100, 146, 106, 156, 155, 109, 173, 91, 92, 170, 82, 164, 163, 85, 78, 184, 191, 73, 177, 71, 64, 182, ],
[0, 247, 243, 4, 251, 12, 8, 255, 235, 28, 24, 239, 16, 231, 227, 20, 203, 60, 56, 207, 48, 199, 195, 52, 32, 215, 211, 36, 219, 44, 40, 223, 139, 124, 120, 143, 112, 135, 131, 116, 96, 151, 147, 100, 155, 108, 104, 159, 64, 183, 179, 68, 187, 76, 72, 191, 171, 92, 88, 175, 80, 167, 163, 84, 11, 252, 248, 15, 240, 7, 3, 244, 224, 23, 19, 228, 27, 236, 232, 31, 192, 55, 51, 196, 59, 204, 200, 63, 43, 220, 216, 47, 208, 39, 35, 212, 128, 119, 115, 132, 123, 140, 136, 127, 107, 156, 152, 111, 144, 103, 99, 148, 75, 188, 184, 79, 176, 71, 67, 180, 160, 87, 83, 164, 91, 172, 168, 95, 22, 225, 229, 18, 237, 26, 30, 233, 253, 10, 14, 249, 6, 241, 245, 2, 221, 42, 46, 217, 38, 209, 213, 34, 54, 193, 197, 50, 205, 58, 62, 201, 157, 106, 110, 153, 102, 145, 149, 98, 118, 129, 133, 114, 141, 122, 126, 137, 86, 161, 165, 82, 173, 90, 94, 169, 189, 74, 78, 185, 70, 177, 181, 66, 29, 234, 238, 25, 230, 17, 21, 226, 246, 1, 5, 242, 13, 250, 254, 9, 214, 33, 37, 210, 45, 218, 222, 41, 61, 202, 206, 57, 198, 49, 53, 194, 150, 97, 101, 146, 109, 154, 158, 105, 125, 138, 142, 121, 134, 113, 117, 130, 93, 170, 174, 89, 166, 81, 85, 162, 182, 65, 69, 178, 77, 186, 190, 73, ],
[0, 248, 237, 21, 199, 63, 42, 210, 147, 107, 126, 134, 84, 172, 185, 65, 59, 195, 214, 46, 252, 4, 17, 233, 168, 80, 69, 189, 111, 151, 130, 122, 118, 142, 155, 99, 177, 73, 92, 164, 229, 29, 8, 240, 34, 218, 207, 55, 77, 181, 160, 88, 138, 114, 103, 159, 222, 38, 51, 203, 25, 225, 244, 12, 236, 20, 1, 249, 43, 211, 198, 62, 127, 135, 146, 106, 184, 64, 85, 173, 215, 47, 58, 194, 16, 232, 253, 5, 68, 188, 169, 81, 131, 123, 110, 150, 154, 98, 119, 143, 93, 165, 176, 72, 9, 241, 228, 28, 206, 54, 35, 219, 161, 89, 76, 180, 102, 158, 139, 115, 50, 202, 223, 39, 245, 13, 24, 224, 197, 61, 40, 208, 2, 250, 239, 23, 86, 174, 187, 67, 145, 105, 124, 132, 254, 6, 19, 235, 57, 193, 212, 44, 109, 149, 128, 120, 170, 82, 71, 191, 179, 75, 94, 166, 116, 140, 153, 97, 32, 216, 205, 53, 231, 31, 10, 242, 136, 112, 101, 157, 79, 183, 162, 90, 27, 227, 246, 14, 220, 36, 49, 201, 41, 209, 196, 60, 238, 22, 3, 251, 186, 66, 87, 175, 125, 133, 144, 104, 18, 234, 255, 7, 213, 45, 56, 192, 129, 121, 108, 148, 70, 190, 171, 83, 95, 167, 178, 74, 152, 96, 117, 141, 204, 52, 33, 217, 11, 243, 230, 30, 100, 156, 137, 113, 163, 91, 78, 182, 247, 15, 26, 226, 48, 200, 221, 37, ],
[0, 249, 239, 22, 195, 58, 44, 213, 155, 98, 116, 141, 88, 161, 183, 78, 43, 210, 196, 61, 232, 17, 7, 254, 176, 73, 95, 166, 115, 138, 156, 101, 86, 175, 185, 64, 149, 108, 122, 131, 205, 52, 34, 219, 14, 247, 225, 24, 125, 132, 146, 107, 190, 71, 81, 168, 230, 31, 9, 240, 37, 220, 202, 51, 172, 85, 67, 186, 111, 150, 128, 121, 55, 206, 216, 33, 244, 13, 27, 226, 135, 126, 104, 145, 68, 189, 171, 82, 28, 229, 243, 10, 223, 38, 48, 201, 250, 3, 21, 236, 57, 192, 214, 47, 97, 152, 142, 119, 162, 91, 77, 180, 209, 40, 62, 199, 18, 235, 253, 4, 74, 179, 165, 92, 137, 112, 102, 159, 69, 188, 170, 83, 134, 127, 105, 144, 222, 39, 49, 200, 29, 228, 242, 11, 110, 151, 129, 120, 173, 84, 66, 187, 245, 12, 26, 227, 54, 207, 217, 32, 19, 234, 252, 5, 208, 41, 63, 198, 136, 113, 103, 158, 75, 178, 164, 93, 56, 193, 215, 46, 251, 2, 20, 237, 163, 90, 76, 181, 96, 153, 143, 118, 233, 16, 6, 255, 42, 211, 197, 60, 114, 139, 157, 100, 177, 72, 94, 167, 194, 59, 45, 212, 1, 248, 238, 23, 89, 160, 182, 79, 154, 99, 117, 140, 191, 70, 80, 169, 124, 133, 147, 106, 36, 221, 203, 50, 231, 30, 8, 241, 148, 109, 123, 130, 87, 174, 184, 65, 15, 246, 224, 25, 204, 53, 35, 218, ],
[0, 250, 233, 19, 207, 53, 38, 220, 131, 121, 106, 144, 76, 182, 165, 95, 27, 225, 242, 8, 212, 46, 61, 199, 152, 98, 113, 139, 87, 173, 190, 68, 54, 204, 223, 37, 249, 3, 16, 234, 181, 79, 92, 166, 122, 128, 147, 105, 45, 215, 196, 62, 226, 24, 11, 241, 174, 84, 71, 189, 97, 155, 136, 114, 108, 150, 133, 127, 163, 89, 74, 176, 239, 21, 6, 252, 32, 218, 201, 51, 119, 141, 158, 100, 184, 66, 81, 171, 244, 14, 29, 231, 59, 193, 210, 40, 90, 160, 179, 73, 149, 111, 124, 134, 217, 35, 48, 202, 22, 236, 255, 5, 65, 187, 168, 82, 142, 116, 103, 157, 194, 56, 43, 209, 13, 247, 228, 30, 216, 34, 49, 203, 23, 237, 254, 4, 91, 161, 178, 72, 148, 110, 125, 135, 195, 57, 42, 208, 12, 246, 229, 31, 64, 186, 169, 83, 143, 117, 102, 156, 238, 20, 7, 253, 33, 219, 200, 50, 109, 151, 132, 126, 162, 88, 75, 177, 245, 15, 28, 230, 58, 192, 211, 41, 118, 140, 159, 101, 185, 67, 80, 170, 180, 78, 93, 167, 123, 129, 146, 104, 55, 205, 222, 36, 248, 2, 17, 235, 175, 85, 70, 188, 96, 154, 137, 115, 44, 214, 197, 63, 227, 25, 10, 240, 130, 120, 107, 145, 77, 183, 164, 94, 1, 251, 232, 18, 206, 52, 39, 221, 153, 99, 112, 138, 86, 172, 191, 69, 26, 224, 243, 9, 213, 47, 60, 198, ],
[0, 251, 235, 16, 203, 48, 32, 219, 139, 112, 96, 155, 64, 187, 171, 80, 11, 240, 224, 27, 192, 59, 43, 208, 128, 123, 107, 144, 75, 176, 160, 91, 22, 237, 253, 6, 221, 38, 54, 205, 157, 102, 118, 141, 86, 173, 189, 70, 29, 230, 246, 13, 214, 45, 61, 198, 150, 109, 125, 134, 93, 166, 182, 77, 44, 215, 199, 60, 231, 28, 12, 247, 167, 92, 76, 183, 108, 151, 135, 124, 39, 220, 204, 55, 236, 23, 7, 252, 172, 87, 71, 188, 103, 156, 140, 119, 58, 193, 209, 42, 241, 10, 26, 225, 177, 74, 90, 161, 122, 129, 145, 106, 49, 202, 218, 33, 250, 1, 17, 234, 186, 65, 81, 170, 113, 138, 154, 97, 88, 163, 179, 72, 147, 104, 120, 131, 211, 40, 56, 195, 24, 227, 243, 8, 83, 168, 184, 67, 152, 99, 115, 136, 216, 35, 51, 200, 19, 232, 248, 3, 78, 181, 165, 94, 133, 126, 110, 149, 197, 62, 46, 213, 14, 245, 229, 30, 69, 190, 174, 85, 142, 117, 101, 158, 206, 53, 37, 222, 5, 254, 238, 21, 116, 143, 159, 100, 191, 68, 84, 175, 255, 4, 20, 239, 52, 207, 223, 36, 127, 132, 148, 111, 180, 79, 95, 164, 244, 15, 31, 228, 63, 196, 212, 47, 98, 153, 137, 114, 169, 82, 66, 185, 233, 18, 2, 249, 34, 217, 201, 50, 105, 146, 130, 121, 162, 89, 73, 178, 226, 25, 9, 242, 41, 210, 194, 57, ],
[0, 252, 229, 25, 215, 43, 50, 206, 179, 79, 86, 170, 100, 152, 129, 125, 123, 135, 158, 98, 172, 80, 73, 181, 200, 52, 45, 209, 31, 227, 250, 6, 246, 10, 19, 239, 33, 221, 196, 56, 69, 185, 160, 92, 146, 110, 119, 139, 141, 113, 104, 148, 90, 166, 191, 67, 62, 194, 219, 39, 233, 21, 12, 240, 241, 13, 20, 232, 38, 218, 195, 63, 66, 190, 167, 91, 149, 105, 112, 140, 138, 118, 111, 147, 93, 161, 184, 68, 57, 197, 220, 32, 238, 18, 11, 247, 7, 251, 226, 30, 208, 44, 53, 201, 180, 72, 81, 173, 99, 159, 134, 122, 124, 128, 153, 101, 171, 87, 78, 178, 207, 51, 42, 214, 24, 228, 253, 1, 255, 3, 26, 230, 40, 212, 205, 49, 76, 176, 169, 85, 155, 103, 126, 130, 132, 120, 97, 157, 83, 175, 182, 74, 55, 203, 210, 46, 224, 28, 5, 249, 9, 245, 236, 16, 222, 34, 59, 199, 186, 70, 95, 163, 109, 145, 136, 116, 114, 142, 151, 107, 165, 89, 64, 188, 193, 61, 36, 216, 22, 234, 243, 15, 14, 242, 235, 23, 217, 37, 60, 192, 189, 65, 88, 164, 106, 150, 143, 115, 117, 137, 144, 108, 162, 94, 71, 187, 198, 58, 35, 223, 17, 237, 244, 8, 248, 4, 29, 225, 47, 211, 202, 54, 75, 183, 174, 82, 156, 96, 121, 133, 131, 127, 102, 154, 84, 168, 177, 77, 48, 204, 213, 41, 231, 27, 2, 254, ],
[0, 253, 231, 26, 211, 46, 52, 201, 187, 70, 92, 161, 104, 149, 143, 114, 107, 150, 140, 113, 184, 69, 95, 162, 208, 45, 55, 202, 3, 254, 228, 25, 214, 43, 49, 204, 5, 248, 226, 31, 109, 144, 138, 119, 190, 67, 89, 164, 189, 64, 90, 167, 110, 147, 137, 116, 6, 251, 225, 28, 213, 40, 50, 207, 177, 76, 86, 171, 98, 159, 133, 120, 10, 247, 237, 16, 217, 36, 62, 195, 218, 39, 61, 192, 9, 244, 238, 19, 97, 156, 134, 123, 178, 79, 85, 168, 103, 154, 128, 125, 180, 73, 83, 174, 220, 33, 59, 198, 15, 242, 232, 21, 12, 241, 235, 22, 223, 34, 56, 197, 183, 74, 80, 173, 100, 153, 131, 126, 127, 130, 152, 101, 172, 81, 75, 182, 196, 57, 35, 222, 23, 234, 240, 13, 20, 233, 243, 14, 199, 58, 32, 221, 175, 82, 72, 181, 124, 129, 155, 102, 169, 84, 78, 179, 122, 135, 157, 96, 18, 239, 245, 8, 193, 60, 38, 219, 194, 63, 37, 216, 17, 236, 246, 11, 121, 132, 158, 99, 170, 87, 77, 176, 206, 51, 41, 212, 29, 224, 250, 7, 117, 136, 146, 111, 166, 91, 65, 188, 165, 88, 66, 191, 118, 139, 145, 108, 30, 227, 249, 4, 205, 48, 42, 215, 24, 229, 255, 2, 203, 54, 44, 209, 163, 94, 68, 185, 112, 141, 151, 106, 115, 142, 148, 105, 160, 93, 71, 186, 200, 53, 47, 210, 27, 230, 252, 1, ],
[0, 254, 225, 31, 223, 33, 62, 192, 163, 93, 66, 188, 124, 130, 157, 99, 91, 165, 186, 68, 132, 122, 101, 155, 248, 6, 25, 231, 39, 217, 198, 56, 182, 72, 87, 169, 105, 151, 136, 118, 21, 235, 244, 10, 202, 52, 43, 213, 237, 19, 12, 242, 50, 204, 211, 45, 78, 176, 175, 81, 145, 111, 112, 142, 113, 143, 144, 110, 174, 80, 79, 177, 210, 44, 51, 205, 13, 243, 236, 18, 42, 212, 203, 53, 245, 11, 20, 234, 137, 119, 104, 150, 86, 168, 183, 73, 199, 57, 38, 216, 24, 230, 249, 7, 100, 154, 133, 123, 187, 69, 90, 164, 156, 98, 125, 131, 67, 189, 162, 92, 63, 193, 222, 32, 224, 30, 1, 255, 226, 28, 3, 253, 61, 195, 220, 34, 65, 191, 160, 94, 158, 96, 127, 129, 185, 71, 88, 166, 102, 152, 135, 121, 26, 228, 251, 5, 197, 59, 36, 218, 84, 170, 181, 75, 139, 117, 106, 148, 247, 9, 22, 232, 40, 214, 201, 55, 15, 241, 238, 16, 208, 46, 49, 207, 172, 82, 77, 179, 115, 141, 146, 108, 147, 109, 114, 140, 76, 178, 173, 83, 48, 206, 209, 47, 239, 17, 14, 240, 200, 54, 41, 215, 23, 233, 246, 8, 107, 149, 138, 116, 180, 74, 85, 171, 37, 219, 196, 58, 250, 4, 27, 229, 134, 120, 103, 153, 89, 167, 184, 70, 126, 128, 159, 97, 161, 95, 64, 190, 221, 35, 60, 194, 2, 252, 227, 29, ],
[0, 255, 227, 28, 219, 36, 56, 199, 171, 84, 72, 183, 112, 143, 147, 108, 75, 180, 168, 87, 144, 111, 115, 140, 224, 31, 3, 252, 59, 196, 216, 39, 150, 105, 117, 138, 77, 178, 174, 81, 61, 194, 222, 33, 230, 25, 5, 250, 221, 34, 62, 193, 6, 249, 229, 26, 118, 137, 149, 106, 173, 82, 78, 177, 49, 206, 210, 45, 234, 21, 9, 246, 154, 101, 121, 134, 65, 190, 162, 93, 122, 133, 153, 102, 161, 94, 66, 189, 209, 46, 50, 205, 10, 245, 233, 22, 167, 88, 68, 187, 124, 131, 159, 96, 12, 243, 239, 16, 215, 40, 52, 203, 236, 19, 15, 240, 55, 200, 212, 43, 71, 184, 164, 91, 156, 99, 127, 128, 98, 157, 129, 126, 185, 70, 90, 165, 201, 54, 42, 213, 18, 237, 241, 14, 41, 214, 202, 53, 242, 13, 17, 238, 130, 125, 97, 158, 89, 166, 186, 69, 244, 11, 23, 232, 47, 208, 204, 51, 95, 160, 188, 67, 132, 123, 103, 152, 191, 64, 92, 163, 100, 155, 135, 120, 20, 235, 247, 8, 207, 48, 44, 211, 83, 172, 176, 79, 136, 119, 107, 148, 248, 7, 27, 228, 35, 220, 192, 63, 24, 231, 251, 4, 195, 60, 32, 223, 179, 76, 80, 175, 104, 151, 139, 116, 197, 58, 38, 217, 30, 225, 253, 2, 110, 145, 141, 114, 181, 74, 86, 169, 142, 113, 109, 146, 85, 170, 182, 73, 37, 218, 198, 57, 254, 1, 29, 226, ],
];

'''
'''--- contract/target/debug/build/thiserror-b630d4dc70d62ee8/out/probe.rs ---

    #![feature(provide_any)]

    use std::any::{Demand, Provider};

    fn _f<'a, P: Provider>(p: &'a P, demand: &mut Demand<'a>) {
        p.provide(demand);
    }

'''
'''--- contract/target/debug/build/typenum-ae266bb20c1c0bd6/out/consts.rs ---

/**
Type aliases for many constants.

This file is generated by typenum's build script.

For unsigned integers, the format is `U` followed by the number. We define aliases for

- Numbers 0 through 1024
- Powers of 2 below `u64::MAX`
- Powers of 10 below `u64::MAX`

These alias definitions look like this:

```rust
use typenum::{B0, B1, UInt, UTerm};

# #[allow(dead_code)]
type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
```

For positive signed integers, the format is `P` followed by the number and for negative
signed integers it is `N` followed by the number. For the signed integer zero, we use
`Z0`. We define aliases for

- Numbers -1024 through 1024
- Powers of 2 between `i64::MIN` and `i64::MAX`
- Powers of 10 between `i64::MIN` and `i64::MAX`

These alias definitions look like this:

```rust
use typenum::{B0, B1, UInt, UTerm, PInt, NInt};

# #[allow(dead_code)]
type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
# #[allow(dead_code)]
type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
```

# Example
```rust
# #[allow(unused_imports)]
use typenum::{U0, U1, U2, U3, U4, U5, U6};
# #[allow(unused_imports)]
use typenum::{N3, N2, N1, Z0, P1, P2, P3};
# #[allow(unused_imports)]
use typenum::{U774, N17, N10000, P1024, P4096};
```

We also define the aliases `False` and `True` for `B0` and `B1`, respectively.
*/
#[allow(missing_docs)]
pub mod consts {
    use crate::uint::{UInt, UTerm};
    use crate::int::{PInt, NInt};

    pub use crate::bit::{B0, B1};
    pub use crate::int::Z0;

    pub type True = B1;
    pub type False = B0;
    pub type U0 = UTerm;
    pub type U1 = UInt<UTerm, B1>;
    pub type P1 = PInt<U1>; pub type N1 = NInt<U1>;
    pub type U2 = UInt<UInt<UTerm, B1>, B0>;
    pub type P2 = PInt<U2>; pub type N2 = NInt<U2>;
    pub type U3 = UInt<UInt<UTerm, B1>, B1>;
    pub type P3 = PInt<U3>; pub type N3 = NInt<U3>;
    pub type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    pub type P4 = PInt<U4>; pub type N4 = NInt<U4>;
    pub type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    pub type P5 = PInt<U5>; pub type N5 = NInt<U5>;
    pub type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
    pub type P6 = PInt<U6>; pub type N6 = NInt<U6>;
    pub type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;
    pub type P7 = PInt<U7>; pub type N7 = NInt<U7>;
    pub type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;
    pub type P8 = PInt<U8>; pub type N8 = NInt<U8>;
    pub type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;
    pub type P9 = PInt<U9>; pub type N9 = NInt<U9>;
    pub type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;
    pub type P10 = PInt<U10>; pub type N10 = NInt<U10>;
    pub type U11 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>;
    pub type P11 = PInt<U11>; pub type N11 = NInt<U11>;
    pub type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;
    pub type P12 = PInt<U12>; pub type N12 = NInt<U12>;
    pub type U13 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>;
    pub type P13 = PInt<U13>; pub type N13 = NInt<U13>;
    pub type U14 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>;
    pub type P14 = PInt<U14>; pub type N14 = NInt<U14>;
    pub type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;
    pub type P15 = PInt<U15>; pub type N15 = NInt<U15>;
    pub type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;
    pub type P16 = PInt<U16>; pub type N16 = NInt<U16>;
    pub type U17 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>;
    pub type P17 = PInt<U17>; pub type N17 = NInt<U17>;
    pub type U18 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>;
    pub type P18 = PInt<U18>; pub type N18 = NInt<U18>;
    pub type U19 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>;
    pub type P19 = PInt<U19>; pub type N19 = NInt<U19>;
    pub type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;
    pub type P20 = PInt<U20>; pub type N20 = NInt<U20>;
    pub type U21 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>;
    pub type P21 = PInt<U21>; pub type N21 = NInt<U21>;
    pub type U22 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>;
    pub type P22 = PInt<U22>; pub type N22 = NInt<U22>;
    pub type U23 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>;
    pub type P23 = PInt<U23>; pub type N23 = NInt<U23>;
    pub type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;
    pub type P24 = PInt<U24>; pub type N24 = NInt<U24>;
    pub type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;
    pub type P25 = PInt<U25>; pub type N25 = NInt<U25>;
    pub type U26 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>;
    pub type P26 = PInt<U26>; pub type N26 = NInt<U26>;
    pub type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;
    pub type P27 = PInt<U27>; pub type N27 = NInt<U27>;
    pub type U28 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>;
    pub type P28 = PInt<U28>; pub type N28 = NInt<U28>;
    pub type U29 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>;
    pub type P29 = PInt<U29>; pub type N29 = NInt<U29>;
    pub type U30 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>;
    pub type P30 = PInt<U30>; pub type N30 = NInt<U30>;
    pub type U31 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>;
    pub type P31 = PInt<U31>; pub type N31 = NInt<U31>;
    pub type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P32 = PInt<U32>; pub type N32 = NInt<U32>;
    pub type U33 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P33 = PInt<U33>; pub type N33 = NInt<U33>;
    pub type U34 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P34 = PInt<U34>; pub type N34 = NInt<U34>;
    pub type U35 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P35 = PInt<U35>; pub type N35 = NInt<U35>;
    pub type U36 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P36 = PInt<U36>; pub type N36 = NInt<U36>;
    pub type U37 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P37 = PInt<U37>; pub type N37 = NInt<U37>;
    pub type U38 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P38 = PInt<U38>; pub type N38 = NInt<U38>;
    pub type U39 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P39 = PInt<U39>; pub type N39 = NInt<U39>;
    pub type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P40 = PInt<U40>; pub type N40 = NInt<U40>;
    pub type U41 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P41 = PInt<U41>; pub type N41 = NInt<U41>;
    pub type U42 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P42 = PInt<U42>; pub type N42 = NInt<U42>;
    pub type U43 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P43 = PInt<U43>; pub type N43 = NInt<U43>;
    pub type U44 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P44 = PInt<U44>; pub type N44 = NInt<U44>;
    pub type U45 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P45 = PInt<U45>; pub type N45 = NInt<U45>;
    pub type U46 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P46 = PInt<U46>; pub type N46 = NInt<U46>;
    pub type U47 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P47 = PInt<U47>; pub type N47 = NInt<U47>;
    pub type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P48 = PInt<U48>; pub type N48 = NInt<U48>;
    pub type U49 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P49 = PInt<U49>; pub type N49 = NInt<U49>;
    pub type U50 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P50 = PInt<U50>; pub type N50 = NInt<U50>;
    pub type U51 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P51 = PInt<U51>; pub type N51 = NInt<U51>;
    pub type U52 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P52 = PInt<U52>; pub type N52 = NInt<U52>;
    pub type U53 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P53 = PInt<U53>; pub type N53 = NInt<U53>;
    pub type U54 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P54 = PInt<U54>; pub type N54 = NInt<U54>;
    pub type U55 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P55 = PInt<U55>; pub type N55 = NInt<U55>;
    pub type U56 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P56 = PInt<U56>; pub type N56 = NInt<U56>;
    pub type U57 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P57 = PInt<U57>; pub type N57 = NInt<U57>;
    pub type U58 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P58 = PInt<U58>; pub type N58 = NInt<U58>;
    pub type U59 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P59 = PInt<U59>; pub type N59 = NInt<U59>;
    pub type U60 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P60 = PInt<U60>; pub type N60 = NInt<U60>;
    pub type U61 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P61 = PInt<U61>; pub type N61 = NInt<U61>;
    pub type U62 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P62 = PInt<U62>; pub type N62 = NInt<U62>;
    pub type U63 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P63 = PInt<U63>; pub type N63 = NInt<U63>;
    pub type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P64 = PInt<U64>; pub type N64 = NInt<U64>;
    pub type U65 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P65 = PInt<U65>; pub type N65 = NInt<U65>;
    pub type U66 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P66 = PInt<U66>; pub type N66 = NInt<U66>;
    pub type U67 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P67 = PInt<U67>; pub type N67 = NInt<U67>;
    pub type U68 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P68 = PInt<U68>; pub type N68 = NInt<U68>;
    pub type U69 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P69 = PInt<U69>; pub type N69 = NInt<U69>;
    pub type U70 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P70 = PInt<U70>; pub type N70 = NInt<U70>;
    pub type U71 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P71 = PInt<U71>; pub type N71 = NInt<U71>;
    pub type U72 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P72 = PInt<U72>; pub type N72 = NInt<U72>;
    pub type U73 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P73 = PInt<U73>; pub type N73 = NInt<U73>;
    pub type U74 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P74 = PInt<U74>; pub type N74 = NInt<U74>;
    pub type U75 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P75 = PInt<U75>; pub type N75 = NInt<U75>;
    pub type U76 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P76 = PInt<U76>; pub type N76 = NInt<U76>;
    pub type U77 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P77 = PInt<U77>; pub type N77 = NInt<U77>;
    pub type U78 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P78 = PInt<U78>; pub type N78 = NInt<U78>;
    pub type U79 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P79 = PInt<U79>; pub type N79 = NInt<U79>;
    pub type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P80 = PInt<U80>; pub type N80 = NInt<U80>;
    pub type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P81 = PInt<U81>; pub type N81 = NInt<U81>;
    pub type U82 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P82 = PInt<U82>; pub type N82 = NInt<U82>;
    pub type U83 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P83 = PInt<U83>; pub type N83 = NInt<U83>;
    pub type U84 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P84 = PInt<U84>; pub type N84 = NInt<U84>;
    pub type U85 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P85 = PInt<U85>; pub type N85 = NInt<U85>;
    pub type U86 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P86 = PInt<U86>; pub type N86 = NInt<U86>;
    pub type U87 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P87 = PInt<U87>; pub type N87 = NInt<U87>;
    pub type U88 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P88 = PInt<U88>; pub type N88 = NInt<U88>;
    pub type U89 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P89 = PInt<U89>; pub type N89 = NInt<U89>;
    pub type U90 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P90 = PInt<U90>; pub type N90 = NInt<U90>;
    pub type U91 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P91 = PInt<U91>; pub type N91 = NInt<U91>;
    pub type U92 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P92 = PInt<U92>; pub type N92 = NInt<U92>;
    pub type U93 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P93 = PInt<U93>; pub type N93 = NInt<U93>;
    pub type U94 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P94 = PInt<U94>; pub type N94 = NInt<U94>;
    pub type U95 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P95 = PInt<U95>; pub type N95 = NInt<U95>;
    pub type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P96 = PInt<U96>; pub type N96 = NInt<U96>;
    pub type U97 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P97 = PInt<U97>; pub type N97 = NInt<U97>;
    pub type U98 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P98 = PInt<U98>; pub type N98 = NInt<U98>;
    pub type U99 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P99 = PInt<U99>; pub type N99 = NInt<U99>;
    pub type U100 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P100 = PInt<U100>; pub type N100 = NInt<U100>;
    pub type U101 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P101 = PInt<U101>; pub type N101 = NInt<U101>;
    pub type U102 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P102 = PInt<U102>; pub type N102 = NInt<U102>;
    pub type U103 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P103 = PInt<U103>; pub type N103 = NInt<U103>;
    pub type U104 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P104 = PInt<U104>; pub type N104 = NInt<U104>;
    pub type U105 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P105 = PInt<U105>; pub type N105 = NInt<U105>;
    pub type U106 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P106 = PInt<U106>; pub type N106 = NInt<U106>;
    pub type U107 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P107 = PInt<U107>; pub type N107 = NInt<U107>;
    pub type U108 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P108 = PInt<U108>; pub type N108 = NInt<U108>;
    pub type U109 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P109 = PInt<U109>; pub type N109 = NInt<U109>;
    pub type U110 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P110 = PInt<U110>; pub type N110 = NInt<U110>;
    pub type U111 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P111 = PInt<U111>; pub type N111 = NInt<U111>;
    pub type U112 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P112 = PInt<U112>; pub type N112 = NInt<U112>;
    pub type U113 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P113 = PInt<U113>; pub type N113 = NInt<U113>;
    pub type U114 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P114 = PInt<U114>; pub type N114 = NInt<U114>;
    pub type U115 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P115 = PInt<U115>; pub type N115 = NInt<U115>;
    pub type U116 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P116 = PInt<U116>; pub type N116 = NInt<U116>;
    pub type U117 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P117 = PInt<U117>; pub type N117 = NInt<U117>;
    pub type U118 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P118 = PInt<U118>; pub type N118 = NInt<U118>;
    pub type U119 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P119 = PInt<U119>; pub type N119 = NInt<U119>;
    pub type U120 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P120 = PInt<U120>; pub type N120 = NInt<U120>;
    pub type U121 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P121 = PInt<U121>; pub type N121 = NInt<U121>;
    pub type U122 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P122 = PInt<U122>; pub type N122 = NInt<U122>;
    pub type U123 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P123 = PInt<U123>; pub type N123 = NInt<U123>;
    pub type U124 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P124 = PInt<U124>; pub type N124 = NInt<U124>;
    pub type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P125 = PInt<U125>; pub type N125 = NInt<U125>;
    pub type U126 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P126 = PInt<U126>; pub type N126 = NInt<U126>;
    pub type U127 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P127 = PInt<U127>; pub type N127 = NInt<U127>;
    pub type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P128 = PInt<U128>; pub type N128 = NInt<U128>;
    pub type U129 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P129 = PInt<U129>; pub type N129 = NInt<U129>;
    pub type U130 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P130 = PInt<U130>; pub type N130 = NInt<U130>;
    pub type U131 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P131 = PInt<U131>; pub type N131 = NInt<U131>;
    pub type U132 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P132 = PInt<U132>; pub type N132 = NInt<U132>;
    pub type U133 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P133 = PInt<U133>; pub type N133 = NInt<U133>;
    pub type U134 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P134 = PInt<U134>; pub type N134 = NInt<U134>;
    pub type U135 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P135 = PInt<U135>; pub type N135 = NInt<U135>;
    pub type U136 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P136 = PInt<U136>; pub type N136 = NInt<U136>;
    pub type U137 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P137 = PInt<U137>; pub type N137 = NInt<U137>;
    pub type U138 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P138 = PInt<U138>; pub type N138 = NInt<U138>;
    pub type U139 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P139 = PInt<U139>; pub type N139 = NInt<U139>;
    pub type U140 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P140 = PInt<U140>; pub type N140 = NInt<U140>;
    pub type U141 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P141 = PInt<U141>; pub type N141 = NInt<U141>;
    pub type U142 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P142 = PInt<U142>; pub type N142 = NInt<U142>;
    pub type U143 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P143 = PInt<U143>; pub type N143 = NInt<U143>;
    pub type U144 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P144 = PInt<U144>; pub type N144 = NInt<U144>;
    pub type U145 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P145 = PInt<U145>; pub type N145 = NInt<U145>;
    pub type U146 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P146 = PInt<U146>; pub type N146 = NInt<U146>;
    pub type U147 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P147 = PInt<U147>; pub type N147 = NInt<U147>;
    pub type U148 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P148 = PInt<U148>; pub type N148 = NInt<U148>;
    pub type U149 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P149 = PInt<U149>; pub type N149 = NInt<U149>;
    pub type U150 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P150 = PInt<U150>; pub type N150 = NInt<U150>;
    pub type U151 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P151 = PInt<U151>; pub type N151 = NInt<U151>;
    pub type U152 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P152 = PInt<U152>; pub type N152 = NInt<U152>;
    pub type U153 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P153 = PInt<U153>; pub type N153 = NInt<U153>;
    pub type U154 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P154 = PInt<U154>; pub type N154 = NInt<U154>;
    pub type U155 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P155 = PInt<U155>; pub type N155 = NInt<U155>;
    pub type U156 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P156 = PInt<U156>; pub type N156 = NInt<U156>;
    pub type U157 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P157 = PInt<U157>; pub type N157 = NInt<U157>;
    pub type U158 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P158 = PInt<U158>; pub type N158 = NInt<U158>;
    pub type U159 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P159 = PInt<U159>; pub type N159 = NInt<U159>;
    pub type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P160 = PInt<U160>; pub type N160 = NInt<U160>;
    pub type U161 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P161 = PInt<U161>; pub type N161 = NInt<U161>;
    pub type U162 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P162 = PInt<U162>; pub type N162 = NInt<U162>;
    pub type U163 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P163 = PInt<U163>; pub type N163 = NInt<U163>;
    pub type U164 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P164 = PInt<U164>; pub type N164 = NInt<U164>;
    pub type U165 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P165 = PInt<U165>; pub type N165 = NInt<U165>;
    pub type U166 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P166 = PInt<U166>; pub type N166 = NInt<U166>;
    pub type U167 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P167 = PInt<U167>; pub type N167 = NInt<U167>;
    pub type U168 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P168 = PInt<U168>; pub type N168 = NInt<U168>;
    pub type U169 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P169 = PInt<U169>; pub type N169 = NInt<U169>;
    pub type U170 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P170 = PInt<U170>; pub type N170 = NInt<U170>;
    pub type U171 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P171 = PInt<U171>; pub type N171 = NInt<U171>;
    pub type U172 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P172 = PInt<U172>; pub type N172 = NInt<U172>;
    pub type U173 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P173 = PInt<U173>; pub type N173 = NInt<U173>;
    pub type U174 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P174 = PInt<U174>; pub type N174 = NInt<U174>;
    pub type U175 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P175 = PInt<U175>; pub type N175 = NInt<U175>;
    pub type U176 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P176 = PInt<U176>; pub type N176 = NInt<U176>;
    pub type U177 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P177 = PInt<U177>; pub type N177 = NInt<U177>;
    pub type U178 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P178 = PInt<U178>; pub type N178 = NInt<U178>;
    pub type U179 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P179 = PInt<U179>; pub type N179 = NInt<U179>;
    pub type U180 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P180 = PInt<U180>; pub type N180 = NInt<U180>;
    pub type U181 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P181 = PInt<U181>; pub type N181 = NInt<U181>;
    pub type U182 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P182 = PInt<U182>; pub type N182 = NInt<U182>;
    pub type U183 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P183 = PInt<U183>; pub type N183 = NInt<U183>;
    pub type U184 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P184 = PInt<U184>; pub type N184 = NInt<U184>;
    pub type U185 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P185 = PInt<U185>; pub type N185 = NInt<U185>;
    pub type U186 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P186 = PInt<U186>; pub type N186 = NInt<U186>;
    pub type U187 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P187 = PInt<U187>; pub type N187 = NInt<U187>;
    pub type U188 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P188 = PInt<U188>; pub type N188 = NInt<U188>;
    pub type U189 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P189 = PInt<U189>; pub type N189 = NInt<U189>;
    pub type U190 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P190 = PInt<U190>; pub type N190 = NInt<U190>;
    pub type U191 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P191 = PInt<U191>; pub type N191 = NInt<U191>;
    pub type U192 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P192 = PInt<U192>; pub type N192 = NInt<U192>;
    pub type U193 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P193 = PInt<U193>; pub type N193 = NInt<U193>;
    pub type U194 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P194 = PInt<U194>; pub type N194 = NInt<U194>;
    pub type U195 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P195 = PInt<U195>; pub type N195 = NInt<U195>;
    pub type U196 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P196 = PInt<U196>; pub type N196 = NInt<U196>;
    pub type U197 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P197 = PInt<U197>; pub type N197 = NInt<U197>;
    pub type U198 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P198 = PInt<U198>; pub type N198 = NInt<U198>;
    pub type U199 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P199 = PInt<U199>; pub type N199 = NInt<U199>;
    pub type U200 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P200 = PInt<U200>; pub type N200 = NInt<U200>;
    pub type U201 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P201 = PInt<U201>; pub type N201 = NInt<U201>;
    pub type U202 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P202 = PInt<U202>; pub type N202 = NInt<U202>;
    pub type U203 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P203 = PInt<U203>; pub type N203 = NInt<U203>;
    pub type U204 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P204 = PInt<U204>; pub type N204 = NInt<U204>;
    pub type U205 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P205 = PInt<U205>; pub type N205 = NInt<U205>;
    pub type U206 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P206 = PInt<U206>; pub type N206 = NInt<U206>;
    pub type U207 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P207 = PInt<U207>; pub type N207 = NInt<U207>;
    pub type U208 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P208 = PInt<U208>; pub type N208 = NInt<U208>;
    pub type U209 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P209 = PInt<U209>; pub type N209 = NInt<U209>;
    pub type U210 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P210 = PInt<U210>; pub type N210 = NInt<U210>;
    pub type U211 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P211 = PInt<U211>; pub type N211 = NInt<U211>;
    pub type U212 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P212 = PInt<U212>; pub type N212 = NInt<U212>;
    pub type U213 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P213 = PInt<U213>; pub type N213 = NInt<U213>;
    pub type U214 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P214 = PInt<U214>; pub type N214 = NInt<U214>;
    pub type U215 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P215 = PInt<U215>; pub type N215 = NInt<U215>;
    pub type U216 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P216 = PInt<U216>; pub type N216 = NInt<U216>;
    pub type U217 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P217 = PInt<U217>; pub type N217 = NInt<U217>;
    pub type U218 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P218 = PInt<U218>; pub type N218 = NInt<U218>;
    pub type U219 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P219 = PInt<U219>; pub type N219 = NInt<U219>;
    pub type U220 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P220 = PInt<U220>; pub type N220 = NInt<U220>;
    pub type U221 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P221 = PInt<U221>; pub type N221 = NInt<U221>;
    pub type U222 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P222 = PInt<U222>; pub type N222 = NInt<U222>;
    pub type U223 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P223 = PInt<U223>; pub type N223 = NInt<U223>;
    pub type U224 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P224 = PInt<U224>; pub type N224 = NInt<U224>;
    pub type U225 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P225 = PInt<U225>; pub type N225 = NInt<U225>;
    pub type U226 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P226 = PInt<U226>; pub type N226 = NInt<U226>;
    pub type U227 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P227 = PInt<U227>; pub type N227 = NInt<U227>;
    pub type U228 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P228 = PInt<U228>; pub type N228 = NInt<U228>;
    pub type U229 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P229 = PInt<U229>; pub type N229 = NInt<U229>;
    pub type U230 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P230 = PInt<U230>; pub type N230 = NInt<U230>;
    pub type U231 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P231 = PInt<U231>; pub type N231 = NInt<U231>;
    pub type U232 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P232 = PInt<U232>; pub type N232 = NInt<U232>;
    pub type U233 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P233 = PInt<U233>; pub type N233 = NInt<U233>;
    pub type U234 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P234 = PInt<U234>; pub type N234 = NInt<U234>;
    pub type U235 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P235 = PInt<U235>; pub type N235 = NInt<U235>;
    pub type U236 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P236 = PInt<U236>; pub type N236 = NInt<U236>;
    pub type U237 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P237 = PInt<U237>; pub type N237 = NInt<U237>;
    pub type U238 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P238 = PInt<U238>; pub type N238 = NInt<U238>;
    pub type U239 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P239 = PInt<U239>; pub type N239 = NInt<U239>;
    pub type U240 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P240 = PInt<U240>; pub type N240 = NInt<U240>;
    pub type U241 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P241 = PInt<U241>; pub type N241 = NInt<U241>;
    pub type U242 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P242 = PInt<U242>; pub type N242 = NInt<U242>;
    pub type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P243 = PInt<U243>; pub type N243 = NInt<U243>;
    pub type U244 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P244 = PInt<U244>; pub type N244 = NInt<U244>;
    pub type U245 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P245 = PInt<U245>; pub type N245 = NInt<U245>;
    pub type U246 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P246 = PInt<U246>; pub type N246 = NInt<U246>;
    pub type U247 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P247 = PInt<U247>; pub type N247 = NInt<U247>;
    pub type U248 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P248 = PInt<U248>; pub type N248 = NInt<U248>;
    pub type U249 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P249 = PInt<U249>; pub type N249 = NInt<U249>;
    pub type U250 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P250 = PInt<U250>; pub type N250 = NInt<U250>;
    pub type U251 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P251 = PInt<U251>; pub type N251 = NInt<U251>;
    pub type U252 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P252 = PInt<U252>; pub type N252 = NInt<U252>;
    pub type U253 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P253 = PInt<U253>; pub type N253 = NInt<U253>;
    pub type U254 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P254 = PInt<U254>; pub type N254 = NInt<U254>;
    pub type U255 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P255 = PInt<U255>; pub type N255 = NInt<U255>;
    pub type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P256 = PInt<U256>; pub type N256 = NInt<U256>;
    pub type U257 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P257 = PInt<U257>; pub type N257 = NInt<U257>;
    pub type U258 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P258 = PInt<U258>; pub type N258 = NInt<U258>;
    pub type U259 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P259 = PInt<U259>; pub type N259 = NInt<U259>;
    pub type U260 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P260 = PInt<U260>; pub type N260 = NInt<U260>;
    pub type U261 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P261 = PInt<U261>; pub type N261 = NInt<U261>;
    pub type U262 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P262 = PInt<U262>; pub type N262 = NInt<U262>;
    pub type U263 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P263 = PInt<U263>; pub type N263 = NInt<U263>;
    pub type U264 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P264 = PInt<U264>; pub type N264 = NInt<U264>;
    pub type U265 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P265 = PInt<U265>; pub type N265 = NInt<U265>;
    pub type U266 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P266 = PInt<U266>; pub type N266 = NInt<U266>;
    pub type U267 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P267 = PInt<U267>; pub type N267 = NInt<U267>;
    pub type U268 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P268 = PInt<U268>; pub type N268 = NInt<U268>;
    pub type U269 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P269 = PInt<U269>; pub type N269 = NInt<U269>;
    pub type U270 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P270 = PInt<U270>; pub type N270 = NInt<U270>;
    pub type U271 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P271 = PInt<U271>; pub type N271 = NInt<U271>;
    pub type U272 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P272 = PInt<U272>; pub type N272 = NInt<U272>;
    pub type U273 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P273 = PInt<U273>; pub type N273 = NInt<U273>;
    pub type U274 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P274 = PInt<U274>; pub type N274 = NInt<U274>;
    pub type U275 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P275 = PInt<U275>; pub type N275 = NInt<U275>;
    pub type U276 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P276 = PInt<U276>; pub type N276 = NInt<U276>;
    pub type U277 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P277 = PInt<U277>; pub type N277 = NInt<U277>;
    pub type U278 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P278 = PInt<U278>; pub type N278 = NInt<U278>;
    pub type U279 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P279 = PInt<U279>; pub type N279 = NInt<U279>;
    pub type U280 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P280 = PInt<U280>; pub type N280 = NInt<U280>;
    pub type U281 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P281 = PInt<U281>; pub type N281 = NInt<U281>;
    pub type U282 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P282 = PInt<U282>; pub type N282 = NInt<U282>;
    pub type U283 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P283 = PInt<U283>; pub type N283 = NInt<U283>;
    pub type U284 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P284 = PInt<U284>; pub type N284 = NInt<U284>;
    pub type U285 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P285 = PInt<U285>; pub type N285 = NInt<U285>;
    pub type U286 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P286 = PInt<U286>; pub type N286 = NInt<U286>;
    pub type U287 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P287 = PInt<U287>; pub type N287 = NInt<U287>;
    pub type U288 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P288 = PInt<U288>; pub type N288 = NInt<U288>;
    pub type U289 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P289 = PInt<U289>; pub type N289 = NInt<U289>;
    pub type U290 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P290 = PInt<U290>; pub type N290 = NInt<U290>;
    pub type U291 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P291 = PInt<U291>; pub type N291 = NInt<U291>;
    pub type U292 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P292 = PInt<U292>; pub type N292 = NInt<U292>;
    pub type U293 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P293 = PInt<U293>; pub type N293 = NInt<U293>;
    pub type U294 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P294 = PInt<U294>; pub type N294 = NInt<U294>;
    pub type U295 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P295 = PInt<U295>; pub type N295 = NInt<U295>;
    pub type U296 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P296 = PInt<U296>; pub type N296 = NInt<U296>;
    pub type U297 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P297 = PInt<U297>; pub type N297 = NInt<U297>;
    pub type U298 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P298 = PInt<U298>; pub type N298 = NInt<U298>;
    pub type U299 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P299 = PInt<U299>; pub type N299 = NInt<U299>;
    pub type U300 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P300 = PInt<U300>; pub type N300 = NInt<U300>;
    pub type U301 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P301 = PInt<U301>; pub type N301 = NInt<U301>;
    pub type U302 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P302 = PInt<U302>; pub type N302 = NInt<U302>;
    pub type U303 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P303 = PInt<U303>; pub type N303 = NInt<U303>;
    pub type U304 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P304 = PInt<U304>; pub type N304 = NInt<U304>;
    pub type U305 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P305 = PInt<U305>; pub type N305 = NInt<U305>;
    pub type U306 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P306 = PInt<U306>; pub type N306 = NInt<U306>;
    pub type U307 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P307 = PInt<U307>; pub type N307 = NInt<U307>;
    pub type U308 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P308 = PInt<U308>; pub type N308 = NInt<U308>;
    pub type U309 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P309 = PInt<U309>; pub type N309 = NInt<U309>;
    pub type U310 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P310 = PInt<U310>; pub type N310 = NInt<U310>;
    pub type U311 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P311 = PInt<U311>; pub type N311 = NInt<U311>;
    pub type U312 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P312 = PInt<U312>; pub type N312 = NInt<U312>;
    pub type U313 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P313 = PInt<U313>; pub type N313 = NInt<U313>;
    pub type U314 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P314 = PInt<U314>; pub type N314 = NInt<U314>;
    pub type U315 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P315 = PInt<U315>; pub type N315 = NInt<U315>;
    pub type U316 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P316 = PInt<U316>; pub type N316 = NInt<U316>;
    pub type U317 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P317 = PInt<U317>; pub type N317 = NInt<U317>;
    pub type U318 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P318 = PInt<U318>; pub type N318 = NInt<U318>;
    pub type U319 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P319 = PInt<U319>; pub type N319 = NInt<U319>;
    pub type U320 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P320 = PInt<U320>; pub type N320 = NInt<U320>;
    pub type U321 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P321 = PInt<U321>; pub type N321 = NInt<U321>;
    pub type U322 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P322 = PInt<U322>; pub type N322 = NInt<U322>;
    pub type U323 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P323 = PInt<U323>; pub type N323 = NInt<U323>;
    pub type U324 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P324 = PInt<U324>; pub type N324 = NInt<U324>;
    pub type U325 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P325 = PInt<U325>; pub type N325 = NInt<U325>;
    pub type U326 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P326 = PInt<U326>; pub type N326 = NInt<U326>;
    pub type U327 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P327 = PInt<U327>; pub type N327 = NInt<U327>;
    pub type U328 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P328 = PInt<U328>; pub type N328 = NInt<U328>;
    pub type U329 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P329 = PInt<U329>; pub type N329 = NInt<U329>;
    pub type U330 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P330 = PInt<U330>; pub type N330 = NInt<U330>;
    pub type U331 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P331 = PInt<U331>; pub type N331 = NInt<U331>;
    pub type U332 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P332 = PInt<U332>; pub type N332 = NInt<U332>;
    pub type U333 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P333 = PInt<U333>; pub type N333 = NInt<U333>;
    pub type U334 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P334 = PInt<U334>; pub type N334 = NInt<U334>;
    pub type U335 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P335 = PInt<U335>; pub type N335 = NInt<U335>;
    pub type U336 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P336 = PInt<U336>; pub type N336 = NInt<U336>;
    pub type U337 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P337 = PInt<U337>; pub type N337 = NInt<U337>;
    pub type U338 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P338 = PInt<U338>; pub type N338 = NInt<U338>;
    pub type U339 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P339 = PInt<U339>; pub type N339 = NInt<U339>;
    pub type U340 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P340 = PInt<U340>; pub type N340 = NInt<U340>;
    pub type U341 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P341 = PInt<U341>; pub type N341 = NInt<U341>;
    pub type U342 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P342 = PInt<U342>; pub type N342 = NInt<U342>;
    pub type U343 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P343 = PInt<U343>; pub type N343 = NInt<U343>;
    pub type U344 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P344 = PInt<U344>; pub type N344 = NInt<U344>;
    pub type U345 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P345 = PInt<U345>; pub type N345 = NInt<U345>;
    pub type U346 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P346 = PInt<U346>; pub type N346 = NInt<U346>;
    pub type U347 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P347 = PInt<U347>; pub type N347 = NInt<U347>;
    pub type U348 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P348 = PInt<U348>; pub type N348 = NInt<U348>;
    pub type U349 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P349 = PInt<U349>; pub type N349 = NInt<U349>;
    pub type U350 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P350 = PInt<U350>; pub type N350 = NInt<U350>;
    pub type U351 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P351 = PInt<U351>; pub type N351 = NInt<U351>;
    pub type U352 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P352 = PInt<U352>; pub type N352 = NInt<U352>;
    pub type U353 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P353 = PInt<U353>; pub type N353 = NInt<U353>;
    pub type U354 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P354 = PInt<U354>; pub type N354 = NInt<U354>;
    pub type U355 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P355 = PInt<U355>; pub type N355 = NInt<U355>;
    pub type U356 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P356 = PInt<U356>; pub type N356 = NInt<U356>;
    pub type U357 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P357 = PInt<U357>; pub type N357 = NInt<U357>;
    pub type U358 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P358 = PInt<U358>; pub type N358 = NInt<U358>;
    pub type U359 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P359 = PInt<U359>; pub type N359 = NInt<U359>;
    pub type U360 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P360 = PInt<U360>; pub type N360 = NInt<U360>;
    pub type U361 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P361 = PInt<U361>; pub type N361 = NInt<U361>;
    pub type U362 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P362 = PInt<U362>; pub type N362 = NInt<U362>;
    pub type U363 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P363 = PInt<U363>; pub type N363 = NInt<U363>;
    pub type U364 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P364 = PInt<U364>; pub type N364 = NInt<U364>;
    pub type U365 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P365 = PInt<U365>; pub type N365 = NInt<U365>;
    pub type U366 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P366 = PInt<U366>; pub type N366 = NInt<U366>;
    pub type U367 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P367 = PInt<U367>; pub type N367 = NInt<U367>;
    pub type U368 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P368 = PInt<U368>; pub type N368 = NInt<U368>;
    pub type U369 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P369 = PInt<U369>; pub type N369 = NInt<U369>;
    pub type U370 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P370 = PInt<U370>; pub type N370 = NInt<U370>;
    pub type U371 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P371 = PInt<U371>; pub type N371 = NInt<U371>;
    pub type U372 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P372 = PInt<U372>; pub type N372 = NInt<U372>;
    pub type U373 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P373 = PInt<U373>; pub type N373 = NInt<U373>;
    pub type U374 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P374 = PInt<U374>; pub type N374 = NInt<U374>;
    pub type U375 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P375 = PInt<U375>; pub type N375 = NInt<U375>;
    pub type U376 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P376 = PInt<U376>; pub type N376 = NInt<U376>;
    pub type U377 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P377 = PInt<U377>; pub type N377 = NInt<U377>;
    pub type U378 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P378 = PInt<U378>; pub type N378 = NInt<U378>;
    pub type U379 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P379 = PInt<U379>; pub type N379 = NInt<U379>;
    pub type U380 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P380 = PInt<U380>; pub type N380 = NInt<U380>;
    pub type U381 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P381 = PInt<U381>; pub type N381 = NInt<U381>;
    pub type U382 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P382 = PInt<U382>; pub type N382 = NInt<U382>;
    pub type U383 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P383 = PInt<U383>; pub type N383 = NInt<U383>;
    pub type U384 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P384 = PInt<U384>; pub type N384 = NInt<U384>;
    pub type U385 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P385 = PInt<U385>; pub type N385 = NInt<U385>;
    pub type U386 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P386 = PInt<U386>; pub type N386 = NInt<U386>;
    pub type U387 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P387 = PInt<U387>; pub type N387 = NInt<U387>;
    pub type U388 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P388 = PInt<U388>; pub type N388 = NInt<U388>;
    pub type U389 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P389 = PInt<U389>; pub type N389 = NInt<U389>;
    pub type U390 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P390 = PInt<U390>; pub type N390 = NInt<U390>;
    pub type U391 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P391 = PInt<U391>; pub type N391 = NInt<U391>;
    pub type U392 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P392 = PInt<U392>; pub type N392 = NInt<U392>;
    pub type U393 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P393 = PInt<U393>; pub type N393 = NInt<U393>;
    pub type U394 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P394 = PInt<U394>; pub type N394 = NInt<U394>;
    pub type U395 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P395 = PInt<U395>; pub type N395 = NInt<U395>;
    pub type U396 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P396 = PInt<U396>; pub type N396 = NInt<U396>;
    pub type U397 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P397 = PInt<U397>; pub type N397 = NInt<U397>;
    pub type U398 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P398 = PInt<U398>; pub type N398 = NInt<U398>;
    pub type U399 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P399 = PInt<U399>; pub type N399 = NInt<U399>;
    pub type U400 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P400 = PInt<U400>; pub type N400 = NInt<U400>;
    pub type U401 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P401 = PInt<U401>; pub type N401 = NInt<U401>;
    pub type U402 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P402 = PInt<U402>; pub type N402 = NInt<U402>;
    pub type U403 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P403 = PInt<U403>; pub type N403 = NInt<U403>;
    pub type U404 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P404 = PInt<U404>; pub type N404 = NInt<U404>;
    pub type U405 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P405 = PInt<U405>; pub type N405 = NInt<U405>;
    pub type U406 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P406 = PInt<U406>; pub type N406 = NInt<U406>;
    pub type U407 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P407 = PInt<U407>; pub type N407 = NInt<U407>;
    pub type U408 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P408 = PInt<U408>; pub type N408 = NInt<U408>;
    pub type U409 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P409 = PInt<U409>; pub type N409 = NInt<U409>;
    pub type U410 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P410 = PInt<U410>; pub type N410 = NInt<U410>;
    pub type U411 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P411 = PInt<U411>; pub type N411 = NInt<U411>;
    pub type U412 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P412 = PInt<U412>; pub type N412 = NInt<U412>;
    pub type U413 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P413 = PInt<U413>; pub type N413 = NInt<U413>;
    pub type U414 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P414 = PInt<U414>; pub type N414 = NInt<U414>;
    pub type U415 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P415 = PInt<U415>; pub type N415 = NInt<U415>;
    pub type U416 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P416 = PInt<U416>; pub type N416 = NInt<U416>;
    pub type U417 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P417 = PInt<U417>; pub type N417 = NInt<U417>;
    pub type U418 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P418 = PInt<U418>; pub type N418 = NInt<U418>;
    pub type U419 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P419 = PInt<U419>; pub type N419 = NInt<U419>;
    pub type U420 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P420 = PInt<U420>; pub type N420 = NInt<U420>;
    pub type U421 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P421 = PInt<U421>; pub type N421 = NInt<U421>;
    pub type U422 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P422 = PInt<U422>; pub type N422 = NInt<U422>;
    pub type U423 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P423 = PInt<U423>; pub type N423 = NInt<U423>;
    pub type U424 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P424 = PInt<U424>; pub type N424 = NInt<U424>;
    pub type U425 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P425 = PInt<U425>; pub type N425 = NInt<U425>;
    pub type U426 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P426 = PInt<U426>; pub type N426 = NInt<U426>;
    pub type U427 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P427 = PInt<U427>; pub type N427 = NInt<U427>;
    pub type U428 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P428 = PInt<U428>; pub type N428 = NInt<U428>;
    pub type U429 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P429 = PInt<U429>; pub type N429 = NInt<U429>;
    pub type U430 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P430 = PInt<U430>; pub type N430 = NInt<U430>;
    pub type U431 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P431 = PInt<U431>; pub type N431 = NInt<U431>;
    pub type U432 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P432 = PInt<U432>; pub type N432 = NInt<U432>;
    pub type U433 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P433 = PInt<U433>; pub type N433 = NInt<U433>;
    pub type U434 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P434 = PInt<U434>; pub type N434 = NInt<U434>;
    pub type U435 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P435 = PInt<U435>; pub type N435 = NInt<U435>;
    pub type U436 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P436 = PInt<U436>; pub type N436 = NInt<U436>;
    pub type U437 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P437 = PInt<U437>; pub type N437 = NInt<U437>;
    pub type U438 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P438 = PInt<U438>; pub type N438 = NInt<U438>;
    pub type U439 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P439 = PInt<U439>; pub type N439 = NInt<U439>;
    pub type U440 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P440 = PInt<U440>; pub type N440 = NInt<U440>;
    pub type U441 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P441 = PInt<U441>; pub type N441 = NInt<U441>;
    pub type U442 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P442 = PInt<U442>; pub type N442 = NInt<U442>;
    pub type U443 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P443 = PInt<U443>; pub type N443 = NInt<U443>;
    pub type U444 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P444 = PInt<U444>; pub type N444 = NInt<U444>;
    pub type U445 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P445 = PInt<U445>; pub type N445 = NInt<U445>;
    pub type U446 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P446 = PInt<U446>; pub type N446 = NInt<U446>;
    pub type U447 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P447 = PInt<U447>; pub type N447 = NInt<U447>;
    pub type U448 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P448 = PInt<U448>; pub type N448 = NInt<U448>;
    pub type U449 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P449 = PInt<U449>; pub type N449 = NInt<U449>;
    pub type U450 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P450 = PInt<U450>; pub type N450 = NInt<U450>;
    pub type U451 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P451 = PInt<U451>; pub type N451 = NInt<U451>;
    pub type U452 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P452 = PInt<U452>; pub type N452 = NInt<U452>;
    pub type U453 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P453 = PInt<U453>; pub type N453 = NInt<U453>;
    pub type U454 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P454 = PInt<U454>; pub type N454 = NInt<U454>;
    pub type U455 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P455 = PInt<U455>; pub type N455 = NInt<U455>;
    pub type U456 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P456 = PInt<U456>; pub type N456 = NInt<U456>;
    pub type U457 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P457 = PInt<U457>; pub type N457 = NInt<U457>;
    pub type U458 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P458 = PInt<U458>; pub type N458 = NInt<U458>;
    pub type U459 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P459 = PInt<U459>; pub type N459 = NInt<U459>;
    pub type U460 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P460 = PInt<U460>; pub type N460 = NInt<U460>;
    pub type U461 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P461 = PInt<U461>; pub type N461 = NInt<U461>;
    pub type U462 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P462 = PInt<U462>; pub type N462 = NInt<U462>;
    pub type U463 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P463 = PInt<U463>; pub type N463 = NInt<U463>;
    pub type U464 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P464 = PInt<U464>; pub type N464 = NInt<U464>;
    pub type U465 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P465 = PInt<U465>; pub type N465 = NInt<U465>;
    pub type U466 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P466 = PInt<U466>; pub type N466 = NInt<U466>;
    pub type U467 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P467 = PInt<U467>; pub type N467 = NInt<U467>;
    pub type U468 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P468 = PInt<U468>; pub type N468 = NInt<U468>;
    pub type U469 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P469 = PInt<U469>; pub type N469 = NInt<U469>;
    pub type U470 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P470 = PInt<U470>; pub type N470 = NInt<U470>;
    pub type U471 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P471 = PInt<U471>; pub type N471 = NInt<U471>;
    pub type U472 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P472 = PInt<U472>; pub type N472 = NInt<U472>;
    pub type U473 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P473 = PInt<U473>; pub type N473 = NInt<U473>;
    pub type U474 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P474 = PInt<U474>; pub type N474 = NInt<U474>;
    pub type U475 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P475 = PInt<U475>; pub type N475 = NInt<U475>;
    pub type U476 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P476 = PInt<U476>; pub type N476 = NInt<U476>;
    pub type U477 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P477 = PInt<U477>; pub type N477 = NInt<U477>;
    pub type U478 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P478 = PInt<U478>; pub type N478 = NInt<U478>;
    pub type U479 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P479 = PInt<U479>; pub type N479 = NInt<U479>;
    pub type U480 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P480 = PInt<U480>; pub type N480 = NInt<U480>;
    pub type U481 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P481 = PInt<U481>; pub type N481 = NInt<U481>;
    pub type U482 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P482 = PInt<U482>; pub type N482 = NInt<U482>;
    pub type U483 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P483 = PInt<U483>; pub type N483 = NInt<U483>;
    pub type U484 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P484 = PInt<U484>; pub type N484 = NInt<U484>;
    pub type U485 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P485 = PInt<U485>; pub type N485 = NInt<U485>;
    pub type U486 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P486 = PInt<U486>; pub type N486 = NInt<U486>;
    pub type U487 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P487 = PInt<U487>; pub type N487 = NInt<U487>;
    pub type U488 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P488 = PInt<U488>; pub type N488 = NInt<U488>;
    pub type U489 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P489 = PInt<U489>; pub type N489 = NInt<U489>;
    pub type U490 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P490 = PInt<U490>; pub type N490 = NInt<U490>;
    pub type U491 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P491 = PInt<U491>; pub type N491 = NInt<U491>;
    pub type U492 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P492 = PInt<U492>; pub type N492 = NInt<U492>;
    pub type U493 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P493 = PInt<U493>; pub type N493 = NInt<U493>;
    pub type U494 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P494 = PInt<U494>; pub type N494 = NInt<U494>;
    pub type U495 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P495 = PInt<U495>; pub type N495 = NInt<U495>;
    pub type U496 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P496 = PInt<U496>; pub type N496 = NInt<U496>;
    pub type U497 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P497 = PInt<U497>; pub type N497 = NInt<U497>;
    pub type U498 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P498 = PInt<U498>; pub type N498 = NInt<U498>;
    pub type U499 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P499 = PInt<U499>; pub type N499 = NInt<U499>;
    pub type U500 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P500 = PInt<U500>; pub type N500 = NInt<U500>;
    pub type U501 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P501 = PInt<U501>; pub type N501 = NInt<U501>;
    pub type U502 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P502 = PInt<U502>; pub type N502 = NInt<U502>;
    pub type U503 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P503 = PInt<U503>; pub type N503 = NInt<U503>;
    pub type U504 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P504 = PInt<U504>; pub type N504 = NInt<U504>;
    pub type U505 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P505 = PInt<U505>; pub type N505 = NInt<U505>;
    pub type U506 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P506 = PInt<U506>; pub type N506 = NInt<U506>;
    pub type U507 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P507 = PInt<U507>; pub type N507 = NInt<U507>;
    pub type U508 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P508 = PInt<U508>; pub type N508 = NInt<U508>;
    pub type U509 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P509 = PInt<U509>; pub type N509 = NInt<U509>;
    pub type U510 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P510 = PInt<U510>; pub type N510 = NInt<U510>;
    pub type U511 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P511 = PInt<U511>; pub type N511 = NInt<U511>;
    pub type U512 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P512 = PInt<U512>; pub type N512 = NInt<U512>;
    pub type U513 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P513 = PInt<U513>; pub type N513 = NInt<U513>;
    pub type U514 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P514 = PInt<U514>; pub type N514 = NInt<U514>;
    pub type U515 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P515 = PInt<U515>; pub type N515 = NInt<U515>;
    pub type U516 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P516 = PInt<U516>; pub type N516 = NInt<U516>;
    pub type U517 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P517 = PInt<U517>; pub type N517 = NInt<U517>;
    pub type U518 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P518 = PInt<U518>; pub type N518 = NInt<U518>;
    pub type U519 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P519 = PInt<U519>; pub type N519 = NInt<U519>;
    pub type U520 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P520 = PInt<U520>; pub type N520 = NInt<U520>;
    pub type U521 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P521 = PInt<U521>; pub type N521 = NInt<U521>;
    pub type U522 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P522 = PInt<U522>; pub type N522 = NInt<U522>;
    pub type U523 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P523 = PInt<U523>; pub type N523 = NInt<U523>;
    pub type U524 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P524 = PInt<U524>; pub type N524 = NInt<U524>;
    pub type U525 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P525 = PInt<U525>; pub type N525 = NInt<U525>;
    pub type U526 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P526 = PInt<U526>; pub type N526 = NInt<U526>;
    pub type U527 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P527 = PInt<U527>; pub type N527 = NInt<U527>;
    pub type U528 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P528 = PInt<U528>; pub type N528 = NInt<U528>;
    pub type U529 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P529 = PInt<U529>; pub type N529 = NInt<U529>;
    pub type U530 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P530 = PInt<U530>; pub type N530 = NInt<U530>;
    pub type U531 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P531 = PInt<U531>; pub type N531 = NInt<U531>;
    pub type U532 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P532 = PInt<U532>; pub type N532 = NInt<U532>;
    pub type U533 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P533 = PInt<U533>; pub type N533 = NInt<U533>;
    pub type U534 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P534 = PInt<U534>; pub type N534 = NInt<U534>;
    pub type U535 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P535 = PInt<U535>; pub type N535 = NInt<U535>;
    pub type U536 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P536 = PInt<U536>; pub type N536 = NInt<U536>;
    pub type U537 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P537 = PInt<U537>; pub type N537 = NInt<U537>;
    pub type U538 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P538 = PInt<U538>; pub type N538 = NInt<U538>;
    pub type U539 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P539 = PInt<U539>; pub type N539 = NInt<U539>;
    pub type U540 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P540 = PInt<U540>; pub type N540 = NInt<U540>;
    pub type U541 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P541 = PInt<U541>; pub type N541 = NInt<U541>;
    pub type U542 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P542 = PInt<U542>; pub type N542 = NInt<U542>;
    pub type U543 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P543 = PInt<U543>; pub type N543 = NInt<U543>;
    pub type U544 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P544 = PInt<U544>; pub type N544 = NInt<U544>;
    pub type U545 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P545 = PInt<U545>; pub type N545 = NInt<U545>;
    pub type U546 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P546 = PInt<U546>; pub type N546 = NInt<U546>;
    pub type U547 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P547 = PInt<U547>; pub type N547 = NInt<U547>;
    pub type U548 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P548 = PInt<U548>; pub type N548 = NInt<U548>;
    pub type U549 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P549 = PInt<U549>; pub type N549 = NInt<U549>;
    pub type U550 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P550 = PInt<U550>; pub type N550 = NInt<U550>;
    pub type U551 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P551 = PInt<U551>; pub type N551 = NInt<U551>;
    pub type U552 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P552 = PInt<U552>; pub type N552 = NInt<U552>;
    pub type U553 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P553 = PInt<U553>; pub type N553 = NInt<U553>;
    pub type U554 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P554 = PInt<U554>; pub type N554 = NInt<U554>;
    pub type U555 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P555 = PInt<U555>; pub type N555 = NInt<U555>;
    pub type U556 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P556 = PInt<U556>; pub type N556 = NInt<U556>;
    pub type U557 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P557 = PInt<U557>; pub type N557 = NInt<U557>;
    pub type U558 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P558 = PInt<U558>; pub type N558 = NInt<U558>;
    pub type U559 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P559 = PInt<U559>; pub type N559 = NInt<U559>;
    pub type U560 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P560 = PInt<U560>; pub type N560 = NInt<U560>;
    pub type U561 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P561 = PInt<U561>; pub type N561 = NInt<U561>;
    pub type U562 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P562 = PInt<U562>; pub type N562 = NInt<U562>;
    pub type U563 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P563 = PInt<U563>; pub type N563 = NInt<U563>;
    pub type U564 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P564 = PInt<U564>; pub type N564 = NInt<U564>;
    pub type U565 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P565 = PInt<U565>; pub type N565 = NInt<U565>;
    pub type U566 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P566 = PInt<U566>; pub type N566 = NInt<U566>;
    pub type U567 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P567 = PInt<U567>; pub type N567 = NInt<U567>;
    pub type U568 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P568 = PInt<U568>; pub type N568 = NInt<U568>;
    pub type U569 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P569 = PInt<U569>; pub type N569 = NInt<U569>;
    pub type U570 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P570 = PInt<U570>; pub type N570 = NInt<U570>;
    pub type U571 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P571 = PInt<U571>; pub type N571 = NInt<U571>;
    pub type U572 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P572 = PInt<U572>; pub type N572 = NInt<U572>;
    pub type U573 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P573 = PInt<U573>; pub type N573 = NInt<U573>;
    pub type U574 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P574 = PInt<U574>; pub type N574 = NInt<U574>;
    pub type U575 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P575 = PInt<U575>; pub type N575 = NInt<U575>;
    pub type U576 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P576 = PInt<U576>; pub type N576 = NInt<U576>;
    pub type U577 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P577 = PInt<U577>; pub type N577 = NInt<U577>;
    pub type U578 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P578 = PInt<U578>; pub type N578 = NInt<U578>;
    pub type U579 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P579 = PInt<U579>; pub type N579 = NInt<U579>;
    pub type U580 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P580 = PInt<U580>; pub type N580 = NInt<U580>;
    pub type U581 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P581 = PInt<U581>; pub type N581 = NInt<U581>;
    pub type U582 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P582 = PInt<U582>; pub type N582 = NInt<U582>;
    pub type U583 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P583 = PInt<U583>; pub type N583 = NInt<U583>;
    pub type U584 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P584 = PInt<U584>; pub type N584 = NInt<U584>;
    pub type U585 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P585 = PInt<U585>; pub type N585 = NInt<U585>;
    pub type U586 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P586 = PInt<U586>; pub type N586 = NInt<U586>;
    pub type U587 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P587 = PInt<U587>; pub type N587 = NInt<U587>;
    pub type U588 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P588 = PInt<U588>; pub type N588 = NInt<U588>;
    pub type U589 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P589 = PInt<U589>; pub type N589 = NInt<U589>;
    pub type U590 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P590 = PInt<U590>; pub type N590 = NInt<U590>;
    pub type U591 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P591 = PInt<U591>; pub type N591 = NInt<U591>;
    pub type U592 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P592 = PInt<U592>; pub type N592 = NInt<U592>;
    pub type U593 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P593 = PInt<U593>; pub type N593 = NInt<U593>;
    pub type U594 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P594 = PInt<U594>; pub type N594 = NInt<U594>;
    pub type U595 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P595 = PInt<U595>; pub type N595 = NInt<U595>;
    pub type U596 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P596 = PInt<U596>; pub type N596 = NInt<U596>;
    pub type U597 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P597 = PInt<U597>; pub type N597 = NInt<U597>;
    pub type U598 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P598 = PInt<U598>; pub type N598 = NInt<U598>;
    pub type U599 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P599 = PInt<U599>; pub type N599 = NInt<U599>;
    pub type U600 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P600 = PInt<U600>; pub type N600 = NInt<U600>;
    pub type U601 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P601 = PInt<U601>; pub type N601 = NInt<U601>;
    pub type U602 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P602 = PInt<U602>; pub type N602 = NInt<U602>;
    pub type U603 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P603 = PInt<U603>; pub type N603 = NInt<U603>;
    pub type U604 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P604 = PInt<U604>; pub type N604 = NInt<U604>;
    pub type U605 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P605 = PInt<U605>; pub type N605 = NInt<U605>;
    pub type U606 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P606 = PInt<U606>; pub type N606 = NInt<U606>;
    pub type U607 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P607 = PInt<U607>; pub type N607 = NInt<U607>;
    pub type U608 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P608 = PInt<U608>; pub type N608 = NInt<U608>;
    pub type U609 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P609 = PInt<U609>; pub type N609 = NInt<U609>;
    pub type U610 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P610 = PInt<U610>; pub type N610 = NInt<U610>;
    pub type U611 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P611 = PInt<U611>; pub type N611 = NInt<U611>;
    pub type U612 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P612 = PInt<U612>; pub type N612 = NInt<U612>;
    pub type U613 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P613 = PInt<U613>; pub type N613 = NInt<U613>;
    pub type U614 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P614 = PInt<U614>; pub type N614 = NInt<U614>;
    pub type U615 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P615 = PInt<U615>; pub type N615 = NInt<U615>;
    pub type U616 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P616 = PInt<U616>; pub type N616 = NInt<U616>;
    pub type U617 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P617 = PInt<U617>; pub type N617 = NInt<U617>;
    pub type U618 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P618 = PInt<U618>; pub type N618 = NInt<U618>;
    pub type U619 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P619 = PInt<U619>; pub type N619 = NInt<U619>;
    pub type U620 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P620 = PInt<U620>; pub type N620 = NInt<U620>;
    pub type U621 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P621 = PInt<U621>; pub type N621 = NInt<U621>;
    pub type U622 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P622 = PInt<U622>; pub type N622 = NInt<U622>;
    pub type U623 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P623 = PInt<U623>; pub type N623 = NInt<U623>;
    pub type U624 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P624 = PInt<U624>; pub type N624 = NInt<U624>;
    pub type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P625 = PInt<U625>; pub type N625 = NInt<U625>;
    pub type U626 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P626 = PInt<U626>; pub type N626 = NInt<U626>;
    pub type U627 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P627 = PInt<U627>; pub type N627 = NInt<U627>;
    pub type U628 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P628 = PInt<U628>; pub type N628 = NInt<U628>;
    pub type U629 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P629 = PInt<U629>; pub type N629 = NInt<U629>;
    pub type U630 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P630 = PInt<U630>; pub type N630 = NInt<U630>;
    pub type U631 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P631 = PInt<U631>; pub type N631 = NInt<U631>;
    pub type U632 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P632 = PInt<U632>; pub type N632 = NInt<U632>;
    pub type U633 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P633 = PInt<U633>; pub type N633 = NInt<U633>;
    pub type U634 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P634 = PInt<U634>; pub type N634 = NInt<U634>;
    pub type U635 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P635 = PInt<U635>; pub type N635 = NInt<U635>;
    pub type U636 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P636 = PInt<U636>; pub type N636 = NInt<U636>;
    pub type U637 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P637 = PInt<U637>; pub type N637 = NInt<U637>;
    pub type U638 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P638 = PInt<U638>; pub type N638 = NInt<U638>;
    pub type U639 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P639 = PInt<U639>; pub type N639 = NInt<U639>;
    pub type U640 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P640 = PInt<U640>; pub type N640 = NInt<U640>;
    pub type U641 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P641 = PInt<U641>; pub type N641 = NInt<U641>;
    pub type U642 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P642 = PInt<U642>; pub type N642 = NInt<U642>;
    pub type U643 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P643 = PInt<U643>; pub type N643 = NInt<U643>;
    pub type U644 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P644 = PInt<U644>; pub type N644 = NInt<U644>;
    pub type U645 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P645 = PInt<U645>; pub type N645 = NInt<U645>;
    pub type U646 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P646 = PInt<U646>; pub type N646 = NInt<U646>;
    pub type U647 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P647 = PInt<U647>; pub type N647 = NInt<U647>;
    pub type U648 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P648 = PInt<U648>; pub type N648 = NInt<U648>;
    pub type U649 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P649 = PInt<U649>; pub type N649 = NInt<U649>;
    pub type U650 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P650 = PInt<U650>; pub type N650 = NInt<U650>;
    pub type U651 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P651 = PInt<U651>; pub type N651 = NInt<U651>;
    pub type U652 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P652 = PInt<U652>; pub type N652 = NInt<U652>;
    pub type U653 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P653 = PInt<U653>; pub type N653 = NInt<U653>;
    pub type U654 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P654 = PInt<U654>; pub type N654 = NInt<U654>;
    pub type U655 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P655 = PInt<U655>; pub type N655 = NInt<U655>;
    pub type U656 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P656 = PInt<U656>; pub type N656 = NInt<U656>;
    pub type U657 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P657 = PInt<U657>; pub type N657 = NInt<U657>;
    pub type U658 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P658 = PInt<U658>; pub type N658 = NInt<U658>;
    pub type U659 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P659 = PInt<U659>; pub type N659 = NInt<U659>;
    pub type U660 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P660 = PInt<U660>; pub type N660 = NInt<U660>;
    pub type U661 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P661 = PInt<U661>; pub type N661 = NInt<U661>;
    pub type U662 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P662 = PInt<U662>; pub type N662 = NInt<U662>;
    pub type U663 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P663 = PInt<U663>; pub type N663 = NInt<U663>;
    pub type U664 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P664 = PInt<U664>; pub type N664 = NInt<U664>;
    pub type U665 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P665 = PInt<U665>; pub type N665 = NInt<U665>;
    pub type U666 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P666 = PInt<U666>; pub type N666 = NInt<U666>;
    pub type U667 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P667 = PInt<U667>; pub type N667 = NInt<U667>;
    pub type U668 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P668 = PInt<U668>; pub type N668 = NInt<U668>;
    pub type U669 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P669 = PInt<U669>; pub type N669 = NInt<U669>;
    pub type U670 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P670 = PInt<U670>; pub type N670 = NInt<U670>;
    pub type U671 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P671 = PInt<U671>; pub type N671 = NInt<U671>;
    pub type U672 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P672 = PInt<U672>; pub type N672 = NInt<U672>;
    pub type U673 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P673 = PInt<U673>; pub type N673 = NInt<U673>;
    pub type U674 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P674 = PInt<U674>; pub type N674 = NInt<U674>;
    pub type U675 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P675 = PInt<U675>; pub type N675 = NInt<U675>;
    pub type U676 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P676 = PInt<U676>; pub type N676 = NInt<U676>;
    pub type U677 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P677 = PInt<U677>; pub type N677 = NInt<U677>;
    pub type U678 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P678 = PInt<U678>; pub type N678 = NInt<U678>;
    pub type U679 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P679 = PInt<U679>; pub type N679 = NInt<U679>;
    pub type U680 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P680 = PInt<U680>; pub type N680 = NInt<U680>;
    pub type U681 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P681 = PInt<U681>; pub type N681 = NInt<U681>;
    pub type U682 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P682 = PInt<U682>; pub type N682 = NInt<U682>;
    pub type U683 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P683 = PInt<U683>; pub type N683 = NInt<U683>;
    pub type U684 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P684 = PInt<U684>; pub type N684 = NInt<U684>;
    pub type U685 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P685 = PInt<U685>; pub type N685 = NInt<U685>;
    pub type U686 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P686 = PInt<U686>; pub type N686 = NInt<U686>;
    pub type U687 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P687 = PInt<U687>; pub type N687 = NInt<U687>;
    pub type U688 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P688 = PInt<U688>; pub type N688 = NInt<U688>;
    pub type U689 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P689 = PInt<U689>; pub type N689 = NInt<U689>;
    pub type U690 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P690 = PInt<U690>; pub type N690 = NInt<U690>;
    pub type U691 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P691 = PInt<U691>; pub type N691 = NInt<U691>;
    pub type U692 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P692 = PInt<U692>; pub type N692 = NInt<U692>;
    pub type U693 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P693 = PInt<U693>; pub type N693 = NInt<U693>;
    pub type U694 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P694 = PInt<U694>; pub type N694 = NInt<U694>;
    pub type U695 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P695 = PInt<U695>; pub type N695 = NInt<U695>;
    pub type U696 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P696 = PInt<U696>; pub type N696 = NInt<U696>;
    pub type U697 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P697 = PInt<U697>; pub type N697 = NInt<U697>;
    pub type U698 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P698 = PInt<U698>; pub type N698 = NInt<U698>;
    pub type U699 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P699 = PInt<U699>; pub type N699 = NInt<U699>;
    pub type U700 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P700 = PInt<U700>; pub type N700 = NInt<U700>;
    pub type U701 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P701 = PInt<U701>; pub type N701 = NInt<U701>;
    pub type U702 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P702 = PInt<U702>; pub type N702 = NInt<U702>;
    pub type U703 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P703 = PInt<U703>; pub type N703 = NInt<U703>;
    pub type U704 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P704 = PInt<U704>; pub type N704 = NInt<U704>;
    pub type U705 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P705 = PInt<U705>; pub type N705 = NInt<U705>;
    pub type U706 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P706 = PInt<U706>; pub type N706 = NInt<U706>;
    pub type U707 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P707 = PInt<U707>; pub type N707 = NInt<U707>;
    pub type U708 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P708 = PInt<U708>; pub type N708 = NInt<U708>;
    pub type U709 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P709 = PInt<U709>; pub type N709 = NInt<U709>;
    pub type U710 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P710 = PInt<U710>; pub type N710 = NInt<U710>;
    pub type U711 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P711 = PInt<U711>; pub type N711 = NInt<U711>;
    pub type U712 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P712 = PInt<U712>; pub type N712 = NInt<U712>;
    pub type U713 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P713 = PInt<U713>; pub type N713 = NInt<U713>;
    pub type U714 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P714 = PInt<U714>; pub type N714 = NInt<U714>;
    pub type U715 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P715 = PInt<U715>; pub type N715 = NInt<U715>;
    pub type U716 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P716 = PInt<U716>; pub type N716 = NInt<U716>;
    pub type U717 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P717 = PInt<U717>; pub type N717 = NInt<U717>;
    pub type U718 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P718 = PInt<U718>; pub type N718 = NInt<U718>;
    pub type U719 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P719 = PInt<U719>; pub type N719 = NInt<U719>;
    pub type U720 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P720 = PInt<U720>; pub type N720 = NInt<U720>;
    pub type U721 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P721 = PInt<U721>; pub type N721 = NInt<U721>;
    pub type U722 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P722 = PInt<U722>; pub type N722 = NInt<U722>;
    pub type U723 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P723 = PInt<U723>; pub type N723 = NInt<U723>;
    pub type U724 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P724 = PInt<U724>; pub type N724 = NInt<U724>;
    pub type U725 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P725 = PInt<U725>; pub type N725 = NInt<U725>;
    pub type U726 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P726 = PInt<U726>; pub type N726 = NInt<U726>;
    pub type U727 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P727 = PInt<U727>; pub type N727 = NInt<U727>;
    pub type U728 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P728 = PInt<U728>; pub type N728 = NInt<U728>;
    pub type U729 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P729 = PInt<U729>; pub type N729 = NInt<U729>;
    pub type U730 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P730 = PInt<U730>; pub type N730 = NInt<U730>;
    pub type U731 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P731 = PInt<U731>; pub type N731 = NInt<U731>;
    pub type U732 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P732 = PInt<U732>; pub type N732 = NInt<U732>;
    pub type U733 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P733 = PInt<U733>; pub type N733 = NInt<U733>;
    pub type U734 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P734 = PInt<U734>; pub type N734 = NInt<U734>;
    pub type U735 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P735 = PInt<U735>; pub type N735 = NInt<U735>;
    pub type U736 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P736 = PInt<U736>; pub type N736 = NInt<U736>;
    pub type U737 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P737 = PInt<U737>; pub type N737 = NInt<U737>;
    pub type U738 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P738 = PInt<U738>; pub type N738 = NInt<U738>;
    pub type U739 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P739 = PInt<U739>; pub type N739 = NInt<U739>;
    pub type U740 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P740 = PInt<U740>; pub type N740 = NInt<U740>;
    pub type U741 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P741 = PInt<U741>; pub type N741 = NInt<U741>;
    pub type U742 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P742 = PInt<U742>; pub type N742 = NInt<U742>;
    pub type U743 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P743 = PInt<U743>; pub type N743 = NInt<U743>;
    pub type U744 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P744 = PInt<U744>; pub type N744 = NInt<U744>;
    pub type U745 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P745 = PInt<U745>; pub type N745 = NInt<U745>;
    pub type U746 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P746 = PInt<U746>; pub type N746 = NInt<U746>;
    pub type U747 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P747 = PInt<U747>; pub type N747 = NInt<U747>;
    pub type U748 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P748 = PInt<U748>; pub type N748 = NInt<U748>;
    pub type U749 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P749 = PInt<U749>; pub type N749 = NInt<U749>;
    pub type U750 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P750 = PInt<U750>; pub type N750 = NInt<U750>;
    pub type U751 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P751 = PInt<U751>; pub type N751 = NInt<U751>;
    pub type U752 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P752 = PInt<U752>; pub type N752 = NInt<U752>;
    pub type U753 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P753 = PInt<U753>; pub type N753 = NInt<U753>;
    pub type U754 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P754 = PInt<U754>; pub type N754 = NInt<U754>;
    pub type U755 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P755 = PInt<U755>; pub type N755 = NInt<U755>;
    pub type U756 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P756 = PInt<U756>; pub type N756 = NInt<U756>;
    pub type U757 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P757 = PInt<U757>; pub type N757 = NInt<U757>;
    pub type U758 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P758 = PInt<U758>; pub type N758 = NInt<U758>;
    pub type U759 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P759 = PInt<U759>; pub type N759 = NInt<U759>;
    pub type U760 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P760 = PInt<U760>; pub type N760 = NInt<U760>;
    pub type U761 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P761 = PInt<U761>; pub type N761 = NInt<U761>;
    pub type U762 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P762 = PInt<U762>; pub type N762 = NInt<U762>;
    pub type U763 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P763 = PInt<U763>; pub type N763 = NInt<U763>;
    pub type U764 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P764 = PInt<U764>; pub type N764 = NInt<U764>;
    pub type U765 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P765 = PInt<U765>; pub type N765 = NInt<U765>;
    pub type U766 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P766 = PInt<U766>; pub type N766 = NInt<U766>;
    pub type U767 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P767 = PInt<U767>; pub type N767 = NInt<U767>;
    pub type U768 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P768 = PInt<U768>; pub type N768 = NInt<U768>;
    pub type U769 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P769 = PInt<U769>; pub type N769 = NInt<U769>;
    pub type U770 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P770 = PInt<U770>; pub type N770 = NInt<U770>;
    pub type U771 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P771 = PInt<U771>; pub type N771 = NInt<U771>;
    pub type U772 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P772 = PInt<U772>; pub type N772 = NInt<U772>;
    pub type U773 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P773 = PInt<U773>; pub type N773 = NInt<U773>;
    pub type U774 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P774 = PInt<U774>; pub type N774 = NInt<U774>;
    pub type U775 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P775 = PInt<U775>; pub type N775 = NInt<U775>;
    pub type U776 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P776 = PInt<U776>; pub type N776 = NInt<U776>;
    pub type U777 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P777 = PInt<U777>; pub type N777 = NInt<U777>;
    pub type U778 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P778 = PInt<U778>; pub type N778 = NInt<U778>;
    pub type U779 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P779 = PInt<U779>; pub type N779 = NInt<U779>;
    pub type U780 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P780 = PInt<U780>; pub type N780 = NInt<U780>;
    pub type U781 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P781 = PInt<U781>; pub type N781 = NInt<U781>;
    pub type U782 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P782 = PInt<U782>; pub type N782 = NInt<U782>;
    pub type U783 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P783 = PInt<U783>; pub type N783 = NInt<U783>;
    pub type U784 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P784 = PInt<U784>; pub type N784 = NInt<U784>;
    pub type U785 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P785 = PInt<U785>; pub type N785 = NInt<U785>;
    pub type U786 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P786 = PInt<U786>; pub type N786 = NInt<U786>;
    pub type U787 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P787 = PInt<U787>; pub type N787 = NInt<U787>;
    pub type U788 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P788 = PInt<U788>; pub type N788 = NInt<U788>;
    pub type U789 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P789 = PInt<U789>; pub type N789 = NInt<U789>;
    pub type U790 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P790 = PInt<U790>; pub type N790 = NInt<U790>;
    pub type U791 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P791 = PInt<U791>; pub type N791 = NInt<U791>;
    pub type U792 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P792 = PInt<U792>; pub type N792 = NInt<U792>;
    pub type U793 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P793 = PInt<U793>; pub type N793 = NInt<U793>;
    pub type U794 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P794 = PInt<U794>; pub type N794 = NInt<U794>;
    pub type U795 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P795 = PInt<U795>; pub type N795 = NInt<U795>;
    pub type U796 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P796 = PInt<U796>; pub type N796 = NInt<U796>;
    pub type U797 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P797 = PInt<U797>; pub type N797 = NInt<U797>;
    pub type U798 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P798 = PInt<U798>; pub type N798 = NInt<U798>;
    pub type U799 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P799 = PInt<U799>; pub type N799 = NInt<U799>;
    pub type U800 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P800 = PInt<U800>; pub type N800 = NInt<U800>;
    pub type U801 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P801 = PInt<U801>; pub type N801 = NInt<U801>;
    pub type U802 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P802 = PInt<U802>; pub type N802 = NInt<U802>;
    pub type U803 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P803 = PInt<U803>; pub type N803 = NInt<U803>;
    pub type U804 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P804 = PInt<U804>; pub type N804 = NInt<U804>;
    pub type U805 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P805 = PInt<U805>; pub type N805 = NInt<U805>;
    pub type U806 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P806 = PInt<U806>; pub type N806 = NInt<U806>;
    pub type U807 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P807 = PInt<U807>; pub type N807 = NInt<U807>;
    pub type U808 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P808 = PInt<U808>; pub type N808 = NInt<U808>;
    pub type U809 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P809 = PInt<U809>; pub type N809 = NInt<U809>;
    pub type U810 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P810 = PInt<U810>; pub type N810 = NInt<U810>;
    pub type U811 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P811 = PInt<U811>; pub type N811 = NInt<U811>;
    pub type U812 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P812 = PInt<U812>; pub type N812 = NInt<U812>;
    pub type U813 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P813 = PInt<U813>; pub type N813 = NInt<U813>;
    pub type U814 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P814 = PInt<U814>; pub type N814 = NInt<U814>;
    pub type U815 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P815 = PInt<U815>; pub type N815 = NInt<U815>;
    pub type U816 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P816 = PInt<U816>; pub type N816 = NInt<U816>;
    pub type U817 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P817 = PInt<U817>; pub type N817 = NInt<U817>;
    pub type U818 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P818 = PInt<U818>; pub type N818 = NInt<U818>;
    pub type U819 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P819 = PInt<U819>; pub type N819 = NInt<U819>;
    pub type U820 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P820 = PInt<U820>; pub type N820 = NInt<U820>;
    pub type U821 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P821 = PInt<U821>; pub type N821 = NInt<U821>;
    pub type U822 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P822 = PInt<U822>; pub type N822 = NInt<U822>;
    pub type U823 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P823 = PInt<U823>; pub type N823 = NInt<U823>;
    pub type U824 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P824 = PInt<U824>; pub type N824 = NInt<U824>;
    pub type U825 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P825 = PInt<U825>; pub type N825 = NInt<U825>;
    pub type U826 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P826 = PInt<U826>; pub type N826 = NInt<U826>;
    pub type U827 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P827 = PInt<U827>; pub type N827 = NInt<U827>;
    pub type U828 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P828 = PInt<U828>; pub type N828 = NInt<U828>;
    pub type U829 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P829 = PInt<U829>; pub type N829 = NInt<U829>;
    pub type U830 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P830 = PInt<U830>; pub type N830 = NInt<U830>;
    pub type U831 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P831 = PInt<U831>; pub type N831 = NInt<U831>;
    pub type U832 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P832 = PInt<U832>; pub type N832 = NInt<U832>;
    pub type U833 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P833 = PInt<U833>; pub type N833 = NInt<U833>;
    pub type U834 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P834 = PInt<U834>; pub type N834 = NInt<U834>;
    pub type U835 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P835 = PInt<U835>; pub type N835 = NInt<U835>;
    pub type U836 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P836 = PInt<U836>; pub type N836 = NInt<U836>;
    pub type U837 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P837 = PInt<U837>; pub type N837 = NInt<U837>;
    pub type U838 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P838 = PInt<U838>; pub type N838 = NInt<U838>;
    pub type U839 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P839 = PInt<U839>; pub type N839 = NInt<U839>;
    pub type U840 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P840 = PInt<U840>; pub type N840 = NInt<U840>;
    pub type U841 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P841 = PInt<U841>; pub type N841 = NInt<U841>;
    pub type U842 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P842 = PInt<U842>; pub type N842 = NInt<U842>;
    pub type U843 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P843 = PInt<U843>; pub type N843 = NInt<U843>;
    pub type U844 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P844 = PInt<U844>; pub type N844 = NInt<U844>;
    pub type U845 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P845 = PInt<U845>; pub type N845 = NInt<U845>;
    pub type U846 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P846 = PInt<U846>; pub type N846 = NInt<U846>;
    pub type U847 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P847 = PInt<U847>; pub type N847 = NInt<U847>;
    pub type U848 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P848 = PInt<U848>; pub type N848 = NInt<U848>;
    pub type U849 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P849 = PInt<U849>; pub type N849 = NInt<U849>;
    pub type U850 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P850 = PInt<U850>; pub type N850 = NInt<U850>;
    pub type U851 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P851 = PInt<U851>; pub type N851 = NInt<U851>;
    pub type U852 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P852 = PInt<U852>; pub type N852 = NInt<U852>;
    pub type U853 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P853 = PInt<U853>; pub type N853 = NInt<U853>;
    pub type U854 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P854 = PInt<U854>; pub type N854 = NInt<U854>;
    pub type U855 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P855 = PInt<U855>; pub type N855 = NInt<U855>;
    pub type U856 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P856 = PInt<U856>; pub type N856 = NInt<U856>;
    pub type U857 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P857 = PInt<U857>; pub type N857 = NInt<U857>;
    pub type U858 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P858 = PInt<U858>; pub type N858 = NInt<U858>;
    pub type U859 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P859 = PInt<U859>; pub type N859 = NInt<U859>;
    pub type U860 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P860 = PInt<U860>; pub type N860 = NInt<U860>;
    pub type U861 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P861 = PInt<U861>; pub type N861 = NInt<U861>;
    pub type U862 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P862 = PInt<U862>; pub type N862 = NInt<U862>;
    pub type U863 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P863 = PInt<U863>; pub type N863 = NInt<U863>;
    pub type U864 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P864 = PInt<U864>; pub type N864 = NInt<U864>;
    pub type U865 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P865 = PInt<U865>; pub type N865 = NInt<U865>;
    pub type U866 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P866 = PInt<U866>; pub type N866 = NInt<U866>;
    pub type U867 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P867 = PInt<U867>; pub type N867 = NInt<U867>;
    pub type U868 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P868 = PInt<U868>; pub type N868 = NInt<U868>;
    pub type U869 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P869 = PInt<U869>; pub type N869 = NInt<U869>;
    pub type U870 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P870 = PInt<U870>; pub type N870 = NInt<U870>;
    pub type U871 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P871 = PInt<U871>; pub type N871 = NInt<U871>;
    pub type U872 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P872 = PInt<U872>; pub type N872 = NInt<U872>;
    pub type U873 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P873 = PInt<U873>; pub type N873 = NInt<U873>;
    pub type U874 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P874 = PInt<U874>; pub type N874 = NInt<U874>;
    pub type U875 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P875 = PInt<U875>; pub type N875 = NInt<U875>;
    pub type U876 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P876 = PInt<U876>; pub type N876 = NInt<U876>;
    pub type U877 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P877 = PInt<U877>; pub type N877 = NInt<U877>;
    pub type U878 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P878 = PInt<U878>; pub type N878 = NInt<U878>;
    pub type U879 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P879 = PInt<U879>; pub type N879 = NInt<U879>;
    pub type U880 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P880 = PInt<U880>; pub type N880 = NInt<U880>;
    pub type U881 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P881 = PInt<U881>; pub type N881 = NInt<U881>;
    pub type U882 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P882 = PInt<U882>; pub type N882 = NInt<U882>;
    pub type U883 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P883 = PInt<U883>; pub type N883 = NInt<U883>;
    pub type U884 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P884 = PInt<U884>; pub type N884 = NInt<U884>;
    pub type U885 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P885 = PInt<U885>; pub type N885 = NInt<U885>;
    pub type U886 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P886 = PInt<U886>; pub type N886 = NInt<U886>;
    pub type U887 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P887 = PInt<U887>; pub type N887 = NInt<U887>;
    pub type U888 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P888 = PInt<U888>; pub type N888 = NInt<U888>;
    pub type U889 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P889 = PInt<U889>; pub type N889 = NInt<U889>;
    pub type U890 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P890 = PInt<U890>; pub type N890 = NInt<U890>;
    pub type U891 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P891 = PInt<U891>; pub type N891 = NInt<U891>;
    pub type U892 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P892 = PInt<U892>; pub type N892 = NInt<U892>;
    pub type U893 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P893 = PInt<U893>; pub type N893 = NInt<U893>;
    pub type U894 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P894 = PInt<U894>; pub type N894 = NInt<U894>;
    pub type U895 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P895 = PInt<U895>; pub type N895 = NInt<U895>;
    pub type U896 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P896 = PInt<U896>; pub type N896 = NInt<U896>;
    pub type U897 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P897 = PInt<U897>; pub type N897 = NInt<U897>;
    pub type U898 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P898 = PInt<U898>; pub type N898 = NInt<U898>;
    pub type U899 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P899 = PInt<U899>; pub type N899 = NInt<U899>;
    pub type U900 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P900 = PInt<U900>; pub type N900 = NInt<U900>;
    pub type U901 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P901 = PInt<U901>; pub type N901 = NInt<U901>;
    pub type U902 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P902 = PInt<U902>; pub type N902 = NInt<U902>;
    pub type U903 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P903 = PInt<U903>; pub type N903 = NInt<U903>;
    pub type U904 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P904 = PInt<U904>; pub type N904 = NInt<U904>;
    pub type U905 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P905 = PInt<U905>; pub type N905 = NInt<U905>;
    pub type U906 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P906 = PInt<U906>; pub type N906 = NInt<U906>;
    pub type U907 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P907 = PInt<U907>; pub type N907 = NInt<U907>;
    pub type U908 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P908 = PInt<U908>; pub type N908 = NInt<U908>;
    pub type U909 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P909 = PInt<U909>; pub type N909 = NInt<U909>;
    pub type U910 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P910 = PInt<U910>; pub type N910 = NInt<U910>;
    pub type U911 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P911 = PInt<U911>; pub type N911 = NInt<U911>;
    pub type U912 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P912 = PInt<U912>; pub type N912 = NInt<U912>;
    pub type U913 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P913 = PInt<U913>; pub type N913 = NInt<U913>;
    pub type U914 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P914 = PInt<U914>; pub type N914 = NInt<U914>;
    pub type U915 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P915 = PInt<U915>; pub type N915 = NInt<U915>;
    pub type U916 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P916 = PInt<U916>; pub type N916 = NInt<U916>;
    pub type U917 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P917 = PInt<U917>; pub type N917 = NInt<U917>;
    pub type U918 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P918 = PInt<U918>; pub type N918 = NInt<U918>;
    pub type U919 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P919 = PInt<U919>; pub type N919 = NInt<U919>;
    pub type U920 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P920 = PInt<U920>; pub type N920 = NInt<U920>;
    pub type U921 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P921 = PInt<U921>; pub type N921 = NInt<U921>;
    pub type U922 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P922 = PInt<U922>; pub type N922 = NInt<U922>;
    pub type U923 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P923 = PInt<U923>; pub type N923 = NInt<U923>;
    pub type U924 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P924 = PInt<U924>; pub type N924 = NInt<U924>;
    pub type U925 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P925 = PInt<U925>; pub type N925 = NInt<U925>;
    pub type U926 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P926 = PInt<U926>; pub type N926 = NInt<U926>;
    pub type U927 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P927 = PInt<U927>; pub type N927 = NInt<U927>;
    pub type U928 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P928 = PInt<U928>; pub type N928 = NInt<U928>;
    pub type U929 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P929 = PInt<U929>; pub type N929 = NInt<U929>;
    pub type U930 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P930 = PInt<U930>; pub type N930 = NInt<U930>;
    pub type U931 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P931 = PInt<U931>; pub type N931 = NInt<U931>;
    pub type U932 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P932 = PInt<U932>; pub type N932 = NInt<U932>;
    pub type U933 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P933 = PInt<U933>; pub type N933 = NInt<U933>;
    pub type U934 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P934 = PInt<U934>; pub type N934 = NInt<U934>;
    pub type U935 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P935 = PInt<U935>; pub type N935 = NInt<U935>;
    pub type U936 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P936 = PInt<U936>; pub type N936 = NInt<U936>;
    pub type U937 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P937 = PInt<U937>; pub type N937 = NInt<U937>;
    pub type U938 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P938 = PInt<U938>; pub type N938 = NInt<U938>;
    pub type U939 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P939 = PInt<U939>; pub type N939 = NInt<U939>;
    pub type U940 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P940 = PInt<U940>; pub type N940 = NInt<U940>;
    pub type U941 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P941 = PInt<U941>; pub type N941 = NInt<U941>;
    pub type U942 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P942 = PInt<U942>; pub type N942 = NInt<U942>;
    pub type U943 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P943 = PInt<U943>; pub type N943 = NInt<U943>;
    pub type U944 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P944 = PInt<U944>; pub type N944 = NInt<U944>;
    pub type U945 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P945 = PInt<U945>; pub type N945 = NInt<U945>;
    pub type U946 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P946 = PInt<U946>; pub type N946 = NInt<U946>;
    pub type U947 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P947 = PInt<U947>; pub type N947 = NInt<U947>;
    pub type U948 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P948 = PInt<U948>; pub type N948 = NInt<U948>;
    pub type U949 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P949 = PInt<U949>; pub type N949 = NInt<U949>;
    pub type U950 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P950 = PInt<U950>; pub type N950 = NInt<U950>;
    pub type U951 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P951 = PInt<U951>; pub type N951 = NInt<U951>;
    pub type U952 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P952 = PInt<U952>; pub type N952 = NInt<U952>;
    pub type U953 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P953 = PInt<U953>; pub type N953 = NInt<U953>;
    pub type U954 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P954 = PInt<U954>; pub type N954 = NInt<U954>;
    pub type U955 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P955 = PInt<U955>; pub type N955 = NInt<U955>;
    pub type U956 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P956 = PInt<U956>; pub type N956 = NInt<U956>;
    pub type U957 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P957 = PInt<U957>; pub type N957 = NInt<U957>;
    pub type U958 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P958 = PInt<U958>; pub type N958 = NInt<U958>;
    pub type U959 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P959 = PInt<U959>; pub type N959 = NInt<U959>;
    pub type U960 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P960 = PInt<U960>; pub type N960 = NInt<U960>;
    pub type U961 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>;
    pub type P961 = PInt<U961>; pub type N961 = NInt<U961>;
    pub type U962 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>;
    pub type P962 = PInt<U962>; pub type N962 = NInt<U962>;
    pub type U963 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>;
    pub type P963 = PInt<U963>; pub type N963 = NInt<U963>;
    pub type U964 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>;
    pub type P964 = PInt<U964>; pub type N964 = NInt<U964>;
    pub type U965 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>;
    pub type P965 = PInt<U965>; pub type N965 = NInt<U965>;
    pub type U966 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>;
    pub type P966 = PInt<U966>; pub type N966 = NInt<U966>;
    pub type U967 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>;
    pub type P967 = PInt<U967>; pub type N967 = NInt<U967>;
    pub type U968 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>;
    pub type P968 = PInt<U968>; pub type N968 = NInt<U968>;
    pub type U969 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>;
    pub type P969 = PInt<U969>; pub type N969 = NInt<U969>;
    pub type U970 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>;
    pub type P970 = PInt<U970>; pub type N970 = NInt<U970>;
    pub type U971 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B1>;
    pub type P971 = PInt<U971>; pub type N971 = NInt<U971>;
    pub type U972 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>;
    pub type P972 = PInt<U972>; pub type N972 = NInt<U972>;
    pub type U973 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>;
    pub type P973 = PInt<U973>; pub type N973 = NInt<U973>;
    pub type U974 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>;
    pub type P974 = PInt<U974>; pub type N974 = NInt<U974>;
    pub type U975 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B1>;
    pub type P975 = PInt<U975>; pub type N975 = NInt<U975>;
    pub type U976 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P976 = PInt<U976>; pub type N976 = NInt<U976>;
    pub type U977 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>;
    pub type P977 = PInt<U977>; pub type N977 = NInt<U977>;
    pub type U978 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>;
    pub type P978 = PInt<U978>; pub type N978 = NInt<U978>;
    pub type U979 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>;
    pub type P979 = PInt<U979>; pub type N979 = NInt<U979>;
    pub type U980 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>;
    pub type P980 = PInt<U980>; pub type N980 = NInt<U980>;
    pub type U981 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B1>;
    pub type P981 = PInt<U981>; pub type N981 = NInt<U981>;
    pub type U982 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>;
    pub type P982 = PInt<U982>; pub type N982 = NInt<U982>;
    pub type U983 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>;
    pub type P983 = PInt<U983>; pub type N983 = NInt<U983>;
    pub type U984 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>;
    pub type P984 = PInt<U984>; pub type N984 = NInt<U984>;
    pub type U985 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>;
    pub type P985 = PInt<U985>; pub type N985 = NInt<U985>;
    pub type U986 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>;
    pub type P986 = PInt<U986>; pub type N986 = NInt<U986>;
    pub type U987 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>;
    pub type P987 = PInt<U987>; pub type N987 = NInt<U987>;
    pub type U988 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>;
    pub type P988 = PInt<U988>; pub type N988 = NInt<U988>;
    pub type U989 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>;
    pub type P989 = PInt<U989>; pub type N989 = NInt<U989>;
    pub type U990 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>;
    pub type P990 = PInt<U990>; pub type N990 = NInt<U990>;
    pub type U991 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>;
    pub type P991 = PInt<U991>; pub type N991 = NInt<U991>;
    pub type U992 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P992 = PInt<U992>; pub type N992 = NInt<U992>;
    pub type U993 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>;
    pub type P993 = PInt<U993>; pub type N993 = NInt<U993>;
    pub type U994 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>;
    pub type P994 = PInt<U994>; pub type N994 = NInt<U994>;
    pub type U995 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>;
    pub type P995 = PInt<U995>; pub type N995 = NInt<U995>;
    pub type U996 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>;
    pub type P996 = PInt<U996>; pub type N996 = NInt<U996>;
    pub type U997 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>;
    pub type P997 = PInt<U997>; pub type N997 = NInt<U997>;
    pub type U998 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>;
    pub type P998 = PInt<U998>; pub type N998 = NInt<U998>;
    pub type U999 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>;
    pub type P999 = PInt<U999>; pub type N999 = NInt<U999>;
    pub type U1000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>;
    pub type P1000 = PInt<U1000>; pub type N1000 = NInt<U1000>;
    pub type U1001 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>;
    pub type P1001 = PInt<U1001>; pub type N1001 = NInt<U1001>;
    pub type U1002 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>;
    pub type P1002 = PInt<U1002>; pub type N1002 = NInt<U1002>;
    pub type U1003 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>;
    pub type P1003 = PInt<U1003>; pub type N1003 = NInt<U1003>;
    pub type U1004 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>;
    pub type P1004 = PInt<U1004>; pub type N1004 = NInt<U1004>;
    pub type U1005 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>;
    pub type P1005 = PInt<U1005>; pub type N1005 = NInt<U1005>;
    pub type U1006 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>;
    pub type P1006 = PInt<U1006>; pub type N1006 = NInt<U1006>;
    pub type U1007 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B1>;
    pub type P1007 = PInt<U1007>; pub type N1007 = NInt<U1007>;
    pub type U1008 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>;
    pub type P1008 = PInt<U1008>; pub type N1008 = NInt<U1008>;
    pub type U1009 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;
    pub type P1009 = PInt<U1009>; pub type N1009 = NInt<U1009>;
    pub type U1010 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>;
    pub type P1010 = PInt<U1010>; pub type N1010 = NInt<U1010>;
    pub type U1011 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;
    pub type P1011 = PInt<U1011>; pub type N1011 = NInt<U1011>;
    pub type U1012 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>;
    pub type P1012 = PInt<U1012>; pub type N1012 = NInt<U1012>;
    pub type U1013 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>;
    pub type P1013 = PInt<U1013>; pub type N1013 = NInt<U1013>;
    pub type U1014 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B0>;
    pub type P1014 = PInt<U1014>; pub type N1014 = NInt<U1014>;
    pub type U1015 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>, B1>;
    pub type P1015 = PInt<U1015>; pub type N1015 = NInt<U1015>;
    pub type U1016 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>;
    pub type P1016 = PInt<U1016>; pub type N1016 = NInt<U1016>;
    pub type U1017 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>;
    pub type P1017 = PInt<U1017>; pub type N1017 = NInt<U1017>;
    pub type U1018 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>;
    pub type P1018 = PInt<U1018>; pub type N1018 = NInt<U1018>;
    pub type U1019 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B1>;
    pub type P1019 = PInt<U1019>; pub type N1019 = NInt<U1019>;
    pub type U1020 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>;
    pub type P1020 = PInt<U1020>; pub type N1020 = NInt<U1020>;
    pub type U1021 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>;
    pub type P1021 = PInt<U1021>; pub type N1021 = NInt<U1021>;
    pub type U1022 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B0>;
    pub type P1022 = PInt<U1022>; pub type N1022 = NInt<U1022>;
    pub type U1023 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>, B1>;
    pub type P1023 = PInt<U1023>; pub type N1023 = NInt<U1023>;
    pub type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1024 = PInt<U1024>; pub type N1024 = NInt<U1024>;
    pub type U2048 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2048 = PInt<U2048>; pub type N2048 = NInt<U2048>;
    pub type U4096 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4096 = PInt<U4096>; pub type N4096 = NInt<U4096>;
    pub type U8192 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P8192 = PInt<U8192>; pub type N8192 = NInt<U8192>;
    pub type U16384 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P16384 = PInt<U16384>; pub type N16384 = NInt<U16384>;
    pub type U32768 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P32768 = PInt<U32768>; pub type N32768 = NInt<U32768>;
    pub type U65536 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P65536 = PInt<U65536>; pub type N65536 = NInt<U65536>;
    pub type U131072 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P131072 = PInt<U131072>; pub type N131072 = NInt<U131072>;
    pub type U262144 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P262144 = PInt<U262144>; pub type N262144 = NInt<U262144>;
    pub type U524288 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P524288 = PInt<U524288>; pub type N524288 = NInt<U524288>;
    pub type U1048576 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1048576 = PInt<U1048576>; pub type N1048576 = NInt<U1048576>;
    pub type U2097152 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2097152 = PInt<U2097152>; pub type N2097152 = NInt<U2097152>;
    pub type U4194304 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4194304 = PInt<U4194304>; pub type N4194304 = NInt<U4194304>;
    pub type U8388608 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P8388608 = PInt<U8388608>; pub type N8388608 = NInt<U8388608>;
    pub type U16777216 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P16777216 = PInt<U16777216>; pub type N16777216 = NInt<U16777216>;
    pub type U33554432 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P33554432 = PInt<U33554432>; pub type N33554432 = NInt<U33554432>;
    pub type U67108864 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P67108864 = PInt<U67108864>; pub type N67108864 = NInt<U67108864>;
    pub type U134217728 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P134217728 = PInt<U134217728>; pub type N134217728 = NInt<U134217728>;
    pub type U268435456 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P268435456 = PInt<U268435456>; pub type N268435456 = NInt<U268435456>;
    pub type U536870912 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P536870912 = PInt<U536870912>; pub type N536870912 = NInt<U536870912>;
    pub type U1073741824 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1073741824 = PInt<U1073741824>; pub type N1073741824 = NInt<U1073741824>;
    pub type U2147483648 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2147483648 = PInt<U2147483648>; pub type N2147483648 = NInt<U2147483648>;
    pub type U4294967296 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4294967296 = PInt<U4294967296>; pub type N4294967296 = NInt<U4294967296>;
    pub type U8589934592 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P8589934592 = PInt<U8589934592>; pub type N8589934592 = NInt<U8589934592>;
    pub type U17179869184 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P17179869184 = PInt<U17179869184>; pub type N17179869184 = NInt<U17179869184>;
    pub type U34359738368 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P34359738368 = PInt<U34359738368>; pub type N34359738368 = NInt<U34359738368>;
    pub type U68719476736 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P68719476736 = PInt<U68719476736>; pub type N68719476736 = NInt<U68719476736>;
    pub type U137438953472 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P137438953472 = PInt<U137438953472>; pub type N137438953472 = NInt<U137438953472>;
    pub type U274877906944 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P274877906944 = PInt<U274877906944>; pub type N274877906944 = NInt<U274877906944>;
    pub type U549755813888 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P549755813888 = PInt<U549755813888>; pub type N549755813888 = NInt<U549755813888>;
    pub type U1099511627776 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1099511627776 = PInt<U1099511627776>; pub type N1099511627776 = NInt<U1099511627776>;
    pub type U2199023255552 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2199023255552 = PInt<U2199023255552>; pub type N2199023255552 = NInt<U2199023255552>;
    pub type U4398046511104 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4398046511104 = PInt<U4398046511104>; pub type N4398046511104 = NInt<U4398046511104>;
    pub type U8796093022208 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P8796093022208 = PInt<U8796093022208>; pub type N8796093022208 = NInt<U8796093022208>;
    pub type U17592186044416 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P17592186044416 = PInt<U17592186044416>; pub type N17592186044416 = NInt<U17592186044416>;
    pub type U35184372088832 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P35184372088832 = PInt<U35184372088832>; pub type N35184372088832 = NInt<U35184372088832>;
    pub type U70368744177664 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P70368744177664 = PInt<U70368744177664>; pub type N70368744177664 = NInt<U70368744177664>;
    pub type U140737488355328 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P140737488355328 = PInt<U140737488355328>; pub type N140737488355328 = NInt<U140737488355328>;
    pub type U281474976710656 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P281474976710656 = PInt<U281474976710656>; pub type N281474976710656 = NInt<U281474976710656>;
    pub type U562949953421312 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P562949953421312 = PInt<U562949953421312>; pub type N562949953421312 = NInt<U562949953421312>;
    pub type U1125899906842624 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1125899906842624 = PInt<U1125899906842624>; pub type N1125899906842624 = NInt<U1125899906842624>;
    pub type U2251799813685248 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2251799813685248 = PInt<U2251799813685248>; pub type N2251799813685248 = NInt<U2251799813685248>;
    pub type U4503599627370496 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4503599627370496 = PInt<U4503599627370496>; pub type N4503599627370496 = NInt<U4503599627370496>;
    pub type U9007199254740992 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P9007199254740992 = PInt<U9007199254740992>; pub type N9007199254740992 = NInt<U9007199254740992>;
    pub type U18014398509481984 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P18014398509481984 = PInt<U18014398509481984>; pub type N18014398509481984 = NInt<U18014398509481984>;
    pub type U36028797018963968 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P36028797018963968 = PInt<U36028797018963968>; pub type N36028797018963968 = NInt<U36028797018963968>;
    pub type U72057594037927936 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P72057594037927936 = PInt<U72057594037927936>; pub type N72057594037927936 = NInt<U72057594037927936>;
    pub type U144115188075855872 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P144115188075855872 = PInt<U144115188075855872>; pub type N144115188075855872 = NInt<U144115188075855872>;
    pub type U288230376151711744 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P288230376151711744 = PInt<U288230376151711744>; pub type N288230376151711744 = NInt<U288230376151711744>;
    pub type U576460752303423488 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P576460752303423488 = PInt<U576460752303423488>; pub type N576460752303423488 = NInt<U576460752303423488>;
    pub type U1152921504606846976 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1152921504606846976 = PInt<U1152921504606846976>; pub type N1152921504606846976 = NInt<U1152921504606846976>;
    pub type U2305843009213693952 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P2305843009213693952 = PInt<U2305843009213693952>; pub type N2305843009213693952 = NInt<U2305843009213693952>;
    pub type U4611686018427387904 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P4611686018427387904 = PInt<U4611686018427387904>; pub type N4611686018427387904 = NInt<U4611686018427387904>;
    pub type U9223372036854775808 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type U10000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>;
    pub type P10000 = PInt<U10000>; pub type N10000 = NInt<U10000>;
    pub type U100000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;
    pub type P100000 = PInt<U100000>; pub type N100000 = NInt<U100000>;
    pub type U1000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1000000 = PInt<U1000000>; pub type N1000000 = NInt<U1000000>;
    pub type U10000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P10000000 = PInt<U10000000>; pub type N10000000 = NInt<U10000000>;
    pub type U100000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P100000000 = PInt<U100000000>; pub type N100000000 = NInt<U100000000>;
    pub type U1000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1000000000 = PInt<U1000000000>; pub type N1000000000 = NInt<U1000000000>;
    pub type U10000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P10000000000 = PInt<U10000000000>; pub type N10000000000 = NInt<U10000000000>;
    pub type U100000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P100000000000 = PInt<U100000000000>; pub type N100000000000 = NInt<U100000000000>;
    pub type U1000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1000000000000 = PInt<U1000000000000>; pub type N1000000000000 = NInt<U1000000000000>;
    pub type U10000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P10000000000000 = PInt<U10000000000000>; pub type N10000000000000 = NInt<U10000000000000>;
    pub type U100000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P100000000000000 = PInt<U100000000000000>; pub type N100000000000000 = NInt<U100000000000000>;
    pub type U1000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1000000000000000 = PInt<U1000000000000000>; pub type N1000000000000000 = NInt<U1000000000000000>;
    pub type U10000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P10000000000000000 = PInt<U10000000000000000>; pub type N10000000000000000 = NInt<U10000000000000000>;
    pub type U100000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P100000000000000000 = PInt<U100000000000000000>; pub type N100000000000000000 = NInt<U100000000000000000>;
    pub type U1000000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B1>, B1>, B0>, B1>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
    pub type P1000000000000000000 = PInt<U1000000000000000000>; pub type N1000000000000000000 = NInt<U1000000000000000000>;
    pub type U10000000000000000000 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B1>, B0>, B1>, B0>, B1>, B1>, B0>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B1>, B0>, B0>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B0>, B0>, B0>, B1>, B0>, B0>, B1>, B1>, B1>, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;
}
'''
'''--- contract/target/debug/build/typenum-ae266bb20c1c0bd6/out/op.rs ---

/**
Convenient type operations.

Any types representing values must be able to be expressed as `ident`s. That means they need to be
in scope.

For example, `P5` is okay, but `typenum::P5` is not.

You may combine operators arbitrarily, although doing so excessively may require raising the
recursion limit.

# Example
```rust
#![recursion_limit="128"]
#[macro_use] extern crate typenum;
use typenum::consts::*;

fn main() {
    assert_type!(
        op!(min((P1 - P2) * (N3 + N7), P5 * (P3 + P4)) == P10)
    );
}
```
Operators are evaluated based on the operator precedence outlined
[here](https://doc.rust-lang.org/reference.html#operator-precedence).

The full list of supported operators and functions is as follows:

`*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `&`, `^`, `|`, `==`, `!=`, `<=`, `>=`, `<`, `>`, `cmp`, `sqr`, `sqrt`, `abs`, `cube`, `pow`, `min`, `max`, `log2`, `gcd`

They all expand to type aliases defined in the `operator_aliases` module. Here is an expanded list,
including examples:

---
Operator `*`. Expands to `Prod`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P2 * P3), P6);
# }
```

---
Operator `/`. Expands to `Quot`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P6 / P2), P3);
# }
```

---
Operator `%`. Expands to `Mod`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P5 % P3), P2);
# }
```

---
Operator `+`. Expands to `Sum`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P2 + P3), P5);
# }
```

---
Operator `-`. Expands to `Diff`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P2 - P3), N1);
# }
```

---
Operator `<<`. Expands to `Shleft`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(U1 << U5), U32);
# }
```

---
Operator `>>`. Expands to `Shright`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(U32 >> U5), U1);
# }
```

---
Operator `&`. Expands to `And`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(U5 & U3), U1);
# }
```

---
Operator `^`. Expands to `Xor`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(U5 ^ U3), U6);
# }
```

---
Operator `|`. Expands to `Or`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(U5 | U3), U7);
# }
```

---
Operator `==`. Expands to `Eq`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P5 == P3 + P2), True);
# }
```

---
Operator `!=`. Expands to `NotEq`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P5 != P3 + P2), False);
# }
```

---
Operator `<=`. Expands to `LeEq`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P6 <= P3 + P2), False);
# }
```

---
Operator `>=`. Expands to `GrEq`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P6 >= P3 + P2), True);
# }
```

---
Operator `<`. Expands to `Le`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P4 < P3 + P2), True);
# }
```

---
Operator `>`. Expands to `Gr`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(P5 < P3 + P2), False);
# }
```

---
Operator `cmp`. Expands to `Compare`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(cmp(P2, P3)), Less);
# }
```

---
Operator `sqr`. Expands to `Square`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(sqr(P2)), P4);
# }
```

---
Operator `sqrt`. Expands to `Sqrt`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(sqrt(U9)), U3);
# }
```

---
Operator `abs`. Expands to `AbsVal`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(abs(N2)), P2);
# }
```

---
Operator `cube`. Expands to `Cube`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(cube(P2)), P8);
# }
```

---
Operator `pow`. Expands to `Exp`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(pow(P2, P3)), P8);
# }
```

---
Operator `min`. Expands to `Minimum`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(min(P2, P3)), P2);
# }
```

---
Operator `max`. Expands to `Maximum`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(max(P2, P3)), P3);
# }
```

---
Operator `log2`. Expands to `Log2`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(log2(U9)), U3);
# }
```

---
Operator `gcd`. Expands to `Gcf`.

```rust
# #[macro_use] extern crate typenum;
# use typenum::*;
# fn main() {
assert_type_eq!(op!(gcd(U9, U21)), U3);
# }
```

*/
#[macro_export(local_inner_macros)]
macro_rules! op {
    ($($tail:tt)*) => ( __op_internal__!($($tail)*) );
}

    #[doc(hidden)]
    #[macro_export(local_inner_macros)]
    macro_rules! __op_internal__ {

(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cmp $($tail:tt)*) => (
    __op_internal__!(@stack[Compare, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqr $($tail:tt)*) => (
    __op_internal__!(@stack[Square, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqrt $($tail:tt)*) => (
    __op_internal__!(@stack[Sqrt, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: abs $($tail:tt)*) => (
    __op_internal__!(@stack[AbsVal, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cube $($tail:tt)*) => (
    __op_internal__!(@stack[Cube, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: pow $($tail:tt)*) => (
    __op_internal__!(@stack[Exp, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: min $($tail:tt)*) => (
    __op_internal__!(@stack[Minimum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: max $($tail:tt)*) => (
    __op_internal__!(@stack[Maximum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: log2 $($tail:tt)*) => (
    __op_internal__!(@stack[Log2, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: gcd $($tail:tt)*) => (
    __op_internal__!(@stack[Gcf, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) => (
    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: , $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: * $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: * $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: * $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) => (
    __op_internal__!(@stack[Prod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: / $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: / $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: / $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) => (
    __op_internal__!(@stack[Quot, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: % $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: % $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: % $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) => (
    __op_internal__!(@stack[Mod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: + $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: + $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: + $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: + $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: + $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) => (
    __op_internal__!(@stack[Sum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: - $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: - $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: - $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: - $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: - $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) => (
    __op_internal__!(@stack[Diff, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: << $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: << $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: << $($tail:tt)*) => (
    __op_internal__!(@stack[Shleft, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: >> $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >> $($tail:tt)*) => (
    __op_internal__!(@stack[Shright, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: & $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: & $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: & $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: & $($tail:tt)*) => (
    __op_internal__!(@stack[And, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: ^ $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) => (
    __op_internal__!(@stack[Xor, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: | $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: | $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: | $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) => (
    __op_internal__!(@stack[Or, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: == $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: == $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: == $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: == $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: == $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: == $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) => (
    __op_internal__!(@stack[Eq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: != $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: != $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: != $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: != $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: != $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: != $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) => (
    __op_internal__!(@stack[NotEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: <= $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: <= $($tail:tt)*) => (
    __op_internal__!(@stack[LeEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: >= $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: >= $($tail:tt)*) => (
    __op_internal__!(@stack[GrEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: < $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: < $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: < $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: < $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: < $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: < $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: < $($tail:tt)*) => (
    __op_internal__!(@stack[Le, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: > $($tail)*)
);
(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: > $($tail)*)
);
(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: > $($tail)*)
);
(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: > $($tail)*)
);
(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: > $($tail)*)
);
(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: > $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: > $($tail:tt)*) => (
    __op_internal__!(@stack[Gr, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ( $($stuff:tt)* ) $($tail:tt)* )
 => (
    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*]
                     @tail: $($stuff)* RParen $($tail)*)
);
(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*) => (
    __op_internal__!(@rp3 @stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*)
 => (
    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: RParen $($tail)*)
);
(@rp3 @stack[Compare, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Compare, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Square, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Square, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Sqrt, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Sqrt, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[AbsVal, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[AbsVal, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Cube, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Cube, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Exp, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Exp, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Minimum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Minimum, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Maximum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Maximum, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Log2, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Log2, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[Gcf, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[Gcf, $($queue,)*] @tail: $($tail)*)
);
(@rp3 @stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)
);
(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $num:ident $($tail:tt)*) => (
    __op_internal__!(@stack[$($stack,)*] @queue[$num, $($queue,)*] @tail: $($tail)*)
);
(@stack[] @queue[$($queue:ident,)*] @tail: ) => (
    __op_internal__!(@reverse[] @input: $($queue,)*)
);
(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail:) => (
    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: )
);
(@reverse[$($revved:ident,)*] @input: $head:ident, $($tail:ident,)* ) => (
    __op_internal__!(@reverse[$head, $($revved,)*] @input: $($tail,)*)
);
(@reverse[$($revved:ident,)*] @input: ) => (
    __op_internal__!(@eval @stack[] @input[$($revved,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Prod, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Prod<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Quot, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Quot<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Mod, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Mod<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Sum, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Sum<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Diff, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Diff<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shleft, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Shleft<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shright, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Shright<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[And, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::And<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Xor, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Xor<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Or, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Or<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Eq, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Eq<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[NotEq, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::NotEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[LeEq, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::LeEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[GrEq, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::GrEq<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Le, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Le<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gr, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Gr<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Compare, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Compare<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Exp, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Exp<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Minimum, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Minimum<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Maximum, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Maximum<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gcf, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Gcf<$b, $a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $($stack:ty,)*] @input[Square, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Square<$a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $($stack:ty,)*] @input[Sqrt, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Sqrt<$a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $($stack:ty,)*] @input[AbsVal, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::AbsVal<$a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $($stack:ty,)*] @input[Cube, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Cube<$a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$a:ty, $($stack:ty,)*] @input[Log2, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$crate::Log2<$a>, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$($stack:ty,)*] @input[$head:ident, $($tail:ident,)*]) => (
    __op_internal__!(@eval @stack[$head, $($stack,)*] @input[$($tail,)*])
);
(@eval @stack[$stack:ty,] @input[]) => (
    $stack
);
($($tail:tt)* ) => (
    __op_internal__!(@stack[] @queue[] @tail: $($tail)*)
);
}
'''
'''--- contract/target/debug/build/typenum-ae266bb20c1c0bd6/out/tests.rs ---

extern crate typenum;

use std::ops::*;
use std::cmp::Ordering;
use typenum::*;

#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitOrU0 = <<A as BitOr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitOrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitXorU0 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitXorU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU0 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU0 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0AddU0 = <<A as Add<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0AddU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MaxU0 = <<A as Max<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MaxU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0GcdU0 = <<A as Gcd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0GcdU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Sub_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0SubU0 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0SubU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_0() {
    type A = UTerm;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_0() {
    type A = UTerm;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_0() {
    type A = UTerm;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U0CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU0 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0BitXorU1 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0BitXorU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU1 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0AddU1 = <<A as Add<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0AddU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU1 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U0GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU1 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Div_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0DivU1 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0DivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Rem_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_PartialDiv_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PartialDivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PowU1 = <<A as Pow<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PowU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_1() {
    type A = UTerm;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U0CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U0BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0BitXorU2 = <<A as BitXor<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U0BitXorU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU2 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0AddU2 = <<A as Add<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U0AddU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU2 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U0MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U0GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU2 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Div_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Rem_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_PartialDiv_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PartialDivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PowU2 = <<A as Pow<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PowU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_2() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U0CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U0BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0BitXorU3 = <<A as BitXor<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U0BitXorU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU3 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0AddU3 = <<A as Add<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U0AddU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU3 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U0MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U0GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU3 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Div_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Rem_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_PartialDiv_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PartialDivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PowU3 = <<A as Pow<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PowU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_3() {
    type A = UTerm;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U0CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U0BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0BitXorU4 = <<A as BitXor<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U0BitXorU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU4 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0AddU4 = <<A as Add<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U0AddU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU4 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U0MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U0GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU4 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Div_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Rem_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_PartialDiv_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PartialDivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PowU4 = <<A as Pow<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PowU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_4() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U0CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitAnd_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitOr_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U0BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_BitXor_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0BitXorU5 = <<A as BitXor<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U0BitXorU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shl_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShlU5 = <<A as Shl<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShlU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Shr_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Add_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0AddU5 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U0AddU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Min_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MinU5 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MinU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Max_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U0MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Gcd_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U0GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Mul_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0MulU5 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0MulU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Div_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Rem_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_PartialDiv_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PartialDivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Pow_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U0PowU5 = <<A as Pow<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U0PowU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_0_Cmp_5() {
    type A = UTerm;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U0CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U0CmpU5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU0 = <<A as BitOr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitOrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitXorU0 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitXorU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1ShlU0 = <<A as Shl<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1ShlU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1ShrU0 = <<A as Shr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1ShrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1AddU0 = <<A as Add<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1AddU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MaxU0 = <<A as Max<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MaxU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU0 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Sub_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1SubU0 = <<A as Sub<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1SubU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_0() {
    type A = UInt<UTerm, B1>;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U1CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1BitXorU1 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1BitXorU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1ShlU1 = <<A as Shl<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U1ShlU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1AddU1 = <<A as Add<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U1AddU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Sub_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1SubU1 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1SubU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MulU1 = <<A as Mul<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MulU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Div_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1DivU1 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1DivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Rem_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_PartialDiv_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PartialDivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU1 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_1() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU1 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitXorU2 = <<A as BitXor<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1BitXorU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1ShlU2 = <<A as Shl<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U1ShlU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1AddU2 = <<A as Add<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1AddU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MinU2 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MinU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U1MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1MulU2 = <<A as Mul<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U1MulU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Div_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Rem_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU2 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_2() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1BitXorU3 = <<A as BitXor<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U1BitXorU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1ShlU3 = <<A as Shl<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U1ShlU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1AddU3 = <<A as Add<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U1AddU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MinU3 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MinU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1MulU3 = <<A as Mul<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U1MulU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Div_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Rem_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU3 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_3() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U1CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitXorU4 = <<A as BitXor<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1BitXorU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1ShlU4 = <<A as Shl<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U1ShlU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1AddU4 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1AddU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MinU4 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MinU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U1MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1MulU4 = <<A as Mul<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U1MulU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Div_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Rem_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU4 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_4() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitAnd_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitOr_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_BitXor_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1BitXorU5 = <<A as BitXor<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U1BitXorU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shl_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U1ShlU5 = <<A as Shl<B>>::Output as Same<U32>>::Output;

    assert_eq!(<U1ShlU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Shr_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Add_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U1AddU5 = <<A as Add<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U1AddU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Min_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1MinU5 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1MinU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Max_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Gcd_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Mul_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1MulU5 = <<A as Mul<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U1MulU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Div_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U1DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U1DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Rem_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1RemU5 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1RemU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Pow_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U1PowU5 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U1PowU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_1_Cmp_5() {
    type A = UInt<UTerm, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U1CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U1CmpU5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitOrU0 = <<A as BitOr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2BitOrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitXorU0 = <<A as BitXor<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2BitXorU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU0 = <<A as Shl<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2ShlU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShrU0 = <<A as Shr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2ShrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2AddU0 = <<A as Add<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2AddU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MaxU0 = <<A as Max<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MaxU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2GcdU0 = <<A as Gcd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2GcdU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Sub_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2SubU0 = <<A as Sub<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2SubU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_0() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U2CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U2BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2BitXorU1 = <<A as BitXor<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U2BitXorU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU1 = <<A as Shl<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U2ShlU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2AddU1 = <<A as Add<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U2AddU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MaxU1 = <<A as Max<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MaxU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Sub_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2SubU1 = <<A as Sub<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2SubU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MulU1 = <<A as Mul<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MulU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Div_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2DivU1 = <<A as Div<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2DivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Rem_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_PartialDiv_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2PartialDivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2PowU1 = <<A as Pow<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2PowU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_1() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2BitXorU2 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2BitXorU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU2 = <<A as Shl<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U2ShlU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2AddU2 = <<A as Add<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U2AddU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Sub_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2SubU2 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2SubU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2MulU2 = <<A as Mul<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U2MulU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Div_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Rem_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_PartialDiv_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2PartialDivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2PowU2 = <<A as Pow<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U2PowU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_2() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU2 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitAndU3 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2BitAndU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U2BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2BitXorU3 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2BitXorU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU3 = <<A as Shl<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U2ShlU3 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U2AddU3 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U2AddU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MinU3 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MinU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U2MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MulU3 = <<A as Mul<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U2MulU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Div_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Rem_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2PowU3 = <<A as Pow<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U2PowU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_3() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitOrU4 = <<A as BitOr<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U2BitOrU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2BitXorU4 = <<A as BitXor<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U2BitXorU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU4 = <<A as Shl<B>>::Output as Same<U32>>::Output;

    assert_eq!(<U2ShlU4 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2AddU4 = <<A as Add<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U2AddU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MinU4 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MinU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U2MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2GcdU4 = <<A as Gcd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2GcdU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2MulU4 = <<A as Mul<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U2MulU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Div_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Rem_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2RemU4 = <<A as Rem<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2RemU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2PowU4 = <<A as Pow<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U2PowU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_4() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitAnd_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitOr_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U2BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_BitXor_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2BitXorU5 = <<A as BitXor<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U2BitXorU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shl_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2ShlU5 = <<A as Shl<B>>::Output as Same<U64>>::Output;

    assert_eq!(<U2ShlU5 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Shr_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Add_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U2AddU5 = <<A as Add<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U2AddU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Min_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MinU5 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2MinU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Max_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U2MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U2MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Gcd_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U2GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U2GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Mul_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2MulU5 = <<A as Mul<B>>::Output as Same<U10>>::Output;

    assert_eq!(<U2MulU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Div_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U2DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U2DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Rem_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U2RemU5 = <<A as Rem<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U2RemU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Pow_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U2PowU5 = <<A as Pow<B>>::Output as Same<U32>>::Output;

    assert_eq!(<U2PowU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_2_Cmp_5() {
    type A = UInt<UInt<UTerm, B1>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U2CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U2CmpU5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU0 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitOrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitXorU0 = <<A as BitXor<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitXorU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3ShlU0 = <<A as Shl<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3ShlU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3ShrU0 = <<A as Shr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3ShrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3AddU0 = <<A as Add<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3AddU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MaxU0 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MaxU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU0 = <<A as Gcd<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3GcdU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Sub_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3SubU0 = <<A as Sub<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3SubU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_0() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U3CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3BitXorU1 = <<A as BitXor<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U3BitXorU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3ShlU1 = <<A as Shl<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U3ShlU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3AddU1 = <<A as Add<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U3AddU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MaxU1 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MaxU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Sub_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3SubU1 = <<A as Sub<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U3SubU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MulU1 = <<A as Mul<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MulU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Div_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3DivU1 = <<A as Div<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3DivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Rem_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_PartialDiv_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3PartialDivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU1 = <<A as Pow<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3PowU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_1() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U3BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3BitXorU2 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3BitXorU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3ShlU2 = <<A as Shl<B>>::Output as Same<U12>>::Output;

    assert_eq!(<U3ShlU2 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3AddU2 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U3AddU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U3MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MaxU2 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MaxU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Sub_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3SubU2 = <<A as Sub<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3SubU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3MulU2 = <<A as Mul<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U3MulU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Div_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Rem_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU2 = <<A as Pow<B>>::Output as Same<U9>>::Output;

    assert_eq!(<U3PowU2 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_2() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitAndU3 = <<A as BitAnd<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitAndU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3BitXorU3 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3BitXorU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3ShlU3 = <<A as Shl<B>>::Output as Same<U24>>::Output;

    assert_eq!(<U3ShlU3 as Unsigned>::to_u64(), <U24 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3AddU3 = <<A as Add<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U3AddU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Sub_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3SubU3 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3SubU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3MulU3 = <<A as Mul<B>>::Output as Same<U9>>::Output;

    assert_eq!(<U3MulU3 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Div_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Rem_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_PartialDiv_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3PartialDivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU3 = <<A as Pow<B>>::Output as Same<U27>>::Output;

    assert_eq!(<U3PowU3 as Unsigned>::to_u64(), <U27 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_3() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU3 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU4 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U3BitOrU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitXorU4 = <<A as BitXor<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U3BitXorU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3ShlU4 = <<A as Shl<B>>::Output as Same<U48>>::Output;

    assert_eq!(<U3ShlU4 as Unsigned>::to_u64(), <U48 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3AddU4 = <<A as Add<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U3AddU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MinU4 = <<A as Min<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MinU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U3MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3MulU4 = <<A as Mul<B>>::Output as Same<U12>>::Output;

    assert_eq!(<U3MulU4 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Div_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Rem_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3RemU4 = <<A as Rem<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3RemU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU4 = <<A as Pow<B>>::Output as Same<U81>>::Output;

    assert_eq!(<U3PowU4 as Unsigned>::to_u64(), <U81 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_4() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitAnd_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitOr_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U3BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_BitXor_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U3BitXorU5 = <<A as BitXor<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U3BitXorU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shl_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3ShlU5 = <<A as Shl<B>>::Output as Same<U96>>::Output;

    assert_eq!(<U3ShlU5 as Unsigned>::to_u64(), <U96 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Shr_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Add_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U3AddU5 = <<A as Add<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U3AddU5 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Min_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MinU5 = <<A as Min<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3MinU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Max_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U3MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Gcd_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U3GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U3GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Mul_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3MulU5 = <<A as Mul<B>>::Output as Same<U15>>::Output;

    assert_eq!(<U3MulU5 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Div_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U3DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U3DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Rem_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3RemU5 = <<A as Rem<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U3RemU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Pow_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U3PowU5 = <<A as Pow<B>>::Output as Same<U243>>::Output;

    assert_eq!(<U3PowU5 as Unsigned>::to_u64(), <U243 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_3_Cmp_5() {
    type A = UInt<UInt<UTerm, B1>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U3CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U3CmpU5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitOrU0 = <<A as BitOr<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4BitOrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitXorU0 = <<A as BitXor<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4BitXorU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU0 = <<A as Shl<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4ShlU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShrU0 = <<A as Shr<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4ShrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4AddU0 = <<A as Add<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4AddU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MaxU0 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MaxU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4GcdU0 = <<A as Gcd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4GcdU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Sub_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4SubU0 = <<A as Sub<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4SubU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U4CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U4BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4BitXorU1 = <<A as BitXor<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U4BitXorU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU1 = <<A as Shl<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U4ShlU1 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4AddU1 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U4AddU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MaxU1 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MaxU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Sub_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4SubU1 = <<A as Sub<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U4SubU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MulU1 = <<A as Mul<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MulU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Div_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4DivU1 = <<A as Div<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4DivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Rem_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_PartialDiv_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4PartialDivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PowU1 = <<A as Pow<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4PowU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitOrU2 = <<A as BitOr<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U4BitOrU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitXorU2 = <<A as BitXor<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U4BitXorU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU2 = <<A as Shl<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U4ShlU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4AddU2 = <<A as Add<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U4AddU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MaxU2 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MaxU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Sub_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4SubU2 = <<A as Sub<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4SubU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MulU2 = <<A as Mul<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U4MulU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Div_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Rem_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_PartialDiv_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U4PartialDivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PowU2 = <<A as Pow<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U4PowU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U4CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U4BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4BitXorU3 = <<A as BitXor<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U4BitXorU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU3 = <<A as Shl<B>>::Output as Same<U32>>::Output;

    assert_eq!(<U4ShlU3 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4AddU3 = <<A as Add<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U4AddU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U4MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MaxU3 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MaxU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Sub_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4SubU3 = <<A as Sub<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4SubU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MulU3 = <<A as Mul<B>>::Output as Same<U12>>::Output;

    assert_eq!(<U4MulU3 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Div_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Rem_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PowU3 = <<A as Pow<B>>::Output as Same<U64>>::Output;

    assert_eq!(<U4PowU3 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U4CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4BitXorU4 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4BitXorU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU4 = <<A as Shl<B>>::Output as Same<U64>>::Output;

    assert_eq!(<U4ShlU4 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4AddU4 = <<A as Add<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U4AddU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Sub_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4SubU4 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4SubU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MulU4 = <<A as Mul<B>>::Output as Same<U16>>::Output;

    assert_eq!(<U4MulU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Div_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Rem_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_PartialDiv_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4PartialDivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PowU4 = <<A as Pow<B>>::Output as Same<U256>>::Output;

    assert_eq!(<U4PowU4 as Unsigned>::to_u64(), <U256 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU4 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitAnd_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4BitAndU5 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4BitAndU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitOr_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U4BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_BitXor_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4BitXorU5 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4BitXorU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shl_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4ShlU5 = <<A as Shl<B>>::Output as Same<U128>>::Output;

    assert_eq!(<U4ShlU5 as Unsigned>::to_u64(), <U128 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Shr_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Add_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4AddU5 = <<A as Add<B>>::Output as Same<U9>>::Output;

    assert_eq!(<U4AddU5 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Min_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MinU5 = <<A as Min<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4MinU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Max_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U4MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Gcd_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U4GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U4GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Mul_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4MulU5 = <<A as Mul<B>>::Output as Same<U20>>::Output;

    assert_eq!(<U4MulU5 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Div_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U4DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U4DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Rem_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4RemU5 = <<A as Rem<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U4RemU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Pow_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U4PowU5 = <<A as Pow<B>>::Output as Same<U1024>>::Output;

    assert_eq!(<U4PowU5 as Unsigned>::to_u64(), <U1024 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_4_Cmp_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U4CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U4CmpU5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU0 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitOrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitXorU0 = <<A as BitXor<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitXorU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5ShlU0 = <<A as Shl<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5ShlU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5ShrU0 = <<A as Shr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5ShrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5AddU0 = <<A as Add<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5AddU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU0 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU0 = <<A as Gcd<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5GcdU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5SubU0 = <<A as Sub<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5SubU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_0() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UTerm;

    #[allow(non_camel_case_types)]
    type U5CmpU0 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5BitXorU1 = <<A as BitXor<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U5BitXorU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShlU1 = <<A as Shl<B>>::Output as Same<U10>>::Output;

    assert_eq!(<U5ShlU1 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U5ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5AddU1 = <<A as Add<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U5AddU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU1 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5SubU1 = <<A as Sub<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U5SubU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MulU1 = <<A as Mul<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MulU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Div_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5DivU1 = <<A as Div<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5DivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Rem_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_PartialDiv_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5PartialDivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU1 = <<A as Pow<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5PowU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_1() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5CmpU1 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU2 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U5BitOrU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitXorU2 = <<A as BitXor<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U5BitXorU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShlU2 = <<A as Shl<B>>::Output as Same<U20>>::Output;

    assert_eq!(<U5ShlU2 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5AddU2 = <<A as Add<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U5AddU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U5MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU2 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5SubU2 = <<A as Sub<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U5SubU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5MulU2 = <<A as Mul<B>>::Output as Same<U10>>::Output;

    assert_eq!(<U5MulU2 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Div_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U5DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Rem_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;
    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU2 = <<A as Pow<B>>::Output as Same<U25>>::Output;

    assert_eq!(<U5PowU2 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_2() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5CmpU2 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;

    assert_eq!(<U5BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5BitXorU3 = <<A as BitXor<B>>::Output as Same<U6>>::Output;

    assert_eq!(<U5BitXorU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShlU3 = <<A as Shl<B>>::Output as Same<U40>>::Output;

    assert_eq!(<U5ShlU3 as Unsigned>::to_u64(), <U40 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5AddU3 = <<A as Add<B>>::Output as Same<U8>>::Output;

    assert_eq!(<U5AddU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U3 = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;

    assert_eq!(<U5MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU3 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5SubU3 = <<A as Sub<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U5SubU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5MulU3 = <<A as Mul<B>>::Output as Same<U15>>::Output;

    assert_eq!(<U5MulU3 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Div_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Rem_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U2 = UInt<UInt<UTerm, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;

    assert_eq!(<U5RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;
    type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU3 = <<A as Pow<B>>::Output as Same<U125>>::Output;

    assert_eq!(<U5PowU3 as Unsigned>::to_u64(), <U125 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_3() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UTerm, B1>, B1>;

    #[allow(non_camel_case_types)]
    type U5CmpU3 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U5BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5BitXorU4 = <<A as BitXor<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5BitXorU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShlU4 = <<A as Shl<B>>::Output as Same<U80>>::Output;

    assert_eq!(<U5ShlU4 as Unsigned>::to_u64(), <U80 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5AddU4 = <<A as Add<B>>::Output as Same<U9>>::Output;

    assert_eq!(<U5AddU4 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;

    assert_eq!(<U5MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU4 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5SubU4 = <<A as Sub<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5SubU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5MulU4 = <<A as Mul<B>>::Output as Same<U20>>::Output;

    assert_eq!(<U5MulU4 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Div_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Rem_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;
    type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU4 = <<A as Pow<B>>::Output as Same<U625>>::Output;

    assert_eq!(<U5PowU4 as Unsigned>::to_u64(), <U625 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_4() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5CmpU4 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitAnd_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitAndU5 = <<A as BitAnd<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitAndU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitOr_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_BitXor_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5BitXorU5 = <<A as BitXor<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5BitXorU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shl_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;

    #[allow(non_camel_case_types)]
    type U5ShlU5 = <<A as Shl<B>>::Output as Same<U160>>::Output;

    assert_eq!(<U5ShlU5 as Unsigned>::to_u64(), <U160 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Shr_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Add_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;

    #[allow(non_camel_case_types)]
    type U5AddU5 = <<A as Add<B>>::Output as Same<U10>>::Output;

    assert_eq!(<U5AddU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Min_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MinU5 = <<A as Min<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MinU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Max_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Gcd_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;

    assert_eq!(<U5GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Sub_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5SubU5 = <<A as Sub<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5SubU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Mul_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5MulU5 = <<A as Mul<B>>::Output as Same<U25>>::Output;

    assert_eq!(<U5MulU5 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Div_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5DivU5 = <<A as Div<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5DivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Rem_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U0 = UTerm;

    #[allow(non_camel_case_types)]
    type U5RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;

    assert_eq!(<U5RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_PartialDiv_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U1 = UInt<UTerm, B1>;

    #[allow(non_camel_case_types)]
    type U5PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;

    assert_eq!(<U5PartialDivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Pow_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type U3125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5PowU5 = <<A as Pow<B>>::Output as Same<U3125>>::Output;

    assert_eq!(<U5PowU5 as Unsigned>::to_u64(), <U3125 as Unsigned>::to_u64());
}
#[test]
#[allow(non_snake_case)]
fn test_5_Cmp_5() {
    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;
    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;

    #[allow(non_camel_case_types)]
    type U5CmpU5 = <A as Cmp<B>>::Output;
    assert_eq!(<U5CmpU5 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5AddN5 = <<A as Add<B>>::Output as Same<N10>>::Output;

    assert_eq!(<N5AddN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5SubN5 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5SubN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulN5 = <<A as Mul<B>>::Output as Same<P25>>::Output;

    assert_eq!(<N5MulN5 as Integer>::to_i64(), <P25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxN5 = <<A as Max<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MaxN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivN5 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5DivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_PartialDiv_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5PartialDivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpN5 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5AddN4 = <<A as Add<B>>::Output as Same<N9>>::Output;

    assert_eq!(<N5AddN4 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5SubN4 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5SubN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MulN4 = <<A as Mul<B>>::Output as Same<P20>>::Output;

    assert_eq!(<N5MulN4 as Integer>::to_i64(), <P20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinN4 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N5MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpN4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5AddN3 = <<A as Add<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N5AddN3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5SubN3 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5SubN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulN3 = <<A as Mul<B>>::Output as Same<P15>>::Output;

    assert_eq!(<N5MulN3 as Integer>::to_i64(), <P15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinN3 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N5MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpN3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5AddN2 = <<A as Add<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N5AddN2 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5SubN2 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N5SubN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MulN2 = <<A as Mul<B>>::Output as Same<P10>>::Output;

    assert_eq!(<N5MulN2 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinN2 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N5DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpN2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5AddN1 = <<A as Add<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N5AddN1 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5SubN1 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N5SubN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulN1 = <<A as Mul<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5MulN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinN1 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivN1 = <<A as Div<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5DivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_PartialDiv_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5PartialDivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpN1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5Add_0 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5Add_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5Sub_0 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5Sub_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5Min_0 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5Min_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type N5Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<N5Cmp_0 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5AddP1 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N5AddP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5SubP1 = <<A as Sub<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N5SubP1 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulP1 = <<A as Mul<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MulP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinP1 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivP1 = <<A as Div<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5DivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_PartialDiv_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5PartialDivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PowP1 = <<A as Pow<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5PowP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5AddP2 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N5AddP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5SubP2 = <<A as Sub<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N5SubP2 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MulP2 = <<A as Mul<B>>::Output as Same<N10>>::Output;

    assert_eq!(<N5MulP2 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinP2 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N5MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;

    assert_eq!(<N5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5AddP3 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5AddP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5SubP3 = <<A as Sub<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N5SubP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulP3 = <<A as Mul<B>>::Output as Same<N15>>::Output;

    assert_eq!(<N5MulP3 as Integer>::to_i64(), <N15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinP3 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N5MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N5RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PowP3 = <<A as Pow<B>>::Output as Same<N125>>::Output;

    assert_eq!(<N5PowP3 as Integer>::to_i64(), <N125 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5AddP4 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5AddP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5SubP4 = <<A as Sub<B>>::Output as Same<N9>>::Output;

    assert_eq!(<N5SubP4 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MulP4 = <<A as Mul<B>>::Output as Same<N20>>::Output;

    assert_eq!(<N5MulP4 as Integer>::to_i64(), <N20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinP4 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N5MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;

    assert_eq!(<N5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N5CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Add_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5AddP5 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5AddP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Sub_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N5SubP5 = <<A as Sub<B>>::Output as Same<N10>>::Output;

    assert_eq!(<N5SubP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Mul_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MulP5 = <<A as Mul<B>>::Output as Same<N25>>::Output;

    assert_eq!(<N5MulP5 as Integer>::to_i64(), <N25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Min_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MinP5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N5MinP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Max_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Gcd_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Div_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5DivP5 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5DivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Rem_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_PartialDiv_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N5PartialDivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Pow_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5PowP5 = <<A as Pow<B>>::Output as Same<N3125>>::Output;

    assert_eq!(<N5PowP5 as Integer>::to_i64(), <N3125 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Cmp_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N5CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<N5CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddN5 = <<A as Add<B>>::Output as Same<N9>>::Output;

    assert_eq!(<N4AddN5 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubN5 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4SubN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulN5 = <<A as Mul<B>>::Output as Same<P20>>::Output;

    assert_eq!(<N4MulN5 as Integer>::to_i64(), <P20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MaxN5 = <<A as Max<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MaxN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4RemN5 = <<A as Rem<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4RemN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_N5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4AddN4 = <<A as Add<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N4AddN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4SubN4 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4SubN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulN4 = <<A as Mul<B>>::Output as Same<P16>>::Output;

    assert_eq!(<N4MulN4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4PartialDivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_N4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpN4 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddN3 = <<A as Add<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N4AddN3 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubN3 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4SubN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulN3 = <<A as Mul<B>>::Output as Same<P12>>::Output;

    assert_eq!(<N4MulN3 as Integer>::to_i64(), <P12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinN3 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N4MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_N3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpN3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4AddN2 = <<A as Add<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N4AddN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4SubN2 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N4SubN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulN2 = <<A as Mul<B>>::Output as Same<P8>>::Output;

    assert_eq!(<N4MulN2 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinN2 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N4MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N4DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N4PartialDivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_N2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpN2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddN1 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N4AddN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubN1 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N4SubN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulN1 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4MulN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinN1 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4DivN1 = <<A as Div<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4DivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4PartialDivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_N1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpN1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4Add_0 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4Add_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4Sub_0 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4Sub_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4Min_0 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4Min_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp__0() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type N4Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<N4Cmp_0 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddP1 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N4AddP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubP1 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N4SubP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulP1 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MulP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinP1 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4DivP1 = <<A as Div<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4DivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4PartialDivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PowP1 = <<A as Pow<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4PowP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_P1() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4AddP2 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N4AddP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4SubP2 = <<A as Sub<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N4SubP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulP2 = <<A as Mul<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N4MulP2 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinP2 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N4MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N4DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N4PartialDivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;

    assert_eq!(<N4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_P2() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N4CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddP3 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4AddP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubP3 = <<A as Sub<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N4SubP3 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulP3 = <<A as Mul<B>>::Output as Same<N12>>::Output;

    assert_eq!(<N4MulP3 as Integer>::to_i64(), <N12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinP3 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N4MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N64 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PowP3 = <<A as Pow<B>>::Output as Same<N64>>::Output;

    assert_eq!(<N4PowP3 as Integer>::to_i64(), <N64 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_P3() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4AddP4 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4AddP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4SubP4 = <<A as Sub<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N4SubP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulP4 = <<A as Mul<B>>::Output as Same<N16>>::Output;

    assert_eq!(<N4MulP4 as Integer>::to_i64(), <N16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinP4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_PartialDiv_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N4PartialDivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;

    assert_eq!(<N4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_P4() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Add_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4AddP5 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4AddP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Sub_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4SubP5 = <<A as Sub<B>>::Output as Same<N9>>::Output;

    assert_eq!(<N4SubP5 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Mul_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MulP5 = <<A as Mul<B>>::Output as Same<N20>>::Output;

    assert_eq!(<N4MulP5 as Integer>::to_i64(), <N20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Min_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4MinP5 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4MinP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Max_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Gcd_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Div_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Rem_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4RemP5 = <<A as Rem<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N4RemP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Pow_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1024 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N4PowP5 = <<A as Pow<B>>::Output as Same<N1024>>::Output;

    assert_eq!(<N4PowP5 as Integer>::to_i64(), <N1024 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Cmp_P5() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N4CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<N4CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3AddN5 = <<A as Add<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N3AddN5 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3SubN5 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N3SubN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulN5 = <<A as Mul<B>>::Output as Same<P15>>::Output;

    assert_eq!(<N3MulN5 as Integer>::to_i64(), <P15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxN5 = <<A as Max<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MaxN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemN5 = <<A as Rem<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3RemN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3AddN4 = <<A as Add<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N3AddN4 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3SubN4 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3SubN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MulN4 = <<A as Mul<B>>::Output as Same<P12>>::Output;

    assert_eq!(<N3MulN4 as Integer>::to_i64(), <P12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxN4 = <<A as Max<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MaxN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemN4 = <<A as Rem<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3RemN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3AddN3 = <<A as Add<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N3AddN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3SubN3 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3SubN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulN3 = <<A as Mul<B>>::Output as Same<P9>>::Output;

    assert_eq!(<N3MulN3 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_PartialDiv_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3PartialDivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpN3 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3AddN2 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N3AddN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3SubN2 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3SubN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MulN2 = <<A as Mul<B>>::Output as Same<P6>>::Output;

    assert_eq!(<N3MulN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinN2 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N3MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpN2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3AddN1 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N3AddN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3SubN1 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N3SubN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulN1 = <<A as Mul<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3MulN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinN1 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivN1 = <<A as Div<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3DivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_PartialDiv_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3PartialDivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpN1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3Add_0 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3Add_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3Sub_0 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3Sub_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3Min_0 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3Min_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type N3Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<N3Cmp_0 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3AddP1 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N3AddP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3SubP1 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N3SubP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulP1 = <<A as Mul<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MulP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinP1 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivP1 = <<A as Div<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3DivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_PartialDiv_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3PartialDivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PowP1 = <<A as Pow<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3PowP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3AddP2 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3AddP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3SubP2 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N3SubP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MulP2 = <<A as Mul<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N3MulP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinP2 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N3MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;

    assert_eq!(<N3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3AddP3 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3AddP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3SubP3 = <<A as Sub<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N3SubP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulP3 = <<A as Mul<B>>::Output as Same<N9>>::Output;

    assert_eq!(<N3MulP3 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinP3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_PartialDiv_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N3PartialDivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N27 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PowP3 = <<A as Pow<B>>::Output as Same<N27>>::Output;

    assert_eq!(<N3PowP3 as Integer>::to_i64(), <N27 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3AddP4 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3AddP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3SubP4 = <<A as Sub<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N3SubP4 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MulP4 = <<A as Mul<B>>::Output as Same<N12>>::Output;

    assert_eq!(<N3MulP4 as Integer>::to_i64(), <N12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinP4 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemP4 = <<A as Rem<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3RemP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;

    assert_eq!(<N3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Add_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N3AddP5 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N3AddP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Sub_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N3SubP5 = <<A as Sub<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N3SubP5 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Mul_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MulP5 = <<A as Mul<B>>::Output as Same<N15>>::Output;

    assert_eq!(<N3MulP5 as Integer>::to_i64(), <N15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Min_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MinP5 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3MinP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Max_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Gcd_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Div_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Rem_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3RemP5 = <<A as Rem<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N3RemP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Pow_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N243 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N3PowP5 = <<A as Pow<B>>::Output as Same<N243>>::Output;

    assert_eq!(<N3PowP5 as Integer>::to_i64(), <N243 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Cmp_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N3CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<N3CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddN5 = <<A as Add<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N2AddN5 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubN5 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N2SubN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulN5 = <<A as Mul<B>>::Output as Same<P10>>::Output;

    assert_eq!(<N2MulN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxN5 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MaxN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemN5 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_N5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2AddN4 = <<A as Add<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N2AddN4 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2SubN4 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2SubN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulN4 = <<A as Mul<B>>::Output as Same<P8>>::Output;

    assert_eq!(<N2MulN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxN4 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MaxN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemN4 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_N4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddN3 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N2AddN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubN3 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2SubN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulN3 = <<A as Mul<B>>::Output as Same<P6>>::Output;

    assert_eq!(<N2MulN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxN3 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MaxN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_N3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2AddN2 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N2AddN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2SubN2 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2SubN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulN2 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N2MulN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_PartialDiv_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2PartialDivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_N2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpN2 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddN1 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N2AddN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubN1 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N2SubN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulN1 = <<A as Mul<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2MulN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinN1 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N2MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2DivN1 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2DivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_PartialDiv_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2PartialDivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_N1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpN1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2Add_0 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2Add_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2Sub_0 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2Sub_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2Min_0 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2Min_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp__0() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type N2Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<N2Cmp_0 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddP1 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N2AddP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubP1 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N2SubP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulP1 = <<A as Mul<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MulP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinP1 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2DivP1 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2DivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_PartialDiv_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2PartialDivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PowP1 = <<A as Pow<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2PowP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_P1() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2AddP2 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2AddP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2SubP2 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N2SubP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulP2 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N2MulP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinP2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N2DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_PartialDiv_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N2PartialDivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_P2() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddP3 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2AddP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubP3 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N2SubP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulP3 = <<A as Mul<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N2MulP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinP3 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PowP3 = <<A as Pow<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N2PowP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_P3() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2AddP4 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2AddP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2SubP4 = <<A as Sub<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N2SubP4 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulP4 = <<A as Mul<B>>::Output as Same<N8>>::Output;

    assert_eq!(<N2MulP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinP4 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemP4 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;

    assert_eq!(<N2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_P4() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Add_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2AddP5 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N2AddP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Sub_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N2SubP5 = <<A as Sub<B>>::Output as Same<N7>>::Output;

    assert_eq!(<N2SubP5 as Integer>::to_i64(), <N7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Mul_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MulP5 = <<A as Mul<B>>::Output as Same<N10>>::Output;

    assert_eq!(<N2MulP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Min_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2MinP5 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2MinP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Max_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Gcd_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Div_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Rem_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N2RemP5 = <<A as Rem<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N2RemP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Pow_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N32 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N2PowP5 = <<A as Pow<B>>::Output as Same<N32>>::Output;

    assert_eq!(<N2PowP5 as Integer>::to_i64(), <N32 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Cmp_P5() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N2CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<N2CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1AddN5 = <<A as Add<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N1AddN5 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1SubN5 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N1SubN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulN5 = <<A as Mul<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N1MulN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxN5 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MaxN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemN5 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowN5 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_N5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1AddN4 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N1AddN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1SubN4 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N1SubN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MulN4 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N1MulN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxN4 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MaxN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_N4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1AddN3 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N1AddN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1SubN3 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N1SubN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulN3 = <<A as Mul<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N1MulN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxN3 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MaxN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowN3 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_N3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1AddN2 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N1AddN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1SubN2 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1SubN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MulN2 = <<A as Mul<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N1MulN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxN2 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MaxN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_N2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1AddN1 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N1AddN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1SubN1 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1SubN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulN1 = <<A as Mul<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1MulN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1DivN1 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1DivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_PartialDiv_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1PartialDivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowN1 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_N1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpN1 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1Add_0 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1Add_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1Sub_0 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1Sub_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1Min_0 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1Min_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp__0() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type N1Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<N1Cmp_0 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1AddP1 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1AddP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1SubP1 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N1SubP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulP1 = <<A as Mul<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MulP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinP1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1DivP1 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1DivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_PartialDiv_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PartialDivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowP1 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_P1() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1AddP2 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1AddP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1SubP2 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N1SubP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MulP2 = <<A as Mul<B>>::Output as Same<N2>>::Output;

    assert_eq!(<N1MulP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinP2 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_P2() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1AddP3 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<N1AddP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1SubP3 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N1SubP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulP3 = <<A as Mul<B>>::Output as Same<N3>>::Output;

    assert_eq!(<N1MulP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinP3 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowP3 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_P3() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type N1AddP4 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<N1AddP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1SubP4 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N1SubP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MulP4 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<N1MulP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinP4 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_P4() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Add_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type N1AddP5 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<N1AddP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Sub_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type N1SubP5 = <<A as Sub<B>>::Output as Same<N6>>::Output;

    assert_eq!(<N1SubP5 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Mul_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MulP5 = <<A as Mul<B>>::Output as Same<N5>>::Output;

    assert_eq!(<N1MulP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Min_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1MinP5 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1MinP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Max_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<N1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Gcd_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<N1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Div_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type N1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<N1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Rem_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1RemP5 = <<A as Rem<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1RemP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Pow_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type N1PowP5 = <<A as Pow<B>>::Output as Same<N1>>::Output;

    assert_eq!(<N1PowP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Cmp_P5() {
    type A = NInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type N1CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<N1CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddN5 = <<A as Add<B>>::Output as Same<N5>>::Output;

    assert_eq!(<_0AddN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubN5 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<_0SubN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulN5 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<_0MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MaxN5 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MaxN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<_0GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_N5() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0AddN4 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<_0AddN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0SubN4 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<_0SubN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulN4 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<_0MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MaxN4 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MaxN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<_0GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_N4() {
    type A = Z0;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddN3 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<_0AddN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubN3 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<_0SubN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulN3 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<_0MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MaxN3 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MaxN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<_0GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_N3() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0AddN2 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<_0AddN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0SubN2 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<_0SubN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulN2 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<_0MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MaxN2 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MaxN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<_0GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_N2() {
    type A = Z0;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddN1 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<_0AddN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubN1 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0SubN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulN1 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<_0MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MaxN1 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MaxN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivN1 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_N1() {
    type A = Z0;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Add_0 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Add_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Sub_0 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Sub_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd__0() {
    type A = Z0;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0Gcd_0 = <<A as Gcd<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0Gcd_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow__0() {
    type A = Z0;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp__0() {
    type A = Z0;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type _0Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<_0Cmp_0 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddP1 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0AddP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubP1 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<_0SubP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulP1 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MinP1 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MinP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<_0GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivP1 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PowP1 = <<A as Pow<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PowP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_P1() {
    type A = Z0;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpP1 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0AddP2 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<_0AddP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0SubP2 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<_0SubP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulP2 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MinP2 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MinP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<_0MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<_0GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PowP2 = <<A as Pow<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PowP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_P2() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type _0CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddP3 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<_0AddP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubP3 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<_0SubP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulP3 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MinP3 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MinP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<_0MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<_0GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PowP3 = <<A as Pow<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PowP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_P3() {
    type A = Z0;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0AddP4 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<_0AddP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0SubP4 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<_0SubP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulP4 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MinP4 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MinP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<_0MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<_0GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PowP4 = <<A as Pow<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PowP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_P4() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type _0CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test__0_Add_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0AddP5 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<_0AddP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Sub_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0SubP5 = <<A as Sub<B>>::Output as Same<N5>>::Output;

    assert_eq!(<_0SubP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Mul_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MulP5 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MulP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Min_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0MinP5 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0MinP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Max_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<_0MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Gcd_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<_0GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Div_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Rem_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_PartialDiv_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PartialDivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Pow_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type _0PowP5 = <<A as Pow<B>>::Output as Same<_0>>::Output;

    assert_eq!(<_0PowP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Cmp_P5() {
    type A = Z0;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type _0CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<_0CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1AddN5 = <<A as Add<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P1AddN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1SubN5 = <<A as Sub<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P1SubN5 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulN5 = <<A as Mul<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P1MulN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxN5 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemN5 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowN5 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_N5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1AddN4 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P1AddN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1SubN4 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P1SubN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MulN4 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P1MulN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxN4 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_N4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1AddN3 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P1AddN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1SubN3 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P1SubN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulN3 = <<A as Mul<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P1MulN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxN3 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowN3 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_N3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1AddN2 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1AddN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1SubN2 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P1SubN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MulN2 = <<A as Mul<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P1MulN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxN2 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_N2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1AddN1 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1AddN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1SubN1 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P1SubN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulN1 = <<A as Mul<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1MulN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxN1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1DivN1 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1DivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_PartialDiv_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1PartialDivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowN1 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_N1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1Add_0 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1Add_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1Sub_0 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1Sub_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1Max_0 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1Max_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp__0() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type P1Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<P1Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1AddP1 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P1AddP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1SubP1 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1SubP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulP1 = <<A as Mul<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MulP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1DivP1 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1DivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_PartialDiv_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PartialDivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowP1 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_P1() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpP1 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1AddP2 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P1AddP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1SubP2 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P1SubP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MulP2 = <<A as Mul<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P1MulP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinP2 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MinP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_P2() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpP2 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1AddP3 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P1AddP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1SubP3 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P1SubP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulP3 = <<A as Mul<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P1MulP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinP3 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MinP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowP3 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_P3() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1AddP4 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P1AddP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P1SubP4 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P1SubP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MulP4 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P1MulP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinP4 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MinP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_P4() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Add_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P1AddP5 = <<A as Add<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P1AddP5 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Sub_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P1SubP5 = <<A as Sub<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P1SubP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Mul_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MulP5 = <<A as Mul<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P1MulP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Min_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1MinP5 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1MinP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Max_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Gcd_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Div_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Rem_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1RemP5 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1RemP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Pow_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P1PowP5 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P1PowP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Cmp_P5() {
    type A = PInt<UInt<UTerm, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P1CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<P1CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddN5 = <<A as Add<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P2AddN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubN5 = <<A as Sub<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P2SubN5 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulN5 = <<A as Mul<B>>::Output as Same<N10>>::Output;

    assert_eq!(<P2MulN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxN5 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemN5 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2AddN4 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2AddN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2SubN4 = <<A as Sub<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P2SubN4 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulN4 = <<A as Mul<B>>::Output as Same<N8>>::Output;

    assert_eq!(<P2MulN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxN4 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemN4 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddN3 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P2AddN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubN3 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P2SubN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulN3 = <<A as Mul<B>>::Output as Same<N6>>::Output;

    assert_eq!(<P2MulN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxN3 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2AddN2 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2AddN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2SubN2 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P2SubN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulN2 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P2MulN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxN2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P2DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_PartialDiv_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P2PartialDivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddN1 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2AddN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubN1 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P2SubN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulN1 = <<A as Mul<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2MulN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P2MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxN1 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2DivN1 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2DivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_PartialDiv_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2PartialDivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2Add_0 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2Add_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2Sub_0 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2Sub_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2Max_0 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2Max_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type P2Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<P2Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddP1 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P2AddP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubP1 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2SubP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulP1 = <<A as Mul<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MulP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxP1 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2DivP1 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2DivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_PartialDiv_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2PartialDivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PowP1 = <<A as Pow<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2PowP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpP1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2AddP2 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P2AddP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2SubP2 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2SubP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulP2 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P2MulP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_PartialDiv_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2PartialDivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpP2 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddP3 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P2AddP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubP3 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P2SubP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulP3 = <<A as Mul<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P2MulP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinP3 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MinP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PowP3 = <<A as Pow<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P2PowP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpP3 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2AddP4 = <<A as Add<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P2AddP4 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2SubP4 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P2SubP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulP4 = <<A as Mul<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P2MulP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinP4 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MinP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemP4 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;

    assert_eq!(<P2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Add_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2AddP5 = <<A as Add<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P2AddP5 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Sub_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P2SubP5 = <<A as Sub<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P2SubP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Mul_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MulP5 = <<A as Mul<B>>::Output as Same<P10>>::Output;

    assert_eq!(<P2MulP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Min_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2MinP5 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2MinP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Max_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Gcd_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Div_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Rem_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P2RemP5 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P2RemP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Pow_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P32 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P2PowP5 = <<A as Pow<B>>::Output as Same<P32>>::Output;

    assert_eq!(<P2PowP5 as Integer>::to_i64(), <P32 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Cmp_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P2CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<P2CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3AddN5 = <<A as Add<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P3AddN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3SubN5 = <<A as Sub<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P3SubN5 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulN5 = <<A as Mul<B>>::Output as Same<N15>>::Output;

    assert_eq!(<P3MulN5 as Integer>::to_i64(), <N15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxN5 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemN5 = <<A as Rem<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3RemN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3AddN4 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3AddN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3SubN4 = <<A as Sub<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P3SubN4 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MulN4 = <<A as Mul<B>>::Output as Same<N12>>::Output;

    assert_eq!(<P3MulN4 as Integer>::to_i64(), <N12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxN4 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemN4 = <<A as Rem<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3RemN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_N4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3AddN3 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3AddN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3SubN3 = <<A as Sub<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P3SubN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulN3 = <<A as Mul<B>>::Output as Same<N9>>::Output;

    assert_eq!(<P3MulN3 as Integer>::to_i64(), <N9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxN3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_PartialDiv_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3PartialDivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_N3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3AddN2 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3AddN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3SubN2 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P3SubN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MulN2 = <<A as Mul<B>>::Output as Same<N6>>::Output;

    assert_eq!(<P3MulN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P3MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxN2 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_N2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3AddN1 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P3AddN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3SubN1 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P3SubN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulN1 = <<A as Mul<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P3MulN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxN1 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivN1 = <<A as Div<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P3DivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_PartialDiv_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P3PartialDivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_N1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3Add_0 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3Add_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3Sub_0 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3Sub_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3Max_0 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3Max_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp__0() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type P3Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<P3Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3AddP1 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P3AddP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3SubP1 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P3SubP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulP1 = <<A as Mul<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MulP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxP1 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivP1 = <<A as Div<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3DivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_PartialDiv_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3PartialDivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PowP1 = <<A as Pow<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3PowP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_P1() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpP1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3AddP2 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P3AddP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3SubP2 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3SubP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MulP2 = <<A as Mul<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P3MulP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P3MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxP2 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_P2() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpP2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3AddP3 = <<A as Add<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P3AddP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3SubP3 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3SubP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulP3 = <<A as Mul<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P3MulP3 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_PartialDiv_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3PartialDivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P27 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PowP3 = <<A as Pow<B>>::Output as Same<P27>>::Output;

    assert_eq!(<P3PowP3 as Integer>::to_i64(), <P27 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_P3() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpP3 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3AddP4 = <<A as Add<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P3AddP4 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3SubP4 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P3SubP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MulP4 = <<A as Mul<B>>::Output as Same<P12>>::Output;

    assert_eq!(<P3MulP4 as Integer>::to_i64(), <P12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinP4 = <<A as Min<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MinP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemP4 = <<A as Rem<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3RemP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;

    assert_eq!(<P3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_P4() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpP4 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Add_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P3AddP5 = <<A as Add<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P3AddP5 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Sub_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P3SubP5 = <<A as Sub<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P3SubP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Mul_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MulP5 = <<A as Mul<B>>::Output as Same<P15>>::Output;

    assert_eq!(<P3MulP5 as Integer>::to_i64(), <P15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Min_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MinP5 = <<A as Min<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3MinP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Max_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Gcd_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Div_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Rem_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3RemP5 = <<A as Rem<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P3RemP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Pow_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P243 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P3PowP5 = <<A as Pow<B>>::Output as Same<P243>>::Output;

    assert_eq!(<P3PowP5 as Integer>::to_i64(), <P243 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Cmp_P5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddN5 = <<A as Add<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4AddN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubN5 = <<A as Sub<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P4SubN5 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulN5 = <<A as Mul<B>>::Output as Same<N20>>::Output;

    assert_eq!(<P4MulN5 as Integer>::to_i64(), <N20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxN5 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4RemN5 = <<A as Rem<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4RemN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4AddN4 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4AddN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4SubN4 = <<A as Sub<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P4SubN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulN4 = <<A as Mul<B>>::Output as Same<N16>>::Output;

    assert_eq!(<P4MulN4 as Integer>::to_i64(), <N16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxN4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4PartialDivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddN3 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4AddN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubN3 = <<A as Sub<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P4SubN3 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulN3 = <<A as Mul<B>>::Output as Same<N12>>::Output;

    assert_eq!(<P4MulN3 as Integer>::to_i64(), <N12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P4MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxN3 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4AddN2 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4AddN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4SubN2 = <<A as Sub<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P4SubN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulN2 = <<A as Mul<B>>::Output as Same<N8>>::Output;

    assert_eq!(<P4MulN2 as Integer>::to_i64(), <N8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P4MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxN2 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P4DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P4PartialDivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddN1 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P4AddN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubN1 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P4SubN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulN1 = <<A as Mul<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P4MulN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxN1 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4DivN1 = <<A as Div<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P4DivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P4PartialDivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4Add_0 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4Add_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4Sub_0 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4Sub_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4Max_0 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4Max_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type P4Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<P4Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddP1 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P4AddP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubP1 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P4SubP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulP1 = <<A as Mul<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MulP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxP1 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4DivP1 = <<A as Div<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4DivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4PartialDivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PowP1 = <<A as Pow<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4PowP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpP1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4AddP2 = <<A as Add<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P4AddP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4SubP2 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4SubP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulP2 = <<A as Mul<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P4MulP2 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxP2 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P4PartialDivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;

    assert_eq!(<P4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P4CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpP2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddP3 = <<A as Add<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P4AddP3 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubP3 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4SubP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulP3 = <<A as Mul<B>>::Output as Same<P12>>::Output;

    assert_eq!(<P4MulP3 as Integer>::to_i64(), <P12 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P4MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxP3 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P64 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PowP3 = <<A as Pow<B>>::Output as Same<P64>>::Output;

    assert_eq!(<P4PowP3 as Integer>::to_i64(), <P64 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpP3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4AddP4 = <<A as Add<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P4AddP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4SubP4 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4SubP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulP4 = <<A as Mul<B>>::Output as Same<P16>>::Output;

    assert_eq!(<P4MulP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_PartialDiv_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4PartialDivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;

    assert_eq!(<P4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpP4 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Add_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4AddP5 = <<A as Add<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P4AddP5 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Sub_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4SubP5 = <<A as Sub<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P4SubP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Mul_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MulP5 = <<A as Mul<B>>::Output as Same<P20>>::Output;

    assert_eq!(<P4MulP5 as Integer>::to_i64(), <P20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Min_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4MinP5 = <<A as Min<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4MinP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Max_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Gcd_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Div_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Rem_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4RemP5 = <<A as Rem<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P4RemP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Pow_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1024 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P4PowP5 = <<A as Pow<B>>::Output as Same<P1024>>::Output;

    assert_eq!(<P4PowP5 as Integer>::to_i64(), <P1024 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Cmp_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P4CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<P4CmpP5 as Ord>::to_ordering(), Ordering::Less);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5AddN5 = <<A as Add<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5AddN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5SubN5 = <<A as Sub<B>>::Output as Same<P10>>::Output;

    assert_eq!(<P5SubN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulN5 = <<A as Mul<B>>::Output as Same<N25>>::Output;

    assert_eq!(<P5MulN5 as Integer>::to_i64(), <N25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxN5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivN5 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P5DivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_PartialDiv_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P5PartialDivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_N5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5AddN4 = <<A as Add<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5AddN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5SubN4 = <<A as Sub<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P5SubN4 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MulN4 = <<A as Mul<B>>::Output as Same<N20>>::Output;

    assert_eq!(<P5MulN4 as Integer>::to_i64(), <N20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;

    assert_eq!(<P5MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxN4 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P5DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_N4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5CmpN4 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpN4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5AddN3 = <<A as Add<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5AddN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5SubN3 = <<A as Sub<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P5SubN3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulN3 = <<A as Mul<B>>::Output as Same<N15>>::Output;

    assert_eq!(<P5MulN3 as Integer>::to_i64(), <N15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;

    assert_eq!(<P5MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxN3 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P5DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_N3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpN3 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpN3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5AddN2 = <<A as Add<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P5AddN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5SubN2 = <<A as Sub<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P5SubN2 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MulN2 = <<A as Mul<B>>::Output as Same<N10>>::Output;

    assert_eq!(<P5MulN2 as Integer>::to_i64(), <N10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P5MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxN2 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;

    assert_eq!(<P5DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_N2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5CmpN2 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpN2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5AddN1 = <<A as Add<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P5AddN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5SubN1 = <<A as Sub<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P5SubN1 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulN1 = <<A as Mul<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P5MulN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;

    assert_eq!(<P5MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxN1 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivN1 = <<A as Div<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P5DivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_PartialDiv_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;

    assert_eq!(<P5PartialDivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_N1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpN1 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpN1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5Add_0 = <<A as Add<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5Add_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5Sub_0 = <<A as Sub<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5Sub_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5Max_0 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5Max_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp__0() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = Z0;

    #[allow(non_camel_case_types)]
    type P5Cmp_0 = <A as Cmp<B>>::Output;
    assert_eq!(<P5Cmp_0 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5AddP1 = <<A as Add<B>>::Output as Same<P6>>::Output;

    assert_eq!(<P5AddP1 as Integer>::to_i64(), <P6 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5SubP1 = <<A as Sub<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P5SubP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulP1 = <<A as Mul<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MulP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxP1 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivP1 = <<A as Div<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5DivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_PartialDiv_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5PartialDivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PowP1 = <<A as Pow<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5PowP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_P1() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpP1 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpP1 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5AddP2 = <<A as Add<B>>::Output as Same<P7>>::Output;

    assert_eq!(<P5AddP2 as Integer>::to_i64(), <P7 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5SubP2 = <<A as Sub<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P5SubP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MulP2 = <<A as Mul<B>>::Output as Same<P10>>::Output;

    assert_eq!(<P5MulP2 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxP2 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;

    assert_eq!(<P5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_P2() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5CmpP2 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpP2 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5AddP3 = <<A as Add<B>>::Output as Same<P8>>::Output;

    assert_eq!(<P5AddP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5SubP3 = <<A as Sub<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5SubP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulP3 = <<A as Mul<B>>::Output as Same<P15>>::Output;

    assert_eq!(<P5MulP3 as Integer>::to_i64(), <P15 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;

    assert_eq!(<P5MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxP3 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;

    assert_eq!(<P5RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PowP3 = <<A as Pow<B>>::Output as Same<P125>>::Output;

    assert_eq!(<P5PowP3 as Integer>::to_i64(), <P125 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_P3() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpP3 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpP3 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5AddP4 = <<A as Add<B>>::Output as Same<P9>>::Output;

    assert_eq!(<P5AddP4 as Integer>::to_i64(), <P9 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5SubP4 = <<A as Sub<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5SubP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MulP4 = <<A as Mul<B>>::Output as Same<P20>>::Output;

    assert_eq!(<P5MulP4 as Integer>::to_i64(), <P20 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;

    assert_eq!(<P5MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxP4 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;

    assert_eq!(<P5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_P4() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type P5CmpP4 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpP4 as Ord>::to_ordering(), Ordering::Greater);
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Add_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type P5AddP5 = <<A as Add<B>>::Output as Same<P10>>::Output;

    assert_eq!(<P5AddP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Sub_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5SubP5 = <<A as Sub<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5SubP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Mul_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MulP5 = <<A as Mul<B>>::Output as Same<P25>>::Output;

    assert_eq!(<P5MulP5 as Integer>::to_i64(), <P25 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Min_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MinP5 = <<A as Min<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MinP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Max_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Gcd_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;

    assert_eq!(<P5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Div_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5DivP5 = <<A as Div<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5DivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Rem_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type P5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;

    assert_eq!(<P5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_PartialDiv_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type P5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;

    assert_eq!(<P5PartialDivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Pow_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P3125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5PowP5 = <<A as Pow<B>>::Output as Same<P3125>>::Output;

    assert_eq!(<P5PowP5 as Integer>::to_i64(), <P3125 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Cmp_P5() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P5CmpP5 = <A as Cmp<B>>::Output;
    assert_eq!(<P5CmpP5 as Ord>::to_ordering(), Ordering::Equal);
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Neg() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type NegN5 = <<A as Neg>::Output as Same<P5>>::Output;
    assert_eq!(<NegN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N5_Abs() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type AbsN5 = <<A as Abs>::Output as Same<P5>>::Output;
    assert_eq!(<AbsN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Neg() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type NegN4 = <<A as Neg>::Output as Same<P4>>::Output;
    assert_eq!(<NegN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N4_Abs() {
    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type AbsN4 = <<A as Abs>::Output as Same<P4>>::Output;
    assert_eq!(<AbsN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Neg() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type NegN3 = <<A as Neg>::Output as Same<P3>>::Output;
    assert_eq!(<NegN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N3_Abs() {
    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type AbsN3 = <<A as Abs>::Output as Same<P3>>::Output;
    assert_eq!(<AbsN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Neg() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type NegN2 = <<A as Neg>::Output as Same<P2>>::Output;
    assert_eq!(<NegN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N2_Abs() {
    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type AbsN2 = <<A as Abs>::Output as Same<P2>>::Output;
    assert_eq!(<AbsN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Neg() {
    type A = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type NegN1 = <<A as Neg>::Output as Same<P1>>::Output;
    assert_eq!(<NegN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_N1_Abs() {
    type A = NInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type AbsN1 = <<A as Abs>::Output as Same<P1>>::Output;
    assert_eq!(<AbsN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Neg() {
    type A = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type Neg_0 = <<A as Neg>::Output as Same<_0>>::Output;
    assert_eq!(<Neg_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test__0_Abs() {
    type A = Z0;
    type _0 = Z0;

    #[allow(non_camel_case_types)]
    type Abs_0 = <<A as Abs>::Output as Same<_0>>::Output;
    assert_eq!(<Abs_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Neg() {
    type A = PInt<UInt<UTerm, B1>>;
    type N1 = NInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type NegP1 = <<A as Neg>::Output as Same<N1>>::Output;
    assert_eq!(<NegP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P1_Abs() {
    type A = PInt<UInt<UTerm, B1>>;
    type P1 = PInt<UInt<UTerm, B1>>;

    #[allow(non_camel_case_types)]
    type AbsP1 = <<A as Abs>::Output as Same<P1>>::Output;
    assert_eq!(<AbsP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Neg() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type NegP2 = <<A as Neg>::Output as Same<N2>>::Output;
    assert_eq!(<NegP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P2_Abs() {
    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;
    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;

    #[allow(non_camel_case_types)]
    type AbsP2 = <<A as Abs>::Output as Same<P2>>::Output;
    assert_eq!(<AbsP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Neg() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type NegP3 = <<A as Neg>::Output as Same<N3>>::Output;
    assert_eq!(<NegP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P3_Abs() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;

    #[allow(non_camel_case_types)]
    type AbsP3 = <<A as Abs>::Output as Same<P3>>::Output;
    assert_eq!(<AbsP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Neg() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type NegP4 = <<A as Neg>::Output as Same<N4>>::Output;
    assert_eq!(<NegP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P4_Abs() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;
    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;

    #[allow(non_camel_case_types)]
    type AbsP4 = <<A as Abs>::Output as Same<P4>>::Output;
    assert_eq!(<AbsP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Neg() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type NegP5 = <<A as Neg>::Output as Same<N5>>::Output;
    assert_eq!(<NegP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());
}
#[test]
#[allow(non_snake_case)]
fn test_P5_Abs() {
    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type AbsP5 = <<A as Abs>::Output as Same<P5>>::Output;
    assert_eq!(<AbsP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());
}
'''
'''--- contract/target/debug/build/wee_alloc-e8ba7f89fb28bf35/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- contract/target/release/.fingerprint/Inflector-9f6c5eb6607cae38/lib-inflector.json ---
{"rustc":15699327122048238920,"features":"[]","target":894124792023433695,"profile":13031817089607207246,"path":11122834297798179470,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/Inflector-9f6c5eb6607cae38/dep-lib-inflector"}}],"rustflags":[],"metadata":6849597462678386541,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/ahash-0b2ae90c84309e83/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":2297296889237502566,"profile":13031817089607207246,"path":7447198088260506862,"deps":[[16079472387499994964,"version_check",false,11298230445682978351]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/ahash-0b2ae90c84309e83/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":6548036084630991988,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/borsh-derive-c636fc05e86bd331/lib-borsh-derive.json ---
{"rustc":15699327122048238920,"features":"[]","target":14484299583844374162,"profile":13031817089607207246,"path":11450951485296481208,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[2345288959107110519,"borsh_schema_derive_internal",false,10911586976927730958],[3971538142687143787,"proc_macro_crate",false,9775195993640435166],[8324001644593655249,"borsh_derive_internal",false,16004433150068754778],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/borsh-derive-c636fc05e86bd331/dep-lib-borsh-derive"}}],"rustflags":[],"metadata":6341613096556135379,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/borsh-derive-internal-4e901194e2ba0bba/lib-borsh-derive-internal.json ---
{"rustc":15699327122048238920,"features":"[]","target":9985232031898684131,"profile":13031817089607207246,"path":2594658786862283272,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/borsh-derive-internal-4e901194e2ba0bba/dep-lib-borsh-derive-internal"}}],"rustflags":[],"metadata":6341613096556135379,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/borsh-schema-derive-internal-6e58ef152f518a7e/lib-borsh-schema-derive-internal.json ---
{"rustc":15699327122048238920,"features":"[]","target":15664144342437137661,"profile":13031817089607207246,"path":6573703121797019932,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/borsh-schema-derive-internal-6e58ef152f518a7e/dep-lib-borsh-schema-derive-internal"}}],"rustflags":[],"metadata":7685215035480038221,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/near-sdk-macros-36f7ac81dfe28d3c/lib-near-sdk-macros.json ---
{"rustc":15699327122048238920,"features":"[\"abi\"]","target":16568417427542612,"profile":13031817089607207246,"path":9780430594623096928,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[7454270075138479745,"inflector",false,302047889374719252],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/near-sdk-macros-36f7ac81dfe28d3c/dep-lib-near-sdk-macros"}}],"rustflags":[],"metadata":9520434766592551999,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/proc-macro-crate-153af1958b43cd46/lib-proc-macro-crate.json ---
{"rustc":15699327122048238920,"features":"[]","target":7474588766210387923,"profile":13031817089607207246,"path":227868375118459675,"deps":[[6554997584025100622,"toml",false,5404258884699278781]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/proc-macro-crate-153af1958b43cd46/dep-lib-proc-macro-crate"}}],"rustflags":[],"metadata":4875023412952309093,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/proc-macro2-2f00336b091e545d/lib-proc-macro2.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":16714894217519287322,"profile":13031817089607207246,"path":11796634835171484160,"deps":[[2275467556785573469,"build_script_build",false,2689876653603142280],[10721203361745528474,"unicode_ident",false,9904802124996857092]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/proc-macro2-2f00336b091e545d/dep-lib-proc-macro2"}}],"rustflags":[],"metadata":7635439851376710101,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/proc-macro2-661a751eabc24d73/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":427768481117760528,"profile":13031817089607207246,"path":8992500073505163134,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/proc-macro2-661a751eabc24d73/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":7635439851376710101,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/proc-macro2-e9d6a1c6b1795f53/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[2275467556785573469,"build_script_build",false,13472373281186011710]],"local":[{"RerunIfChanged":{"output":"release/build/proc-macro2-e9d6a1c6b1795f53/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/quote-11fb4ae980dfa73d/lib-quote.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"proc-macro\"]","target":10824007166531090010,"profile":13031817089607207246,"path":13692805388911958044,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/quote-11fb4ae980dfa73d/dep-lib-quote"}}],"rustflags":[],"metadata":2717943770976187624,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/schemars-b49dd5ab1051bd0d/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"impl_json_schema\", \"schemars_derive\"]","target":2297296889237502566,"profile":13031817089607207246,"path":6992114467550045648,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/schemars-b49dd5ab1051bd0d/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11679674351051169359,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/schemars_derive-898655f545f5dba8/lib-schemars_derive.json ---
{"rustc":15699327122048238920,"features":"[]","target":6818468949020714808,"profile":13031817089607207246,"path":3640997363547260656,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[15472200400644609968,"serde_derive_internals",false,16360764499067960968],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/schemars_derive-898655f545f5dba8/dep-lib-schemars_derive"}}],"rustflags":[],"metadata":17573214762644668264,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/semver-36e396563abb5fd6/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":2297296889237502566,"profile":13031817089607207246,"path":9351936425294567869,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/semver-36e396563abb5fd6/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":7480721012031345649,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde-8b6b92464e4c218c/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":2297296889237502566,"profile":13031817089607207246,"path":2816091323965661388,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/serde-8b6b92464e4c218c/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde-9a6d2656cd2db639/lib-serde.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":12518487807107382959,"profile":13031817089607207246,"path":2059293589033131972,"deps":[[10264775547355706342,"serde_derive",false,5650470831744786995],[18260804926946925357,"build_script_build",false,17723702142701404786]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/serde-9a6d2656cd2db639/dep-lib-serde"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde-f8108f1aae9e5343/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[18260804926946925357,"build_script_build",false,86160398527588947]],"local":[{"RerunIfChanged":{"output":"release/build/serde-f8108f1aae9e5343/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde_derive-1a29582276a110be/lib-serde_derive.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":17975654915224872304,"profile":13031817089607207246,"path":4286166998206562974,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[15257104365642082152,"syn",false,14687335897492932585]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/serde_derive-1a29582276a110be/dep-lib-serde_derive"}}],"rustflags":[],"metadata":7087207080818960155,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde_derive_internals-36c60e952570c91e/lib-serde_derive_internals.json ---
{"rustc":15699327122048238920,"features":"[]","target":10801114250991275972,"profile":13031817089607207246,"path":7370719870937853850,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[17143850428905299221,"syn",false,7766552289257873598]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/serde_derive_internals-36c60e952570c91e/dep-lib-serde_derive_internals"}}],"rustflags":[],"metadata":7691849674774261228,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/serde_json-a1e906be9ffe71d9/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":427768481117760528,"profile":13031817089607207246,"path":12845853630429608721,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/serde_json-a1e906be9ffe71d9/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":16261601059619201932,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/syn-6a7536e097ee295c/lib-syn.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":9229941241798225847,"profile":13031817089607207246,"path":16345241445430471193,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[10721203361745528474,"unicode_ident",false,9904802124996857092]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/syn-6a7536e097ee295c/dep-lib-syn"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/syn-7d3f7ed4bf18893b/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[17143850428905299221,"build_script_build",false,5051322605755642067]],"local":[{"Precalculated":"1.0.109"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/syn-ab0a2b44f7694773/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":2297296889237502566,"profile":13031817089607207246,"path":16324885284038255013,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/syn-ab0a2b44f7694773/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/syn-f9066a0b9c7d520a/lib-syn.json ---
{"rustc":15699327122048238920,"features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"quote\", \"visit\"]","target":8516813339728780372,"profile":13031817089607207246,"path":11168288741992561292,"deps":[[2275467556785573469,"proc_macro2",false,11891690454271689958],[3475017103742128739,"quote",false,4260196510696032567],[10721203361745528474,"unicode_ident",false,9904802124996857092],[17143850428905299221,"build_script_build",false,2163133304861641819]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/syn-f9066a0b9c7d520a/dep-lib-syn"}}],"rustflags":[],"metadata":6886477143387768027,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/toml-b58a756847e11186/lib-toml.json ---
{"rustc":15699327122048238920,"features":"[\"default\"]","target":12757549743382924349,"profile":13031817089607207246,"path":12642978622691932116,"deps":[[18260804926946925357,"serde",false,5261520890768319149]],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/toml-b58a756847e11186/dep-lib-toml"}}],"rustflags":[],"metadata":13437692833141290973,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/unicode-ident-a1c028795e9f032c/lib-unicode-ident.json ---
{"rustc":15699327122048238920,"features":"[]","target":7243519288898877878,"profile":13031817089607207246,"path":5667461645529735126,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/unicode-ident-a1c028795e9f032c/dep-lib-unicode-ident"}}],"rustflags":[],"metadata":1159190378059262574,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/version_check-37bfa5ae93653f8b/lib-version_check.json ---
{"rustc":15699327122048238920,"features":"[]","target":1907215788979932987,"profile":13031817089607207246,"path":9409674391701698002,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/version_check-37bfa5ae93653f8b/dep-lib-version_check"}}],"rustflags":[],"metadata":14847206692933921638,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/release/.fingerprint/wee_alloc-bc9bb16427189535/build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"[]","target":8188216131759486267,"profile":13031817089607207246,"path":2340182334242780106,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"release/.fingerprint/wee_alloc-bc9bb16427189535/dep-build-script-build-script-build"}}],"rustflags":[],"metadata":11837593470300214873,"config":2202906307356721367,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/ahash-1c14633346178fe7/lib-ahash.json ---
{"rustc":15699327122048238920,"features":"[]","target":295758560010665018,"profile":9992919965254561576,"path":8421458435079503437,"deps":[[4424799446218848649,"once_cell",false,8817123884840651162],[6564554279330852038,"build_script_build",false,1552432112660851550]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/ahash-1c14633346178fe7/dep-lib-ahash"}}],"rustflags":[],"metadata":6548036084630991988,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/ahash-591cc009c06e7cf5/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[6564554279330852038,"build_script_build",false,10709453979684427829]],"local":[{"RerunIfChanged":{"output":"wasm32-unknown-unknown/release/build/ahash-591cc009c06e7cf5/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/base64-6bac46afbd1962fd/lib-base64.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":16778825523953873731,"profile":9992919965254561576,"path":4651863785387530832,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/base64-6bac46afbd1962fd/dep-lib-base64"}}],"rustflags":[],"metadata":13936919950537592407,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/borsh-b25ae22c3296dc12/lib-borsh.json ---
{"rustc":15699327122048238920,"features":"[\"const-generics\", \"default\", \"rc\", \"std\"]","target":5127993436019407528,"profile":9992919965254561576,"path":406704560459441769,"deps":[[1759060122986695407,"borsh_derive",false,9733935662537504984],[16284710795702459458,"hashbrown",false,9925008672128853798]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/borsh-b25ae22c3296dc12/dep-lib-borsh"}}],"rustflags":[],"metadata":7032358266178414993,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/bs58-0aef5dfa83ca8a80/lib-bs58.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"std\"]","target":18352831503079783019,"profile":9992919965254561576,"path":7315557794883744608,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/bs58-0aef5dfa83ca8a80/dep-lib-bs58"}}],"rustflags":[],"metadata":13637435404263704389,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/cfg-if-caba0a56c040732b/lib-cfg-if.json ---
{"rustc":15699327122048238920,"features":"[]","target":10623512480563079566,"profile":9992919965254561576,"path":8957231522740584638,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/cfg-if-caba0a56c040732b/dep-lib-cfg-if"}}],"rustflags":[],"metadata":8462187951337715540,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/dyn-clone-51e519c98ad7464c/lib-dyn-clone.json ---
{"rustc":15699327122048238920,"features":"[]","target":456433028138942822,"profile":9992919965254561576,"path":5197101175864803496,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/dyn-clone-51e519c98ad7464c/dep-lib-dyn-clone"}}],"rustflags":[],"metadata":10939357194659760099,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/hashbrown-49ddfa3f6d06f1fc/lib-hashbrown.json ---
{"rustc":15699327122048238920,"features":"[\"ahash\", \"default\", \"inline-more\"]","target":11240190406153278838,"profile":9992919965254561576,"path":12348266937490265093,"deps":[[6564554279330852038,"ahash",false,6770681844981131478]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/hashbrown-49ddfa3f6d06f1fc/dep-lib-hashbrown"}}],"rustflags":[],"metadata":6228333144549390726,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/itoa-c7a9e3fc3eac61d1/lib-itoa.json ---
{"rustc":15699327122048238920,"features":"[]","target":17114873591667335244,"profile":9992919965254561576,"path":12832357535484239742,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/itoa-c7a9e3fc3eac61d1/dep-lib-itoa"}}],"rustflags":[],"metadata":851671291587502216,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/memory_units-a5486a0e2d197f5a/lib-memory_units.json ---
{"rustc":15699327122048238920,"features":"[]","target":14318584593297629915,"profile":9992919965254561576,"path":9747641232677581986,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/memory_units-a5486a0e2d197f5a/dep-lib-memory_units"}}],"rustflags":[],"metadata":16366510313631463741,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/near-abi-a490f316d7a04638/lib-near-abi.json ---
{"rustc":15699327122048238920,"features":"[\"__chunked-entries\"]","target":3772619746852673170,"profile":9992919965254561576,"path":9976207718907102603,"deps":[[8370833984941964102,"semver",false,4874627383658595014],[13434381959712907675,"borsh",false,4817930643157118299],[13519362093482305381,"schemars",false,430949982370326763],[18260804926946925357,"serde",false,765842218601994920]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/near-abi-a490f316d7a04638/dep-lib-near-abi"}}],"rustflags":[],"metadata":2664010391987966176,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/near-sdk-b5609a6bfa947fd4/lib-near-sdk.json ---
{"rustc":15699327122048238920,"features":"[\"abi\", \"default\", \"legacy\", \"near-abi\", \"near-crypto\", \"near-primitives\", \"near-primitives-core\", \"near-vm-logic\", \"schemars\", \"unit-testing\", \"wee_alloc\"]","target":11925494537554991322,"profile":9992919965254561576,"path":12456458662647203773,"deps":[[2711478123133662383,"bs58",false,15692720209527218969],[2748724984193634118,"near_abi",false,6929049430449683963],[3178493835647231921,"wee_alloc",false,7807646707269092037],[4424799446218848649,"once_cell",false,8817123884840651162],[4790332501662844689,"base64",false,3872363816070778809],[5751920542139757056,"serde_json",false,445859062847552423],[9608617076544306583,"near_sys",false,16430564763582697982],[13195315199838120338,"near_sdk_macros",false,12315236993023258637],[13434381959712907675,"borsh",false,4817930643157118299],[13519362093482305381,"schemars",false,430949982370326763],[18260804926946925357,"serde",false,765842218601994920]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/near-sdk-b5609a6bfa947fd4/dep-lib-near-sdk"}}],"rustflags":[],"metadata":9215943102709044213,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/near-sys-ceeb9e0e6a6af79a/lib-near-sys.json ---
{"rustc":15699327122048238920,"features":"[]","target":4927594367761543910,"profile":9992919965254561576,"path":10750026643164942851,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/near-sys-ceeb9e0e6a6af79a/dep-lib-near-sys"}}],"rustflags":[],"metadata":14904885344401450229,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/nearcon-factory-contract-829ba4831a3a9531/lib-nearcon-factory-contract.json ---
{"rustc":15699327122048238920,"features":"[]","target":6817780012199052871,"profile":15694811749346577000,"path":17523903030608720598,"deps":[[5751920542139757056,"serde_json",false,445859062847552423],[14706394349651137205,"near_sdk",false,10349737805401645979]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/nearcon-factory-contract-829ba4831a3a9531/dep-lib-nearcon-factory-contract"}}],"rustflags":[],"metadata":9592253857461293192,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/once_cell-3e0d8eb85f9c424a/lib-once_cell.json ---
{"rustc":15699327122048238920,"features":"[\"alloc\", \"default\", \"race\", \"std\"]","target":14856186769647684053,"profile":9992919965254561576,"path":4383825698887745490,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/once_cell-3e0d8eb85f9c424a/dep-lib-once_cell"}}],"rustflags":[],"metadata":14177539708254521827,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/ryu-321680dd110e2fa6/lib-ryu.json ---
{"rustc":15699327122048238920,"features":"[]","target":13901881936739684103,"profile":9992919965254561576,"path":4867907593234663134,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/ryu-321680dd110e2fa6/dep-lib-ryu"}}],"rustflags":[],"metadata":10387617312689919117,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/schemars-de8dfce3726c8bc3/lib-schemars.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"impl_json_schema\", \"schemars_derive\"]","target":16218395617641602000,"profile":9992919965254561576,"path":14006680898418958582,"deps":[[538174865708573463,"dyn_clone",false,7061119908065254298],[5751920542139757056,"serde_json",false,445859062847552423],[13519362093482305381,"build_script_build",false,1471533944055583644],[13685478631301934036,"schemars_derive",false,12076896920122534568],[18260804926946925357,"serde",false,765842218601994920]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/schemars-de8dfce3726c8bc3/dep-lib-schemars"}}],"rustflags":[],"metadata":11679674351051169359,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/schemars-faefaebea69e0fbf/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[13519362093482305381,"build_script_build",false,7215703762343645481]],"local":[{"Precalculated":"0.8.12"}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/semver-6dc3e67d65107941/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[8370833984941964102,"build_script_build",false,13794140890149806330]],"local":[{"RerunIfChanged":{"output":"wasm32-unknown-unknown/release/build/semver-6dc3e67d65107941/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/semver-c4f891220617eb46/lib-semver.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1855717086744217893,"profile":9992919965254561576,"path":3905156107758913639,"deps":[[8370833984941964102,"build_script_build",false,12700835529792384580]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/semver-c4f891220617eb46/dep-lib-semver"}}],"rustflags":[],"metadata":7480721012031345649,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/serde-a7fbaf84d33ee300/lib-serde.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"derive\", \"rc\", \"serde_derive\", \"std\"]","target":12518487807107382959,"profile":9992919965254561576,"path":2059293589033131972,"deps":[[10264775547355706342,"serde_derive",false,5650470831744786995],[18260804926946925357,"build_script_build",false,4579777998524646666]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/serde-a7fbaf84d33ee300/dep-lib-serde"}}],"rustflags":[],"metadata":3767376778934503013,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/serde-d4a82b1095dfd93f/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[18260804926946925357,"build_script_build",false,86160398527588947]],"local":[{"RerunIfChanged":{"output":"wasm32-unknown-unknown/release/build/serde-d4a82b1095dfd93f/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/serde_json-ae90ee906564c6dc/lib-serde_json.json ---
{"rustc":15699327122048238920,"features":"[\"default\", \"std\"]","target":1572482250304784865,"profile":9992919965254561576,"path":2192819217601010030,"deps":[[5751920542139757056,"build_script_build",false,2843915678039805481],[10680519162924001902,"itoa",false,15609216080109672499],[12140443443804514189,"ryu",false,14391944597066588231],[18260804926946925357,"serde",false,765842218601994920]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/serde_json-ae90ee906564c6dc/dep-lib-serde_json"}}],"rustflags":[],"metadata":16261601059619201932,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/serde_json-fd6f09702787e79b/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[5751920542139757056,"build_script_build",false,10492339899099300980]],"local":[{"RerunIfChanged":{"output":"wasm32-unknown-unknown/release/build/serde_json-fd6f09702787e79b/output","paths":["build.rs"]}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/wee_alloc-b96209701010a280/lib-wee_alloc.json ---
{"rustc":15699327122048238920,"features":"[]","target":4386990340108308755,"profile":9992919965254561576,"path":6329283078616733185,"deps":[[1429323848562539564,"memory_units",false,16347292293735859490],[3178493835647231921,"build_script_build",false,16445488480135700036],[11311719388751911026,"cfg_if",false,15000438616874505293]],"local":[{"CheckDepInfo":{"dep_info":"wasm32-unknown-unknown/release/.fingerprint/wee_alloc-b96209701010a280/dep-lib-wee_alloc"}}],"rustflags":[],"metadata":11837593470300214873,"config":2202906307356721367,"compile_kind":8104632896995515128}
'''
'''--- contract/target/wasm32-unknown-unknown/release/.fingerprint/wee_alloc-c5dfd13fdbef16ac/run-build-script-build-script-build.json ---
{"rustc":15699327122048238920,"features":"","target":0,"profile":0,"path":0,"deps":[[3178493835647231921,"build_script_build",false,6762151548946192334]],"local":[{"RerunIfChanged":{"output":"wasm32-unknown-unknown/release/build/wee_alloc-c5dfd13fdbef16ac/output","paths":["./Cargo.toml","./build.rs","./src/lib.rs","./src/imp_static_array.rs"]}},{"RerunIfEnvChanged":{"var":"WEE_ALLOC_STATIC_ARRAY_BACKEND_BYTES","val":null}}],"rustflags":[],"metadata":0,"config":0,"compile_kind":0}
'''
'''--- contract/target/wasm32-unknown-unknown/release/build/wee_alloc-c5dfd13fdbef16ac/out/wee_alloc_static_array_backend_size_bytes.txt ---
33554432
'''
'''--- frontend/.prettierrc.js ---
module.exports = {
    trailingComma: 'es5',
    tabWidth: 4,
    semi: true,
    singleQuote: true,
};

'''
'''--- frontend/config-overrides.js ---
const webpack = require('webpack');

module.exports = function override(config) {
    const fallback = config.resolve.fallback || {};
    Object.assign(fallback, {
        crypto: require.resolve('crypto-browserify'),
        stream: require.resolve('stream-browserify'),
        assert: require.resolve('assert'),
        http: require.resolve('stream-http'),
        https: require.resolve('https-browserify'),
        os: require.resolve('os-browserify'),
        url: require.resolve('url'),
    });
    config.resolve.fallback = fallback;
    config.plugins = (config.plugins || []).concat([
        new webpack.ProvidePlugin({
            process: 'process/browser',
            Buffer: ['buffer', 'Buffer'],
        }),
    ]);
    return config;
};

'''
'''--- frontend/package.json ---
{
  "name": "aha-boilerplate",
  "version": "1.0.0",
  "description": "AHA Boilerplate for Frontend Development",
  "license": "MIT",
  "private": true,
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint .",
    "format": "prettier --write .",
    "predeploy": "npm run build",
    "deploy": "gh-pages -d build",
    "serve": "serve -s build"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.4.2",
    "@fortawesome/free-brands-svg-icons": "^6.4.2",
    "@fortawesome/react-fontawesome": "^0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.39.7",
    "react-router-dom": "^6.4.3",
    "react-scripts": "^5.0.1",
    "zustand": "^4.1.4"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.3",
    "@types/react": "^18.0.25",
    "@types/react-dom": "^18.0.9",
    "classnames": "^2.3.2",
    "eslint": "^8.0.1",
    "flowbite": "^1.5.4",
    "flowbite-react": "^0.3.5",
    "gh-pages": "^6.0.0",
    "husky": "^8.0.0",
    "jest": "^27.0.4",
    "prettier": "^2.8.0",
    "prettier-plugin-tailwindcss": "^0.2.0",
    "pretty-quick": "^3.1.3",
    "serve": "^14.2.1",
    "tailwindcss": "^3.2.4"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/postcss.config.js ---
module.exports = {
    plugins: {
        tailwindcss: {},
        autoprefixer: {},
    },
};

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap"
            rel="stylesheet"
        />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <meta
            name="description"
            content="Web site created using create-react-app"
        />
        <meta
            name="viewport"
            content="width=device-width, minimum-scale=1.0, maximum-scale = 1.0, user-scalable = no"
        />
        <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
        <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
        <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
        <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
        <title>React App</title>
    </head>
    <body>
        <noscript>You need to enable JavaScript to run this app.</noscript>
        <div id="root"></div>
        <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    --></body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
    "short_name": "React App",
    "name": "Create React App Sample",
    "icons": [
        {
            "src": "favicon.ico",
            "sizes": "64x64 32x32 24x24 16x16",
            "type": "image/x-icon"
        },
        {
            "src": "logo192.png",
            "type": "image/png",
            "sizes": "192x192"
        },
        {
            "src": "logo512.png",
            "type": "image/png",
            "sizes": "512x512"
        }
    ],
    "start_url": ".",
    "display": "standalone",
    "theme_color": "#000000",
    "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.js ---
import React from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import AppRoutes from './routes/routes';
import './index.css';

const App = () => {
  return (
    <Router>
      <AppRoutes />
    </Router>
  );
};

export default App;
'''
'''--- frontend/src/components/Footer/Footer.css ---
/* Footer.css */

/* Mobile Styles */
@media (max-width: 640px) {
    .footer-container {
        flex-direction: column;
        /* Stack elements vertically on small screens */
    }

    .footer-container a img {
        max-width: 200px;
        /* Limit the maximum width of the logo */
    }

    .footer-container .text-xs {
        text-align: center;
        /* Center-align the copyright text */
    }
}

/* Default Styles */
.footer {
    background-color: #333;
    color: #fff;
    padding: 20px;
}

/* Set opacity for the logo image */
.footer img {
    opacity: 0.7;
    /* Opacity set to 80% */
}

.footer-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 1200px;
    margin: 0 auto;
}

.footer-links {
    display: flex;
    gap: 20px;
}

.footer-links a {
    text-decoration: none;
    color: #fff;
    transition: color 0.3s;
}

.footer-links a:hover {
    color: #ff5733;
}
'''
'''--- frontend/src/components/Footer/index.ts ---
import Footer from './Footer';

export default Footer;
'''
'''--- frontend/src/components/LoadingModal/index.ts ---
import LoadingModal from './LoadingModal';

export default LoadingModal;

'''
'''--- frontend/src/components/MultipleChoice/index.ts ---
import MultipleChoice from './MultipleChoice';

export default MultipleChoice;
'''
'''--- frontend/src/components/Navbar/Navbar.css ---
/* Navbar.css */
.nav-link {
    position: relative;
    text-decoration: none;
}

.nav-link::before {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    border-bottom: 2px solid transparent;
    transition: border-color 300ms;
}

.nav-link:hover::before {
    border-color: #A51431;
    /* Dark red color on hover */
}

/* Custom hover effect for the Login button */
.login-button {
    text-decoration: none;
    display: inline-block;
    padding: 8px 20px;
    /* Adjust the padding as needed */
    border-radius: 30px;
    /* Use half of the desired height to create a capsule shape */
    background-color: rgba(207, 24, 24, 0.638);
    /* Opaque red */
    color: #fff;
    /* Text color */
    transition: background-color 0.3s;
    /* Smooth background color transition on hover */
}

.login-button:hover {
    background-color: #c51818;
    /* Darker red on hover */
    cursor: pointer;
}
'''
'''--- frontend/src/components/Navbar/index.ts ---
import Navbar from './Navbar';

export default Navbar;
'''
'''--- frontend/src/components/SquaresBG/index.ts ---
import SquaresBG from './SquaresBG';

export default SquaresBG;

'''
'''--- frontend/src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
    input[type='number']::-webkit-outer-spin-button,
    input[type='number']::-webkit-inner-spin-button,
    input[type='number'] {
        -webkit-appearance: none;
        margin: 0;
        -moz-appearance: textfield !important;
    }

    body {
        margin: 0;
        font-family: 'Lub Dub', -apple-system, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    code {
        font-family: 'Lub Dub', source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
    }
}

'''
'''--- frontend/src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- frontend/src/react-app-env.d.ts ---
/// <reference types="react-scripts" />

'''
'''--- frontend/src/routes/Error/index.ts ---
import Error from './Error';

export default Error;

'''
'''--- frontend/src/routes/Home/Home.css ---
/* Home.css */

/* Apply a gradient background */
.relative {
    background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),
                 center/cover no-repeat;
    height: 70vh;
    position: relative;
  }
  
  /* Style the title text */
  h1 {
    font-family: 'Lub Dub', sans-serif;
    font-size: 4rem;
    font-weight: bold;
    color: #A51431; /* Deep Red */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }
  
  /* Style the description text */
  p {
    font-size: 1.5rem;
    color: #FFF; /* White */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }
  
  /* Style the "Get Started" button */
  button {
    background-color: #A51431; /* Deep Red */
    color: #FFF; /* White */
    font-size: 1.25rem;
    padding: 1rem 2rem;
    border: none;
    border-radius: 0;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  
  button:hover {
    background-color: #950D28; /* Slightly darker shade of red */
  }
  
'''
'''--- frontend/src/routes/Home/index.ts ---
import Home from './Home';

export default Home;

'''
'''--- frontend/src/routes/Prizes/Gallery/PrizeGallery.css ---
/* PrizeGallery.css */

/* Gallery container */
.gallery-container {
    max-width: 70%;
    margin: 0 auto;
    text-align: center;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    /* Create three columns by default */
}

.gallery {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    /* Create three columns with spacing */
}

/* Individual item cards */
.prize-card {
    background-color: #f9f9f9;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    padding: 20px;
    text-align: center;
    transition: transform 0.2s ease;
    width: calc(33.33% - 20px);
    /* Three cards per row with some spacing by default */
    margin-right: 20px;
    /* Add some spacing between cards */
    margin-bottom: 20px;
    position: relative;
}

/* Prize card layout for medium-sized screens (two cards per row) */
@media screen and (max-width: 768px) {
    .prize-card {
        width: calc(50% - 20px);
        /* Two cards per row with some spacing */
    }
}

/* Prize card layout for small screens (one card per row) */
@media screen and (max-width: 480px) {
    .prize-card {
        width: 100%;
        /* One card per row with no spacing */
    }
}

.prize-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

/* Prize image */
.prize-image {
    max-width: 100%;
    height: auto;
    margin-bottom: 15px;
    border-radius: 8px;
}

.out-of-stock-banner {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    background-color: black;
    /* Black background for out of stock */
    color: white;
    text-align: center;
    padding: 5px;
    font-weight: bold;
    font-size: 1.2rem;
    display: block;
}

/* Prize name */
.prize-name {
    font-size: 1.6rem;
    color: #333;
    font-weight: bold;
}

/* Prize description */
.prize-description {
    font-size: 1.2rem;
    color: #555;
    margin-bottom: 15px;
}

/* Prize points */
.prize-points {
    font-size: 1.4rem;
    color: #A51431;
    font-weight: bold;
    margin-bottom: 15px;
}

/* Redeem button */
.redeem-button {
    background-color: #A51431;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 12px 24px;
    cursor: pointer;
    transition: background-color 0.3s;
}

/* Disabled button style for out-of-stock items */
.redeem-button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
    color: #999;
}

.redeem-button:hover {
    background-color: #8C0D26;
}

/* Out of stock message */
.out-of-stock {
    color: #777;
    font-weight: bold;
}

/* Filters container */
.filters {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    margin: 20px 20px 0 20px;
}

/* Filter text style */
.filter {
    cursor: pointer;
    margin-right: 20px;
    font-size: 1.2rem;
    color: #333;
    text-decoration: none;
    transition: color 0.3s;
}

/* Filter underline animation */
.filter::after {
    content: '';
    position: absolute;
    width: 0;
    height: 2px;
    background-color: #A51431;
    bottom: -2px;
    left: 0;
    transition: width 0.3s;
}

/* Hover state for filters */
.filter:hover {
    color: #A51431;
}

/* Hover state for filter underline */
.filter:hover::after {
    width: 100%;
}

/* Search container */
.search-container {
    margin-bottom: 30px;
    text-align: center;
}

/* Search input styles */
input[type="text"] {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 1.2rem;
}

/* Placeholder text styles */
input::placeholder {
    color: #999;
}

/* Hover state for input */
input[type="text"]:hover {
    border-color: #A51431;
}

/* Active state for input */
input[type="text"]:focus {
    border-color: #A51431;
}
'''
'''--- frontend/src/routes/Prizes/PrizeHome.css ---
/* PrizeHome.css */

.container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

.header {
  text-align: center;
  margin-bottom: 30px;
}

.title {
  font-size: 2.5rem;
  color: #333;
}

.sub-text {
  font-size: 1.2rem;
  color: #666;
  text-align: center;
  margin-bottom: 30px;
}

.cart {
  margin-top: 30px;
}

.remove-button {
  background-color: #A51431;
  color: white;
  border: none;
  border-radius: 6px;
  padding: 10px 20px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.remove-button:hover {
  background-color: #8C0D26;
}

'''
'''--- frontend/src/routes/Prizes/index.ts ---
import PrizeHome from './PrizeHome';

export default PrizeHome;

'''
'''--- frontend/src/routes/Stats/index.ts ---
import Stats from './Stats';

export default Stats;

'''
'''--- frontend/src/routes/Success/index.ts ---
import Success from './Success';

export default Success;

'''
'''--- frontend/src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''
'''--- frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: ['./src/**/*.{js,jsx,ts,tsx}', './node_modules/flowbite/**/*.js'],
    theme: {
        extend: {
            dropShadow: {
                hard: '4px 4px 0px rgba(0,0,0,1)',
            },
            colors: {
                'white': '#FFFFFF', // AHA White
                'gray': '#636466',  // AHA Gray
                'black': '#000000', // AHA Black
                'deep-red': '#A51431',  // AHA Deep Red (Accent)
                // Define other colors you may need
                // ...
            },
            textColor: {
                'default': '#000000',    // Black as default text color
                'accent': '#A51431',      // AHA Deep Red as accent text color
                // Define other text colors you may need
                // ...
            },
            fontFamily: {
                'lub-dub': ['Lub Dub', 'sans-serif'],  // AHA's custom font
                'georgia': ['Georgia', 'serif'],       // Georgia Regular
                // Add other font styles from AHA
                // ...
            },
        },
    },
    plugins: [require('flowbite/plugin')],
};

'''
'''--- frontend/tsconfig.json ---
{
    "compilerOptions": {
        "outDir": "./dist",
        "target": "es5",
        "lib": ["dom", "dom.iterable", "esnext"],
        "allowJs": true,
        "skipLibCheck": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "module": "esnext",
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": false,
        "jsx": "react-jsx"
    },
    "include": ["src/"]
}

'''
'''--- package.json ---
{
	"name": "aha-boilerplate",
	"version": "1.0.0",
	"license": "MIT",
	"author": "Ben Kurrek",
	"scripts": {
		"build:contract": "cd contract && ./build.sh",
		"test:contract": "ava __tests__/tests.ava.ts",
		"build:frontend": "cd frontend && yarn build",
		"start:frontend": "cd frontend && yarn start"
	},
	"dependencies": {
		"@near-js/accounts": "0.1.3",
		"@near-js/crypto": "0.0.4",
		"@near-js/keystores-browser": "0.0.4",
		"@near-js/keystores-node": "0.0.4",
		"@near-js/transactions": "0.2.0",
		"@near-js/types": "0.0.4",
		"@near-js/utils": "0.0.4",
		"@near-js/wallet-account": "0.0.6",
		"@near-wallet-selector/core": "8.0.3",
		"@types/bn.js": "^5.1.0",
		"@types/react": "^18.0.26",
		"ava": "^5.2.0",
		"near-cli": "^3.4.2",
		"near-workspaces": "^3.3.0",
		"react": "^18.2.0",
		"react-dom": "18.2.0",
		"ts-node": "^10.8.0",
		"typedoc": "^0.23.24",
		"typescript": "^4.8.4"
	}
}

'''