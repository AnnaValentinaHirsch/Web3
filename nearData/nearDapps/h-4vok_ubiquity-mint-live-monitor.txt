*GitHub Repository "h-4vok/ubiquity-mint-live-monitor"*

'''--- README.md ---
# Ubiquity Mint Live Monitor - Proof of Concept

Link to deployed demo: https://ubiquity-mint-monitor-poc.netlify.app/

- Check last section for a guide on testing

We are always looking for ways to produce innovative tools for the NFT space in the Solana blockchain, and we have been researching ERC20 blockchains for a while. We have been planning to build a cross-chain NFT monitor and fraud analyzer that would not require you to connect your wallet.

Ubiquity API has now appeared. It's functionality support is still under development, especially for Solana, so we depend on other third party APIs until Ubiquity API can expand its support. However, this prototype of our platform idea is a good first example to show how easy it would be to use Ubiquity API in conjunction to other market APIs to build very fast, concrete and reliable solutions for the NFT space.

# Hackathon participants

### Nathaniel Acton

Marketing and Business Lead

- Twitter: https://twitter.com/nateacton
- Telegram: @nateacton

### Christian Guzman

Product design and software engineer

- Github: https://github.com/h-4vok
- Telegram: @h_4vok

### German Dario

Software engineering lead

- Github: https://github.com/germangp088
- Telegram: @germangp088

# About the team

Our team is also comprised of 4 additional developers, 2 marketing associates, 2 content managers and an array of freelance providers. However, for this particular project only the three of us have participated as the team is busy building other products.

# Technologies used

We developed by PoC for Solana where we have the most experience. We used the following technologies.

## List of technologies

### Frontend

- ReactJS
- Material UI
- Axios

### APIs

- Ubiquity API for Solana
- Solscan API

## How is technology used

We are using the Material UI layout library to quickly build layouts that are mobile responsive while also utilizing the very known styling of Material UI which is also known to end users.

ReactJS is obviously the underlaying library supporting all the rendering and instrumentation of all of our pages.

But this project would not be complete without interacting with the APIs. For Ubiquity API we are using the official @ubiquity/ubiquity-ts-client library from the official ubiquity npm registry (you will need to build the .npmrc file for this to work locally).

We are using AXIOS to interact with the Solscan API in order to obtain the owner of an NFT, the metadata and the image. This could be easily achieved with Ubiquity API but the NFT APIs currently are not supporting Solana.

## Specific places where @ubiquity/ubiquity-ts-client is used

Please head to the monitor.js file under src/lib/monitor

- Line 65 - Where we use Ubiquity API to understand which is the latest block number in the solana blockchain
- Line 80 - Most importantly, we use the Ubiquity API to obtain all the transactions within a specific block number

## How our application works and leverages Ubiquity API

Now that we understand where all the tech stack and where Ubiquity API is used, its time to understand how this prototype of a mint monitor work. We say prototype, as in a real life scenario more complexity and features would be taken into consideration.

When the user types a block number in the home page, or leaves the textbox blank, and clicks on GO, we will determinate which block number the user wants to start scanning from.

Here our live monitor starts and an algorithm can be observed in line 19 of the monitor.js file. Here we define in which block we will begin our search and then we will obtain such block. This block contains all of its transactions but it does not have all the data. However, we do not want to query the transaction data of every single transaction in this block as this would consume enormous resources.

Once the data is obtained, we send the block to the Distiller which is in the distiller.js file under src/lib.

Distiller loops quickly through the data and analyzes its contents. This is a very short and simple version of what the distiller would be, but it is good enough for the prototype. In this particular case we have identified a pattern where all NFT mints in Solana have exactly 6 events and the type of the second event is "create_account". When a transaction fulfills this criteria it does not immediatelly mean that this is an NFT mint, but all NFT mints have to succeed this criteria. All transactions like this are marked as transaction candidates and sent over to the NftDiscovery.

NftDiscovery is in nftDiscovery.js under src/lib. This object receives these transaction candidates and now, having a reduced subset of the block's transactions, it uses the Solscan API to retrieve this element as if it were an NFT. To do this, we have identified that the NFT token address is in the destination field of the second even of the transaction (which is, if you remember, the "create_account" event).

Using the Solscan API we obtain the data of the NFT in JSON format. If this were to be a valid NFT then we will be able to find the location of the json metadata of this NFT under data.data.metadata.data.uri

Using this URL, we run a simple GET with Axios and retrieve this JSON metadata. This contains, among other things, the name and the visual resource's uri of the NFT.

Finally we want to know who is the current owner of the token. We leverage Solscan again and use their specific API for this.

Once all is done, the data is put into a model and sent to the Observer. The Observer can be found in observer.js under src/lib/global.

The Observer lives globally within the application regardless of which route you started the application at, and will emit events every time it receives an NFT. These events are being listened to by the NFTHandler (you will see in this prototype that the Observer knows the NFTHandler. In a real life application there would be a complete decoupling) which in turn takes care of drawing every NFT information on the screen, allowing the user to interact with it as soon as possible.

Our algorithm goes back to the Monitor which will now work on the next block until all blocks have been checked, at which point it will retrieve the information of what is the newest latest block using the Ubiquity API, and proceed to loop again.

# About the coding practices

This was a quick prototype so please do not expect the best practices, nor SOLID principles nor Atomic Design, which are partially concepts we always use in non-prototype projects.

As we have mentioned in other sections, a real life application would require better attention to detail.

# This is not Solana exclusive

Our algorithm and design patterns using the Monitor, Distiller, NftDiscovery, Observer and NFTHandler are quite generic. We would need to build an abstract family interface of these and then potentially have specific implementations for ERC20 compatible blockchains, Solana and NEAR, which are all of the important players in the NFT space.

While implementation will change between blockchains, the algorithm is likely to stay untouched. Potentially classes like Monitor, Observer and NFTHandler will be the same. We would also have to build our own data model for representing NFTs as every blockchain has a different way of structuring this data. This is something the users and the UI should not care about.

# Recommended block numbers for testing:

The live monitor will pick anything from the current block if you input nothing on the home page. However, it's possible that there are no mintings happening at the time of monitoring.

Here are a couple of block numbers where we now there have been several active mints at the same time.

- 119798911
- 119798937

# Testing our application

Please go to https://ubiquity-mint-monitor-poc.netlify.app/ for a deployed version of this prototype.

## Home page

In the home page you will be asked to type the block number you wish to start monitoring from. _This is not something the real users would be doing_ but it is a way for us to have a quick testing scenario. Real users would be accesing our data live without the need to worry about block numbers or other blockchain intrisicancies.

We recommend using the block numbers we have quoted above which have been very active. However, you are welcome to try not typing anything which will start monitoring the blockchain at the current moment.

Once you click GO the monitor will begin

## Monitoring

The monitor will be exploring the blockchain in search of NFTs. Soon, NFTs will start popping up and have its information displayed for you. If you click on the NFT anywhere you will have a popup with more detailed info of this NFT, who is the current owner, what is the metadata of the element and an option to share this NFT in Twitter.

- Note: A lot more can and will be done. The idea is to identify trends, identify frauds, be able to catch a mint that is going to be successful while its happening, etc. Our business presentation includes a myriad of features that be built around this.

## Restarting

Since this is a prototype, we did not put a lot of effort in making it easy to restart the monitor. This would not be a functionality that users will need anyway.

We recommend you navigate again to the home page at https://ubiquity-mint-monitor-poc.netlify.app/#/ and then click F5 (otherwise it won't really reset as we are using ReactJS).

'''
'''--- build_npmrc.sh ---
if [ -f .npmrc ]; then
   rm .npmrc
   echo ".npmrc is removed"
fi
_authToken=$(head -n 1 .env)
echo "@ubiquity:registry=https://gitlab.com/api/v4/projects/27274533/packages/npm/">>.npmrc
echo "//gitlab.com/api/v4/projects/27274533/packages/npm/${_authToken}">>.npmrc
echo "always-auth=true">>.npmrc
'''
'''--- docker-compose.yml ---
version: '2.2'

services:
    ubiquity-mint-live-monitor:
        stdin_open: true
        tty: true
        build:
            context: .
        environment:
        - API_KEY=${API_KEY}
        ports:
            - "3000:3000"
'''
'''--- package.json ---
{
  "name": "ubiquity-mint-live-monitor",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@material-ui/core": "^4.12.4",
    "@material-ui/icons": "^4.11.3",
    "@mui/icons-material": "^5.8.4",
    "@mui/material": "^5.8.7",
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^13.5.0",
    "@ubiquity/ubiquity-ts-client": "^1.0.0",
    "axios": "^0.27.2",
    "hoist-non-react-statics": "^3.3.2",
    "lodash": "^4.17.21",
    "react": "^18.2.0",
    "react-cache-buster": "^0.1.6",
    "react-dom": "^18.2.0",
    "react-router-dom": "^5.3.3",
    "react-scripts": "4.0.3",
    "share-twitter": "^1.0.0",
    "url-encode-decode": "^1.0.0",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "build:npmrc": "build_npmrc.sh",
    "build:env": "react-app-env --env-file=.env",
    "start": "npm run build:env start",
    "serve": "serve build",
    "docker": "docker-compose up --build",
    "build": "npm run build:env build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "react-app-env": "^1.2.3",
    "serve": "^13.0.2"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&family=Kanit:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
      rel="stylesheet"
    />
    <title>Ubiquity Live Mint Monitor - Monitor all mints happening realtime in the Solana blockchain</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/background.css ---
html {
  height: 100%;
}

body {
  margin: 0;
}

/* background-image: linear-gradient(-60deg, #6c3 50%, #09f 50%); */

.bg {
  animation: slide 6s ease-in-out infinite alternate;
  background-image: linear-gradient(-60deg, var(--background-color) 50%, var(--border-color) 50%);
  bottom: 0;
  left: -50%;
  opacity: 0.5;
  position: fixed;
  right: -50%;
  top: 0;
  z-index: -1;
}

.bg2 {
  animation-direction: alternate-reverse;
  animation-duration: 4s;
}

.bg3 {
  animation-duration: 5s;
}

/* background-color: rgba(255, 255, 255, 0.8); */

.content {
  /* background-color: var(--background-color-content); */
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 0.25em;
  box-shadow: 0 0 0.25em rgba(0, 0, 0, 0.25);
  box-sizing: border-box;
  /* left: 50%; */
  padding: 10vmin;
  /* position: absolute; */
  text-align: center;
  margin-top: 40px;
  /* transform: translate(-50%, -50%); */
}

@keyframes slide {
  0% {
    transform: translateX(-25%);
  }
  100% {
    transform: translateX(25%);
  }
}

h1, h2, h3, h4, h5, h6 {
  color: var(--heading-text-color);
}

span, p {
  color: var(--body-text-color);
}
'''
'''--- src/components/atoms/CircularProgressIcon.css ---
.circular-progress-icon {
    width: 25px !important;
    height: 25px !important;
    color: #09f !important;
}
'''
'''--- src/components/pages/Errors/404.test.js ---
import React from 'react';
import NotFound from './404';
import { render } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';

test('render elements', () => {

  const { getByText } = render(
    <NotFound />
  );

  const element = getByText(/404/i);
  const homeElement = getByText(/Home/i);
  expect(element).toBeInTheDocument();
  expect(homeElement).toBeInTheDocument();
});
'''
'''--- src/gradientShadow.css ---
:root {
  --gradient-shadow: linear-gradient(
    45deg,
    #fb0094,
    #0000ff,
    #00ff00,
    #ffff00,
    #ff0000,
    #fb0094,
    #0000ff,
    #00ff00,
    #ffff00,
    #ff0000
  );
}
.gradient-shadow {
  display: flex;
	justify-content: center;
	align-items: center;
	position: relative;
	color: #fff;
	text-align: center;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 50px;
	font-size: 50px;
  width: 200px;
  height: 200px;
  background: linear-gradient(0deg, #000, #262626);
}
.gradient-shadow:before,
.gradient-shadow:after {
  content: "";
  position: absolute;
  top: -2px;
  left: -2px;
  background: var(--gradient-shadow);
  background-size: 400%;
  width: calc(100% + 4px);
  height: calc(100% + 4px);
  z-index: -1;
  animation: animateBackground 20s linear infinite;
}

.gradient-shadow:after {
  filter: blur(20px);
}

@keyframes animateBackground {
  0% {
    background-position: 0 0;
  }
  50% {
    background-position: 300% 0;
  }
  100% {
    background-position: 0 0;
  }
}

'''
'''--- src/index.css ---
:root {
  --heading-font: "Inter", sans-serif;
  --body-font: "Kanit", sans-serif;

  --background-color-content: rgb(0, 19, 33, 0.8);
  --background-color: rgb(0, 19, 33);
  --border-color: rgb(19, 55, 82);
  --action-color: rgb(0, 227, 180);
  --heading-text-color: rgb(255, 255, 255);
  --body-text-color: ghostwhite;
}

body {
  margin: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

.title {
  font-family: var(--heading-font) !important;
  font-style: italic !important;
}

.text-align--center {
  text-align: center;
}

.text-align--left {
  text-align: left;
}

.box {
  padding-top: 20px;
}

.stretched-button {
  width: 100%;
  height: 100%;
}

iframe {
  pointer-events: none;
}

.grid {
  padding: 25px;
}

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.label {
  font-family: var(--body-font);
}

.fungible-token-thumbnail {
  width: 75px;
  height: 75px;
}

.fungible-token-preview {
  width: 200px;
  height: 200px;
}

.margin-top--20px {
  margin-top: 20px;
}

.padding--40px {
  padding: 2em;
}

.hover-animation {
  transition: box-shadow 0s;
}

.cursor--pointer {
  cursor: pointer;
}

.nft-row {
  background-color: var(--background-color) !important;
}

.MuiButton-root {
  background-color: var(--action-color) !important;
}

.MuiButton-root:hover {
  background-color: var(--border-color) !important;
}

.nft-show {
  background-color: var(--background-color) !important;
}

.nft-show-table {
  border: 1px solid var(--border-color) !important;
}

.border-bottom--border-color {
  border-bottom: 1px solid var(--border-color) !important;
}

.text-overflow--ellipsis {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}

.content-text {
  font-family: var(--body-font);
}
'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import pkg from '../package.json';
import './index.css';
import './background.css';
import './gradientShadow.css';
import App from './App';
import Loading from './components/common/Loading'
import CacheBuster from 'react-cache-buster';
import reportWebVitals from './reportWebVitals';
import { NFTHandlerProvider } from './lib/nftHandler'
import { MonitorProvider } from './lib/monitor'

const isProduction = process.env.NODE_ENV === 'production'
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <CacheBuster
    currentVersion={pkg.version}
    isEnabled={isProduction} //If false, the library is disabled.
    isVerboseMode={false} //If true, the library writes verbose logs to console.
    loadingComponent={<Loading open={true} />} //If not pass, nothing appears at the time of new version check.
  >
    <MonitorProvider>
      <NFTHandlerProvider>
        <App />
      </NFTHandlerProvider>
    </MonitorProvider>
  </CacheBuster>,
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

'''
'''--- src/lib/constants/index.js ---
export { homeHash, homeLink, liveMonitorLink } from "./pages";

export const solscanApiGetAccount = "https://api.solscan.io/account?address=";
export const buildUriSolscanApiGetHolders = (nftAddress) =>
  `https://public-api.solscan.io/token/holders?tokenAddress=${nftAddress}&offset=0&limit=1`;
export const solscanUrl = "https://solscan.io/token/";
export const lineBreakCode = "%0A";
export const solscanLinkToAccount = 'https://solscan.io/account/';
'''
'''--- src/lib/constants/pages/index.js ---
const homeHash = "#/"
const homeLink = "/"
const liveMonitorLink = "/monitor";

export { homeHash, homeLink, liveMonitorLink }
'''
'''--- src/lib/delay.js ---
export const delay = (ms) => new Promise((res) => setTimeout(res, ms))

'''
'''--- src/lib/distiller.js ---
import { NftDiscovery } from "./nftDiscovery";

export class Distiller {
  #nftDiscovery;

  constructor() {
    this.#nftDiscovery = new NftDiscovery();
  }

  async findNFTcandidates(block) {
    const txCandidates = block.txs.filter(
      (x) => x.events.length === 6 && x.events[1].type === "create_account"
    );

    if (txCandidates) {
      this.#nftDiscovery.getNFTData(txCandidates);
    }
  }
}

'''
'''--- src/lib/formatting/numberFormat.js ---
const zero = 0;

const returnDefault = (decimalPlaces, defaultIsZero = true) => {
  if (defaultIsZero) return zero.toFixed(decimalPlaces);
  return null;
};

export const toFixed = (
  candidateNumber,
  decimalPlaces,
  defaultIsZero = true
) => {
  if (!candidateNumber) {
    return returnDefault(decimalPlaces, defaultIsZero);
  }

  try {
    const convertedNumber = parseInt(candidateNumber);
    const output = convertedNumber.toFixed(decimalPlaces);

    console.log({ candidateNumber, convertedNumber, output });
    return output;
  } catch {
    return returnDefault(decimalPlaces, defaultIsZero);
  }
};

export const formatRoyalties = (royalties) => {
    if (!royalties) return returnDefault(2);
    if (!royalties.slice) return returnDefault(2);

    const integerPart = royalties.slice(0, royalties.length - 2);
    const decimalPart = royalties.slice(royalties.length - 2, royalties.length);
    const output = [integerPart.toString(), ".", decimalPart.toString()].join("");

    return output;
}
'''
'''--- src/lib/global/globalState.js ---
import { Observer } from './observer'

export const GlobalState = {
  NFTHandler: null,
  Observer:  new Observer()
};

export const resetNFTState = () => {
  if (GlobalState.NFTHandler.getNFTsCount() > 0) {
    GlobalState.NFTHandler.reset()
  }
}
'''
'''--- src/lib/global/index.js ---
export { GlobalState, resetNFTState } from './globalState'
export { Observer } from './observer'

'''
'''--- src/lib/global/observer.js ---
import { EventEmitter } from 'events'
import { GlobalState } from '../global'

export class Observer {
  #eventEmitter
  #NFT_EVENT_KEY

  constructor() {
    this.#eventEmitter = new EventEmitter()
    this.#NFT_EVENT_KEY = 'nft_event'
    this.#onNFTEvent()
  }

  emitNFTEvent = (nft) => this.#eventEmitter.emit(this.#NFT_EVENT_KEY, nft)

  #onNFTEvent = () => this.#eventEmitter.on(this.#NFT_EVENT_KEY, (nft) => GlobalState.NFTHandler.handleNFT(nft))
}

'''
'''--- src/lib/monitor/index.js ---
export { useMonitor } from './useMonitor'
export { MonitorProvider, MonitorConsumer, MonitorContext } from './monitorContext'
export { Monitor } from './monitor'
export { withMonitor } from './withMonitor'
'''
'''--- src/lib/monitor/monitor.js ---
import { UbiquityClient, NETWORKS, PROTOCOL } from "@ubiquity/ubiquity-ts-client"
import { Distiller } from "../distiller"
import { delay } from '../delay'

export class Monitor {
    #running
    #client
    #distiller
    #setBlockNumber
    #setLatestBlockNumber

    constructor(apiKey, setBlockNumber, setLatestBlockNumber) {
      this.#client= new UbiquityClient(apiKey)
      this.#distiller = new Distiller()
      this.#setBlockNumber = setBlockNumber
      this.#setLatestBlockNumber = setLatestBlockNumber
    }

    async start(startBlockNumber) {
      console.log('Running monitor')

      const latestBlockNumber = await this.#getLatestBlockNumber()
      let blockNumber = startBlockNumber === 'current' ? latestBlockNumber : startBlockNumber
      this.#setLatestBlockNumber(latestBlockNumber)
      this.#running = true

      while (latestBlockNumber >= blockNumber && this.isRunning()) {
        console.log(`Monitoring on block number: ${blockNumber}`)

        if (blockNumber === -1) blockNumber = latestBlockNumber
        this.#setBlockNumber(blockNumber)
  
        // Cancel monitoring if we have reached the ending block
        // which is only used for debugging purposes
        if (!!latestBlockNumber && blockNumber > latestBlockNumber)
          return
  
        console.info(`${blockNumber} / ${latestBlockNumber}`)
  
        const block = await this.#getBlock(blockNumber)
        if (block) {
          await this.#distiller.findNFTcandidates(block)
        }
  
        blockNumber++

        await delay(1000)
      }

      if (!this.isRunning()) {
        return
      }
  
      setTimeout(async () => await this.start(latestBlockNumber), 1000)
    }

    stop = () => this.#running = false

    isRunning = () => this.#running

    async #getLatestBlockNumber() {
      console.log("getLatestBlockNumber")

      try {
        const { data } = await this.#client
                                    .syncApi
                                    .currentBlockNumber(PROTOCOL.SOLANA, NETWORKS.MAIN_NET)
        
        console.log({data})
        return data
      } catch (e) {
        console.log(`error code::${e.response.status} url::${e.config.url}`)
      }
    }

    async #getBlock(blockNumber) {
      console.log("getBlock")

      try {
        const { data } = await this.#client
                                      .blocksApi
                                      .getBlock(PROTOCOL.SOLANA, NETWORKS.MAIN_NET, blockNumber)
        console.log({data})

        return data
      } catch (e) {
        console.log(`error code::${e.response.status} url::${e.config.url}`)
      }
    }
}
'''
'''--- src/lib/monitor/monitorContext.js ---
import React  from 'react'
import { Monitor } from "../monitor"

const MonitorContext = React.createContext(null)

class MonitorProvider extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      monitor: null,
      startBlockNumber: -1,
      blockNumber: 0,
      latestBlockNumber: 0
    }
  }

  start = async () => {
    this.setState(() => ({
      monitor: new Monitor(
        process.env.REACT_APP_API_KEY,
        this.#setBlockNumber,
        this.#setLatestBlockNumber
      )
    }), async () => await this.state.monitor.start(this.state.startBlockNumber))
  }

  stop = () => this.state.monitor.stop()

  resetMonitorState = () => {
    this.stop()
    this.setState(() => ({
      monitor: null,
      blockNumber: 0,
      latestBlockNumber: 0
    }))
  }

  isRunning = () => this.state.monitor && this.state.monitor.isRunning()
  
  setStartBlockNumber = (startBlockNumber) => {
    this.setState(() => ({
      startBlockNumber
    }))
  }

  #setBlockNumber = (blockNumber) => {
    this.setState(() => ({
      blockNumber
    }))
  }

  #setLatestBlockNumber = (latestBlockNumber) => {
    this.setState(() => ({
      latestBlockNumber
    }))
  }

  render() {
    return (
      <MonitorContext.Provider
        value={{
          ...this.state,
          start: this.start,
          stop: this.stop,
          setStartBlockNumber: this.setStartBlockNumber,
          resetMonitorState: this.resetMonitorState,
          isRunning: this.isRunning
        }}
      >
        {this.props.children}
      </MonitorContext.Provider>
    )
  }
}

const MonitorConsumer = MonitorContext.Consumer

export { MonitorProvider, MonitorConsumer, MonitorContext }

'''
'''--- src/lib/monitor/useMonitor.js ---
import React from 'react'
import { MonitorContext } from './monitorContext'

export function useMonitor() {
  return React.useContext(MonitorContext)
}

'''
'''--- src/lib/monitor/withMonitor.js ---
import React from 'react';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { MonitorContext } from './monitorContext';

export const withMonitor = (Component) => {
  const WrappedComponent = React.forwardRef((props, ref) => (
    <MonitorContext.Consumer>
      {(monitorContext) => <Component {...props} ref={ref} monitorContext={monitorContext} />}
    </MonitorContext.Consumer>
  ))

  hoistNonReactStatics(WrappedComponent, Component);

  return WrappedComponent;
}
'''
'''--- src/lib/nftDiscovery.js ---
import axios from "axios";
import {
  solscanApiGetAccount,
  buildUriSolscanApiGetHolders,
} from "./constants";
import { GlobalState } from "./global";

export class NftDiscovery {
  async getNFTData(txCandidates) {
    for (var tx of txCandidates) {
      try {
        const nftAddress = tx.events[1].destination;

        const requestToSolscan = `${solscanApiGetAccount}${nftAddress}`;

        const nftData = await axios.get(requestToSolscan);

        // Now we bring the data from arweave
        const metadataUri = nftData.data.data.metadata.data.uri;

        const { data } = await axios.get(metadataUri);

        // We bring the current owner information
        const getOwnerUri = buildUriSolscanApiGetHolders(nftAddress);
        const ownerData = await axios.get(getOwnerUri);

        data.ownerData = ownerData.data.data[0];
        console.log({ discoveryData: data });

        GlobalState.Observer.emitNFTEvent({
          ...data,
          address: nftData.data.data.account,
        });
      } catch (e) {
        console.error({ e });
      }
    }
  }
}

'''
'''--- src/lib/nftHandler/index.js ---
export { useNFTHandler } from './useNFTHandler'
export { NFTHandlerProvider, NFTHandlerConsumer, NFTHandlerContext } from './nftHandlerContext'
export { NFTHandler } from './nftHandler'
export { withNFTHandler } from './withNFTHandler'
'''
'''--- src/lib/nftHandler/nftHandler.js ---
export class NFTHandler {
  #getNFTs
  #setNFTs

  constructor(getNFTs, setNFTs) {
    this.#getNFTs = getNFTs
    this.#setNFTs = setNFTs
  }
  
  getNFTsCount = () => this.#getNFTs().length
  
  handleNFT = (nft) => this.#setNFTs([...this.#getNFTs(), nft])

  reset = () => this.#setNFTs([])
}

'''
'''--- src/lib/nftHandler/nftHandlerContext.js ---
import React  from 'react'
import * as _ from 'lodash'
import { NFTHandler } from "./nftHandler"
import { GlobalState } from '../global'

const NFTHandlerContext = React.createContext(null)

class NFTHandlerProvider extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      nfts: []
    }

    GlobalState.NFTHandler = new NFTHandler(
      this.#getNFTs,
      this.#setNFTs
    )
  }

  maxNFTsReached = () => this.state.nfts.length >= process.env.REACT_APP_MAX_NFTS

  #getNFTs = () => _.clone(this.state.nfts, false)

  #setNFTs = (nfts) => {
    this.setState(() => ({
      nfts,
    }))
  }

  render() {
    return (
      <NFTHandlerContext.Provider
        value={{
          ...this.state,
          resetNFTState: this.resetNFTState,
          maxNFTsReached: this.maxNFTsReached
        }}
      >
        {this.props.children}
      </NFTHandlerContext.Provider>
    )
  }
}

const NFTHandlerConsumer = NFTHandlerContext.Consumer

export { NFTHandlerProvider, NFTHandlerConsumer, NFTHandlerContext }

'''
'''--- src/lib/nftHandler/useNFTHandler.js ---
import React from 'react'
import { NFTHandlerContext } from './nftHandlerContext'

export function useNFTHandler() {
  return React.useContext(NFTHandlerContext)
}

'''
'''--- src/lib/nftHandler/withNFTHandler.js ---
import React from 'react';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { NFTHandlerContext } from './nftHandlerContext';

export const withNFTHandler = (Component) => {
  const WrappedComponent = React.forwardRef((props, ref) => (
    <NFTHandlerContext.Consumer>
      {(nftHandlerContext) => <Component {...props} ref={ref} nftHandlerContext={nftHandlerContext} />}
    </NFTHandlerContext.Consumer>
  ))

  hoistNonReactStatics(WrappedComponent, Component);

  return WrappedComponent;
}
'''
'''--- src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''