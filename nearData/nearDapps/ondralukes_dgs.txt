*GitHub Repository "ondralukes/dgs"*

'''--- README.md ---
# Decentralised Grading System
A simple app for managing classes and grading. Powered by NEAR Blockchain, Rust and Vue.js.

'''
'''--- app/babel.config.js ---
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}

'''
'''--- app/package.json ---
{
  "name": "app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "core-js": "^3.6.5",
    "near-api-js": "^0.42.0",
    "vue": "^2.6.11",
    "vue-router": "^3.2.0"
  },
  "devDependencies": {
    "@vue/cli-plugin-babel": "~4.5.0",
    "@vue/cli-plugin-eslint": "~4.5.0",
    "@vue/cli-plugin-router": "~4.5.0",
    "@vue/cli-service": "~4.5.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^6.7.2",
    "eslint-plugin-vue": "^6.2.2",
    "vue-template-compiler": "^2.6.11"
  },
  "eslintConfig": {
    "root": true,
    "env": {
      "node": true
    },
    "extends": [
      "plugin:vue/essential",
      "eslint:recommended"
    ],
    "parserOptions": {
      "parser": "babel-eslint"
    },
    "rules": {}
  },
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead"
  ]
}

'''
'''--- app/public/index.html ---
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

'''
'''--- app/src/globalState.js ---
import * as nearAPI from 'near-api-js'

const contractId = 'dev-1633940009656-67273686024371';
export class GlobalState{
    user = null;
    near = null;
    wallet = null;
    keyStore = null;
    contract;
    async init(){
        const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
        const config = {
            networkId: "testnet",
            keyStore,
            nodeUrl: "https://rpc.testnet.near.org",
            walletUrl: "https://wallet.testnet.near.org",
            helperUrl: "https://helper.testnet.near.org",
            explorerUrl: "https://explorer.testnet.near.org",
        };
        this.keyStore = keyStore;
        this.near = await nearAPI.connect(config);
        this.wallet = new nearAPI.WalletConnection(this.near);
        this.contract = new nearAPI.Contract(
            this.wallet.isSignedIn()?this.wallet.account():await this.near.account(contractId),
            contractId,
            {
                viewMethods: [
                    'id_lookup',
                    'cls_get_info',
                    'cls_get_members',
                    'cls_get_grades',
                    'p_get_classes'
                ],
                changeMethods: [
                    'id_create',
                    'id_add',
                    'cls_create',
                    'cls_add_member',
                    'cls_add_grade',
                    'cls_finalize'
                ]
            }
        );
    }
    nearWalletLogin(){
        this.wallet.requestSignIn({
            contractId
        });
    }
    nearWalletLogout(){
        this.wallet.signOut();
    }
    async nearIsLogged(){
        if(!this.near) await this.init();
        return this.wallet.isSignedIn();
    }

    async login(storageId, id){
        return new Promise((resolve) => {
            this.identityLookup(storageId, id).then(
                name => {
                    if(name == null) resolve(false);
                    this.user = {
                        storageId: storageId,
                        id: id,
                        name: name
                    };
                    resolve(true);
                },
                () => resolve(false)
            )
        });
    }
    async getClassesId(){
        if(!this.near) await this.init();
        return await this.contract.p_get_classes({
            storage_id: this.user.storageId,
            id: this.user.id
        });
    }
    async getClassInfo(classId){
        if(!this.near) await this.init();
        const raw = await this.contract.cls_get_info({
            class_id: classId
        });
        return {
            name: raw[0],
            storageId: raw[1],
            finalized: raw[2],
            memberCount: raw[3],
            gradeCount: raw[4]
        };
    }
    createClass(storageId, name){
        return this.createTrackableTransaction('cls_create', {
            storage_id: storageId,
            name: name
        });
    }
    addClassMember(classId, memberId){
        return this.createTrackableTransaction('cls_add_member', {
            class_id: classId,
            member_id: memberId
        });
    }
    async getClassMembers(classId){
        if(!this.near) await this.init();
        return await this.contract.cls_get_members({
            class_id: classId
        });
    }
    async getClassGrades(classId){
        if(!this.near) await this.init();
        return await this.contract.cls_get_grades({
            class_id: classId,
            member_id: this.user.id
        });
    }
    addGrade(classId, name, values){
        return this.createTrackableTransaction('cls_add_grade', {
            class_id: classId,
            name: name,
            values: values
        });
    }
    finalizeClass(classId){
        return this.createTrackableTransaction('cls_finalize', {
            class_id: classId
        });
    }
    get logged(){
        return this.user !== null;
    }
    async identityLookup(storageId, id){
        if(!this.near) await this.init();
        return await this.contract.id_lookup({
            storage_id: storageId,
            id: id,
        });
    }
    identityAdd(storageId, name){
        return this.createTrackableTransaction('id_add', {
            storage_id: storageId,
            name: name
        });
    }
    identityCreate(){
        return this.createTrackableTransaction('id_create', {});
    }
    createTrackableTransaction(method, params){
        return {
            contract: contractId,
            method: method,
            params: params,
            promise:
                this.near
                    ?this.contract[method](params)
                    :this.init().then(() => this.contract[method](params))
        }
    }
}

'''
'''--- app/src/main.js ---
import Vue from 'vue'
import App from './App.vue'
import {GlobalState} from "@/globalState";
import router from './router'

Vue.config.productionTip = false

Vue.prototype.$globalState = new GlobalState();

new Vue({
  router,
  render: h => h(App)
}).$mount('#app')

'''
'''--- app/src/router/index.js ---
import Vue from 'vue'
import VueRouter from 'vue-router'
import Login from "@/views/Login";

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Login',
    component: Login
  },
  {
    path: '/user',
    name: 'User',
    component: () => import(/* webpackChunkName: "user" */ '../views/User.vue')
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import(/* webpackChunkName: "admin" */ '../views/Admin.vue')
  },
  {
    path: '/classadmin/:id',
    name: 'ClassAdmin',
    component: () => import(/* webpackChunkName: "classAdmin" */ '../views/ClassAdmin')
  }
]

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

export default router

'''
'''--- near-contract/Cargo.toml ---
[package]
name = "near-contract"
version = "0.1.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- near-contract/src/class.rs ---
use near_sdk::AccountId;
use near_sdk::collections::{UnorderedSet, Vector};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use crate::grade::Grade;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Class{
    name: String,
    storage_id: u128,
    finalized: bool,
    owner: AccountId,
    members: UnorderedSet<u32>,
    grades: Vector<Grade>
}

impl Class{
    /* Getters */
    pub fn storage_id(&self) -> &u128 { &self.storage_id }
    pub fn owner(&self) -> &AccountId { &self.owner }
    pub fn name(&self) -> &String { &self.name }
    pub fn members(&self) -> &UnorderedSet<u32> { &self.members }
    pub fn member_count(&self) -> u64 { self.members.len() }
    pub fn grade_count(&self) -> u64 { self.grades.len() }
    pub fn finalized(&self) -> bool { self.finalized }

    pub fn new(name: &String, storage_id: u128, owner: AccountId, class_id: u128) -> Self{
        let mut mkey = b"clsm".to_vec(); mkey.extend_from_slice(&class_id.to_le_bytes());
        let mut gkey = b"clsg".to_vec(); gkey.extend_from_slice(&class_id.to_le_bytes());
        Self {
            name: name.clone(),
            storage_id,
            owner,
            finalized: false,
            members: UnorderedSet::new(mkey),
            grades: Vector::new(gkey)
        }
    }

    pub fn add_member(&mut self, member_id: &u32){
        self.members.insert(member_id);
    }

    pub fn finalize(&mut self){
        self.finalized = true;
    }

    pub fn add_grade(&mut self, name: &String, class_id: u128, values: &[(u32, u8)]){
        let g = Grade::new(name, class_id, self.grades.len() as u32, values);
        self.grades.push(&g);
    }

    pub fn get_grades(&self, member_id: &u32) -> Vec<(String, u64, Option<u8>)>{
        let mut v = vec![];
        for g in self.grades.iter(){
            v.push((g.name().clone(), *g.timestamp(), g.get_value(member_id)));
        }
        v
    }
    pub fn contains_member(&self, member_id: &u32) -> bool{
        self.members.contains(&member_id)
    }
}

'''
'''--- near-contract/src/grade.rs ---
use near_sdk::collections::UnorderedMap;
use near_sdk::borsh::{self, BorshSerialize, BorshDeserialize};
use near_sdk::env;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Grade{
    name: String,
    // milliseconds
    timestamp: u64,
    values: UnorderedMap<u32, u8>
}

impl Grade{
    /* Getters */
    pub fn name(&self) -> &String { &self.name }
    pub fn timestamp(&self) -> &u64 { &self.timestamp }

    pub fn new(name: &String, class_id: u128, grade_id: u32, values: &[(u32, u8)]) -> Self{
        let mut key = b"gv".to_vec();
        key.extend_from_slice(&class_id.to_le_bytes());
        key.extend_from_slice(&grade_id.to_le_bytes());
        let mut map = UnorderedMap::new(key);
        for (member, val) in values {
            map.insert(member, val);
        }
        Self {
            name: name.clone(),
            timestamp: env::block_timestamp()/1000000,
            values: map
        }
    }
    pub fn get_value(&self, member_id: &u32) -> Option<u8>{
        self.values.get(member_id)
    }
}
'''
'''--- near-contract/src/identity_storage.rs ---
use near_sdk::AccountId;
use near_sdk::collections::LookupMap;
use crate::person::Person;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct IdentityStorage{
    map: LookupMap<u32, Person>,
    id_ctr: u32,
    owner: AccountId
}

impl IdentityStorage{
    /* Getters */
    pub fn owner(&self) -> &AccountId { &self.owner }

    pub fn new(acc: &AccountId) -> Self{
        let mut key = b"idm".to_vec();
        key.extend_from_slice(acc.as_bytes());
        Self{
            map: LookupMap::new(key),
            id_ctr: 0,
            owner: acc.clone()
        }
    }
    pub fn lookup(&self, id: &u32) -> Option<Person>{
        self.map.get(id)
    }
    pub fn contains(&self, id: &u32) -> bool{
        self.map.contains_key(id)
    }
    pub fn add(&mut self, storage_id: u128, name: &String) -> u32 {
        let id = self.id_ctr;
        self.id_ctr += 1;
        let person = Person::new(name, storage_id, id);
        self.map.insert(&id, &person);
        id
    }
    pub fn update(&mut self, id: &u32, value: &Person){
        self.map.insert(id, value);
    }
}

'''
'''--- near-contract/src/lib.rs ---
use near_sdk::{env, near_bindgen};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;

use class::Class;
use identity_storage::IdentityStorage;

mod identity_storage;
mod person;
mod class;
mod grade;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct State {
    storage_id_ctr: u128,
    storages: LookupMap<u128, IdentityStorage>,
    cls_id_ctr: u128,
    classes: LookupMap<u128, Class>
}

impl Default for State{
    fn default() -> Self {
        Self{
            storage_id_ctr: 0,
            storages: LookupMap::new(b'i'),
            cls_id_ctr: 0,
            classes: LookupMap::new(b'c')
        }
    }
}

#[near_bindgen]
impl State {
    pub fn id_create(&mut self) -> u128{
        let storage = IdentityStorage::new(&env::signer_account_id());
        let id = self.storage_id_ctr;
        self.storage_id_ctr+=1;
        self.storages.insert(&id, &storage);
        id
    }

    pub fn id_add(&mut self, storage_id: u128, name: String) -> u32{
        match self.storages.get(&storage_id){
            None => {
                panic!("No such IdentityStorage!");
            }
            Some(mut storage) => {
                assert_eq!(storage.owner(), &env::signer_account_id(), "Only the owner can manage identity records.");
                let id = storage.add(storage_id, &name);
                // IdentityStorage::id_ctr was modified
                self.storages.insert(&storage_id, &storage);
                id
            }
        }
    }

    pub fn id_lookup(&self, storage_id: u128, id: u32) -> Option<String>{
        match self.storages.get(&storage_id){
            None => panic!("No such IdentityStorage!"),
            Some(storage) => {
                match storage.lookup(&id){
                    None => None,
                    Some(p) => Some(p.name().clone())
                }
            }
        }
    }

    pub fn cls_create(&mut self, storage_id: u128, name: String) -> u128{
        if !self.storages.contains_key(&storage_id) {
            panic!("No such IdentityStorage!");
        }
        let id = self.cls_id_ctr;
        self.cls_id_ctr += 1;
        let cls = Class::new(&name, storage_id, env::signer_account_id(), id);
        self.classes.insert(&id, &cls);
        id
    }

    pub fn cls_add_member(&mut self, class_id: u128, member_id: u32) {
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(mut cls) => {
                if cls.owner() != &env::signer_account_id() {
                    panic!("Only class owner can add members!");
                }
                if cls.finalized(){
                    panic!("Cannot modify finalized class!");
                }
                match self.storages.get(cls.storage_id()){
                    None => panic!("Class references non-existent IdentityStorage!"),
                    Some(mut storage) => {
                        match storage.lookup(&member_id){
                            None => panic!("Memeber not found in IdentityStorage!"),
                            Some(mut person) => {
                                person.add_class(&class_id);
                                storage.update(&member_id, &person);
                            }
                        }
                    }
                }
                cls.add_member(&member_id);
                self.classes.insert(&class_id, &cls);
            }
        }
    }

    pub fn cls_get_info(&self, class_id: u128) -> (String, u128, bool, u64, u64){
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(cls) => (
                cls.name().clone(), *cls.storage_id(), cls.finalized(), cls.member_count(), cls.grade_count()
            )
        }
    }

    pub fn cls_get_members(&self, class_id: u128) -> Vec<(u32, String)>{
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(cls) => {
                match self.storages.get(cls.storage_id()){
                    None => panic!("Class references non-existent IdentityStorage!"),
                    Some(storage) => {
                        let mut v = vec![];
                        for id in cls.members().iter(){
                            match storage.lookup(&id){
                                None => panic!("Memeber not found in IdentityStorage!"),
                                Some(name) => {
                                    v.push((id, name.name().clone()));
                                }
                            }
                        }
                        v
                    }
                }
            }
        }
    }

    pub fn cls_add_grade(&mut self, class_id: u128, name: String, values: Vec<(u32, u8)>){
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(mut cls) => {
                if cls.owner() != &env::signer_account_id() {
                    panic!("Only class owner can add grades!");
                }
                if cls.finalized(){
                    panic!("Cannot modify finalized class!");
                }
                for (m, _) in &values {
                    if !cls.contains_member(&m){
                        panic!("Referenced person is not a member.");
                    }
                }
                cls.add_grade(&name, class_id, &values);
                self.classes.insert(&class_id, &cls);
            }
        }
    }

    pub fn cls_get_grades(&self, class_id: u128, member_id: u32) -> Vec<(String, u64, Option<u8>)>{
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(cls) => {
                cls.get_grades(&member_id)
            }
        }
    }

    pub fn cls_finalize(&mut self, class_id: u128) {
        match self.classes.get(&class_id){
            None => panic!("No such Class!"),
            Some(mut cls) => {
                if cls.owner() != &env::signer_account_id() {
                    panic!("Only owner can finalize class!");
                }
                cls.finalize();
                self.classes.insert(&class_id, &cls);
            }
        }
    }

    pub fn p_get_classes(&self, storage_id: u128, id: u32) -> Vec<u128>{
        match self.storages.get(&storage_id){
            None => panic!("No such IdentityStorage!"),
            Some(storage) => {
                match storage.lookup(&id){
                    None => panic!("No such Person!"),
                    Some(person) => person.get_classes()
                }
            }
        }
    }
}

'''
'''--- near-contract/src/person.rs ---
use near_sdk::collections::UnorderedSet;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Person{
    name: String,
    classes: UnorderedSet<u128>
}

impl Person{
    /* Getters */
    pub fn name(&self) -> &String { &self.name }

    pub fn new(name: &String, storage_id: u128, id: u32) -> Self{
        let mut key = b"pcls".to_vec();
        key.extend_from_slice(&storage_id.to_le_bytes());
        key.extend_from_slice(&id.to_le_bytes());
        Self{
            name: name.clone(),
            classes: UnorderedSet::new(key)
        }
    }
    pub fn add_class(&mut self, class_id: &u128){
        self.classes.insert(class_id);
    }
    pub fn get_classes(&self) -> Vec<u128>{
        self.classes.to_vec()
    }
}

'''