*GitHub Repository "frol/near-workshop-2021"*

'''--- example/Cargo.toml ---
[package]
name = "example"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
inquire = "0.2.1"

'''
'''--- example/src/main.rs ---
use inquire::Text;

type AccountId = String;
type Message = String;

struct StatusBox {
    storage: std::collections::HashMap<AccountId, Message>,
}

impl StatusBox {
    pub fn new() -> Self {
        Self {
            //storage: std::collections::HashMap<AccountId, Message>::new(),
            storage: Default::default(),
        }
    }

    pub fn set_message(&mut self, username: AccountId, message: Message) {
        self.storage.insert(username, message);
    }

    pub fn get_message(&self, username: &AccountId) -> Option<&Message> {
        self.storage.get(username)
    }
}

fn main() {
    let mut status_box = StatusBox::new();

    loop {
        let command = Text::new("Какую команду выполнить?").prompt().unwrap();
        match command.as_str() {
            "get" => {
                let username = Text::new("Какой пользователь?").prompt().unwrap();
                if let Some(message) = status_box.get_message(&username) {
                    println!("Статус: {}", message);
                } else {
                    println!("Статус ещё не установлен для пользователя '{}'", username);
                }
            }
            "set" => {
                let username = Text::new("Какой пользователь?").prompt().unwrap();
                let message = Text::new("Укажите статус:").prompt().unwrap();
                status_box.set_message(username, message);
            }
            _ => {
                println!("Такой команды нет");
            }
        }
        println!();
    }
}

'''
'''--- social-rating/Cargo.toml ---
[package]
name = "social-rating"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0-pre.4"

[dev-dependencies]
matches = "0.1.9"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- social-rating/src/lib.rs ---
use near_sdk::{near_bindgen, PanicOnDefault};
use near_sdk::borsh::{self, BorshSerialize, BorshDeserialize};
use near_sdk::serde::Serialize;

const ONE_NEAR: near_sdk::Balance = 1_000_000_000_000_000_000_000_000;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
struct App;

#[near_bindgen]
impl App {
    #[init]
    pub fn new() -> Self {
        Self
    }

    /// Rate another user `other_user` on bahalf of the current user (`predecessor_account_id`)
    #[payable]
    pub fn rate(&mut self, other_user: &near_sdk::AccountId, vote: Vote) {
        assert!(near_sdk::env::attached_deposit() >= ONE_NEAR, "you must attach at least 1 NEAR to rate");
        assert!(vote >= 1 && vote <= 5, "score value must be in a range of [1; 5]");
        let current_user = near_sdk::env::predecessor_account_id();
        assert!(&current_user != other_user, "you cannot rate for yourself");

        // 1. prevent double-rating
        // assert!()
        // 2. update score of the other user
        let previous_score: Score = self.get_score(&other_user).unwrap_or_default();
        let other_user_score = Score {
            total_votes: previous_score.total_votes.checked_add(u64::from(vote)).expect("the user has reached the max total votes"),
            number_of_votes: previous_score.number_of_votes.checked_add(1).expect("the user has reached the max value for number of votes"),
        };
        near_sdk::env::storage_write(other_user.as_ref().as_bytes(), &other_user_score.try_to_vec().unwrap());

        // 3. update information about double-rating
    }

    pub fn get_score(&self, user: &near_sdk::AccountId) -> Option<Score> {
        //self.scores.get(user)
        let raw_score: Vec<u8> = near_sdk::env::storage_read(user.as_ref().as_bytes())?;
        let score: Score = Score::try_from_slice(&raw_score).expect("invalid internal storage state; cannot read Score from the storage");
        Some(score)
    }
}

// struct Vote {
//     vote_value: u8
// }
type Vote = u8;

#[derive(Debug, Default, BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
struct Score {
    total_votes: u64,
    number_of_votes: u64,
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use std::str::FromStr;

    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    use super::*;

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .is_view(is_view)
            .build()
    }

    #[test]
    fn it_works() {
        let mut context = get_context(false);
        context.attached_deposit = ONE_NEAR;

        let mut app = App::new();

        matches::assert_matches!(
            app.get_score(&near_sdk::AccountId::from_str("frol.near").unwrap()),
            None
        );

        context.predecessor_account_id = "bob2.near".to_string();
        testing_env!(context.clone());
        println!("rate #1");
        app.rate(&near_sdk::AccountId::from_str("frol.near").unwrap(), 5);
 
        matches::assert_matches!(
            app.get_score(&near_sdk::AccountId::from_str("frol.near").unwrap()),
            Some(Score { total_votes: 5, number_of_votes: 1 })
        );
       
        context.predecessor_account_id = "alice3.near".to_string();
        testing_env!(context.clone());
        println!("rate #2");
        app.rate(&near_sdk::AccountId::from_str("frol.near").unwrap(), 4);

        matches::assert_matches!(
            app.get_score(&near_sdk::AccountId::from_str("frol.near").unwrap()),
            Some(Score { total_votes: 9, number_of_votes: 2 })
        );
    }
}

'''
'''--- status-box/Cargo.toml ---
[package]
name = "status-box"
version = "0.1.0"
edition = "2018"

[dependencies]
near-sdk = "4.0.0-pre.4"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- status-box/README.md ---
Check that everything is compiling fine:

```
cargo check
```

Build Wasm binary:

```
cargo build --target wasm32-unknown-unknown --release
```

Call a read-only function (`get_message`) through JSON RPC via cURL:

```
curl https://rpc.testnet.near.org -H Content-Type:application/json -X POST --data '{"jsonrpc": "2.0", "id": "dontcare", "method": "query", "params": {"request_type": "call_function", "account_id": "frol-workshop-2021.testnet", "method_name": "get_message", "args_base64": "eyJ1c2VybmFtZSI6ICJmcm9sOS50ZXN0bmV0In0=", "finality": "final"}}'
```

Call a read-only function (`get_message`) through JSON RPC via near-cli:

```
./near-cli execute view-method network testnet contract frol-workshop-2021.testnet call get_message '{"username": "frol9.testnet"}' at-final-block
```

Call an update function (`set_message`) by submitting a transaction via near-cli:

```
./near-cli \
    execute change-method \
    network testnet \
    contract frol-workshop-2021.testnet \
    call set_message '{"username": "frol9.testnet", "message": "asd"}' \
        --attached-deposit '0 NEAR' \
        --prepaid-gas '100.000 TeraGas' \
    signer frol9.testnet \
    sign-with-keychain
```

NOTE: Update frol9.testnet with your own account id

WARNING: Based on our current implementation, `set_message` is allowed to set the message for any given `username`. We should use [`near_sdk::env::predecessor_account_id()`](https://docs.rs/near-sdk/3.1.0/near_sdk/env/fn.predecessor_account_id.html) to ensure the idendity rather than relying on the account id passed in the parameters. See the improved version [here](https://github.com/frol/near-workshop-2021/compare/improved-set-message)

'''
'''--- status-box/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;

type AccountId = String;
type Message = String;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, near_sdk::PanicOnDefault)]
pub struct StatusBox {
    // Read more: https://www.near-sdk.io/contract-structure/collections
    storage: near_sdk::collections::LookupMap<AccountId, Message>,
}

#[near_bindgen]
impl StatusBox {
    #[init]
    pub fn new() -> Self {
        Self {
            storage: near_sdk::collections::LookupMap::new(b"s"),
        }
    }

    pub fn set_message(&mut self, username: &AccountId, message: &Message) {
        self.storage.insert(&username, &message);
    }

    pub fn get_message(&self, username: &AccountId) -> Option<Message> {
        self.storage.get(username)
    }
}

'''