*GitHub Repository "marco-sundsk/near_rust_contract_example"*

'''--- README.md ---
# near_rust_contract_example
'''
'''--- storage-analyser/data/eg_whole.json ---
{
  "block_hash": "DCmFxgGYjnzBJkH3ry6xN4jhmfoVBYGSXTf3LorTygD1",
  "block_height": 68729201,
  "proof": [],
  "values": [
    {
      "key": "AAAAAAAAAAAA",
      "proof": [],
      "value": "AAAAAAABAAAAGwAAAHUxLnRlc3RuZXQ6dGhpcyBpcyBtc2cgb25lLg=="
    },
    {
      "key": "AAEAAAAAAAAA",
      "proof": [],
      "value": "AQEAAAAFAAAAAQEAAAABAAAA"
    },
    {
      "key": "AQEAAAAKAAAAdTEudGVzdG5ldA==",
      "proof": [],
      "value": "EAAAAHRoaXMgaXMgbXNnIHR3by4="
    },
    {
      "key": "AmUAAAAAAAAAAA==",
      "proof": [],
      "value": "CgAAAHUyLnRlc3RuZXQ="
    },
    {
      "key": "AmkKAAAAdTIudGVzdG5ldA==",
      "proof": [],
      "value": "AAAAAAAAAAA="
    },
    {
      "key": "U1RBVEU=",
      "proof": [],
      "value": "CgAAAHUxLnRlc3RuZXQCAAAAAAAAAAEAAAAAAgAAAAJpAQAAAAAAAAACAAAAAmUAAAAAAAAAAAAAAAAAAAAAAQAAAAoAAAB1Mi50ZXN0bmV0AAAAAA=="
    }
  ]
}
'''
'''--- storage-analyser/ncdl2_ex01.py ---
# 0 1 2 4 47 79 377 535
from near_rpc import NodeJsonProviderError,  NodeJsonProvider
import base64
import json
import time

def save2file(filename, json_obj):
    # print(json_obj)
    with open("data/eg_%s.json" % filename, mode='w', encoding="utf-8") as f:
        json.dump(json_obj, f, indent=2)
        print("File %s saved" % filename)

def fetch(prefix, filename=None):
    prefix_key = b''
    import base64
    if prefix:
        prefix_key = base64.b64encode(prefix)
        
    qurey_args = {
        "request_type": "view_state",
        "finality": "final",
        "account_id": "dev-1635142748034-53304986766242",
        "prefix_base64": prefix_key.decode(),
    }
    try:
        conn = NodeJsonProvider("https://rpc.testnet.near.org")
        ret = conn.query(qurey_args)

        if filename:
            save2file(filename, ret)

        import base64
        for item in ret['values']:
            print("key: ", base64.b64decode(item['key']))
            print("value: ", base64.b64decode(item['value']))

    except NodeJsonProviderError as e:
        print("RPC Error: ", e)
    except Exception as e:
        print("Error: ", e)

def analyse(filename):
    json_obj = None
    with open("data/eg_%s.json" % filename, mode='r', encoding="utf-8") as f:
        json_obj = json.load(f)
    print("File %s.json loaded" % filename)
    import base64

    for item in json_obj['values']:
        key = base64.b64decode(item['key'])
        if key == b'STATE':
            # this is contract main struct
            parse_main(base64.b64decode(item['value']))
            pass
        elif key.startswith(b'\x00'):
            parse_notebook(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x01'):
            parse_rich(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x02e'):
            parse_02e(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x02i'):
            parse_02i(key, base64.b64decode(item['value']))
        print()

def parse_02e(bytes_key, bytes_content):
    id = int.from_bytes(bytes_key[2:], 'little')
    value_length = int.from_bytes(bytes_content[0:4], 'little')
    value = bytes_content[4:4+value_length]
    print("Friends Unordered Sets %s -> %s" % (id, value))

def parse_02i(bytes_key, bytes_content):
    value_length = int.from_bytes(bytes_key[2:6], 'little')
    value = bytes_key[6:6+value_length]
    id = int.from_bytes(bytes_content, 'little')
    print("Friends Unordered Sets %s <- %s" % (value, id))

def parse_notebook(bytes_key, bytes_content):
    notebook_id = int.from_bytes(bytes_key[1:], 'little')
    print("notebook id: %s" % notebook_id)
    if bytes_content[0:1] == b'\x00':
        inner_id = int.from_bytes(bytes_content[1:5], 'little')
        notes_count = int.from_bytes(bytes_content[5:9], 'little')
        print("TextNoteBook id: %s, count: %s" % (inner_id, notes_count))
        if notes_count > 0:
            buffer = bytes_content[9:]
            for i in range(notes_count):
                note_length = int.from_bytes(buffer[0:4], 'little')
                note_content = buffer[4:4+note_length]
                buffer = buffer[4+note_length:]
                print("    note content: %s" % note_content)

    elif bytes_content[0:1] == b'\x01':
        inner_id = int.from_bytes(bytes_content[1:5], 'little')
        prefix_length_value = int.from_bytes(bytes_content[5:9], 'little')
        prefix = bytes_content[9:9+prefix_length_value]
        notes_count = int.from_bytes(bytes_content[9+prefix_length_value:9+prefix_length_value+4], 'little')
        print("RichNoteBook id: %s, prefix: %s, count: %s" % (inner_id, prefix, notes_count))
    else:
        print("Unknown bytes!")

def parse_rich(bytes_key, bytes_content):
    notebook_id = int.from_bytes(bytes_key[1:5], 'little')
    sender_length = int.from_bytes(bytes_key[5:9], 'little')
    sender = bytes_key[9:9+sender_length]

    value_length = int.from_bytes(bytes_content[0:4], 'little')
    value = bytes_content[4:4+value_length]

    print("    RichNoteBook#%s has a note from %s, content is %s" % (notebook_id, sender, value))

def parse_main(bytes_content):
    buffer = bytes_content[:]
    
    owner_length = buffer[0:4]
    owner_length_value = int.from_bytes(owner_length, 'little')
    buffer = buffer[4:]
    owner = buffer[:owner_length_value].decode()
    buffer = buffer[owner_length_value:]

    vector_length = buffer[0:8]
    vector_length_value = int.from_bytes(vector_length, 'little')
    buffer = buffer[8:]
    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_v = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]

    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_us1 = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]
    set_length = buffer[0:8]
    set_length_value = int.from_bytes(set_length, 'little')
    buffer = buffer[8:]
    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_us2 = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]

    balance = buffer[0:16]
    balance_value = int.from_bytes(balance, 'little')
    buffer = buffer[16:]

    hashmap_length = buffer[0:4]
    hashmap_length_value = int.from_bytes(hashmap_length, 'little')
    buffer = buffer[4:]
    

    print("Main Structure:----------------")
    print("Owner: %s" % (owner))
    print("Vector length: %s" % (vector_length_value))
    print("Vector prefix: %s" % (prefix_v))
    print("UnorderedSet length: %s" % (set_length_value))
    print("UnorderedSet prefix1: %s, prefix2: %s" % (prefix_us1, prefix_us2))
    print("Balance : %s" % (balance_value))
    print("hashmap length : %s" % (hashmap_length_value))

    for i in range(hashmap_length_value):
        key_length = int.from_bytes(buffer[0:4], 'little')
        key = buffer[4:4+key_length]
        value = int.from_bytes(buffer[4+key_length:4+key_length+4], 'little')
        print("    friend %s has rate %s" % (key, value))

     

if __name__ == '__main__':

    # fetch(None, "whole")
    analyse("whole")

'''
'''--- storage-analyser/near_rpc.py ---
import requests
import base64
import json

class NodeJsonProviderError(Exception):
    pass

class NodeJsonProvider(object):

    def __init__(self, node):
        self._rpc_addr = node

    def rpc_addr(self):
        return self._rpc_addr

    def json_rpc(self, method, params, timeout=300):
        j = {
            'method': method,
            'params': params,
            'id': 0,
            'jsonrpc': '2.0'
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout)
        r.raise_for_status()
        content = json.loads(r.content)
        if "error" in content:
            raise NodeJsonProviderError(content["error"])
        return content["result"]

    def send_tx(self, signed_tx):
        return self.json_rpc('broadcast_tx_async', [base64.b64encode(signed_tx).decode('utf8')])

    def send_tx_and_wait(self, signed_tx, timeout):
        return self.json_rpc('broadcast_tx_commit', [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def get_status(self):
        r = requests.get("%s/status" % self.rpc_addr(), timeout=2)
        r.raise_for_status()
        return json.loads(r.content)
    
    def rpc_status(self):
        return self.json_rpc('status', [None])

    def get_validators(self):
        return self.json_rpc('validators', [None])

    def query(self, query_object):
        return self.json_rpc('query', query_object)

    def get_account(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_account", "account_id": account_id, "finality": finality})

    def get_access_key_list(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key_list", "account_id": account_id, "finality": finality})

    def get_access_key(self, account_id, public_key, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key", "account_id": account_id,
                                       "public_key": public_key, "finality": finality})

    def view_call(self, account_id, method_name, args, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "call_function", "account_id": account_id,
                                       "method_name": method_name, "args_base64": base64.b64encode(args).decode('utf8'), "finality": finality})

    def get_block(self, block_id):
        return self.json_rpc('block', [block_id])

    def get_chunk(self, chunk_id):
        return self.json_rpc('chunk', [chunk_id])

    def get_tx(self, tx_hash, tx_recipient_id):
        return self.json_rpc('tx', [tx_hash, tx_recipient_id])

    def get_changes_in_block(self, changes_in_block_request):
        return self.json_rpc('EXPERIMENTAL_changes_in_block', changes_in_block_request)

    def ping_node(self):
        ret = {'latest_block_height': 0, 'syncing': True}

        try:
            # status = self.get_status()
            status = self.rpc_status()
            print(status)
            if "sync_info" in status:
                ret['latest_block_height'] = status['sync_info']['latest_block_height']
                ret['syncing'] = status['sync_info']['syncing']
        except NodeJsonProviderError as e:
            print("ping node MultiNodeJsonProviderError: ", e)
        except Exception as e:
            print("ping node Exception: ", e)
    
        return ret

if __name__ == "__main__":
    pass

    
'''
'''--- storage-analyser/requirements.txt ---
base58==2.1.0
requests==2.26.0
'''
'''--- storage-demo/Cargo.toml ---
[package]
name = "storage-demo"
version = "0.0.1"
authors = ["Marco <sun.dsk1@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.2.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- storage-demo/build.sh ---
#!/bin/bash
set -e
pushd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./res
cp target/wasm32-unknown-unknown/release/storage_demo.wasm ./res/storage_demo.wasm

popd

'''
'''--- storage-demo/src/lib.rs ---
use std::collections::HashMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedSet, Vector};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey,PanicOnDefault, 
};

use note::{NoteBook, TextNoteBook, RichNoteBook};

mod note;

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Notes,
    RichNotes { notes_id: u32 },
    Friends,
}

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub notes: Vector<NoteBook>,
    pub friends: UnorderedSet<AccountId>,
    pub total_balance: Balance,
    pub friend_rate: HashMap<AccountId, u32>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
    ) -> Self {
        Self {
            owner_id: owner_id.into(),
            notes: Vector::new(StorageKey::Notes),
            friends: UnorderedSet::new(StorageKey::Friends),
            total_balance: 0,
            friend_rate: HashMap::new(),
        }
    }

    pub fn add_text_notebook(&mut self) -> u32 {
        let id = self.notes.len() as u32;
        let notebook = NoteBook::TextNoteBook(TextNoteBook::new(id));   
        self.notes.push(&notebook);
        id
    }

    pub fn add_rich_notebook(&mut self) -> u32 {
        let id = self.notes.len() as u32;
        let notebook = NoteBook::RichNoteBook(RichNoteBook::new(id));   
        self.notes.push(&notebook);
        id
    }

    pub fn add_notes(&mut self, notebook_id: u32, content: String) {
        let sender_id = env::predecessor_account_id();
        let mut notebook = self.notes.get(notebook_id.into()).expect("ERR_NO_NOTEBOOK");
        notebook.add_notes(&sender_id, &content);
        self.notes.replace(notebook_id.into(), &notebook);
    }

    pub fn add_friends(&mut self, friends: Vec<ValidAccountId>) {
        for friend in friends {
            self.friends.insert(friend.as_ref());
            self.friend_rate.insert(friend.into(), 0);
        }
    }

    pub fn remove_friends(&mut self, friends: Vec<ValidAccountId>) {
        for friend in friends {
            self.friends.remove(friend.as_ref());
        }
    }
}

'''
'''--- storage-demo/src/note.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId};
use near_sdk::collections::LookupMap;

use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub enum NoteBook {
    TextNoteBook(TextNoteBook),
    RichNoteBook(RichNoteBook),
}

impl NoteBook {
    /// Returns pool kind.
    pub fn kind(&self) -> String {
        match self {
            NoteBook::TextNoteBook(_) => "Text_NoteBook".to_string(),
            NoteBook::RichNoteBook(_) => "Rich_NoteBook".to_string(),
        }
    }

    pub fn add_notes(&mut self, sender_id: &String, content: &String) {
        match self {
            NoteBook::TextNoteBook(notebook) => notebook.add_notes(sender_id, content),
            NoteBook::RichNoteBook(notebook) => notebook.add_notes(sender_id, content),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct TextNoteBook {
    pub id: u32,
    pub notes: Vec<String>,
}

impl TextNoteBook {
    pub fn new(id: u32) -> Self {
        Self {
            id,
            notes: Vec::new(),

        }
    }

    pub fn add_notes(&mut self, sender_id: &String, content: &String) {
        let record = format!("{}:{}", sender_id, content);
        self.notes.push(record);
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct RichNoteBook {
    pub id: u32,
    pub notes: LookupMap<AccountId, String>,
    pub count: u32,
}

impl RichNoteBook {
    pub fn new(id: u32) -> Self {
        Self {
            id,
            notes: LookupMap::new(StorageKey::RichNotes { notes_id: id }),
            count: 0,
        }
    }

    pub fn add_notes(&mut self, sender_id: &String, content: &String) {
        self.notes.insert(sender_id, content);
        self.count += 1;
    }
}
'''