*GitHub Repository "near-ndc/ndc-dashboard"*

'''--- .github/workflows/main.yml ---
name: Dashboard CI/CD

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: Ubuntu-22.04
    steps:

      - uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: rustfmt, clippy

      - name: Deploy to Production
        uses: appleboy/ssh-action@master
        with:
          username: ${{ secrets.SERVER_USER }}
          host: ${{ secrets.SERVER_IP }}
          password: ${{ secrets.SERVER_PASSWORD }}
          script: |
            cd ~/Projects/ndc-dashboard-v2/
            git fetch origin main
            git reset --hard origin/main
            rustup target add wasm32-unknown-unknown
            npm install
            cd ./server && npm install && cd ..
            npm run substreams:build
            npm run server:restart:production

'''
'''--- .prettierrc.json ---
{
  "tabWidth": 2,
  "semi": true,
  "singleQuote": false
}

'''
'''--- dummy-check-in-contract/Cargo.toml ---
[package]
name = "dummy-check-in-contract"
description = "dummy contract to get DAO ability to onboard users "
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "5.0.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- dummy-check-in-contract/README.md ---
# dummy-check-in-contract

The dummy contract allows contractless DAO to onboard users by their iniatives.

## How to Build Locally?

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near build
```

## How to Deploy?

Deployment is automated with GitHub Actions CI/CD pipeline.
To deploy manually, install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near deploy <account-id>
```

'''
'''--- dummy-check-in-contract/rust-toolchain.toml ---
[toolchain]
channel = "stable"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]

'''
'''--- dummy-check-in-contract/src/lib.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::env::log_str;
use near_sdk::{env, near_bindgen};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
#[borsh(crate = "near_sdk::borsh")]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    pub fn check_in(&mut self) {
        let user = env::signer_account_id();
        log_str(&format!("User {user} has checked in"));
    }
}

'''
'''--- package.json ---
{
  "name": "near-dashboard",
  "version": "2.0.0",
  "description": "NEAR Dashboard",
  "main": "index.js",
  "keywords": [
    "NEAR",
    "dashboard",
    "substreams"
  ],
  "author": "Vlodkow",
  "license": "ISC",
  "scripts": {
    "server:start:local": "cd server && env $(cat ../.env.local) npm run start:local",
    "server:start:production": "cd server && env $(cat ../.env.production) pm2 start ./index.js --name ndc-dashboard --update-env",
    "server:restart:production": "cd server && env $(cat ../.env.production) pm2 restart ./index.js --name ndc-dashboard --update-env",
    "server:logs:production": "pm2 logs ndc-dashboard --lines 500",
    "substreams:build": "cd substreams && make protogen && cargo build --target wasm32-unknown-unknown --release",
    "substreams:init:local": "cd substreams && ./bin/init_substreams.sh ../.env.local",
    "substreams:start:local": "cd substreams && ./bin/start_substreams.sh ../.env.local",
    "substreams:init:production": "cd substreams && ./bin/init_substreams.sh ../.env.production",
    "substreams:rorate_token:local": "cd substreams && ./bin/rotate_substreams_token.sh ../.env.local",
    "substreams:rorate_token:production": "cd substreams && ./bin/rotate_substreams_token.sh ../.env.production && systemctl restart substreams-sink.service",
    "test:tools": "jest tools/lib.test.js",
    "dev": "node tools/dev.js",
    "deploy": "node tools/deploy.js",
    "upload": "node tools/upload.js",
    "pretty": "prettier --write '**/*.{js,jsx,ts,tsx,json,jsonc}'",
    "build": "npm run pretty -- --log-level warn && node tools/build.js",
    "clean": "rm -rf build",
    "near": "near",
    "bos": "bos"
  },
  "dependencies": {
    "@bufbuild/buf": "^1.30.0"
  },
  "devDependencies": {
    "bos-cli": "^0.3.2",
    "chokidar": "^3.5.3",
    "express": "^4.18.2",
    "jest": "^29.6.2",
    "mock-fs": "^5.2.0",
    "near-cli-rs": "^0.4.3",
    "prettier": "^3.0.1"
  }
}

'''
'''--- readme.md ---
# NEAR Dashboard

The NEAR Dashboard is a sophisticated tool designed to store, analyze, and present data from the NEAR blockchain.

## Requirements

- Node.js 16+
- Rust 1.72+
- [substreams](https://github.com/streamingfast/substreams/releases)
- [substreams-sink-sql](https://github.com/streamingfast/substreams-sink-sql/releases)
- Redis

## Install dependencies

```bash
npm install && cd server && npm install
```

## Local Development

### Configuration

Copy the example environment variables file and update it with your specific configurations:

```bash
cp .env.example .env.local
```

Note: To get SUBSTREAMS_API_TOKEN, you need to follow [Substreams Auth Documentation](https://substreams.streamingfast.io/documentation/consume/authentication).

### Initialize the Clickhouse Database

```bash
npm run substreams:build
npm run substreams:init:local
```

### Start Substreams

Launch the substreams to begin data synchronization:

```bash
npm run substreams:start:local
```

### Start Server

Finally, start the server to access the dashboard endpoints:

```bash
npm run server:start:local
```

## Production

### Configuration

Copy the example environment variables file and update it with your specific configurations:

```bash
cp .env.example .env.production
```

### Initialize the Clickhouse Database

```bash
npm run substreams:build
npm run substreams:init:production
```

### Rotate JWT Token

Use next command to rotate the JWT Token each 2 weeks:

```bash
npm run substreams:rorate_token:production
```
Command require SUBSTREAMS_API_KEY in environment variables.

### Start Substreams

We use systemd to manage the substreams sync service.

### Create a systemd service file for substreams

```bash
touch /etc/systemd/system/substreams-sink.service
```

Add the following content to the file:

```bash
[Unit]
Description=Substreams Sink to Clickhouse
After=network.target

[Service]
Type=simple
EnvironmentFile=/path/to/ndc-dashboard-v2/.env.production
ExecStart=/bin/bash -c 'exec substreams-sink-sql run "$DB_CONNECTION" /path/to/ndc-dashboard-v2/substreams/substreams.clickhouse.yaml --undo-buffer-size 50000 --on-module-hash-mistmatch warn'
Restart=on-failure
RestartSec=5s
StandardOutput=append:/var/log/substreams_sink_mainnet.log
StandardError=append:/var/log/substreams_sink_mainnet_err.log

[Install]
WantedBy=multi-user.target
```

NOTE: replace /path/to/ndc-dashboard-v2/ with the actual path to the project directory.

### Start Substreams Service

```bash
sudo systemctl daemon-reload
sudo systemctl start substreams-sink.service
sudo systemctl enable substreams-sink.service
```

### Start Server

Finally, start the server to access the dashboard endpoints:

```bash
npm run server:start:production
```

#### Server Endpoints:

Dashboard API URL: https://dashboard.chatme.page/

Endpoints:
```
/api/total - General Stats
/api/user-retention - User Retention
/api/dapps-used - Dapps Used
/api/social-engagement - Social Engagement
/api/acquisition-cost - Acquisition Cost
/api/daily-stats - Daily Transactions and unique active Users
```

#### Filter parameters available for all endpoints:

```
start_date: string (YYYY-MM-DD), required
end_date: string (YYYY-MM-DD), required
dao_list: string (?dao_list=[1,2,3]), optional
```

'''
'''--- server/api/app.js ---
import express from "express";
import cors from "cors";
import { corsConfig } from "./config/cors.config.js";
import { routes } from "./routes.js";

export const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(cors(corsConfig));

app.use("/api", routes);

'''
'''--- server/api/config/cors.config.js ---
export const corsConfig = {
  origin: [
    "http://localhost:3000",
    "https://near.org",
    "https://near.social",
  ],
  methods: "GET,OPTION,HEAD",
  optionsSuccessStatus: 200,
};

'''
'''--- server/api/config/database.config.js ---
export const DB_REQUEST_TIMEOUT = 60_000;
export const MAX_OPEN_CONNECTIONS = 50;

'''
'''--- server/api/controllers/acquisition_cost.js ---
import { connectDatabase, daoMappingSql } from "../helpers/database.helper.js";
import {
  getCommunityAccountsPerDao,
  getCommunityWalletsPerDao,
} from "../helpers/near.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";

const SELECT = `
/* We load first all the users onboarded by the DAO */
, dao_user as (
    SELECT
        t.signer_id, argMin(dao.dao_id, t.block_timestamp) AS dao_id,
        min(t.block_timestamp) as onboard_time
    FROM
        transactions as t
        INNER JOIN dao_to_contracts_map AS dao ON (t.receiver_id = dao.id)
    GROUP BY
        t.signer_id
),
/* We filter user that were onboarded during the date range */
users_per_dao as (
    select
        dao_id, count(*) as users
    from
        dao_user
    where
        dao_user.onboard_time between { val1: DateTime } and { val2: DateTime }
    group by
        dao_id
),
amount_per_dao as (
    SELECT
        wallets.dao_id, sum(ra.deposit) as total
    FROM
        receipt_actions AS ra
        INNER JOIN dao_to_wallets_map AS wallets ON ra.predecessor_id = wallets.id
    WHERE
        ra.status = 'Success' and ra.block_timestamp between { val1: DateTime } and { val2: DateTime }
    GROUP BY
        wallets.dao_id
)
SELECT
    u.dao_id, if(u.users > 0, divide(a.total, u.users), NULL) as cost
from
    users_per_dao as u
    join amount_per_dao as a on (a.dao_id = u.dao_id)
`;

/**
 *
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetAcquisitionCost = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);

  const dbClient = connectDatabase();

  const contractsPerDao = await getCommunityAccountsPerDao(daoList);
  const walletsPerDao = await getCommunityWalletsPerDao(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  const contracts_map = daoMappingSql("dao_to_contracts_map", contractsPerDao);
  const wallets_map = daoMappingSql("dao_to_wallets_map", walletsPerDao, false);

  const resultSet = await dbClient.query({
    query: contracts_map + "," + wallets_map + SELECT,
    query_params: {
      val1: startDate,
      val2: endDate,
    },
    format: "JSONEachRow",
  });

  const json = await resultSet.json();
  let results = {};

  json.forEach((element) => {
    results[element["dao_id"]] = element["cost"];
  });

  return response.json(results);
};

'''
'''--- server/api/controllers/daily_stats.js ---
import { connectDatabase } from "../helpers/database.helper.js";
import {
  getCommunityAccounts,
} from "../helpers/near.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";

const SELECT = `SELECT
    toDate(block_timestamp) AS day,
    COUNT(1) AS total_transactions,
    COUNT(DISTINCT signer_id) AS unique_wallets
    FROM transactions
    WHERE block_timestamp BETWEEN {startDate: DateTime} AND {endDate: DateTime}
      AND receiver_id IN ({smartContractList: Array(String)})
    GROUP BY toDate(block_timestamp)
    ORDER BY day ASC`;

/**
 *
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetDailyStats = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);

  const dbClient = connectDatabase();
  const smartContractList = await getCommunityAccounts(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  const resultSet = await dbClient.query({
    query: SELECT,
    query_params: {
      startDate,
      endDate,
      smartContractList,
    },
    format: "JSONEachRow",
  });

  const json = await resultSet.json();

  return response.json({
    data: json,
  });
};

'''
'''--- server/api/controllers/dapps_used.js ---
import { connectDatabase, daoMappingSql } from "../helpers/database.helper.js";
import { getCommunityAccountsPerDao } from "../helpers/near.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";

const SELECT = `
, users_per_dao as (
    SELECT
        dao.dao_id,
        t.signer_id
    from
        transactions t
        JOIN dao_to_contracts_map as dao on (dao.id = t.receiver_id)
    WHERE
        t.block_timestamp between {val1: DateTime} and {val2: DateTime} 
    GROUP BY
        (dao.dao_id, t.signer_id)
)
Select
    dao_id, median(total) as median
from
    (
        select users.dao_id as dao_id, COUNT(distinct t.receiver_id) as total
        from
            transactions t
            join dao_to_contracts_map as dao on (dao.id = t.receiver_id)
            join users_per_dao as users on (
                dao.dao_id = users.dao_id
                and t.signer_id = users.signer_id
            )
        where
            t.block_timestamp between {val1: DateTime} and {val2: DateTime} 
        group by
            (users.dao_id, t.signer_id)
    )
group by
    dao_id
`;

/**
 *
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetDappsUsed = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);

  const dbClient = connectDatabase();
  const contractsPerDao = await getCommunityAccountsPerDao(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  const contracts_map = daoMappingSql("dao_to_contracts_map", contractsPerDao);

  const resultSet = await dbClient.query({
    query: contracts_map + SELECT,
    query_params: {
      val1: startDate,
      val2: endDate,
    },
    format: "JSONEachRow",
  });

  const json = await resultSet.json();

  const results = {};
  json.forEach((element) => {
    results[element["dao_id"]] = element["median"];
  });

  return response.json(results);
};

'''
'''--- server/api/controllers/social_engagement.js ---
import { connectDatabase, daoMappingSql } from "../helpers/database.helper.js";
import { getCommunityAccountsPerDao } from "../helpers/near.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";

const SELECT = `
, dao_user as (
    SELECT
        t.signer_id, argMin(dao.dao_id, t.block_timestamp) AS dao_id
    FROM
        transactions as t
        INNER JOIN dao_to_contracts_map AS dao ON t.receiver_id = dao.id
    GROUP BY
        t.signer_id
)
select dao.dao_id as dao_id, sum(ra.social_score) as score
from
    transactions as t
    inner join dao_user as dao on (dao.signer_id = t.signer_id)
    inner join (
        select
            ra.receipt_id,
            multiIf(
                ra.social_kind = 'Post',
                10,
                ra.social_kind = 'Comment',
                3,
                ra.social_kind = 'Like',
                1,
                0
            ) as social_score
        from
            receipt_actions as ra
        where
            ra.status = 'Success'
            and ra.block_timestamp between { val1: DateTime } and { val2: DateTime }
            and ra.receiver_id = 'social.near'
    ) AS ra ON ra.receipt_id = t.receipt_id
where
    t.receiver_id = 'social.near'
    and t.block_timestamp between { val1: DateTime } and { val2: DateTime }
group by
    dao.dao_id
`;

/**
 *
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetSocialEngagement = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);

  const dbClient = connectDatabase();
  const contractsPerDao = await getCommunityAccountsPerDao(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  const contracts_map = daoMappingSql("dao_to_contracts_map", contractsPerDao);

  const resultSet = await dbClient.query({
    query: contracts_map + SELECT,
    query_params: {
      val1: startDate,
      val2: endDate,
    },
    format: "JSONEachRow",
  });

  const json = await resultSet.json();
  let results = {};

  json.forEach((element) => {
    results[element["dao_id"]] = element["score"];
  });

  return response.json(results);
};

'''
'''--- server/api/controllers/total_info.js ---
import { utils } from "near-api-js";
import { connectDatabase } from "../helpers/database.helper.js";
import { getCommunityAccounts, newConnection } from "../helpers/near.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";

const SELECT_TOTAL = `SELECT 
        COUNT(1) as total,
        COUNT(DISTINCT signer_id) as accounts
        FROM transactions WHERE block_timestamp BETWEEN {startDate: DateTime} AND {endDate: DateTime} 
                          AND receiver_id IN ({smartContractList: Array(String)})
        `;

const SELECT_ACTIVE_24H = `SELECT 
        COUNT(DISTINCT signer_id) as accounts
        FROM transactions WHERE block_timestamp >= now() - INTERVAL 1 DAY 
                          AND receiver_id IN ({smartContractList: Array(String)})
        `;

// Get balance of NDC smart-contract: latest or by block number
const getBalanceNDC = async (blockId = null) =>{
  const connection = await newConnection("https://archival-rpc.mainnet.near.org");
  const params = {
    request_type: "view_account",
    account_id: "ndctrust.sputnik-dao.near",
  }

  if (blockId) {
    params.block_id = blockId;
  } else{
    params.finality = "final";
  }

  const result = await connection.provider.query(params);
  const amount = utils.format.formatNearAmount(result.amount, 0);
  return parseInt(amount.replaceAll(",", ""));
}

/**
 * Get total stats
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetTotalInfo = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);

  const dbClient = connectDatabase();
  const smartContractList = await getCommunityAccounts(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  let startAmount = await getBalanceNDC(108126451);
  let currentAmount = await getBalanceNDC();

  const totalTxQuery = await dbClient.query({
    query: SELECT_TOTAL,
    query_params: {
      startDate,
      endDate,
      smartContractList,
    },
    format: "JSONEachRow",
  });
  const totalTx = await totalTxQuery.json();

  const activeUsersQuery = await dbClient.query({
    query: SELECT_ACTIVE_24H,
    query_params: {
      smartContractList,
    },
    format: "JSONEachRow",
  });
  const activeUsers = await activeUsersQuery.json();

  return response.json({
    data: {
      transactions: totalTx[0].total,
      accounts: totalTx[0].accounts,
      active_users: activeUsers[0].accounts,
      totalBalance: currentAmount,
      distributed: startAmount - currentAmount,
    },
  });
};

'''
'''--- server/api/controllers/user_retention.js ---
import { connectDatabase, daoMappingSql } from "../helpers/database.helper.js";
import { parseFilterParams } from "../helpers/request.helper.js";
import { getCommunityAccountsPerDao } from "../helpers/near.helper.js";

const SELECT = `
, dao_user as (
    SELECT
        t.signer_id, argMin(dao.dao_id, t.block_timestamp) AS dao_id,
        min(t.block_timestamp) as onboarded
    FROM
        transactions as t
        INNER JOIN dao_to_contracts_map AS dao ON t.receiver_id = dao.id
    GROUP BY
        t.signer_id
),
-- transaction per month/day/week by every onboarded dao user
user_transactions as (
    select
        dao.dao_id as dao_id, t.signer_id as signer_id
    from
        transactions t
        join dao_user as users on (users.signer_id = t.signer_id)
        join (
            SELECT
                *
            from
                dao_to_contracts_map
            -- We add social.near for activity retention calculation after user was onboarded
            UNION ALL
            SELECT
                distinct dao_id,
                'social.near'
            from
                dao_to_contracts_map
        ) as dao on (
            dao.id = t.receiver_id
            and dao.dao_id = users.dao_id
        )
    where
        t.block_timestamp between {val1: DateTime} and {val2: DateTime} 
        -- We are curious only of transaction after onboarding
        and t.block_timestamp > users.onboarded
    group by
        (
            dao.dao_id,
            t.signer_id,
            formatDateTime(t.block_timestamp, {val3: String})
        )
)
select
    dao_id,
    median(transactions) as median
from
    (
        -- Count transactions per dao-user
        select
            dao_id,
            count(*) as transactions
        from
            user_transactions
        group by
            (dao_id, signer_id)
    )
group by
    dao_id
`;

/**
 * Get user retention stats
 * @param {import("express").Request} request
 * @param {import("express").Response} response
 */
export const GetUserRetention = async (request, response) => {
  const { startDate, endDate, daoList } = parseFilterParams(request, response);
  const method = request.query.method ?? "Monthly";

  const dbClient = connectDatabase();
  const contractsPerDao = await getCommunityAccountsPerDao(daoList);

  if (dbClient === undefined) {
    console.error("Failed to initialize db");
    return response.status(500).json({});
  }

  let timeformat;
  if (method == "Daily") {
    timeformat = "%D";
  } else if (method == "Weekly") {
    timeformat = "%Y %V";
  } else {
    timeformat = "%Y %m";
  }

  const contracts_map = daoMappingSql("dao_to_contracts_map", contractsPerDao);

  const resultSet = await dbClient.query({
    query: contracts_map + SELECT,
    query_params: {
      val1: startDate,
      val2: endDate,
      val3: timeformat,
    },
    format: "JSONEachRow",
  });

  const json = await resultSet.json();
  let results = {};

  json.forEach((element) => {
    results[element["dao_id"]] = element["median"];
  });

  return response.json(results);
};

'''
'''--- server/api/cron.js ---
import {schedule} from "node-cron";
import { getRequestDateRanges } from "./helpers/datetime.helper.js";
import {getDaoIdList} from "./helpers/near.helper.js";

const API_BASE_URL = process.env.API_BASE_URL;
const daoIdList = await getDaoIdList();
const timeRequestDelay = 30000;

const createRequest = async (url, startDate, endDate) =>{
    const callURL = `${API_BASE_URL}${url}?start_date=${startDate}&end_date=${endDate}&dao_list=${JSON.stringify(daoIdList)}`;
    await fetch(callURL);
}

// cron job to update cache
export async function initializeCron() {

    // /api/total
    schedule("0 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/total", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });

    // /api/daily-stats
    schedule("3 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/daily-stats", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });

    // /api/user-retention
    schedule("6 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/user-retention", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });

    // /api/dapps-used
    schedule("9 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/dapps-used", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });

    // /api/social-engagement
    schedule("12 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/social-engagement", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });

    // /api/acquisition-cost
    schedule("15 * * * *", () => {
        getRequestDateRanges().forEach(([startDate, endDate], index) => {
            setTimeout(() => {
                createRequest("/api/acquisition-cost", startDate, endDate);
            }, index * timeRequestDelay);
        });
    });
}

'''
'''--- server/api/helpers/database.helper.js ---
import { createClient } from "@clickhouse/client";
import {
  DB_REQUEST_TIMEOUT,
  MAX_OPEN_CONNECTIONS,
} from "../config/database.config.js";

export function connectDatabase() {
  try {
    const config = parseClickHouseURL(process.env.DB_CONNECTION);
    const hostURL = `http://${config.host}:8123`;

    return createClient({
      host: hostURL,
      request_timeout: DB_REQUEST_TIMEOUT,
      compression: {
        response: true,
        request: true,
      },
      username: config.username.trim(),
      password: config.password.trim(),
      database: config.database.trim(),
      max_open_connections: MAX_OPEN_CONNECTIONS,
    });
  } catch (error) {
    console.error(error.message);
  }
}

function parseClickHouseURL(url) {
  if (!url) {
    throw new Error("URL is empty");
  }

  const urlPattern = /^clickhouse:\/\/([^:]+):([^@]*)@([^:]+):(\d+)\/([^\/]+)$/;

  const match = url.match(urlPattern);
  if (!match) {
    throw new Error("URL is not in the correct format");
  }

  const [_, username, password, host, port, database] = match;
  return { host, port, username, password, database };
}

export function daoMappingSql(name, contractsPerDao, addWith = true) {
  const withStmnt = addWith ? "WITH " : "";
  return (
    `${withStmnt} ${name} AS (
        SELECT
            dao_id,
            arrayJoin(contracts) AS id
        FROM (
            SELECT
                dao_contracts.1 AS dao_id,
                dao_contracts.2 AS contracts
            FROM (
    ` +
    Object.entries(contractsPerDao)
      .filter(([_, value]) => value.length > 0)
      .map(([key, value]) => {
        return `SELECT tuple('${key}', [${value.map((a) => `'${a}'`).join(", ")}]) as dao_contracts`;
      })
      .join("\nUNION ALL\n") +
    `)
    )
)`
  );
}

'''
'''--- server/api/helpers/datetime.helper.js ---
export const formatDate = (date)=> {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
}

export const getToday = () => {
    const date = new Date();
    return formatDate(date);
}

export const getYesterday = () =>{
    const date = new Date();
    date.setDate(date.getDate() - 1);
    return formatDate(date);
}

export const getDateDaysAgo = (days)=> {
    const date = new Date();
    date.setDate(date.getDate() - days);
    return formatDate(date);
}

export const getFirstDayOfCurrentMonth = ()=> {
    const date = new Date();
    date.setDate(1);
    return formatDate(date);
}

export const getFirstDayOfPreviousMonth = ()=> {
    const date = new Date();
    date.setMonth(date.getMonth() - 1, 1);
    return formatDate(date);
}

export const getLastDayOfPreviousMonth = ()=> {
    const date = new Date();
    date.setDate(0);
    return formatDate(date);
}

export const getRequestDateRanges = () => {
    return [
        [getToday(), getToday()],
        [getYesterday(), getYesterday()],
        [getDateDaysAgo(6), getToday()],
        [getDateDaysAgo(29), getToday()],
        [getFirstDayOfCurrentMonth(), getToday()],
        [getFirstDayOfPreviousMonth(), getLastDayOfPreviousMonth()]
    ];
}
'''
'''--- server/api/helpers/near.helper.js ---
import { connect, keyStores, Contract } from "near-api-js";

export const newConnection = async (nodeUrl = 'https://rpc.mainnet.near.org') => {
  const myKeyStore = new keyStores.InMemoryKeyStore();
  // const PRIVATE_KEY = process.env.PRIVATE_KEY;
  // if(!PRIVATE_KEY){
  //   throw new Error("Please provide a private key");
  // }
  //
  // const keyPair = KeyPair.fromString(PRIVATE_KEY);
  // await myKeyStore.setKey("mainnet", "backup-dao.near", keyPair);

  const near = await connect({
    networkId: "mainnet",
    keyStore: myKeyStore,
    nodeUrl,
    walletUrl: "https://wallet.mainnet.near.org",
    helperUrl: "https://helper.mainnet.near.org",
    explorerUrl: "https://nearblocks.io",
  });

  return near.connection;
}

export const nearContractDAO = async () => {
  const connection = await newConnection();
  return new Contract(connection, process.env.DAO_SMART_CONTRACT.trim(), {
    viewMethods: ["get_community_accounts", "get_dao_list", "get_dao_accounts"],
    changeMethods: [],
    useLocalViewExecution: true
  });
};

// Get all smart contracts for a given DAO list
export const getCommunityAccountsPerDao = async (daoList) => {
  const contract = await nearContractDAO();
  return await contract.get_community_accounts({
    dao_list: daoList,
  });
};

export const getDaoIdList = async () => {
  const contract = await nearContractDAO();
  const daoList = await contract.get_dao_list();

  return daoList.map((dao) => {
    return dao.id;
  });
};

export const getCommunityWalletsPerDao = async () => {
  const contract = await nearContractDAO();
  const daoAccounts = await contract.get_dao_accounts();
  
  let result = {};
  Object.keys(daoAccounts).forEach((key) => {
    if (daoAccounts[key]) {
      result[parseInt(key)] = daoAccounts[key];
    }
  });

  return result;
};

// Get all smart contracts for a given DAO list
export const getCommunityAccounts = async (daoList) => {
  const smartContracts = await getCommunityAccountsPerDao(daoList);
  let allSmartContracts = [];
  if (Object.keys(smartContracts).length > 0) {
    for (const key in smartContracts) {
      allSmartContracts = allSmartContracts.concat(smartContracts[key]);
    }
  }

  return allSmartContracts;
};

'''
'''--- server/api/helpers/request.helper.js ---
export const parseFilterParams = (request, response) => {
  const startDate = request.query.start_date;
  const endDate = request.query.end_date;

  let daoList = null;

  if (!startDate || !endDate) {
    return response.status(400).json({ error: "Missing required parameters" });
  }

  const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateFormatRegex.test(startDate) || !dateFormatRegex.test(endDate)) {
    return response.status(400).send({ error: 'Date must be in YYYY-MM-DD format.' });
  }

  if (request.query.dao_list) {
    try {
      daoList = JSON.parse(request.query.dao_list);
      if (!Array.isArray(daoList)) {
        throw new Error();
      }
    } catch (error) {
      // Handles both JSON.parse failures and non-array dao_list
      return response.status(400).json({
        error: "Wrong format for dao_list parameter. Expected an array.",
      });
    }
  }

  return { startDate, endDate, daoList };
};

'''
'''--- server/api/middlewares/redis.js ---
import { createClient } from "redis";
import hash from "object-hash";

let redisClient = undefined;

export async function initializeRedisClient() {
    let redisURL = process.env.REDIS_URI;
    if (redisURL) {
        redisClient = createClient({ url: redisURL }).on("error", (e) => {
            console.error(`Failed to create the Redis client with error:`);
            console.error(e);
        });

        try {
            await redisClient.connect();
            console.log(`Connected to Redis successfully!`);
        } catch (e) {
            console.error(`Connection to Redis failed with error:`);
            console.error(e);
        }
    }
}

function requestToKey(req) {
    const reqDataToHash = {
        query: req.query,
        body: req.body,
    };

    return `${req.path}@${hash.sha1(reqDataToHash)}`;
}

function isRedisWorking() {
    return !!redisClient?.isOpen;
}

async function writeData(key, data, options) {
    if (isRedisWorking()) {
        try {
            await redisClient.set(key, data, options);
        } catch (e) {
            console.error(`Failed to cache data for key=${key}`, e);
        }
    }
}

async function readData(key) {
    let cachedValue = undefined;
    if (isRedisWorking()) {
        return await redisClient.get(key);
    }

    return cachedValue;
}

export function redisCachingMiddleware(
    options = {
        EX: 43200, // 12h
    }
) {
    return async (req, res, next) => {
        if (isRedisWorking()) {
            const key = requestToKey(req);
            const cachedValue = await readData(key);
            
            if (cachedValue) {
                try {
                    return res.json(JSON.parse(cachedValue));
                } catch {
                    return res.send(cachedValue);
                }
            } else {
                const oldSend = res.send;
                res.send = function (data) {
                    res.send = oldSend;

                    if (res.statusCode.toString().startsWith("2")) {
                        writeData(key, data, options).then();
                    }

                    return res.send(data);
                };

                next();
            }
        } else {
            next();
        }
    };
}

'''
'''--- server/api/routes.js ---
import express from "express";
import { GetUserRetention } from "./controllers/user_retention.js";
import { GetDappsUsed } from "./controllers/dapps_used.js";
import { GetTotalInfo } from "./controllers/total_info.js";
import { GetSocialEngagement } from "./controllers/social_engagement.js";
import { GetAcquisitionCost } from "./controllers/acquisition_cost.js";
import {redisCachingMiddleware} from "./middlewares/redis.js";
import {GetDailyStats} from "./controllers/daily_stats.js";

const routes = express.Router();

routes.get("/total", redisCachingMiddleware({EX: 3600}), GetTotalInfo);
routes.get("/daily-stats", redisCachingMiddleware({EX: 3600}), GetDailyStats);

routes.get("/user-retention", redisCachingMiddleware(), GetUserRetention);
routes.get("/dapps-used", redisCachingMiddleware(), GetDappsUsed);
routes.get("/social-engagement", redisCachingMiddleware(), GetSocialEngagement);
routes.get("/acquisition-cost", redisCachingMiddleware(), GetAcquisitionCost);

export { routes };

'''
'''--- server/index.js ---
import { app } from "./api/app.js";
import {initializeRedisClient} from "./api/middlewares/redis.js";
import {initializeCron} from "./api/cron.js";

const port = process.env.SERVER_PORT || 3000;

// connect to Redis cache
await initializeRedisClient();

// initialize cron jobs
await initializeCron();

app.listen(port, () => {
  console.log(`Dashboard server running on port :${port}`);
  console.log(`DAO smart-contract:`, process.env.DAO_SMART_CONTRACT);
  console.log(`REDIS URI:`, process.env.REDIS_URI);
  console.log(`------------------`);
});

'''
'''--- server/package.json ---
{
  "name": "server",
  "version": "0.0.1",
  "description": "NEAR Dashboard server",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start:local": "nodemon index.js --watch .",
    "start:production": "pm2 start ./index.js --name dashboard-mainnet --update-env"
  },
  "author": "Vlodkow",
  "license": "ISC",
  "dependencies": {
    "@clickhouse/client": "^0.3.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "near-api-js": "^4.0.0",
    "node-cron": "^3.0.3",
    "nodemon": "^3.1.0",
    "object-hash": "^3.0.0",
    "redis": "^4.6.12"
  }
}

'''
'''--- substreams/.cargo/config.toml ---
[build]
target = "wasm32-unknown-unknown"
'''
'''--- substreams/Cargo.toml ---
[package]
name = "near-substreams"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
substreams = "0.5.13"
substreams-near = "0.9.6"
prost = "0.11"
substreams-database-change = "1.0.0"
anyhow = "1"
prost-types = "0.11"
chrono = { version = "0.4", features = [ "std" ], default-features = false }
log = "0.4.21"
bs58 = "0.5.0"
serde_json = "1.0.114"

[profile.release]
lto = true
opt-level = 's'
strip = "debuginfo"
'''
'''--- substreams/bin/init_substreams.sh ---
#!/bin/bash

# Check if the environment file path is passed as an argument
if [ -z "$1" ]; then
  echo "Usage: $0 path_to_env_file"
  exit 1
fi

# Load environment variables from the specified file
set -a
source "$1"
set +a

DB_CONNECTION="${DB_CONNECTION//$'\r'/}"

substreams-sink-sql setup "$DB_CONNECTION" ./substreams.clickhouse.yaml
'''
'''--- substreams/bin/rotate_substreams_token.sh ---
#!/bin/bash

# Check if the environment file path is passed as an argument
if [ -z "$1" ]; then
  echo "Usage: $0 path_to_env_file"
  exit 1
fi

ENV_FILE="$1"

# Load environment variables from the specified file
set -a
source "$ENV_FILE"
set +a

SUBSTREAMS_API_KEY="${SUBSTREAMS_API_KEY//$'\r'/}"

NEW_SUBSTREAMS_API_TOKEN=$(curl https://auth.streamingfast.io/v1/auth/issue -s --data-binary '{"api_key":"'$SUBSTREAMS_API_KEY'", "lifetime": 1300000}' | jq -r .token)

# Check if the token was successfully retrieved
if [ -z "$NEW_SUBSTREAMS_API_TOKEN" ]; then
  echo "Failed to retrieve the new token."
  exit 2
fi

echo "New token retrieved successfully."

# Update SUBSTREAMS_API_TOKEN in the .env file
sed -i "s/^SUBSTREAMS_API_TOKEN=.*/SUBSTREAMS_API_TOKEN=$NEW_SUBSTREAMS_API_TOKEN/" "$ENV_FILE"

echo "JWT Token updated."
'''
'''--- substreams/bin/start_substreams.sh ---
#!/bin/bash

# Check if the environment file path is passed as an argument
if [ -z "$1" ]; then
  echo "Usage: $0 path_to_env_file"
  exit 1
fi

# Load environment variables from the specified file
set -a
source "$1"
set +a

DB_CONNECTION="${DB_CONNECTION//$'\r'/}"

substreams-sink-sql run "$DB_CONNECTION" ./substreams.clickhouse.yaml --undo-buffer-size 50000 --on-module-hash-mistmatch warn
'''
'''--- substreams/readme.md ---
# NEAR substreams for Dashboard

Substreams to create NDC dashboard to store and analyse NEAR blockchain data.

## Requirements
- [substreams-sink-sql](https://github.com/streamingfast/substreams-sink-sql)
- Rust 1.72+

## Usage

#### On proto update, regenerate protobuf files:
```bash
make protogen
```

#### Build module:
```bash
cargo build --target wasm32-unknown-unknown --release
```

#### Set JWT key for substreams:
```bash
SUBSTREAMS_API_TOKEN="your-jwt-token"
```
Note: To get SUBSTREAMS_API_TOKEN, you need to follow [Substreams Auth Documentation](https://substreams.streamingfast.io/documentation/consume/authentication).

### Option #1: Postgresql

#### Postgresql create database:
```bash
substreams-sink-sql setup "psql://postgres:secret@127.0.0.1:5432/substreams_example?sslmode=disable" ./substreams.postgresql.yaml
```

#### Postgresql start data sync:
```bash
substreams-sink-sql run "psql://postgres:secret@127.0.0.1:5432/substreams_example?sslmode=disable" ./substreams.postgresql.yaml
```

#### Postgresql resume data sync:
```bash
substreams-sink-sql run "psql://postgres:secret@127.0.0.1:5432/substreams_example?sslmode=disable" ./substreams.postgresql.yaml \
--on-module-hash-mistmatch warn
```

### Option #2: ClickHouse

#### ClickHouse create database:
```bash
substreams-sink-sql setup "clickhouse://default:@127.0.0.1:9000/default" ./substreams.clickhouse.yaml
```

#### ClickHouse start data sync / use $SUBSTREAMS_API_TOKEN:
```bash
substreams-sink-sql run "clickhouse://default:@127.0.0.1:9000/default" ./substreams.clickhouse.yaml \
--undo-buffer-size 50000
```

#### ClickHouse start data sync / use API Key:
```bash
SUBSTREAMS_API_KEY="your-api-key"

substreams-sink-sql run "clickhouse://default:@127.0.0.1:9000/default" ./substreams.clickhouse.yaml \
--header "x-api-key:$SUBSTREAMS_API_KEY" --undo-buffer-size 50000
```
Note: Replace "your-api-key" to your substreams API key.

#### ClickHouse resume data sync:
```bash
substreams-sink-sql run "clickhouse://default:@127.0.0.1:9000/default" ./substreams.clickhouse.yaml \
--undo-buffer-size 50000 --on-module-hash-mistmatch warn
```

Note: Replace DB connection credentials.
Read more: https://substreams.streamingfast.io/documentation/consume/authentication
'''
'''--- substreams/rust-toolchain.toml ---
[toolchain]
channel = "1.72"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]

'''
'''--- substreams/schema.clickhouse.sql ---
CREATE TABLE blocks
(
    block_height Int64,
    block_timestamp DateTime('UTC'),
    block_hash String,
    author_account_id String,
    approvals Int64,

    INDEX idx_transactions_block_height block_height TYPE minmax GRANULARITY 1,
    INDEX idx_transactions_block_timestamp block_timestamp TYPE minmax GRANULARITY 1
)
    ENGINE = MergeTree()
ORDER BY (block_height, block_timestamp)
PRIMARY KEY block_height;

CREATE TABLE transactions
(
    block_height Int64,
    block_timestamp DateTime('UTC'),
    tx_hash String,
    signer_id String,
    nonce Int64,
    receipt_id String,
    receiver_id String,

    INDEX idx_transactions_block_height block_height TYPE minmax GRANULARITY 1,
    INDEX idx_transactions_block_timestamp block_timestamp TYPE minmax GRANULARITY 1,
    INDEX idx_transactions_signer_id signer_id TYPE bloom_filter() GRANULARITY 1,
    INDEX idx_transactions_receiver_id receiver_id TYPE bloom_filter() GRANULARITY 1
)
    ENGINE = MergeTree()
ORDER BY (tx_hash)
PRIMARY KEY (tx_hash);

CREATE TABLE receipt_actions
(
    id String,
    block_height Int64,
    block_timestamp DateTime('UTC'),
    receipt_id String,
    predecessor_id String,
    receiver_id String,
    action_kind String,
    action_index Int64,
    method_name String,
    args String,
    social_kind String,
    gas Int32,
    deposit Float64,
    stake Float64,
    status String,

    INDEX idx_receipt_actions_block_height block_height TYPE minmax GRANULARITY 1,
    INDEX idx_receipt_actions_block_timestamp block_timestamp TYPE minmax GRANULARITY 1,
    INDEX idx_receipt_actions_predecessor_id predecessor_id TYPE bloom_filter() GRANULARITY 1,
    INDEX idx_receipt_actions_receiver_id receiver_id TYPE bloom_filter() GRANULARITY 1,
    INDEX idx_receipt_actions_action_kind action_kind TYPE bloom_filter() GRANULARITY 1
)
    ENGINE = MergeTree()
ORDER BY (id, predecessor_id)
PRIMARY KEY (id);
'''
'''--- substreams/schema.postgresql.sql ---
CREATE TABLE blocks (
      block_height BIGINT UNIQUE NOT NULL,
      block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
      block_hash TEXT NOT NULL UNIQUE,
      author_account_id VARCHAR(64) NOT NULL,
      approvals BIGINT,
    PRIMARY KEY (block_height)
);

CREATE INDEX idx_blocks_block_timestamp ON blocks(block_timestamp);

CREATE TABLE transactions (
      block_height BIGINT NOT NULL,
      block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
      tx_hash TEXT UNIQUE NOT NULL,
      signer_id VARCHAR(64),
      nonce BIGINT,
      receipt_id TEXT,
      receiver_id VARCHAR(64),
    PRIMARY KEY (tx_hash),
    FOREIGN KEY (block_height) REFERENCES blocks(block_height) ON DELETE CASCADE
);

CREATE INDEX idx_transactions_block_timestamp ON transactions(block_timestamp);
CREATE INDEX idx_transactions_signer_id ON transactions(signer_id);
CREATE INDEX idx_transactions_receiver_id ON transactions(receiver_id);

CREATE TABLE receipt_actions (
      id TEXT UNIQUE NOT NULL,
      block_height BIGINT NOT NULL,
      block_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
      receipt_id TEXT,
      predecessor_id VARCHAR(64) NOT NULL,
      receiver_id VARCHAR(64) NOT NULL,
      action_kind VARCHAR(20) NOT NULL,
      action_index BIGINT NOT NULL,
      method_name VARCHAR(255) NOT NULL,
      args TEXT,
      social_kind VARCHAR(20),
      gas INT NOT NULL,
      deposit DOUBLE PRECISION NOT NULL,
      stake DOUBLE PRECISION NOT NULL,
      status VARCHAR(20) NOT NULL,
      PRIMARY KEY (id),
      FOREIGN KEY (block_height) REFERENCES blocks(block_height) ON DELETE CASCADE
);

CREATE INDEX idx_receipt_actions_block_timestamp ON receipt_actions(block_timestamp);
CREATE INDEX idx_receipt_actions_predecessor_id ON receipt_actions(predecessor_id);
CREATE INDEX idx_receipt_actions_receiver_id ON receipt_actions(receiver_id);
'''
'''--- substreams/src/config.rs ---
pub const MAX_ARGS_LENGTH: usize = 200;
pub const TERAGAS_FACTOR: u64 = 1_000_000_000_000;
'''
'''--- substreams/src/lib.rs ---
mod pb;
mod utils;
pub mod config;

use std::collections::HashMap;
use substreams_near::pb::sf::near::r#type::v1::Block;
use substreams_database_change::pb::database::{DatabaseChanges, table_change::Operation};
use substreams_near::pb::sf::near::r#type::v1::execution_outcome::Status;
use crate::pb::near::custom::v1::{BlockDataOutput, BlockMeta, ReceiptActionMeta, TransactionMeta};
use substreams_near::pb::sf::near::r#type::v1::receipt::Receipt as ReceiptTypes;
use crate::utils::block_timestamp::BlockTimestamp;
use crate::utils::helpers::bs58_hash_to_string;
use crate::utils::transform::{transform_action, transform_transaction};

#[substreams::handlers::map]
fn store_transactions(blk: Block) -> BlockDataOutput {
    let (transactions, receipt_actions, block_meta) = if let Some(block_header) = blk.header.as_ref() {
        let timestamp = BlockTimestamp::from_block(block_header);

        let block_meta = BlockMeta {
            block_height: block_header.height,
            block_timestamp: timestamp.timestamp(),
            block_hash: bs58_hash_to_string(block_header.hash.clone()),
            author_account_id: blk.author.clone(),
            approvals: block_header.approvals.len() as u64,
        };

        let mut all_statuses = HashMap::new();
        let (transactions, receipt_actions): (Vec<TransactionMeta>, Vec<ReceiptActionMeta>) =
            blk.shards.iter().fold((Vec::new(), Vec::new()), |(mut all_transactions, mut all_actions), shard| {
                // Collect statuses
                shard.receipt_execution_outcomes.iter().filter_map(|outcome| outcome.execution_outcome.as_ref()).for_each(|outcome_with_id| {
                    let status = outcome_with_id.outcome.as_ref().and_then(|outcome| outcome.status.as_ref()).map_or("Unknown", |status| {
                        match status {
                            Status::Failure(_) => "Failure",
                            _ => "Success",
                        }
                    });
                    if let Some(id) = &outcome_with_id.id {
                        all_statuses.insert(bs58_hash_to_string(Some(id.clone())), status.to_string());
                    }
                });

                if let Some(chunk) = shard.chunk.as_ref() {
                    // Process transactions
                    all_transactions.extend(chunk.transactions.iter().filter_map(|tx_with_outcome| {
                        tx_with_outcome.transaction.as_ref().and_then(|transaction| {
                            tx_with_outcome.outcome.as_ref()?.execution_outcome.as_ref().and_then(|outcome_with_id| {
                                transform_transaction(&timestamp, &block_header.height, transaction, &outcome_with_id.outcome)
                            })
                        })
                    }));

                    // Process receipt actions
                    let mut action_index = all_actions.len() as u64 + 1;
                    let chunk_actions = chunk.receipts.iter().filter_map(|receipt| {
                        receipt.receipt.as_ref().and_then(|receipt_action| match receipt_action {
                            ReceiptTypes::Action(action_receipt) => {
                                let actions = action_receipt.actions.iter().map(|action| {
                                    let transformed_action = transform_action(action, &block_meta, receipt, &all_statuses, action_index);
                                    action_index += 1;
                                    transformed_action
                                }).collect::<Vec<_>>();
                                if actions.is_empty() { None } else { Some(actions) }
                            },
                            _ => None,
                        })
                    }).flatten().collect::<Vec<_>>();

                    all_actions.extend(chunk_actions);
                }
                (all_transactions, all_actions)
            });

        (transactions, receipt_actions, Some(block_meta))
    } else {
        (Vec::new(), Vec::new(), None)
    };

    BlockDataOutput {
        block: block_meta,
        transactions,
        receipt_actions,
    }
}

// Database updates

#[substreams::handlers::map]
fn db_out(block_data_output: BlockDataOutput) -> Result<DatabaseChanges, substreams::errors::Error> {
    let mut database_changes: DatabaseChanges = Default::default();

    // Save block
    push_block_create(&mut database_changes, &block_data_output.block.unwrap());

    // Save transactions
    for transaction in block_data_output.transactions {
        push_transaction_create(&mut database_changes, &transaction, 0);
    }

    // Save Actions
    for action in block_data_output.receipt_actions.iter() {
        push_action_create(&mut database_changes, &action);
    }

    Ok(database_changes)
}

fn push_block_create(
    changes: &mut DatabaseChanges,
    block: &BlockMeta,
) {
    changes
        .push_change("blocks", &block.block_height.to_string(), 0, Operation::Create)
        .change("block_height", (None, block.block_height))
        .change("block_timestamp", (None, block.block_timestamp))
        .change("block_hash", (None, &block.block_hash))
        .change("author_account_id", (None, &block.author_account_id))
        .change("approvals", (None, block.approvals));
}

fn push_transaction_create(
    changes: &mut DatabaseChanges,
    transaction: &TransactionMeta,
    ordinal: u64,
) {
    changes
        .push_change("transactions", &transaction.tx_hash, ordinal, Operation::Create)
        .change("block_timestamp", (None, transaction.block_timestamp))
        .change("block_height", (None, transaction.block_height))
        .change("tx_hash", (None, &transaction.tx_hash))
        .change("signer_id", (None, &transaction.signer_id))
        .change("nonce", (None, transaction.nonce))
        .change("receipt_id", (None, &transaction.receipt_id))
        .change("receiver_id", (None, &transaction.receiver_id));
}

fn push_action_create(
    changes: &mut DatabaseChanges,
    action: &ReceiptActionMeta,
) {
    let pk = format!("{}:{}", action.block_height, action.action_index);

    changes
        .push_change("receipt_actions", &pk, action.action_index, Operation::Create)
        .change("block_timestamp", (None, action.block_timestamp))
        .change("block_height", (None, action.block_height))
        .change("receipt_id", (None, &action.receipt_id))
        .change("action_index", (None, action.action_index))
        .change("predecessor_id", (None, &action.predecessor_id))
        .change("receiver_id", (None, &action.receiver_id))
        .change("action_kind", (None, &action.action_kind))
        .change("method_name", (None, &action.method_name))
        .change("args", (None, &action.args))
        .change("social_kind", (None, &action.social_kind))
        .change("status", (None, action.status.to_string()))
        .change("gas", (None, action.gas))
        .change("deposit", (None, action.deposit.to_string()))
        .change("stake", (None, action.stake.to_string()));
}

'''
'''--- substreams/src/pb/mod.rs ---
// @generated
pub mod near {
    pub mod custom {
        // @@protoc_insertion_point(attribute:near.custom.v1)
        pub mod v1 {
            include!("near.custom.v1.rs");
            // @@protoc_insertion_point(near.custom.v1)
        }
    }
}
pub mod sf {
    pub mod near {
        pub mod r#type {
            // @@protoc_insertion_point(attribute:sf.near.type.v1)
            pub mod v1 {
                include!("sf.near.type.v1.rs");
                // @@protoc_insertion_point(sf.near.type.v1)
            }
        }
    }
}

'''
'''--- substreams/src/pb/near.custom.v1.rs ---
// @generated
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockMeta {
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    #[prost(uint64, tag="3")]
    pub block_timestamp: u64,
    #[prost(string, tag="4")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub author_account_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="6")]
    pub approvals: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionMeta {
    #[prost(uint64, tag="1")]
    pub block_timestamp: u64,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    #[prost(string, tag="3")]
    pub tx_hash: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub signer_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="5")]
    pub nonce: u64,
    #[prost(string, tag="6")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub receipt_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiptActionMeta {
    #[prost(uint64, tag="1")]
    pub block_timestamp: u64,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    #[prost(string, tag="3")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub predecessor_id: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub action_kind: ::prost::alloc::string::String,
    #[prost(uint64, tag="7")]
    pub action_index: u64,
    #[prost(string, tag="8")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(string, tag="9")]
    pub args: ::prost::alloc::string::String,
    #[prost(string, tag="10")]
    pub social_kind: ::prost::alloc::string::String,
    #[prost(uint32, tag="11")]
    pub gas: u32,
    #[prost(double, tag="12")]
    pub deposit: f64,
    #[prost(double, tag="13")]
    pub stake: f64,
    #[prost(string, tag="14")]
    pub status: ::prost::alloc::string::String,
}
/// General block data output
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockDataOutput {
    #[prost(message, optional, tag="1")]
    pub block: ::core::option::Option<BlockMeta>,
    #[prost(message, repeated, tag="2")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionMeta>,
    #[prost(message, repeated, tag="3")]
    pub receipt_actions: ::prost::alloc::vec::Vec<ReceiptActionMeta>,
}
// @@protoc_insertion_point(module)

'''
'''--- substreams/src/pb/sf.near.type.v1.rs ---
// @generated
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(string, tag="1")]
    pub author: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag="3")]
    pub chunk_headers: ::prost::alloc::vec::Vec<ChunkHeader>,
    #[prost(message, repeated, tag="4")]
    pub shards: ::prost::alloc::vec::Vec<IndexerShard>,
    #[prost(message, repeated, tag="5")]
    pub state_changes: ::prost::alloc::vec::Vec<StateChangeWithCause>,
}
/// HeaderOnlyBlock is a standard \[Block\] structure where all other fields are
/// removed so that hydrating that object from a \[Block\] bytes payload will
/// drastically reduced allocated memory required to hold the full block.
///
/// This can be used to unpack a \[Block\] when only the \[BlockHeader\] information
/// is required and greatly reduced required memory.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeaderOnlyBlock {
    #[prost(message, optional, tag="2")]
    pub header: ::core::option::Option<BlockHeader>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChangeWithCause {
    #[prost(message, optional, tag="1")]
    pub value: ::core::option::Option<StateChangeValue>,
    #[prost(message, optional, tag="2")]
    pub cause: ::core::option::Option<StateChangeCause>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChangeCause {
    #[prost(oneof="state_change_cause::Cause", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub cause: ::core::option::Option<state_change_cause::Cause>,
}
/// Nested message and enum types in `StateChangeCause`.
pub mod state_change_cause {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotWritableToDisk {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitialState {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionProcessing {
        #[prost(message, optional, tag="1")]
        pub tx_hash: ::core::option::Option<super::CryptoHash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionReceiptProcessingStarted {
        #[prost(message, optional, tag="1")]
        pub receipt_hash: ::core::option::Option<super::CryptoHash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionReceiptGasReward {
        #[prost(message, optional, tag="1")]
        pub tx_hash: ::core::option::Option<super::CryptoHash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReceiptProcessing {
        #[prost(message, optional, tag="1")]
        pub tx_hash: ::core::option::Option<super::CryptoHash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostponedReceipt {
        #[prost(message, optional, tag="1")]
        pub tx_hash: ::core::option::Option<super::CryptoHash>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdatedDelayedReceipts {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValidatorAccountsUpdate {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Migration {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Cause {
        #[prost(message, tag="1")]
        NotWritableToDisk(NotWritableToDisk),
        #[prost(message, tag="2")]
        InitialState(InitialState),
        #[prost(message, tag="3")]
        TransactionProcessing(TransactionProcessing),
        #[prost(message, tag="4")]
        ActionReceiptProcessingStarted(ActionReceiptProcessingStarted),
        #[prost(message, tag="5")]
        ActionReceiptGasReward(ActionReceiptGasReward),
        #[prost(message, tag="6")]
        ReceiptProcessing(ReceiptProcessing),
        #[prost(message, tag="7")]
        PostponedReceipt(PostponedReceipt),
        #[prost(message, tag="8")]
        UpdatedDelayedReceipts(UpdatedDelayedReceipts),
        #[prost(message, tag="9")]
        ValidatorAccountsUpdate(ValidatorAccountsUpdate),
        #[prost(message, tag="10")]
        Migration(Migration),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChangeValue {
    #[prost(oneof="state_change_value::Value", tags="1, 2, 3, 4, 5, 6, 7, 8")]
    pub value: ::core::option::Option<state_change_value::Value>,
}
/// Nested message and enum types in `StateChangeValue`.
pub mod state_change_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccountUpdate {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag="2")]
        pub account: ::core::option::Option<super::Account>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccountDeletion {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessKeyUpdate {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag="2")]
        pub public_key: ::core::option::Option<super::PublicKey>,
        #[prost(message, optional, tag="3")]
        pub access_key: ::core::option::Option<super::AccessKey>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessKeyDeletion {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag="2")]
        pub public_key: ::core::option::Option<super::PublicKey>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataUpdate {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(bytes="vec", tag="2")]
        pub key: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes="vec", tag="3")]
        pub value: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataDeletion {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(bytes="vec", tag="2")]
        pub key: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContractCodeUpdate {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
        #[prost(bytes="vec", tag="2")]
        pub code: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContractCodeDeletion {
        #[prost(string, tag="1")]
        pub account_id: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        AccountUpdate(AccountUpdate),
        #[prost(message, tag="2")]
        AccountDeletion(AccountDeletion),
        #[prost(message, tag="3")]
        AccessKeyUpdate(AccessKeyUpdate),
        #[prost(message, tag="4")]
        AccessKeyDeletion(AccessKeyDeletion),
        #[prost(message, tag="5")]
        DataUpdate(DataUpdate),
        #[prost(message, tag="6")]
        DataDeletion(DataDeletion),
        #[prost(message, tag="7")]
        ContractCodeUpdate(ContractCodeUpdate),
        #[prost(message, tag="8")]
        ContractDeletion(ContractCodeDeletion),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(message, optional, tag="1")]
    pub amount: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="2")]
    pub locked: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="3")]
    pub code_hash: ::core::option::Option<CryptoHash>,
    #[prost(uint64, tag="4")]
    pub storage_usage: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(uint64, tag="1")]
    pub height: u64,
    #[prost(uint64, tag="2")]
    pub prev_height: u64,
    #[prost(message, optional, tag="3")]
    pub epoch_id: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="4")]
    pub next_epoch_id: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="5")]
    pub hash: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="6")]
    pub prev_hash: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="7")]
    pub prev_state_root: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="8")]
    pub chunk_receipts_root: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="9")]
    pub chunk_headers_root: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="10")]
    pub chunk_tx_root: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="11")]
    pub outcome_root: ::core::option::Option<CryptoHash>,
    #[prost(uint64, tag="12")]
    pub chunks_included: u64,
    #[prost(message, optional, tag="13")]
    pub challenges_root: ::core::option::Option<CryptoHash>,
    #[prost(uint64, tag="14")]
    pub timestamp: u64,
    #[prost(uint64, tag="15")]
    pub timestamp_nanosec: u64,
    #[prost(message, optional, tag="16")]
    pub random_value: ::core::option::Option<CryptoHash>,
    #[prost(message, repeated, tag="17")]
    pub validator_proposals: ::prost::alloc::vec::Vec<ValidatorStake>,
    #[prost(bool, repeated, tag="18")]
    pub chunk_mask: ::prost::alloc::vec::Vec<bool>,
    #[prost(message, optional, tag="19")]
    pub gas_price: ::core::option::Option<BigInt>,
    #[prost(uint64, tag="20")]
    pub block_ordinal: u64,
    #[prost(message, optional, tag="21")]
    pub total_supply: ::core::option::Option<BigInt>,
    #[prost(message, repeated, tag="22")]
    pub challenges_result: ::prost::alloc::vec::Vec<SlashedValidator>,
    #[prost(uint64, tag="23")]
    pub last_final_block_height: u64,
    #[prost(message, optional, tag="24")]
    pub last_final_block: ::core::option::Option<CryptoHash>,
    #[prost(uint64, tag="25")]
    pub last_ds_final_block_height: u64,
    #[prost(message, optional, tag="26")]
    pub last_ds_final_block: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="27")]
    pub next_bp_hash: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="28")]
    pub block_merkle_root: ::core::option::Option<CryptoHash>,
    #[prost(bytes="vec", tag="29")]
    pub epoch_sync_data_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag="30")]
    pub approvals: ::prost::alloc::vec::Vec<Signature>,
    #[prost(message, optional, tag="31")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(uint32, tag="32")]
    pub latest_protocol_version: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigInt {
    #[prost(bytes="vec", tag="1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoHash {
    #[prost(bytes="vec", tag="1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signature {
    #[prost(enumeration="CurveKind", tag="1")]
    pub r#type: i32,
    #[prost(bytes="vec", tag="2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKey {
    #[prost(enumeration="CurveKind", tag="1")]
    pub r#type: i32,
    #[prost(bytes="vec", tag="2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorStake {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub public_key: ::core::option::Option<PublicKey>,
    #[prost(message, optional, tag="3")]
    pub stake: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlashedValidator {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub is_double_sign: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkHeader {
    #[prost(bytes="vec", tag="1")]
    pub chunk_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub prev_block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="3")]
    pub outcome_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="4")]
    pub prev_state_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="5")]
    pub encoded_merkle_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="6")]
    pub encoded_length: u64,
    #[prost(uint64, tag="7")]
    pub height_created: u64,
    #[prost(uint64, tag="8")]
    pub height_included: u64,
    #[prost(uint64, tag="9")]
    pub shard_id: u64,
    #[prost(uint64, tag="10")]
    pub gas_used: u64,
    #[prost(uint64, tag="11")]
    pub gas_limit: u64,
    #[prost(message, optional, tag="12")]
    pub validator_reward: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="13")]
    pub balance_burnt: ::core::option::Option<BigInt>,
    #[prost(bytes="vec", tag="14")]
    pub outgoing_receipts_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="15")]
    pub tx_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag="16")]
    pub validator_proposals: ::prost::alloc::vec::Vec<ValidatorStake>,
    #[prost(message, optional, tag="17")]
    pub signature: ::core::option::Option<Signature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerShard {
    #[prost(uint64, tag="1")]
    pub shard_id: u64,
    #[prost(message, optional, tag="2")]
    pub chunk: ::core::option::Option<IndexerChunk>,
    #[prost(message, repeated, tag="3")]
    pub receipt_execution_outcomes: ::prost::alloc::vec::Vec<IndexerExecutionOutcomeWithReceipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerExecutionOutcomeWithReceipt {
    #[prost(message, optional, tag="1")]
    pub execution_outcome: ::core::option::Option<ExecutionOutcomeWithId>,
    #[prost(message, optional, tag="2")]
    pub receipt: ::core::option::Option<Receipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerChunk {
    #[prost(string, tag="1")]
    pub author: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub header: ::core::option::Option<ChunkHeader>,
    #[prost(message, repeated, tag="3")]
    pub transactions: ::prost::alloc::vec::Vec<IndexerTransactionWithOutcome>,
    #[prost(message, repeated, tag="4")]
    pub receipts: ::prost::alloc::vec::Vec<Receipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerTransactionWithOutcome {
    #[prost(message, optional, tag="1")]
    pub transaction: ::core::option::Option<SignedTransaction>,
    #[prost(message, optional, tag="2")]
    pub outcome: ::core::option::Option<IndexerExecutionOutcomeWithOptionalReceipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedTransaction {
    #[prost(string, tag="1")]
    pub signer_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub public_key: ::core::option::Option<PublicKey>,
    #[prost(uint64, tag="3")]
    pub nonce: u64,
    #[prost(string, tag="4")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(message, optional, tag="6")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(message, optional, tag="7")]
    pub hash: ::core::option::Option<CryptoHash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerExecutionOutcomeWithOptionalReceipt {
    #[prost(message, optional, tag="1")]
    pub execution_outcome: ::core::option::Option<ExecutionOutcomeWithId>,
    #[prost(message, optional, tag="2")]
    pub receipt: ::core::option::Option<Receipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Receipt {
    #[prost(string, tag="1")]
    pub predecessor_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub receipt_id: ::core::option::Option<CryptoHash>,
    #[prost(oneof="receipt::Receipt", tags="10, 11")]
    pub receipt: ::core::option::Option<receipt::Receipt>,
}
/// Nested message and enum types in `Receipt`.
pub mod receipt {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Receipt {
        #[prost(message, tag="10")]
        Action(super::ReceiptAction),
        #[prost(message, tag="11")]
        Data(super::ReceiptData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiptData {
    #[prost(message, optional, tag="1")]
    pub data_id: ::core::option::Option<CryptoHash>,
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiptAction {
    #[prost(string, tag="1")]
    pub signer_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub signer_public_key: ::core::option::Option<PublicKey>,
    #[prost(message, optional, tag="3")]
    pub gas_price: ::core::option::Option<BigInt>,
    #[prost(message, repeated, tag="4")]
    pub output_data_receivers: ::prost::alloc::vec::Vec<DataReceiver>,
    #[prost(message, repeated, tag="5")]
    pub input_data_ids: ::prost::alloc::vec::Vec<CryptoHash>,
    #[prost(message, repeated, tag="6")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataReceiver {
    #[prost(message, optional, tag="1")]
    pub data_id: ::core::option::Option<CryptoHash>,
    #[prost(string, tag="2")]
    pub receiver_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionOutcomeWithId {
    #[prost(message, optional, tag="1")]
    pub proof: ::core::option::Option<MerklePath>,
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="3")]
    pub id: ::core::option::Option<CryptoHash>,
    #[prost(message, optional, tag="4")]
    pub outcome: ::core::option::Option<ExecutionOutcome>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionOutcome {
    #[prost(string, repeated, tag="1")]
    pub logs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="2")]
    pub receipt_ids: ::prost::alloc::vec::Vec<CryptoHash>,
    #[prost(uint64, tag="3")]
    pub gas_burnt: u64,
    #[prost(message, optional, tag="4")]
    pub tokens_burnt: ::core::option::Option<BigInt>,
    #[prost(string, tag="5")]
    pub executor_id: ::prost::alloc::string::String,
    #[prost(enumeration="ExecutionMetadata", tag="6")]
    pub metadata: i32,
    #[prost(oneof="execution_outcome::Status", tags="20, 21, 22, 23")]
    pub status: ::core::option::Option<execution_outcome::Status>,
}
/// Nested message and enum types in `ExecutionOutcome`.
pub mod execution_outcome {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Status {
        #[prost(message, tag="20")]
        Unknown(super::UnknownExecutionStatus),
        #[prost(message, tag="21")]
        Failure(super::FailureExecutionStatus),
        #[prost(message, tag="22")]
        SuccessValue(super::SuccessValueExecutionStatus),
        #[prost(message, tag="23")]
        SuccessReceiptId(super::SuccessReceiptIdExecutionStatus),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuccessValueExecutionStatus {
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuccessReceiptIdExecutionStatus {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<CryptoHash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnknownExecutionStatus {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureExecutionStatus {
    #[prost(oneof="failure_execution_status::Failure", tags="1, 2")]
    pub failure: ::core::option::Option<failure_execution_status::Failure>,
}
/// Nested message and enum types in `FailureExecutionStatus`.
pub mod failure_execution_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Failure {
        #[prost(message, tag="1")]
        ActionError(super::ActionError),
        #[prost(enumeration="super::InvalidTxError", tag="2")]
        InvalidTxError(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionError {
    #[prost(uint64, tag="1")]
    pub index: u64,
    #[prost(oneof="action_error::Kind", tags="21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42")]
    pub kind: ::core::option::Option<action_error::Kind>,
}
/// Nested message and enum types in `ActionError`.
pub mod action_error {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag="21")]
        AccountAlreadyExist(super::AccountAlreadyExistsErrorKind),
        #[prost(message, tag="22")]
        AccountDoesNotExist(super::AccountDoesNotExistErrorKind),
        #[prost(message, tag="23")]
        CreateAccountOnlyByRegistrar(super::CreateAccountOnlyByRegistrarErrorKind),
        #[prost(message, tag="24")]
        CreateAccountNotAllowed(super::CreateAccountNotAllowedErrorKind),
        #[prost(message, tag="25")]
        ActorNoPermission(super::ActorNoPermissionErrorKind),
        #[prost(message, tag="26")]
        DeleteKeyDoesNotExist(super::DeleteKeyDoesNotExistErrorKind),
        #[prost(message, tag="27")]
        AddKeyAlreadyExists(super::AddKeyAlreadyExistsErrorKind),
        #[prost(message, tag="28")]
        DeleteAccountStaking(super::DeleteAccountStakingErrorKind),
        #[prost(message, tag="29")]
        LackBalanceForState(super::LackBalanceForStateErrorKind),
        #[prost(message, tag="30")]
        TriesToUnstake(super::TriesToUnstakeErrorKind),
        #[prost(message, tag="31")]
        TriesToStake(super::TriesToStakeErrorKind),
        #[prost(message, tag="32")]
        InsufficientStake(super::InsufficientStakeErrorKind),
        #[prost(message, tag="33")]
        FunctionCall(super::FunctionCallErrorKind),
        #[prost(message, tag="34")]
        NewReceiptValidation(super::NewReceiptValidationErrorKind),
        #[prost(message, tag="35")]
        OnlyImplicitAccountCreationAllowed(super::OnlyImplicitAccountCreationAllowedErrorKind),
        #[prost(message, tag="36")]
        DeleteAccountWithLargeState(super::DeleteAccountWithLargeStateErrorKind),
        #[prost(message, tag="37")]
        DelegateActionInvalidSignature(super::DelegateActionInvalidSignatureKind),
        #[prost(message, tag="38")]
        DelegateActionSenderDoesNotMatchTxReceiver(super::DelegateActionSenderDoesNotMatchTxReceiverKind),
        #[prost(message, tag="39")]
        DelegateActionExpired(super::DelegateActionExpiredKind),
        #[prost(message, tag="40")]
        DelegateActionAccessKeyError(super::DelegateActionAccessKeyErrorKind),
        #[prost(message, tag="41")]
        DelegateActionInvalidNonce(super::DelegateActionInvalidNonceKind),
        #[prost(message, tag="42")]
        DelegateActionNonceTooLarge(super::DelegateActionNonceTooLargeKind),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountAlreadyExistsErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountDoesNotExistErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
/// / A top-level account ID can only be created by registrar.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountOnlyByRegistrarErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub registrar_account_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub predecessor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountNotAllowedErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub predecessor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorNoPermissionErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyDoesNotExistErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub public_key: ::core::option::Option<PublicKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddKeyAlreadyExistsErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub public_key: ::core::option::Option<PublicKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccountStakingErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LackBalanceForStateErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub balance: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriesToUnstakeErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriesToStakeErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub stake: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="3")]
    pub locked: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="4")]
    pub balance: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsufficientStakeErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub stake: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="3")]
    pub minimum_stake: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallErrorKind {
    #[prost(enumeration="FunctionCallErrorSer", tag="1")]
    pub error: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewReceiptValidationErrorKind {
    #[prost(enumeration="ReceiptValidationError", tag="1")]
    pub error: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyImplicitAccountCreationAllowedErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccountWithLargeStateErrorKind {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionInvalidSignatureKind {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionSenderDoesNotMatchTxReceiverKind {
    #[prost(string, tag="1")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub receiver_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionExpiredKind {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionAccessKeyErrorKind {
    /// InvalidAccessKeyError
    #[prost(enumeration="InvalidTxError", tag="1")]
    pub error: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionInvalidNonceKind {
    #[prost(uint64, tag="1")]
    pub delegate_nonce: u64,
    #[prost(uint64, tag="2")]
    pub ak_nonce: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateActionNonceTooLargeKind {
    #[prost(uint64, tag="1")]
    pub delegate_nonce: u64,
    #[prost(uint64, tag="2")]
    pub upper_bound: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePath {
    #[prost(message, repeated, tag="1")]
    pub path: ::prost::alloc::vec::Vec<MerklePathItem>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePathItem {
    #[prost(message, optional, tag="1")]
    pub hash: ::core::option::Option<CryptoHash>,
    #[prost(enumeration="Direction", tag="2")]
    pub direction: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(oneof="action::Action", tags="1, 2, 3, 4, 5, 6, 7, 8, 9")]
    pub action: ::core::option::Option<action::Action>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag="1")]
        CreateAccount(super::CreateAccountAction),
        #[prost(message, tag="2")]
        DeployContract(super::DeployContractAction),
        #[prost(message, tag="3")]
        FunctionCall(super::FunctionCallAction),
        #[prost(message, tag="4")]
        Transfer(super::TransferAction),
        #[prost(message, tag="5")]
        Stake(super::StakeAction),
        #[prost(message, tag="6")]
        AddKey(super::AddKeyAction),
        #[prost(message, tag="7")]
        DeleteKey(super::DeleteKeyAction),
        #[prost(message, tag="8")]
        DeleteAccount(super::DeleteAccountAction),
        #[prost(message, tag="9")]
        Delegate(super::SignedDelegateAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountAction {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployContractAction {
    #[prost(bytes="vec", tag="1")]
    pub code: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallAction {
    #[prost(string, tag="1")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="2")]
    pub args: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag="3")]
    pub gas: u64,
    #[prost(message, optional, tag="4")]
    pub deposit: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferAction {
    #[prost(message, optional, tag="1")]
    pub deposit: ::core::option::Option<BigInt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakeAction {
    #[prost(message, optional, tag="1")]
    pub stake: ::core::option::Option<BigInt>,
    #[prost(message, optional, tag="2")]
    pub public_key: ::core::option::Option<PublicKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddKeyAction {
    #[prost(message, optional, tag="1")]
    pub public_key: ::core::option::Option<PublicKey>,
    #[prost(message, optional, tag="2")]
    pub access_key: ::core::option::Option<AccessKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyAction {
    #[prost(message, optional, tag="1")]
    pub public_key: ::core::option::Option<PublicKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccountAction {
    #[prost(string, tag="1")]
    pub beneficiary_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedDelegateAction {
    #[prost(message, optional, tag="1")]
    pub signature: ::core::option::Option<Signature>,
    #[prost(message, optional, tag="2")]
    pub delegate_action: ::core::option::Option<DelegateAction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateAction {
    #[prost(string, tag="1")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="3")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(uint64, tag="4")]
    pub nonce: u64,
    #[prost(uint64, tag="5")]
    pub max_block_height: u64,
    #[prost(message, optional, tag="6")]
    pub public_key: ::core::option::Option<PublicKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessKey {
    #[prost(uint64, tag="1")]
    pub nonce: u64,
    #[prost(message, optional, tag="2")]
    pub permission: ::core::option::Option<AccessKeyPermission>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessKeyPermission {
    #[prost(oneof="access_key_permission::Permission", tags="1, 2")]
    pub permission: ::core::option::Option<access_key_permission::Permission>,
}
/// Nested message and enum types in `AccessKeyPermission`.
pub mod access_key_permission {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Permission {
        #[prost(message, tag="1")]
        FunctionCall(super::FunctionCallPermission),
        #[prost(message, tag="2")]
        FullAccess(super::FullAccessPermission),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallPermission {
    #[prost(message, optional, tag="1")]
    pub allowance: ::core::option::Option<BigInt>,
    #[prost(string, tag="2")]
    pub receiver_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub method_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullAccessPermission {
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CurveKind {
    Ed25519 = 0,
    Secp256k1 = 1,
}
impl CurveKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CurveKind::Ed25519 => "ED25519",
            CurveKind::Secp256k1 => "SECP256K1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "SECP256K1" => Some(Self::Secp256k1),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionMetadata {
    V1 = 0,
}
impl ExecutionMetadata {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExecutionMetadata::V1 => "ExecutionMetadataV1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ExecutionMetadataV1" => Some(Self::V1),
            _ => None,
        }
    }
}
/// todo: add more detail?
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionCallErrorSer {
    CompilationError = 0,
    LinkError = 1,
    MethodResolveError = 2,
    WasmTrap = 3,
    WasmUnknownError = 4,
    HostError = 5,
    EvmError = 6,
    ExecutionError = 7,
}
impl FunctionCallErrorSer {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FunctionCallErrorSer::CompilationError => "CompilationError",
            FunctionCallErrorSer::LinkError => "LinkError",
            FunctionCallErrorSer::MethodResolveError => "MethodResolveError",
            FunctionCallErrorSer::WasmTrap => "WasmTrap",
            FunctionCallErrorSer::WasmUnknownError => "WasmUnknownError",
            FunctionCallErrorSer::HostError => "HostError",
            FunctionCallErrorSer::EvmError => "_EVMError",
            FunctionCallErrorSer::ExecutionError => "ExecutionError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CompilationError" => Some(Self::CompilationError),
            "LinkError" => Some(Self::LinkError),
            "MethodResolveError" => Some(Self::MethodResolveError),
            "WasmTrap" => Some(Self::WasmTrap),
            "WasmUnknownError" => Some(Self::WasmUnknownError),
            "HostError" => Some(Self::HostError),
            "_EVMError" => Some(Self::EvmError),
            "ExecutionError" => Some(Self::ExecutionError),
            _ => None,
        }
    }
}
/// todo: add more detail?
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReceiptValidationError {
    InvalidPredecessorId = 0,
    InvalidReceiverAccountId = 1,
    InvalidSignerAccountId = 2,
    InvalidDataReceiverId = 3,
    ReturnedValueLengthExceeded = 4,
    NumberInputDataDependenciesExceeded = 5,
    ActionsValidationError = 6,
}
impl ReceiptValidationError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReceiptValidationError::InvalidPredecessorId => "InvalidPredecessorId",
            ReceiptValidationError::InvalidReceiverAccountId => "InvalidReceiverAccountId",
            ReceiptValidationError::InvalidSignerAccountId => "InvalidSignerAccountId",
            ReceiptValidationError::InvalidDataReceiverId => "InvalidDataReceiverId",
            ReceiptValidationError::ReturnedValueLengthExceeded => "ReturnedValueLengthExceeded",
            ReceiptValidationError::NumberInputDataDependenciesExceeded => "NumberInputDataDependenciesExceeded",
            ReceiptValidationError::ActionsValidationError => "ActionsValidationError",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InvalidPredecessorId" => Some(Self::InvalidPredecessorId),
            "InvalidReceiverAccountId" => Some(Self::InvalidReceiverAccountId),
            "InvalidSignerAccountId" => Some(Self::InvalidSignerAccountId),
            "InvalidDataReceiverId" => Some(Self::InvalidDataReceiverId),
            "ReturnedValueLengthExceeded" => Some(Self::ReturnedValueLengthExceeded),
            "NumberInputDataDependenciesExceeded" => Some(Self::NumberInputDataDependenciesExceeded),
            "ActionsValidationError" => Some(Self::ActionsValidationError),
            _ => None,
        }
    }
}
/// todo: add more detail?
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvalidTxError {
    InvalidAccessKeyError = 0,
    InvalidSignerId = 1,
    SignerDoesNotExist = 2,
    InvalidNonce = 3,
    NonceTooLarge = 4,
    InvalidReceiverId = 5,
    InvalidSignature = 6,
    NotEnoughBalance = 7,
    LackBalanceForState = 8,
    CostOverflow = 9,
    InvalidChain = 10,
    Expired = 11,
    ActionsValidation = 12,
    TransactionSizeExceeded = 13,
}
impl InvalidTxError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InvalidTxError::InvalidAccessKeyError => "InvalidAccessKeyError",
            InvalidTxError::InvalidSignerId => "InvalidSignerId",
            InvalidTxError::SignerDoesNotExist => "SignerDoesNotExist",
            InvalidTxError::InvalidNonce => "InvalidNonce",
            InvalidTxError::NonceTooLarge => "NonceTooLarge",
            InvalidTxError::InvalidReceiverId => "InvalidReceiverId",
            InvalidTxError::InvalidSignature => "InvalidSignature",
            InvalidTxError::NotEnoughBalance => "NotEnoughBalance",
            InvalidTxError::LackBalanceForState => "LackBalanceForState",
            InvalidTxError::CostOverflow => "CostOverflow",
            InvalidTxError::InvalidChain => "InvalidChain",
            InvalidTxError::Expired => "Expired",
            InvalidTxError::ActionsValidation => "ActionsValidation",
            InvalidTxError::TransactionSizeExceeded => "TransactionSizeExceeded",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InvalidAccessKeyError" => Some(Self::InvalidAccessKeyError),
            "InvalidSignerId" => Some(Self::InvalidSignerId),
            "SignerDoesNotExist" => Some(Self::SignerDoesNotExist),
            "InvalidNonce" => Some(Self::InvalidNonce),
            "NonceTooLarge" => Some(Self::NonceTooLarge),
            "InvalidReceiverId" => Some(Self::InvalidReceiverId),
            "InvalidSignature" => Some(Self::InvalidSignature),
            "NotEnoughBalance" => Some(Self::NotEnoughBalance),
            "LackBalanceForState" => Some(Self::LackBalanceForState),
            "CostOverflow" => Some(Self::CostOverflow),
            "InvalidChain" => Some(Self::InvalidChain),
            "Expired" => Some(Self::Expired),
            "ActionsValidation" => Some(Self::ActionsValidation),
            "TransactionSizeExceeded" => Some(Self::TransactionSizeExceeded),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Left = 0,
    Right = 1,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Direction::Left => "left",
            Direction::Right => "right",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "left" => Some(Self::Left),
            "right" => Some(Self::Right),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)

'''
'''--- substreams/src/utils/block_timestamp.rs ---
use chrono::{NaiveDateTime};
use substreams_near::pb::sf::near::r#type::v1::BlockHeader;

#[derive(Debug, PartialEq)]
pub struct BlockTimestamp(chrono::NaiveDateTime);

impl BlockTimestamp {

    pub fn from_block(block_header: &BlockHeader) -> Self {
        let timestamp = block_header.timestamp;

        BlockTimestamp(
            NaiveDateTime::from_timestamp_millis((timestamp / 1_000_000) as i64)
                .unwrap_or_else(|| panic!("invalid date for timestamp {}", timestamp)),
        )
    }

    // pub fn timestamp_to_date(&self) -> String {
    //     self.0.date().format("%Y-%m-%d").to_string()
    // }

    pub fn timestamp(&self) -> u64 {
        self.0.timestamp() as u64
    }

}
'''
'''--- substreams/src/utils/helpers.rs ---
use serde_json::Value;
use std::string::String;
use substreams_near::pb::sf::near::r#type::v1::CryptoHash;
use crate::config::MAX_ARGS_LENGTH;

pub fn bytes_to_near_amount(bytes: Vec<u8>) -> f64 {
    let bytes_array: [u8; 16] = bytes.try_into().expect("slice with incorrect length");
    let yocto_near = u128::from_be_bytes(bytes_array);
    yocto_near as f64 / 1e24
}

pub fn bs58_hash_to_string(hash: Option<CryptoHash>) -> String {
    match hash {
        Some(h) => bs58::encode(h.bytes).into_string(),
        None => "".to_string(),
    }
}

// Extracts the function call arguments from the action and limits the length to MAX_ARGS_LENGTH
pub fn extract_function_call_args(args: &Vec<u8>) -> String {
    let args_str = match std::str::from_utf8(args) {
        Ok(str) => str.to_string(),
        Err(_) => "".to_string(),
    };

    if args_str.len() > MAX_ARGS_LENGTH {
        return "".to_string();
    }

    args_str
}

pub fn extract_social_kind(method_name: &str, args: &[u8]) -> String {
    if method_name != "set" {
        return "".to_string();
    }

    let args_str = match std::str::from_utf8(args) {
        Ok(v) => v,
        Err(_) => return "".to_string(),
    };

    let v: Value = match serde_json::from_str(args_str) {
        Ok(val) => val,
        Err(_) => return "".to_string(),
    };

    let data = match v.get("data").and_then(|d| d.as_object()) {
        Some(data) => data,
        None => return "".to_string(),
    };

    let binding = "".to_string();
    let wallet_address = data.keys().next().unwrap_or(&binding);
    let user_data = data.get(wallet_address).unwrap_or(&Value::Null);

    determine_social_action_type(user_data)
}

fn determine_social_action_type(user_data: &Value) -> String {
    if let Some(post_data) = user_data.get("post") {
        if post_data.get("main").is_some() {
            return "Post".to_string();
        } else if post_data.get("comment").is_some() {
            return "Comment".to_string();
        }
    } else if user_data.get("index").and_then(|x| x.get("like")).is_some() {
        return "Like".to_string();
    } else if user_data.get("index").and_then(|x| x.get("repost")).is_some() {
        return "Repost".to_string();
    } else if user_data.get("profile").is_some() {
        return "Profile".to_string();
    } else if let Some(graph_data) = user_data.get("index").and_then(|x| x.get("graph")) {
        if graph_data.as_str().map_or(false, |s| s.contains("\"poke\"")) {
            return "Poke".to_string();
        }
    } else if user_data.get("graph").and_then(|x| x.get("follow")).is_some() {
        return if user_data.get("graph").and_then(|x| x.get("follow")).and_then(|f| f.as_object()).and_then(|o| o.values().next()).map_or(false, |v| v.is_string()) {
            "Follow"
        } else {
            "Unfollow"
        }.to_string();
    } else if user_data.get("widget").is_some() {
        return "Widget".to_string();
    } else if user_data.get("index").and_then(|x| x.get("notify")).is_some() {
        return "Notify".to_string();
    }

    "".to_string()
}
'''
'''--- substreams/src/utils/mod.rs ---
pub mod block_timestamp;
pub mod transform;
pub mod helpers;

'''
'''--- substreams/src/utils/transform.rs ---
use std::collections::HashMap;
use substreams_near::pb::sf::near::r#type::v1::{Action, ExecutionOutcome, Receipt, SignedTransaction};
use crate::pb::near::custom::v1::{TransactionMeta, BlockMeta, ReceiptActionMeta};
use substreams_near::pb::sf::near::r#type::v1::action::Action as ActionTypes;
use crate::config::TERAGAS_FACTOR;
use crate::utils::block_timestamp::BlockTimestamp;
use crate::utils::helpers::{bs58_hash_to_string, bytes_to_near_amount, extract_function_call_args, extract_social_kind};

pub fn transform_action(action: &Action, block: &BlockMeta, receipt: &Receipt, all_statuses: &HashMap<String, String>, action_index: u64) -> ReceiptActionMeta {
    let receipt_id_hash = bs58_hash_to_string(receipt.receipt_id.clone());

    let action_kind = match &action.action {
        Some(ActionTypes::FunctionCall(_)) => "FunctionCall",
        Some(ActionTypes::Transfer(_)) => "Transfer",
        Some(ActionTypes::Stake(_)) => "Stake",
        Some(ActionTypes::CreateAccount(_)) => "CreateAccount",
        Some(ActionTypes::DeployContract(_)) => "DeployContract",
        Some(ActionTypes::AddKey(_)) => "AddKey",
        Some(ActionTypes::DeleteKey(_)) => "DeleteKey",
        Some(ActionTypes::DeleteAccount(_)) => "DeleteAccount",
        Some(ActionTypes::Delegate(_)) => "Delegate",
        None => "Unknown",
    };

    let status = all_statuses.get(&receipt_id_hash).cloned().unwrap_or_else(|| "".to_string());

    let method_name = match &action.action {
        Some(ActionTypes::FunctionCall(function_call)) => function_call.method_name.clone(),
        _ => "".to_string(),
    };

    let args = match &action.action {
        Some(ActionTypes::FunctionCall(function_call)) => extract_function_call_args(&function_call.args),
        _ => "".to_string(),
    };

    let social_kind = match &action.action {
        Some(ActionTypes::FunctionCall(function_call)) => extract_social_kind(&method_name, &function_call.args),
        _ => "".to_string(),
    };

    let gas: u32 = match &action.action {
        Some(ActionTypes::FunctionCall(function_call)) => {
            function_call.gas.checked_div(TERAGAS_FACTOR).unwrap_or(0) as u32
        },
        _ => 0,
    };

    let deposit: f64 = match &action.action {
        Some(ActionTypes::FunctionCall(function_call)) => bytes_to_near_amount(function_call.clone().deposit.unwrap().bytes),
        Some(ActionTypes::Transfer(transfer)) => bytes_to_near_amount(transfer.clone().deposit.unwrap().bytes),
        _ => 0.0,
    };

    let stake: f64 = match &action.action {
        Some(ActionTypes::Stake(stake)) => bytes_to_near_amount(stake.stake.clone().unwrap().bytes),
        _ => 0.0,
    };

    ReceiptActionMeta {
        block_timestamp: block.block_timestamp,
        block_height: block.block_height,
        receipt_id: receipt_id_hash,
        predecessor_id: receipt.predecessor_id.clone(),
        receiver_id: receipt.receiver_id.clone(),
        action_kind: action_kind.to_string(),
        action_index,
        method_name,
        args,
        social_kind,
        gas,
        deposit,
        stake,
        status,
    }
}

pub fn transform_transaction(
    blk_timestamp: &BlockTimestamp,
    height: &u64,
    transaction: &SignedTransaction,
    outcome: &Option<ExecutionOutcome>
) -> Option<TransactionMeta> {
    let tx_hash = bs58_hash_to_string(transaction.hash.clone());

    let receipts: Vec<String> = if let Some(execution_outcome) = outcome {
        execution_outcome.receipt_ids.iter().map(|receipt_id| {
            bs58_hash_to_string(Some(receipt_id.clone()))
        }).collect()
    } else {
        vec![]
    };

    Some(TransactionMeta {
        block_timestamp: blk_timestamp.timestamp(),
        block_height: *height,
        tx_hash,
        receipt_id: receipts.join(","),
        signer_id: transaction.signer_id.to_string(),
        nonce: transaction.nonce,
        receiver_id: transaction.receiver_id.to_string(),
    })
}

'''