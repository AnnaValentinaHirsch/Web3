*GitHub Repository "muoi07052001/near-app-vote-sc"*

'''--- Cargo.toml ---
[package]
name = "app-vote-smart-contract"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-rng = "0.1.0"

[profile.release]
codegen-units = 1
# Tell 'rustc' to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
# App Vote Project

## Useful Links

1. [App Vote Domain](https://app-vote-git-developphase2-app-vote-front-end.vercel.app/)
2. [App Vote Repository](https://github.com/btc-studio/app-vote-smart-contract)

## What is App Vote?

A NEAR smart contract for the Near Protocol based voting app.

- Allow users/organizations to create voting Poll for anything
- Allow users/organizations to create criterias for each Poll
- Allow users/organizations to create answer options
- Allow users/organizations to vote for their Polls

## Built with

- [NEAR](https://near.org/)
- [Rust Programming Language](https://www.rust-lang.org/)

## Prerequisites

### Rust toolchain

- Install Rust toolchain:
  - Install rustup: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
  - Configure the current shell: `source $HOME/.cargo/env`
  - Add the wasm target to the blockchain network: `rustup target add wasm32-unknown-unknown`

### A NEAR account

- Create a NEAR account: https://wallet.testnet.near.org/create

### NEAR command-line interface (near-cli)

- Install near-cli: `npm install -g near-cli`

## App Vote Repository

### Overview

app-vote-smart-contract </br>
├── Cargo.toml </br>
├── README.md </br>
├── build.sh </br>
├── neardev </br>
├ ├── dev-account </br>
├   └── dev-account.env </br>
├── notes </br>
├   ├── DAO.md </br>
├   ├── build-test-stable.md </br>
├   ├── build-test.md </br>
├   └── build.md </br>
├── out </br>
├   └── app-vote-contract.wasm </br>
├── scripts </br>
├   ├── create-data.sh </br>
├   ├── log-deposit.sh </br>
├   └── log-deposit.txt </br>
├── src </br>
├ ├── criterias.rs </br>
├ ├── custom_struct.rs </br>
├ ├── event.rs </br>
├ ├── is_user_votes.rs </br>
├ ├── lib.rs </br>
├ ├── poll_options.rs </br>
├ ├── polls.rs </br>
├ ├── results.rs </br>
├ ├── tests.rs </br>
├ ├── users.rs </br>
└ └── utils.rs </br>

### Directory Details

- **build.sh** - Contains the build script
- **neardev** - The folder contains dev account which the Smart Contract being deployed to
- **out** - Contains .wasm file to push to blockchain
- **scripts** - Contains scripts
- **src** - Contains all the Smart Contract logic for App Vote

## Interacting with the App Vote contracts locally

### Deploy to testnet for usable API

1. Install dependencies

```shell
cargo install
```

2. Compile code to .wasm file

```shell
./build
```

3. Deploy to NEAR testnet

```shell
near dev-deploy ./out/app-vote-contract.wasm
```

4. Use smart contract id in **neardev/dev-account** to call in near-cli

```
near call dev-1660616028365-78983722768651 <command> <arguments>
```

> For more information, see: `/notes/build-test.md`

## Network

development

## Contracts

|   CONTRACT   |        ADDRESS        |
| :----------: | :-------------------: |
| **App Vote** | app-vote.btcs.testnet |

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./out
cp target/wasm32-unknown-unknown/release/*.wasm ./out/app-vote-contract.wasm
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1663063864254-30265345959004
'''
'''--- notes/DAO.md ---
## Proposals

- Add new proposal (Add Member to DAO)

```
near call btc-app-vote.sputnikv2.testnet add_proposal '{"proposal": {"description": "Add New Council", "kind": {"AddMemberToRole": {"member_id": "btcs-duongnh.testnet", "role": "council"}}}}' --accountId duongnh.testnet --amount 0.1
```

- Add new proposal (Add Poll to DAO)

```
near call btc-app-vote.sputnikv2.testnet add_proposal '{"proposal": {"description": "Should i learn a new technology", "kind": "Vote"}}' --accountId duongnh.testnet --amount 0.1
```

- View all proposals

```
near view btc-app-vote.sputnikv2.testnet get_proposals '{"from_index": 0, "limit": 10}'
```

- View 1 proposal

```
near view btc-app-vote.sputnikv2.testnet get_proposal '{"id": 0}'
```

## Vote

- Approve:

```
near call btc-app-vote.sputnikv2.testnet act_proposal '{"id": 1, "action": "VoteApprove"}' --accountId duongnh.testnet
```

- Reject:

```
near call btc-app-vote.sputnikv2.testnet act_proposal '{"id": 1, "action": "VoteReject"}' --accountId duongnh.testnet
```

'''
'''--- notes/build-test-stable.md ---
# How to build and test this contract

1. Create nft_contract_id -> deploy out/nft-contract.wasm to nft_contract_id (`nearhub-nft.duongnh.testnet`)

```
- ./build.sh
- near dev-deploy ./out/app-vote-contract.wasm
```

---

### Init contract

```
near call dev-1660616028365-78983722768651 new '{"owner_id": "duongnh.testnet"}' --accountId duongnh.testnet
```

---

### Users

1. Create a User:

```
near call dev-1660616028365-78983722768651 create_user '{"name": "Zuong", "role": "Admin", "email": "muoi07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of User in the Smart Contract
```
near view dev-1660616028365-78983722768651 user_total_supply
```

3. View list of Users (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1660616028365-78983722768651 get_all_users '{"from_index": 0, "limit": 10}'
```

4. View 1 User by user_id

```
near view dev-1660616028365-78983722768651 get_user_by_id '{"user_id": 1}'
```

5. View 1 User by wallet_address (Ex: Near Wallet)

```
near view dev-1660616028365-78983722768651 get_user_by_wallet_address '{"wallet_address": "duongnh.testnet"}'
```

6. Update User information

```
near call dev-1660616028365-78983722768651 update_user '{"user_id": 1, "name": "Hai", "role": "Admin", "email": "duong07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --accountId duongnh.testnet
```

7. Delete a User

```
near call dev-1660616028365-78983722768651 delete_user '{"user_id": 1}' --accountId duongnh.testnet
```

---

### Criterias

1. Create a Criteria:

```
near call dev-1660616028365-78983722768651 create_criteria '{"created_by": 1, "descriptions": ["The most handsome employee", "The most creative employee"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Criteria in the Smart Contract
```
near view dev-1660616028365-78983722768651 criteria_total_supply
```

3. View list of Criterias (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1660616028365-78983722768651 get_all_criterias '{"from_index": 0, "limit": 10}'
```
4. View 1 Criteria by criteria_id

```
near view dev-1660616028365-78983722768651 get_criteria_by_id '{"criteria_id": 1}'
```

5. Update Criteria information

```
near call dev-1660616028365-78983722768651 update_criteria '{"criteria_id": 1, "description": "Updated description"}' --accountId duongnh.testnet
```

6. Delete a Criteria

```
near call dev-1660616028365-78983722768651 delete_criteria '{"criteria_id": 1}' --accountId duongnh.testnet
```

---

### Poll Options

1. Create a Poll Option:

```
near call dev-1660616028365-78983722768651 create_poll_option '{"created_by": 1, "title": "Test Option", "description": "Test Option description", "options": ["Zuong", "Manh"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll Option in the Smart Contract
```
near view dev-1660616028365-78983722768651 poll_option_total_supply
```

3. View list of Poll Option (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1660616028365-78983722768651 get_all_poll_options '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll Option by poll_option_id

```
near view dev-1660616028365-78983722768651 get_poll_option_by_id '{"poll_option_id": 1}'
```

5. Update a Poll Option

```
near call dev-1660616028365-78983722768651 update_poll_option '{"poll_option_id": 1, "title": "Updated title", "description": "Updated description", options: ["Zuong", "Hieu"]}' --accountId duongnh.testnet
```

6. Delete a Poll Option

```
near call dev-1660616028365-78983722768651 delete_poll_option '{"poll_option_id": 1}' --accountId duongnh.testnet
```

---

### Polls

1. Create a Poll:

```
near call dev-1660616028365-78983722768651 create_poll '{"criteria_option_id_array": [{"criteria_id": 1, "poll_option_id": 1}, {"criteria_id": 2, "poll_option_id": 2}], "created_by": 1, "img_url": "", "title": "Test poll", "description": "Test poll description", "start_at": 0, "end_at": 0}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll in the Smart Contract
```
near view dev-1660616028365-78983722768651 poll_total_supply
```

3. View list of Poll (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1660616028365-78983722768651 get_all_polls '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll by poll_id

```
near view dev-1660616028365-78983722768651 get_poll_by_id '{"poll_id": 1}'
```

5. Update Poll information

```
near call dev-1660616028365-78983722768651 update_poll '{"poll_id": 1, "img_url": "", "title": "Updated title", "description": "Updated description", "start_at": 0, "end_at": 0}' --accountId duongnh.testnet
```

6. Delete a Poll

```
near call dev-1660616028365-78983722768651 delete_poll '{"poll_id": 1}' --accountId duongnh.testnet
```

---
### Results
1. View list of Results (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1660616028365-78983722768651 get_all_results '{"from_index": 0, "limit": 10}'
```

2. View total number of Result in the Smart Contract
```
near view dev-1660616028365-78983722768651 result_total_supply
```

3. View list of Results of 1 Poll of the Contract

```
near view dev-1660616028365-78983722768651 get_all_results_by_poll_criteria_id '{"poll_id": 1, "criteria_id": 1}'

```

4. Update Result information

```
near call dev-1660616028365-78983722768651 vote '{"voted_user_id": 1, "poll_id": 1, "criteria_option_array": [{"criteria_id": 1,"option": "Duong"}, {"criteria_id": 2,"option": "Manh"}]}' --accountId duongnh.testnet --gas 30000000000000
```

5. Get the number of Users who voted for a poll
```
near view dev-1660616028365-78983722768651 num_users_vote_for_a_poll '{"poll_id": 1}'
```

5. Delete a Result

```
near call dev-1660616028365-78983722768651 delete_result '{"result_id": 1}' --accountId duongnh.testnet
```

---
## Is Voted
1. Check if a User has voted for a Poll or not
```
near view dev-1660616028365-78983722768651 is_voted '{"user_id": 1, "poll_id": 1}'
```

2. View list of IsUserVote (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)
```
near view dev-1660616028365-78983722768651 get_all_is_user_votes '{"from_index": 0, "limit": 10}'
```

## Thứ tự delete
- Delete Poll
- Delete Criteria
- Delete Poll Option
- Delele User
'''
'''--- notes/build-test.md ---
# How to build and test this contract

1. Create nft_contract_id -> deploy out/nft-contract.wasm to nft_contract_id (`nearhub-nft.duongnh.testnet`)

```
- ./build.sh
- near dev-deploy ./out/app-vote-contract.wasm
```

---

### Init contract

```
near call dev-1663063864254-30265345959004 new '{"owner_id": "duongnh.testnet"}' --accountId duongnh.testnet
```

---

### Users

1. Create a User:

```
near call dev-1663063864254-30265345959004 create_user '{"name": "Zuong", "role": "Admin", "email": "muoi07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of User in the Smart Contract
```
near view dev-1663063864254-30265345959004 user_total_supply
```

3. View list of Users (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1663063864254-30265345959004 get_all_users '{"from_index": 0, "limit": 10}'
```

4. View 1 User by user_id

```
near view dev-1663063864254-30265345959004 get_user_by_id '{"user_id": 1}'
```

5. View 1 User by wallet_address (Ex: Near Wallet)

```
near view dev-1663063864254-30265345959004 get_user_by_wallet_address '{"wallet_address": "duongnh.testnet"}'
```

6. Update User information

```
near call dev-1663063864254-30265345959004 update_user '{"user_id": 1, "name": "Hai", "role": "Admin", "email": "duong07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --accountId duongnh.testnet
```

7. Delete a User

```
near call dev-1663063864254-30265345959004 delete_user '{"user_id": 1}' --accountId duongnh.testnet
```

---

### Criterias

1. Create a Criteria:

```
near call dev-1663063864254-30265345959004 create_criteria '{"created_by": 1, "descriptions": ["The most handsome employee", "The most creative employee"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Criteria in the Smart Contract
```
near view dev-1663063864254-30265345959004 criteria_total_supply
```

3. View list of Criterias (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1663063864254-30265345959004 get_all_criterias '{"from_index": 0, "limit": 10}'
```
4. View 1 Criteria by criteria_id

```
near view dev-1663063864254-30265345959004 get_criteria_by_id '{"criteria_id": 1}'
```

5. Update Criteria information

```
near call dev-1663063864254-30265345959004 update_criteria '{"criteria_id": 1, "description": "Updated description"}' --accountId duongnh.testnet
```

6. Delete a Criteria

```
near call dev-1663063864254-30265345959004 delete_criteria '{"criteria_id": 1}' --accountId duongnh.testnet
```

---

### Poll Options

1. Create a Poll Option:

```
near call dev-1663063864254-30265345959004 create_poll_option '{"created_by": 1, "title": "Test Option", "description": "Test Option description", "options": ["Zuong", "Manh"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll Option in the Smart Contract
```
near view dev-1663063864254-30265345959004 poll_option_total_supply
```

3. View list of Poll Option (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1663063864254-30265345959004 get_all_poll_options '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll Option by poll_option_id

```
near view dev-1663063864254-30265345959004 get_poll_option_by_id '{"poll_option_id": 1}'
```

5. Update a Poll Option

```
near call dev-1663063864254-30265345959004 update_poll_option '{"poll_option_id": 1, "title": "Updated title", "description": "Updated description", options: ["Zuong", "Hieu"]}' --accountId duongnh.testnet
```

6. Delete a Poll Option

```
near call dev-1663063864254-30265345959004 delete_poll_option '{"poll_option_id": 1}' --accountId duongnh.testnet
```

---

### Polls

1. Create a Poll:

```
near call dev-1663063864254-30265345959004 create_poll '{"criteria_option_id_array": [{"criteria_id": 1, "poll_option_id": 1}, {"criteria_id": 2, "poll_option_id": 2}], "created_by": 1, "img_url": "", "title": "Test poll", "description": "Test poll description", "start_at": 0, "end_at": 0}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll in the Smart Contract
```
near view dev-1663063864254-30265345959004 poll_total_supply
```

3. View list of Poll (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1663063864254-30265345959004 get_all_polls '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll by poll_id

```
near view dev-1663063864254-30265345959004 get_poll_by_id '{"poll_id": 1}'
```

5. Update Poll information

```
near call dev-1663063864254-30265345959004 update_poll '{"poll_id": 1, "img_url": "", "title": "Updated title", "description": "Updated description", "start_at": 0, "end_at": 0}' --accountId duongnh.testnet
```

6. Delete a Poll

```
near call dev-1663063864254-30265345959004 delete_poll '{"poll_id": 1}' --accountId duongnh.testnet
```

---
### Results
1. View list of Results (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view dev-1663063864254-30265345959004 get_all_results '{"from_index": 0, "limit": 10}'
```

2. View total number of Result in the Smart Contract
```
near view dev-1663063864254-30265345959004 result_total_supply
```

3. View list of Results of 1 Poll of the Contract

```
near view dev-1663063864254-30265345959004 get_all_results_by_poll_criteria_id '{"poll_id": 1, "criteria_id": 1}'

```

4. Update Result information

```
near call dev-1663063864254-30265345959004 vote '{"voted_user_id": 1, "poll_id": 1, "criteria_option_array": [{"criteria_id": 1,"option": "Hamburger"}, {"criteria_id": 2,"option": "Pepsi"}]}' --accountId duongnh.testnet --gas 300000000000000
```

5. Get the number of Users who voted for a poll
```
near view dev-1663063864254-30265345959004 num_users_vote_for_a_poll '{"poll_id": 1}'
```

5. Delete a Result

```
near call dev-1663063864254-30265345959004 delete_result '{"result_id": 1}' --accountId duongnh.testnet
```

---
## Is Voted
1. Check if a User has voted for a Poll or not
```
near view dev-1663063864254-30265345959004 is_voted '{"user_id": 1, "poll_id": 1}'
```

2. View list of IsUserVote (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)
```
near view dev-1663063864254-30265345959004 get_all_is_user_votes '{"from_index": 0, "limit": 10}'
```

## Thứ tự delete
- Delete Poll
- Delete Criteria
- Delete Poll Option
- Delele User
'''
'''--- notes/build.md ---
# How to build and test this contract

1. Deploy Smart Contract into a stable account

```
- ./build.sh
- near deploy --wasmFile ./out/app-vote-contract.wasm --accountId app-vote.btcs.testnet --initFunction new --initArgs '{"owner_id": "btcs.testnet"}'
```

---

### Init contract

```
near call app-vote.btcs.testnet new '{"owner_id": "duongnh.testnet"}' --accountId duongnh.testnet
```

---

### Users

1. Create a User:

```
near call app-vote.btcs.testnet create_user '{"name": "Zuong", "role": "Admin", "email": "muoi07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of User in the Smart Contract

```
near view app-vote.btcs.testnet user_total_supply
```

3. View list of Users (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_users '{"from_index": 0, "limit": 10}'
```

4. View 1 User by user_id

```
near view app-vote.btcs.testnet get_user_by_id '{"user_id": 1}'
```

5. View 1 User by wallet_address (Ex: Near Wallet)

```
near view app-vote.btcs.testnet get_user_by_wallet_address '{"wallet_address": "duongnh.testnet"}'
```

6. Update User information

```
near call app-vote.btcs.testnet update_user '{"user_id": 1, "name": "Hai", "role": "Admin", "email": "duong07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --accountId duongnh.testnet
```

7. Delete a User

```
near call app-vote.btcs.testnet delete_user '{"user_id": 1}' --accountId duongnh.testnet
```

---

### Criterias

1. Create a Criteria:

```
near call app-vote.btcs.testnet create_criteria '{"created_by": 1, "descriptions": ["The most handsome employee", "The most creative employee"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Criteria in the Smart Contract

```
near view app-vote.btcs.testnet criteria_total_supply
```

3. View list of Criterias (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_criterias '{"from_index": 0, "limit": 10}'
```

4. View 1 Criteria by criteria_id

```
near view app-vote.btcs.testnet get_criteria_by_id '{"criteria_id": 1}'
```

5. Update Criteria information

```
near call app-vote.btcs.testnet update_criteria '{"criteria_id": 1, "description": "Updated description"}' --accountId duongnh.testnet
```

6. Delete a Criteria

```
near call app-vote.btcs.testnet delete_criteria '{"criteria_id": 1}' --accountId duongnh.testnet
```

---

### Poll Options

1. Create a Poll Option:

```
near call app-vote.btcs.testnet create_poll_option '{"created_by": 1, "title": "Test Option", "description": "Test Option description", "options": ["Zuong", "Manh"]}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll Option in the Smart Contract

```
near view app-vote.btcs.testnet poll_option_total_supply
```

3. View list of Poll Option (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_poll_options '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll Option by poll_option_id

```
near view app-vote.btcs.testnet get_poll_option_by_id '{"poll_option_id": 1}'
```

5. Update a Poll Option

```
near call app-vote.btcs.testnet update_poll_option '{"poll_option_id": 1, "title": "Updated title", "description": "Updated description", options: ["Zuong", "Hieu"]}' --accountId duongnh.testnet
```

6. Delete a Poll Option

```
near call app-vote.btcs.testnet delete_poll_option '{"poll_option_id": 1}' --accountId duongnh.testnet
```

---

### Polls

1. Create a Poll:

```
near call app-vote.btcs.testnet create_poll '{"criteria_option_id_array": [{"criteria_id": 1, "poll_option_id": 1}, {"criteria_id": 2, "poll_option_id": 2}], "created_by": 1, "img_url": "", "title": "Test poll", "description": "Test poll description", "start_at": 0, "end_at": 0}' --deposit 0.1 --accountId duongnh.testnet
```

2. View total number of Poll in the Smart Contract

```
near view app-vote.btcs.testnet poll_total_supply
```

3. View list of Poll (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_polls '{"from_index": 0, "limit": 10}'
```

4. View 1 Poll by poll_id

```
near view app-vote.btcs.testnet get_poll_by_id '{"poll_id": 1}'
```

5. Update Poll information

```
near call app-vote.btcs.testnet update_poll '{"poll_id": 1, "img_url": "", "title": "Updated title", "description": "Updated description", "start_at": 0, "end_at": 0}' --accountId duongnh.testnet
```

6. Delete a Poll

```
near call app-vote.btcs.testnet delete_poll '{"poll_id": 1}' --accountId duongnh.testnet
```

---

### Results

1. View list of Results (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_results '{"from_index": 0, "limit": 10}'
```

2. View total number of Result in the Smart Contract

```
near view app-vote.btcs.testnet result_total_supply
```

3. View list of Results of 1 Poll of the Contract

```
near view app-vote.btcs.testnet get_all_results_by_poll_criteria_id '{"poll_id": 1, "criteria_id": 1}'

```

4. Update Result information

```
near call app-vote.btcs.testnet vote '{"voted_user_id": 1, "poll_id": 1, "criteria_option_array": [{"criteria_id": 1,"option": "Hamburger"}, {"criteria_id": 2,"option": "Pepsi"}]}' --accountId duongnh.testnet --gas 300000000000000
```

5. Get the number of Users who voted for a poll
```
near view app-vote.btcs.testnet num_users_vote_for_a_poll '{"poll_id": 1}'
```

5. Delete a Result

```
near call app-vote.btcs.testnet delete_result '{"result_id": 1}' --accountId duongnh.testnet
```

---

## Is Voted

1. Check if a User has voted for a Poll or not

```
near view app-vote.btcs.testnet is_voted '{"user_id": 1, "poll_id": 1}'
```

2. View list of IsUserVote (with pagination) of the Contract: (`from_index`: integer, `limit`: integer)

```
near view app-vote.btcs.testnet get_all_is_user_votes '{"from_index": 0, "limit": 10}'
```

'''
'''--- scripts/create-data.sh ---
# Create Users
near call dev-1661499707374-98283221529225 create_user '{"name": "Zuong", "role": "Admin", "email": "muoi07052001@gmail.com", "blockchain_type": "Near", "wallet_address": "duongnh.testnet"}' --deposit 0.1 --accountId duongnh.testnet
near call dev-1661499707374-98283221529225 create_user '{"name": "Nguyen Xuan Hai", "role": "Admin", "email": "hainx@gmail.com", "blockchain_type": "Near", "wallet_address": "hainx.testnet"}' --deposit 0.1 --accountId duongnh.testnet
near call dev-1661499707374-98283221529225 create_user '{"name": "Nguyen Duc Toan", "role": "Employee", "email": "toannd@gmail.com", "blockchain_type": "Near", "wallet_address": "toannd.testnet"}' --deposit 0.1 --accountId duongnh.testnet
near call dev-1661499707374-98283221529225 create_user '{"name": "Phi Duc Binh", "role": "Employee", "email": "binhpd@gmail.com", "blockchain_type": "Near", "wallet_address": "binhpd.testnet"}' --deposit 0.1 --accountId duongnh.testnet

# Create Criterias
near call dev-1661499707374-98283221529225 create_criteria '{"created_by": 1, "descriptions": ["The best food", "The best drink"]}' --deposit 0.1 --accountId duongnh.testnet
near call dev-1661499707374-98283221529225 create_criteria '{"created_by": 2, "descriptions": ["The most handsome employee", "The most creative employee"]}' --deposit 0.1 --accountId duongnh.testnet

# Create Poll Options
near call dev-1661499707374-98283221529225 create_poll_option '{"created_by": 1, "title": "The best food", "description": "The best food for developers", "options": ["Hamburger", "Chicken"]}' --deposit 0.1 --accountId duongnh.testnet
near call dev-1661499707374-98283221529225 create_poll_option '{"created_by": 1, "title": "The best drink", "description": "The best drink for developers", "options": ["Coca", "Pepsi", "Fanta"]}' --deposit 0.1 --accountId duongnh.testnet

# Create Polls
near call dev-1661499707374-98283221529225 create_poll '{"criteria_option_id_array": [{"criteria_id": 1, "poll_option_id": 1}, {"criteria_id": 2, "poll_option_id": 2}], "created_by": 1, "img_url": "", "title": "How to keep energy", "description": "Things that developers love", "start_at": 0, "end_at": 0}' --deposit 0.1 --accountId duongnh.testnet

# Get all results
near view dev-1661499707374-98283221529225 get_all_results '{"from_index": 0, "limit": 100}'
near view dev-1661499707374-98283221529225 get_all_results_by_poll_criteria_id '{"poll_id": 1, "criteria_id": 1}'
'''
'''--- scripts/log-deposit.sh ---
# Random

# Users
echo "------------- USERS STORAGE FEE -------------" >> log-deposit.txt
for((i = 0; i < 10; i++))
do
    # Generate a random string's character number
    # -> Generate a random string for params
    RAN_STR1=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR2=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR3=$(openssl rand -base64 $(($RANDOM % 20)))

    $(near call dev-1661499707374-98283221529225 create_user "{\"name\": \"$RAN_STR1\", \"role\": \"Admin\", \"email\": \"$RAN_STR2@gmail.com\", \"blockchain_type\": \"Near\", \"wallet_address\": \"$RAN_STR3.testnet\"}" --deposit 0.5 --accountId duongnh.testnet > temp.txt)

    # Extract storage data + fee from Contract Call Output
    OUTPUT_FEE=$(grep 'Storage fee' ./temp.txt)
    OUTPUT_DATA=$(grep 'Storage data' ./temp.txt)
    SUBSTRING_FEE=$(echo $OUTPUT_FEE| cut -d':' -f 3)
    SUBSTRING_DATA=$(echo $OUTPUT_DATA| cut -d':' -f 3)

    echo "create_user: $SUBSTRING_DATA bytes - $SUBSTRING_FEE yoctoNear" >> log-deposit.txt
done

echo "\n" >> log-deposit.txt

# Criterias
echo "------------- CRITERIAS STORAGE FEE -------------" >> log-deposit.txt
for((i = 0; i < 10; i++))
do
    # Generate a random string's character number
    # -> Generate a random string for params
    RAN_STR1=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR2=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR3=$(openssl rand -base64 $(($RANDOM % 10)))

    near call dev-1661499707374-98283221529225 create_criteria "{\"created_by\": 5, \"descriptions\": [\"$RAN_STR1\", \"$RAN_STR2\", \"$RAN_STR3\"]}" --deposit 0.5 --accountId duongnh.testnet > temp.txt

    # Extract storage data + fee from Contract Call Output
    OUTPUT_FEE=$(grep 'Storage fee' ./temp.txt)
    OUTPUT_DATA=$(grep 'Storage data' ./temp.txt)
    SUBSTRING_FEE=$(echo $OUTPUT_FEE| cut -d':' -f 3)
    SUBSTRING_DATA=$(echo $OUTPUT_DATA| cut -d':' -f 3)

    echo "create_criteria: $SUBSTRING_DATA bytes - $SUBSTRING_FEE yoctoNear" >> log-deposit.txt
done

echo "\n" >> log-deposit.txt

# Options
echo "------------- ANSWER OPTIONS STORAGE FEE -------------" >> log-deposit.txt
for((i = 0; i < 10; i++))
do
    # Generate a random string's character number
    # -> Generate a random string for params
    RAN_STR1=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR2=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR3=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR4=$(openssl rand -base64 $(($RANDOM % 10)))

    near call dev-1661499707374-98283221529225 create_poll_option "{\"created_by\": 5, \"title\": \"$RAN_STR1\", \"description\": \"$RAN_STR2\", \"options\": [\"$RAN_STR3\", \"$RAN_STR4\"]}" --deposit 0.5 --accountId duongnh.testnet > temp.txt

    # Extract storage data + fee from Contract Call Output
    OUTPUT_FEE=$(grep 'Storage fee' ./temp.txt)
    OUTPUT_DATA=$(grep 'Storage data' ./temp.txt)
    SUBSTRING_FEE=$(echo $OUTPUT_FEE| cut -d':' -f 3)
    SUBSTRING_DATA=$(echo $OUTPUT_DATA| cut -d':' -f 3)

    echo "create_poll_option: $SUBSTRING_DATA bytes - $SUBSTRING_FEE yoctoNear" >> log-deposit.txt
done

echo "\n" >> log-deposit.txt

# Polls
echo "------------- POLLS STORAGE FEE -------------" >> log-deposit.txt
for((i = 0; i < 10; i++))
do
    # Generate a random string's character number
    # -> Generate a random string for params
    RAN_STR1=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR2=$(openssl rand -base64 $(($RANDOM % 10)))
    RAN_STR3=$(openssl rand -base64 $(($RANDOM % 10)))

    near call dev-1661499707374-98283221529225 create_poll "{\"criteria_option_id_array\": [{\"criteria_id\": 5, \"poll_option_id\": 5}, {\"criteria_id\": 2, \"poll_option_id\": 2}], \"created_by\": 5, \"img_url\": \"$RAN_STR1\", \"title\": \"$RAN_STR2\", \"description\": \"$RAN_STR3\", \"start_at\": 0, \"end_at\": 0}" --deposit 0.5 --accountId duongnh.testnet > temp.txt

    # Extract storage data + fee from Contract Call Output
    OUTPUT_FEE=$(grep 'Storage fee' ./temp.txt)
    echo "create_poll: $OUTPUT_FEE yoctoNear" >> log-deposit.txt
done

# Remove temporary file
rm temp.txt
'''
'''--- scripts/log-deposit.txt ---
------------- USERS STORAGE FEE -------------
create_user:  228 bytes -  2280000000000000000000 yoctoNear
create_user:  212 bytes -  2120000000000000000000 yoctoNear
create_user:  216 bytes -  2160000000000000000000 yoctoNear
create_user:  236 bytes -  2360000000000000000000 yoctoNear
create_user:  228 bytes -  2280000000000000000000 yoctoNear
create_user:  240 bytes -  2400000000000000000000 yoctoNear
create_user:  252 bytes -  2520000000000000000000 yoctoNear
create_user:  228 bytes -  2280000000000000000000 yoctoNear
create_user:  228 bytes -  2280000000000000000000 yoctoNear
create_user:  220 bytes -  2200000000000000000000 yoctoNear

------------- CRITERIAS STORAGE FEE -------------
create_criteria:  540 bytes -  5400000000000000000000 yoctoNear
create_criteria:  560 bytes -  5600000000000000000000 yoctoNear
create_criteria:  564 bytes -  5640000000000000000000 yoctoNear
create_criteria:  552 bytes -  5520000000000000000000 yoctoNear
create_criteria:  568 bytes -  5680000000000000000000 yoctoNear
create_criteria:  556 bytes -  5560000000000000000000 yoctoNear
create_criteria:  568 bytes -  5680000000000000000000 yoctoNear
create_criteria:  568 bytes -  5680000000000000000000 yoctoNear
create_criteria:  544 bytes -  5440000000000000000000 yoctoNear
create_criteria:  576 bytes -  5760000000000000000000 yoctoNear

------------- ANSWER OPTIONS STORAGE FEE -------------
create_poll_option:  216 bytes -  2160000000000000000000 yoctoNear
create_poll_option:  236 bytes -  2360000000000000000000 yoctoNear
create_poll_option:  212 bytes -  2120000000000000000000 yoctoNear
create_poll_option:  212 bytes -  2120000000000000000000 yoctoNear
create_poll_option:  208 bytes -  2080000000000000000000 yoctoNear
create_poll_option:  208 bytes -  2080000000000000000000 yoctoNear
create_poll_option:  216 bytes -  2160000000000000000000 yoctoNear
create_poll_option:  244 bytes -  2440000000000000000000 yoctoNear
create_poll_option:  208 bytes -  2080000000000000000000 yoctoNear
create_poll_option:  224 bytes -  2240000000000000000000 yoctoNear

------------- POLLS STORAGE FEE -------------
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2590000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2550000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2430000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2390000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2430000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2390000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2390000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2390000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2310000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear
create_poll: 	Log [dev-1661499707374-98283221529225]: Storage fee: 2310000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1920000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1880000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000
	Log [dev-1661499707374-98283221529225]: Storage fee: 1960000000000000000000 yoctoNear

'''
'''--- src/criterias.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    // ----------------------------------------- CREATE -----------------------------------------
    /**
     * - Create a new Criteria
     * - Ask user to deposit an amount of NEAR to cover storage data fee
     * - Add Criteria into criterias_by_id
     * - Refund redundant deposited NEAR back to user
     */
    #[payable]
    pub fn create_criteria(&mut self, created_by: UserId, descriptions: Vec<String>) {
        let before_storage_usage = env::storage_usage(); // Used to calculate the amount of redundant NEAR when users deposit

        // Check if the user_id exists or not
        assert!(
            self.users_by_id.get(&created_by).is_some(),
            "User does not exist"
        );

        // Create multiple criterias due to Array of desc
        for description in descriptions {
            let criteria_id = self.criterias_by_id_counter;

            // Create new Criteria
            let new_criteria = Criteria {
                id: criteria_id,
                created_by,
                description: description,
                created_at: Some(env::block_timestamp()),
                updated_at: None,
            };

            // Insert new Criteria into criterias_by_id (list of Criterias of this Smart Contract)
            self.criterias_by_id.insert(&criteria_id, &new_criteria);

            // Update Criteria Id Counter
            self.criterias_by_id_counter += 1;

            // EVENT LOG
            let create_criteria_log: EventLog = EventLog {
                standard: "nep297".to_string(),
                version: "1.0.0".to_string(),
                event: EventLogVariant::CreateCriteria,
                data: serde_json::to_string(&new_criteria).unwrap(),
            };

            log!(
                "EVENT_JSON:{}",
                serde_json::to_string(&create_criteria_log).unwrap()
            );
        }
        // Used data storage = after_storage_usage - before_storage_usage
        let after_storage_usage = env::storage_usage();
        // Refund NEAR
        refund_deposit(after_storage_usage - before_storage_usage);
    }

    // ----------------------------------------- READ -----------------------------------------
    // Get total number of User in the Smart Contract
    pub fn criteria_total_supply(&self) -> u64 {
        // Count the number of criteria_id in criterias_by_id
        self.criterias_by_id.len()
    }

    // Get list of all Criterias in this Smart Contract (with pagination)
    pub fn get_all_criterias(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Criteria> {
        self.criterias_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(criteria_id, _criteria)| self.criterias_by_id.get(&criteria_id).unwrap())
            .collect()
    }

    // Get 1 Criteria by id
    pub fn get_criteria_by_id(&self, criteria_id: CriteriaId) -> Criteria {
        self.criterias_by_id
            .get(&criteria_id)
            .expect("Criteria does not exist")
    }

    // ----------------------------------------- UPDATE -----------------------------------------
    // Update Criteria information
    pub fn update_criteria(
        &mut self,
        criteria_id: CriteriaId,
        description: String, // Description of the Criteria
    ) -> Criteria {
        let criteria = self
            .criterias_by_id
            .get(&criteria_id)
            .expect("This criteria does not exist");

        let updated_criteria = Criteria {
            id: criteria.id,
            created_by: criteria.created_by, // The user who created this criteria (Can't be change)
            description,
            created_at: criteria.created_at,
            updated_at: Some(env::block_timestamp()),
        };

        // Update criterias_by_id
        self.criterias_by_id.insert(&criteria_id, &updated_criteria);

         // EVENT LOG
         let update_criteria_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::UpdateCriteria,
            data: serde_json::to_string(&updated_criteria).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&update_criteria_log).unwrap()
        );

        updated_criteria
    }

    // Delete Criteria from the Smart Contract
    pub fn delete_criteria(&mut self, criteria_id: CriteriaId) {
        // Check if this Criteria is a foreign key in Poll or not
        for (_poll_id, poll) in self.polls_by_id.iter() {
            for criteria_option_id in poll.criteria_option_id_array.clone() {
                assert!(
                    criteria_option_id.criteria_id != criteria_id,
                    "Cannot delete this Criteria! This Criteria is linked to a Poll record!"
                );
            }
        }

        // Delete Result belongs to this Criteria
        let mut remove_result_set = vec![]; // Vector of result_ids that need to be deleted
        for (result_id, result) in self.results_by_id.iter() {
            if result.criteria_id == criteria_id {
                remove_result_set.push(result_id);
            }
        }
        log!("Remove result set: {:?}", remove_result_set);
        for result_id in remove_result_set {
            self.results_by_id.remove(&result_id).unwrap();
        }

        // Delete Criteria
        self.criterias_by_id
            .remove(&criteria_id)
            .expect("This criteria does not exists");
    }
}

'''
'''--- src/custom_struct.rs ---
use crate::*;

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    Admin,
    Employee,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum BlockchainType {
    Near,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct UserWallet {
    pub blockchain_type: BlockchainType, // Blockchain's type of this User Wallet
    pub wallet_address: String,          // Wallet Account
}

// ----------------------------------- User Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct User {
    pub id: UserId,              // Id of the User
    pub name: AccountId,         // Name of the User
    pub role: Role,              // Role of the User
    pub email: String,           // Email of the User
    pub user_wallet: UserWallet, // Blockchain Wallet of the User
    pub created_at: Option<Timestamp>,
    pub updated_at: Option<Timestamp>,
}

// ----------------------------------- Criteria Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Criteria {
    pub id: CriteriaId,      // Id of the Criteria
    pub created_by: UserId,  // Id of the User who created this Criteria
    pub description: String, // Description of the Criteria
    pub created_at: Option<Timestamp>,
    pub updated_at: Option<Timestamp>,
}

// ----------------------------------- Poll Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Poll {
    pub id: PollId,                                      // Id of the Poll
    pub criteria_option_id_array: Vec<CriteriaOptionId>, // Array of relative Criterias and Answer Options for this Poll
    pub created_by: UserId,                              // Id of the User who vote
    pub img_url: Option<String>,                         // URL of the Poll's image
    pub title: String,                                   // Title of the Poll
    pub description: String,                             // Description of the Poll
    pub start_at: Option<Timestamp>, // Start time of the Vote (In epoch -> nanoseconds)
    pub end_at: Option<Timestamp>,   // End time of the Vote (In epoch -> nanoseconds)
    pub created_at: Option<Timestamp>,
    pub updated_at: Option<Timestamp>,
}

// ----------------------------------- Option Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PollOption {
    pub id: PollOptionId,
    pub created_by: UserId,   // Id of the User who vote
    pub title: String,        // Title of the PollOption
    pub description: String,  // Description of the PollOption
    pub options: Vec<String>, // List of options of this poll option
    pub created_at: Option<Timestamp>,
    pub updated_at: Option<Timestamp>,
}

// ----------------------------------- Result Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Result {
    pub id: ResultId,            // Id of the Result
    pub criteria_id: CriteriaId, // Id of the Criteria this Vote belongs to
    pub poll_id: PollId,         // Id of the Poll this Vote belongs to
    pub option: String,          // The Option that being Voted
    pub total_vote: u32,         // Total Vote for this User
    pub created_at: Option<Timestamp>,
    pub updated_at: Option<Timestamp>,
}
// ----------------------------------- Result by a Poll's Criteria Struct -----------------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ResultByPollCriteria {
    pub poll_id: PollId,         // Id of the Poll this Vote belongs to
    pub criteria_id: CriteriaId, // Id of the Criteria this Vote belongs to
    pub option: String,          // Id of the User of the Vote
    pub total_vote: u32,         // Total Vote for this User
}

// ------------------------ Check if user_id has voted for poll_id or not ------------------------
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct IsUserVote {
    pub user_id: UserId, // If of the User
    pub poll_id: PollId, // If of the Poll
    pub is_voted: bool,  // Check if this User has voted for this Poll or not
}

// An Option id due to a Criteria
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CriteriaOption {
    pub criteria_id: CriteriaId,
    pub option: String,
}

// An Option id due to a Criteria
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CriteriaOptionId {
    pub criteria_id: CriteriaId,
    pub poll_option_id: PollOptionId,
}

'''
'''--- src/event.rs ---
/**
 * Để các ứng dụng (bên thứ 3) theo dõi được các
 * hành động (events) cho tất cả các Near-driven apps.
 */
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;

/// Enum that represents the data type of the EventLog.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    CreateUser,
    UpdateUser,
    CreateCriteria,
    UpdateCriteria,
    CreatePollOption,
    UpdatePollOption,
    CreatePoll,
    UpdatePoll,
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
/// * `data`?: Stringified JSON 
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
    pub data: String,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

// --- EXAMPLE INTERFACE ---
// /// An event log to capture token minting
// ///
// /// Arguments
// /// * `owner_id`: "account.near"
// /// * `token_ids`: ["1", "abc"]
// /// * `memo`: optional message
// #[derive(Serialize, Deserialize, Debug)]
// #[serde(crate = "near_sdk::serde")]
// pub struct NftMintLog {
//     pub owner_id: String,
//     pub token_ids: Vec<String>,
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn nep_format_vector() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftMint(vec![
//                 NftMintLog {
//                     owner_id: "foundation.near".to_owned(),
//                     token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
//                     memo: None,
//                 },
//                 NftMintLog {
//                     owner_id: "user1.near".to_owned(),
//                     token_ids: vec!["meme".to_string()],
//                     memo: None,
//                 },
//             ]),
//         };
//         assert_eq!(expected, log.to_string());
//     }

//     #[test]
//     fn nep_format_mint() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftMint(vec![NftMintLog {
//                 owner_id: "foundation.near".to_owned(),
//                 token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
//                 memo: None,
//             }]),
//         };
//         assert_eq!(expected, log.to_string());
//     }

//     #[test]
//     fn nep_format_transfer_all_fields() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftTransfer(vec![NftTransferLog {
//                 authorized_id: Some("market.near".to_string()),
//                 old_owner_id: "user1.near".to_string(),
//                 new_owner_id: "user2.near".to_string(),
//                 token_ids: vec!["token".to_string()],
//                 memo: Some("Go Team!".to_owned()),
//             }]),
//         };
//         assert_eq!(expected, log.to_string());
//     }
// }
'''
'''--- src/is_user_votes.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    pub fn is_voted(&self, user_id: UserId, poll_id: PollId) -> bool {
        let mut is_voted = false; // Default value

        for (_is_user_vote_id, is_user_vote) in self.is_user_votes_by_id.iter() {
            if is_user_vote.user_id == user_id && is_user_vote.poll_id == poll_id {
                is_voted = is_user_vote.is_voted;
            }
        }

        is_voted
    }

    pub fn get_all_is_user_votes(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<IsUserVote> {
        self.is_user_votes_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(is_user_vote_id, _is_user_vote)| {
                self.is_user_votes_by_id.get(&is_user_vote_id).unwrap()
            })
            .collect()
    }
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise, Timestamp, log, serde_json};

pub type UserId = u32;
pub type CriteriaId = u32;
pub type PollId = u32;
pub type PollOptionId = u32;
pub type ResultId = u32;
pub type IsUserVoteId = u32;

pub use crate::criterias::*;
pub use crate::custom_struct::*;
pub use crate::is_user_votes::*;
pub use crate::poll_options::*;
pub use crate::polls::*;
pub use crate::results::*;
pub use crate::tests::*;
pub use crate::users::*;
pub use crate::event::*;
use crate::utils::*;

mod criterias;
mod custom_struct;
mod is_user_votes;
mod poll_options;
mod polls;
mod results;
mod tests;
mod users;
mod event;
mod utils;

const PAGINATION_SIZE: u64 = 10;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct AppVoteContract {
    pub owner_id: AccountId, // Account id of the Smart Contract
    pub users_by_id: UnorderedMap<UserId, User>, // List of Users in this Smart Contract
    pub criterias_by_id: UnorderedMap<CriteriaId, Criteria>, // List of Criterias in this Smart Contract
    pub polls_by_id: UnorderedMap<PollId, Poll>,             // List of Votes in this Smart Contract
    pub poll_options_by_id: UnorderedMap<PollOptionId, PollOption>, // List of Results in this Smart Contract
    pub results_by_id: UnorderedMap<ResultId, Result>, // List of Results in this Smart Contract
    pub is_user_votes_by_id: UnorderedMap<IsUserVoteId, IsUserVote>, // List to check if this User has voted for this Poll or not

    pub users_by_id_counter: u32,     // Counter of the list of User Id
    pub polls_by_id_counter: u32,     // Counter of the list of Poll Id
    pub criterias_by_id_counter: u32, // Counter of the list of Criteria Id
    pub poll_options_by_id_counter: u32, // Counter of the list of PollOption Id
    pub results_by_id_counter: u32,   // Counter of the list of Result Id
    pub is_user_votes_by_id_counter: u32, // Counter of the list to check User has voted for Poll
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum StorageKey {
    UsersByIdKey,
    CriteriasByIdKey,
    PollsByIdKey,
    PollOptionsByIdKey,
    ResultsByIdKey,
    IsUserVotesByIdKey,
}

#[near_bindgen]
impl AppVoteContract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            users_by_id: UnorderedMap::new(StorageKey::UsersByIdKey.try_to_vec().unwrap()),
            criterias_by_id: UnorderedMap::new(StorageKey::CriteriasByIdKey.try_to_vec().unwrap()),
            polls_by_id: UnorderedMap::new(StorageKey::PollsByIdKey.try_to_vec().unwrap()),
            poll_options_by_id: UnorderedMap::new(
                StorageKey::PollOptionsByIdKey.try_to_vec().unwrap(),
            ),
            results_by_id: UnorderedMap::new(StorageKey::ResultsByIdKey.try_to_vec().unwrap()),
            is_user_votes_by_id: UnorderedMap::new(
                StorageKey::IsUserVotesByIdKey.try_to_vec().unwrap(),
            ),
            users_by_id_counter: 1,
            polls_by_id_counter: 1,
            criterias_by_id_counter: 1,
            poll_options_by_id_counter: 1,
            results_by_id_counter: 1,
            is_user_votes_by_id_counter: 1,
        }
    }
}

'''
'''--- src/poll_options.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    // ----------------------------------------- CREATE -----------------------------------------
    /**
     * - Create a new Poll Option
     * - Ask user to deposit an amount of NEAR to cover storage data fee
     * - Add Vote into polls_by_id
     * - Refund redundant deposited NEAR back to user
     */
    #[payable]
    pub fn create_poll_option(
        &mut self,
        created_by: UserId,
        title: String,
        description: String,
        options: Vec<String>,
    ) -> PollOption {
        let before_storage_usage = env::storage_usage(); // Used to calculate the amount of redundant NEAR when users deposit

        let poll_option_id = self.poll_options_by_id_counter;

        // Check if the user_id exists or not
        assert!(
            self.users_by_id.get(&created_by).is_some(),
            "User who created this Option does not exist"
        );

        // Create new Poll
        let new_poll_option = PollOption {
            id: poll_option_id,
            created_by,
            title,
            description,
            options,
            created_at: Some(env::block_timestamp()),
            updated_at: None,
        };

        // Insert new Poll into polls_by_id (list of Votes of this Smart Contract)
        self.poll_options_by_id
            .insert(&poll_option_id, &new_poll_option);

        // Update Poll Id Counter
        self.poll_options_by_id_counter += 1;

        // Used data storage = after_storage_usage - before_storage_usage
        let after_storage_usage = env::storage_usage();
        // Refund NEAR
        refund_deposit(after_storage_usage - before_storage_usage);

        // EVENT LOG
        let create_poll_option_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::CreatePollOption,
            data: serde_json::to_string(&new_poll_option).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&create_poll_option_log).unwrap()
        );

        new_poll_option
    }

    // ----------------------------------------- READ -----------------------------------------
    // Get total number of User in the Smart Contract
    pub fn poll_option_total_supply(&self) -> u64 {
        // Count the number of poll_option_id in poll_options_by_id
        self.poll_options_by_id.len()
    }

    // Get list of all Poll Options in this Smart Contract (with pagination)
    pub fn get_all_poll_options(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<PollOption> {
        self.poll_options_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(poll_option_id, _poll_option)| {
                self.poll_options_by_id.get(&poll_option_id).unwrap()
            })
            .collect()
    }

    // Get 1 Poll Option by id
    pub fn get_poll_option_by_id(&self, poll_option_id: PollOptionId) -> PollOption {
        self.poll_options_by_id
            .get(&poll_option_id)
            .expect("Poll Option does not exist")
    }

    // ----------------------------------------- UPDATE -----------------------------------------
    // Update Poll Option information
    pub fn update_poll_option(
        &mut self,
        poll_option_id: PollOptionId,
        title: String,
        description: String,
        options: Vec<String>,
    ) -> PollOption {
        let poll_option = self
            .poll_options_by_id
            .get(&poll_option_id)
            .expect("This poll option does not exist");

        let updated_poll_option = PollOption {
            id: poll_option.id,
            created_by: poll_option.created_by,
            title: title,
            description: description,
            options: options,
            created_at: poll_option.created_at,
            updated_at: Some(env::block_timestamp()),
        };

        // Update polls_by_id
        self.poll_options_by_id
            .insert(&poll_option_id, &updated_poll_option);

        // EVENT LOG
        let update_poll_option_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::UpdatePollOption,
            data: serde_json::to_string(&updated_poll_option).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&update_poll_option_log).unwrap()
        );

        updated_poll_option
    }

    // Delete Poll Option from the Smart Contract
    pub fn delete_poll_option(&mut self, poll_option_id: PollOptionId) {
        // Check if this Poll Option is a foreign key in Poll or not
        for (_poll_id, poll) in self.polls_by_id.iter() {
            for criteria_option_id in poll.criteria_option_id_array.clone() {
                assert!(
                    criteria_option_id.poll_option_id != poll_option_id,
                    "Cannot delete this Poll Option! This Poll Option is linked to a Poll record!"
                );
            }
        }

        // Delete Poll Option
        self.poll_options_by_id
            .remove(&poll_option_id)
            .expect("This poll_option does not exists");
    }
}

'''
'''--- src/polls.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    // ----------------------------------------- CREATE -----------------------------------------
    /**
     * - Create a new Poll
     * - Ask user to deposit an amount of NEAR to cover storage data fee
     * - Add Vote into polls_by_id
     * - Refund redundant deposited NEAR back to user
     */
    #[payable]
    pub fn create_poll(
        &mut self,
        criteria_option_id_array: Vec<CriteriaOptionId>,
        created_by: UserId,
        img_url: Option<String>,
        title: String,
        description: String,
        start_at: Option<Timestamp>,
        end_at: Option<Timestamp>,
    ) -> Poll {
        let before_storage_usage = env::storage_usage(); // Used to calculate the amount of redundant NEAR when users deposit

        let poll_id = self.polls_by_id_counter;

        for criteria_option_id in criteria_option_id_array.clone() {
            // Check if the all the criteria_ids exists or not
            assert!(
                self.criterias_by_id
                    .get(&criteria_option_id.criteria_id)
                    .is_some(),
                "Some of the criterias does not exist"
            );
            // Check if the pool_option_id exists or not
            assert!(
                self.poll_options_by_id
                    .get(&criteria_option_id.poll_option_id)
                    .is_some(),
                "Some of the poll options does not exist"
            );
        }

        // Check if the user_id exists or not
        let user = self
            .users_by_id
            .get(&created_by)
            .expect("User does not exist");

        // Check if the User who create poll is Admin or not?
        assert!(
            matches!(user.role, Role::Admin),
            "Only Admin can create polls"
        );

        // Create new Poll
        let new_poll = Poll {
            id: poll_id,
            criteria_option_id_array: criteria_option_id_array.clone(),
            created_by,
            img_url,
            title,
            description,
            start_at,
            end_at,
            created_at: Some(env::block_timestamp()),
            updated_at: None,
        };

        // Insert new Poll into polls_by_id (list of Votes of this Smart Contract)
        self.polls_by_id.insert(&poll_id, &new_poll);

        // Update Poll Id Counter
        self.polls_by_id_counter += 1;

        // Used data storage = after_storage_usage - before_storage_usage
        let after_storage_usage = env::storage_usage();
        // Refund NEAR
        refund_deposit(after_storage_usage - before_storage_usage);

        // Insert data with total_vote = 0 into Result table
        for criteria_option_id in criteria_option_id_array.clone() {
            let poll_option = self
                .poll_options_by_id
                .get(&criteria_option_id.poll_option_id)
                .expect("This Poll does not exists");
            for option in poll_option.clone().options {
                self.create_result(criteria_option_id.criteria_id, poll_id, option);
            }
        }

        // EVENT LOG
        let create_poll_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::CreatePoll,
            data: serde_json::to_string(&new_poll).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&create_poll_log).unwrap()
        );

        new_poll
    }

    // ----------------------------------------- READ -----------------------------------------
    // Get total number of User in the Smart Contract
    pub fn poll_total_supply(&self) -> u64 {
        // Count the number of poll_id in polls_by_id
        self.polls_by_id.len()
    }

    // Get list of all Polls in this Smart Contract (with pagination)
    pub fn get_all_polls(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Poll> {
        self.polls_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(poll_id, _poll)| self.polls_by_id.get(&poll_id).unwrap())
            .collect()
    }

    // Get 1 Poll by id
    pub fn get_poll_by_id(&self, poll_id: PollId) -> Poll {
        self.polls_by_id.get(&poll_id).expect("Poll does not exist")
    }

    // ----------------------------------------- UPDATE -----------------------------------------
    // Update Poll information
    pub fn update_poll(
        &mut self,
        poll_id: PollId,
        img_url: Option<String>,
        title: String,
        description: String,
        start_at: Option<Timestamp>,
        end_at: Option<Timestamp>,
    ) -> Poll {
        let poll = self
            .polls_by_id
            .get(&poll_id)
            .expect("This poll does not exist");

        let updated_poll = Poll {
            id: poll.id,
            criteria_option_id_array: poll.criteria_option_id_array,
            created_by: poll.created_by,
            img_url,
            title: title,
            description: description,
            start_at,
            end_at,
            created_at: poll.created_at,
            updated_at: Some(env::block_timestamp()),
        };

        // Update polls_by_id
        self.polls_by_id.insert(&poll_id, &updated_poll);

        // EVENT LOG
        let update_poll_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::UpdatePoll,
            data: serde_json::to_string(&updated_poll).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&update_poll_log).unwrap()
        );

        updated_poll
    }

    // Delete Poll from the Smart Contract
    pub fn delete_poll(&mut self, poll_id: PollId) {
        // Delete Result belongs to this Poll
        let mut remove_result_set = vec![]; // Vector of result_ids that need to be deleted
        for (result_id, result) in self.results_by_id.iter() {
            if result.poll_id == poll_id {
                remove_result_set.push(result_id);
            }
        }
        log!("Remove result set: {:?}", remove_result_set);
        for result_id in remove_result_set {
            self.results_by_id.remove(&result_id).unwrap();
        }

        // Delete this Poll from IsUserVote
        let mut remove_is_user_vote_set = vec![]; // Vector of is_user_vote_ids that need to be deleted
        for (is_user_vote_id, is_user_vote) in self.is_user_votes_by_id.iter() {
            if is_user_vote.poll_id == poll_id {
                remove_is_user_vote_set.push(is_user_vote_id);
            }
        }
        log!("Remove is user vote set: {:?}", remove_is_user_vote_set);
        for is_user_vote_id in remove_is_user_vote_set {
            self.is_user_votes_by_id.remove(&is_user_vote_id).unwrap();
        }

        // Delete Poll
        self.polls_by_id
            .remove(&poll_id)
            .expect("This poll does not exists");
    }
}

'''
'''--- src/results.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    // ----------------------------------------- CREATE -----------------------------------------
    /**
     * - Create a new Result
     * - Ask user to deposit an amount of NEAR to cover storage data fee
     * - Add Result into results_by_id
     * - Refund redundant deposited NEAR back to user
     */
    #[payable]
    pub fn create_result(
        &mut self,
        criteria_id: CriteriaId,
        poll_id: PollId,
        option: String,
    ) -> Result {
        let before_storage_usage = env::storage_usage(); // Used to calculate the amount of redundant NEAR when users deposit

        let result_id = self.results_by_id_counter;

        // Check if the criteria_id exists or not
        assert!(
            self.criterias_by_id.get(&criteria_id).is_some(),
            "Criteria does not exist"
        );

        // Check if the poll_id exists or not
        let poll = self.polls_by_id.get(&poll_id).expect("Poll does not exist");
        let mut is_belongs = 0;

        // Check if this Criteria belongs to this Poll or not
        for criteria_option_id in poll.criteria_option_id_array {
            if criteria_option_id.criteria_id == criteria_id {
                is_belongs = 1;
            }
        }
        assert_eq!(is_belongs, 1, "This Criteria does not belongs to this Poll");

        // Create new Result
        let new_result = Result {
            id: result_id,
            criteria_id,
            poll_id,
            option,
            total_vote: 0,
            created_at: Some(env::block_timestamp()),
            updated_at: None,
        };

        // Insert new Result into results_by_id (list of Results of this Smart Contract)
        self.results_by_id.insert(&result_id, &new_result);

        // Update Result Id Counter
        self.results_by_id_counter += 1;

        // Used data storage = after_storage_usage - before_storage_usage
        let after_storage_usage = env::storage_usage();
        // Refund NEAR
        refund_deposit(after_storage_usage - before_storage_usage);

        new_result
    }

    // ----------------------------------------- READ -----------------------------------------
    // Get total number of Result in the Smart Contract
    pub fn result_total_supply(&self) -> u64 {
        // Count the number of result_id in results_by_id
        self.results_by_id.len()
    }

    // Get list of all Results in this Smart Contract (with pagination)
    pub fn get_all_results(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Result> {
        self.results_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(result_id, _result)| self.results_by_id.get(&result_id).unwrap())
            .collect()
    }

    // Get 1 Result by id
    pub fn get_result_by_id(&self, result_id: ResultId) -> Result {
        self.results_by_id
            .get(&result_id)
            .expect("Result does not exist")
    }

    // Voting
    // Update Result information (When a user vote)
    pub fn vote(
        &mut self,
        voted_user_id: UserId,
        poll_id: PollId,
        criteria_option_array: Vec<CriteriaOption>,
    ) {
        // Check voted User exists or not
        assert!(
            self.users_by_id.get(&voted_user_id).is_some(),
            "The user who votes do not exist"
        );

        // Check Criteria, Poll, User exists or not
        let poll = self
            .polls_by_id
            .get(&poll_id)
            .expect("Related poll does not exist");

        for criteria_option in criteria_option_array.clone() {
            assert!(
                self.criterias_by_id
                    .get(&criteria_option.criteria_id)
                    .is_some(),
                "Some of the Criteria does not exist"
            );
        }

        // Check if User has voted for this Poll or not
        assert_eq!(
            self.is_voted(voted_user_id, poll_id),
            false,
            "This User has voted for this Poll"
        );

        // Check current time is between poll.start_time and poll.end_time or not
        let vote_timestamp = env::block_timestamp(); // Voting timestamp

        let base: u64 = 10;
        let poll_start_at = poll.start_at.unwrap_or(0);
        let poll_end_at = poll.end_at.unwrap_or(0);

        let end_at_nano = poll_end_at * base.pow(6); // Voting timestamp in milliseconds
        let start_at_nano = poll_start_at * base.pow(6); // Voting timestamp in milliseconds

        // --------------------------- CHECK VOTING TIME ---------------------------
        if poll_start_at != 0 {
            if poll_end_at == 0 {
                // If poll_end_at == 0 -> Only check poll_start_at
                assert!(
                    vote_timestamp > start_at_nano,
                    "Cannot vote this Poll during this time"
                );
            } else {
                // If poll_end_at != 0 -> Check both poll_start_at and poll_end_at
                assert!(
                    vote_timestamp < end_at_nano && vote_timestamp > start_at_nano,
                    "Cannot vote this Poll during this time"
                );
            }
        } else {
            // If poll_end_at == 0 -> Don't have to check anything

            // If poll_end_at != -> Only check poll_end_at
            if poll_end_at != 0 {
                assert!(
                    vote_timestamp < end_at_nano,
                    "Cannot vote this Poll during this time"
                )
            }
        }
        // -------------------------------------------------------------------------
        for criteria_option in criteria_option_array {
            // Get result_id
            let mut match_result_id = 0; // Default value
            let mut match_result = Result {
                // Default value
                id: 0,
                criteria_id: 0,
                poll_id: 0,
                option: "".to_string(),
                total_vote: 0,
                created_at: None,
                updated_at: None,
            };

            for (result_id, result) in self.results_by_id.iter() {
                if result.criteria_id == criteria_option.criteria_id
                    && result.poll_id == poll_id
                    && result.option == criteria_option.option
                {
                    match_result_id = result_id;
                    match_result = result;
                    break;
                }
            }

            assert!(match_result_id != 0, "Not found result"); // If match_result_id == 0 -> No appropriate result

            let updated_result = Result {
                id: match_result.id,
                criteria_id: criteria_option.criteria_id,
                poll_id,
                option: criteria_option.option,
                total_vote: match_result.total_vote + 1, // Increase the number of votes by one
                created_at: match_result.created_at,
                updated_at: Some(env::block_timestamp()),
            };

            // Update results_by_id
            self.results_by_id.insert(&match_result_id, &updated_result);
        }

        // Find the voted user -> Mark this User as has voted for this Pol
        let is_user_vote_id = self.is_user_votes_by_id_counter; // Default value
        let is_user_vote = IsUserVote {
            // Default value
            user_id: voted_user_id,
            poll_id,
            is_voted: true,
        };
        self.is_user_votes_by_id
            .insert(&is_user_vote_id, &is_user_vote);
        self.is_user_votes_by_id_counter += 1;
    }

    pub fn get_all_results_by_poll_criteria_id(
        &self,
        poll_id: PollId,
        criteria_id: CriteriaId,
    ) -> Vec<ResultByPollCriteria> {
        // Check Poll exists or not
        assert!(
            self.polls_by_id.get(&poll_id).is_some(),
            "Poll does not exist"
        );
        // Check Criteria exists or not
        assert!(
            self.criterias_by_id.get(&criteria_id).is_some(),
            "Criteria does not exist"
        );

        // Get the Array of Result of this Poll
        let mut result_by_poll_criteria_id_set: Vec<Result> = vec![];
        let mut return_set: Vec<ResultByPollCriteria> = vec![];
        for result in self.results_by_id.values() {
            if result.poll_id == poll_id && result.criteria_id == criteria_id {
                result_by_poll_criteria_id_set.push(result);
            }
        }

        let poll = self
            .polls_by_id
            .get(&poll_id)
            .expect("Poll does not exists");

        for criteria_option_id in poll.criteria_option_id_array {
            // Find the right Criteria inside this Poll to calculate vote
            if criteria_option_id.criteria_id == criteria_id {
                let option = self
                    .poll_options_by_id
                    .get(&criteria_option_id.poll_option_id)
                    .expect("Poll Option does not exists");

                for option in option.options {
                    let mut vote_count = 0;
                    for result in result_by_poll_criteria_id_set.clone() {
                        if result.option == option {
                            vote_count += result.total_vote;
                        }
                    }
                    let new_result: ResultByPollCriteria = ResultByPollCriteria {
                        poll_id: poll_id,
                        criteria_id: criteria_id,
                        option: option,
                        total_vote: vote_count,
                    };

                    return_set.push(new_result);
                }
                break;
            }
        }

        // Sort ranking desc
        return_set.sort_by(|a, b| b.total_vote.cmp(&a.total_vote));

        return_set
    }

    // Get number of Users who voted for a poll
    pub fn num_users_vote_for_a_poll(&self, poll_id: PollId) -> u32 {
        let mut count: u32 = 0;
        for (_is_user_vote_id, is_user_vote) in self.is_user_votes_by_id.iter() {
            if is_user_vote.poll_id == poll_id {
                count += 1;
            }
        }
        count
    }

    // Delete Result from the Smart Contract
    pub fn delete_result(&mut self, result_id: PollOptionId) {
        self.results_by_id
            .remove(&result_id)
            .expect("This result does not exists");
    }

    pub fn num_users_vote_for_a_poll(&self, poll_id: PollId) -> u64 {
        let mut count = 0;
        for (_is_user_vote_id, is_user_vote) in self.is_user_votes_by_id.iter() {
            if is_user_vote.poll_id == poll_id && is_user_vote.is_voted == true {
                count += 1;
            }
        }
        count
    }
}

'''
'''--- src/tests.rs ---
#[allow(unused_imports)]
use crate::*;

#[cfg(all(test, not(target_arch = "wasm-32")))]
mod tests {
    use super::*;

    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;

    const CREATE_STORAGE_COST: u128 = 100_000_000_000_000_000_000_000;

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .is_view(is_view);

        builder
    }

    #[test]
    fn test_crud() {
        // ------------------------------------------------------------------------------------------------
        // ----------------------------------- INIT TESTING ENVIRONMENT -----------------------------------
        // ------------------------------------------------------------------------------------------------
        let mut context = get_context(false);
        testing_env!(context.build());

        // Init contract
        let mut contract = AppVoteContract::new(accounts(0).to_string());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(CREATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        // ----------------------------------------------------------------------------
        // ----------------------------------- USER -----------------------------------
        // ----------------------------------------------------------------------------
        let name = "Zuong".to_string();
        let role = Role::Admin;
        let email = "admin@gmail.com".to_string();
        let blockchain_type = BlockchainType::Near;
        let wallet_address = "duongnh.testnet".to_string();

        // --- Create the first user ---
        contract.create_user(name, role, email, blockchain_type, wallet_address);

        let first_user_id = 1; // Id of the newly created user
        let mut first_user = contract.get_user_by_id(first_user_id);
        assert_eq!(first_user.name, "Zuong".to_string());

        // --- Create the second user ---
        contract.create_user(
            "Hoang".to_string(),
            Role::Employee,
            "hoangnv@gmail.com".to_string(),
            BlockchainType::Near,
            "hoangnv.testnet".to_string(),
        );
        let mut all_users = contract.get_all_users(Some(0), Some(10));
        assert_eq!(all_users.len(), 2);
        assert_eq!(all_users[1].name, "Hoang".to_string());

        // --- Update the first user ---
        contract.update_user(
            first_user_id,
            "Updated name".to_string(),
            Role::Admin,
            "updatedmail@gmail.com".to_string(),
            BlockchainType::Near,
            "duongnh.testnet".to_string(),
        );

        // Check updated information
        first_user = contract.get_user_by_id(first_user_id);
        assert_eq!(first_user.name, "Updated name".to_string());

        // --- Delete the second user ---
        contract.delete_user(2);

        // Check if the first user has been deleted
        all_users = contract.get_all_users(Some(0), Some(10));
        assert_eq!(all_users.len(), 1);

        // --------------------------------------------------------------------------------
        // ----------------------------------- CRITERIA -----------------------------------
        // --------------------------------------------------------------------------------
        let user_id = 1; // User id 1 create this criteria
        let descriptions = vec!["The most handsome employee".to_string()];

        // --- Create the first criteria ---
        contract.create_criteria(user_id, descriptions);

        let first_criteria_id = 1; // Id of the newly created Criteria
        let mut first_criteria = contract.get_criteria_by_id(first_criteria_id);
        assert_eq!(first_criteria.created_by, 1);
        assert_eq!(
            first_criteria.description,
            "The most handsome employee".to_string()
        );

        // --- Create the second criteria ---
        contract.create_criteria(1, vec!["The most creative employee".to_string()]);
        let mut all_criterias = contract.get_all_criterias(Some(0), Some(10));
        assert_eq!(all_criterias.len(), 2);
        assert_eq!(
            all_criterias[1].description,
            "The most creative employee".to_string()
        );

        // --- Update the first Criteria ---
        contract.update_criteria(first_criteria_id, "Updated description".to_string());

        // Check updated information
        first_criteria = contract.get_criteria_by_id(first_criteria_id);
        assert_eq!(
            first_criteria.description,
            "Updated description".to_string()
        );

        // --- Delete the second Criteria ---
        contract.delete_criteria(2);

        // Check if the first Criteria has been deleted
        all_criterias = contract.get_all_criterias(Some(0), Some(10));
        assert_eq!(all_criterias.len(), 1);

        // --- Create the third criteria ---
        contract.create_criteria(1, vec!["The most productive employee".to_string()]);
        let all_criterias = contract.get_all_criterias(Some(0), Some(10));
        assert_eq!(all_criterias.len(), 2);
        assert_eq!(
            all_criterias[1].description,
            "The most productive employee".to_string()
        );

        // ----------------------------------------------------------------------------
        // ------------------------------- POLL OPTION --------------------------------
        // ----------------------------------------------------------------------------
        // Create the 3th user
        let new_user = contract.create_user(
            "Hoang".to_string(),
            Role::Employee,
            "hoangnv@gmail.com".to_string(),
            BlockchainType::Near,
            "hoangnv.testnet".to_string(),
        );

        assert_eq!(new_user.id, 3);

        let created_by = first_user_id;
        let title = "Test poll option".to_string();
        let description = "Test poll option description".to_string();
        let options = vec!["Zuong".to_string(), "Manh".to_string()];

        contract.create_poll_option(created_by, title, description, options);

        // ----------------------------------------------------------------------------
        // ----------------------------------- POLL -----------------------------------
        // ----------------------------------------------------------------------------
        let user_id = 1; // User id 1 create this Poll
        let criteria_option_id_array = vec![CriteriaOptionId {
            criteria_id: 1,
            poll_option_id: 1,
        }];
        let img_url = None;
        let title = "Test poll".to_string();
        let description = "Test poll description".to_string();
        let start_at = Some(0);
        let end_at = Some(0);

        // --- Create the first poll ---
        contract.create_poll(
            criteria_option_id_array,
            user_id,
            img_url,
            title,
            description,
            start_at,
            end_at,
        );

        let first_poll_id = 1; // Id of the newly created Poll
        let first_poll = contract.get_poll_by_id(first_poll_id);
        assert_eq!(first_poll.created_by, 1);
        assert_eq!(first_poll.title, "Test poll".to_string());
        assert_eq!(first_poll.description, "Test poll description".to_string());

        // --- Create the second Poll ---
        contract.create_poll(
            vec![CriteriaOptionId {
                criteria_id: 2,
                poll_option_id: 2,
            }],
            1,
            None,
            "Test poll 2".to_string(),
            "Test poll description 2".to_string(),
            Some(0),
            Some(0),
        );
        let mut all_polls = contract.get_all_polls(Some(0), Some(10));
        assert_eq!(all_polls.len(), 2);
        assert_eq!(all_polls[1].title, "Test poll 2".to_string());

        // --- Update the second Poll ---
        contract.update_poll(
            2,
            None,
            "Updated Poll title".to_string(),
            "Updated Poll description".to_string(),
            Some(0),
            Some(0),
        );

        // Check updated information
        let second_poll = contract.get_poll_by_id(2);
        assert_eq!(second_poll.title, "Updated Poll title".to_string());
        assert_eq!(
            second_poll.description,
            "Updated Poll description".to_string()
        );

        // --- Delete the second Poll ---
        contract.delete_poll(2);

        // Check if the first Poll has been deleted
        all_polls = contract.get_all_polls(Some(0), Some(10));
        assert_eq!(all_polls.len(), 1);

        // ----------------------------------------------------------------------------
        // ----------------------------------- VOTE -----------------------------------
        // ----------------------------------------------------------------------------

        // Vote
        assert_eq!(contract.is_voted(1, 1), false); // user_id 1 hasn't voted for poll_id 1

        let voted_user_id = 1;
        let poll_id = 1;
        let criteria_user_array = vec![
            CriteriaOption {
                criteria_id: 1,
                option: "Zuong".to_string(),
            },
            CriteriaOption {
                criteria_id: 3,
                option: "Manh".to_string(),
            },
        ];
        contract.vote(voted_user_id, poll_id, criteria_user_array);

        // Check if user_id 1 has voted for poll_id 1
        assert_eq!(contract.is_voted(1, 1), true);
    }
}

'''
'''--- src/users.rs ---
use crate::*;

#[near_bindgen]
impl AppVoteContract {
    // ----------------------------------------- CREATE -----------------------------------------
    /**
     * - Create a new User
     * - Ask user to deposit an amount of NEAR to cover storage data fee
     * - Add User into users_by_id
     * - Refund redundant deposited NEAR back to user
     */
    #[payable]
    pub fn create_user(
        &mut self,
        name: AccountId,
        role: Role,
        email: String,
        blockchain_type: BlockchainType,
        wallet_address: String,
    ) -> User {
        let before_storage_usage = env::storage_usage(); // Dùng để tính toán lượng near thừa khi deposit

        let user_id = self.users_by_id_counter;

        // Check duplicate wallet_address of the same blockchain_type
        // Check only SC's owner / user with role Admin can create_user
        let mut create_account_id = 0; // Default value
        for (_user_id, user) in self.users_by_id.iter() {
            if matches!(user.user_wallet.blockchain_type, _blockchain_type) {
                assert!(
                    user.user_wallet.wallet_address != wallet_address,
                    "Duplicate wallet address for this blockchain!"
                );
            }
            if user.user_wallet.wallet_address == env::predecessor_account_id() {
                create_account_id = user.id;
            }
        }
        if env::predecessor_account_id() != self.owner_id {
            let create_account = self
                .users_by_id
                .get(&create_account_id)
                .expect("User does not exist");
            assert!(
                matches!(create_account.role, Role::Admin)
                    || self.owner_id == create_account.user_wallet.wallet_address,
                "Only Admin or Smart Contract's owner can create new user"
            );
        }

        // Create new User
        let new_user = User {
            id: user_id,
            name,
            role,
            email,
            user_wallet: UserWallet {
                blockchain_type,
                wallet_address,
            },
            created_at: Some(env::block_timestamp()),
            updated_at: None,
        };

        // Insert new User into users_by_id (list of Users of this Smart Contract)
        self.users_by_id.insert(&user_id, &new_user);

        // Update User Id Counter
        self.users_by_id_counter += 1;

        // Used data storage = after_storage_usage - before_storage_usage
        let after_storage_usage = env::storage_usage();
        // Refund NEAR
        refund_deposit(after_storage_usage - before_storage_usage);

        // EVENT LOG
        let create_user_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::CreateUser,
            data: serde_json::to_string(&new_user).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&create_user_log).unwrap()
        );

        new_user
    }

    // ----------------------------------------- READ -----------------------------------------
    // Get total number of User in the Smart Contract
    pub fn user_total_supply(&self) -> u64 {
        // Count the number of user_id in users_by_id
        self.users_by_id.len()
    }

    // Get list of all Users in this Smart Contract (with pagination)
    pub fn get_all_users(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<User> {
        self.users_by_id
            .iter()
            .skip(from_index.unwrap_or(0) as usize)
            .take(limit.unwrap_or(PAGINATION_SIZE) as usize)
            .map(|(user_id, _user)| self.users_by_id.get(&user_id).unwrap())
            .collect()
    }

    // Get 1 User by id
    pub fn get_user_by_id(&self, user_id: UserId) -> User {
        self.users_by_id.get(&user_id).expect("User does not exist")
    }

    // Get User's id by Wallet Account
    pub fn get_user_by_wallet_address(&self, wallet_address: AccountId) -> Option<User> {
        for user in self.users_by_id.values() {
            if user.user_wallet.wallet_address == wallet_address {
                return Some(user);
            }
        }
        return None;
    }

    // ----------------------------------------- UPDATE -----------------------------------------
    // Update User information
    pub fn update_user(
        &mut self,
        user_id: UserId,
        name: AccountId,
        role: Role,
        email: String,
        blockchain_type: BlockchainType,
        wallet_address: String,
    ) -> User {
        let user = self
            .users_by_id
            .get(&user_id)
            .expect("This user does not exist");

        // Check duplicate wallet_address of the same blockchain_type
        for (_user_id, user) in self.users_by_id.iter() {
            if matches!(user.user_wallet.blockchain_type, _blockchain_type) {
                assert!(
                    user.user_wallet.wallet_address != wallet_address || user.id == user_id,
                    "Duplicate wallet address for this blockchain!"
                );
            }
        }

        let updated_user = User {
            id: user.id,
            name,
            role,
            email,
            user_wallet: UserWallet {
                blockchain_type,
                wallet_address,
            },
            created_at: user.created_at,
            updated_at: Some(env::block_timestamp()),
        };

        // Update users_by_id
        self.users_by_id.insert(&user_id, &updated_user);

        // EVENT LOG
        let update_user_log: EventLog = EventLog {
            standard: "nep297".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::UpdateUser,
            data: serde_json::to_string(&updated_user).unwrap(),
        };

        log!(
            "EVENT_JSON:{}",
            serde_json::to_string(&update_user_log).unwrap()
        );

        updated_user
    }

    // Delete User from the Smart Contract
    pub fn delete_user(&mut self, user_id: UserId) {
        // TODO: Check only admin can call this function

        // Check if this User is a foreign key in Criteria or not
        for (_criteria_id, criteria) in self.criterias_by_id.iter() {
            assert!(
                criteria.created_by != user_id,
                "Cannot delete this User! This User is linked to a Criteria record!"
            );
        }
        // Check if this User is a foreign key in Poll or not
        for (_poll_id, poll) in self.polls_by_id.iter() {
            assert!(
                poll.created_by != user_id,
                "Cannot delete this User! This User is linked to a Poll record!"
            );
        }
        // Check if this User is a foreign key in PollOption or not
        for (_poll_option_id, poll_option) in self.poll_options_by_id.iter() {
            assert!(
                poll_option.created_by != user_id,
                "Cannot delete this User! This User is linked to a Poll Option record!"
            );
        }

        // Delete this User from IsUserVote
        let mut remove_is_user_vote_set = vec![]; // Vector of is_user_vote_ids that need to be deleted
        for (is_user_vote_id, is_user_vote) in self.is_user_votes_by_id.iter() {
            if is_user_vote.user_id == user_id {
                remove_is_user_vote_set.push(is_user_vote_id);
            }
        }
        log!("Remove is user vote set: {:?}", remove_is_user_vote_set);
        for is_user_vote_id in remove_is_user_vote_set {
            self.is_user_votes_by_id.remove(&is_user_vote_id).unwrap();
        }

        // Delete User
        self.users_by_id
            .remove(&user_id)
            .expect("This user does not exists");
    }
}

'''
'''--- src/utils.rs ---
use crate::*;

pub(crate) fn refund_deposit(storage_used: u64) -> u128 {
    // Tính lượng tiền cần nạp để cover storage
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    log!("Storage data: {}", storage_used);
    log!("Storage fee: {}", required_cost);

    // Nếu người dùng deposit lượng tiền ít hơn lượng cần thiết để lưu data -> Báo lỗi
    assert!(
        attached_deposit >= required_cost,
        "Must attach {} yoctoNear to cover storage",
        required_cost
    );

    let refund_amount = attached_deposit - required_cost;

    // Thực hiện refund
    if refund_amount > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund_amount);
    }

    required_cost
}

// pub(crate) fn assert_one_yocto() {
//     assert_eq!(
//         env::attached_deposit(),
//         1,
//         "Required attached deposit of exact 1 yoctoNear"
//     );
// }

// pub(crate) fn assert_at_least_one_yocto() {
//     assert!(
//         env::attached_deposit() >= 1,
//         "Required attached deposit of at least 1 yoctoNear"
//     );
// }

'''