*GitHub Repository "near-explorer/near-explorer.github.io"*

'''--- Notes.md ---
{
"version": "",
// Description fields. Can be rendered using available variables
"title": {
"text": "",
"link": null
},
"short_description": "$input.msg->value",
"icon": {},
"extends": "",
"repository": "",
"homepage": "",
"documentation": "",

    // Extra description of the contract/transaction.
    "reference": "near://aurora/ft_metadata/",
    "reference_hash": "",

    // Filtering rules
    "filter_by": {},

    // Dynamic annotations.
    "schema": {
        "input": {},
        "output": {},
        "require": {},
        "description": {}
    },
    "variables": [
        {
            "name": "amount",
            "value": "$Nep141_Amount($token, $args.amount)"
        },
        {
            "name": "rec",
            "value": "$receipt[method:ft_transfer_call]"
        }
    ]

}

-- Introspection --
-- Reflection --

Goals of the DAO: - Approve users with whitelist access to the registry - Increase coverage of transactions in the registry - Visibility and funding - Help with development of mini-explorer - Propose changes on the Road-map (of registry and mini-explorer)

Use cases for the registry:

-   NEAR Explorers (explorer.near.org && nearblocks.io)
-   NEAR Telegram Bot that reports txs

registry.add_index(column, key, value, with_endorsement=true) {
hash := sha256({value})
registry.add_value(hash, value)
// make all relevant indexing information
}

// You can endorse only using the hash
registry.endorse(column, key, hash)
registry.remove_endorsement(column, key, hash)
registry.get_preferred_value(column, key) -> Option<Value>
data: List[Column]
Column: List[DataPoint]
DataPoint:
hash: Hash,
endorser: AccountId[],
fn recent_act

'''
'''--- README.md ---
# NEAR Mini Explorer

Serverless explorer for [NEAR](https://near.org/).

## Roadmap

-   [ ] Host service using web4.near.page
-   [ ] Save downloaded data using [IndexedDB](https://developer.mozilla.org/es/docs/Web/API/IndexedDB_API)
        This will help to avoid downloading the same data multiple times. For each account select what was the last block downloaded and only start from there.
        Save common data from react components like FT metadata (etc...)
-   [ ] Add FAQ section (How does it work! How to contribute (to the code && to the parsed data)!)
-   [ ] Add search / filter functionality
-   [ ] Add support for multiple networks (mainnet,testnet)
-   [ ] Support fetching transactions descriptions from NEAR Blockchain (need to create a contract for this)
-   [ ] Add page to interact easily with contracts (view methods / state queries / change methods)
-   [ ] Make better invasive download policy (make only 100?? requests at a time)
    -   [ ] Prioritize most recent transactions first
    -   [ ] Update the progress bar depending on the percent of the prefix completed

'''
'''--- library/contracts/aurora.json ---
{
    "type": "ContractInterface",
    "filter_by": {
        "contract_id": "aurora"
    },
    "extends": [
        "interfaces/nep141.json"
    ],
    "state": [
        {
            "type": "pure|regex",
            "key": "STATE",
            "key-encoding": "utf8",
            "state-encoding": "binary|json-with-schema|borsh-with-schema"
        }
    ],
    "view_methods": [],
    "change_methods": []
}

'''
'''--- library/contracts/interfaces/nep141.json ---
{
    "type": "ContractInterface",
    "filter_by": false,
    "state": [
        {
            "type": "pure",
            "key": "STATE",
            "key_encoding": "base64",
            "state_encoding": {
                "type": "borsh",
                "schema": ""
            }
        },
        {
            "type": "regex"
        }
    ],
    "view_methods": [
        {
            "name": "ft_transfer_call",
            "refresh_frequency": "never",
            "input": {
                "type": "json",
                "json_schema": {},
                "borsh_schema": {}
            },
            "output": {
                "type": "number"
            }
        }
    ],
    "change_methods": [
        {
            "hidden": true,
            "private": true,
            "suggested_gas": "125Tgas",
            "suggested_balance": "1yoctoNEAR"
        }
    ]
}

'''
'''--- library/transactions/deploy_bridge_token.json ---
{
    "title": "Deploy Bridge Token on NEAR",
    "filter_by": {
        "contract": "factory.bridge.near",
        "method": "deploy_bridge_token"
    },
    "mui_icon": {
        "name": "Looks",
        "color": "success"
    },
    "input_schema": {
        "type": "json"
    },
    "variables": [],
    "description": "Token address $args.address"
}

'''
'''--- library/transactions/ft_transfer_call.json ---
{
    "type": "TransactionDescription",
    "title": "FT Transfer Call ($name)",
    "filter_by": {
        "method": "ft_transfer_call"
    },
    "mui_icon": {
        "name": "CurrencyExchange",
        "color": "warning"
    },
    "input_schema": {
        "type": "json"
    },
    "variables": [
        {
            "name": "token",
            "value": "$transaction.receiver_id"
        },
        {
            "name": "amount",
            "value": "${Nep141/Amount,token:$token,amount:$args.amount}"
        },
        {
            "name": "symbol",
            "value": "${Nep141/Symbol,token:$token}"
        },
        {
            "name": "name",
            "value": "${Nep141/Name,token:$token}"
        },
        {
            "name": "receiver",
            "value": "${NEAR/Contract,accountId:$args.receiver_id}"
        }
    ],
    "description": "Send $amount $symbol to $receiver"
}

'''
'''--- library/transactions/wnear.deposit.json ---
{
    "type": "TransactionDescription",
    "title": "Wrap NEAR",
    "filter_by": {
        "contract": "wrap.near",
        "method": "near_deposit"
    },
    "mui_icon": {
        "name": "LocalPostOffice",
        "color": "warning"
    },
    "input_schema": {
        "type": "json"
    },
    "variables": [
        {
            "name": "debug",
            "value": "${NEAR/Debug}"
        },
        {
            "name": "amount",
            "value": "${NEAR/Token,amount:$transaction.deposit}"
        }
    ],
    "description": "Wrapped $amount"
}

'''
'''--- package.json ---
{
  "name": "account-viewer",
  "homepage": "https://near-explorer.github.io/",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.9.0",
    "@emotion/styled": "^11.8.1",
    "@mui/icons-material": "^5.6.1",
    "@mui/lab": "^5.0.0-alpha.77",
    "@mui/material": "^5.6.1",
    "@reduxjs/toolkit": "^1.8.1",
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@testing-library/user-event": "^13.2.1",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.13",
    "@types/react": "^17.0.20",
    "@types/react-dom": "^18.0.0",
    "@types/react-redux": "^7.1.23",
    "@types/redux-thunk": "^2.1.0",
    "@types/request-promise": "^4.1.48",
    "bignumber.js": "^9.0.2",
    "buffer": "^6.0.3",
    "gh-pages": "^3.2.3",
    "near-api-js": "^0.44.2",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-redux": "^7.2.8",
    "react-router-dom": "^6.3.0",
    "react-scripts": "5.0.0",
    "redux-thunk": "^2.4.1",
    "request-promise": "^4.2.6",
    "typescript": "^4.4.2",
    "web-vitals": "^2.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "predeploy": "yarn build",
    "deploy": "gh-pages -d build",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/>
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- scripts/make_bundle.py ---
# TODO: Use json-schemas to make sure the json description is properly formatted
# TODO: Initiate this program in watchdog mode: https://thepythoncorner.com/posts/2019-01-13-how-to-create-a-watchdog-in-python-to-look-for-filesystem-changes/
import json
from pathlib import Path

SOURCE_DIRECTORY = Path(__file__).parent / ".." / "library" / "transactions"
TARGET_FILE = Path(__file__).parent / ".." / "src" / \
    "library-tools" / "bundle.json"

def main():
    bundle = []
    for p in SOURCE_DIRECTORY.glob("**/*.json"):
        with open(p) as f:
            data = json.load(f)
        bundle.append(data)

    with open(TARGET_FILE, "w") as f:
        json.dump({"descriptions": bundle}, f, indent=4)

if __name__ == '__main__':
    main()

'''
'''--- src/actions/TxsAction.ts ---
import { Block, Transaction } from "../near-api/types";
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { getBlock, getChunk } from "../near-api/near";
import { RootState } from "../store";
import downloadAccountIdTransaction from "../api/txs";

export interface IndexedTransaction {
    tx: Transaction;
    block: Block;
    blockHeight: number;
    index: number;
}

function key(tx: IndexedTransaction) {
    return tx.blockHeight * 1000 + tx.index;
}

export const counterSlice = createSlice({
    name: "transactions",
    initialState: {
        activeSearch: {
            active: false,
            lastBlock: 0,
            started: 0,
            searched: 0,
            rangeSize: 0,
        },
        transactions: [] as IndexedTransaction[],
    },
    reducers: {
        newTransaction: (state, action: { payload: IndexedTransaction }) => {
            state.transactions.push(action.payload);
            state.transactions.sort((a, b) => key(a) - key(b));
        },
        start: (state, action: { payload: number }) => {
            state.activeSearch.lastBlock = action.payload;
            state.activeSearch.started = Date.now();
            state.activeSearch.active = true;
        },
        updateProgress: (state, action: { payload: number }) => {
            if (state.activeSearch.rangeSize === 0) {
                state.activeSearch.rangeSize = action.payload;
            } else {
                state.activeSearch.searched += action.payload;
            }
        },
        finish: (state) => {
            state.activeSearch.active = false;
        },
    },
});

export const { newTransaction, start, finish, updateProgress } =
    counterSlice.actions;

export default counterSlice.reducer;

export const fetchTxs = createAsyncThunk(
    "transactions/fetchTxs",
    async (accountId: string, thunkAPI: any) => {
        const state: RootState = thunkAPI.getState();

        if (state.txs.activeSearch.active) {
            return;
        }

        thunkAPI.dispatch(start(1));
        await downloadAccountIdTransaction(
            accountId,
            async (blockHeight) => {
                getBlock(blockHeight).then(async (block_) => {
                    const block = block_.result;
                    const chunks = await Promise.all(
                        block.chunks.map(async (chunk) => {
                            return await getChunk(chunk.chunk_hash);
                        })
                    );

                    chunks
                        .map((chunk) => chunk.result)
                        .forEach((chunk) => {
                            chunk.transactions.forEach((tx, index) => {
                                if (
                                    tx.signer_id === accountId ||
                                    tx.receiver_id === accountId
                                ) {
                                    thunkAPI.dispatch(
                                        newTransaction({
                                            tx,
                                            block,
                                            blockHeight,
                                            index,
                                        })
                                    );
                                }
                            });
                        });
                });
            },
            (delta) => {
                thunkAPI.dispatch(updateProgress(delta));
            },
            (delta) => {
                thunkAPI.dispatch(updateProgress(delta));
            }
        );
        thunkAPI.dispatch(finish());
    }
);

'''
'''--- src/api/Txs.ts ---
import { genesisConfig, getStatus, viewAccessKeyList } from "../near-api/near";
import { AccountId, unwrap } from "../near-api/types";

interface KeyState {
    publicKey: string;
    nonce: number;
}

async function getKeysState(
    accountId: AccountId,
    height: number
): Promise<KeyState[]> {
    let content;
    while (true) {
        content = await viewAccessKeyList(accountId, height);
        if ("result" in content) {
            break;
        }
        console.log("Block not available:", { height });
        height -= 1;
    }

    const keys = unwrap(content).result.keys.map((key) => {
        return { publicKey: key.public_key, nonce: key.access_key.nonce };
    });

    keys.sort((a, b) => {
        if (a.publicKey === b.publicKey) return a.nonce < b.nonce ? -1 : +1;
        return a.publicKey < b.publicKey ? -1 : +1;
    });

    return keys;
}

function equalKeyStates(left: KeyState[], right: KeyState[]): boolean {
    if (left.length !== right.length) return false;

    for (let i = 0; i < left.length; i++) {
        if (left[i].publicKey !== right[i].publicKey) return false;
        if (left[i].nonce !== right[i].nonce) return false;
    }

    return true;
}

async function parallelBinarySearch(
    lo: number,
    hi: number,
    loVal: KeyState[] | null = null,
    hiVal: KeyState[] | null = null,
    compute: (position: number) => Promise<KeyState[]>,
    step: (position: number) => Promise<void>,
    delta: (delta: number) => void
) {
    if (loVal === null) {
        loVal = await compute(lo);
        delta(1);
        await step(lo);
    }

    if (hiVal === null) {
        hiVal = await compute(hi);
        delta(1);
    }

    if (equalKeyStates(loVal, hiVal)) {
        delta(hi - lo - 1);
        return;
    }

    if (lo + 1 === hi) {
        await step(hi);
        return;
    }

    const mid = Math.round((lo + hi) / 2);

    const midVal = await compute(mid);
    delta(1);

    const left = parallelBinarySearch(
        lo,
        mid,
        loVal,
        midVal,
        compute,
        step,
        delta
    );
    const right = parallelBinarySearch(
        mid,
        hi,
        midVal,
        hiVal,
        compute,
        step,
        delta
    );

    await Promise.all([left, right]);
}

interface Item {
    position: number;
    result: KeyState[];
}

export default async function downloadAccountIdTransaction(
    accountId: AccountId,
    // Callback to be called on each block `h`, such that keys are different between `h-1` and `h`
    stepCb: (block: number) => Promise<void>,
    initProgressCb: (delta: number) => void,
    deltaProgressCb: (delta: number) => void
): Promise<void> {
    const lo = (await genesisConfig()).result.genesis_height;
    const hi = (await getStatus()).result.sync_info.latest_block_height;

    const reqs: Item[] = [];

    initProgressCb(hi - lo + 1);
    await parallelBinarySearch(
        lo,
        hi,
        [],
        null,
        async (position) => {
            // TODO: Use a pair of keys-state and code-hash. This should cover most of the issues with redeployments.
            const result = await getKeysState(accountId, position);
            reqs.push({ position, result });
            return result;
        },
        stepCb,
        deltaProgressCb
    );

    reqs.sort((a, b) => {
        return a.position - b.position;
    });

    // Finish the progress
    deltaProgressCb(hi - lo + 1);
}

'''
'''--- src/assets/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- src/assets/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- src/components/Api/index.ts ---
// TODO: Fill components using reflection (or something similar) See here(https://github.com/Hookyns/tst-reflect)
import { Token } from "./NEAR/Token";
import { Contract } from "./NEAR/Contract";
import { Debug } from "./NEAR/Debug";
import { Amount } from "./Nep141/Amount";
import { Name } from "./Nep141/Name";
import { Symbol } from "./Nep141/Symbol";

export { Token as NearToken } from "./NEAR/Token";
export { Contract } from "./NEAR/Contract";
export { Debug } from "./NEAR/Debug";
export { Amount } from "./Nep141/Amount";
export { Name } from "./Nep141/Name";
export { Symbol } from "./Nep141/Symbol";

export const Components = new Map<string, (props: any) => JSX.Element>();

Components.set("NEAR/Token", Token);
Components.set("NEAR/Contract", Contract);
Components.set("NEAR/Debug", Debug);
Components.set("Nep141/Amount", Amount);
Components.set("Nep141/Symbol", Symbol);
Components.set("Nep141/Name", Name);

'''
'''--- src/library-tools/ast.ts ---
import { Ast, Ast2, ReactComponentArgument } from "./types";

const SPECIAL_CHARACTERS = "$},";
const VALID_IDENTIFIERS_CHARACTERS =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.";

function flush(output: Ast, token: string[]) {
    if (token.length > 0) {
        output.push(token.join(""));
        token.splice(0, token.length);
    }
}

export function collapseString(ast: Ast | Ast2): string {
    return ast
        .map((item) => {
            if (typeof item !== "string") {
                throw new Error("Ast elements must be string for collapsing");
            }
            return item;
        })
        .join("");
}

export class AstParser {
    pointer: number;
    buffer: string;
    variables: Map<string, Ast>;

    constructor(buffer: string, variables: Map<string, Ast>) {
        this.pointer = 0;
        this.buffer = buffer;
        this.variables = variables;
    }

    curChar(): string | null {
        if (this.pointer === this.buffer.length) {
            return null;
        } else {
            return this.buffer[this.pointer];
        }
    }

    nextChar(): string | null {
        if (this.pointer + 1 >= this.buffer.length) {
            return null;
        } else {
            return this.buffer[this.pointer + 1];
        }
    }

    parse(lastElement: string = ""): Ast {
        let currentToken: string[] = [];
        const output: Ast = [];

        do {
            const curChar = this.curChar();

            if (curChar === null || lastElement.indexOf(curChar) !== -1) {
                flush(output, currentToken);
                break;
            }

            if (curChar !== "$") {
                currentToken.push(curChar);
                this.pointer += 1;
            } else {
                const next = this.nextChar();

                if (next === null) {
                    throw Error(
                        "Invalid syntax. Found `$` at the end of the input."
                    );
                }

                // Handle escaped characters
                if (SPECIAL_CHARACTERS.indexOf(next) !== -1) {
                    currentToken.push(next);
                    this.pointer += 2;
                    continue;
                }

                flush(output, currentToken);

                // Handle React Components
                if (next === "{") {
                    this.pointer += 2;

                    const name = this.parse(",}");
                    const args: ReactComponentArgument[] = [];

                    while (this.curChar() === ",") {
                        this.pointer += 1;
                        const key = this.parse(":");
                        this.pointer += 1;
                        const value = this.parse(",}");
                        args.push({
                            key: collapseString(key),
                            value,
                        });
                    }

                    if (this.curChar() !== "}") {
                        throw Error(
                            "Invalid syntax. Expected `}` after React component arguments."
                        );
                    }

                    this.pointer += 1;
                    output.push({
                        name: collapseString(name),
                        arguments: args,
                    });
                    continue;
                }

                // Handle pure substitution
                this.pointer += 1;
                const identifier = [];
                do {
                    const curChar = this.curChar();
                    if (
                        curChar === null ||
                        VALID_IDENTIFIERS_CHARACTERS.indexOf(curChar) === -1
                    ) {
                        break;
                    }
                    identifier.push(curChar);
                    this.pointer += 1;
                } while (true);

                output.push(...this.substitute(identifier.join("")));
            }
        } while (true);

        flush(output, currentToken);

        return output;
    }

    substitute(key: string): Ast {
        const result = this.variables.get(key);
        return result ? result : [{ key }];
    }
}

'''
'''--- src/library-tools/bundle.json ---
{
    "descriptions": [
        {
            "type": "TransactionDescription",
            "title": "Deploy Bridge Token on NEAR",
            "filter_by": {
                "contract": "factory.bridge.near",
                "method": "deploy_bridge_token"
            },
            "mui_icon": {
                "name": "Looks",
                "color": "success"
            },
            "input_schema": {
                "type": "json"
            },
            "variables": [],
            "description": "Token address $args.address"
        },
        {
            "type": "TransactionDescription",
            "title": "Wrap NEAR",
            "filter_by": {
                "contract": "wrap.near",
                "method": "near_deposit"
            },
            "mui_icon": {
                "name": "LocalPostOffice",
                "color": "warning"
            },
            "input_schema": {
                "type": "json"
            },
            "variables": [
                {
                    "name": "debug",
                    "value": "${NEAR/Debug}"
                },
                {
                    "name": "amount",
                    "value": "${NEAR/Token,amount:$transaction.deposit}"
                }
            ],
            "description": "Wrapped $amount"
        },
        {
            "type": "TransactionDescription",
            "title": "FT Transfer Call ($name)",
            "filter_by": {
                "method": "ft_transfer_call"
            },
            "mui_icon": {
                "name": "CurrencyExchange",
                "color": "warning"
            },
            "input_schema": {
                "type": "json"
            },
            "variables": [
                {
                    "name": "token",
                    "value": "$transaction.receiver_id"
                },
                {
                    "name": "amount",
                    "value": "${Nep141/Amount,token:$token,amount:$args.amount}"
                },
                {
                    "name": "symbol",
                    "value": "${Nep141/Symbol,token:$token}"
                },
                {
                    "name": "name",
                    "value": "${Nep141/Name,token:$token}"
                },
                {
                    "name": "receiver",
                    "value": "${NEAR/Contract,accountId:$args.receiver_id}"
                }
            ],
            "description": "Send $amount $symbol to $receiver"
        }
    ]
}

'''
'''--- src/library-tools/loader.ts ---
import * as library from "./bundle.json";
import { parseItem } from "./parser";
import { ItemDefinition, TransactionItem } from "./types";

interface ILibrary {
    descriptions: ItemDefinition[];
}

function loadLibrary() {
    const libraryItems: ILibrary = library as ILibrary;

    const byContractMethod = new Map<string, TransactionItem>();
    const byContract = new Map<string, TransactionItem>();
    const byMethod = new Map<string, TransactionItem>();
    const byBaseContractMethod = new Map<string, TransactionItem>();
    const byBaseContract = new Map<string, TransactionItem>();

    libraryItems.descriptions.forEach((item) => {
        const parsedItem = parseItem(item);

        if (item.filter_by.contract !== undefined) {
            if (item.filter_by.method !== undefined) {
                byContractMethod.set(
                    `${item.filter_by.contract}.${item.filter_by.method}`,
                    parsedItem
                );
            } else {
                byContract.set(item.filter_by.contract, parsedItem);
            }
        } else if (item.filter_by.base_contract !== undefined) {
            if (item.filter_by.method !== undefined) {
                byBaseContractMethod.set(
                    `${item.filter_by.base_contract}.${item.filter_by.method}`,
                    parsedItem
                );
            } else {
                byBaseContract.set(item.filter_by.base_contract, parsedItem);
            }
        } else if (item.filter_by.method !== undefined) {
            byMethod.set(item.filter_by.method, parsedItem);
        } else {
            throw new Error("Empty filter_by");
        }
    });

    return {
        byContractMethod,
        byContract,
        byMethod,
        byBaseContractMethod,
        byBaseContract,
    };
}

export const content = loadLibrary();

'''
'''--- src/library-tools/parser.ts ---
import { AstParser } from "./ast";
import { Ast, ItemDefinition, TransactionItem } from "./types";

function buildElement(input: string, variables: Map<string, Ast>): Ast {
    const parser = new AstParser(input, variables);
    return parser.parse();
}

export function parseItem(content: ItemDefinition): TransactionItem {
    // Building variables for substitution
    const variables = new Map<string, Ast>();

    content.variables.forEach((variable) => {
        const result = buildElement(variable.value, variables);
        variables.set(variable.name, result);
    });

    return {
        type: "TransactionItem",
        title: buildElement(content.title, variables),
        mui_icon: content.mui_icon,
        input_schema: content.input_schema,
        description: buildElement(content.description, variables),
    };
}

'''
'''--- src/library-tools/types.ts ---
import { ColorType } from "../components/Transactions/TxItemBase";

type ItemType = "TransactionDescription";

export interface Filters {
    action_type?: string;
    method?: string;
    contract?: string;
    base_contract?: string;
}

export interface MuiIcon {
    name: string;
    color?: ColorType;
}

export interface Variable {
    name: string;
    value: string;
}

export interface ItemDefinition {
    type: ItemType;
    title: string;
    filter_by: Filters;
    mui_icon: MuiIcon;
    variables: Variable[];
    input_schema: InputSchema;
    description: string;
}

export interface InputSchema {
    type: "json" | "borsh" | "base64" | "hex" | "utf8" | "raw";
    schema?: any;
}

export interface TransactionItem {
    // TODO: remove type field
    type: "TransactionItem";
    title: Ast;
    mui_icon: MuiIcon;
    input_schema: InputSchema;
    description: Ast;
}

export interface TransactionReactItem {
    type: "TransactionReactItem";
    title: JSX.Element;
    icon: JSX.Element;
    icon_color: ColorType;
    description: JSX.Element;
}

export interface ReactComponentArgument {
    key: string;
    value: Ast;
}

export interface ReactComponent {
    name: string;
    arguments: ReactComponentArgument[];
}

export interface Substitute {
    key: string;
}

export type AstItem = string | ReactComponent | Substitute;
export type Ast = AstItem[];

export function isInstanceOfReactComponent(
    item: AstItem
): item is ReactComponent {
    if (typeof item !== "string") {
        return "name" in item;
    } else {
        return false;
    }
}

export function isInstanceOfSubstitute(item: AstItem): item is Substitute {
    if (typeof item !== "string") {
        return "key" in item;
    } else {
        return false;
    }
}

export interface ReactComponent2Argument {
    key: string;
    value: string;
}
export interface ReactComponent2 {
    name: string;
    arguments: ReactComponent2Argument[];
}
export type Ast2Item = string | ReactComponent2;
export type Ast2 = Ast2Item[];

'''
'''--- src/near-api/near.ts ---
import {
    NearRpcResult,
    Block,
    Chunk,
    ViewAccessKeyList,
    unwrap,
    NearRpcResultOk,
    GenesisConfig,
    Status,
    FunctionResult,
    AccountId,
} from "./types";

const NODE_URL = "https://archival-rpc.mainnet.near.org/";

async function nearFetch<T>(
    method: string,
    params: any = null
): Promise<NearRpcResult<T>> {
    const result = await fetch(
        new Request(NODE_URL, {
            method: "post",
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: "dontcare",
                method,
                params,
            }),
            headers: { "Content-Type": "application/json" },
        })
    );
    return (await result.json()) as NearRpcResult<T>;
}

// TODO: Remove method after return rust::Result
async function nearFetchOk<T>(
    method: string,
    params: any = null
): Promise<NearRpcResultOk<T>> {
    const result = await nearFetch<T>(method, params);
    return unwrap(result);
}

export async function getBlock(
    blockHeight: number
): Promise<NearRpcResultOk<Block>> {
    return await nearFetchOk<Block>("block", { block_id: blockHeight });
}

export async function getChunk(
    chunkId: string
): Promise<NearRpcResultOk<Chunk>> {
    return await nearFetchOk<Chunk>("chunk", { chunk_id: chunkId });
}

export async function viewAccessKeyList(
    accountId: string,
    blockHeight: number
): Promise<NearRpcResult<ViewAccessKeyList>> {
    return await nearFetch<ViewAccessKeyList>("query", {
        request_type: "view_access_key_list",
        block_id: blockHeight,
        account_id: accountId,
    });
}

export async function genesisConfig(): Promise<NearRpcResultOk<GenesisConfig>> {
    return await nearFetchOk<GenesisConfig>("EXPERIMENTAL_genesis_config");
}

export async function getStatus(): Promise<NearRpcResultOk<Status>> {
    return await nearFetchOk<Status>("status", []);
}

export async function viewFunction(
    accountId: AccountId,
    methodName: string,
    args: undefined | string | Buffer | any
): Promise<NearRpcResult<FunctionResult>> {
    // Make a best effort to encode args
    let args_base64;
    if (args === undefined) {
        args_base64 = Buffer.from([]);
    } else if (typeof args === "string") {
        args_base64 = Buffer.from(args, "utf-8");
    } else if (Buffer.isBuffer(args)) {
        args_base64 = args;
    } else {
        args_base64 = Buffer.from(JSON.stringify(args));
    }

    return await nearFetch<FunctionResult>("query", {
        request_type: "call_function",
        finality: "final",
        account_id: accountId,
        method_name: methodName,
        args_base64: args_base64.toString("base64"),
    });
}

'''
'''--- src/near-api/types.ts ---
export type AccountId = string;
export type CryptoHash = string;
export type U256 = string;

export interface NearRpcResultOk<T> {
    id: AccountId;
    jsonrpc: string;
    result: T;
}

export interface NearRpcResultError {
    id: AccountId;
    jsonrpc: string;
    error: any | undefined;
}

// TODO: Use Result / Either
export type NearRpcResult<T> = NearRpcResultOk<T> | NearRpcResultError;

export function unwrap<T>(result: NearRpcResult<T>): NearRpcResultOk<T> {
    if ("result" in result) {
        return result as NearRpcResultOk<T>;
    } else {
        throw new Error(`Unexpected result: ${JSON.stringify(result)}`);
    }
}
export interface GenesisConfig {
    genesis_height: number;
}

export interface FunctionCallAccessKey {
    allowance: U256;
    method_names: string[];
    receiver_id: AccountId;
}
export interface FunctionCallAccessKeyOuter {
    FunctionCall: FunctionCallAccessKey;
}

export interface AccessKey {
    nonce: number;
    permission: "FullAccess" | FunctionCallAccessKeyOuter;
}

export interface Key {
    public_key: CryptoHash;
    access_key: AccessKey;
}

export interface ViewAccessKeyList {
    block_hash: CryptoHash;
    block_heigh: number;
    keys: Key[];
}

export interface BlockChunk {
    chunk_hash: CryptoHash;
}

export interface BlockHeader {
    timestamp: number;
    timestamp_nanosec: string;
}

export interface Block {
    author: AccountId;
    chunks: BlockChunk[];
    header: BlockHeader;
}

export interface Receipt {
    predecessor_id: AccountId;
    receiver_id: AccountId;
}

export interface ActionTransfer {
    Transfer: {
        deposit: U256;
    };
}
export interface AddKey {
    access_key: AccessKey;
    public_key: CryptoHash;
}

export interface ActionAddKey {
    AddKey: AddKey;
}

export interface ActionFunctionCall {
    FunctionCall: {
        args: string;
        deposit: U256;
        gas: number;
        method_name: string;
    };
}
export interface ActionDeployContract {
    DeployContract: {
        code: string;
    };
}

export type Action =
    | ActionAddKey
    | ActionDeployContract
    | ActionFunctionCall
    | ActionTransfer;

export function isInstanceOfTransfer(action: Action): action is ActionTransfer {
    return "Transfer" in action;
}

export function isInstanceOfAddKey(action: Action): action is ActionAddKey {
    return "AddKey" in action;
}

export function isInstanceOfFunctionCall(
    action: Action
): action is ActionFunctionCall {
    return "FunctionCall" in action;
}

export function isInstanceOfDeployContract(
    action: Action
): action is ActionDeployContract {
    return "DeployContract" in action;
}

export interface Transaction {
    actions: Action[];
    hash: CryptoHash;
    nonce: number;
    public_key: CryptoHash;
    receiver_id: AccountId;
    signature: CryptoHash;
    signer_id: AccountId;
}

// TODO: Rename to Context
export interface TransactionWithBlock {
    tx: Transaction;
    block: Block;
}

export interface Chunk {
    receipts: Receipt[];
    transactions: Transaction[];
}

export interface SyncInfo {
    latest_block_height: number;
}

export interface Status {
    sync_info: SyncInfo;
}

export interface FunctionResult {
    block_hash: CryptoHash;
    block_height: number;
    logs: any[];
    result: number[];
}

'''
'''--- src/storage/contract.ts ---
import { viewFunction } from "../near-api/near";
import { AccountId } from "../near-api/types";

export async function persistentViewCall(
    accountId: AccountId,
    methodName: string
): Promise<Buffer | null> {
    // TODO: Persist this information
    const output = await viewFunction(accountId, methodName, {});
    if ("result" in output) {
        return Buffer.from(output.result.result);
    } else {
        return null;
    }
}

'''
'''--- src/store.ts ---
import { configureStore } from "@reduxjs/toolkit";
import txReducer from "./actions/TxsAction";

const store = configureStore({
    reducer: {
        txs: txReducer,
    },
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;

export default store;

'''
'''--- src/utils/format.ts ---
import BigNumber from "bignumber.js";

export function yoctoToNear(amount: string): string {
    let x = new BigNumber(amount);
    x = x.div(new BigNumber(10).pow(24 - 6));
    const res = (x.toNumber() / 1000000).toFixed(2);
    return res;
}

'''
'''--- src/utils/reportWebVitals.ts ---
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

'''