*GitHub Repository "near-hackathon-luciferius/nft-example"*

'''--- .cargo/config.toml ---
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]

'''
'''--- Cargo.toml ---
[package]
name = "non-fungible-token-wrapper"
version = "0.0.2"
authors = ["Luciferius <twitter.cryptosketches@gmail.com>"]
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
near-primitives = "0.5.0"
near-contract-standards = "4.0.0-pre.8"
near-sdk = "4.0.0-pre.8"
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.1.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "test-approval-receiver",
  "test-token-receiver",
]

'''
'''--- README.md ---
Non-fungible Token (NFT)
===================

Example implementation of a [non-fungible token] contract which uses [near-contract-standards] and [simulation] tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

NOTES:
 - The maximum balance value is limited by U128 (2**128 - 1).
 - JSON calls should pass [U128](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.U128.html) or [U64](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.U64.html) as a base-10 string. E.g. "100".
 - The core NFT standard does not include escrow/approval functionality, as `nft_transfer_call` provides a superior approach. Please see the approval management standard if this is the desired approach.

## Building
To build run:
```bash
./build.sh
```

## Testing
To test run:
```bash
cargo test --workspace --package non-fungible-token -- --nocapture
```

'''
'''--- build.bat ---
@echo off

title NFT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
'''
'''--- build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/approval_receiver.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/non_fungible_token.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/token_receiver.wasm ./res/
'''
'''--- nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Luciferius <twitter.cryptosketches@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.8"
near-contract-standards = "4.0.0-pre.8"

'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `token_owner_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        token_owner_id: AccountId
    ) -> Token {
        self.tokens.internal_mint(token_id, token_owner_id, Some(TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0));
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id, accounts(0));
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0));

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1));
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0));

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.0.1"
authors = ["Luciferius <twitter.cryptosketches@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.8"
near-contract-standards = "4.0.0-pre.8"

'''
'''--- test-approval-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_approve for simulation testing nft_approve.
*/
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_NFT_ON_APPROVE: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ApprovalReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

#[near_bindgen]
impl ApprovalReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for ApprovalReceiver {
    /// Could do anything useful to the approval-receiving contract, such as store the given
    /// approval_id for use later when calling the NFT contract. Can also return whatever it wants,
    /// maybe after further promise calls. This one simulates "return anything" behavior only.
    /// Supports the following `msg` patterns:
    /// * "return-now" - immediately return `"cool"`
    /// * anything else - return the given `msg` after one more cross-contract call
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        // Verifying that we were called by non-fungible token contract that we expect.
        require!(
            env::predecessor_account_id() == self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        match msg.as_str() {
            "return-now" => PromiseOrValue::Value("cool".to_string()),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(msg, account_id, NO_DEPOSIT, prepaid_gas - GAS_FOR_NFT_ON_APPROVE)
                    .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for ApprovalReceiver {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String> {
        log!("in ok_go, msg={}", msg);
        PromiseOrValue::Value(msg)
    }
}

'''
'''--- test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Luciferius <twitter.cryptosketches@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.8"
near-contract-standards = "4.0.0-pre.8"

'''
'''--- test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_transfer for simulation testing nft_transfer_call.
*/
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(BASE_GAS + PROMISE_CALL);

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Verifying that we were called by non-fungible token contract that we expect.
        require!(
            env::predecessor_account_id() == self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_transfer; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &sender_id,
            &previous_owner_id,
            &token_id,
            msg
        );
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(true),
            "return-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(true, account_id, NO_DEPOSIT, prepaid_gas - GAS_FOR_NFT_ON_TRANSFER)
                    .into()
            }
            "keep-it-now" => PromiseOrValue::Value(false),
            "keep-it-later" => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::ok_go(
                    false,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - GAS_FOR_NFT_ON_TRANSFER,
                )
                .into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool> {
        log!("in ok_go, return_it={}", return_it);
        PromiseOrValue::Value(return_it)
    }
}

'''
'''--- tests/workspaces/main.rs ---
mod test_approval;
mod test_core;
mod test_enumeration;
mod utils;

'''
'''--- tests/workspaces/test_approval.rs ---
use crate::utils::init;
use near_contract_standards::non_fungible_token::Token;
use near_primitives::views::FinalExecutionStatus;
use near_sdk::{AccountId, ONE_NEAR, ONE_YOCTO};
use std::collections::HashMap;
use std::convert::TryFrom;

pub const TOKEN_ID: &str = "0";

#[tokio::test]
async fn simulate_simple_approve() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // check nft_is_approved, don't provide approval_id
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approved);

    // check nft_is_approved, with approval_id=1
    let alice_approval_id_is_1 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(1u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approval_id_is_1);

    // check nft_is_approved, with approval_id=2
    let alice_approval_id_is_2 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(&(TOKEN_ID, alice.id(), Some(2u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approval_id_is_2);

    // alternatively, one could check the data returned by nft_token
    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    let mut expected_approvals: HashMap<AccountId, u64> = HashMap::new();
    expected_approvals.insert(AccountId::try_from(alice.id().to_string())?, 1);
    assert_eq!(token.approved_account_ids.unwrap(), expected_approvals);

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(ONE_NEAR)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let alice_approval_id_is_2 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(2u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(alice_approval_id_is_2);

    // approving another account gives different approval_id
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        // note that token_receiver's account name is shorter, and so takes less bytes to store and
        // therefore requires a smaller deposit!
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token_receiver_approval_id_is_3 = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(token_receiver_approval_id_is_3);

    Ok(())
}

#[tokio::test]
async fn simulate_approval_with_call() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, approval_receiver_contract) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, approval_receiver_contract.id(), Some("return-now".to_string())))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert_eq!(res.json::<String>()?, "cool".to_string());

    // Approve again; will set different approval_id (ignored by approval_receiver).
    // The approval_receiver implementation will return given `msg` after subsequent promise call,
    // if given something other than "return-now".
    let msg = "hahaha".to_string();
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, approval_receiver_contract.id(), Some(msg.clone())))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert_eq!(res.json::<String>()?, msg);

    Ok(())
}

#[tokio::test]
async fn simulate_approved_account_transfers_token() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice sends to self
    let res = alice
        .call(&worker, nft_contract.id().clone(), "nft_transfer")
        .args_json((alice.id(), TOKEN_ID, Some(1u64), Some("gotcha! bahahaha".to_string())))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // token now owned by alice
    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), alice.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_revoke() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root approves token_receiver
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root revokes alice
    let res = nft_contract
        .call(&worker, "nft_revoke")
        .args_json((TOKEN_ID, alice.id()))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // but token_receiver is still approved
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(token_receiver_approved);

    // root revokes token_receiver
    let res = nft_contract
        .call(&worker, "nft_revoke")
        .args_json((TOKEN_ID, token_receiver_contract.id()))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is still revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // ...and now so is token_receiver
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!token_receiver_approved);

    Ok(())
}

#[tokio::test]
async fn simulate_revoke_all() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, token_receiver_contract, _) = init(&worker).await?;

    // root approves alice
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, alice.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(510000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root approves token_receiver
    let res = nft_contract
        .call(&worker, "nft_approve")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<String>::None))?
        .gas(300_000_000_000_000)
        .deposit(450000000000000000000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // root revokes all
    let res = nft_contract
        .call(&worker, "nft_revoke_all")
        .args_json((TOKEN_ID,))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // alice is revoked...
    let alice_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, alice.id(), Some(3u64)))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!alice_approved);

    // and so is token_receiver
    let token_receiver_approved = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json((TOKEN_ID, token_receiver_contract.id(), Option::<u64>::None))?
        .view()
        .await?
        .json::<bool>()?;
    assert!(!token_receiver_approved);

    Ok(())
}

'''
'''--- tests/workspaces/test_core.rs ---
use crate::utils::{init, TOKEN_ID};
use near_contract_standards::non_fungible_token::Token;
use near_primitives::views::FinalExecutionStatus;
use near_sdk::ONE_YOCTO;

#[tokio::test]
async fn simulate_simple_transfer() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    let res = nft_contract
        .call(&worker, "nft_transfer")
        .args_json((
            alice.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("simple transfer".to_string()),
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), alice.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_fast_return_to_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "return-it-now",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_slow_return_to_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "return-it-later",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_fast_keep_with_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "keep-it-now",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), token_receiver_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_slow_keep_with_sender() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "keep-it-later",
        ))?
        .gas(300_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), token_receiver_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_receiver_panics() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "incorrect message",
        ))?
        .gas(35_000_000_000_000 + 1)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints final log
    // assert_eq!(res.logs().len(), 1);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_transfer_call_receiver_panics_and_nft_resolve_transfer_produces_no_log_if_not_enough_gas(
) -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, token_receiver_contract, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer_call")
        .args_json((
            token_receiver_contract.id(),
            TOKEN_ID,
            Option::<u64>::None,
            Some("transfer & call"),
            "incorrect message",
        ))?
        .gas(30_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::Failure(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_simple_transfer_no_logs_on_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;

    let res = nft_contract
        .call(&worker, "nft_transfer")
        // transfer to the current owner should fail and not print log
        .args_json((nft_contract.id(), TOKEN_ID, Option::<u64>::None, Some("simple transfer")))?
        .gas(200_000_000_000_000)
        .deposit(ONE_YOCTO)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::Failure(_)));

    // TODO: Check the logs once workspaces starts exposing them
    // Prints no logs
    // assert_eq!(res.logs().len(), 0);

    let token = nft_contract
        .call(&worker, "nft_token")
        .args_json((TOKEN_ID,))?
        .view()
        .await?
        .json::<Token>()?;
    assert_eq!(token.owner_id.to_string(), nft_contract.id().to_string());

    Ok(())
}

'''
'''--- tests/workspaces/test_enumeration.rs ---
use crate::utils::{helper_mint, init};
use near_contract_standards::non_fungible_token::Token;
use near_sdk::json_types::U128;
use workspaces::{Contract, DevNetwork, Worker};

async fn mint_more(
    nft_contract: &Contract,
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<()> {
    helper_mint(
        nft_contract,
        worker,
        "1".to_string(),
        "Black as the Night".to_string(),
        "In charcoal".to_string(),
    )
    .await?;
    helper_mint(
        nft_contract,
        worker,
        "2".to_string(),
        "Hamakua".to_string(),
        "Vintage recording".to_string(),
    )
    .await?;
    helper_mint(
        nft_contract,
        worker,
        "3".to_string(),
        "Aloha ke akua".to_string(),
        "Original with piano".to_string(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn simulate_enum_total_supply() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    let total_supply: U128 = nft_contract.call(&worker, "nft_total_supply").view().await?.json()?;
    assert_eq!(total_supply, U128::from(4));

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_tokens() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, _, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    // No optional args should return all
    let mut tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 4);
    // Start at "1", with no limit arg
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Some(U128::from(1)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 3);
    assert_eq!(tokens.get(0).unwrap().token_id, "1".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "2".to_string());
    assert_eq!(tokens.get(2).unwrap().token_id, "3".to_string());

    // Start at "2", with limit 1
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Some(U128::from(2)), Some(1u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens.get(0).unwrap().token_id, "2".to_string());

    // Don't specify from_index, but limit 2
    tokens = nft_contract
        .call(&worker, "nft_tokens")
        .args_json((Option::<U128>::None, Some(2u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 2);
    assert_eq!(tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "1".to_string());

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_supply_for_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;

    // Get number from account with no NFTs
    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((alice.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(0));

    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((nft_contract.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(1));

    mint_more(&nft_contract, &worker).await?;

    let owner_num_tokens: U128 = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json((nft_contract.id(),))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_num_tokens, U128::from(4));

    Ok(())
}

#[tokio::test]
async fn simulate_enum_nft_tokens_for_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let (nft_contract, alice, _, _) = init(&worker).await?;
    mint_more(&nft_contract, &worker).await?;

    // Get tokens from account with no NFTs
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((alice.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 0);

    // Get tokens with no optional args
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Option::<U128>::None, Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 4);

    // With from_index and no limit
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Some(U128::from(2)), Option::<u64>::None))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 2);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "2".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "3".to_string());

    // With from_index and limit 1
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Some(U128::from(1)), Some(1u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 1);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "1".to_string());

    // No from_index but limit 3
    let owner_tokens: Vec<Token> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json((nft_contract.id(), Option::<U128>::None, Some(3u64)))?
        .view()
        .await?
        .json()?;
    assert_eq!(owner_tokens.len(), 3);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "1".to_string());
    assert_eq!(owner_tokens.get(2).unwrap().token_id, "2".to_string());

    Ok(())
}

'''
'''--- tests/workspaces/utils.rs ---
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_contract_standards::non_fungible_token::TokenId;
use near_primitives::views::FinalExecutionStatus;
use near_units::parse_near;
use workspaces::prelude::DevAccountDeployer;
use workspaces::{Account, Contract, DevNetwork, Worker};

pub const TOKEN_ID: &str = "0";

pub async fn helper_mint(
    nft_contract: &Contract,
    worker: &Worker<impl DevNetwork>,
    token_id: TokenId,
    title: String,
    desc: String,
) -> anyhow::Result<()> {
    let token_metadata = TokenMetadata {
        title: Some(title),
        description: Some(desc),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let res = nft_contract
        .call(&worker, "nft_mint")
        .args_json((token_id, nft_contract.id(), token_metadata))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    Ok(())
}

/// Deploy and initialize contracts and return:
/// * nft_contract: the NFT contract, callable with `call!` and `view!`
/// * alice: a user account, does not yet own any tokens
/// * token_receiver_contract: a contract implementing `nft_on_transfer` for use with `transfer_and_call`
/// * approval_receiver_contract: a contract implementing `nft_on_approve` for use with `nft_approve`
pub async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Account, Contract, Contract)> {
    let nft_contract =
        worker.dev_deploy(include_bytes!("../../res/non_fungible_token.wasm").to_vec()).await?;

    let res = nft_contract
        .call(&worker, "new_default_meta")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let token_metadata = TokenMetadata {
        title: Some("Olympus Mons".into()),
        description: Some("The tallest mountain in the charted solar system".into()),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let res = nft_contract
        .call(&worker, "nft_mint")
        .args_json((TOKEN_ID, nft_contract.id(), token_metadata))?
        .gas(300_000_000_000_000)
        .deposit(parse_near!("7 mN"))
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let res = nft_contract
        .as_account()
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?;
    assert!(matches!(res.details.status, FinalExecutionStatus::SuccessValue(_)));
    let alice = res.result;

    let token_receiver_contract =
        worker.dev_deploy(include_bytes!("../../res/token_receiver.wasm").to_vec()).await?;
    let res = token_receiver_contract
        .call(&worker, "new")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    let approval_receiver_contract =
        worker.dev_deploy(include_bytes!("../../res/approval_receiver.wasm").to_vec()).await?;
    let res = approval_receiver_contract
        .call(&worker, "new")
        .args_json((nft_contract.id(),))?
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    assert!(matches!(res.status, FinalExecutionStatus::SuccessValue(_)));

    return Ok((nft_contract, alice, token_receiver_contract, approval_receiver_contract));
}

'''