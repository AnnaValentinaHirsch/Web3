*GitHub Repository "parkdao/parkdao"*

'''--- Cargo.toml ---
[package]
name = "parkdao"
version = "0.0.2"
authors = ["Evan Feenstra <evanfeenstra@gmail.com>"]
edition = "2018"

[dependencies]
near-sdk = "4.0.0-pre.5"
near-sdk-sim = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"

# remember to include a line for each contract
non-fungible-token = { path = "./nft" }
market = { path = "./market" }
park-token = { path = "./park" }

[dev-dependencies]
tokio = { version = "1.10.0", features = ["full"] }
workspaces = "0.1" 
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.1.0"
serde_json = { version = "1.0", features = ["arbitrary_precision"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "market",
  "park",
]

'''
'''--- README.md ---
[![parkdao](https://parkdao.sfo3.digitaloceanspaces.com/media/3bjKUasf7SVHjvFA3W25wohua7NbkrvYpmvFhsix9ek3)](https://parkdao.xyz/world)

This repository contains 3 NEAR smart contracts that compose the parkdao ecosystem. Frontend code is [here](https://github.com/middlew4y/parkdao-platform)

### park

 - `NEP 141` Fungible Token
 - staking pool for parkdao NFTs, using `nft_on_transfer`
 - DAO contract with proposals and voting
 - core Council based on [multi-ownable](https://crates.io/crates/multi-ownable)

### market
 
 - marketplace for NFTs using `approvals`
 - auctions can be settled without owner being online

### nft

 - `NEP 171` NFT contract

### build

`./build.sh`

### test

`cargo test -- --nocapture`

Integration testing is built with the [workspaces.rs](https://github.com/near/workspaces-rs) framework.

'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
source flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./out/
'''
'''--- flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- market/Cargo.toml ---
[package]
name = "market"
version = "0.0.1"
authors = ["middlew4y <middlew4y@protonmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]
 
[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"

'''
'''--- market/src/external.rs ---
use crate::*;

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: u128, memo: Option<String>);
}

'''
'''--- market/src/lib.rs ---
mod external;
mod nft_on_approve;
mod sale;
mod sale_views;

use crate::external::*;
use crate::sale::*;

use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::json_types::U64;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const NFT_TRANSFER_GAS: u64 = 10_000_000_000_000;
const NO_DEPOSIT: Balance = 0;
static DELIMETER: &str = "||";

pub type ContractAndTokenId = String;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Market {
    pub owner_id: AccountId,
    pub nft_contracts: UnorderedSet<AccountId>,
    pub ft_contracts: UnorderedSet<AccountId>,
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    NFTContractIds,
    FTTokenIds,
}

#[near_bindgen]
impl Market {
    #[init]
    pub fn new(owner_id: AccountId, nft_contract: AccountId) -> Self {
        let mut this = Self {
            owner_id: owner_id,
            nft_contracts: UnorderedSet::new(StorageKey::NFTContractIds),
            ft_contracts: UnorderedSet::new(StorageKey::FTTokenIds),
            sales: UnorderedMap::new(StorageKey::Sales),
        };
        // support near by default
        let near_id = AccountId::new_unchecked("near".to_string());
        this.ft_contracts.insert(&near_id);
        // initial nft contract
        this.nft_contracts.insert(&nft_contract);
        this
    }

    pub fn owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// only owner
    pub fn add_nft_contract(&mut self, nft_contract: AccountId) -> bool {
        self.assert_owner();
        self.nft_contracts.insert(&nft_contract)
    }

    /// only owner
    pub fn add_ft_contract(&mut self, ft_contract: AccountId) -> bool {
        self.assert_owner();
        self.ft_contracts.insert(&ft_contract)
    }

    pub fn supported_ft_contracts(&self) -> Vec<AccountId> {
        self.ft_contracts.to_vec()
    }

    pub fn supported_nft_contracts(&self) -> Vec<AccountId> {
        self.nft_contracts.to_vec()
    }
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Owner's method"
        );
    }

    pub(crate) fn now(&self) -> u64 {
        env::block_timestamp() / 1_000_000 // millis
    }

    pub fn get_now(&self) -> U64 {
        U64(self.now())
    }
}

'''
'''--- market/src/nft_on_approve.rs ---
use crate::*;
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{log, PromiseOrValue};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct SaleArgs {
    price: u128,
    exp: u64,
    ft_contract: Option<AccountId>,
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for Market {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        assert!(
            &self.nft_contracts.contains(&env::predecessor_account_id()),
            "Only supports some NFT contracts"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        // enforce cross contract call and owner_id is signer
        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        assert_ne!(
            nft_contract_id, signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        assert_eq!(owner_id, signer_id, "owner_id should be signer_id");
        let SaleArgs { price, exp, ft_contract } =
            near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        assert!(exp==0 || exp > self.now(), "exp should be in the future");

        let the_ft_contract = if ft_contract.is_some() {
            ft_contract.unwrap()
        } else {
            AccountId::new_unchecked("near".to_string())
        };
        if !self.ft_contracts.contains(&the_ft_contract) {
            env::panic_str("Token {} not supported by this market");
        }
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone().into(),
                approval_id,
                nft_contract: nft_contract_id.clone(),
                token_id: token_id.clone(),
                ft_contract: the_ft_contract,
                bid: None,
                min_price: price,
                exp: U64(exp),
                created_at: U64(self.now()),
            },
        );

        // let prepaid_gas = env::prepaid_gas();
        // let account_id = env::current_account_id();
        PromiseOrValue::Value(contract_and_token_id)
    }
}

'''
'''--- market/src/sale.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Promise, PromiseResult};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub owner_id: AccountId,
    pub price: Balance,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract: AccountId,
    pub token_id: String,
    pub ft_contract: AccountId,
    pub min_price: Balance,
    pub bid: Option<Bid>,
    pub created_at: U64,
    pub exp: U64, // expiry timestamp. 0 = not an auction
}

#[near_bindgen]
impl Market {
    #[payable]
    pub fn bid(&mut self, nft_contract: AccountId, token_id: String) {
        let contract_and_token_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");
        let buyer_id = env::predecessor_account_id();
        assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");

        let ft_contract = AccountId::new_unchecked("near".to_string());
        assert_eq!(sale.ft_contract, ft_contract, "Not for sale in NEAR");

        let deposit = env::attached_deposit();
        assert!(deposit > 0, "Attached deposit must be greater than 0");

        let is_auction = sale.exp.0 > 0;

        if !is_auction && deposit >= sale.min_price {
            self.process_purchase(nft_contract, token_id, ft_contract, U128(deposit), buyer_id);
        } else {
            if is_auction && sale.min_price > 0 {
                assert!(
                    deposit >= sale.min_price,
                    "Attached deposit must be greater than min price"
                );
            }
            self.add_bid(contract_and_token_id, deposit, ft_contract, buyer_id, &mut sale);
        }
    }

    // the highest bid wins (if exp is passed). Anyone can call "settle"
    pub fn settle(&mut self, nft_contract: AccountId, token_id: String) {
        let contract_and_token_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
        let sale = self.sales.get(&contract_and_token_id).expect("No sale");
        assert!(sale.bid.is_some(), "No bid to settle");
        let bid = sale.bid.unwrap();
        assert!(sale.exp.0 > 0, "Can only settle auctions");
        assert!(sale.exp.0 < self.now(), "Can only settle after expiry time");
        self.process_purchase(nft_contract, token_id, sale.ft_contract, U128(bid.price), bid.owner_id);
    }

    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract: AccountId,
        token_id: String,
        ft_contract: AccountId,
        price: U128,
        buyer_id: AccountId,
    ) -> Promise {
        let sale = self.internal_remove_sale(nft_contract.clone(), token_id.clone());

        ext_contract::nft_transfer(
            buyer_id.clone(),
            sale.token_id,
            Some(sale.approval_id),
            None,
            sale.nft_contract,
            1,
            Gas(NFT_TRANSFER_GAS),
        )
        .then(ext_self::resolve_purchase(
            ft_contract,
            sale.owner_id,
            price,
            env::current_account_id(),
            NO_DEPOSIT,
            Gas(BASE_GAS),
        ))
    }

    #[private]
    pub fn add_bid(
        &mut self,
        contract_and_token_id: ContractAndTokenId,
        amount: Balance,
        ft_contract: AccountId,
        buyer_id: AccountId,
        sale: &mut Sale,
    ) {
        // store a bid and refund any current bid lower
        let new_bid = Bid {
            owner_id: buyer_id,
            price: amount,
        };
        if sale.bid.is_some() {
            let current_bid = sale.bid.clone().unwrap();
            assert!(
                amount > current_bid.price,
                "Can't pay less than or equal to current bid price: {}",
                current_bid.price
            );
            // refund
            self.payout(ft_contract, current_bid.owner_id, current_bid.price);
        }
        sale.bid = Some(new_bid);
        // update the storage
        self.sales.insert(&contract_and_token_id, &sale);
    }

    #[private]
    pub fn resolve_purchase(&mut self, ft_contract: AccountId, seller_id: AccountId, price: U128) {
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => env::panic_str("nft_transfer failed"),
            PromiseResult::Successful(_result) => {
                self.payout(ft_contract, seller_id, price.0);
            },
        }
    }

    #[private]
    pub fn payout(&self, ft_contract: AccountId, receiver: AccountId, amount: Balance) {
        if ft_contract.to_string() == "near" {
            Promise::new(receiver.clone()).transfer(u128::from(amount));
        } else {
            ext_contract::ft_transfer(receiver.clone(), amount, None, ft_contract, 1, Gas(BASE_GAS));
        }
    }

    pub(crate) fn internal_remove_sale(&mut self, nft_contract: AccountId, token_id: TokenId) -> Sale {
        let contract_and_token_id = format!("{}{}{}", &nft_contract, DELIMETER, token_id);
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");
        sale
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(&mut self, ft_contract: AccountId, seller_id: AccountId, price: U128) -> Promise;
}

'''
'''--- market/src/sale_views.rs ---
use crate::*;
use near_sdk::json_types::U64;
use near_sdk::near_bindgen;

#[near_bindgen]
impl Market {
    
    //returns the number of sales the marketplace has up (as a string)
    pub fn get_supply_sales(&self) -> U64 {
        U64(self.sales.len())
    }

    pub fn get_all_sales(&self) -> Vec<Sale> {
        self.sales.to_vec().iter().map(|t| t.1.clone()).collect()
    }

    pub fn get_sales_by_contract(&self, nft_contract: AccountId) -> Vec<Sale> {
        self.sales.to_vec().iter().filter(|t| {
            let split: Vec<&str> = t.0.split(DELIMETER).collect();
            let nft_id = split.get(0).unwrap();
            nft_id.to_string() == nft_contract.to_string()
        }).map(|t| t.1.clone()).collect()
    }

    pub fn get_sale(&self, contract_and_token: ContractAndTokenId) -> Option<Sale> {
        self.sales.get(&contract_and_token)
    }

}
'''
'''--- nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"

'''
'''--- nft/src/lib.rs ---

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};
use std::collections::HashMap;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_ICON: &str = "data:image/svg+xml,%3Csvg id='Artwork' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 598.6 369.78'%3E%3Cpath d='M159,209.67c-12.42,0-21.93,9-21.93,21.64v22.44h43.67V231.31C180.75,218.69,171.43,209.67,159,209.67Z'/%3E%3Cpath d='M401.43,228.52c-5.92,0-10.09,2.91-11.45,8.25h22.61C411.33,231.43,407.06,228.52,401.43,228.52Z'/%3E%3Cpath d='M225.86,228.52c-5.92,0-10.09,2.91-11.45,8.25H237C235.76,231.43,231.49,228.52,225.86,228.52Z'/%3E%3Cpath d='M299.3,70.48C172.92,70.48,70.48,172.92,70.48,299.3H528.12C528.12,172.92,425.67,70.48,299.3,70.48Zm-105,195.79H123.49V231.21c0-20.57,15.43-35.42,35.52-35.42s35.32,14.85,35.32,35.42Zm55.4-19.41h-35c1.65,4.85,6.21,8.15,12,8.15a12.44,12.44,0,0,0,9.69-4.43l11.86,4.91c-4.27,7.19-12.13,11.84-21.74,11.84-14.75,0-25.33-11.06-25.33-25.42,0-14.56,10.09-25.62,24.55-25.62s24.46,10.87,24.46,25.42A30,30,0,0,1,249.73,246.86Zm51.09,19.41h-13.2v-28c0-5.05-3.39-9.12-9-9.12a8.82,8.82,0,0,0-9.13,9.12v28H256.28V217.36h13v3.1a19.4,19.4,0,0,1,12.23-4.17c11.16,0,19.31,8.34,19.31,19.41Zm20.44,0h-13.2V217.36h13.2Zm-6.6-56.36a7.06,7.06,0,1,1,7.06-7.06A6.9,6.9,0,0,1,314.66,209.91Zm59.85,19.48-26.3,24.36h26.3v12.52H329.29v-12l26.3-24.35h-26.3V217.36h45.22Zm50.79,17.47h-35c1.65,4.85,6.21,8.15,12,8.15a12.44,12.44,0,0,0,9.69-4.43l11.86,4.91c-4.27,7.19-12.13,11.84-21.74,11.84-14.75,0-25.33-11.06-25.33-25.42,0-14.56,10.09-25.62,24.55-25.62s24.46,10.87,24.46,25.42A30,30,0,0,1,425.3,246.86Zm36.61,19.41v-28c0-5.05-3.4-9.12-9-9.12a8.81,8.81,0,0,0-9.12,9.12v28h-13.2V217.36h13v3.1a19.37,19.37,0,0,1,12.22-4.17c11.16,0,19.31,8.34,19.31,19.41v30.57Z'/%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Denizen NFT".to_string(),
                symbol: "DENIZEN".to_string(),
                icon: Some(DATA_IMAGE_SVG_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");
        self.tokens
            .internal_mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id, accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- out/README.md ---
# Folder that contains wasm files
'''
'''--- park/Cargo.toml ---
[package]
name = "park-token"
version = "0.0.1"
authors = ["middlew4y <middlew4y@protonmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"
multi-ownable = "0.1.1"
'''
'''--- park/src/external.rs ---
use crate::*;
// use near_contract_standards::non_fungible_token::Token;

#[ext_contract(ext_contract)]
pub trait ExtContract {
  fn nft_transfer(
    &self,
    receiver_id: AccountId,
    token_id: String,
    approval_id: Option<u64>,
    memo: Option<String>,
  ) -> Vec<Token>;
  fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token>;
  fn nft_tokens_for_owner(
    &self,
    account_id: AccountId,
    from_index: Option<U128>,
    limit: Option<u64>,
  ) -> Vec<Token>;
}

'''
'''--- park/src/lib.rs ---
mod external;
mod owner_calls;
mod proposals;
mod stake;
mod views;

use crate::external::*;
use crate::owner_calls::MultiOwnableCall;

use multi_ownable::{impl_multi_ownable, MultiOwnableData};

use near_contract_standards::fungible_token::metadata::{
  FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::{
  env, ext_contract, log, near_bindgen, require, AccountId, Balance, BorshStorageKey, Gas,
  PanicOnDefault, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  genesis: u64,
  epoch_millis: u64,
  nfts: UnorderedSet<stake::SupportedNft>,
  stakes: UnorderedMap<ContractAndTokenId, stake::Stake>,
  reward_rate: u16, // inflation basis points per epoch
  token: FungibleToken,
  metadata: LazyOption<FungibleTokenMetadata>,
  multi_ownable: MultiOwnableData,
}

const DATA_IMAGE_SVG_ICON: &str = "data:image/svg+xml,%3Csvg id='Artwork' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 598.6 369.78'%3E%3Cpath d='M159,209.67c-12.42,0-21.93,9-21.93,21.64v22.44h43.67V231.31C180.75,218.69,171.43,209.67,159,209.67Z'/%3E%3Cpath d='M401.43,228.52c-5.92,0-10.09,2.91-11.45,8.25h22.61C411.33,231.43,407.06,228.52,401.43,228.52Z'/%3E%3Cpath d='M225.86,228.52c-5.92,0-10.09,2.91-11.45,8.25H237C235.76,231.43,231.49,228.52,225.86,228.52Z'/%3E%3Cpath d='M299.3,70.48C172.92,70.48,70.48,172.92,70.48,299.3H528.12C528.12,172.92,425.67,70.48,299.3,70.48Zm-105,195.79H123.49V231.21c0-20.57,15.43-35.42,35.52-35.42s35.32,14.85,35.32,35.42Zm55.4-19.41h-35c1.65,4.85,6.21,8.15,12,8.15a12.44,12.44,0,0,0,9.69-4.43l11.86,4.91c-4.27,7.19-12.13,11.84-21.74,11.84-14.75,0-25.33-11.06-25.33-25.42,0-14.56,10.09-25.62,24.55-25.62s24.46,10.87,24.46,25.42A30,30,0,0,1,249.73,246.86Zm51.09,19.41h-13.2v-28c0-5.05-3.39-9.12-9-9.12a8.82,8.82,0,0,0-9.13,9.12v28H256.28V217.36h13v3.1a19.4,19.4,0,0,1,12.23-4.17c11.16,0,19.31,8.34,19.31,19.41Zm20.44,0h-13.2V217.36h13.2Zm-6.6-56.36a7.06,7.06,0,1,1,7.06-7.06A6.9,6.9,0,0,1,314.66,209.91Zm59.85,19.48-26.3,24.36h26.3v12.52H329.29v-12l26.3-24.35h-26.3V217.36h45.22Zm50.79,17.47h-35c1.65,4.85,6.21,8.15,12,8.15a12.44,12.44,0,0,0,9.69-4.43l11.86,4.91c-4.27,7.19-12.13,11.84-21.74,11.84-14.75,0-25.33-11.06-25.33-25.42,0-14.56,10.09-25.62,24.55-25.62s24.46,10.87,24.46,25.42A30,30,0,0,1,425.3,246.86Zm36.61,19.41v-28c0-5.05-3.4-9.12-9-9.12a8.81,8.81,0,0,0-9.12,9.12v28h-13.2V217.36h13v3.1a19.37,19.37,0,0,1,12.22-4.17c11.16,0,19.31,8.34,19.31,19.41v30.57Z'/%3E%3C/svg%3E";
// there are 2551443 seconds in a lunar month
// const LUNAR_SECONDS: u64 = 2551443;
// there are 637860750 milliseconds in a lunar "week"
// const LUNAR_WEEK_MILLIS: u64 = LUNAR_SECONDS*1000/4;
const BASE_GAS: u64 = 5_000_000_000_000;
const GAS_FOR_NFT_TRANSFER: u64 = 15_000_000_000_000;

// const TWO_WEEKS: u64 = 1_209_600_000; // millis
// const DAY_MILLIS: u64 = 86_400_000;
const DELIMETER: &str = "||";

pub type ContractAndTokenId = String;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  NFTContracts,
  Stakes,
  FungibleToken,
  Metadata,
  Owners,
  MultiOwnableCalls,
}

#[near_bindgen]
impl Contract {
  /// Initializes the contract with the given total supply owned by the given `owner_id` with
  /// default metadata (for example purposes only).
  #[init]
  pub fn new_default_meta(owner_id: AccountId, total_supply: U128, epoch_millis: u64) -> Self {
    Self::new(
      owner_id,
      total_supply,
      epoch_millis,
      FungibleTokenMetadata {
        spec: FT_METADATA_SPEC.to_string(),
        name: "Park Token".to_string(),
        symbol: "PARK".to_string(),
        icon: Some(DATA_IMAGE_SVG_ICON.to_string()),
        reference: None,
        reference_hash: None,
        decimals: 24,
      },
    )
  }

  #[init]
  pub fn new(
    owner_id: AccountId,
    total_supply: U128,
    epoch_millis: u64,
    metadata: FungibleTokenMetadata,
  ) -> Self {
    require!(!env::state_exists(), "Already initialized");
    metadata.assert_valid();
    let mut this = Self {
      genesis: 0,
      reward_rate: 0,
      epoch_millis: epoch_millis,
      stakes: UnorderedMap::new(StorageKey::Stakes),
      // proposals: UnorderedMap::new(StorageKey::Proposals),
      nfts: UnorderedSet::new(StorageKey::NFTContracts),
      token: FungibleToken::new(StorageKey::FungibleToken),
      metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
      multi_ownable: MultiOwnableData::new(StorageKey::Owners, StorageKey::MultiOwnableCalls),
    };
    this.init_multi_ownable(vec![owner_id.clone()], 1);
    this.genesis = this.now();
    this.token.internal_register_account(&owner_id);
    this.token.internal_deposit(&owner_id, total_supply.into());
    this
  }

  pub fn now(&self) -> u64 {
    env::block_timestamp() / 1_000_000 // milliseconds
  }

  fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
    log!("Closed @{} with {}", account_id, balance);
  }

  fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
    log!("Account @{} burned {}", account_id, amount);
  }

  pub fn genesis(&self) -> u64 {
    self.genesis
  }

  pub fn reward_rate(&self) -> u16 {
    self.reward_rate
  }

  pub fn supported_nfts(&self) -> Vec<stake::SupportedNft> {
    self.nfts.to_vec()
  }

  fn on_call(&mut self, call_name: MultiOwnableCall, arguments: &str) {
    match call_name {
      MultiOwnableCall::SetRewardRate => self._set_reward_rate(arguments),
      MultiOwnableCall::UpdateWeights => self._update_weights(arguments),
      MultiOwnableCall::AddNftContract => self._add_nft_contract(arguments),
    }
  }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

crate::impl_multi_ownable!(Contract, multi_ownable, MultiOwnableCall, on_call);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
  fn ft_metadata(&self) -> FungibleTokenMetadata {
    self.metadata.get().unwrap()
  }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
  use near_sdk::test_utils::{accounts, VMContextBuilder};
  use near_sdk::{testing_env, Balance};

  use super::*;

  const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

  fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
      .current_account_id(accounts(0))
      .signer_account_id(predecessor_account_id.clone())
      .predecessor_account_id(predecessor_account_id);
    builder
  }

  #[test]
  fn test_new() {
    let mut context = get_context(accounts(1));
    testing_env!(context.build());
    let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into(), 30_000);
    testing_env!(context.is_view(true).build());
    assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
    assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
  }

  #[test]
  #[should_panic(expected = "The contract is not initialized")]
  fn test_default() {
    let context = get_context(accounts(1));
    testing_env!(context.build());
    let _contract = Contract::default();
  }

  #[test]
  fn test_transfer() {
    let mut context = get_context(accounts(2));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into(), 30_000);
    testing_env!(context
      .storage_usage(env::storage_usage())
      .attached_deposit(contract.storage_balance_bounds().min.into())
      .predecessor_account_id(accounts(1))
      .build());
    // Paying for account registration, aka storage deposit
    contract.storage_deposit(None, None);

    testing_env!(context
      .storage_usage(env::storage_usage())
      .attached_deposit(1)
      .predecessor_account_id(accounts(2))
      .build());
    let transfer_amount = TOTAL_SUPPLY / 3;
    contract.ft_transfer(accounts(1), transfer_amount.into(), None);

    testing_env!(context
      .storage_usage(env::storage_usage())
      .account_balance(env::account_balance())
      .is_view(true)
      .attached_deposit(0)
      .build());
    assert_eq!(
      contract.ft_balance_of(accounts(2)).0,
      (TOTAL_SUPPLY - transfer_amount)
    );
    assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
  }
}

'''
'''--- park/src/owner_calls.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MultiOwnableCall {
  #[serde(rename = "update_weights", alias = "update_weights")]
  UpdateWeights,
  #[serde(rename = "set_reward_rate", alias = "set_reward_rate")]
  SetRewardRate,
  #[serde(rename = "add_nft_contract", alias = "add_nft_contract")]
  AddNftContract,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SetRewardRateArgs {
  pub rate: u16,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AddNftContractArgs {
  pub nft_contract: AccountId,
  pub role: stake::NftRole,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct UpdateWeightsArgs {
  pub proposal_id: String,
}

#[near_bindgen]
impl Contract {
  // FIXME: remove mint
  pub fn mint(&mut self, amount: U128) {
    let caller = env::predecessor_account_id();
    self.assert_is_owner();
    self.token.internal_deposit(&caller, amount.into());
  }

  pub(crate) fn _set_reward_rate(&mut self, args: &str) {
    let SetRewardRateArgs { rate } =
      near_sdk::serde_json::from_str(&args).expect("Invalid SetRewardRateArgs");
    assert!(rate <= 1000, "Rate too high");
    self.reward_rate = rate;
  }

  pub(crate) fn _add_nft_contract(&mut self, args: &str) {
    let AddNftContractArgs { nft_contract, role } =
      near_sdk::serde_json::from_str(&args).expect("Invalid AddNftContractArgs");
    self.nfts.insert(&stake::SupportedNft {
      role: role,
      contract_id: nft_contract,
    });
  }

  pub(crate) fn _update_weights(&mut self, args: &str) {
    let UpdateWeightsArgs { proposal_id: _ } =
      near_sdk::serde_json::from_str(&args).expect("Invalid UpdateWeightsArgs");
  }
}

'''
'''--- park/src/proposals.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use near_sdk::{Promise, PromiseResult};
use std::str::FromStr;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
  pub name: String,  // must be unique
  pub lifetime: u16, // in days
  pub metadata: Option<Metadata>,
  pub tasks: Vec<Metadata>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Metadata {
  pub name: String,
  pub budget: Option<U128>,
  pub ft_contract: Option<AccountId>,
  pub note: Option<String>,
  pub url: Option<String>,
  pub contact: Option<String>,
  pub media: Option<String>,
}

#[ext_contract(ext_self)]
trait ExtSelf {
  fn resolve_send_nft(
    &self,
    to: AccountId,
    new_tokens: u128,
    nft_contract: AccountId,
    token_id: String,
  ) -> Promise;
}

#[near_bindgen]
impl Contract {
  pub fn complete_proposal(
    &mut self,
    nft_contract: AccountId,
    token_id: String,
  ) -> PromiseOrValue<U128> {
    let cat_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
    let stake = self.stakes.get(&cat_id).expect("stake not found");
    let prop = stake.proposal.expect("proposal must exist");
    let end_time = stake.time + (self.epoch_millis * prop.lifetime as u64);
    require!(self.now() > end_time, "proposal still active");

    let active_stakes = self.stakes_for_proposal_id(cat_id.clone());
    for s in active_stakes.iter() {
      let cat: Vec<&str> = s.0.split(DELIMETER).collect();
      let staked_nft_contract =
        AccountId::from_str(&cat[0].to_string()).expect("couldnt parse stake id");
      let staked_token_id = cat[1].to_string();
      self._send_nft(s.1.staker_id.clone(), staked_nft_contract, staked_token_id);
    }
    self
      ._send_nft(stake.staker_id.clone(), nft_contract, token_id)
      .into()
  }
  pub fn unstake(&self, nft_contract: AccountId, token_id: String) {
    let cat_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
    let stake = self.stakes.get(&cat_id).expect("no matching stake");
    let caller = env::predecessor_account_id();
    require!(stake.staker_id == caller, "unauthrized to unstake");

    let is_proposal = stake.proposal.is_some();
    if is_proposal {
      let prop = stake.proposal.unwrap();
      let end_time = stake.time + (self.epoch_millis * prop.lifetime as u64);
      require!(self.now() < end_time, "too early to unstake");
    } else {
      let min_time = stake.time + self.epoch_millis;
      require!(self.now() < min_time, "must stake for at least one day");
    }
    self._send_nft(caller, nft_contract, token_id);
  }
  #[private]
  pub(crate) fn _send_nft(
    &self,
    to: AccountId,
    nft_contract: AccountId,
    token_id: String,
  ) -> Promise {
    ext_contract::nft_transfer(
      to.clone(),
      token_id.clone(),
      None,
      None,
      nft_contract.clone(),
      1, // one yocto near required
      Gas(GAS_FOR_NFT_TRANSFER),
    )
    .then(ext_self::resolve_send_nft(
      to,
      1 as u128,
      nft_contract,
      token_id,
      env::current_account_id(),
      0,
      Gas(BASE_GAS),
    ))
  }
  #[private]
  pub fn resolve_send_nft(
    &mut self,
    to: AccountId,
    new_tokens: u128,
    nft_contract: AccountId,
    token_id: String,
  ) -> U128 {
    assert_eq!(env::promise_results_count(), 1, "This is a callback method");

    match env::promise_result(0) {
      PromiseResult::NotReady => unreachable!(),
      PromiseResult::Failed => env::panic_str("Unable to return token"),
      PromiseResult::Successful(_) => (),
    };
    let cat_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
    self.remove_and_reward_stake(cat_id, to, new_tokens);
    U128(new_tokens)
  }
  #[private]
  pub(crate) fn remove_and_reward_stake(
    &mut self,
    contract_and_token_id: ContractAndTokenId,
    to: AccountId,
    amount: u128,
  ) {
    self
      .stakes
      .remove(&contract_and_token_id)
      .expect("couldnt remove stake");
    self.token.internal_deposit(&to, amount.into());
  }
}

'''
'''--- park/src/stake.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Stake {
  pub staker_id: AccountId,
  pub proposal_id: Option<ContractAndTokenId>, // vote on another stake (proposal)
  pub proposal: Option<proposals::Proposal>, // create a new proposal
  pub time: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SupportedNft {
  pub contract_id: AccountId,
  pub role: NftRole,
}

#[derive(Clone, PartialEq, Eq, PartialOrd)]
pub enum NftAction {
  Stake,
  Create,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum NftRole {
  #[serde(rename = "voter", alias = "voter")]
  Voter,
  #[serde(rename = "creator", alias = "creator")]
  Creator,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftCall {
  pub proposal_id: Option<ContractAndTokenId>, // the proposal to vote on
  pub proposal: Option<proposals::Proposal>, // a new proposal
}

#[near_bindgen]
impl NonFungibleTokenReceiver for Contract {
  // stake
  fn nft_on_transfer(
    &mut self,
    sender_id: AccountId,
    previous_owner_id: AccountId,
    token_id: TokenId,
    msg: String,
  ) -> PromiseOrValue<bool> {
    let nft_contract = env::predecessor_account_id();
    let caller = previous_owner_id;
    let call: NftCall = near_sdk::serde_json::from_str(&msg).expect("invalid StakeCall");
    let proposal = call.proposal;
    let proposal_id = call.proposal_id;
    let contract_and_token_id = format!("{}{}{}", nft_contract, DELIMETER, token_id);
    let action = if proposal.is_some() {
      let stake = self.stakes.get(&contract_and_token_id);
      require!(stake.is_none(), "already a proposal by that id");
      let existing = self.proposal_by_name(proposal.clone().unwrap().name);
      require!(existing.is_none(), "already a proposal with that name");
      NftAction::Create
    } else {
      require!(proposal_id.is_some(), "must include proposal id");
      let stake = self.stakes.get(&proposal_id.clone().unwrap());
      require!(stake.is_some(), "no matching proposal");
      NftAction::Stake
    };
    self.assert_nft_can_act(nft_contract.clone(), action.clone());
    self.stakes.insert(
      &contract_and_token_id.clone(),
      &Stake {
        staker_id: caller,
        proposal_id: proposal_id,
        proposal: proposal,
        time: self.now(),
      },
    );
    PromiseOrValue::Value(false) // return false = success
  }
}

impl SupportedNft {
  pub fn can(&self, action: NftAction) -> bool {
    self.role.acl().contains(&action)
  }
}

impl NftRole {
  pub fn acl(&self) -> Vec<NftAction> {
    match self {
      NftRole::Voter => vec![NftAction::Stake],
      NftRole::Creator => vec![NftAction::Stake, NftAction::Create],
    }
  }
}

#[near_bindgen]
impl Contract {
  #[private]
  pub(crate) fn assert_nft_can_act(
    &self,
    nft_contract: AccountId,
    action: NftAction,
  ) -> SupportedNft {
    let nfts = self.supported_nfts().to_vec();
    let contract = nfts.iter().find(|n| n.contract_id == nft_contract);
    require!(contract.is_some(), "invalid nft contract");
    let nft_contract = contract.unwrap();
    require!(nft_contract.can(action.clone()));
    nft_contract.to_owned()
  }
}

'''
'''--- park/src/views.rs ---
use crate::*;
use std::collections::HashMap;

#[near_bindgen]
impl Contract {
  pub fn proposal_by_name(&self, name: String) -> Option<proposals::Proposal> {
    self
      .stakes
      .iter()
      .filter(|s| s.1.proposal.is_some())
      .map(|s| s.1.proposal.unwrap())
      .find(|p| p.name == name)
  }
  pub fn proposals(&self) -> Vec<proposals::Proposal> {
    self
      .stakes
      .iter()
      .filter(|s| s.1.proposal.is_some())
      .map(|s| s.1.proposal.unwrap())
      .collect()
  }
  pub fn stakes(&self) -> HashMap<ContractAndTokenId, stake::Stake> {
    let mut ret = HashMap::new();
    self.stakes.iter().for_each(|s| {
      ret.insert(s.0, s.1);
    });
    ret
  }
  pub fn stakes_for_proposal_id(
    &self,
    proposal_id: ContractAndTokenId,
  ) -> HashMap<ContractAndTokenId, stake::Stake> {
    let mut ret = HashMap::new();
    self
      .stakes
      .iter()
      .filter(|s| {
        if let Some(pid) = &s.1.proposal_id {
          return &proposal_id == pid;
        }
        false
      })
      .for_each(|s| {
        ret.insert(s.0, s.1);
      });
    ret
  }
  pub fn my_stakes(&self) -> Vec<stake::Stake> {
    let caller = env::predecessor_account_id();
    self
      .stakes
      .iter()
      .map(|s| s.1)
      .filter(|s| s.staker_id == caller)
      .collect()
  }
}

'''
'''--- scripts/add_nft_contract_to_market.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";

async function add_nft_contract() {
  const { market } = await utils.contracts();
  const added = await market.add_nft_contract({
    args: {
      nft_contract: constants.NFT_ID,
    },
  });
  console.log(added);
}
add_nft_contract();

'''
'''--- scripts/add_nft_contract_to_park.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";

async function add_nft_contract() {
  const { park } = await utils.contracts();
  const added = await park.multi_ownable_call({
    args: {
      call_name: "add_nft_contract",
      arguments: JSON.stringify({
        role: "creator",
        nft_contract: constants.NFT_ID,
      }),
    },
  });
  console.log(added);
}
add_nft_contract();

'''
'''--- scripts/all_sales.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

const BID_GAS = Big(45).times(10 ** 19);

async function settle() {
  const { market } = await utils.contracts();
  const sales = await market.get_all_sales();
  console.log(sales);
}
settle();

'''
'''--- scripts/constants.js ---
//
export const ACCOUNT_ID = "evanfeenstra.testnet";
// export const ACCOUNT_ID = "parkdao.testnet";

export const NFT_ID = "nft6.evanfeenstra.testnet";
export const MARKET_ID = "market3.evanfeenstra.testnet";
export const PARK_ID = "park3.evanfeenstra.testnet";

export function config(keyStore) {
  return {
    networkId: "testnet",
    keyStore, // optional if not signing transactions
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
    helperUrl: "https://helper.testnet.near.org",
    explorerUrl: "https://explorer.testnet.near.org",
  };
}

'''
'''--- scripts/index.js ---

'''
'''--- scripts/init_market.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

// 10^12 is one TGas
const BASE_GAS = Big(5).times(10 ** 12);
const GAS_30 = BASE_GAS.times(6);

async function init_market() {
  const { market } = await utils.contracts();
  console.log(market);
  // const r1 = await nft.nft_tokens();
  // console.log(r1);
  const r1 = await market.new({
    args: {
      owner_id: constants.ACCOUNT_ID,
      nft_contract: constants.NFT_ID,
    },
    gas: GAS_30.toFixed(),
  });
  console.log("market new_default_meta", r1);
}
init_market();

'''
'''--- scripts/init_nft.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

// 10^12 is one TGas
const BASE_GAS = Big(5).times(10 ** 12);
const GAS_30 = BASE_GAS.times(6);

async function init_nft() {
  const { nft } = await utils.contracts();
  console.log(nft);
  // const r1 = await nft.nft_tokens();
  // console.log(r1);
  const r1 = await nft.new_default_meta({
    args: { owner_id: constants.ACCOUNT_ID },
    gas: GAS_30.toFixed(),
  });
  console.log("nft new_default_meta", r1);
}
init_nft();

'''
'''--- scripts/init_park.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

// 10^12 is one TGas
const BASE_GAS = Big(5).times(10 ** 12);
const GAS_30 = BASE_GAS.times(6);

async function init_park() {
  const { park } = await utils.contracts();
  console.log(park);
  // const r1 = await nft.nft_tokens();
  // console.log(r1);
  const r1 = await park.new_default_meta({
    args: {
      owner_id: constants.ACCOUNT_ID,
      total_supply: "1000000000000",
      epoch_millis: 60000,
    },
    gas: GAS_30.toFixed(),
  });
  console.log("park new_default_meta", r1);
}
init_park();

'''
'''--- scripts/list_on_market.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";
import { NFTS } from "./nfts.js";

const LIST_GAS = Big(45).times(10 ** 19);

async function list(token_id) {
  const { nft } = await utils.contracts();
  const extra = parseInt(token_id);
  const args = {
    price: 10 + extra * 2,
    exp: 0, // Date.now() + 10000, // in 10 seconds
  };
  const listed = await nft.nft_approve({
    amount: LIST_GAS.toFixed(),
    args: {
      token_id,
      account_id: constants.MARKET_ID, // approve for the market
      msg: JSON.stringify(args),
    },
  });
  console.log(listed);
}

for (let i = 0; i < NFTS.length; i++) {
  const nft = NFTS[i];
  await list(nft.id);
}

'''
'''--- scripts/mint_nft.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";
import { NFTS } from "./nfts.js";

// 10000000000000000000000
const MINT_GAS = Big(1).times(10 ** 22);

async function mint(token_id, media) {
  if (!token_id || !media) return console.log("MISSING A PARAM");
  const { nft } = await utils.contracts();

  // let token_id = "1";
  const minted = await nft.nft_mint({
    amount: MINT_GAS.toFixed(),
    args: {
      token_id,
      receiver_id: constants.ACCOUNT_ID,
      token_metadata: {
        title: "Tile #" + token_id,
        description: "Park DAO Tile",
        copies: 1,
        media: media,
      },
    },
  });
  console.log(minted);
}

for (let i = 0; i < NFTS.length; i++) {
  const nft = NFTS[i];
  await mint(nft.id, nft.url);
}

'''
'''--- scripts/mint_park.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

// 10000000000000000000000000
const MINT_GAS = Big(1).times(10 ** 22);

async function mint() {
  const { park } = await utils.contracts();

  const minted = await park.mint({
    // amount: MINT_GAS.toFixed(),
    args: {
      amount: "100000000000000000000000000",
    },
  });
  console.log(minted);
}
mint();

'''
'''--- scripts/nft_tokens.js ---
import * as utils from "./utils.js";

async function list() {
  const { nft } = await utils.contracts();
  const tokens = await nft.nft_tokens();
  console.log(tokens);
}
list();

'''
'''--- scripts/nfts.js ---
const NFTS = [
  {
    id: "0",
    url: "https://parkdao.sfo3.digitaloceanspaces.com/testnet/nft3/3qnkCqt81mnKmfBFBwzQYAttNFw7uH7gxCQf5AXTykM9",
  },
  {
    id: "1",
    url: "https://parkdao.sfo3.digitaloceanspaces.com/testnet/nft3/4RoRiphGNE8UvNbVNPh5F46Ro57WAcTkzwvdmRp5ZhDX",
  },
  {
    id: "2",
    url: "https://parkdao.sfo3.digitaloceanspaces.com/testnet/nft3/BdgTW7weoE3AhTRQqo4xpNrv5xunN7gaHRbVMAKKM9bB",
  },
  {
    id: "3",
    url: "https://parkdao.sfo3.digitaloceanspaces.com/testnet/nft3/BMm1tPCE2JAjq7Zw16X5nGuYXMJYXthao3TUghhadS2r",
  },
  {
    id: "4",
    url: "https://parkdao.sfo3.digitaloceanspaces.com/testnet/nft3/4twgHiPNzSPWyJW1rxFWaW7rBbrwmf2UikRJe28PUuGm",
  },
];

export { NFTS };

'''
'''--- scripts/package.json ---
{
  "type": "module",
  "name": "parkdao-scripts",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "big.js": "^6.1.1",
    "near-api-js": "^0.44.2"
  }
}

'''
'''--- scripts/park_supported_nfts.js ---
import * as utils from "./utils.js";

async function supported_nfts() {
  const { park } = await utils.contracts();
  const nfts = await park.supported_nfts();
  console.log(nfts);
}
supported_nfts();

'''
'''--- scripts/settle.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

const SETTLE_GAS = Big(45).times(10 ** 19);

async function settle() {
  const { market } = await utils.contracts();
  let token_id = "0";
  const settled = await market.settle({
    args: {
      nft_contract: constants.NFT_ID,
      token_id,
    },
    deposit: SETTLE_GAS.toFixed(),
  });
  console.log(settled);
}
settle();

'''
'''--- scripts/stakes.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";

async function get_stakes() {
  const { park } = await utils.contracts();
  const stakes = await park.stakes();
  console.log(stakes);
}
get_stakes();

'''
'''--- scripts/transfer.js ---
import * as utils from "./utils.js";
import Big from "big.js";

const TO = "evanfeenstra.testnet";

async function mint() {
  const { nft } = await utils.contracts();

  const trans = await nft.nft_transfer({
    amount: Big(1).toFixed(),
    gas: Big(10)
      .times(10 ** 12)
      .toFixed(),
    args: {
      receiver_id: TO,
      token_id: "0",
    },
  });
  console.log(trans);
}
mint();

'''
'''--- scripts/unstake.js ---
import * as utils from "./utils.js";
import * as constants from "./constants.js";
import Big from "big.js";

async function unstake() {
  const { park } = await utils.contracts();
  let token_id = "4";
  const unstaked = await park.unstake({
    args: {
      nft_contract: constants.NFT_ID,
      token_id,
    },
  });
  console.log(unstaked);
}
unstake();

'''
'''--- scripts/utils.js ---
import * as NEAR from "near-api-js";
import * as OS from "os";
import * as constants from "./constants.js";

export async function contracts() {
  const { near, account } = await connect();
  const accid = account.accountId;
  const nft = nftContract(account, accid);
  const market = marketContract(account, accid);
  const park = parkContract(account, accid);
  return { near, nft, market, park };
}

export function nftContract(account, accountId) {
  const contract = new NEAR.Contract(account, constants.NFT_ID, {
    viewMethods: [
      "nft_token",
      "nft_tokens",
      "nft_supply_for_owner",
      "nft_tokens_for_owner",
      "nft_metadata",
      "nft_is_approved",
      "nft_total_supply",
    ],
    changeMethods: [
      "new",
      "new_default_meta",
      "nft_mint",
      "nft_transfer",
      "nft_transfer_call",
      "nft_approve",
      "nft_revoke",
      "nft_revoke_all",
    ],
    sender: accountId,
  });
  return contract;
}

export function marketContract(account, accountId) {
  return new NEAR.Contract(account, constants.MARKET_ID, {
    viewMethods: [
      "supported_ft_contracts",
      "supported_nft_contracts",
      "get_now",
      "get_supply_sales",
      "get_all_sales",
      "get_sales_by_contract",
      "get_sale",
    ],
    changeMethods: [
      "new",
      "add_nft_contract",
      "add_ft_contract",
      "bid",
      "settle",
    ],
    sender: accountId,
  });
}

export function parkContract(account, accountId) {
  return new NEAR.Contract(account, constants.PARK_ID, {
    viewMethods: [
      "genesis",
      "reward_rate",
      "epoch_of",
      "ft_balance_of",
      "ft_total_supply",
      "supported_nfts",
      "stakes",
      "proposals",
    ],
    changeMethods: [
      "new",
      "new_default_meta",
      "mint",
      "set_reward_rate",
      "reward",
      "ft_transfer",
      "ft_transfer_call",
      "multi_ownable_call",
      "unstake",
    ],
    sender: accountId,
  });
}

export async function connect() {
  const homedir = OS.homedir();
  const credentialsPath = homedir + "/.near-credentials";
  const keyStore = new NEAR.keyStores.UnencryptedFileSystemKeyStore(
    credentialsPath
  );
  const near = await NEAR.connect(constants.config(keyStore));
  const account = await near.account(constants.ACCOUNT_ID);
  return { near, account };
}

'''
'''--- scripts/view.js ---
import * as utils from "./utils.js";

async function view() {
  const { nft } = await utils.contracts();

  const nft_tokens = await nft.nft_tokens({
    args: {
      from_index: "0",
      limit: "1000",
    },
  });
  console.log("nft_tokens", nft_tokens);
}
view();

'''
'''--- tests/sim/main.rs ---
// mod test_approval;
// mod test_core;
// mod test_enumeration;
// mod test_market;
// mod utils;

'''
'''--- tests/sim/test_approval.rs ---
use crate::utils::{init, TOKEN_ID};
use near_contract_standards::non_fungible_token::Token;
use near_sdk_sim::{call, view};
use std::collections::HashMap;

#[test]
fn simulate_simple_approve() {
    let (root, nft, alice, _, market) = init();

    // root approves alice
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
        deposit = 170000000000000000000
    )
    .assert_success();

    // check nft_is_approved, don't provide approval_id
    let alice_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), None)).unwrap_json();
    assert!(alice_approved);

    // check nft_is_approved, with approval_id=1
    let alice_approval_id_is_1: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), Some(1))).unwrap_json();
    assert!(alice_approval_id_is_1);

    // check nft_is_approved, with approval_id=2
    let alice_approval_id_is_2: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), Some(2))).unwrap_json();
    assert!(!alice_approval_id_is_2);

    // alternatively, one could check the data returned by nft_token
    let token: Token = view!(nft.nft_token(TOKEN_ID.into())).unwrap_json();
    let mut expected_approvals = HashMap::new();
    expected_approvals.insert(alice.account_id(), 1);
    assert_eq!(token.approved_account_ids.unwrap(), expected_approvals);

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
        deposit = 1
    )
    .assert_success();

    let alice_approval_id_is_2: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), Some(2))).unwrap_json();
    assert!(alice_approval_id_is_2);

    // approving another account gives different approval_id
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), market.account_id(), None),
        // note that token_receiver's account name is longer, and so takes more bytes to store and
        // therefore requires a larger deposit!
        deposit = 260000000000000000000
    )
    .assert_success();

    let token_receiver_approval_id_is_3: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), market.account_id(), Some(3))).unwrap_json();
    assert!(token_receiver_approval_id_is_3);
}

#[test]
fn simulate_approved_account_transfers_token() {
    let (root, nft, alice, _, _) = init();

    // root approves alice
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
        deposit = 170000000000000000000
    )
    .assert_success();

    // alice sends to self
    call!(
        alice,
        nft.nft_transfer(alice.account_id(), TOKEN_ID.into(), Some(1), None),
        deposit = 1
    )
    .assert_success();

    // token now owned by alice
    let token: Token = view!(nft.nft_token(TOKEN_ID.into())).unwrap_json();
    assert_eq!(token.owner_id, alice.account_id());
}

#[test]
fn simulate_revoke() {
    let (root, nft, alice, _, market) = init();

    // root approves alice
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
        deposit = 170000000000000000000
    )
    .assert_success();

    // root approves token_receiver
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), market.account_id(), None),
        deposit = 260000000000000000000
    )
    .assert_success();

    // root revokes alice
    call!(
        root,
        nft.nft_revoke(TOKEN_ID.into(), alice.account_id()),
        deposit = 1
    )
    .assert_success();

    // alice is revoked...
    let alice_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), None)).unwrap_json();
    assert!(!alice_approved);

    // but token_receiver is still approved
    let token_receiver_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), market.account_id(), None)).unwrap_json();
    assert!(token_receiver_approved);

    // root revokes token_receiver
    call!(
        root,
        nft.nft_revoke(TOKEN_ID.into(), market.account_id()),
        deposit = 1
    )
    .assert_success();

    // alice is still revoked...
    let alice_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), None)).unwrap_json();
    assert!(!alice_approved);

    // ...and now so is token_receiver
    let token_receiver_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), market.account_id(), None)).unwrap_json();
    assert!(!token_receiver_approved);
}

#[test]
fn simulate_revoke_all() {
    let (root, nft, alice, _, market) = init();

    // root approves alice
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), alice.account_id(), None),
        deposit = 170000000000000000000
    )
    .assert_success();

    // root approves token_receiver
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), market.account_id(), None),
        deposit = 260000000000000000000
    )
    .assert_success();

    // root revokes all
    call!(root, nft.nft_revoke_all(TOKEN_ID.into()), deposit = 1).assert_success();

    // alice is revoked...
    let alice_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), alice.account_id(), None)).unwrap_json();
    assert!(!alice_approved);

    // but token_receiver is still approved
    let token_receiver_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), market.account_id(), None)).unwrap_json();
    assert!(!token_receiver_approved);
}

'''
'''--- tests/sim/test_core.rs ---
use crate::utils::{init, TOKEN_ID};
use near_contract_standards::non_fungible_token::Token;
use near_sdk_sim::{call, view};

#[test]
fn simulate_simple_transfer() {
    let (root, nft, alice, _, _) = init();

    let token: Token = view!(nft.nft_token(TOKEN_ID.into())).unwrap_json();
    assert_eq!(token.owner_id, root.account_id());

    call!(
        root,
        nft.nft_transfer(
            alice.account_id(),
            TOKEN_ID.into(),
            None,
            Some("simple transfer".to_string())
        ),
        deposit = 1
    )
    .assert_success();

    let token: Token = view!(nft.nft_token(TOKEN_ID.into())).unwrap_json();
    assert_eq!(token.owner_id, alice.account_id());
}

'''
'''--- tests/sim/test_enumeration.rs ---
use crate::utils::{helper_mint, init};
use near_contract_standards::non_fungible_token::Token;
use near_sdk::json_types::U128;
use near_sdk_sim::{view, ContractAccount, UserAccount};
use non_fungible_token::ContractContract as NftContract;

fn mint_more(root: &UserAccount, nft: &ContractAccount<NftContract>) {
    helper_mint(
        "1".to_string(),
        &root,
        &nft,
        "Black as the Night".to_string(),
        "In charcoal".to_string(),
    );
    helper_mint(
        "2".to_string(),
        &root,
        &nft,
        "Hamakua".to_string(),
        "Vintage recording".to_string(),
    );
    helper_mint(
        "3".to_string(),
        &root,
        &nft,
        "Aloha ke akua".to_string(),
        "Original with piano".to_string(),
    );
}

#[test]
fn simulate_enum_total_supply() {
    let (root, nft, _, _, _) = init();
    mint_more(&root, &nft);

    let total_supply: U128 = view!(nft.nft_total_supply()).unwrap_json();
    assert_eq!(total_supply, U128::from(4));
}

#[test]
fn simulate_enum_nft_tokens() {
    let (root, nft, _, _, _) = init();
    mint_more(&root, &nft);

    // No optional args should return all
    let mut tokens: Vec<Token> = view!(nft.nft_tokens(None, None)).unwrap_json();
    assert_eq!(tokens.len(), 4);
    // Start at "1", with no limit arg
    tokens = view!(nft.nft_tokens(Some(U128::from(1)), None)).unwrap_json();
    assert_eq!(tokens.len(), 3);
    assert_eq!(tokens.get(0).unwrap().token_id, "1".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "2".to_string());
    assert_eq!(tokens.get(2).unwrap().token_id, "3".to_string());

    // Start at "2", with limit 1
    tokens = view!(nft.nft_tokens(Some(U128::from(2)), Some(1u64))).unwrap_json();
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens.get(0).unwrap().token_id, "2".to_string());

    // Don't specify from_index, but limit 2
    tokens = view!(nft.nft_tokens(None, Some(2u64))).unwrap_json();
    assert_eq!(tokens.len(), 2);
    assert_eq!(tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(tokens.get(1).unwrap().token_id, "1".to_string());
}

#[test]
fn simulate_enum_nft_supply_for_owner() {
    let (root, nft, alice, _, _) = init();

    // Get number from account with no NFTs
    let mut owner_num_tokens: U128 =
        view!(nft.nft_supply_for_owner(alice.account_id())).unwrap_json();
    assert_eq!(owner_num_tokens, U128::from(0));

    owner_num_tokens = view!(nft.nft_supply_for_owner(root.account_id())).unwrap_json();
    assert_eq!(owner_num_tokens, U128::from(1));

    mint_more(&root, &nft);

    owner_num_tokens = view!(nft.nft_supply_for_owner(root.account_id())).unwrap_json();
    assert_eq!(owner_num_tokens, U128::from(4));
}

#[test]
fn simulate_enum_nft_tokens_for_owner() {
    let (root, nft, alice, _, _) = init();
    mint_more(&root, &nft);

    // Get tokens from account with no NFTs
    let mut owner_tokens: Vec<Token> =
        view!(nft.nft_tokens_for_owner(alice.account_id(), None, None)).unwrap_json();
    assert_eq!(owner_tokens.len(), 0);

    // Get tokens with no optional args
    owner_tokens = view!(nft.nft_tokens_for_owner(root.account_id(), None, None)).unwrap_json();
    assert_eq!(owner_tokens.len(), 4);

    // With from_index and no limit
    owner_tokens =
        view!(nft.nft_tokens_for_owner(root.account_id(), Some(U128::from(2)), None)).unwrap_json();
    assert_eq!(owner_tokens.len(), 2);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "2".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "3".to_string());

    // With from_index and limit 1
    owner_tokens = view!(nft.nft_tokens_for_owner(root.account_id(), Some(U128::from(1)), Some(1)))
        .unwrap_json();
    assert_eq!(owner_tokens.len(), 1);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "1".to_string());

    // No from_index but limit 3
    owner_tokens = view!(nft.nft_tokens_for_owner(root.account_id(), None, Some(3))).unwrap_json();
    assert_eq!(owner_tokens.len(), 3);
    assert_eq!(owner_tokens.get(0).unwrap().token_id, "0".to_string());
    assert_eq!(owner_tokens.get(1).unwrap().token_id, "1".to_string());
    assert_eq!(owner_tokens.get(2).unwrap().token_id, "2".to_string());
}

'''
'''--- tests/sim/test_market.rs ---
use crate::utils::{init, TOKEN_ID};
// use near_contract_standards::non_fungible_token::Token;
use near_sdk::serde::Serialize;
use near_sdk::{serde_json, AccountId};
use near_sdk_sim::{call, view};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct SaleArgs {
    price: u128,
    exp: u64,
    ft_contract: Option<AccountId>,
}

#[test]
fn simulate_market_listing() {
    let (root, nft, _, _, market) = init();
    // let near_id = AccountId::new_unchecked("near".to_string());
    let a = SaleArgs {
        price: 12,
        exp: 9999999999,
        ft_contract: None,
    };
    let msg = serde_json::to_string(&a).unwrap();
    call!(
        root,
        nft.nft_approve(TOKEN_ID.into(), market.account_id(), Some(msg.to_string())),
        // note that token_receiver's account name is longer, and so takes more bytes to store and
        // therefore requires a larger deposit! each character is one more
        deposit = 180_000_000_000_000_000_000
    )
    .assert_success();

    let alice_approved: bool =
        view!(nft.nft_is_approved(TOKEN_ID.into(), market.account_id(), None)).unwrap_json();
    assert!(alice_approved);
}

'''
'''--- tests/sim/utils.rs ---
use fungible_token::ContractContract as FungibleContract;
use market::MarketContract;
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use non_fungible_token::ContractContract as NftContract;

use near_contract_standards::non_fungible_token::TokenId;
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    NFT_WASM_BYTES => "out/non_fungible_token.wasm",
    FT_WASM_BYTES => "out/fungible_token.wasm",
    MARKET_WASM_BYTES => "out/market.wasm",
}

const NFT_ID: &str = "nft";
const FT_ID: &str = "ft";
const MARKET_ID: &str = "market";

// TODO: how to export String instead of &str? Way too much `into`/`to_string` with &str.
pub const TOKEN_ID: &str = "0";

/// Initialize simulator and return:
/// * root: the root user, set as owner_id for NFT contract, owns a token with ID=1
/// * nft: the NFT contract, callable with `call!` and `view!`
/// * alice: a user account, does not yet own any tokens
pub fn init() -> (
    UserAccount,
    ContractAccount<NftContract>,
    UserAccount,
    ContractAccount<FungibleContract>,
    ContractAccount<MarketContract>,
) {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let nft = deploy!(
        // Contract Proxy
        contract: NftContract,
        // Contract account id
        contract_id: NFT_ID,
        // Bytes of contract
        bytes: &NFT_WASM_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(
            root.account_id()
        )
    );

    call!(
        root,
        nft.nft_mint(
            TOKEN_ID.into(),
            root.account_id(),
            TokenMetadata {
                title: Some("Olympus Mons".into()),
                description: Some("The tallest mountain in the charted solar system".into()),
                media: None,
                media_hash: None,
                copies: Some(1u64),
                issued_at: None,
                expires_at: None,
                starts_at: None,
                updated_at: None,
                extra: None,
                reference: None,
                reference_hash: None,
            }
        ),
        deposit = 7000000000000000000000
    );

    let alice = root.create_user(
        AccountId::new_unchecked("alice".to_string()),
        to_yocto("100"),
    );

    let token_receiver = deploy!(
        contract: FungibleContract,
        contract_id: FT_ID,
        bytes: &FT_WASM_BYTES,
        signer_account: root,
        init_method: new_default_meta(
            root.account_id(),
            U128(1_000_000_000_000_000)
        )
    );

    let approval_receiver = deploy!(
        contract: MarketContract,
        contract_id: MARKET_ID,
        bytes: &MARKET_WASM_BYTES,
        signer_account: root,
        init_method: new(
            root.account_id(),
            nft.account_id()
        )
    );

    (root, nft, alice, token_receiver, approval_receiver)
}

pub fn helper_mint(
    token_id: TokenId,
    root: &UserAccount,
    nft: &ContractAccount<NftContract>,
    title: String,
    desc: String,
) {
    call!(
        root,
        nft.nft_mint(
            token_id,
            root.account_id(),
            TokenMetadata {
                title: Some(title),
                description: Some(desc),
                media: None,
                media_hash: None,
                copies: Some(1u64),
                issued_at: None,
                expires_at: None,
                starts_at: None,
                updated_at: None,
                extra: None,
                reference: None,
                reference_hash: None,
            }
        ),
        deposit = 7000000000000000000000
    );
}

'''
'''--- tests/workspaces/main.rs ---
#![cfg(test)]

// mod test_market;
mod test_park;
mod utils;

'''
'''--- tests/workspaces/test_market.rs ---
use crate::utils::{init_market, init_nft, mint_nft, BASE_GAS};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    serde_json,
    serde_json::{json, Value},
};
use near_units::parse_gas;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::time::{sleep, Duration};
use workspaces::prelude::*;
use workspaces::{Account, Contract, Network, Worker};

const NFT_WASM_FILEPATH: &str = "./out/non_fungible_token.wasm";
const MARKET_WASM_FILEPATH: &str = "./out/market.wasm";

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct SaleArgs {
    price: u128,
    exp: u64,
    ft_contract: Option<String>,
}

#[tokio::test]
async fn test_market() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();

    let root = worker.root_account();

    let alice = worker.dev_create_account().await?;

    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft = worker.dev_deploy(wasm).await?;
    init_nft(&worker, &nft, &root).await?;

    let wasm = std::fs::read(MARKET_WASM_FILEPATH)?;
    let market = worker.dev_deploy(wasm).await?;
    init_market(&worker, &market, &nft, &root).await?;

    let id = "0";
    let from_now = 10_000;
    let exp = millis() + from_now;
    list_sale(id, exp, &worker, &root, &nft, &market).await?;

    bid_and_settle(id, from_now, &worker, &nft, &market, &alice).await?;

    let id1 = "1";
    let exp1 = 0; // not an auction
    list_sale(id1, exp1, &worker, &root, &nft, &market).await?;

    buy(id1, &worker, &nft, &market, &alice).await?;

    Ok(())
}

async fn list_sale(
    token_id: &str,
    exp: u64,
    worker: &Worker<impl Network>,
    root: &Account,
    nft: &Contract,
    market: &Contract,
) -> anyhow::Result<()> {
    mint_nft(token_id, worker, root, nft, root.id().clone()).await?;

    let a = SaleArgs {
        price: 12,
        exp: exp,
        ft_contract: None,
    };
    let msg = serde_json::to_string(&a).unwrap();
    let deposit = 450_000_000_000_000_000_000;
    let res = root
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": market.id(),
            "msg": msg,
        }))?
        .deposit(deposit)
        .gas(parse_gas!("100 Tgas") as u64)
        .transact()
        .await?;
    println!("nft_approve: {:#?}", res.status);

    let contract_and_token: String = res.json()?;
    println!("contract_and_token: {:#?}", contract_and_token);

    let result: Value = worker
        .view(
            nft.id().clone(),
            "nft_is_approved",
            json!({
                "token_id": token_id,
                "approved_account_id": market.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    println!("nft_is_approved: {:#?}", result);

    let supply_sales: String = worker
        .view(market.id().clone(), "get_supply_sales", Vec::new())
        .await?
        .json()?;
    println!("supply sales: {:?}", supply_sales);
    assert_eq!(supply_sales, "1", "should be 1 nft");

    let all_sales: Value = worker
        .view(market.id().clone(), "get_all_sales", Vec::new())
        .await?
        .json()?;
    println!("all_sales: {:?}", all_sales);

    let sale: Value = worker
        .view(
            market.id().clone(),
            "get_sale",
            json!({
                "contract_and_token": contract_and_token,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    println!("sale: {:?}", sale);

    Ok(())
}

async fn bid_and_settle(
    token_id: &str,
    exp_from_now: u64,
    worker: &Worker<impl Network>,
    nft: &Contract,
    market: &Contract,
    alice: &Account,
) -> anyhow::Result<()> {
    let res = alice
        .call(&worker, market.id().clone(), "bid")
        .args_json(json!({
            "nft_contract": nft.id(),
            "token_id": token_id,
        }))?
        .deposit(BASE_GAS.into())
        .transact()
        .await?;
    println!("bid: {:#?}", res);

    let res = alice
        .call(&worker, market.id().clone(), "settle")
        .args_json(json!({
            "nft_contract": nft.id(),
            "token_id": token_id,
        }))?
        .transact()
        .await?;
    println!("settle 1: {:#?}", res);

    let alices_tokens: Value = worker
        .view(
            nft.id().clone(),
            "nft_tokens_for_owner",
            json!({
                "account_id": alice.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    println!("alices_tokens: {:?}", alices_tokens);
    let len1 = alices_tokens.as_array().unwrap().len();

    sleep(Duration::from_millis(exp_from_now)).await;

    let res = alice
        .call(&worker, market.id().clone(), "settle")
        .args_json(json!({
            "nft_contract": nft.id(),
            "token_id": token_id,
        }))?
        .gas(parse_gas!("100 Tgas") as u64)
        .transact()
        .await?;
    println!("settle 2: {:#?}", res);

    let alices_tokens2: Value = worker
        .view(
            nft.id().clone(),
            "nft_tokens_for_owner",
            json!({
                "account_id": alice.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    let len2 = alices_tokens2.as_array().unwrap().len();
    println!("alices_tokens len 2: {:?}", len2);

    assert!(len1 == len2 - 1, "didnt get the token");
    Ok(())
}

async fn buy(
    token_id: &str,
    worker: &Worker<impl Network>,
    nft: &Contract,
    market: &Contract,
    alice: &Account,
) -> anyhow::Result<()> {
    let alices_tokens: Value = worker
        .view(
            nft.id().clone(),
            "nft_tokens_for_owner",
            json!({
                "account_id": alice.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    let len1 = alices_tokens.as_array().unwrap().len();
    println!("alices_tokens len: {:?}", len1);
    // buy it
    // since it "settles", gas is needed
    let res = alice
        .call(&worker, market.id().clone(), "bid")
        .args_json(json!({
            "nft_contract": nft.id(),
            "token_id": token_id,
        }))?
        .deposit(BASE_GAS.into())
        .gas(parse_gas!("100 Tgas") as u64)
        .transact()
        .await?;
    println!("bid: {:#?}", res);

    let alices_tokens2: Value = worker
        .view(
            nft.id().clone(),
            "nft_tokens_for_owner",
            json!({
                "account_id": alice.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    println!("alices_tokens 2: {:?}", alices_tokens2);
    let len2 = alices_tokens2.as_array().unwrap().len();

    assert!(len1 == len2 - 1, "didnt get the token");

    // alice.view_account()

    Ok(())
}

fn millis() -> u64 {
    let start = SystemTime::now();
    let since_the_epoch = start
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    since_the_epoch.as_millis() as u64
}

'''
'''--- tests/workspaces/test_park.rs ---
use crate::utils::{init_nft, init_park, mint_nft};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    serde_json,
    serde_json::{json, Value},
};
use near_units::parse_gas;
use std::collections::HashMap;
use workspaces::prelude::*;
use workspaces::{Account, AccountId, Contract, Network, Worker};
// use std::time::{SystemTime, UNIX_EPOCH};
// use tokio::time::{sleep, Duration};

const NFT_WASM_FILEPATH: &str = "./out/non_fungible_token.wasm";
const PARK_WASM_FILEPATH: &str = "./out/park_token.wasm";

#[tokio::test]
async fn test_park() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();

    let root = worker.root_account();

    let alice = worker.dev_create_account().await?;

    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft = worker.dev_deploy(wasm).await?;
    init_nft(&worker, &nft, &alice).await?;

    let token_id = "0";

    // alice mints an NFT
    mint_nft(token_id, &worker, &alice, &nft, alice.id().clone()).await?;

    let token_2 = "1";
    // root mints an NFT
    mint_nft(token_2, &worker, &alice, &nft, root.id().clone()).await?;

    let wasm2 = std::fs::read(PARK_WASM_FILEPATH)?;
    let park = worker.dev_deploy(wasm2).await?;
    let epoch_length = 5_000;
    init_park(&worker, &park, &root, epoch_length).await?;

    // alice needs to "register" to park
    check_and_register_storage(&worker, &park, &alice).await?;

    let add_nft_contract_args = json!({ "nft_contract": nft.id(), "role": "creator" }).to_string();
    multi_ownable_call(
        &worker,
        &park,
        &root,
        "add_nft_contract",
        add_nft_contract_args.as_str(),
    )
    .await?;

    // alice creates proposal
    create_proposal(&worker, &park, &nft, &alice, token_id).await?;
    let nft_count = nft_tokens_for_owner(&worker, &nft, park.id().clone()).await?;
    assert_eq!(nft_count, 1, "wrong number of NFTs");

    now(&worker, &park).await?;

    stakes(&worker, &park).await?;

    proposals(&worker, &park).await?;

    // root votes on proposal
    let prop_id = format!("{}||{}", nft.id(), token_id);
    println!("PROPS ID {:?}", prop_id);
    vote_on_proposal(&worker, &park, &nft, &root, token_2, prop_id.as_str()).await?;
    let nft_count = nft_tokens_for_owner(&worker, &nft, park.id().clone()).await?;
    assert_eq!(nft_count, 2, "wrong number of NFTs");

    stakes(&worker, &park).await?;

    stakes_for_proposal_id(&worker, &park, prop_id.clone()).await?;

    // sleep(Duration::from_millis(epoch_length)).await;

    complete_proposal(&worker, &park, &nft, &alice, token_id).await?;

    stakes_for_proposal_id(&worker, &park, prop_id).await?;

    stakes(&worker, &park).await?;

    let p1 = nft_tokens_for_owner(&worker, &nft, park.id().clone()).await?;
    println!("PARK TOKENS {}", p1);

    let p2 = nft_tokens_for_owner(&worker, &nft, alice.id().clone()).await?;
    println!("ALICE TOKENS {}", p2);

    let p3 = nft_tokens_for_owner(&worker, &nft, root.id().clone()).await?;
    println!("VOTER TOKENS {}", p3);

    let nft_count = nft_tokens_for_owner(&worker, &nft, park.id().clone()).await?;
    assert_eq!(nft_count, 0, "wrong number of NFTs");

    println!("SUCCESS!");
    Ok(())
}

async fn _balance_of(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
) -> anyhow::Result<String> {
    let balance: String = worker
        .view(
            park.id().clone(),
            "ft_balance_of",
            json!({
                "account_id": account.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    Ok(balance)
}

async fn check_and_register_storage(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
) -> anyhow::Result<()> {
    let storage_balance: Value = worker
        .view(
            park.id().clone(),
            "storage_balance_of",
            json!({
                "account_id": account.id(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    println!("storage balance: {:?}", storage_balance);

    if storage_balance.is_null() {
        register_storage(&worker, &park, &account).await?;
    }
    Ok(())
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
struct StorageBalanceBounds {
    min: U128,
    max: U128,
}

async fn register_storage(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
) -> anyhow::Result<()> {
    let storage_prices: StorageBalanceBounds = worker
        .view(
            park.id().clone(),
            "storage_balance_bounds",
            json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;
    // println!("storage_balance_bounds: {:?}", storage_prices);

    let outcome = account
        .call(&worker, park.id().clone(), "storage_deposit")
        .args_json(json!({
            "account_id": account.id(),
            "registration_only": true,
        }))?
        .deposit(storage_prices.min.into())
        .transact()
        .await?;
    println!("storage_deposit: {:#?}", outcome);
    Ok(())
}

pub type ProposalId = String;

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
    pub owner_id: AccountId,
    pub name: String,
    pub lifetime: u16, // in days
    pub metadata: Option<Metadata>,
    pub tasks: Vec<Metadata>,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Metadata {
    pub budget: U128,
    pub ft_contract: Option<AccountId>,
    pub name: Option<String>,
    pub note: Option<String>,
    pub url: Option<String>,
    pub contact: Option<String>,
    pub media: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftCall {
    pub proposal_id: Option<ProposalId>,
    pub proposal: Option<Proposal>,
}

async fn create_proposal(
    worker: &Worker<impl Network>,
    park: &Contract,
    nft: &Contract,
    account: &Account,
    token_id: &str,
) -> anyhow::Result<()> {
    let args: NftCall = NftCall {
        proposal_id: None,
        proposal: Some(Proposal {
            owner_id: account.id().clone(),
            name: "to do a thing".to_string(),
            lifetime: 1,
            metadata: None,
            tasks: Vec::new(),
        }),
    };
    let outcome = account
        .call(&worker, nft.id().clone(), "nft_transfer_call")
        .args_json(json!({
            "receiver_id": park.id(),
            "token_id": token_id,
            "msg": serde_json::to_string(&args).unwrap(),
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("nft_transfer_call: {:#?}", outcome);
    Ok(())
}

async fn vote_on_proposal(
    worker: &Worker<impl Network>,
    park: &Contract,
    nft: &Contract,
    account: &Account,
    token_id: &str,
    proposal_id: &str,
) -> anyhow::Result<()> {
    let args: NftCall = NftCall {
        proposal_id: Some(proposal_id.to_string()),
        proposal: None,
    };
    let outcome = account
        .call(&worker, nft.id().clone(), "nft_transfer_call")
        .args_json(json!({
            "receiver_id": park.id(),
            "token_id": token_id,
            "msg": serde_json::to_string(&args).unwrap(),
        }))?
        .deposit(1)
        .gas(parse_gas!("100 Tgas") as u64)
        .transact()
        .await?;
    println!("nft_transfer_call: {:#?}", outcome);
    Ok(())
}

pub async fn multi_ownable_call(
    worker: &Worker<impl Network>,
    park: &Contract,
    account: &Account,
    call: &str,
    args: &str,
) -> anyhow::Result<()> {
    let outcome = account
        .call(&worker, park.id().clone(), "multi_ownable_call")
        .args_json(json!({ "call_name": call, "arguments": args }))?
        .transact()
        .await?;
    println!("park multi_ownable_call: {:#?}", outcome);
    Ok(())
}

async fn now(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<()> {
    let n: Value = worker
        .view(park.id().clone(), "now", Vec::new())
        .await?
        .json()?;
    println!("now: {:?}", n);

    Ok(())
}

async fn nft_tokens_for_owner(
    worker: &Worker<impl Network>,
    nft: &Contract,
    owner: AccountId,
) -> anyhow::Result<usize> {
    let n: Vec<Value> = worker
        .view(
            nft.id().clone(),
            "nft_tokens_for_owner",
            json!({ "account_id": owner }).to_string().into_bytes(),
        )
        .await?
        .json()?;
    // println!("nft_tokens_for_owner: {:?}", n);
    Ok(n.len())
}

async fn stakes(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<()> {
    let ss: HashMap<String, Value> = worker
        .view(park.id().clone(), "stakes", Vec::new())
        .await?
        .json()?;
    println!("stakes: {:?}", ss);

    Ok(())
}

async fn proposals(worker: &Worker<impl Network>, park: &Contract) -> anyhow::Result<()> {
    let props: Vec<Value> = worker
        .view(park.id().clone(), "proposals", Vec::new())
        .await?
        .json()?;
    println!("proposals: {:?}", props);

    Ok(())
}

async fn stakes_for_proposal_id(
    worker: &Worker<impl Network>,
    park: &Contract,
    prop_id: ProposalId,
) -> anyhow::Result<()> {
    let ss: HashMap<String, Value> = worker
        .view(
            park.id().clone(),
            "stakes_for_proposal_id",
            json!({ "proposal_id": prop_id }).to_string().into_bytes(),
        )
        .await?
        .json()?;
    println!("stakes_for_proposal_id: {:?}", ss);

    Ok(())
}

pub async fn complete_proposal(
    worker: &Worker<impl Network>,
    park: &Contract,
    nft: &Contract,
    account: &Account,
    token_id: &str,
) -> anyhow::Result<()> {
    let outcome = account
        .call(&worker, park.id().clone(), "complete_proposal")
        .args_json(json!({ "nft_contract": nft.id(), "token_id": token_id }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    println!("park complete_proposal: {:#?}", outcome);
    Ok(())
}

'''
'''--- tests/workspaces/utils.rs ---
use serde_json::json;
// use workspaces::prelude::*;
use workspaces::{Account, AccountId, Contract, Network, Worker};

pub const BASE_GAS: u64 = 5_000_000_000_000;

pub async fn init_nft(
    worker: &Worker<impl Network>,
    nft: &Contract,
    root: &Account,
) -> anyhow::Result<()> {
    let outcome = nft
        .call(&worker, "new_default_meta")
        .args_json(json!({
            "owner_id": root.id(),
        }))?
        .transact()
        .await?;
    println!("nft new_default_meta: {:#?}", outcome);
    Ok(())
}

pub async fn mint_nft(
    token_id: &str,
    worker: &Worker<impl Network>,
    account: &Account,
    nft: &Contract,
    receiver_id: AccountId,
) -> anyhow::Result<()> {
    let deposit = 10000000000000000000000;
    let res = account
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(json!({
            "token_id": token_id,
            "receiver_id": receiver_id,
            "token_metadata": {
                "title": "Olympus Mons",
                "dscription": "Tallest mountain in charted solar system",
                "copies": 1,
            },
        }))?
        .deposit(deposit)
        .transact()
        .await?;
    println!("nft_mint: {:#?}", res);
    Ok(())
}

pub async fn init_market(
    worker: &Worker<impl Network>,
    market: &Contract,
    nft: &Contract,
    root: &Account,
) -> anyhow::Result<()> {
    let outcome2 = market
        .call(&worker, "new")
        .args_json(json!({
            "owner_id": root.id(),
            "nft_contract": nft.id(),
        }))?
        .transact()
        .await?;

    println!("market new: {:#?}", outcome2);

    Ok(())
}

pub async fn init_park(
    worker: &Worker<impl Network>,
    park: &Contract,
    root: &Account,
    epoch_millis: u64,
) -> anyhow::Result<()> {
    let outcome = root
        .call(&worker, park.id().clone(), "new_default_meta")
        .args_json(json!({
            "owner_id": root.id(),
            "total_supply": "1000000",
            "epoch_millis": epoch_millis
        }))?
        .transact()
        .await?;
    println!("park new_default_meta: {:#?}", outcome);

    Ok(())
}

'''