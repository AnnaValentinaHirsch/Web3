*GitHub Repository "LafMonGen/ChessNEAR"*

'''--- README.md ---
# ChessNEAR
Chess on NEAR blockchain

This is example of turn based game with 2 persons with RUST backend and 2 variants of website (frontend) for it (first variant stored in src/lib.rs web4 interaction as base64 string or you can just copy it from https://1chess.testnet.page). Second variant stored in index.html or just copy it from https://1chess.near.page

Many thanks to https://github.com/niklasf/shakmaty as I use it on the backend for move checking and win conditions.

Build of smartcontract is the same as in this tutorial https://docs.near.org/docs/develop/contracts/rust/intro

Feel free to join https://t.me/chess_testnet_near 

Best regards,
LafMon

'''
'''--- cargo.toml ---
[package]
name = "chess"
version = "0.1.0"
authors = ["@LafMon"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
shakmaty = "0.21.1"
base64 = "0.13.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <svg xmlns="http://www.w3.org/2000/svg" width="475" height="500" viewBox="000 000 475 500">
  <rect width="100%" height="100%" fill="#000" />
  </svg>
  <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.41.0/dist/near-api-js.min.js"></script>

  <script>  
const svg = document.querySelector("svg");
 
// variable for the namespace 
const svgns = "http://www.w3.org/2000/svg"; 

const contract_id = '1chess.testnet';
 
//1 connect to NEAR
const near = new nearApi.Near({
  keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  walletUrl: 'https://wallet.testnet.near.org'
});

//2 connect to the NEAR Wallet
const wallet = new nearApi.WalletConnection(near, 'my-app');

//3 connect to a NEAR smart contract
const contract = new nearApi.Contract(wallet.account(), contract_id, {
  viewMethods: ['get_coords'],
  changeMethods: ['set_move', 'set_enter', 'set_end'] 
});

var wid = wallet.getAccountId();
var view = "";
var oppo = "";

 
if (!wallet.isSignedIn()) {
  const response = contract.get_coords({
        id: wid
      }).then( 
        function(value) { 
          if ( value[0] == "Board not found!" ) {
            oppo=prompt("Enter opponent NEAR test wallet (*RECOMMENDED*), leave blank for a random one, start with VIEW:<wallet>.testnet for viewing. For any questions https://t.me/chess_testnet_near","");
            if ( oppo.includes("VIEW:") == true ) {
              // alert(oppo);
              cview = oppo.replace("VIEW:", "");
              view = cview;
              wid = view;
            } else { 
              wallet.requestSignIn({
                contractId: contract_id,
                methodNames: ['get_coords', 'set_move', 'set_enter', 'set_end']
              }); 
            }
          }  
        },
        function(error) {
          alert(error); 
        }
  );
} 
 
var mult = 50
var steps = 50 
var zzz = 1;
var x_shift = steps;
var y_shift = steps;
var entered = 0;

var clicks = "";

const alphabet = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];

if ( view == "" ) {
  wid = wallet.getAccountId(); 
  const response = contract.get_coords({
        id: wid
      }).then( 
        function(value) {
          // alert(value[0]);
          if ( value[0] == "Board not found!" ) {
            if (wallet.isSignedIn()) {
              oppo=prompt("Enter opponent NEAR wallet, leave blank for a random one, start with VIEW:wallet for viewing","");
              if ( oppo.includes("VIEW:") == true ) {
                // alert(oppo);
                cview = oppo.replace("VIEW:", "");
                view = cview;
                wid = view;
              } else { 
                contract.set_enter({
                  args: { 
                    opponent: oppo 
                  }
                });
              }
              setTimeout(function() {
              }, 1000)
            }
            // }
          }  
        },
        function(error) {
          alert(error); 
        }
  );
} else {
  wid = view;
} 

var objects = {};
var figs = {};

var times = 8;
x = 70;
lv_white = true;
for(var i = 0; i < times; i++){ 
  x = mult * i;
  y = mult;
  lv_abc = document.createElementNS(svgns, "text");
  lv_abc.setAttribute("x", x_shift + x );
  lv_abc.setAttribute("y", y );
  lv_abc.setAttribute("fill", "green");  
  lv_abc.textContent = alphabet[i];  
  svg.appendChild(lv_abc);

  y3 = mult * i;
  x3 = 17;
  lv_abc = document.createElementNS(svgns, "text");
  lv_abc.setAttribute("x", x3 );
  lv_abc.setAttribute("y", 85 + y3 );
  lv_abc.setAttribute("fill", "green");  
  lv_abc.textContent = 8 - i;  
  svg.appendChild(lv_abc);
  
  for(var i2 = 0; i2 < times; i2++){ 
    xid = 8 - i2;
    rect_id = alphabet[i] + xid; 

    objects[rect_id] = document.createElementNS(svgns, "rect"); 
    fx = 30 + x;
    fy = 55 + y*i2;
    objects[rect_id].setAttribute("x", fx );
    objects[rect_id].setAttribute("y", fy );
    if ( lv_white == true ) {
      objects[rect_id].setAttribute("fill", "orange");
      lv_white = false;
    } else { 
      objects[rect_id].setAttribute("fill", "grey");
      lv_white = true;
    }
    objects[rect_id].setAttribute("width", mult);
    objects[rect_id].setAttribute("height", mult);
    objects[rect_id].setAttribute("name", rect_id);

    objects[rect_id].addEventListener("click", rect_click);  
    svg.appendChild(objects[rect_id]);

    figs[rect_id] = document.createElementNS(svgns, "text");
    fx = parseInt(fx) + x_shift / 2 - 9;
    fy = parseInt(fy) + y_shift / 2 + 9;  
    figs[rect_id].setAttribute("x", fx );
    figs[rect_id].setAttribute("y", fy );  
    figs[rect_id].setAttribute("font-size", "xx-large" );  
    figs[rect_id].textContent = "";
    figs[rect_id].setAttribute("name", rect_id); 
    figs[rect_id].setAttribute("fill", "transparent");
    figs[rect_id].addEventListener("click", rect_click); 
    svg.appendChild(figs[rect_id]);

  }
  if ( lv_white == true ) { 
    lv_white = false;
  } else {  
    lv_white = true;
  }
}

 
var pawns = {};
var pawns1 = {};
var pawns2 = {};

for(var pw = 0; pw < 16; pw++){
  pawns[pw] = document.createElementNS(svgns, "rect");  
  pawns[pw].setAttribute("fill", "transparent"); 
  pawns[pw].setAttribute("width", 28);
  pawns[pw].setAttribute("height", mult/5);
  pawns[pw].setAttribute("rx", 7);
  pawns[pw].addEventListener("click", rect_click); 
  svg.appendChild(pawns[pw]);

  pawns1[pw] = document.createElementNS(svgns, "polygon");   
  pawns1[pw].setAttribute("fill", "transparent"); 
  pawns1[pw].addEventListener("click", rect_click);    
  svg.appendChild(pawns1[pw]); 

  pawns2[pw] = document.createElementNS(svgns, "rect");  
  pawns2[pw].setAttribute("fill", "transparent"); 
  pawns2[pw].setAttribute("width", 10 );
  pawns2[pw].setAttribute("height", 10 );
  pawns2[pw].setAttribute("rx", 20);
  pawns2[pw].addEventListener("click", rect_click);   
  svg.appendChild(pawns2[pw]); 
}
 
var bish = {};
var bish1 = {};
var bish2 = {}; 

var rook = {};
var rook1 = {};
var rook2 = {}; 

var hors = {};
var hors1 = {};
var hors2 = {}; 

for(var pw = 0; pw < 4; pw++){
  bish[pw] = document.createElementNS(svgns, "rect");  
  bish[pw].setAttribute("fill", "transparent"); 
  bish[pw].setAttribute("width", 36);
  bish[pw].setAttribute("height", mult/5);
  bish[pw].setAttribute("rx", 7); 
  bish[pw].addEventListener("click", rect_click);  
  svg.appendChild(bish[pw]);

  bish1[pw] = document.createElementNS(svgns, "rect");  
  bish1[pw].setAttribute("fill", "transparent"); 
  bish1[pw].setAttribute("width", 14 );
  bish1[pw].setAttribute("height", 24 );
  bish1[pw].setAttribute("rx", 20); 
  bish1[pw].addEventListener("click", rect_click);  
  svg.appendChild(bish1[pw]);

  bish2[pw] = document.createElementNS(svgns, "rect");  
  bish2[pw].setAttribute("fill", "transparent"); 
  bish2[pw].setAttribute("width", 10 );
  bish2[pw].setAttribute("height", 10 );
  bish2[pw].setAttribute("rx", 20);  
  bish2[pw].addEventListener("click", rect_click);  
  svg.appendChild(bish2[pw]);

  rook[pw] = document.createElementNS(svgns, "rect");  
  rook[pw].setAttribute("fill", "transparent"); 
  rook[pw].setAttribute("width", 36);
  rook[pw].setAttribute("height", mult/5); 
  rook[pw].addEventListener("click", rect_click);  
  svg.appendChild(rook[pw]);

  rook1[pw] = document.createElementNS(svgns, "rect");  
  rook1[pw].setAttribute("fill", "transparent"); 
  rook1[pw].setAttribute("width", 12 );
  rook1[pw].setAttribute("height", 24 ); 
  rook1[pw].addEventListener("click", rect_click);  
  svg.appendChild(rook1[pw]);

  rook2[pw] = document.createElementNS(svgns, "rect");  
  rook2[pw].setAttribute("fill", "transparent"); 
  rook2[pw].setAttribute("width", 16 );
  rook2[pw].setAttribute("height", 16 ); 
  rook2[pw].addEventListener("click", rect_click);  
  svg.appendChild(rook2[pw]);

  hors[pw] = document.createElementNS(svgns, "rect");  
  hors[pw].setAttribute("fill", "transparent"); 
  hors[pw].setAttribute("width", 36);
  hors[pw].setAttribute("height", mult/5); 
  hors[pw].setAttribute("rx", 5);  
  hors[pw].addEventListener("click", rect_click);  
  svg.appendChild(hors[pw]);

  hors1[pw] = document.createElementNS(svgns, "rect");  
  hors1[pw].setAttribute("fill", "transparent"); 
  hors1[pw].setAttribute("width", 10 );
  hors1[pw].setAttribute("height", 30 );
  hors1[pw].setAttribute("rx", 4);   
  hors1[pw].addEventListener("click", rect_click);  
  svg.appendChild(hors1[pw]);

  hors2[pw] = document.createElementNS(svgns, "polygon");  
  hors2[pw].setAttribute("fill", "transparent"); 
  hors2[pw].addEventListener("click", rect_click);  
  svg.appendChild(hors2[pw]);
}

var quee = {};
var quee1 = {};
var quee2 = {}; 

var king = {};
var king1 = {};
var king2 = {};

for(var pw = 0; pw < 2; pw++){ 
  quee[pw] = document.createElementNS(svgns, "polygon");  
  quee[pw].setAttribute("fill", "transparent"); 
  quee[pw].addEventListener("click", rect_click);  
  svg.appendChild(quee[pw]);

  quee1[pw] = document.createElementNS(svgns, "polygon");  
  quee1[pw].setAttribute("fill", "transparent"); 
  quee1[pw].addEventListener("click", rect_click);  
  svg.appendChild(quee1[pw]);

  quee2[pw] = document.createElementNS(svgns, "polygon");  
  quee2[pw].setAttribute("fill", "transparent"); 
  quee2[pw].addEventListener("click", rect_click);  
  svg.appendChild(quee2[pw]);

  king[pw] = document.createElementNS(svgns, "polygon");  
  king[pw].setAttribute("fill", "transparent"); 
  king[pw].addEventListener("click", rect_click);  
  svg.appendChild(king[pw]);

  king1[pw] = document.createElementNS(svgns, "polygon");  
  king1[pw].setAttribute("fill", "transparent"); 
  king1[pw].addEventListener("click", rect_click);  
  svg.appendChild(king1[pw]);

  king2[pw] = document.createElementNS(svgns, "polygon");  
  king2[pw].setAttribute("fill", "transparent"); 
  king2[pw].addEventListener("click", rect_click);  
  svg.appendChild(king2[pw]);
}

lv_white_wid = document.createElementNS(svgns, "text"); 
lv_white_wid.setAttribute("x", 20 );
lv_white_wid.setAttribute("y", 20 );  
lv_white_wid.setAttribute("fill", "yellow" );  
lv_white_wid.textContent = ""; 
svg.appendChild(lv_white_wid);

lv_b_wid = document.createElementNS(svgns, "text"); 
lv_b_wid.setAttribute("x", 20 );
lv_b_wid.setAttribute("y", 480 );  
lv_b_wid.setAttribute("fill", "yellow" );  
lv_b_wid.textContent = ""; 
svg.appendChild(lv_b_wid);

lv_b_ind = document.createElementNS(svgns, "text"); 
lv_b_ind.setAttribute("x", 370 );
lv_b_ind.setAttribute("y", 480 );  
lv_b_ind.setAttribute("fill", "lime" );  
lv_b_ind.textContent = ""; 
svg.appendChild(lv_b_ind);

lv_w_ind = document.createElementNS(svgns, "text"); 
lv_w_ind.setAttribute("x", 370 );
lv_w_ind.setAttribute("y", 30 );  
lv_w_ind.setAttribute("fill", "lime" );  
lv_w_ind.textContent = ""; 
svg.appendChild(lv_w_ind);

lv_end = document.createElementNS(svgns, "rect"); 
lv_end.setAttribute("x", 440 );
lv_end.setAttribute("y", 110 ); 
lv_end.setAttribute("width", 22);
lv_end.setAttribute("height", 55);  
lv_end.setAttribute("fill", "red" );
lv_end.setAttribute("rx", 13);  
lv_end.addEventListener("click", end_click);  
svg.appendChild(lv_end);

lv_con = document.createElementNS(svgns, "text"); 
lv_con.setAttribute("x", 30 );
lv_con.setAttribute("y", 455 );  
lv_con.setAttribute("fill", "white" ); 
lv_con.setAttribute("transform", "translate(900 20) rotate(90)");
lv_con.textContent = "conceed"; 
svg.appendChild(lv_con);

lv_st = document.createElementNS(svgns, "text"); 
lv_st.setAttribute("x", 170 );
lv_st.setAttribute("y", 460 );  
lv_st.setAttribute("fill", "orange" ); 
lv_st.setAttribute("font-size", "x-large" ); 
lv_st.setAttribute("transform", "translate(900 20) rotate(90)");
lv_st.textContent = "_GAME PREPARE_"; 
svg.appendChild(lv_st);

var gv_ind = 0;
var gv_fen = 0;
var gv_to = "";
var gv_role = "";

function end_click(evt) {
  var lv_end_cond=prompt("Please type yes to finish the game","yes"); //paper hENDs ^)
  if ( lv_end_cond == "yes") { 
    contract.set_end({
        args: {
        } 
    });
  }
}

var lv_from;
function rect_click(evt) {
  if ( clicks == "") {
    clicks = evt.target.getAttribute("name"); 
    lv_from = objects[clicks]; 

    lv_from.setAttribute("rx", 15);

  } else { 
    to = evt.target.getAttribute("name");
    lv_to = evt.target;

    lv_from_role = figs[clicks].textContent;
    lv_from_upper = lv_from_role.toUpperCase();
    if ( lv_from_role != "" ) {
      lv_to_role = figs[to].textContent;
      if ( lv_to_role == "") {
        if ( lv_from_upper == "P" ) {
          if ( lv_to.getAttribute("x") != lv_from.getAttribute("x") ) {
            lv_to_role = "EnPassant"; //Битое поле
          }
        }
      }

      var lv_promotion = "";
      if ( lv_from_upper == "P" ) {
        if ( to[1] == "8" || to[1] == "1" ) { 
          var name=prompt("Please enter promotion_role (Bishop, kNight, Rook, Officer)","Queen");
          if ( name[0] == "K" ) {
            name[0] = "N";
          } 
          lv_promotion = name[0];
          lv_promotion.toUpperCase();
          lv_from_upper = lv_promotion;
        }
      }

      if ( lv_from_upper == 'K' ) {
        if ( clicks[0] == 'E' ) {
          if ( to[0] == "G" ) {  
            to = "E" + clicks[1];
            clicks = "H" + clicks[1];
            lv_to_role = "Castle"; //Рокировка
          } else if ( to[0] == "C" ) { 
            to = "E" + clicks[1];
            clicks = "A" + clicks[1];
            lv_to_role = "Castle"; //Рокировка
          }
        }
      }

      contract.set_move({
        args: { 
          from: clicks,
          to: to,
          role: lv_from_role,
          capture_role: lv_to_role,
          promotion_role: lv_promotion,
        }
      });

    }
    lv_from.setAttribute("rx", 0); 

    if ( lv_from_upper != "" ) {
      gv_to = clicks+":"+to;
      lv_st.textContent = gv_to+" Wait up to 15 sec!";
      lv_st.setAttribute("fill", "orange");
      gv_role = gv_to+lv_from_upper;
      gv_ind == 0;
    }

    clicks = "";
  }    
 
}
  
(function myLoop(i) {
  setTimeout(function() { 
    //call the get_coords view method
    const response = contract.get_coords({
          id: wid
        }).then( 
          function(value) { 
            for(var ti = 0; ti < 16; ti++){
              pawns[ti].setAttribute("fill", "transparent");  
              pawns1[ti].setAttribute("fill", "transparent");  
              pawns2[ti].setAttribute("fill", "transparent");
              if (ti < 4) {
                bish[ti].setAttribute("fill", "transparent"); 
                bish1[ti].setAttribute("fill", "transparent"); 
                bish2[ti].setAttribute("fill", "transparent"); 
                hors[ti].setAttribute("fill", "transparent"); 
                hors1[ti].setAttribute("fill", "transparent"); 
                hors2[ti].setAttribute("fill", "transparent"); 
                rook[ti].setAttribute("fill", "transparent"); 
                rook1[ti].setAttribute("fill", "transparent"); 
                rook2[ti].setAttribute("fill", "transparent"); 
              }
              if (ti < 2) {
                quee[ti].setAttribute("fill", "transparent"); 
                quee1[ti].setAttribute("fill", "transparent"); 
                quee2[ti].setAttribute("fill", "transparent"); 
                king[ti].setAttribute("fill", "transparent"); 
                king1[ti].setAttribute("fill", "transparent"); 
                king2[ti].setAttribute("fill", "transparent");  
              }
            }

            var pi = 0;
            var bi = 0;
            var ni = 0;
            var ri = 0;
            var ki = 0;
            var qi = 0;

            lv_white_wid.textContent = value[2].toUpperCase();
            lv_b_wid.textContent = value[1].toUpperCase();
            if ( value[1] == wid ) {
              lv_b_wid.textContent = lv_b_wid.textContent + '  _YOUR SIDE_';
            } else if ( value[2] == wid )  {
              lv_white_wid.textContent = lv_white_wid.textContent + '  _YOUR SIDE_';
            } else  {
              lv_white_wid.textContent = lv_white_wid.textContent + '  ___VIEWING___';
              lv_b_wid.textContent = lv_b_wid.textContent + '  ___VIEWING___';
            }

            if ( value[3] == "1" ) {
              lv_b_ind.textContent = "";
              lv_w_ind.textContent = "TURN"; 
            } else if ( value[3] == "0" ) {
              lv_w_ind.textContent = "";
              lv_b_ind.textContent = "TURN"; 
            } else if ( value[3] == "3" ) {
              lv_w_ind.textContent = "";
              lv_b_ind.textContent = "WINNER"; 
            } else if ( value[3] == "2" ) {
              lv_w_ind.textContent = "WINNER";
              lv_b_ind.textContent = ""; 
            } else if ( value[3] == "7" ) {
              lv_w_ind.textContent = "DEUCE";
              lv_b_ind.textContent = "DEUCE"; 
            }

            xx = 0;
            yy = 8;
            tt = 70; 

            lv_fen = value[0];
            if ( lv_fen == "Board not found!" ) {
              lv_fen = "";
            }
            for(var fen_i = 0; fen_i < tt; fen_i++){
              if ( lv_fen[fen_i] == ' ' ) { 
                break;
              } else if ( lv_fen[fen_i] == '/' ) { 
                xx = 0;
                yy--;
                continue;
              } else if ( (/[a-zA-Z]/).test(lv_fen[fen_i]) == true ) { 
                rid = alphabet[xx] + yy; 
                xx++;  

                //Start: New style with figures:
                var temp_o;
                var temp_o1;
                var temp_o2; 
                fx = parseInt(figs[rid].getAttribute("x"));
                fy = parseInt(figs[rid].getAttribute("y"));
                if ( lv_fen[fen_i].toUpperCase() == 'P' ) {
                  temp_o = pawns[pi];
                  temp_o1 = pawns1[pi];
                  temp_o2 = pawns2[pi];
                  // alert(fx);

                  temp_o.setAttribute("x", fx - 4 );
                  temp_o.setAttribute("y", fy ); 
                  // alert(fx);
                  
                  lv_p = (fx+3).toString() + "," + fy.toString() + " " + (fx+10).toString() + "," + (fy-20).toString() + " " + (fx+18).toString() + "," + fy.toString();

                  // alert(lv_p);
                  temp_o1.setAttribute("points", lv_p ); 
                 
                  temp_o2.setAttribute("x", fx + 5 );
                  temp_o2.setAttribute("y", fy - 21); 
 

                  pi++;

                }
                if ( lv_fen[fen_i].toUpperCase() == 'B' ) {
                  temp_o = bish[bi];
                  temp_o1 = bish1[bi];
                  temp_o2 = bish2[bi];  

                  temp_o.setAttribute("x", fx - 8 );
                  temp_o.setAttribute("y", fy );  

                  temp_o1.setAttribute("x", fx + 3  );
                  temp_o1.setAttribute("y", fy - 19 );  

                  temp_o2.setAttribute("x", fx + 5  );
                  temp_o2.setAttribute("y", fy - 28 );  

                  bi++; 
                }
                if ( lv_fen[fen_i].toUpperCase() == 'R' ) {
                  temp_o  =  rook[ri];
                  temp_o1 = rook1[ri];
                  temp_o2 = rook2[ri];  

                  temp_o.setAttribute("x", fx - 8 );
                  temp_o.setAttribute("y", fy );  

                  temp_o1.setAttribute("x", fx + 5  );
                  temp_o1.setAttribute("y", fy - 19 );  

                  temp_o2.setAttribute("x", fx + 3  );
                  temp_o2.setAttribute("y", fy - 26 );  

                  ri++; 
                } 
                if ( lv_fen[fen_i].toUpperCase() == 'N' ) {
                  temp_o  =  hors[ni];
                  temp_o1 = hors1[ni];
                  temp_o2 = hors2[ni];  

                  temp_o.setAttribute("x", fx - 8 );
                  temp_o.setAttribute("y", fy );  

                  temp_o1.setAttribute("x", fx + 6  );
                  temp_o1.setAttribute("y", fy - 24 );  
 
                  lv_p = (fx+1).toString() + "," + (fy-7).toString() + " " + (fx-3).toString() + "," + (fy-16).toString() + " " + (fx+19).toString() + "," + (fy-23).toString(); 
                  temp_o2.setAttribute("points", lv_p ); 
                  ni++; 
                } 
                if ( lv_fen[fen_i].toUpperCase() == 'Q' ) {
                  temp_o  = quee[qi];
                  temp_o1 = quee1[qi];
                  temp_o2 = quee2[qi];  

                  lv_p = (fx+5).toString() + "," + (fy+10).toString() + " " + (fx-2).toString() + "," + (fy-25).toString() + " " + (fx+15).toString() + "," + (fy+10).toString(); 
                  temp_o.setAttribute("points", lv_p );
 
                  lv_p = (fx).toString() + "," + (fy+10).toString() + " " + (fx+10).toString() + "," + (fy-30).toString() + " " + (fx+20).toString() + "," + (fy+10).toString(); 
                  temp_o1.setAttribute("points", lv_p );

                  lv_p = (fx+5).toString() + "," + (fy+10).toString() + " " + (fx+22).toString() + "," + (fy-25).toString() + " " + (fx+15).toString() + "," + (fy+10).toString(); 
                  temp_o2.setAttribute("points", lv_p );

                  qi++; 
                } 
                if ( lv_fen[fen_i].toUpperCase() == 'K' ) {
                  temp_o  =  king[ki];
                  temp_o1 = king1[ki];
                  temp_o2 = king2[ki];  

                  lv_p = (fx-5).toString() + "," + (fy+10).toString() + " " + (fx-2).toString() + "," + (fy-28).toString() + " " + (fx+20).toString() + "," + (fy+10).toString(); 
                  temp_o.setAttribute("points", lv_p );
 
                  lv_p = (fx).toString() + "," + (fy+10).toString() + " " + (fx+10).toString() + "," + (fy-28).toString() + " " + (fx+20).toString() + "," + (fy+10).toString(); 
                  temp_o1.setAttribute("points", lv_p );

                  lv_p = (fx).toString() + "," + (fy+10).toString() + " " + (fx+22).toString() + "," + (fy-28).toString() + " " + (fx+25).toString() + "," + (fy+10).toString(); 
                  temp_o2.setAttribute("points", lv_p );

                  ki++; 
                } 

                if ( temp_o != undefined ) {
                  if ( lv_fen[fen_i] == lv_fen[fen_i].toUpperCase() ) {
                    col = 'white';
                  } else {
                    col = 'black'; 
                  }
                  // alert(col);
                  temp_o.setAttribute("fill", col);  
                  temp_o1.setAttribute("fill", col);  
                  temp_o2.setAttribute("fill", col);  
                  temp_o.setAttribute( "name", rid);  
                  temp_o1.setAttribute("name", rid);  
                  temp_o2.setAttribute("name", rid);

                }
                //End: New style with figures
 
                figs[rid].textContent = lv_fen[fen_i];
                if ( gv_role[5] == lv_fen[fen_i].toUpperCase() ) { 
                  if ( gv_role[3] == rid[0] ) {
                    if ( gv_role[4] == rid[1] ) {
                      if ( gv_to != "" ) {
                        lv_rid_from = gv_role[0]+gv_role[1];
                        if ( figs[lv_rid_from].textContent == "" ) { 
                          lv_st.textContent = gv_to+" Ok";
                          lv_st.setAttribute("fill", "green"); 
                          gv_to = "";
                        }
                      }
                    }
                  }
                }

              } else { 
                for(var clear_i = 0; clear_i < parseInt(lv_fen[fen_i]); clear_i++){
                  rid = alphabet[xx] + yy;
                  xx++;
                  figs[rid].textContent = "";
                }
              }
            } 

            if ( gv_to != "") {
              if ( gv_ind == 4 ) {
                if ( lv_st.getAttribute("fill") != "green" ) { 
                  lv_st.textContent = gv_to+" Wrong move or turn!";
                  lv_st.setAttribute("fill", "red");
                }
              }
              gv_ind++;
            }

            if ( gv_fen == 0 ) {
              gv_fen = 1;
              lv_st.textContent = "";
            } 
          },
          function(error) {alert(error); }
    );
 

    if (--i) myLoop(i); //  decrement i and call myLoop again if i > 0
  }, 3000) //  timeout in milliseconds (screen refresh)
})(50000); //  pass the number of iterations as an argument

 
</script>
</body>

</html>

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;   
use near_sdk::serde::{Serialize, Deserialize};
extern crate shakmaty; 
extern crate base64; 
use shakmaty::{fen::Fen, fen::Epd, EnPassantMode, CastlingMode, Chess, Position, Square, Move, Role};

near_sdk::setup_alloc!();

#[derive(Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Web4Request {
    #[serde(rename = "accountId")]
    pub account_id: Option<String>,
    pub path: String,
    #[serde(default)]
    pub params: std::collections::HashMap<String, String>,
    #[serde(default)]
    pub query: std::collections::HashMap<String, Vec<String>>,
    pub preloads: Option<std::collections::HashMap<String, Web4Response>>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum Web4Response {
    Body {
        #[serde(rename = "contentType")]
        content_type: String,
        body: near_sdk::json_types::Base64VecU8,
    },
    BodyUrl {
        #[serde(rename = "bodyUrl")]
        body_url: String,
    },
    PreloadUrls {
        #[serde(rename = "preloadUrls")]
        preload_urls: Vec<String>,
    },
}

#[derive(Default, Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TysItem {
    white: String,
    black: String,
    enter_block: u64,
    turn: u8,
    fen: String,
}
 

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct NChess { 
    items: Vec<TysItem>,
}

#[near_bindgen]
impl NChess {
    /// Learn more about web4 here: https://web4.near.page
    pub fn web4_get(&self, request: Web4Request) -> Web4Response {

        if request.path == "/" {
            Web4Response::Body {
                content_type: "text/html; charset=UTF-8".to_owned(),
                body: base64::decode("PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KCjxoZWFkPgogIDxtZXRhIGNoYXJzZXQ9IlVURi04Ij4KICA8bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPWVkZ2UiPgogIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wIj4KICA8dGl0bGU+RG9jdW1lbnQ8L3RpdGxlPgo8L2hlYWQ+Cgo8Ym9keT4KICA8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjQ3NSIgaGVpZ2h0PSI1MDAiIHZpZXdCb3g9IjAwMCAwMDAgNDc1IDUwMCI+CiAgPHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iIzAwMCIgLz4KICA8L3N2Zz4KICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9uZWFyLWFwaS1qc0AwLjQxLjAvZGlzdC9uZWFyLWFwaS1qcy5taW4uanMiPjwvc2NyaXB0PgoKCiAgPHNjcmlwdD4gIApjb25zdCBzdmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCJzdmciKTsKIAovLyB2YXJpYWJsZSBmb3IgdGhlIG5hbWVzcGFjZSAKY29uc3Qgc3ZnbnMgPSAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciOyAKCgpjb25zdCBjb250cmFjdF9pZCA9ICcxY2hlc3MudGVzdG5ldCc7CiAKLy8xIGNvbm5lY3QgdG8gTkVBUgpjb25zdCBuZWFyID0gbmV3IG5lYXJBcGkuTmVhcih7CiAga2V5U3RvcmU6IG5ldyBuZWFyQXBpLmtleVN0b3Jlcy5Ccm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmUoKSwKICBuZXR3b3JrSWQ6ICd0ZXN0bmV0JywKICBub2RlVXJsOiAnaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZycsCiAgd2FsbGV0VXJsOiAnaHR0cHM6Ly93YWxsZXQudGVzdG5ldC5uZWFyLm9yZycKfSk7CgoKLy8yIGNvbm5lY3QgdG8gdGhlIE5FQVIgV2FsbGV0CmNvbnN0IHdhbGxldCA9IG5ldyBuZWFyQXBpLldhbGxldENvbm5lY3Rpb24obmVhciwgJ215LWFwcCcpOwoKLy8zIGNvbm5lY3QgdG8gYSBORUFSIHNtYXJ0IGNvbnRyYWN0CmNvbnN0IGNvbnRyYWN0ID0gbmV3IG5lYXJBcGkuQ29udHJhY3Qod2FsbGV0LmFjY291bnQoKSwgY29udHJhY3RfaWQsIHsKICB2aWV3TWV0aG9kczogWydnZXRfY29vcmRzJ10sCiAgY2hhbmdlTWV0aG9kczogWydzZXRfbW92ZScsICdzZXRfZW50ZXInLCAnc2V0X2VuZCddIAp9KTsKCgp2YXIgd2lkID0gd2FsbGV0LmdldEFjY291bnRJZCgpOwp2YXIgdmlldyA9ICIiOwp2YXIgb3BwbyA9ICIiOwoKIAppZiAoIXdhbGxldC5pc1NpZ25lZEluKCkpIHsKICBjb25zdCByZXNwb25zZSA9IGNvbnRyYWN0LmdldF9jb29yZHMoewogICAgICAgIGlkOiB3aWQKICAgICAgfSkudGhlbiggCiAgICAgICAgZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIC8vIGFsZXJ0KHZhbHVlWzBdKTsKICAgICAgICAgIGlmICggdmFsdWVbMF0gPT0gIkJvYXJkIG5vdCBmb3VuZCEiICkgewogICAgICAgICAgICBvcHBvPXByb21wdCgiRW50ZXIgb3Bwb25lbnQgTkVBUiB3YWxsZXQsIGxlYXZlIGJsYW5rIGZvciBhIHJhbmRvbSBvbmUsIHN0YXJ0IHdpdGggVklFVzp3YWxsZXQgZm9yIHZpZXdpbmciLCIiKTsKICAgICAgICAgICAgaWYgKCBvcHBvLmluY2x1ZGVzKCJWSUVXOiIpID09IHRydWUgKSB7CiAgICAgICAgICAgICAgLy8gYWxlcnQob3Bwbyk7CiAgICAgICAgICAgICAgY3ZpZXcgPSBvcHBvLnJlcGxhY2UoIlZJRVc6IiwgIiIpOwogICAgICAgICAgICAgIHZpZXcgPSBjdmlldzsKICAgICAgICAgICAgICB3aWQgPSB2aWV3OwogICAgICAgICAgICB9IGVsc2UgeyAKICAgICAgICAgICAgICB3YWxsZXQucmVxdWVzdFNpZ25Jbih7CiAgICAgICAgICAgICAgICBjb250cmFjdElkOiBjb250cmFjdF9pZCwKICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzOiBbJ2dldF9jb29yZHMnLCAnc2V0X21vdmUnLCAnc2V0X2VudGVyJywgJ3NldF9lbmQnXQogICAgICAgICAgICAgIH0pOyAKICAgICAgICAgICAgfQogICAgICAgICAgfSAgCiAgICAgICAgfSwKICAgICAgICBmdW5jdGlvbihlcnJvcikgewogICAgICAgICAgYWxlcnQoZXJyb3IpOyAKICAgICAgICB9CiAgKTsKfSAKCiAKLy8gaWYgKCB3YWxsZXQuaXNTaWduZWRJbigpIHx8IHZpZXcgIT0gIiIgKSB7Ci8vICAgLy9ncmVhdAovLyB9IGVsc2UgewovLyAgIHdhbGxldC5yZXF1ZXN0U2lnbkluKHsKLy8gICAgIGNvbnRyYWN0SWQ6IGNvbnRyYWN0X2lkLAovLyAgICAgbWV0aG9kTmFtZXM6IFsnZ2V0X2Nvb3JkcycsICdzZXRfbW92ZScsICdzZXRfZW50ZXInLCAnc2V0X2VuZCddCi8vICAgfSk7Ci8vIH0gIAogCnZhciBtdWx0ID0gNTAKdmFyIHN0ZXBzID0gNTAKLy8gaWYgKCB2aWV3ID09ICIiICkgeyAKLy8gICAgd2lkID0gd2FsbGV0LmdldEFjY291bnRJZCgpOwovLyAgICAgdmFyIGNvbnRyYWN0ID0gbmV3IG5lYXJBcGkuQ29udHJhY3Qod2FsbGV0LmFjY291bnQoKSwgY29udHJhY3RfaWQsIHsKLy8gICAgICAgdmlld01ldGhvZHM6IFsnZ2V0X2Nvb3JkcyddLAovLyAgICAgICBjaGFuZ2VNZXRob2RzOiBbJ3NldF9tb3ZlJywgJ3NldF9lbnRlcicsICdzZXRfZW5kJ10gCi8vICAgICB9KTsgCi8vIH0KdmFyIHp6eiA9IDE7CnZhciB4X3NoaWZ0ID0gc3RlcHM7CnZhciB5X3NoaWZ0ID0gc3RlcHM7CnZhciBlbnRlcmVkID0gMDsKCgp2YXIgY2xpY2tzID0gIiI7Cgpjb25zdCBhbHBoYWJldCA9IFsiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiXTsKCgppZiAoIHZpZXcgPT0gIiIgKSB7CiAgd2lkID0gd2FsbGV0LmdldEFjY291bnRJZCgpOyAKICBjb25zdCByZXNwb25zZSA9IGNvbnRyYWN0LmdldF9jb29yZHMoewogICAgICAgIGlkOiB3aWQKICAgICAgfSkudGhlbiggCiAgICAgICAgZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIC8vIGFsZXJ0KHZhbHVlWzBdKTsKICAgICAgICAgIGlmICggdmFsdWVbMF0gPT0gIkJvYXJkIG5vdCBmb3VuZCEiICkgewogICAgICAgICAgICBpZiAod2FsbGV0LmlzU2lnbmVkSW4oKSkgewogICAgICAgICAgICAgIG9wcG89cHJvbXB0KCJFbnRlciBvcHBvbmVudCBORUFSIHdhbGxldCwgbGVhdmUgYmxhbmsgZm9yIGEgcmFuZG9tIG9uZSwgc3RhcnQgd2l0aCBWSUVXOndhbGxldCBmb3Igdmlld2luZyIsIiIpOwogICAgICAgICAgICAgIGlmICggb3Bwby5pbmNsdWRlcygiVklFVzoiKSA9PSB0cnVlICkgewogICAgICAgICAgICAgICAgLy8gYWxlcnQob3Bwbyk7CiAgICAgICAgICAgICAgICBjdmlldyA9IG9wcG8ucmVwbGFjZSgiVklFVzoiLCAiIik7CiAgICAgICAgICAgICAgICB2aWV3ID0gY3ZpZXc7CiAgICAgICAgICAgICAgICB3aWQgPSB2aWV3OwogICAgICAgICAgICAgIH0gZWxzZSB7IAogICAgICAgICAgICAgICAgY29udHJhY3Quc2V0X2VudGVyKHsKICAgICAgICAgICAgICAgICAgYXJnczogeyAKICAgICAgICAgICAgICAgICAgICBvcHBvbmVudDogb3BwbyAKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgfSwgMTAwMCkKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyB9CiAgICAgICAgICB9ICAKICAgICAgICB9LAogICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7CiAgICAgICAgICBhbGVydChlcnJvcik7IAogICAgICAgIH0KICApOwp9IGVsc2UgewogIHdpZCA9IHZpZXc7Cn0gCgoKdmFyIG9iamVjdHMgPSB7fTsKdmFyIGZpZ3MgPSB7fTsKdmFyIHRpbWVzID0gODsKeCA9IDcwOwpsdl93aGl0ZSA9IHRydWU7CmZvcih2YXIgaSA9IDA7IGkgPCB0aW1lczsgaSsrKXsgCiAgeCA9IG11bHQgKiBpOwogIHkgPSBtdWx0OwogIGx2X2FiYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgInRleHQiKTsKICBsdl9hYmMuc2V0QXR0cmlidXRlKCJ4IiwgeF9zaGlmdCArIHggKTsKICBsdl9hYmMuc2V0QXR0cmlidXRlKCJ5IiwgeSApOwogIGx2X2FiYy5zZXRBdHRyaWJ1dGUoImZpbGwiLCAiZ3JlZW4iKTsgIAogIGx2X2FiYy50ZXh0Q29udGVudCA9IGFscGhhYmV0W2ldOyAgCiAgc3ZnLmFwcGVuZENoaWxkKGx2X2FiYyk7CgogIHkzID0gbXVsdCAqIGk7CiAgeDMgPSAxNzsKICBsdl9hYmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsICJ0ZXh0Iik7CiAgbHZfYWJjLnNldEF0dHJpYnV0ZSgieCIsIHgzICk7CiAgbHZfYWJjLnNldEF0dHJpYnV0ZSgieSIsIDg1ICsgeTMgKTsKICBsdl9hYmMuc2V0QXR0cmlidXRlKCJmaWxsIiwgImdyZWVuIik7ICAKICBsdl9hYmMudGV4dENvbnRlbnQgPSA4IC0gaTsgIAogIHN2Zy5hcHBlbmRDaGlsZChsdl9hYmMpOwogIAogIGZvcih2YXIgaTIgPSAwOyBpMiA8IHRpbWVzOyBpMisrKXsgCiAgICB4aWQgPSA4IC0gaTI7CiAgICByZWN0X2lkID0gYWxwaGFiZXRbaV0gKyB4aWQ7IAoKICAgIG9iamVjdHNbcmVjdF9pZF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsICJyZWN0Iik7IAogICAgZnggPSAzMCArIHg7CiAgICBmeSA9IDU1ICsgeSppMjsKICAgIG9iamVjdHNbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJ4IiwgZnggKTsKICAgIG9iamVjdHNbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJ5IiwgZnkgKTsKICAgIGlmICggbHZfd2hpdGUgPT0gdHJ1ZSApIHsKICAgICAgb2JqZWN0c1tyZWN0X2lkXS5zZXRBdHRyaWJ1dGUoImZpbGwiLCAib3JhbmdlIik7CiAgICAgIGx2X3doaXRlID0gZmFsc2U7CiAgICB9IGVsc2UgeyAKICAgICAgb2JqZWN0c1tyZWN0X2lkXS5zZXRBdHRyaWJ1dGUoImZpbGwiLCAiZ3JleSIpOwogICAgICBsdl93aGl0ZSA9IHRydWU7CiAgICB9CiAgICBvYmplY3RzW3JlY3RfaWRdLnNldEF0dHJpYnV0ZSgid2lkdGgiLCBtdWx0KTsKICAgIG9iamVjdHNbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJoZWlnaHQiLCBtdWx0KTsKICAgIG9iamVjdHNbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJuYW1lIiwgcmVjdF9pZCk7CgogICAgb2JqZWN0c1tyZWN0X2lkXS5hZGRFdmVudExpc3RlbmVyKCJjbGljayIsIHJlY3RfY2xpY2spOyAgCiAgICBzdmcuYXBwZW5kQ2hpbGQob2JqZWN0c1tyZWN0X2lkXSk7CgoKICAgIGZpZ3NbcmVjdF9pZF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsICJ0ZXh0Iik7CiAgICBmeCA9IHBhcnNlSW50KGZ4KSArIHhfc2hpZnQgLyAyIC0gOTsKICAgIGZ5ID0gcGFyc2VJbnQoZnkpICsgeV9zaGlmdCAvIDIgKyA5OyAgCiAgICBmaWdzW3JlY3RfaWRdLnNldEF0dHJpYnV0ZSgieCIsIGZ4ICk7CiAgICBmaWdzW3JlY3RfaWRdLnNldEF0dHJpYnV0ZSgieSIsIGZ5ICk7ICAKICAgIGZpZ3NbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJmb250LXNpemUiLCAieHgtbGFyZ2UiICk7ICAKICAgIGZpZ3NbcmVjdF9pZF0udGV4dENvbnRlbnQgPSAiIjsKICAgIGZpZ3NbcmVjdF9pZF0uc2V0QXR0cmlidXRlKCJuYW1lIiwgcmVjdF9pZCk7IAogICAgZmlnc1tyZWN0X2lkXS5hZGRFdmVudExpc3RlbmVyKCJjbGljayIsIHJlY3RfY2xpY2spOyAKICAgIHN2Zy5hcHBlbmRDaGlsZChmaWdzW3JlY3RfaWRdKTsKCiAgfQogIGlmICggbHZfd2hpdGUgPT0gdHJ1ZSApIHsgCiAgICBsdl93aGl0ZSA9IGZhbHNlOwogIH0gZWxzZSB7ICAKICAgIGx2X3doaXRlID0gdHJ1ZTsKICB9Cn0KCgpsdl93aGl0ZV93aWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsICJ0ZXh0Iik7IApsdl93aGl0ZV93aWQuc2V0QXR0cmlidXRlKCJ4IiwgMjAgKTsKbHZfd2hpdGVfd2lkLnNldEF0dHJpYnV0ZSgieSIsIDIwICk7ICAKbHZfd2hpdGVfd2lkLnNldEF0dHJpYnV0ZSgiZmlsbCIsICJ5ZWxsb3ciICk7ICAKbHZfd2hpdGVfd2lkLnRleHRDb250ZW50ID0gIiI7IApzdmcuYXBwZW5kQ2hpbGQobHZfd2hpdGVfd2lkKTsKCgpsdl9iX3dpZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgInRleHQiKTsgCmx2X2Jfd2lkLnNldEF0dHJpYnV0ZSgieCIsIDIwICk7Cmx2X2Jfd2lkLnNldEF0dHJpYnV0ZSgieSIsIDQ4MCApOyAgCmx2X2Jfd2lkLnNldEF0dHJpYnV0ZSgiZmlsbCIsICJ5ZWxsb3ciICk7ICAKbHZfYl93aWQudGV4dENvbnRlbnQgPSAiIjsgCnN2Zy5hcHBlbmRDaGlsZChsdl9iX3dpZCk7Cgpsdl9iX2luZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgInRleHQiKTsgCmx2X2JfaW5kLnNldEF0dHJpYnV0ZSgieCIsIDQwMCApOwpsdl9iX2luZC5zZXRBdHRyaWJ1dGUoInkiLCA0ODAgKTsgIApsdl9iX2luZC5zZXRBdHRyaWJ1dGUoImZpbGwiLCAibGltZSIgKTsgIApsdl9iX2luZC50ZXh0Q29udGVudCA9ICIiOyAKc3ZnLmFwcGVuZENoaWxkKGx2X2JfaW5kKTsKCgpsdl93X2luZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgInRleHQiKTsgCmx2X3dfaW5kLnNldEF0dHJpYnV0ZSgieCIsIDQwMCApOwpsdl93X2luZC5zZXRBdHRyaWJ1dGUoInkiLCAzMCApOyAgCmx2X3dfaW5kLnNldEF0dHJpYnV0ZSgiZmlsbCIsICJsaW1lIiApOyAgCmx2X3dfaW5kLnRleHRDb250ZW50ID0gIiI7IApzdmcuYXBwZW5kQ2hpbGQobHZfd19pbmQpOwoKCmx2X2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgInJlY3QiKTsgCmx2X2VuZC5zZXRBdHRyaWJ1dGUoIngiLCA0NDAgKTsKbHZfZW5kLnNldEF0dHJpYnV0ZSgieSIsIDIyNSApOyAKbHZfZW5kLnNldEF0dHJpYnV0ZSgid2lkdGgiLCAyMik7Cmx2X2VuZC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIDU1KTsgIApsdl9lbmQuc2V0QXR0cmlidXRlKCJmaWxsIiwgInJlZCIgKTsKbHZfZW5kLnNldEF0dHJpYnV0ZSgicngiLCAxMyk7ICAKbHZfZW5kLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgZW5kX2NsaWNrKTsgIApzdmcuYXBwZW5kQ2hpbGQobHZfZW5kKTsKCmZ1bmN0aW9uIGVuZF9jbGljayhldnQpIHsKICB2YXIgbHZfZW5kX2NvbmQ9cHJvbXB0KCJQbGVhc2UgdHlwZSB5ZXMgdG8gZmluaXNoIHRoZSBnYW1lIiwieWVzIik7IC8vcGFwZXIgaEVORHMgXikKICBpZiAoIGx2X2VuZF9jb25kID09ICJ5ZXMiKSB7IAogICAgY29udHJhY3Quc2V0X2VuZCh7CiAgICAgICAgYXJnczogewogICAgICAgIH0gCiAgICB9KTsKICB9Cn0KCnZhciBsdl9mcm9tOwpmdW5jdGlvbiByZWN0X2NsaWNrKGV2dCkgewogIGlmICggY2xpY2tzID09ICIiKSB7CiAgICBjbGlja3MgPSBldnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgibmFtZSIpOyAKICAgIGx2X2Zyb20gPSBvYmplY3RzW2NsaWNrc107IAoKICAgIGx2X2Zyb20uc2V0QXR0cmlidXRlKCJyeCIsIDE1KTsKCiAgfSBlbHNlIHsgCiAgICB0byA9IGV2dC50YXJnZXQuZ2V0QXR0cmlidXRlKCJuYW1lIik7CiAgICBsdl90byA9IGV2dC50YXJnZXQ7CgogICAgbHZfZnJvbV9yb2xlID0gZmlnc1tjbGlja3NdLnRleHRDb250ZW50OwogICAgbHZfZnJvbV91cHBlciA9IGx2X2Zyb21fcm9sZS50b1VwcGVyQ2FzZSgpOwogICAgaWYgKCBsdl9mcm9tX3JvbGUgIT0gIiIgKSB7CiAgICAgIGx2X3RvX3JvbGUgPSBmaWdzW3RvXS50ZXh0Q29udGVudDsKICAgICAgaWYgKCBsdl90b19yb2xlID09ICIiKSB7CiAgICAgICAgaWYgKCBsdl9mcm9tX3VwcGVyID09ICJQIiApIHsKICAgICAgICAgIGlmICggbHZfdG8uZ2V0QXR0cmlidXRlKCJ4IikgIT0gbHZfZnJvbS5nZXRBdHRyaWJ1dGUoIngiKSApIHsKICAgICAgICAgICAgbHZfdG9fcm9sZSA9ICJFblBhc3NhbnQiOyAvL9CR0LjRgtC+0LUg0L/QvtC70LUKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBsdl9wcm9tb3Rpb24gPSAiIjsKICAgICAgaWYgKCBsdl9mcm9tX3VwcGVyID09ICJQIiApIHsKICAgICAgICBpZiAoIHRvWzFdID09ICI4IiB8fCB0b1sxXSA9PSAiMSIgKSB7IAogICAgICAgICAgdmFyIG5hbWU9cHJvbXB0KCJQbGVhc2UgZW50ZXIgcHJvbW90aW9uX3JvbGUgKEJpc2hvcCwga05pZ2h0LCBSb29rLCBPZmZpY2VyKSIsIlF1ZWVuIik7CiAgICAgICAgICBsdl9wcm9tb3Rpb24gPSBuYW1lWzBdOwogICAgICAgICAgbHZfcHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7CiAgICAgICAgICBpZiAoIGx2X2Zyb21fdXBwZXIgPT0gIksiICkgewogICAgICAgICAgICBsdl9mcm9tX3VwcGVyID0gIk4iOwogICAgICAgICAgfSAKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICggbHZfZnJvbV91cHBlciA9PSAnSycgKSB7CiAgICAgICAgaWYgKCBjbGlja3NbMF0gPT0gJ0UnICkgewogICAgICAgICAgaWYgKCB0b1swXSA9PSAiRyIgKSB7IAogICAgICAgICAgICAvLyBjbGlja3MgPSAiRiIgKyBjbGlja3NbMV07CiAgICAgICAgICAgIHRvID0gIkUiICsgY2xpY2tzWzFdOwogICAgICAgICAgICBjbGlja3MgPSAiSCIgKyBjbGlja3NbMV07CiAgICAgICAgICAgIGx2X3RvX3JvbGUgPSAiQ2FzdGxlIjsgLy/QoNC+0LrQuNGA0L7QstC60LAKICAgICAgICAgIH0gZWxzZSBpZiAoIHRvWzBdID09ICJDIiApIHsKICAgICAgICAgICAgLy8gY2xpY2tzID0gIkQiICsgY2xpY2tzWzFdOwogICAgICAgICAgICB0byA9ICJFIiArIGNsaWNrc1sxXTsKICAgICAgICAgICAgY2xpY2tzID0gIkEiICsgY2xpY2tzWzFdOwogICAgICAgICAgICBsdl90b19yb2xlID0gIkNhc3RsZSI7IC8v0KDQvtC60LjRgNC+0LLQutCwCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBjb250cmFjdC5zZXRfbW92ZSh7CiAgICAgICAgYXJnczogeyAKICAgICAgICAgIGZyb206IGNsaWNrcywKICAgICAgICAgIHRvOiB0bywKICAgICAgICAgIHJvbGU6IGx2X2Zyb21fcm9sZSwKICAgICAgICAgIGNhcHR1cmVfcm9sZTogbHZfdG9fcm9sZSwKICAgICAgICAgIHByb21vdGlvbl9yb2xlOiBsdl9wcm9tb3Rpb24sCiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICAgIGNsaWNrcyA9ICIiOwogICAgbHZfZnJvbS5zZXRBdHRyaWJ1dGUoInJ4IiwgMCk7CiAgfSAgICAKIAp9CiAKCihmdW5jdGlvbiBteUxvb3AoaSkgewogIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAvLyBhbGVydCh3aWQpOwogICAgLy9jYWxsIHRoZSBnZXRfY29vcmRzIHZpZXcgbWV0aG9kCiAgICBjb25zdCByZXNwb25zZSA9IGNvbnRyYWN0LmdldF9jb29yZHMoewogICAgICAgICAgaWQ6IHdpZAogICAgICAgIH0pLnRoZW4oIAogICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHsgCiAgICAgICAgICAgIC8vIGFsZXJ0KHZhbHVlKSAKICAgICAgICAgICAgbHZfd2hpdGVfd2lkLnRleHRDb250ZW50ID0gdmFsdWVbMl07CiAgICAgICAgICAgIGx2X2Jfd2lkLnRleHRDb250ZW50ID0gdmFsdWVbMV07CiAgICAgICAgICAgIGlmICggdmFsdWVbM10gPT0gIjEiICkgewogICAgICAgICAgICAgIGx2X2JfaW5kLnRleHRDb250ZW50ID0gIiI7CiAgICAgICAgICAgICAgbHZfd19pbmQudGV4dENvbnRlbnQgPSAidHVybiI7IAogICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZVszXSA9PSAiMCIgKSB7CiAgICAgICAgICAgICAgbHZfd19pbmQudGV4dENvbnRlbnQgPSAiIjsKICAgICAgICAgICAgICBsdl9iX2luZC50ZXh0Q29udGVudCA9ICJ0dXJuIjsgCiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlWzNdID09ICIzIiApIHsKICAgICAgICAgICAgICBsdl93X2luZC50ZXh0Q29udGVudCA9ICIiOwogICAgICAgICAgICAgIGx2X2JfaW5kLnRleHRDb250ZW50ID0gIldJTk5FUiI7IAogICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZVszXSA9PSAiMiIgKSB7CiAgICAgICAgICAgICAgbHZfd19pbmQudGV4dENvbnRlbnQgPSAiV0lOTkVSIjsKICAgICAgICAgICAgICBsdl9iX2luZC50ZXh0Q29udGVudCA9ICIiOyAKICAgICAgICAgICAgfSBlbHNlIGlmICggdmFsdWVbM10gPT0gIjciICkgewogICAgICAgICAgICAgIGx2X3dfaW5kLnRleHRDb250ZW50ID0gIkRFVUNFIjsKICAgICAgICAgICAgICBsdl9iX2luZC50ZXh0Q29udGVudCA9ICJERVVDRSI7IAogICAgICAgICAgICB9CgogICAgICAgICAgICB4eCA9IDA7CiAgICAgICAgICAgIHl5ID0gODsKICAgICAgICAgICAgdHQgPSA3MDsgCgogICAgICAgICAgICBsdl9mZW4gPSB2YWx1ZVswXTsgCiAgICAgICAgICAgIGZvcih2YXIgZmVuX2kgPSAwOyBmZW5faSA8IHR0OyBmZW5faSsrKXsgCiAgICAgICAgICAgICAgaWYgKCBsdl9mZW5bZmVuX2ldID09ICcgJyApIHsgCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBsdl9mZW5bZmVuX2ldID09ICcvJyApIHsgCiAgICAgICAgICAgICAgICB4eCA9IDA7CiAgICAgICAgICAgICAgICB5eS0tOwogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICggKC9bYS16QS1aXS8pLnRlc3QobHZfZmVuW2Zlbl9pXSkgPT0gdHJ1ZSApIHsgCiAgICAgICAgICAgICAgICByaWQgPSBhbHBoYWJldFt4eF0gKyB5eTsgCiAgICAgICAgICAgICAgICB4eCsrOyAKCiAgICAgICAgICAgICAgICBpZiAobHZfZmVuW2Zlbl9pXSA9PSBsdl9mZW5bZmVuX2ldLnRvVXBwZXJDYXNlKCkpIHsKICAgICAgICAgICAgICAgICAgZmlnc1tyaWRdLnNldEF0dHJpYnV0ZSgiZmlsbCIsICJ3aGl0ZSIpOyAgCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBmaWdzW3JpZF0uc2V0QXR0cmlidXRlKCJmaWxsIiwgImJsYWNrIik7IAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBmaWdzW3JpZF0udGV4dENvbnRlbnQgPSBsdl9mZW5bZmVuX2ldOyAgCiAgICAgICAgICAgICAgfSBlbHNlIHsgCiAgICAgICAgICAgICAgICBmb3IodmFyIGNsZWFyX2kgPSAwOyBjbGVhcl9pIDwgcGFyc2VJbnQobHZfZmVuW2Zlbl9pXSk7IGNsZWFyX2krKyl7CiAgICAgICAgICAgICAgICAgIHJpZCA9IGFscGhhYmV0W3h4XSArIHl5OwogICAgICAgICAgICAgICAgICB4eCsrOwogICAgICAgICAgICAgICAgICBmaWdzW3JpZF0udGV4dENvbnRlbnQgPSAiIjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICBmdW5jdGlvbihlcnJvcikge2FsZXJ0KGVycm9yKTsgfQogICAgKTsKICAgIGlmICgtLWkpIG15TG9vcChpKTsgLy8gIGRlY3JlbWVudCBpIGFuZCBjYWxsIG15TG9vcCBhZ2FpbiBpZiBpID4gMAogIH0sIDMwMDApIC8vICB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcwp9KSg1MDAwMCk7IC8vICBwYXNzIHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBhcyBhbiBhcmd1bWVudAogCjwvc2NyaXB0Pgo8L2JvZHk+Cgo8L2h0bWw+").unwrap().to_owned().into(),
            }
        } else {
            Web4Response::Body {
                content_type: "text/html; charset=UTF-8".to_owned(),
                body: format!("<h1>Some page</h1><pre>{:#?}</pre>", request).into_bytes().into(),
            } 
        }

    }

    pub fn set_enter(&mut self, opponent: String) -> (i8, i8, u64) {
        let acc = near_sdk::env::predecessor_account_id();
        let cblock = near_sdk::env::block_index().clone();
        let mut empty = String::from("@empty@");

        for _item in &self.items {
            if _item.white == acc {
                return (-99, -99, 0);
            } else if _item.black == acc {
                return (-99, -99, 1);
            }
        }

        let mut delete = false;
        for _item in &mut self.items {
            if _item.enter_block < cblock - 100000 {
                delete = true;
            }

            if opponent == "" {
                if _item.black == empty {
                    if _item.white != empty { 
                        _item.black = acc.clone();
                        return (1, 1, 1); 
                    }
                }
            } 

        }

        if delete == true {
            self.items.remove(0);
        } 

        if opponent != "" {
            empty = opponent;
        }

        let new_user = TysItem {
            white: acc,
            black: empty, 
            enter_block: cblock,
            turn: 0,
            fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -".to_string(),
        }; 

        self.items.push(new_user);  

        return (1, 0, 0);

    }

    pub fn set_move(&mut self, from: String, to: String, role:String, capture_role:String, promotion_role:String) -> String {
 

        let acc = near_sdk::env::predecessor_account_id();
        let role_c = role.clone();
        let lv_role = NChess::convert_role(role);
        if lv_role == Role::Knight {
            if role_c != "N" {
                if role_c != "n" {
                    return "No such role".to_string();
                }
            }
        }

        let mut lv_future_turn = 0;
        for _item in &mut self.items {
            if _item.white == acc { 
                if _item.turn == 1 {
                    return "Black turn".to_string();
                }
                lv_future_turn = 1;
            } else if _item.black == acc {
                if _item.turn == 0 { 
                    return "White turn".to_string();
                }
            } else  { 
                continue;
            }
 
            let fen: Fen = _item.fen.parse().unwrap(); 
     
            let pos: Chess = fen.into_position(CastlingMode::Standard).unwrap();

            if capture_role == "".to_string() {
                if promotion_role == "".to_string() { 
                    let pos = pos.play(&Move::Normal {
                        role: lv_role, 
                        from: NChess::convert_square(from), 
                        to: NChess::convert_square(to),
                        capture: None,
                        promotion: None,
                    }).unwrap();

                    if pos.is_checkmate() == true {
                        _item.turn = lv_future_turn + 2;
                    } else if pos.is_stalemate() == true {
                        _item.turn = 7;
                    } else {
                        _item.turn = lv_future_turn;
                    }

                    _item.fen = Epd::from_position(pos, EnPassantMode::Legal).to_string();
                    return _item.fen.clone();
                } else {
                    let pos = pos.play(&Move::Normal {
                        role: lv_role, 
                        from: NChess::convert_square(from), 
                        to: NChess::convert_square(to), 
                        capture: None,
                        promotion: Some(NChess::convert_role(promotion_role)),
                    }).unwrap();

                    if pos.is_checkmate() == true {
                        _item.turn = lv_future_turn + 2;
                    } else if pos.is_stalemate() == true {
                        _item.turn = 7;
                    } else {
                        _item.turn = lv_future_turn;
                    }
 
                    _item.fen = Epd::from_position(pos, EnPassantMode::Legal).to_string();
                    return _item.fen.clone();
                }

            } else {
                if promotion_role == "".to_string() {
 
                    if capture_role == "EnPassant" {
                        let pos = pos.play(&Move::EnPassant { 
                            from: NChess::convert_square(from), 
                            to: NChess::convert_square(to),
                        }).unwrap();

                        if pos.is_checkmate() == true {
                            _item.turn = lv_future_turn + 2;
                        } else if pos.is_stalemate() == true {
                            _item.turn = 7;
                        } else {
                            _item.turn = lv_future_turn;
                        }
 
                        _item.fen = Epd::from_position(pos, EnPassantMode::PseudoLegal).to_string();
                        return _item.fen.clone();

                    } else if capture_role == "Castle" {
                        let pos = pos.play(&Move::Castle { 
                            king: NChess::convert_square(to), 
                            rook: NChess::convert_square(from),
                        }).unwrap();

                        if pos.is_checkmate() == true {
                            _item.turn = lv_future_turn + 2;
                        } else if pos.is_stalemate() == true {
                            _item.turn = 7;
                        } else {
                            _item.turn = lv_future_turn;
                        }
 
                        _item.fen = Epd::from_position(pos, EnPassantMode::Legal).to_string();
                        return _item.fen.clone(); 

                    } else {  
                        let pos = pos.play(&Move::Normal {
                            role: lv_role, 
                            from: NChess::convert_square(from), 
                            to: NChess::convert_square(to),
                            capture: Some(NChess::convert_role(capture_role)), 
                            promotion: None,
                        }).unwrap();

                        if pos.is_checkmate() == true {
                            _item.turn = lv_future_turn + 2;
                        } else if pos.is_stalemate() == true {
                            _item.turn = 7;
                        } else {
                            _item.turn = lv_future_turn;
                        }
 
                        _item.fen = Epd::from_position(pos, EnPassantMode::Legal).to_string();
                        return _item.fen.clone();
                    }

                } else {
                    let pos = pos.play(&Move::Normal {
                        role: lv_role, 
                        from: NChess::convert_square(from), 
                        to: NChess::convert_square(to), 
                        capture: Some(NChess::convert_role(capture_role)),
                        promotion: Some(NChess::convert_role(promotion_role)),
                    }).unwrap();

                    if pos.is_checkmate() == true {
                        _item.turn = lv_future_turn + 2;
                    } else if pos.is_stalemate() == true {
                        _item.turn = 7;
                    } else {
                        _item.turn = lv_future_turn;
                    }
                     
                    _item.fen = Epd::from_position(pos, EnPassantMode::Legal).to_string();
                    return _item.fen.clone();
                }

            }
        }

        return "Not entered".to_string();

    }
         
    pub fn get_coords(&self, id: String) -> (String,String,String,String) {
  
        for _item in &self.items {
           if _item.white == id {
             return ( _item.fen.clone(), _item.white.clone(), _item.black.clone(), _item.turn.clone().to_string() );
           } else if _item.black == id {
             return ( _item.fen.clone(), _item.white.clone(), _item.black.clone(), _item.turn.clone().to_string() );
           }
        } 
        return ( "Board not found!".to_string(), "".to_string(), "".to_string(), "".to_string() );

    }
 

    fn convert_square(id:String) -> Square {
        match id.as_str() {
            "A1" => Square::A1,
            "B1" => Square::B1, 
            "C1" => Square::C1, 
            "D1" => Square::D1, 
            "E1" => Square::E1, 
            "F1" => Square::F1, 
            "G1" => Square::G1, 
            "H1" => Square::H1, 
            "A2" => Square::A2, 
            "B2" => Square::B2, 
            "C2" => Square::C2, 
            "D2" => Square::D2, 
            "E2" => Square::E2, 
            "F2" => Square::F2, 
            "G2" => Square::G2, 
            "H2" => Square::H2,  
            "A3" => Square::A3, 
            "B3" => Square::B3, 
            "C3" => Square::C3, 
            "D3" => Square::D3, 
            "E3" => Square::E3, 
            "F3" => Square::F3, 
            "G3" => Square::G3, 
            "H3" => Square::H3, 
            "A4" => Square::A4, 
            "B4" => Square::B4, 
            "C4" => Square::C4, 
            "D4" => Square::D4, 
            "E4" => Square::E4, 
            "F4" => Square::F4, 
            "G4" => Square::G4, 
            "H4" => Square::H4, 
            "A5" => Square::A5, 
            "B5" => Square::B5, 
            "C5" => Square::C5, 
            "D5" => Square::D5, 
            "E5" => Square::E5, 
            "F5" => Square::F5,
            "G5" => Square::G5, 
            "H5" => Square::H5, 
            "A6" => Square::A6, 
            "B6" => Square::B6, 
            "C6" => Square::C6, 
            "D6" => Square::D6, 
            "E6" => Square::E6, 
            "F6" => Square::F6, 
            "G6" => Square::G6, 
            "H6" => Square::H6, 
            "A7" => Square::A7, 
            "B7" => Square::B7, 
            "C7" => Square::C7, 
            "D7" => Square::D7, 
            "E7" => Square::E7, 
            "F7" => Square::F7, 
            "G7" => Square::G7, 
            "H7" => Square::H7, 
            "A8" => Square::A8, 
            "B8" => Square::B8, 
            "C8" => Square::C8, 
            "D8" => Square::D8, 
            "E8" => Square::E8, 
            "F8" => Square::F8, 
            "G8" => Square::G8, 
            "H8" => Square::H8,
            _ => Square::H8,
        }
    }

    fn convert_role(id:String) -> Role {
        match id.as_str() {
            "P"|"p" => Role::Pawn,
            "N"|"n" => Role::Knight,
            "B"|"b" => Role::Bishop,
            "R"|"r" => Role::Rook,
            "Q"|"q" => Role::Queen,
            "K"|"k" => Role::King,
            _ => Role::Knight,
        }
    }

    pub fn set_end(&mut self) -> String {
        let mut acc = near_sdk::env::predecessor_account_id().clone(); 

        let mut index = 0usize;
        for _item in &self.items {
            if _item.white == acc {
                acc = "".to_string();
                break;
            } else if _item.black == acc {
                acc = "".to_string();
                break;
            }
            index += 1;
        } 

        if acc == "" {
            self.items.remove(index);
            return "GameOver".to_string();
        } 

        return "!Not found!".to_string();

    }

}

'''